---
aliases: [Архитектура обработки ошибок, Обработка ошибок в фронтенде, Error Handling Architecture]
tags: [архитектура, фронтенд, ошибки, обработка-ошибок]
---

# Обработка ошибок в фронтенд-приложениях

## Введение

Обработка ошибок — это критический аспект разработки фронтенд-приложений, который влияет на пользовательский опыт, надежность системы и легкость поддержки кода. В российских реалиях 2025 года, с учетом специфических требований к защите данных и требованиями к локализации, архитектура обработки ошибок должна учитывать как технические, так и правовые аспекты.

## Основные принципы архитектуры обработки ошибок

### 1. Централизованная обработка

Центральный обработчик ошибок позволяет унифицировать логику обработки исключений по всему приложению. В JavaScript/TypeScript приложениях это может быть реализовано с помощью:

- Глобального перехвата ошибок (Global Error Handler)
- Перехвата промисов (Promise Rejection Handler)
- Централизованного middleware для HTTP-запросов

```javascript
// Пример централизованного обработчика ошибок
class ErrorHandler {
  constructor(logger, notifier) {
    this.logger = logger;
    this.notifier = notifier;
    this.setupGlobalHandlers();
  }

  setupGlobalHandlers() {
    window.addEventListener('error', (event) => {
      this.handleGlobalError(event.error);
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.handleUnhandledRejection(event.reason);
    });
  }

  handleGlobalError(error) {
    // Логирование ошибки
    this.logger.error(error);
    
    // Уведомление разработчиков
    this.notifier.notify(error);
    
    // Отображение пользовательского сообщения
    this.showUserFriendlyMessage(error);
  }

  handleUnhandledRejection(reason) {
    console.error('Unhandled promise rejection:', reason);
    this.handleGlobalError(reason);
  }

  showUserFriendlyMessage(error) {
    // Отображение дружелюбного сообщения пользователю
    // без раскрытия внутренних деталей ошибки
    UI.showMessage('Произошла ошибка. Пожалуйста, попробуйте позже.');
  }
}
```

### 2. Классификация ошибок

Для эффективной обработки ошибок необходимо их классифицировать:

- **Клиентские ошибки** (ошибки валидации, логические ошибки в UI)
- **Сетевые ошибки** (ошибки соединения, таймауты, 4xx/5xx ответы)
- **Серверные ошибки** (ошибки бизнес-логики, ошибки инфраструктуры)
- **Системные ошибки** (ошибки памяти, безопасности и т.д.)

```javascript
// Пример классификации ошибок
class AppError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = this.constructor.name;
    this.code = options.code;
    this.severity = options.severity || 'medium'; // low, medium, high
    this.type = options.type || 'application'; // network, validation, business, system
    this.timestamp = new Date().toISOString();
    this.meta = options.meta || {};
  }
}

class NetworkError extends AppError {
  constructor(message, response, options = {}) {
    super(message, { ...options, type: 'network' });
    this.response = response;
    this.status = response?.status;
  }
}

class ValidationError extends AppError {
  constructor(message, field, options = {}) {
    super(message, { ...options, type: 'validation' });
    this.field = field;
  }
}
```

### 3. Безопасность и конфиденциальность

В соответствии с требованиями российского законодательства (ФЗ-152 "О персональных данных") и в свете ужесточения требований к защите данных в 2025 году, при обработке ошибок необходимо учитывать:

- Не сохранять персональные данные в логах ошибок
- Шифровать чувствительные данные при передаче в системы мониторинга
- Обеспечивать анонимизацию ошибок, содержащих персональные данные

```javascript
class SecureErrorHandler {
  sanitizeError(error) {
    const sanitized = { ...error };
    
    // Удаление потенциально чувствительных данных
    delete sanitized.stack; // Не отправлять полный стек вызовов на сервер
    delete sanitized.config?.data; // Не отправлять тело запроса
    
    // Анонимизация данных
    if (sanitized.message) {
      sanitized.message = this.maskSensitiveData(sanitized.message);
    }
    
    return sanitized;
  }
  
  maskSensitiveData(message) {
    // Маскировка потенциально чувствительных данных
    return message
      .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, '****-****-****-****')
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, '[PHONE]');
  }
}
```

## Практические рекомендации

### 1. Обработка асинхронных операций

В современных фронтенд-приложениях асинхронные операции составляют большую часть взаимодействия с сервером. Важно правильно обрабатывать ошибки в промисах и async/await:

```javascript
// Плохо: не обрабатываются ошибки
async function fetchData() {
  const response = await fetch('/api/data');
  return response.json();
}

// Хорошо: ошибка обрабатывается
async function fetchDataSafely() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new NetworkError('Network request failed', response);
    }
    return await response.json();
  } catch (error) {
    ErrorHandler.handleGlobalError(error);
    throw error; // Пробрасываем ошибку для дальнейшей обработки
  }
}
```

### 2. Обработка ошибок в компонентах

В компонентно-ориентированных фреймворках (React, Vue, Angular) важно правильно обрабатывать ошибки на уровне компонентов:

```javascript
// Пример обработки ошибок в React компоненте
function DataComponent() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const result = await api.getData();
        setData(result);
      } catch (err) {
        setError(err);
        ErrorHandler.handleGlobalError(err);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, []);

  if (error) {
    return <ErrorMessage error={error} />;
  }

  if (loading) {
    return <LoadingSpinner />;
  }

  return <DataDisplay data={data} />;
}
```

### 3. Обработка ошибок в роутинге

Ошибки могут возникать при навигации между страницами. Важно обрабатывать их корректно:

```javascript
// Пример обработки ошибок в роутинге (React Router)
function App() {
  return (
    <Router>
      <ErrorBoundary fallback={<ErrorFallback />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </ErrorBoundary>
    </Router>
  );
}
```

## Заключение

Правильная архитектура обработки ошибок в фронтенд-приложениях обеспечивает:

- Улучшенный пользовательский опыт
- Более легкую диагностику и устранение неполадок
- Повышенную безопасность и защиту персональных данных
- Соответствие требованиям законодательства РФ

Для эффективной реализации рекомендуется использовать комбинацию централизованной обработки, надлежащей классификации ошибок и соблюдения требований безопасности.

## См. также

- [[Логирование]]
- [[Мониторинг]]
- [[Восстановление]]
- [[Тестирование]]
- [[Архитектура фронтенд-приложений]]
- [[Безопасность фронтенд-приложений]]