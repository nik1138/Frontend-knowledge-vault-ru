---
aliases: [Система логирования ошибок, Логирование ошибок, Error Logging]
tags: [архитектура, фронтенд, ошибки, логирование, мониторинг]
---

# Логирование ошибок в фронтенд-приложениях

## Введение

Логирование ошибок в фронтенд-приложениях — это критически важный компонент архитектуры, обеспечивающий видимость в работу приложения и позволяющий быстро диагностировать и устранять проблемы. В российских реалиях 2025 года система логирования должна учитывать требования к защите персональных данных и обеспечивать безопасность передачи информации.

## Принципы построения системы логирования

### 1. Централизованное логирование

Система логирования должна собирать все ошибки в одном месте для удобства анализа. Важно обеспечить:

- Единый формат логов
- Возможность фильтрации и поиска
- Безопасность передаваемых данных
- Соответствие требованиям ФЗ-152 "О персональных данных"

```javascript
class Logger {
  constructor(config) {
    this.config = config;
    this.transport = this.initializeTransport(config);
  }

  initializeTransport(config) {
    // Инициализация транспорта логов (HTTP, WebSocket, etc.)
    // Важно: использовать зашифрованное соединение (HTTPS/WSS)
    return new HttpTransport(config.endpoint, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${config.apiKey}`
      }
    });
  }

  log(level, message, meta = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message: this.sanitizeMessage(message),
      meta: this.sanitizeMeta(meta),
      user: this.getUserContext(),
      session: this.getSessionId(),
      appVersion: this.getAppVersion(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    this.transport.send(logEntry);
  }

  sanitizeMessage(message) {
    // Удаление потенциально чувствительной информации из сообщений
    if (typeof message === 'string') {
      return this.maskSensitiveData(message);
    }
    return message;
  }

  sanitizeMeta(meta) {
    // Удаление чувствительных данных из метаданных
    const sanitized = { ...meta };
    
    // Удаление потенциально чувствительных полей
    delete sanitized.stack;
    delete sanitized.password;
    delete sanitized.token;
    delete sanitized.credentials;
    
    return sanitized;
  }

  maskSensitiveData(text) {
    // Маскировка чувствительных данных
    return text
      .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, '****-****-****-****')
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, '[PHONE]');
  }

  getUserContext() {
    // Получение контекста пользователя без раскрытия персональных данных
    return {
      userId: this.getAnonymizedUserId(),
      isLoggedIn: !!this.getAuthToken()
    };
  }

  getAnonymizedUserId() {
    // Возвращаем анонимизированный идентификатор пользователя
    // для обеспечения соответствия требованиям конфиденциальности
    const userId = localStorage.getItem('userId');
    return userId ? this.hashUserId(userId) : null;
  }

  hashUserId(userId) {
    // Хэширование идентификатора пользователя для анонимизации
    // В реальной реализации использовать криптографически стойкие методы
    return btoa(userId).substring(0, 8);
  }
}
```

### 2. Уровни логирования

Рекомендуется использовать следующие уровни логирования ошибок:

- **Error** — критические ошибки, требующие немедленного внимания
- **Warning** — потенциально проблемные ситуации
- **Info** — информационные сообщения о нормальной работе
- **Debug** — отладочная информация (включается при необходимости)

```javascript
class LogLevel {
  static ERROR = 'error';
  static WARNING = 'warning';
  static INFO = 'info';
  static DEBUG = 'debug';
}

// Пример использования уровней логирования
const logger = new Logger(config);

try {
  await someRiskyOperation();
  logger.log(LogLevel.INFO, 'Operation completed successfully');
} catch (error) {
  if (error.isCritical) {
    logger.log(LogLevel.ERROR, 'Critical error occurred', {
      error: error.message,
      stack: error.stack,
      operation: 'someRiskyOperation'
    });
  } else {
    logger.log(LogLevel.WARNING, 'Non-critical error occurred', {
      error: error.message,
      operation: 'someRiskyOperation'
    });
  }
}
```

### 3. Контекст ошибок

Для эффективной диагностики ошибок важно сохранять контекст:

- Идентификатор сессии пользователя
- Текущий URL
- Данные о пользователе (анонимизированные)
- Версия приложения
- Информация о браузере и ОС

```javascript
class ErrorContext {
  constructor() {
    this.sessionId = this.generateSessionId();
    this.pageContext = this.getCurrentPageContext();
  }

  generateSessionId() {
    // Генерация уникального идентификатора сессии
    return Math.random().toString(36).substr(2, 9);
  }

  getCurrentPageContext() {
    return {
      url: window.location.href,
      path: window.location.pathname,
      query: window.location.search,
      referrer: document.referrer,
      title: document.title
    };
  }

  getFullContext() {
    return {
      sessionId: this.sessionId,
      pageContext: this.pageContext,
      device: this.getDeviceInfo(),
      network: this.getNetworkInfo(),
      performance: this.getPerformanceMetrics()
    };
  }

  getDeviceInfo() {
    return {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language,
      cookieEnabled: navigator.cookieEnabled,
      online: navigator.onLine
    };
  }

  getNetworkInfo() {
    return {
      connection: navigator.connection?.effectiveType,
      downlink: navigator.connection?.downlink,
      rtt: navigator.connection?.rtt
    };
  }

  getPerformanceMetrics() {
    const perf = performance.getEntriesByType('navigation')[0];
    return perf ? {
      loadEventEnd: perf.loadEventEnd,
      domContentLoadedEventEnd: perf.domContentLoadedEventEnd,
      responseEnd: perf.responseEnd
    } : {};
  }
}
```

## Практические рекомендации

### 1. Логирование сетевых ошибок

Сетевые ошибки составляют значительную часть проблем в фронтенд-приложениях. Важно логировать:

- Статус HTTP-ответа
- URL запроса (без чувствительных параметров)
- Тип запроса (GET, POST и т.д.)
- Время выполнения запроса
- Сообщение об ошибке

```javascript
class NetworkLogger {
  logRequest(request, response, duration) {
    const logData = {
      type: 'network',
      method: request.method,
      url: this.sanitizeUrl(request.url),
      status: response?.status,
      duration: duration,
      timestamp: new Date().toISOString()
    };

    if (response && !response.ok) {
      logData.error = {
        message: response.statusText,
        status: response.status
      };
    }

    logger.log(LogLevel.INFO, 'Network request completed', logData);
  }

  sanitizeUrl(url) {
    // Удаляем чувствительные параметры из URL
    try {
      const urlObj = new URL(url);
      const sensitiveParams = ['token', 'auth', 'password', 'key'];
      
      sensitiveParams.forEach(param => {
        if (urlObj.searchParams.has(param)) {
          urlObj.searchParams.set(param, '[REDACTED]');
        }
      });
      
      return urlObj.toString();
    } catch (e) {
      // Если URL некорректный, возвращаем оригинальный
      return url;
    }
  }
}
```

### 2. Логирование ошибок в компонентах

В компонентно-ориентированных фреймворках важно логировать ошибки с контекстом компонента:

```javascript
// Пример логирования ошибок в React компоненте
function useErrorLogger(componentName) {
  const logger = useContext(LoggerContext);

  const logComponentError = useCallback((error, context = {}) => {
    logger.log(LogLevel.ERROR, `Error in ${componentName}`, {
      component: componentName,
      error: {
        message: error.message,
        name: error.name
      },
      context: {
        ...context,
        timestamp: new Date().toISOString()
      }
    });
  }, [logger, componentName]);

  return logComponentError;
}

function DataComponent() {
  const logError = useErrorLogger('DataComponent');
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const result = await api.getData();
        setData(result);
      } catch (err) {
        setError(err);
        logError(err, { operation: 'fetchData', userId: getCurrentUserId() });
      }
    }

    fetchData();
  }, []);
}
```

### 3. Агрегация и анализ логов

Для эффективного анализа логов рекомендуется:

- Использовать систему агрегации логов (например, ELK stack, Graylog)
- Настроить алертинг на критические ошибки
- Создать дашборды для мониторинга
- Реализовать автоматическую классификацию ошибок

## Безопасность логирования

В соответствии с требованиями российского законодательства и в целях обеспечения безопасности, при логировании ошибок необходимо:

1. **Не сохранять персональные данные** в открытом виде
2. **Шифровать чувствительные данные** при передаче
3. **Анонимизировать пользовательские данные**
4. **Ограничивать доступ** к системе логирования
5. **Обеспечивать защиту** транспорта логов

```javascript
class SecureLogger extends Logger {
  constructor(config) {
    super(config);
    this.encryptionKey = this.getEncryptionKey();
  }

  getEncryptionKey() {
    // В реальной реализации ключ должен быть получен безопасным способом
    // например, через безопасный API или предварительно настроенный ключ
    return localStorage.getItem('logEncryptionKey');
  }

  async encryptLogEntry(entry) {
    if (!this.encryptionKey) {
      return entry;
    }

    // Шифрование чувствительных данных в логе
    const encryptedEntry = { ...entry };
    
    if (encryptedEntry.meta && encryptedEntry.meta.sensitive) {
      encryptedEntry.meta.encrypted_sensitive = await this.encrypt(
        JSON.stringify(encryptedEntry.meta.sensitive),
        this.encryptionKey
      );
      delete encryptedEntry.meta.sensitive;
    }

    return encryptedEntry;
  }

  async encrypt(data, key) {
    // Реализация шифрования (в реальной системе использовать криптографически стойкие методы)
    // Это упрощенный пример для демонстрации
    return btoa(data);
  }
}
```

## Заключение

Эффективная система логирования ошибок в фронтенд-приложениях должна обеспечивать:

- Полное покрытие всех типов ошибок
- Безопасность и конфиденциальность данных
- Соответствие требованиям законодательства РФ
- Удобство анализа и диагностики
- Интеграцию с системами мониторинга и оповещения

Правильно реализованная система логирования становится основой для построения надежной архитектуры обработки ошибок.

## См. также

- [[Обработка-ошибок]]
- [[Мониторинг]]
- [[Восстановление]]
- [[Тестирование]]
- [[Безопасность фронтенд-приложений]]
- [[Анализ логов]]