---
aliases: [Тестирование обработки ошибок, Тесты ошибок, Error Testing]
tags: [архитектура, фронтенд, ошибки, тестирование, юнит-тесты, интеграционные-тесты]
---

# Тестирование обработки ошибок в фронтенд-приложениях

## Введение

Тестирование обработки ошибок — это критически важная часть разработки фронтенд-приложений, обеспечивающая надежность и стабильность работы системы в условиях непредвиденных ситуаций. В российских реалиях 2025 года, с учетом требований к защите данных и безопасности приложений, тестирование должно покрывать как функциональные аспекты обработки ошибок, так и аспекты безопасности и конфиденциальности.

## Типы тестов для обработки ошибок

### 1. Модульные (юнит) тесты

Модульные тесты проверяют отдельные компоненты системы обработки ошибок:

```javascript
// Пример тестирования обработчика ошибок
import { ErrorHandler } from './ErrorHandler';
import { Logger } from './Logger';
import { Notifier } from './Notifier';

describe('ErrorHandler', () => {
  let errorHandler;
  let mockLogger;
  let mockNotifier;

  beforeEach(() => {
    mockLogger = {
      error: jest.fn(),
      warn: jest.fn(),
      info: jest.fn()
    };

    mockNotifier = {
      notify: jest.fn()
    };

    errorHandler = new ErrorHandler(mockLogger, mockNotifier);
  });

  test('должен корректно обрабатывать ошибки', () => {
    const error = new Error('Тестовая ошибка');
    
    errorHandler.handleGlobalError(error);
    
    expect(mockLogger.error).toHaveBeenCalledWith(error);
    expect(mockNotifier.notify).toHaveBeenCalledWith(error);
  });

  test('должен обрабатывать ошибки с разной критичностью', () => {
    const highSeverityError = new Error('Критическая ошибка');
    highSeverityError.severity = 'high';
    
    errorHandler.handleGlobalError(highSeverityError);
    
    expect(mockNotifier.notify).toHaveBeenCalledWith(highSeverityError);
  });

  test('должен обрабатывать отклоненные промисы', () => {
    const reason = new Error('Причина отклонения');
    
    errorHandler.handleUnhandledRejection(reason);
    
    expect(mockLogger.error).toHaveBeenCalledWith(reason);
  });
});

// Пример тестирования класса ошибок
import { AppError, NetworkError, ValidationError } from './errors';

describe('AppError', () => {
  test('должен создавать ошибку с правильными свойствами', () => {
    const error = new AppError('Сообщение об ошибке', {
      code: 'TEST_ERROR',
      severity: 'high',
      type: 'application'
    });

    expect(error.message).toBe('Сообщение об ошибке');
    expect(error.code).toBe('TEST_ERROR');
    expect(error.severity).toBe('high');
    expect(error.type).toBe('application');
    expect(error.timestamp).toBeDefined();
  });

  test('NetworkError должен содержать информацию о ответе', () => {
    const mockResponse = { status: 500, statusText: 'Internal Server Error' };
    const error = new NetworkError('Сетевая ошибка', mockResponse);

    expect(error.type).toBe('network');
    expect(error.response).toBe(mockResponse);
    expect(error.status).toBe(500);
  });

  test('ValidationError должен содержать информацию о поле', () => {
    const error = new ValidationError('Неверное значение', 'email');

    expect(error.type).toBe('validation');
    expect(error.field).toBe('email');
  });
});
```

### 2. Интеграционные тесты

Интеграционные тесты проверяют взаимодействие компонентов системы обработки ошибок:

```javascript
// Пример интеграционного теста для API сервиса с обработкой ошибок
import { ApiService } from './ApiService';
import { ErrorHandler } from './ErrorHandler';
import { Logger } from './Logger';

describe('ApiService с обработкой ошибок', () => {
  let apiService;
  let errorHandler;
  let logger;

  beforeEach(() => {
    logger = new Logger();
    errorHandler = new ErrorHandler(logger);
    apiService = new ApiService(errorHandler);
    
    // Мокаем fetch
    global.fetch = jest.fn();
  });

  test('должен корректно обрабатывать сетевые ошибки', async () => {
    const mockError = new Error('Network error');
    global.fetch.mockRejectedValue(mockError);
    
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

    await expect(apiService.getData('/api/test')).rejects.toThrow();
    
    expect(consoleSpy).toHaveBeenCalled();
    
    consoleSpy.mockRestore();
  });

  test('должен обрабатывать HTTP ошибки 5xx', async () => {
    global.fetch.mockResolvedValue({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error',
      json: async () => ({ error: 'Server error' })
    });

    await expect(apiService.getData('/api/test')).rejects.toThrow();

    // Проверяем, что ошибка была залогирована
    // Это зависит от реализации логгера
  });

  test('должен обрабатывать HTTP ошибки 4xx', async () => {
    global.fetch.mockResolvedValue({
      ok: false,
      status: 400,
      statusText: 'Bad Request',
      json: async () => ({ error: 'Validation error' })
    });

    await expect(apiService.getData('/api/test')).rejects.toThrow();

    // Проверяем обработку ошибки валидации
  });
});

// Пример тестирования компонента с обработкой ошибок
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { DataComponent } from './DataComponent';
import { ApiClient } from './ApiClient';

describe('DataComponent с обработкой ошибок', () => {
  let mockApiClient;

  beforeEach(() => {
    mockApiClient = {
      fetchData: jest.fn()
    };
  });

  test('должен отображать сообщение об ошибке при неудачной загрузке данных', async () => {
    mockApiClient.fetchData.mockRejectedValue(new Error('Network error'));
    
    render(<DataComponent apiClient={mockApiClient} />);
    
    await waitFor(() => {
      expect(screen.getByText(/ошибка/i)).toBeInTheDocument();
    });
  });

  test('должен повторно пытаться загрузить данные при ошибке', async () => {
    const retryButton = screen.getByText(/попробовать снова/i);
    
    // Симулируем успешную загрузку после повторной попытки
    mockApiClient.fetchData
      .mockRejectedValueOnce(new Error('First attempt failed'))
      .mockResolvedValueOnce({ data: 'test data' });
    
    render(<DataComponent apiClient={mockApiClient} />);
    
    await waitFor(() => {
      expect(screen.getByText(/ошибка/i)).toBeInTheDocument();
    });
    
    retryButton.click();
    
    await waitFor(() => {
      expect(screen.getByText(/test data/i)).toBeInTheDocument();
    });
  });
});
```

### 3. Тесты на основе сценариев использования

Тестирование обработки ошибок в контексте реальных сценариев:

```javascript
// Пример теста сценария "Ошибка при отправке формы"
describe('Сценарий: Ошибка при отправке формы', () => {
  test('должен корректно обрабатывать ошибку валидации на сервере', async () => {
    // Мокаем API для возврата ошибки валидации
    global.fetch.mockResolvedValue({
      ok: false,
      status: 422,
      json: async () => ({
        errors: {
          email: 'Некорректный email',
          password: 'Пароль слишком короткий'
        }
      })
    });

    // Монтируем компонент формы
    render(<RegistrationForm />);
    
    // Заполняем форму некорректными данными
    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByText(/зарегистрироваться/i);
    
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } });
    fireEvent.change(passwordInput, { target: { value: '123' } });
    fireEvent.click(submitButton);
    
    // Проверяем отображение ошибок валидации
    await waitFor(() => {
      expect(screen.getByText(/некорректный email/i)).toBeInTheDocument();
      expect(screen.getByText(/пароль слишком короткий/i)).toBeInTheDocument();
    });
  });

  test('должен корректно обрабатывать сетевые ошибки при отправке', async () => {
    // Мокаем сетевую ошибку
    global.fetch.mockRejectedValue(new TypeError('Network error'));
    
    render(<RegistrationForm />);
    
    // Заполняем форму
    const emailInput = screen.getByLabelText(/email/i);
    const passwordInput = screen.getByLabelText(/password/i);
    const submitButton = screen.getByText(/зарегистрироваться/i);
    
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });
    fireEvent.change(passwordInput, { target: { value: 'password123' } });
    fireEvent.click(submitButton);
    
    // Проверяем отображение сообщения о сетевой ошибке
    await waitFor(() => {
      expect(screen.getByText(/ошибка соединения/i)).toBeInTheDocument();
    });
  });
});

// Пример теста сценария "Восстановление после ошибки"
describe('Сценарий: Восстановление после ошибки', () => {
  test('должен восстанавливаться после временной сетевой ошибки', async () => {
    // Сначала возвращаем ошибку, затем успешный ответ
    global.fetch
      .mockRejectedValueOnce(new TypeError('Network error'))
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: 'success' })
      });
    
    render(<DataComponent />);
    
    // Проверяем, что отображается индикатор загрузки
    expect(screen.getByText(/загрузка/i)).toBeInTheDocument();
    
    // Ждем отображения ошибки
    await waitFor(() => {
      expect(screen.getByText(/ошибка/i)).toBeInTheDocument();
    });
    
    // Имитируем повторную попытку
    const retryButton = screen.getByText(/повторить/i);
    fireEvent.click(retryButton);
    
    // Проверяем успешное восстановление
    await waitFor(() => {
      expect(screen.getByText(/success/i)).toBeInTheDocument();
    });
  });
});
```

## Тестирование безопасности обработки ошибок

### 1. Проверка маскировки чувствительных данных

```javascript
// Тестирование маскировки персональных данных в ошибках
import { SecureErrorHandler } from './SecureErrorHandler';

describe('SecureErrorHandler', () => {
  let secureErrorHandler;
  let mockLogger;

  beforeEach(() => {
    mockLogger = {
      error: jest.fn()
    };
    secureErrorHandler = new SecureErrorHandler(mockLogger);
  });

  test('должен маскировать персональные данные в сообщениях об ошибках', () => {
    const sensitiveMessage = 'Ошибка с данными: john.doe@example.com, 1234-5678-9012-3456';
    const error = new Error(sensitiveMessage);
    
    const sanitized = secureErrorHandler.sanitizeError(error);
    
    expect(sanitized.message).not.toContain('john.doe@example.com');
    expect(sanitized.message).not.toContain('1234-5678-9012-3456');
    expect(sanitized.message).toContain('[EMAIL]');
    expect(sanitized.message).toContain('****-****-****-****');
  });

  test('должен удалять чувствительные поля из метаданных ошибок', () => {
    const errorWithSensitiveData = {
      message: 'Тестовая ошибка',
      stack: 'stack trace',
      config: {
        data: { password: 'secret123', token: 'auth-token' },
        headers: { 'Authorization': 'Bearer token123' }
      }
    };
    
    const sanitized = secureErrorHandler.sanitizeError(errorWithSensitiveData);
    
    expect(sanitized.stack).toBeUndefined();
    expect(sanitized.config.data).toBeUndefined();
    expect(sanitized.config.headers.Authorization).toBeUndefined();
  });
});

// Тестирование анонимизации пользовательских данных
describe('Пользовательская анонимизация в логах', () => {
  test('должен анонимизировать идентификаторы пользователей', () => {
    const logger = new SecureLogger();
    const userId = 'user123';
    
    const anonymizedId = logger.getAnonymizedUserId(userId);
    
    expect(anonymizedId).not.toBe(userId);
    expect(typeof anonymizedId).toBe('string');
    expect(anonymizedId.length).toBeGreaterThan(0);
  });
});
```

### 2. Тестирование утечек информации

```javascript
// Тестирование на утечку информации через обработку ошибок
describe('Тестирование утечки информации', () => {
  test('обработчик ошибок не должен раскрывать внутренние детали системы', async () => {
    const internalError = new Error('Внутренняя ошибка: /path/to/internal/file.js:123');
    internalError.stack = `
      Error: Внутренняя ошибка
          at internalFunction (/path/to/internal/file.js:123:15)
          at processData (/path/to/business/logic.js:45:20)
          at handleRequest (server.js:67:10)
    `;
    
    // Мокаем отправку ошибки в систему мониторинга
    const sendErrorSpy = jest.spyOn(ErrorHandler.prototype, 'sendErrorReport');
    
    const errorHandler = new ErrorHandler();
    errorHandler.handleError(internalError);
    
    const calledWith = sendErrorSpy.mock.calls[0][0];
    
    // Проверяем, что внутренние пути не передаются
    expect(calledWith.error.message).not.toContain('/path/to/internal/file.js');
    expect(calledWith.error.stack).toBeUndefined();
    
    sendErrorSpy.mockRestore();
  });

  test('не должен передавать чувствительные параметры в URL ошибок', () => {
    const urlWithSensitiveParams = 'https://api.example.com/data?token=secret&key=private';
    const error = new Error(`Ошибка при запросе: ${urlWithSensitiveParams}`);
    
    const sanitizedUrl = ErrorHandler.sanitizeUrl(urlWithSensitiveParams);
    
    expect(sanitizedUrl).not.toContain('secret');
    expect(sanitizedUrl).not.toContain('private');
    expect(sanitizedUrl).toContain('[REDACTED]');
  });
});
```

## Инструменты и библиотеки для тестирования

### 1. Mock-библиотеки для симуляции ошибок

```javascript
// Пример использования Jest для мокирования ошибок
describe('Тестирование с моками ошибок', () => {
  test('симуляция различных типов ошибок', async () => {
    // Мокаем API для возврата разных типов ошибок
    const apiErrors = {
      network: () => Promise.reject(new TypeError('Network error')),
      server: () => Promise.reject(new Error('500 Internal Server Error')),
      validation: () => Promise.resolve({
        ok: false,
        status: 400,
        json: async () => ({ error: 'Validation failed' })
      }),
      timeout: () => new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 10000)
      )
    };

    for (const [errorType, errorFunction] of Object.entries(apiErrors)) {
      global.fetch.mockImplementation(errorFunction);
      
      try {
        await ApiService.getData('/test');
      } catch (error) {
        // Проверяем правильную обработку каждого типа ошибки
        expect(error).toBeDefined();
      }
    }
  });
});

// Пример использования Sinon.js для более сложного мокирования
import sinon from 'sinon';

describe('Тестирование с Sinon.js', () => {
  let clock;
  let server;

  beforeEach(() => {
    clock = sinon.useFakeTimers();
    server = sinon.createFakeServer();
    server.autoRespond = true;
  });

  afterEach(() => {
    clock.restore();
    server.restore();
  });

  test('должен обрабатывать таймауты', async () => {
    server.respondWith('GET', '/api/data', [
      408,
      { 'Content-Type': 'application/json' },
      JSON.stringify({ error: 'Request timeout' })
    ]);

    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

    await expect(ApiService.getData('/api/data')).rejects.toThrow();

    expect(consoleSpy).toHaveBeenCalledWith(
      expect.stringContaining('timeout')
    );

    consoleSpy.mockRestore();
  });
});
```

### 2. Тестирование производительности при ошибках

```javascript
// Тестирование влияния обработки ошибок на производительность
describe('Тестирование производительности при ошибках', () => {
  test('обработка ошибок не должна значительно замедлять приложение', async () => {
    const errorHandler = new ErrorHandler();
    const iterations = 1000;
    
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      const error = new Error(`Тестовая ошибка ${i}`);
      errorHandler.handleGlobalError(error);
    }
    
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    // Убедимся, что обработка 1000 ошибок занимает менее 100ms
    expect(totalTime).toBeLessThan(100);
  });

  test('асинхронная обработка ошибок не должна блокировать UI', async () => {
    const errorHandler = new ErrorHandler();
    
    // Запускаем обработку множества ошибок
    const errorPromises = [];
    for (let i = 0; i < 100; i++) {
      const error = new Error(`Ошибка ${i}`);
      errorPromises.push(errorHandler.handleGlobalError(error));
    }
    
    // Проверяем, что UI остается отзывчивым
    const uiResponsive = await checkUIResponsiveness();
    expect(uiResponsive).toBe(true);
    
    await Promise.all(errorPromises);
  });

  async function checkUIResponsiveness() {
    // Имитация проверки отзывчивости UI
    return new Promise(resolve => {
      requestAnimationFrame(() => resolve(true));
    });
  }
});
```

## Практические рекомендации

### 1. Стратегии тестирования

```javascript
// Пример стратегии комплексного тестирования ошибок
class ErrorTestingStrategy {
  static getTestScenarios() {
    return [
      {
        name: 'Сетевые ошибки',
        description: 'Тестирование обработки различных сетевых ошибок',
        tests: [
          'Network timeout',
          'Connection refused',
          'DNS resolution failure',
          'HTTP 5xx errors',
          'HTTP 4xx errors'
        ]
      },
      {
        name: 'Ошибки валидации',
        description: 'Тестирование обработки ошибок валидации',
        tests: [
          'Invalid input data',
          'Missing required fields',
          'Malformed JSON',
          'Invalid formats'
        ]
      },
      {
        name: 'Ошибки бизнес-логики',
        description: 'Тестирование обработки ошибок бизнес-логики',
        tests: [
          'Insufficient permissions',
          'Business rule violations',
          'Resource conflicts',
          'Quota exceeded'
        ]
      },
      {
        name: 'Системные ошибки',
        description: 'Тестирование обработки системных ошибок',
        tests: [
          'Out of memory',
          'Storage quota exceeded',
          'Security violations',
          'Browser API errors'
        ]
      }
    ];
  }

  static async runAllTests() {
    const scenarios = this.getTestScenarios();
    const results = [];

    for (const scenario of scenarios) {
      console.log(`Запуск сценария: ${scenario.name}`);
      
      for (const test of scenario.tests) {
        try {
          // Выполнение конкретного теста
          const result = await this.executeTest(test);
          results.push({ test, result, status: 'passed' });
        } catch (error) {
          results.push({ test, error: error.message, status: 'failed' });
        }
      }
    }

    return results;
  }

  static async executeTest(testName) {
    // В реальной реализации здесь будет логика выполнения конкретного теста
    // В зависимости от типа ошибки
    return true;
  }
}
```

### 2. Автоматизация тестирования ошибок

```javascript
// Пример системы автоматического тестирования ошибок
class AutomatedErrorTester {
  constructor() {
    this.testResults = [];
    this.errorSimulator = new ErrorSimulator();
  }

  async runAutomatedTests() {
    const testSuites = [
      this.networkErrorTests(),
      this.validationErrorTests(),
      this.businessErrorTests(),
      this.systemErrorTests()
    ];

    for (const testSuite of testSuites) {
      const results = await testSuite;
      this.testResults.push(...results);
    }

    return this.generateReport();
  }

  async networkErrorTests() {
    const tests = [
      { name: 'Тест таймаута соединения', action: () => this.testConnectionTimeout() },
      { name: 'Тест разрыва соединения', action: () => this.testConnectionDrop() },
      { name: 'Тест ошибки DNS', action: () => this.testDNSError() }
    ];

    return this.executeTestSuite(tests);
  }

  async validationErrorTests() {
    const tests = [
      { name: 'Тест ошибки валидации email', action: () => this.testEmailValidation() },
      { name: 'Тест ошибки длины пароля', action: () => this.testPasswordLength() }
    ];

    return this.executeTestSuite(tests);
  }

  async testConnectionTimeout() {
    // Симуляция таймаута соединения
    global.fetch = jest.fn(() =>
      new Promise((_, reject) => 
        setTimeout(() => reject(new TypeError('Network timeout')), 15000)
      )
    );

    try {
      await ApiService.getData('/api/test');
      return { success: false, error: 'Expected timeout error' };
    } catch (error) {
      return { success: true, errorType: 'timeout' };
    }
  }

  async testConnectionDrop() {
    global.fetch = jest.fn(() => Promise.reject(new TypeError('Network request failed')));

    try {
      await ApiService.getData('/api/test');
      return { success: false, error: 'Expected network error' };
    } catch (error) {
      return { success: true, errorType: 'connection_drop' };
    }
  }

  async testEmailValidation() {
    const invalidEmail = 'invalid-email';
    
    try {
      await ValidationService.validateEmail(invalidEmail);
      return { success: false, error: 'Expected validation error' };
    } catch (error) {
      return { success: true, errorType: 'validation' };
    }
  }

  async executeTestSuite(tests) {
    const results = [];
    
    for (const test of tests) {
      try {
        const result = await test.action();
        results.push({
          name: test.name,
          result,
          status: 'passed',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        results.push({
          name: test.name,
          error: error.message,
          status: 'failed',
          timestamp: new Date().toISOString()
        });
      }
    }
    
    return results;
  }

  generateReport() {
    const passed = this.testResults.filter(r => r.status === 'passed').length;
    const failed = this.testResults.filter(r => r.status === 'failed').length;
    
    return {
      total: this.testResults.length,
      passed,
      failed,
      successRate: (passed / this.testResults.length) * 100,
      details: this.testResults
    };
  }
}
```

## Заключение

Тестирование обработки ошибок в фронтенд-приложениях должно быть комплексным и включать:

- Модульные тесты для отдельных компонентов
- Интеграционные тесты для проверки взаимодействия компонентов
- Сценарные тесты для проверки реальных ситуаций
- Тесты безопасности для предотвращения утечек данных
- Тесты производительности для обеспечения отзывчивости

Регулярное тестирование различных сценариев ошибок помогает обеспечить надежность, безопасность и качество пользовательского опыта приложений, соответствующих требованиям российского законодательства 2025 года.

## См. также

- [[Обработка-ошибок]]
- [[Логирование]]
- [[Мониторинг]]
- [[Восстановление]]
- [[Тестирование производительности]]
- [[Безопасность фронтенд-приложений]]