---
aliases: [Система мониторинга ошибок, Мониторинг фронтенд-ошибок, Error Monitoring]
tags: [архитектура, фронтенд, ошибки, мониторинг, аналитика]
---

# Мониторинг ошибок в фронтенд-приложениях

## Введение

Мониторинг ошибок в фронтенд-приложениях — это система, обеспечивающая непрерывное отслеживание состояния приложения, выявление проблем в реальном времени и предоставление аналитики для улучшения качества пользовательского опыта. В условиях российского законодательства 2025 года мониторинг должен обеспечивать безопасность данных и соответствовать требованиям ФЗ-152 "О персональных данных".

## Архитектура системы мониторинга

### 1. Компоненты системы мониторинга

Современная система мониторинга ошибок включает следующие компоненты:

- **Клиентская библиотека** — код, внедренный в приложение для перехвата и отправки ошибок
- **Сервер приема** — сервис, принимающий ошибки от клиентов
- **Система хранения** — база данных для хранения информации об ошибках
- **Система анализа** — компонент для обработки и классификации ошибок
- **Интерфейс анализа** — веб-интерфейс для просмотра и анализа ошибок
- **Система оповещений** — компонент для отправки уведомлений о критических ошибках

```javascript
// Пример архитектуры клиентской библиотеки мониторинга
class FrontendMonitor {
  constructor(config) {
    this.config = config;
    this.errorHandler = new ErrorHandler(config);
    this.performanceMonitor = new PerformanceMonitor(config);
    this.sessionTracker = new SessionTracker(config);
    this.dataPrivacyManager = new DataPrivacyManager(config);
    
    this.initialize();
  }

  initialize() {
    // Инициализация компонентов мониторинга
    this.setupErrorHandling();
    this.setupPerformanceMonitoring();
    this.setupSessionTracking();
    this.setupPrivacyControls();
  }

  setupErrorHandling() {
    // Установка глобальных обработчиков ошибок
    window.addEventListener('error', (event) => {
      this.handleError(event.error, { type: 'js_error' });
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(event.reason, { type: 'unhandled_promise_rejection' });
    });
  }

  setupPerformanceMonitoring() {
    // Мониторинг производительности
    this.performanceMonitor.startMonitoring();
  }

  setupSessionTracking() {
    // Отслеживание сессий пользователей
    this.sessionTracker.startTracking();
  }

  setupPrivacyControls() {
    // Настройка контроля конфиденциальности
    this.dataPrivacyManager.setupPrivacyControls();
  }

  handleError(error, context = {}) {
    // Проверка конфиденциальности перед отправкой
    if (!this.dataPrivacyManager.isAllowedToSend(error)) {
      return;
    }

    const errorReport = {
      id: this.generateErrorId(),
      error: this.sanitizeError(error),
      context: this.enrichContext(context),
      timestamp: new Date().toISOString(),
      session: this.sessionTracker.getSessionInfo(),
      user: this.getUserContext(),
      appVersion: this.config.appVersion,
      environment: this.config.environment
    };

    this.sendErrorReport(errorReport);
  }

  sanitizeError(error) {
    // Очистка ошибки от чувствительных данных
    return this.dataPrivacyManager.sanitizeError(error);
  }

  enrichContext(context) {
    // Добавление контекста к ошибке
    return {
      ...context,
      userAgent: navigator.userAgent,
      url: window.location.href,
      referrer: document.referrer,
      performance: this.performanceMonitor.getCurrentMetrics()
    };
  }

  getUserContext() {
    // Получение анонимизированного контекста пользователя
    return this.dataPrivacyManager.getAnonymizedUserContext();
  }

  sendErrorReport(report) {
    // Отправка отчета об ошибке на сервер
    fetch(this.config.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`,
        'X-Client-Version': this.config.appVersion
      },
      body: JSON.stringify(report)
    }).catch(error => {
      console.error('Failed to send error report:', error);
    });
  }

  generateErrorId() {
    // Генерация уникального идентификатора ошибки
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
}
```

### 2. Классификация и группировка ошибок

Для эффективного мониторинга ошибки должны быть классифицированы и сгруппированы:

- По типу ошибки (JS ошибка, сетевая ошибка, ошибка бизнес-логики)
- По критичности (критическая, высокая, средняя, низкая)
- По частоте возникновения
- По затронутым пользователям
- По версии приложения

```javascript
class ErrorClassifier {
  static classify(errorReport) {
    const classification = {
      type: this.getType(errorReport),
      severity: this.getSeverity(errorReport),
      fingerprint: this.getFingerprint(errorReport),
      affectedUsers: 1,
      occurrences: 1,
      firstSeen: errorReport.timestamp,
      lastSeen: errorReport.timestamp
    };

    return classification;
  }

  static getType(errorReport) {
    const message = errorReport.error.message || '';
    const stack = errorReport.error.stack || '';

    if (message.includes('NetworkError') || message.includes('fetch')) {
      return 'network';
    } else if (stack.includes('TypeError') || stack.includes('ReferenceError')) {
      return 'javascript';
    } else if (message.includes('Validation')) {
      return 'validation';
    } else {
      return 'application';
    }
  }

  static getSeverity(errorReport) {
    // Определение критичности ошибки
    const { type, message, context } = errorReport;

    if (type === 'network' && context.status >= 500) {
      return 'high';
    } else if (message.includes('critical') || message.includes('fatal')) {
      return 'high';
    } else if (context.component === 'auth' || context.component === 'payment') {
      return 'high';
    } else {
      return 'medium';
    }
  }

  static getFingerprint(errorReport) {
    // Генерация отпечатка ошибки для группировки
    const { error, context } = errorReport;
    const signature = `${error.name}:${error.message.split(' ').slice(0, 5).join(' ')}`;
    
    // Используем хэш для нормализации
    return this.hashString(signature);
  }

  static hashString(str) {
    // Простая хэш-функция для отпечатка ошибки
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(16);
  }
}
```

## Метрики и показатели

### 1. Ключевые метрики мониторинга

Для эффективного мониторинга необходимо отслеживать следующие метрики:

- **Частота ошибок** — количество ошибок за определенный период
- **Критические ошибки** — ошибки, влияющие на пользовательский опыт
- **Время до обнаружения** — время между возникновением и обнаружением ошибки
- **Время устранения** — время между обнаружением и исправлением
- **Затронутые пользователи** — количество пользователей, столкнувшихся с ошибкой
- **Влияние на бизнес** — влияние ошибок на ключевые бизнес-показатели

```javascript
class MetricsCollector {
  constructor() {
    this.metrics = {
      errorCount: 0,
      criticalErrorCount: 0,
      errorRate: 0,
      affectedUsers: new Set(),
      sessions: new Map(),
      performance: {
        avgLoadTime: 0,
        avgResponseTime: 0
      }
    };
  }

  recordError(errorReport) {
    this.metrics.errorCount++;
    
    if (errorReport.classification.severity === 'high') {
      this.metrics.criticalErrorCount++;
    }

    this.metrics.affectedUsers.add(errorReport.session.userId);
    
    // Обновление частоты ошибок
    this.updateErrorRate();
  }

  updateErrorRate() {
    // Расчет частоты ошибок за последний час
    const now = Date.now();
    const hourAgo = now - 60 * 60 * 1000;
    
    // В реальной реализации использовать данные за последний час
    this.metrics.errorRate = this.metrics.errorCount / 1000; // Условный расчет
  }

  getDashboardData() {
    return {
      totalErrors: this.metrics.errorCount,
      criticalErrors: this.metrics.criticalErrorCount,
      errorRate: this.metrics.errorRate,
      affectedUsers: this.metrics.affectedUsers.size,
      uptime: this.calculateUptime(),
      performance: this.metrics.performance
    };
  }

  calculateUptime() {
    // Расчет времени безотказной работы
    // В реальной системе использовать данные о доступности
    return 99.9;
  }
}
```

### 2. Пороговые значения и алертинг

Для эффективного реагирования на ошибки необходимо настроить пороговые значения и систему оповещений:

```javascript
class AlertSystem {
  constructor(metricsCollector) {
    this.metrics = metricsCollector;
    this.alerts = [];
    this.alertConfig = this.loadAlertConfig();
  }

  loadAlertConfig() {
    // Загрузка конфигурации алертов
    return [
      {
        name: 'High Error Rate',
        condition: (metrics) => metrics.errorRate > 0.05, // >5% ошибок
        severity: 'high',
        notification: ['email', 'slack']
      },
      {
        name: 'Critical Errors',
        condition: (metrics) => metrics.criticalErrors > 10, // >10 критических ошибок
        severity: 'critical',
        notification: ['email', 'sms', 'slack']
      },
      {
        name: 'Many Affected Users',
        condition: (metrics) => metrics.affectedUsers > 100, // >100 затронутых пользователей
        severity: 'high',
        notification: ['email', 'slack']
      }
    ];
  }

  checkAlerts() {
    const metrics = this.metrics.getDashboardData();
    
    this.alertConfig.forEach(config => {
      if (config.condition(metrics)) {
        this.triggerAlert(config, metrics);
      }
    });
  }

  triggerAlert(config, metrics) {
    const alert = {
      id: this.generateAlertId(),
      name: config.name,
      severity: config.severity,
      timestamp: new Date().toISOString(),
      metrics: metrics,
      triggeredBy: config.condition.toString()
    };

    this.alerts.push(alert);
    this.sendNotifications(alert, config.notification);
  }

  sendNotifications(alert, channels) {
    channels.forEach(channel => {
      switch (channel) {
        case 'email':
          this.sendEmailNotification(alert);
          break;
        case 'slack':
          this.sendSlackNotification(alert);
          break;
        case 'sms':
          this.sendSmsNotification(alert);
          break;
      }
    });
  }

  generateAlertId() {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
  }

  // Методы отправки уведомлений
  sendEmailNotification(alert) {
    // Реализация отправки email уведомления
    console.log(`Sending email alert: ${alert.name}`);
  }

  sendSlackNotification(alert) {
    // Реализация отправки Slack уведомления
    console.log(`Sending Slack alert: ${alert.name}`);
  }

  sendSmsNotification(alert) {
    // Реализация отправки SMS уведомления
    console.log(`Sending SMS alert: ${alert.name}`);
  }
}
```

## Практические рекомендации

### 1. Интеграция с существующими системами

Для эффективного мониторинга рекомендуется интегрировать систему с:

- Системами CI/CD для отслеживания ошибок после деплоя
- Системами аналитики (Google Analytics, Яндекс.Метрика)
- Системами оповещений (PagerDuty, Opsgenie)
- Системами управления задачами (Jira, Trello)

```javascript
// Пример интеграции с системой аналитики
class AnalyticsIntegration {
  constructor(analyticsProvider) {
    this.provider = analyticsProvider;
  }

  trackError(errorReport) {
    // Отправка ошибки в систему аналитики
    this.provider.event('error_occurred', {
      error_type: errorReport.classification.type,
      error_severity: errorReport.classification.severity,
      component: errorReport.context.component,
      user_segment: errorReport.user.segment
    });
  }

  trackPerformanceIssue(performanceData) {
    // Отслеживание проблем с производительностью
    this.provider.timing('performance', performanceData.metric, performanceData.value);
  }
}
```

### 2. Мониторинг пользовательского опыта

Важно отслеживать не только технические ошибки, но и проблемы с пользовательским опытом:

- Долгие загрузки страниц
- Проблемы с взаимодействием
- Ошибки ввода данных
- Проблемы с доступностью

```javascript
class UserExperienceMonitor {
  constructor() {
    this.setupUXMonitoring();
  }

  setupUXMonitoring() {
    // Мониторинг взаимодействия пользователя
    this.setupClickMonitoring();
    this.setupFormMonitoring();
    this.setupPerformanceMonitoring();
  }

  setupClickMonitoring() {
    document.addEventListener('click', (event) => {
      // Отслеживание кликов, которые могут привести к ошибке
      const element = event.target;
      if (element.tagName === 'BUTTON' && element.classList.contains('error-prone')) {
        // Логирование потенциально проблемного взаимодействия
        this.logUXEvent('potential_error_interaction', {
          element: element.tagName,
          className: element.className,
          xpath: this.getElementXPath(element)
        });
      }
    });
  }

  setupFormMonitoring() {
    document.querySelectorAll('form').forEach(form => {
      form.addEventListener('submit', (event) => {
        // Мониторинг ошибок валидации форм
        setTimeout(() => {
          const errorElements = form.querySelectorAll('.error');
          if (errorElements.length > 0) {
            this.logUXEvent('form_validation_error', {
              formId: form.id,
              errorCount: errorElements.length,
              errors: Array.from(errorElements).map(el => el.textContent)
            });
          }
        }, 1000); // Ждем результат валидации
      });
    });
  }

  logUXEvent(eventType, data) {
    // Логирование UX события
    console.log(`UX Event: ${eventType}`, data);
    // В реальной системе отправлять на сервер мониторинга
  }

  getElementXPath(element) {
    // Генерация XPath элемента для идентификации
    if (element.id) return `//*[@id="${element.id}"]`;
    
    const path = [];
    while (element.nodeType === Node.ELEMENT_NODE && element !== document.body) {
      let index = 1;
      let hasSameTypeSiblings = false;
      const siblings = element.parentNode.childNodes;
      
      for (let i = 0; i < siblings.length; i++) {
        const sibling = siblings[i];
        if (sibling === element) break;
        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === element.tagName) {
          index++;
          hasSameTypeSiblings = true;
        }
      }
      
      const name = element.nodeName.toLowerCase();
      const selector = hasSameTypeSiblings ? `${name}[${index}]` : name;
      path.unshift(selector);
      element = element.parentNode;
    }
    
    path.unshift('body');
    return '/' + path.join('/');
  }
}
```

## Безопасность и конфиденциальность

В условиях российского законодательства система мониторинга должна обеспечивать:

- Защиту персональных данных
- Анонимизацию пользовательской информации
- Шифрование данных при передаче
- Соответствие требованиям локализации данных

```javascript
class PrivacyComplianceMonitor {
  constructor() {
    this.privacySettings = this.loadPrivacySettings();
  }

  loadPrivacySettings() {
    // Загрузка настроек конфиденциальности
    return {
      maskPII: true,
      anonymizeUserIds: true,
      restrictSensitiveData: true,
      complyWithLocalLaws: true
    };
  }

  processErrorReport(report) {
    if (this.privacySettings.maskPII) {
      report = this.maskPersonalData(report);
    }
    
    if (this.privacySettings.anonymizeUserIds) {
      report.user.anonymousId = this.generateAnonymousId(report.user.id);
      delete report.user.id;
    }
    
    if (this.privacySettings.restrictSensitiveData) {
      report = this.removeSensitiveData(report);
    }
    
    return report;
  }

  maskPersonalData(report) {
    // Маскировка потенциально персональных данных
    if (report.error.message) {
      report.error.message = this.maskPII(report.error.message);
    }
    
    if (report.context.url) {
      report.context.url = this.maskPII(report.context.url);
    }
    
    return report;
  }

  maskPII(text) {
    // Маскировка потенциально персональных данных в тексте
    return text
      .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, '****-****-****-****')
      .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL]')
      .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, '[PHONE]')
      .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{2}[-.]?\d{2}\b/g, '[ID]');
  }

  generateAnonymousId(userId) {
    // Генерация анонимного идентификатора
    return btoa(userId).substring(0, 12);
  }

  removeSensitiveData(report) {
    // Удаление чувствительных данных из отчета
    delete report.context.formData;
    delete report.context.queryParams;
    delete report.error.stack;
    
    if (report.context.meta) {
      delete report.context.meta.token;
      delete report.context.meta.password;
      delete report.context.meta.credentials;
    }
    
    return report;
  }
}
```

## Заключение

Эффективная система мониторинга ошибок в фронтенд-приложениях должна обеспечивать:

- Полное покрытие всех типов ошибок
- Быстрое обнаружение и классификацию проблем
- Соответствие требованиям безопасности и конфиденциальности
- Интеграцию с существующими системами
- Удобный интерфейс для анализа и реагирования

Правильно реализованный мониторинг становится основой для построения надежного и стабильного фронтенд-приложения.

## См. также

- [[Обработка-ошибок]]
- [[Логирование]]
- [[Восстановление]]
- [[Тестирование]]
- [[Анализ логов]]
- [[Метрики производительности]]