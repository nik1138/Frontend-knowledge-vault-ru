---
aliases: [Восстановление после ошибок, Стратегии восстановления, Error Recovery]
tags: [архитектура, фронтенд, ошибки, восстановление, отказоустойчивость]
---

# Восстановление после ошибок в фронтенд-приложениях

## Введение

Восстановление после ошибок — это критически важный аспект архитектуры фронтенд-приложений, обеспечивающий продолжение работы приложения даже после возникновения проблем. В российских реалиях 2025 года, с учетом требований к защите данных и необходимости обеспечения стабильной работы приложений, стратегии восстановления должны быть тщательно продуманы и реализованы.

## Принципы восстановления

### 1. Изолированное восстановление

Важно обеспечить восстановление только проблемных компонентов без перезагрузки всего приложения. Это достигается через:

- Использование Error Boundary в React
- Обработка ошибок на уровне компонентов
- Изоляцию состояния компонентов

```javascript
// Пример Error Boundary в React для изолированного восстановления
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    // Обновить состояние, чтобы следующий рендер показал запасной UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Логирование ошибки для анализа
    this.setState({
      error: error,
      errorInfo: errorInfo
    });

    // Отправка ошибки в систему мониторинга
    ErrorHandler.logError(error, errorInfo);
  }

  // Метод для восстановления компонента
  handleRecovery = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
    
    // Перезапуск логики компонента
    if (this.props.onRecover) {
      this.props.onRecover();
    }
  };

  render() {
    if (this.state.hasError) {
      // Запасной UI при ошибке
      return (
        <div className="error-fallback">
          <h2>Произошла ошибка</h2>
          <p>Мы уже работаем над устранением проблемы.</p>
          <button onClick={this.handleRecovery}>Попробовать снова</button>
          {process.env.NODE_ENV === 'development' && (
            <details style={{ whiteSpace: 'pre-wrap' }}>
              {this.state.error && this.state.error.toString()}
              <br />
              {this.state.errorInfo.componentStack}
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

// Использование Error Boundary
function App() {
  return (
    <ErrorBoundary>
      <MainContent />
    </ErrorBoundary>
  );
}
```

### 2. Повторные попытки (Retry)

Многие ошибки, особенно сетевые, являются временными. Реализация механизма повторных попыток позволяет автоматически восстановиться после таких ошибок:

```javascript
class RetryMechanism {
  static async execute(fn, options = {}) {
    const {
      maxRetries = 3,
      baseDelay = 1000,
      backoffMultiplier = 2,
      shouldRetry = () => true
    } = options;

    let lastError;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn(attempt);
      } catch (error) {
        lastError = error;

        // Проверка, стоит ли повторять попытку
        if (attempt === maxRetries || !shouldRetry(error)) {
          break;
        }

        // Вычисление задержки с экспоненциальным затуханием
        const delay = baseDelay * Math.pow(backoffMultiplier, attempt);
        await this.delay(delay);
      }
    }

    throw lastError;
  }

  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Пример использования механизма повторных попыток
async function fetchUserData(userId) {
  return await RetryMechanism.execute(
    async (attempt) => {
      console.log(`Попытка ${attempt + 1} получить данные пользователя`);
      const response = await fetch(`/api/users/${userId}`);
      
      if (!response.ok) {
        throw new NetworkError(`HTTP ${response.status}`, response);
      }
      
      return response.json();
    },
    {
      maxRetries: 3,
      baseDelay: 1000,
      shouldRetry: (error) => error.type === 'network'
    }
  );
}
```

### 3. Резервные стратегии (Fallback)

Когда основная функциональность недоступна, приложение должно предоставить резервные опции:

```javascript
class FallbackManager {
  constructor() {
    this.fallbackStrategies = new Map();
  }

  // Регистрация резервной стратегии
  registerFallback(key, strategy) {
    this.fallbackStrategies.set(key, strategy);
  }

  // Выполнение операции с резервной стратегией
  async executeWithFallback(primaryFn, fallbackKey, context = {}) {
    try {
      return await primaryFn();
    } catch (error) {
      console.warn('Primary operation failed, trying fallback:', error);
      
      const fallback = this.fallbackStrategies.get(fallbackKey);
      if (fallback) {
        try {
          return await fallback(context);
        } catch (fallbackError) {
          console.error('Fallback also failed:', fallbackError);
          throw new Error('Both primary and fallback operations failed');
        }
      } else {
        throw error; // Если резервной стратегии нет, бросаем исходную ошибку
      }
    }
  }
}

// Пример резервных стратегий
const fallbackManager = new FallbackManager();

// Резервная стратегия для получения данных пользователя
fallbackManager.registerFallback('getUserData', async ({ userId }) => {
  // Попытка получить данные из кэша
  const cachedData = await CacheService.get(`user_${userId}`);
  if (cachedData) {
    console.log('Using cached user data as fallback');
    return cachedData;
  }

  // Если в кэше нет, возвращаем минимальные данные
  return {
    id: userId,
    name: 'Пользователь',
    avatar: '/default-avatar.png',
    isOffline: true
  };
});

// Резервная стратегия для отправки данных
fallbackManager.registerFallback('sendData', async ({ data, endpoint }) => {
  // Сохранение данных в локальное хранилище для последующей отправки
  await LocalStorageQueue.enqueue({ data, endpoint, timestamp: Date.now() });
  
  // Возврат успешного ответа для пользователя
  return { success: true, queued: true };
});
```

## Стратегии восстановления

### 1. Клиентская синхронизация данных

Для обеспечения согласованности данных при сетевых ошибках:

```javascript
class DataSyncManager {
  constructor() {
    this.syncQueue = new PriorityQueue();
    this.conflictResolver = new ConflictResolver();
  }

  // Добавление операции в очередь синхронизации
  async queueOperation(operation) {
    const syncTask = {
      id: this.generateId(),
      operation,
      timestamp: Date.now(),
      priority: this.calculatePriority(operation),
      retries: 0,
      maxRetries: 5
    };

    this.syncQueue.enqueue(syncTask);
    await this.processQueue();
  }

  async processQueue() {
    while (!this.syncQueue.isEmpty()) {
      const task = this.syncQueue.dequeue();
      
      try {
        await this.executeSyncTask(task);
        console.log(`Sync task ${task.id} completed successfully`);
      } catch (error) {
        if (task.retries < task.maxRetries) {
          // Увеличиваем приоритет и возвращаем в очередь
          task.retries++;
          task.priority = this.increasePriority(task);
          this.syncQueue.enqueue(task);
          
          // Повтор через задержку
          await this.delay(2000 * task.retries);
        } else {
          console.error(`Sync task ${task.id} failed after ${task.maxRetries} attempts`);
          this.handleSyncFailure(task, error);
        }
      }
    }
  }

  async executeSyncTask(task) {
    const response = await fetch(task.operation.endpoint, {
      method: task.operation.method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getAuthToken()}`
      },
      body: JSON.stringify(task.operation.data)
    });

    if (!response.ok) {
      throw new NetworkError(`Sync failed: ${response.status}`, response);
    }

    return response.json();
  }

  handleSyncFailure(task, error) {
    // Логирование ошибки синхронизации
    ErrorHandler.logError(error, {
      task: task.operation,
      retries: task.retries
    });

    // Попытка разрешения конфликта
    this.conflictResolver.resolve(task, error);
  }

  calculatePriority(operation) {
    // Приоритет зависит от типа операции
    switch (operation.type) {
      case 'critical':
        return 1;
      case 'user_action':
        return 2;
      case 'background':
        return 3;
      default:
        return 2;
    }
  }

  increasePriority(task) {
    // Увеличение приоритета для провалившихся задач
    return Math.max(1, task.priority - 1);
  }

  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 2. Восстановление состояния приложения

Сохранение и восстановление состояния приложения после ошибок:

```javascript
class StateRecoveryManager {
  constructor() {
    this.stateSnapshotInterval = 30000; // 30 секунд
    this.maxSnapshots = 10;
    this.snapshots = [];
    this.isRecovering = false;
  }

  // Начало отслеживания состояния
  startTracking(store) {
    this.store = store;
    this.setupSnapshotInterval();
    this.setupErrorRecovery();
  }

  setupSnapshotInterval() {
    // Регулярное создание снимков состояния
    this.snapshotInterval = setInterval(() => {
      this.createSnapshot();
    }, this.stateSnapshotInterval);
  }

  setupErrorRecovery() {
    // Установка обработчика для восстановления после критических ошибок
    window.addEventListener('critical_error', (event) => {
      this.recoverFromSnapshot(event.detail.error);
    });
  }

  createSnapshot() {
    if (this.isRecovering) return;

    const snapshot = {
      id: this.generateId(),
      timestamp: Date.now(),
      state: this.store.getState(),
      url: window.location.href,
      userData: this.getUserData()
    };

    this.snapshots.push(snapshot);

    // Ограничение количества снимков
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift();
    }

    // Сохранение в локальное хранилище
    this.saveToLocalStorage();
  }

  async recoverFromSnapshot(error) {
    if (this.isRecovering) return;

    this.isRecovering = true;
    console.log('Начало восстановления состояния после ошибки:', error);

    try {
      // Поиск наиболее подходящего снимка
      const snapshot = this.findRecoverySnapshot(error);
      
      if (snapshot) {
        await this.restoreState(snapshot);
        console.log('Состояние успешно восстановлено');
        
        // Уведомление пользователя
        this.notifyUser('Состояние приложения восстановлено после ошибки');
      } else {
        console.log('Не найдено подходящего снимка для восстановления');
        // Сброс до начального состояния
        this.resetToInitialState();
      }
    } catch (recoveryError) {
      console.error('Ошибка при восстановлении состояния:', recoveryError);
      this.resetToInitialState();
    } finally {
      this.isRecovering = false;
    }
  }

  findRecoverySnapshot(error) {
    // Поиск снимка перед ошибкой
    // В реальной реализации может использовать более сложную логику
    return this.snapshots[this.snapshots.length - 1] || null;
  }

  async restoreState(snapshot) {
    // Восстановление состояния из снимка
    this.store.setState(snapshot.state);
    
    // Восстановление URL, если необходимо
    if (snapshot.url !== window.location.href) {
      window.history.replaceState({}, '', snapshot.url);
    }
    
    // Восстановление пользовательских данных
    if (snapshot.userData) {
      this.restoreUserData(snapshot.userData);
    }
  }

  resetToInitialState() {
    // Сброс до начального состояния
    this.store.reset();
    window.location.reload();
  }

  saveToLocalStorage() {
    try {
      const serializedSnapshots = this.snapshots.map(snapshot => ({
        ...snapshot,
        state: JSON.stringify(snapshot.state) // Сериализация состояния
      }));
      
      localStorage.setItem('app_state_snapshots', JSON.stringify(serializedSnapshots));
    } catch (error) {
      console.error('Failed to save snapshots to localStorage:', error);
    }
  }

  loadFromLocalStorage() {
    try {
      const serializedSnapshots = localStorage.getItem('app_state_snapshots');
      if (serializedSnapshots) {
        this.snapshots = JSON.parse(serializedSnapshots).map(snapshot => ({
          ...snapshot,
          state: JSON.parse(snapshot.state) // Десериализация состояния
        }));
      }
    } catch (error) {
      console.error('Failed to load snapshots from localStorage:', error);
      this.snapshots = [];
    }
  }

  getUserData() {
    // Получение минимально необходимых пользовательских данных
    return {
      userId: localStorage.getItem('userId'),
      preferences: localStorage.getItem('preferences'),
      lastAction: sessionStorage.getItem('lastAction')
    };
  }

  restoreUserData(userData) {
    // Восстановление пользовательских данных
    if (userData.userId) {
      localStorage.setItem('userId', userData.userId);
    }
    if (userData.preferences) {
      localStorage.setItem('preferences', userData.preferences);
    }
    if (userData.lastAction) {
      sessionStorage.setItem('lastAction', userData.lastAction);
    }
  }

  notifyUser(message) {
    // Показ уведомления пользователю
    if (window.Notification && Notification.permission === 'granted') {
      new Notification('Восстановление состояния', { body: message });
    } else {
      // Альтернативный способ уведомления
      console.info(message);
    }
  }

  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  destroy() {
    if (this.snapshotInterval) {
      clearInterval(this.snapshotInterval);
    }
  }
}
```

### 3. Кэширование и автономная работа

Обеспечение работы приложения при сетевых ошибках:

```javascript
class OfflineManager {
  constructor() {
    this.isOnline = navigator.onLine;
    this.cache = new Map();
    this.requestQueue = [];
    this.setupEventListeners();
  }

  setupEventListeners() {
    // Отслеживание изменения статуса подключения
    window.addEventListener('online', () => {
      this.handleOnline();
    });

    window.addEventListener('offline', () => {
      this.handleOffline();
    });
  }

  handleOffline() {
    this.isOnline = false;
    console.log('Приложение перешло в автономный режим');
    
    // Уведомление пользователю
    this.showOfflineNotification();
  }

  handleOnline() {
    this.isOnline = true;
    console.log('Соединение восстановлено');
    
    // Попытка выполнения отложенных запросов
    this.processRequestQueue();
  }

  // Метод для выполнения запросов с автоматическим кэшированием
  async fetchWithCache(url, options = {}, cacheTimeout = 300000) { // 5 минут
    const cacheKey = this.generateCacheKey(url, options);
    
    // Проверка кэша
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < cacheTimeout) {
      console.log('Возврат данных из кэша для:', url);
      return cached.data;
    }

    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new NetworkError(`HTTP ${response.status}`, response);
      }
      
      const data = await response.json();
      
      // Сохранение в кэш
      this.cache.set(cacheKey, {
        data,
        timestamp: Date.now()
      });
      
      return data;
    } catch (error) {
      if (error.type === 'network' && this.cache.has(cacheKey)) {
        // Возврат устаревших данных из кэша при сетевой ошибке
        console.warn('Возврат устаревших данных из кэша из-за сетевой ошибки');
        return this.cache.get(cacheKey).data;
      }
      throw error;
    }
  }

  // Метод для выполнения запросов с очередью
  async fetchWithQueue(url, options = {}) {
    if (this.isOnline) {
      try {
        return await fetch(url, options);
      } catch (error) {
        if (error.type === 'network') {
          // Добавление в очередь при сетевой ошибке
          return this.queueRequest(url, options);
        }
        throw error;
      }
    } else {
      // Автоматически добавляем в очередь в автономном режиме
      return this.queueRequest(url, options);
    }
  }

  async queueRequest(url, options) {
    const request = {
      id: this.generateId(),
      url,
      options,
      timestamp: Date.now(),
      retries: 0
    };

    this.requestQueue.push(request);
    this.saveQueueToStorage();

    // Возврат промиса, который будет выполнен при отправке запроса
    return new Promise((resolve, reject) => {
      request.resolve = resolve;
      request.reject = reject;
    });
  }

  async processRequestQueue() {
    if (!this.isOnline || this.requestQueue.length === 0) {
      return;
    }

    console.log(`Обработка очереди из ${this.requestQueue.length} запросов`);
    
    const remainingRequests = [];
    
    for (const request of this.requestQueue) {
      try {
        const response = await fetch(request.url, request.options);
        
        if (request.resolve) {
          request.resolve(response);
        }
        
        console.log(`Запрос ${request.id} успешно выполнен`);
      } catch (error) {
        if (request.retries < 3) {
          // Повторяем неудачные запросы
          request.retries++;
          remainingRequests.push(request);
          console.warn(`Запрос ${request.id} не выполнен, планируется повтор`);
        } else {
          // Отказываемся от запроса после нескольких попыток
          if (request.reject) {
            request.reject(error);
          }
          console.error(`Запрос ${request.id} окончательно не выполнен`);
        }
      }
    }
    
    this.requestQueue = remainingRequests;
    this.saveQueueToStorage();
  }

  showOfflineNotification() {
    // Показ уведомления о переходе в автономный режим
    const notification = document.createElement('div');
    notification.className = 'offline-notification';
    notification.innerHTML = `
      <div class="notification-content">
        <span>⚠️</span>
        <span>Вы работаете в автономном режиме</span>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    // Автоматическое скрытие через 5 секунд
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 5000);
  }

  generateCacheKey(url, options) {
    return `${url}_${JSON.stringify(options)}`;
  }

  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  saveQueueToStorage() {
    try {
      const serializableQueue = this.requestQueue.map(req => ({
        id: req.id,
        url: req.url,
        options: req.options,
        timestamp: req.timestamp,
        retries: req.retries
      }));
      
      localStorage.setItem('request_queue', JSON.stringify(serializableQueue));
    } catch (error) {
      console.error('Failed to save request queue:', error);
    }
  }

  loadQueueFromStorage() {
    try {
      const storedQueue = localStorage.getItem('request_queue');
      if (storedQueue) {
        const parsedQueue = JSON.parse(storedQueue);
        this.requestQueue = parsedQueue.map(req => ({
          ...req,
          // Восстановление промисов невозможно, поэтому не добавляем resolve/reject
        }));
      }
    } catch (error) {
      console.error('Failed to load request queue:', error);
      this.requestQueue = [];
    }
  }
}
```

## Практические рекомендации

### 1. Пользовательские уведомления

Важно информировать пользователей о процессе восстановления:

```javascript
class RecoveryNotificationManager {
  constructor() {
    this.notifications = new Map();
  }

  showRecoveryNotification(type, message, options = {}) {
    const id = this.generateId();
    const notification = {
      id,
      type,
      message,
      timestamp: Date.now(),
      ...options
    };

    this.displayNotification(notification);
    this.notifications.set(id, notification);

    // Автоматическое скрытие уведомления
    if (options.autoHide !== false) {
      setTimeout(() => {
        this.hideNotification(id);
      }, options.duration || 5000);
    }

    return id;
  }

  displayNotification(notification) {
    // Создание элемента уведомления
    const element = document.createElement('div');
    element.className = `recovery-notification notification-${notification.type}`;
    element.id = `notification-${notification.id}`;
    element.innerHTML = `
      <div class="notification-content">
        <span class="notification-message">${notification.message}</span>
        ${notification.showProgress ? '<div class="notification-progress"></div>' : ''}
        ${notification.showRetry ? '<button class="retry-button">Повторить</button>' : ''}
        <button class="close-button">&times;</button>
      </div>
    `;

    // Добавление обработчиков
    const closeButton = element.querySelector('.close-button');
    closeButton.addEventListener('click', () => {
      this.hideNotification(notification.id);
    });

    if (notification.onRetry) {
      const retryButton = element.querySelector('.retry-button');
      retryButton.addEventListener('click', () => {
        notification.onRetry();
        this.hideNotification(notification.id);
      });
    }

    // Добавление в DOM
    const container = document.getElementById('notifications-container') || 
                     this.createNotificationContainer();
    container.appendChild(element);

    // Анимация появления
    setTimeout(() => element.classList.add('shown'), 10);
  }

  hideNotification(id) {
    const notification = this.notifications.get(id);
    if (notification) {
      const element = document.getElementById(`notification-${id}`);
      if (element) {
        element.classList.remove('shown');
        setTimeout(() => {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }, 300);
      }
      this.notifications.delete(id);
    }
  }

  createNotificationContainer() {
    const container = document.createElement('div');
    container.id = 'notifications-container';
    container.className = 'notifications-container';
    document.body.appendChild(container);
    return container;
  }

  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}
```

### 2. Градуированное восстановление

Реализация восстановления с разным уровнем агрессивности:

```javascript
class GradualRecoveryManager {
  constructor() {
    this.strategies = {
      optimistic: this.optimisticRecovery.bind(this),
      standard: this.standardRecovery.bind(this),
      aggressive: this.aggressiveRecovery.bind(this)
    };
  }

  async recover(error, context) {
    // Определение стратегии на основе типа ошибки
    const strategy = this.determineRecoveryStrategy(error, context);
    return await this.strategies[strategy](error, context);
  }

  determineRecoveryStrategy(error, context) {
    // Определение стратегии на основе критичности ошибки
    if (error.severity === 'low') {
      return 'optimistic';
    } else if (error.severity === 'high' || context.criticalComponent) {
      return 'aggressive';
    } else {
      return 'standard';
    }
  }

  async optimisticRecovery(error, context) {
    console.log('Попытка оптимистичного восстановления');
    
    // Простая попытка повтора
    try {
      return await context.retry();
    } catch (retryError) {
      // Если повтор не помог, применяем стандартную стратегию
      return await this.standardRecovery(retryError, context);
    }
  }

  async standardRecovery(error, context) {
    console.log('Попытка стандартного восстановления');
    
    // Более комплексная стратегия
    const steps = [
      () => this.clearComponentState(context.component),
      () => this.retryOperation(context.operation),
      () => this.useFallbackData(context.fallback)
    ];

    for (const step of steps) {
      try {
        const result = await step();
        if (result) return result;
      } catch (stepError) {
        console.warn('Шаг восстановления не удался:', stepError);
        continue;
      }
    }

    throw error; // Все шаги не удались
  }

  async aggressiveRecovery(error, context) {
    console.log('Попытка агрессивного восстановления');
    
    // Комплексные меры восстановления
    await this.resetComponent(context.component);
    await this.refreshAuthToken();
    await this.purgeCache();
    await this.reinitializeServices();
    
    // Повторная попытка после полного восстановления
    return await context.retry();
  }

  async clearComponentState(component) {
    if (component && typeof component.clearError === 'function') {
      component.clearError();
      return true;
    }
    return false;
  }

  async retryOperation(operation) {
    if (operation) {
      return await operation();
    }
    return false;
  }

  async useFallbackData(fallback) {
    if (fallback) {
      return fallback();
    }
    return false;
  }

  async resetComponent(component) {
    if (component && typeof component.reset === 'function') {
      await component.reset();
    }
  }

  async refreshAuthToken() {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('authToken', data.token);
      }
    } catch (error) {
      console.error('Failed to refresh auth token:', error);
    }
  }

  async purgeCache() {
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      await Promise.all(
        cacheNames.map(name => caches.delete(name))
      );
    }
    
    // Очистка других кэшей
    localStorage.clear();
    sessionStorage.clear();
  }

  async reinitializeServices() {
    // Повторная инициализация критических сервисов
    // В реальной реализации зависит от архитектуры приложения
  }
}
```

## Заключение

Эффективное восстановление после ошибок в фронтенд-приложениях обеспечивает:

- Непрерывность работы приложения
- Улучшенный пользовательский опыт
- Повышенную надежность системы
- Соответствие требованиям российского законодательства по защите данных

Реализация комплексного подхода к восстановлению, включающего изолированное восстановление, повторные попытки, резервные стратегии и автономную работу, делает приложение более устойчивым к различным типам ошибок.

## См. также

- [[Обработка-ошибок]]
- [[Логирование]]
- [[Мониторинг]]
- [[Тестирование]]
- [[Архитектура фронтенд-приложений]]
- [[Безопасность фронтенд-приложений]]