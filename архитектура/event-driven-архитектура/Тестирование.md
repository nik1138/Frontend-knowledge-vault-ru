---
aliases: [Testing Event-Driven Systems, Тестирование событийных систем]
tags: [тестирование, архитектура, events, frontend, programming]
---

# Тестирование событийно-ориентированных систем

## Обзор

Тестирование событийно-ориентированных систем (EDA) представляет собой уникальные вызовы по сравнению с традиционными синхронными приложениями. В таких системах компоненты взаимодействуют через события, что делает тестирование более сложным из-за асинхронности, распределенности и потенциальной сложности отслеживания потока выполнения.

## Особенности тестирования EDA

### 1. Асинхронность
События могут обрабатываться с задержкой, что требует специальных подходов к тестированию.

### 2. Слабая связанность
Компоненты не знают друг о друге напрямую, что усложняет изоляцию и тестирование отдельных частей системы.

### 3. Невозможность предсказать порядок
В системах с несколькими подписчиками порядок обработки событий может быть недетерминированным.

### 4. Сложность отладки
Сложнее отследить путь события через систему и понять, что произошло в случае ошибки.

## Типы тестов для EDA

### 1. Модульные тесты (Unit Tests)

Тестирование отдельных компонентов: издателей, подписчиков, обработчиков событий.

```javascript
// Пример тестирования издателя событий
import { EventBus } from './eventBus';
import { UserService } from './userService';

describe('UserService', () => {
  let eventBus;
  let userService;
  let mockCallback;

  beforeEach(() => {
    eventBus = new EventBus();
    userService = new UserService(eventBus);
    mockCallback = jest.fn();
  });

  test('should publish USER_CREATED event when creating user', () => {
    eventBus.subscribe('USER_CREATED', mockCallback);

    const userData = { name: 'John Doe', email: 'john@example.com' };
    userService.createUser(userData);

    expect(mockCallback).toHaveBeenCalledWith({
      ...userData,
      id: expect.any(String)
    });
  });
});

// Пример тестирования подписчика событий
import { UserProfileUpdater } from './userProfileUpdater';

describe('UserProfileUpdater', () => {
  let profileUpdater;
  let mockState;

  beforeEach(() => {
    mockState = { user: null };
    profileUpdater = new UserProfileUpdater(() => mockState, (newState) => {
      mockState = { ...mockState, ...newState };
    });
  });

  test('should update user profile when USER_UPDATED event is received', () => {
    const userData = { id: '123', name: 'Jane Doe', email: 'jane@example.com' };
    
    profileUpdater.handleUserUpdated(userData);
    
    expect(mockState.user).toEqual(userData);
  });
});
```

### 2. Интеграционные тесты

Тестирование взаимодействия между несколькими компонентами системы.

```javascript
// Тестирование цепочки событий
import { OrderService } from './orderService';
import { InventoryService } from './inventoryService';
import { EventBus } from './eventBus';

describe('Order Processing Integration', () => {
  let eventBus;
  let orderService;
  let inventoryService;
  let orderEvents = [];
  let inventoryEvents = [];

  beforeEach(() => {
    eventBus = new EventBus();
    
    // Подписываемся на все события для проверки
    eventBus.subscribe('ORDER_CREATED', (data) => orderEvents.push({ type: 'ORDER_CREATED', data }));
    eventBus.subscribe('INVENTORY_RESERVED', (data) => inventoryEvents.push({ type: 'INVENTORY_RESERVED', data }));
    
    orderService = new OrderService(eventBus);
    inventoryService = new InventoryService(eventBus);
  });

  afterEach(() => {
    orderEvents = [];
    inventoryEvents = [];
  });

  test('should process order and reserve inventory', async () => {
    const orderData = { 
      orderId: 'ORD-001', 
      items: [{ productId: 'PROD-001', quantity: 2 }] 
    };

    // Создаем заказ
    orderService.createOrder(orderData);

    // Ожидаем, что событие ORDER_CREATED будет опубликовано
    expect(orderEvents).toContainEqual({
      type: 'ORDER_CREATED',
      data: expect.objectContaining({ orderId: 'ORD-001' })
    });

    // Ждем обработки событий
    await new Promise(resolve => setTimeout(resolve, 100));

    // Проверяем, что инвентарь был зарезервирован
    expect(inventoryEvents).toContainEqual({
      type: 'INVENTORY_RESERVED',
      data: expect.objectContaining({ orderId: 'ORD-001' })
    });
  });
});
```

### 3. Тесты потока событий (Event Flow Tests)

Тестирование полного потока обработки событий от начала до конца.

```javascript
// Тестирование сложного потока событий
import { EventFlowTester } from './eventFlowTester';

describe('Complete Event Flow', () => {
  let eventFlowTester;

  beforeEach(() => {
    eventFlowTester = new EventFlowTester();
  });

  test('should handle complete user registration flow', async () => {
    // Подписываемся на ожидаемые события
    const expectedEvents = [
      'USER_REGISTERED',
      'EMAIL_VERIFICATION_SENT',
      'WELCOME_BONUS_GRANTED',
      'NOTIFICATION_SENT'
    ];

    const actualEvents = [];
    expectedEvents.forEach(eventType => {
      eventFlowTester.subscribe(eventType, (data) => {
        actualEvents.push({ type: eventType, data, timestamp: Date.now() });
      });
    });

    // Инициируем поток событий
    const userData = { email: 'test@example.com', name: 'Test User' };
    eventFlowTester.initiateUserRegistration(userData);

    // Ждем завершения потока событий
    await eventFlowTester.waitForEvents(expectedEvents);

    // Проверяем, что все ожидаемые события произошли
    expect(actualEvents.length).toBe(expectedEvents.length);
    expectedEvents.forEach(eventType => {
      expect(actualEvents.some(e => e.type === eventType)).toBe(true);
    });

    // Проверяем порядок событий
    const eventOrder = actualEvents.map(e => e.type);
    expect(eventOrder).toEqual(expectedEvents);
  });
});
```

## Паттерны тестирования

### 1. Тестирование через фиксированные точки

```javascript
// Использование тестовых заглушек для событий
class TestEventBus {
  constructor() {
    this.events = [];
    this.subscribers = new Map();
  }

  publish(eventType, data) {
    this.events.push({ type: eventType, data, timestamp: Date.now() });
    
    const subscribers = this.subscribers.get(eventType) || [];
    subscribers.forEach(callback => callback(data));
  }

  subscribe(eventType, callback) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType).push(callback);
  }

  getEventsOfType(eventType) {
    return this.events.filter(e => e.type === eventType);
  }

  clear() {
    this.events = [];
  }
}

// Использование в тестах
describe('User Service with Test Event Bus', () => {
  let testEventBus;
  let userService;

  beforeEach(() => {
    testEventBus = new TestEventBus();
    userService = new UserService(testEventBus);
  });

  test('should publish correct events in correct order', () => {
    const userData = { name: 'John', email: 'john@example.com' };
    userService.createUser(userData);

    const userCreatedEvents = testEventBus.getEventsOfType('USER_CREATED');
    const emailSentEvents = testEventBus.getEventsOfType('WELCOME_EMAIL_SENT');

    expect(userCreatedEvents.length).toBe(1);
    expect(emailSentEvents.length).toBe(1);
    
    // Проверяем, что событие создания пользователя произошло раньше отправки email
    expect(userCreatedEvents[0].timestamp).toBeLessThanOrEqual(emailSentEvents[0].timestamp);
  });
});
```

### 2. Тестирование с ожиданием асинхронных событий

```javascript
// Утилита для ожидания событий
class EventWaiter {
  static async waitForEvent(eventBus, eventType, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Timeout waiting for event: ${eventType}`));
      }, timeout);

      const unsubscribe = eventBus.subscribe(eventType, (data) => {
        clearTimeout(timeoutId);
        unsubscribe();
        resolve(data);
      });
    });
  }

  static async waitForMultipleEvents(eventBus, eventTypes, timeout = 5000) {
    const promises = eventTypes.map(eventType => 
      this.waitForEvent(eventBus, eventType, timeout)
    );
    return Promise.all(promises);
  }
}

// Использование в тестах
describe('Async Event Testing', () => {
  test('should handle async event processing', async () => {
    const eventBus = new EventBus();
    const service = new AsyncProcessingService(eventBus);

    // Запускаем асинхронный процесс
    service.startLongRunningProcess();

    // Ожидаем события
    const processData = await EventWaiter.waitForEvent(eventBus, 'PROCESS_STARTED');
    expect(processData.status).toBe('started');

    const completionData = await EventWaiter.waitForEvent(eventBus, 'PROCESS_COMPLETED');
    expect(completionData.status).toBe('completed');
  });
});
```

### 3. Тестирование с использованием моков и стабов

```javascript
// Создание моков для внешних систем
class MockEventPublisher {
  constructor() {
    this.publishedEvents = [];
  }

  publish(eventType, data) {
    this.publishedEvents.push({ type: eventType, data, timestamp: Date.now() });
  }

  reset() {
    this.publishedEvents = [];
  }

  getLastEventOfType(eventType) {
    return this.publishedEvents
      .filter(e => e.type === eventType)
      .pop();
  }

  getAllEventsOfType(eventType) {
    return this.publishedEvents.filter(e => e.type === eventType);
  }
}

// Тестирование с моками
describe('Service with Mock Publisher', () => {
  let mockPublisher;
  let service;

  beforeEach(() => {
    mockPublisher = new MockEventPublisher();
    service = new ServiceWithExternalPublisher(mockPublisher);
  });

  test('should publish correct events to external system', async () => {
    const inputData = { userId: '123', action: 'purchase' };
    await service.processUserAction(inputData);

    const publishedEvent = mockPublisher.getLastEventOfType('USER_ACTION_PROCESSED');
    expect(publishedEvent).toBeDefined();
    expect(publishedEvent.data).toEqual({
      userId: '123',
      action: 'purchase',
      processedAt: expect.any(Number)
    });
  });
});
```

## Тестирование с TypeScript

```typescript
// Типизированные тесты для событий
interface EventMap {
  USER_CREATED: { id: string; name: string; email: string };
  USER_UPDATED: { id: string; updates: Partial<{ name: string; email: string }> };
  USER_DELETED: { id: string };
}

type EventType = keyof EventMap;

class TypedTestEventBus {
  private events: { [K in EventType]?: Array<EventMap[K]> } = {};
  private subscribers: { [K in EventType]?: Array<(data: EventMap[K]) => void> } = {};

  publish<K extends EventType>(eventType: K, data: EventMap[K]): void {
    if (!this.events[eventType]) {
      this.events[eventType] = [];
    }
    (this.events[eventType] as Array<EventMap[K]>).push(data);

    const subscribers = this.subscribers[eventType] as Array<(data: EventMap[K]) => void> | undefined;
    if (subscribers) {
      subscribers.forEach(callback => callback(data));
    }
  }

  subscribe<K extends EventType>(eventType: K, callback: (data: EventMap[K]) => void): () => void {
    if (!this.subscribers[eventType]) {
      this.subscribers[eventType] = [];
    }
    (this.subscribers[eventType] as Array<(data: EventMap[K]) => void>).push(callback);

    // Возвращаем функцию отписки
    return () => {
      const index = (this.subscribers[eventType] as Array<(data: EventMap[K]) => void>)
        .indexOf(callback as (data: EventMap[K]) => void);
      if (index > -1) {
        (this.subscribers[eventType] as Array<(data: EventMap[K]) => void>).splice(index, 1);
      }
    };
  }

  getEvents<K extends EventType>(eventType: K): EventMap[K][] {
    return (this.events[eventType] || []) as EventMap[K][];
  }

  clear(): void {
    this.events = {};
  }
}

// Типизированные тесты
describe('Typed Event Testing', () => {
  let eventBus: TypedTestEventBus;
  let userService: UserService;

  beforeEach(() => {
    eventBus = new TypedTestEventBus();
    userService = new UserService(eventBus);
  });

  test('should create user and publish typed event', () => {
    const userData = { name: 'John Doe', email: 'john@example.com' };
    userService.createUser(userData);

    const userCreatedEvents = eventBus.getEvents('USER_CREATED');
    expect(userCreatedEvents.length).toBe(1);
    
    const event = userCreatedEvents[0];
    expect(event).toEqual({
      id: expect.any(String),
      name: 'John Doe',
      email: 'john@example.com'
    });
  });
});
```

## Инструменты для тестирования EDA

### 1. Использование Jest для тестирования событий

```javascript
// Использование Jest для тестирования асинхронных событий
describe('Jest Event Testing', () => {
  test('should handle events with async/await', async () => {
    const eventBus = new EventBus();
    const service = new AsyncEventService(eventBus);

    // Подписываемся на событие
    const eventPromise = new Promise(resolve => {
      eventBus.subscribe('DATA_PROCESSED', resolve);
    });

    // Запускаем процесс
    service.processData({ id: 1, value: 'test' });

    // Ожидаем событие
    await expect(eventPromise).resolves.toEqual(
      expect.objectContaining({ id: 1, value: 'test', status: 'processed' })
    );
  });

  test('should test event order with Jest', async () => {
    const eventBus = new EventBus();
    const events: any[] = [];

    eventBus.subscribe('EVENT_A', (data) => events.push({ type: 'EVENT_A', data }));
    eventBus.subscribe('EVENT_B', (data) => events.push({ type: 'EVENT_B', data }));

    const service = new OrderedEventService(eventBus);
    service.startProcess();

    // Ждем, пока все события не будут обработаны
    await new Promise(resolve => setTimeout(resolve, 200));

    // Проверяем порядок событий
    expect(events).toEqual([
      { type: 'EVENT_A', data: expect.any(Object) },
      { type: 'EVENT_B', data: expect.any(Object) }
    ]);
  });
});
```

### 2. Использование специализированных библиотек

```javascript
// Пример использования библиотеки для тестирования событий
import { EventTester } from 'event-tester-library';

describe('Advanced Event Testing', () => {
  test('should test complex event scenarios', async () => {
    const eventTester = new EventTester();

    // Устанавливаем ожидаемые события
    eventTester.expectEvents([
      { type: 'USER_LOGIN', payload: { userId: '123' } },
      { type: 'SESSION_CREATED', payload: { sessionId: expect.any(String) } },
      { type: 'USER_PROFILE_LOADED', payload: { userId: '123' } }
    ]);

    // Выполняем действие
    const authService = new AuthService(eventTester.eventBus);
    await authService.login('user@example.com', 'password');

    // Проверяем, что все ожидаемые события произошли
    await eventTester.verify();
  });
});
```

## Российские реалии и особенности 2025

В 2025 году тестирование событийно-ориентированных систем в российской разработке имеет следующие особенности:

- Необходимость тестирования интеграции с отечественными сервисами и API
- Требования к высокой надежности систем в условиях нестабильной инфраструктуры
- Увеличение сложности тестирования из-за перехода на отечественные решения
- Акцент на тестирование производительности и отказоустойчивости

Российские компании также сталкиваются с необходимостью тестирования систем в оффлайн-режимах и с ограниченным доступом к зарубежным сервисам.

## Лучшие практики тестирования

### 1. Изолированное тестирование компонентов

Тестируйте каждый компонент (издатель, подписчик, обработчик) отдельно с использованием моков.

### 2. Тестирование граничных условий

Проверяйте поведение системы при сбоях, таймаутах и других исключительных ситуациях.

### 3. Тестирование производительности

Проверяйте, как система ведет себя под нагрузкой и при большом количестве событий.

### 4. Использование тестовых двойников

Создавайте специальные тестовые реализации для внешних систем и сервисов.

### 5. Логирование и отслеживание

Обеспечьте возможность отслеживания потока событий для целей отладки.

## Связанные концепции

- [[Событийная-архитектура]]
- [[Pub-Sub]]
- [[Event-sourcing]]
- [[CQRS]]

## Заключение

Тестирование событийно-ориентированных систем требует специального подхода из-за их асинхронной и распределенной природы. Успешное тестирование таких систем включает в себя комбинацию модульных, интеграционных и сквозных тестов, а также использование специализированных инструментов и подходов. При правильной реализации тестирование EDA систем позволяет обеспечить высокую надежность и производительность приложений.