---
aliases: [Тестирование реактивного кода, Тестирование RxJS, Проверка Observables]
tags: [testing, rxjs, reactive, observables, jasmine, jest, unit-tests, integration]
---

# Тестирование реактивного кода

**Тестирование реактивного кода** — это процесс проверки корректности работы потоков данных, Observables и реактивных паттернов в приложениях. В условиях российской разработки 2025 года это особенно важно для обеспечения надежности сложных интерактивных приложений.

## Особенности тестирования реактивного кода

### Асинхронность
Реактивный код по своей природе асинхронен, что требует специального подхода к тестированию:
- Обработка временных задержек
- Проверка последовательности событий
- Управление временными зависимостями

### Потоковая природа
- Тестирование потоков данных вместо отдельных значений
- Проверка трансформаций и комбинаций
- Учет состояния между испусканиями значений

### Состояние и побочные эффекты
- Проверка состояния приложения
- Тестирование сайд-эффектов
- Управление внешними зависимостями

## Инструменты для тестирования

### Jasmine и Karma
```javascript
// Пример теста с использованием Jasmine и RxJS marble testing
import { TestScheduler } from 'rxjs/testing';
import { map, filter } from 'rxjs/operators';

describe('Reactive stream tests', () => {
  let testScheduler: TestScheduler;

  beforeEach(() => {
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });

  it('should filter and map values correctly', () => {
    testScheduler.run(({ cold, expectObservable }) => {
      const source$ = cold('-1-2-3-4-5-|', { 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 });
      const expected = '   -1---3---5-|';
      
      const result$ = source$.pipe(
        filter(value => value % 2 !== 0),
        map(value => value * 2)
      );
      
      expectObservable(result$).toBe(expected, { 1: 2, 3: 6, 5: 10 });
    });
  });
});
```

### Jest
```javascript
// Пример теста с использованием Jest
import { of, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { TestScheduler } from 'rxjs/testing';

describe('Jest reactive tests', () => {
  test('should handle success case', done => {
    const source$ = of(1, 2, 3);
    
    source$.pipe(
      map(x => x * 2)
    ).subscribe({
      next: value => expect(value).toBeLessThan(7), // 2, 4, 6 < 7
      complete: done
    });
  });

  test('should handle error case', done => {
    const error$ = throwError(() => new Error('Test error'));
    
    error$.pipe(
      catchError(err => of('default value'))
    ).subscribe({
      next: value => expect(value).toBe('default value'),
      complete: done
    });
  });
});
```

## Типы тестов для реактивного кода

### Unit-тесты Observables

```javascript
import { cold, hot } from 'jasmine-marbles';
import { map, filter, switchMap } from 'rxjs/operators';

describe('Observable unit tests', () => {
  it('should transform values correctly', () => {
    const source = cold('-1-2-3-|', { 1: 10, 2: 20, 3: 30 });
    const expected = '  -a-b-c-|';
    const values = { a: 100, b: 200, c: 300 };
    
    expect(source.pipe(
      map(value => value * 10)
    )).toBeObservable(expected, values);
  });

  it('should filter values correctly', () => {
    const source = cold('-1-2-3-4-5-|', { 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 });
    const expected = '  -1---3---5-|';
    
    expect(source.pipe(
      filter(value => value % 2 !== 0)
    )).toBeObservable(expected);
  });
});
```

### Integration-тесты компонентов

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { of } from 'rxjs';
import { MyReactiveComponent } from './my-reactive.component';

describe('Integration tests for reactive components', () => {
  let component: MyReactiveComponent;
  let fixture: ComponentFixture<MyReactiveComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [MyReactiveComponent]
    })
    .overrideProvider(MyReactiveService, {
      useValue: {
        getDataStream: () => of([{ id: 1, name: 'Test' }])
      }
    })
    .compileComponents();
  });

  it('should update UI when observable emits', async () => {
    fixture = TestBed.createComponent(MyReactiveComponent);
    component = fixture.componentInstance;
    
    fixture.detectChanges();
    await fixture.whenStable();
    
    const element = fixture.debugElement.query(By.css('.data-item'));
    expect(element.nativeElement.textContent).toContain('Test');
  });
});
```

## Тестирование различных операторов

### Тестирование map, filter, и других transformation operators

```javascript
import { of } from 'rxjs';
import { map, filter, scan } from 'rxjs/operators';

describe('Transformation operators tests', () => {
  test('map should transform each value', done => {
    of(1, 2, 3).pipe(
      map(x => x * 2)
    ).subscribe({
      next: value => expect([2, 4, 6]).toContain(value),
      complete: done
    });
  });

  test('scan should accumulate values', done => {
    of(1, 2, 3, 4).pipe(
      scan((acc, curr) => acc + curr, 0)
    ).subscribe({
      next: value => {
        // Последовательно: 1, 3, 6, 10
        expect([1, 3, 6, 10]).toContain(value);
      },
      complete: done
    });
  });
});
```

### Тестирование combination operators

```javascript
import { combineLatest, merge, forkJoin } from 'rxjs';

describe('Combination operators tests', () => {
  test('combineLatest should combine latest values', done => {
    const obs1 = of(1, 2);
    const obs2 = of('a', 'b');
    
    combineLatest([obs1, obs2]).subscribe({
      next: ([num, str]) => {
        expect(typeof num).toBe('number');
        expect(typeof str).toBe('string');
      },
      complete: done
    });
  });

  test('merge should combine emissions', done => {
    const obs1 = of(1, 3);
    const obs2 = of(2, 4);
    
    // Ожидаемые значения могут прийти в любом порядке
    const results: number[] = [];
    merge(obs1, obs2).subscribe({
      next: value => results.push(value),
      complete: () => {
        expect(results.sort()).toEqual([1, 2, 3, 4]);
        done();
      }
    });
  });
});
```

### Тестирование flattening operators

```javascript
import { of } from 'rxjs';
import { switchMap, mergeMap, concatMap } from 'rxjs/operators';

describe('Flattening operators tests', () => {
  test('switchMap should cancel previous inner observables', done => {
    const outer$ = of(1, 2, 3);
    
    outer$.pipe(
      switchMap(id => of(`result-${id}`))
    ).subscribe({
      next: value => expect(['result-1', 'result-2', 'result-3']).toContain(value),
      complete: done
    });
  });
});
```

## Тестирование HTTP-запросов

```typescript
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { TestBed } from '@angular/core/testing';
import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { delay, map } from 'rxjs/operators';

describe('HTTP request testing', () => {
  let httpClient: HttpClient;
  let httpTestingController: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule]
    });

    httpClient = TestBed.inject(HttpClient);
    httpTestingController = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpTestingController.verify();
  });

  it('should handle HTTP GET request', () => {
    const mockData = { id: 1, name: 'Test User' };
    
    const result$ = httpClient.get('/api/users/1').pipe(
      map((response: any) => response.data)
    );

    result$.subscribe(data => {
      expect(data).toEqual(mockData);
    });

    const req = httpTestingController.expectOne('/api/users/1');
    expect(req.request.method).toBe('GET');
    req.flush({ data: mockData });
  });
});
```

## Тестирование пользовательских событий

```javascript
import { fromEvent } from 'rxjs';
import { debounceTime, map } from 'rxjs/operators';

describe('User events testing', () => {
  it('should handle input events with debounce', done => {
    // Создаем фальшивый элемент для тестирования
    const input = document.createElement('input');
    const input$ = fromEvent(input, 'input').pipe(
      map((event: any) => event.target.value),
      debounceTime(10) // Очень короткая задержка для тестов
    );

    input$.subscribe({
      next: value => {
        expect(value).toBe('test');
        done();
      }
    });

    // Имитируем ввод
    input.value = 'test';
    input.dispatchEvent(new Event('input'));
  });
});
```

## Mocking и Stubbing в реактивных тестах

### Создание моков для Observables

```javascript
// Service мок
export class MockDataService {
  getData$ = of([{ id: 1, name: 'Mocked Data' }]);
  
  postData$ = (data: any) => of({ ...data, id: 123 });
  
  getError$ = throwError(() => new Error('Mocked error'));
}

// Использование в тестах
describe('Component with mocked service', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        { provide: DataService, useClass: MockDataService }
      ]
    });
  });
});
```

### Использование Subjects для тестирования

```javascript
import { Subject } from 'rxjs';

describe('Testing with Subjects', () => {
  let dataSubject: Subject<any>;
  let component: MyComponent;

  beforeEach(() => {
    dataSubject = new Subject();
    component = new MyComponent(dataSubject.asObservable());
  });

  it('should react to subject emissions', () => {
    const spy = jest.spyOn(component, 'handleData');
    
    dataSubject.next({ test: 'data' });
    
    expect(spy).toHaveBeenCalledWith({ test: 'data' });
  });
});
```

## Тестирование ошибок и обработки исключений

```javascript
import { throwError } from 'rxjs';
import { catchError, retry } from 'rxjs/operators';

describe('Error handling tests', () => {
  test('should handle errors gracefully', done => {
    throwError(() => new Error('Test error')).pipe(
      catchError(error => {
        expect(error.message).toBe('Test error');
        return of('default value');
      })
    ).subscribe({
      next: value => {
        expect(value).toBe('default value');
        done();
      }
    });
  });

  test('should retry on failure', done => {
    let attempts = 0;
    const failingObservable = () => {
      attempts++;
      if (attempts < 3) {
        return throwError(() => new Error('Attempt failed'));
      }
      return of('success');
    };

    failingObservable().pipe(
      retry(3),
      catchError(() => of('fallback'))
    ).subscribe({
      next: value => {
        expect(value).toBe('success');
        expect(attempts).toBe(3);
        done();
      }
    });
  });
});
```

## Тестирование производительности реактивных потоков

```javascript
describe('Performance tests', () => {
  test('should not create memory leaks', () => {
    const observable$ = interval(10).pipe(
      take(1000), // Ограничиваем количество испусканий
      share() // Разделяем выполнение между подписчиками
    );

    const subscription1 = observable$.subscribe();
    const subscription2 = observable$.subscribe();
    
    // Проверяем, что мы можем отписаться и освободить ресурсы
    setTimeout(() => {
      subscription1.unsubscribe();
      subscription2.unsubscribe();
    }, 100);
  });

  test('should handle high-frequency emissions', (done) => {
    const start = performance.now();
    
    range(1, 10000).pipe(
      bufferCount(1000), // Буферизация для производительности
      take(10)
    ).subscribe({
      complete: () => {
        const duration = performance.now() - start;
        expect(duration).toBeLessThan(1000); // Должно выполниться менее чем за 1 секунду
        done();
      }
    });
  });
});
```

## Практические рекомендации для российской разработки 2025 года

### 1. Использование marble diagrams
Marble diagrams позволяют визуализировать потоки данных и упрощают тестирование сложных комбинаций операторов:

```javascript
// Пример marble теста
it('should debounce and filter correctly', () => {
  testScheduler.run(({ cold, expectObservable }) => {
    // 100ms между каждым символом
    const source = cold('a-b-c----d--e--f--|', { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 });
    const expected = '   ---c--------e-----|'; // Только нечетные значения после debounce
    
    expect(source.pipe(
      debounceTime(150, testScheduler),
      filter(value => value % 2 !== 0)
    )).toBeObservable(expected);
  });
});
```

### 2. Тестирование с временными зависимостями
```javascript
import { TestScheduler } from 'rxjs/testing';

describe('Time-based operators', () => {
  let testScheduler: TestScheduler;

  beforeEach(() => {
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });

  it('should handle interval correctly', () => {
    testScheduler.run(({ expectObservable }) => {
      const expected = '1s (a|) 1s (a|) 1s (a|)'; // a испускается каждые 2 секунды
      
      expectObservable(
        interval(2000, testScheduler).pipe(
          take(3),
          map(() => 'a')
        )
      ).toBe(expected, { a: 'tick' });
    });
  });
});
```

### 3. Тестирование сайд-эффектов
```javascript
import { tap } from 'rxjs/operators';

describe('Side effects testing', () => {
  test('should call side effect function', () => {
    const spy = jasmine.createSpy('sideEffect');
    const source$ = of(1, 2, 3);
    
    source$.pipe(
      tap(spy)
    ).subscribe();
    
    expect(spy).toHaveBeenCalledTimes(3);
    expect(spy).toHaveBeenCalledWith(1);
    expect(spy).toHaveBeenCalledWith(2);
    expect(spy).toHaveBeenCalledWith(3);
  });
});
```

## Общие рекомендации

### 1. Покрытие тестами
- Тестируйте как успешные сценарии, так и ошибки
- Проверяйте все ветки логики
- Уделяйте внимание граничным условиям

### 2. Структура тестов
- Используйте AAA (Arrange-Act-Assert) или BDD структуру
- Давайте понятные имена тестам
- Изолируйте каждый тест

### 3. Утилиты для тестирования
Создайте утилиты для часто используемых паттернов тестирования:

```javascript
// Утилита для тестирования Observable с ожиданием завершения
export const testObservableCompletion = <T>(observable$: Observable<T>, expectedValues: T[]) => {
  return new Promise<void>((resolve, reject) => {
    const results: T[] = [];
    
    observable$.subscribe({
      next: value => results.push(value),
      complete: () => {
        try {
          expect(results).toEqual(expectedValues);
          resolve();
        } catch (error) {
          reject(error);
        }
      },
      error: reject
    });
  });
};
```

## Связь с другими концепциями

- [[Реактивное-программирование]] — основная парадигма
- [[RxJS]] — основная библиотека для тестирования
- [[Observables]] — тестируемый объект
- [[Потоки-данных]] — архитектурный паттерн
- [[State-менеджмент]] — тестирование управления состоянием

## Заключение

Тестирование реактивного кода требует особого подхода из-за его асинхронной и потоковой природы. В российских реалиях 2025 года, с увеличением сложности веб-приложений, качественное тестирование реактивных потоков становится критически важным для обеспечения надежности и стабильности приложений.

> [!tip]
> Используйте marble тесты для сложных комбинаций операторов — они делают тесты более наглядными и легкими для понимания.

> [!warning]
> Не забывайте про тестирование отписок и управления ресурсами — это критически важно для предотвращения утечек памяти в реактивных приложениях.