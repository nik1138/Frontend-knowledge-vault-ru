---
aliases: ["Компонентный подход", "Архитектура компонентов", "Компоненты UI"]
tags: [frontend, architecture, components, ui]
---

# Компонентная архитектура фронтенд-приложений

## Введение

Компонентная архитектура — это подход к разработке пользовательского интерфейса, при котором интерфейс разбивается на независимые, повторно используемые компоненты. В 2025 году в российской ИТ-индустрии компонентный подход стал стандартом де-факто для создания современных веб-приложений, особенно в свете необходимости быстрой адаптации к смене технологий и требованиям локализации.

## Основы компонентной архитектуры

### Что такое компонент

Компонент — это независимый, самодостаточный блок пользовательского интерфейса, который инкапсулирует:

- Структуру (HTML/JSX)
- Стили (CSS/SCSS)
- Логику (JavaScript/TypeScript)
- Состояние (props, state)

```tsx
// Пример компонента
const Button = ({ 
  children, 
  variant = 'primary', 
  onClick 
}: {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  onClick?: () => void;
}) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

### Принципы компонентной архитектуры

#### 1. Самодостаточность

Каждый компонент должен быть способен работать независимо от других компонентов. Это достигается через:

- Ясные интерфейсы (props)
- Инкапсуляцию состояния
- Минимальные зависимости от внешнего контекста

#### 2. Повторное использование

Компоненты должны быть спроектированы так, чтобы их можно было использовать в разных частях приложения:

- Обобщенные компоненты с параметрами
- Композиция вместо наследования
- Библиотеки компонентов

#### 3. Композиция

Сложные интерфейсы строятся путем комбинирования простых компонентов:

```tsx
// Композиция компонентов
const UserProfile = () => (
  <Card>
    <Avatar />
    <UserInfo />
    <UserActions />
  </Card>
);
```

## Типы компонентов

### Представления (Dumb/Presentational Components)

Компоненты, отвечающие только за отображение данных:

- Получают данные через props
- Не имеют собственного состояния
- Не зависят от внешнего контекста
- Легко тестируются

```tsx
const UserCard = ({ user, showEmail = false }: { 
  user: User; 
  showEmail?: boolean; 
}) => (
  <div className="user-card">
    <h3>{user.name}</h3>
    {showEmail && <p>{user.email}</p>}
  </div>
);
```

### Контейнеры (Smart/Container Components)

Компоненты, отвечающие за логику и управление состоянием:

- Получают данные из внешних источников
- Управляют состоянием
- Передают данные в представления

```tsx
const UserContainer = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser().then(data => {
      setUser(data);
      setLoading(false);
    });
  }, []);
  
  if (loading) return <LoadingSpinner />;
  
  return <UserCard user={user} />;
};
```

### Хуки (Hooks)

Функции, которые позволяют использовать состояние и другие возможности React без написания классов:

```tsx
const useUser = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);
  
  return { user, loading };
};
```

## Архитектура компонентов

### Структура проекта

Эффективная компонентная архитектура начинается с правильной структуры проекта:

```
src/
├── components/
│   ├── ui/                 # Базовые UI-компоненты
│   │   ├── Button/
│   │   ├── Input/
│   │   └── Modal/
│   ├── layout/             # Компоненты макета
│   │   ├── Header/
│   │   ├── Sidebar/
│   │   └── Footer/
│   └── features/           # Функциональные компоненты
│       ├── User/
│       ├── Product/
│       └── Cart/
├── hooks/                  # Пользовательские хуки
├── services/               # Сервисы
├── types/                  # Типы TypeScript
└── lib/                    # Вспомогательные функции
```

### Уровни компонентов

#### 1. Атомы (Atoms)

Наименьшие элементы интерфейса:

- Кнопки
- Инпуты
- Лейблы
- Иконки

#### 2. Молекулы (Molecules)

Комбинации атомов:

- Форма поиска (инпут + кнопка)
- Карточка пользователя (аватар + имя + статус)

#### 3. Организмы (Organisms)

Комбинации молекул:

- Навигационная панель
- Профиль пользователя
- Форма заказа

#### 4. Шаблоны (Templates)

Структура страниц:

- Макеты страниц
- Расположение компонентов

#### 5. Страницы (Pages)

Конкретные страницы приложения:

- Главная
- Профиль
- Каталог

### Структура компонента

Хорошо организованный компонент обычно имеет следующую структуру:

```tsx
// 1. Импорты
import React, { useState, useEffect } from 'react';
import { Button } from '../ui/Button';
import { User } from '../../types/user';

// 2. Типы и интерфейсы
interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (id: string) => void;
}

// 3. Константы
const USER_CARD_CLASS = 'user-card';

// 4. Компонент
const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  // 5. Состояние
  const [isEditing, setIsEditing] = useState(false);
  
  // 6. Вспомогательные функции
  const handleEdit = () => {
    setIsEditing(true);
    onEdit?.(user);
  };
  
  // 7. JSX
  return (
    <div className={USER_CARD_CLASS}>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <Button onClick={handleEdit}>Edit</Button>
      <Button onClick={() => onDelete?.(user.id)}>Delete</Button>
    </div>
  );
};

// 8. Экспорт
export default UserCard;
```

## Практические аспекты

### Управление состоянием компонентов

#### Локальное состояние

Для простых случаев используйте встроенные хуки:

- `useState` для простого состояния
- `useReducer` для сложного состояния
- `useContext` для глобального состояния

```tsx
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  
  return { count, increment, decrement };
};
```

#### Глобальное состояние

Для сложных приложений используйте специализированные решения:

- [[Redux]] с [[Redux Toolkit]]
- [[Zustand]]
- [[Jotai]]
- [[Recoil]]

### Стилизация компонентов

#### CSS Modules

Изолированные стили для каждого компонента:

```css
/* UserCard.module.css */
.card {
  border: 1px solid #ccc;
  padding: 1rem;
  border-radius: 4px;
}

.name {
  font-weight: bold;
  color: #333;
}
```

```tsx
import styles from './UserCard.module.css';

const UserCard = () => (
  <div className={styles.card}>
    <h3 className={styles.name}>John Doe</h3>
  </div>
);
```

#### Styled Components

CSS-in-JS решение:

```tsx
import styled from 'styled-components';

const Card = styled.div`
  border: 1px solid #ccc;
  padding: 1rem;
  border-radius: 4px;
`;

const Name = styled.h3`
  font-weight: bold;
  color: #333;
`;

const UserCard = () => (
  <Card>
    <Name>John Doe</Name>
  </Card>
);
```

### Тестирование компонентов

#### Модульное тестирование

Тестируйте компоненты изолированно:

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import UserCard from './UserCard';

describe('UserCard', () => {
  const mockUser = { id: '1', name: 'John Doe', email: 'john@example.com' };
  
  it('renders user information', () => {
    render(<UserCard user={mockUser} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
  
  it('calls onEdit when edit button is clicked', () => {
    const onEdit = jest.fn();
    render(<UserCard user={mockUser} onEdit={onEdit} />);
    
    fireEvent.click(screen.getByText('Edit'));
    expect(onEdit).toHaveBeenCalledWith(mockUser);
  });
});
```

## Российские особенности и требования

### Локализация

Компоненты должны поддерживать:

- Множественные языки
- Правильное форматирование дат, чисел и валют
- RTL (справа налево) направление текста

```tsx
const LocalizedDate = ({ date }: { date: Date }) => {
  const formattedDate = new Intl.DateTimeFormat('ru-RU').format(date);
  return <span>{formattedDate}</span>;
};
```

### Доступность (Accessibility)

Компоненты должны соответствовать требованиям доступности:

- ARIA-атрибуты
- Клавиатурная навигация
- Поддержка скринридеров

```tsx
const AccessibleButton = ({ 
  children, 
  onClick 
}: { 
  children: React.ReactNode; 
  onClick: () => void; 
}) => (
  <button 
    onClick={onClick}
    aria-label="Кнопка действия"
    role="button"
    tabIndex={0}
  >
    {children}
  </button>
);
```

### Безопасность

- Защита от XSS-атак
- Санитизация пользовательского ввода
- Правильная обработка данных

## Паттерны компонентной архитектуры

### Compound Components

Паттерн, при котором компоненты работают вместе через общее контекстное API:

```tsx
const Select = ({ children, value, onChange }) => (
  <select value={value} onChange={onChange}>
    {children}
  </select>
);

const Option = ({ value, children }) => (
  <option value={value}>{children}</option>
);

// Использование
<Select value={selectedValue} onChange={handleChange}>
  <Option value="1">Option 1</Option>
  <Option value="2">Option 2</Option>
</Select>
```

### Render Props

Паттерн, при котором компонент получает функцию для отображения:

```tsx
const DataProvider = ({ render, url }) => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch(url).then(res => res.json()).then(setData);
  }, [url]);
  
  return render(data);
};

// Использование
<DataProvider 
  url="/api/users" 
  render={(users) => <UserList users={users} />} 
/>
```

### Higher-Order Components (HOC)

Функции, которые принимают компонент и возвращают новый компонент:

```tsx
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <LoadingSpinner />;
    }
    return <WrappedComponent {...props} />;
  };
};

const UserCardWithLoading = withLoading(UserCard);
```

## Библиотеки компонентов

### Внутренние библиотеки

Для крупных проектов рекомендуется создавать внутренние библиотеки компонентов:

- Единый дизайн-система
- Согласованное поведение
- Повторное использование

### Популярные библиотеки

- [[Ant Design]] - полнофункциональная библиотека компонентов
- [[Material-UI]] - компоненты в стиле Material Design
- [[Chakra UI]] - доступная, модульная библиотека
- [[Radix UI]] - нестилизованные примитивы для построения компонентов

## Заключение

Компонентная архитектура фронтенд-приложений в 2025 году требует глубокого понимания не только технических аспектов, но и контекста разработки, особенно в российских реалиях. Правильная архитектура компонентов позволяет создавать масштабируемые, поддерживаемые и безопасные приложения.

Ключевые моменты:

1. Следование принципам компонентной архитектуры
2. Учет требований локализации и доступности
3. Поддержка безопасности
4. Возможность быстрой адаптации к изменениям

Для более глубокого понимания модульности приложений см. [[Модульность]].

## См. также

- [[Основы-архитектуры]]
- [[Принципы-архитектуры]]
- [[Архитектурные-паттерны]]
- [[Модульность]]