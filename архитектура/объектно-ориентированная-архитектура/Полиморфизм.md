---
aliases: ["Полиморфизм в JavaScript", "Интерфейсы в JavaScript", "Переопределение методов"]
tags: ["#programming", "#javascript", "#oop", "#polymorphism", "#frontend", "#interfaces", "#inheritance"]
---

# Полиморфизм в объектно-ориентированной архитектуре фронтенда

## Обзор

Полиморфизм - один из ключевых принципов объектно-ориентированного программирования, позволяющий объектам разных классов обрабатываться одинаково через общий интерфейс. В фронтенд-разработке 2025 года полиморфизм играет важную роль в создании гибких, расширяемых и легко поддерживаемых пользовательских интерфейсов.

## Понятие полиморфизма

Полиморфизм позволяет:

- Использовать объекты разных типов через общий интерфейс
- Повторно использовать код без знания конкретного типа объекта
- Легко расширять функциональность за счет добавления новых типов
- Создавать гибкие архитектурные решения

В JavaScript полиморфизм реализуется через:

- Наследование классов
- Общие методы у разных объектов
- Прототипное наследование
- Паттерн стратегия

## Основы полиморфизма

### 1. Простой пример полиморфизма

```javascript
// Базовый класс
class Shape {
  constructor(color) {
    this.color = color;
  }
  
  // Абстрактный метод, который должен быть реализован в дочерних классах
  draw() {
    throw new Error('Метод draw должен быть реализован');
  }
  
  // Метод, общий для всех фигур
  getColor() {
    return this.color;
  }
}

// Конкретные реализации
class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }
  
  draw() {
    return `Круг радиусом ${this.radius}, цвет: ${this.color}`;
  }
  
  getArea() {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }
  
  draw() {
    return `Прямоугольник ${this.width}x${this.height}, цвет: ${this.color}`;
  }
  
  getArea() {
    return this.width * this.height;
  }
}

class Triangle extends Shape {
  constructor(color, base, height) {
    super(color);
    this.base = base;
    this.height = height;
  }
  
  draw() {
    return `Треугольник с основанием ${this.base} и высотой ${this.height}, цвет: ${this.color}`;
  }
  
  getArea() {
    return 0.5 * this.base * this.height;
  }
}

// Полиморфное использование
function renderShapes(shapes) {
  shapes.forEach(shape => {
    // Независимо от типа фигуры, мы можем вызвать метод draw()
    console.log(shape.draw());
  });
}

// Использование
const shapes = [
  new Circle('красный', 5),
  new Rectangle('синий', 10, 8),
  new Triangle('зеленый', 6, 4)
];

renderShapes(shapes);
// Вывод:
// Круг радиусом 5, цвет: красный
// Прямоугольник 10x8, цвет: синий
// Треугольник с основанием 6 и высотой 4, цвет: зеленый
```

### 2. Полиморфизм с DOM-элементами

```javascript
// Базовый класс UI-компонента
class UIComponent {
  constructor(container) {
    this.container = container;
    this.element = null;
  }
  
  // Абстрактный метод рендеринга
  render() {
    if (!this.element) {
      this.createElement();
    }
    this.container.appendChild(this.element);
    return this.element;
  }
  
  // Абстрактный метод создания элемента
  createElement() {
    throw new Error('Метод createElement должен быть реализован');
  }
  
  // Общий метод для всех компонентов
  show() {
    if (this.element) {
      this.element.style.display = 'block';
    }
  }
  
  hide() {
    if (this.element) {
      this.element.style.display = 'none';
    }
  }
  
  destroy() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
}

// Конкретные компоненты
class Button extends UIComponent {
  constructor(container, text, onClick) {
    super(container);
    this.text = text;
    this.onClick = onClick;
  }
  
  createElement() {
    this.element = document.createElement('button');
    this.element.textContent = this.text;
    this.element.className = 'btn';
    
    if (this.onClick) {
      this.element.addEventListener('click', this.onClick);
    }
    
    return this.element;
  }
}

class Input extends UIComponent {
  constructor(container, placeholder, type = 'text') {
    super(container);
    this.placeholder = placeholder;
    this.type = type;
  }
  
  createElement() {
    this.element = document.createElement('input');
    this.element.type = this.type;
    this.element.placeholder = this.placeholder;
    this.element.className = 'input';
    
    return this.element;
  }
  
  getValue() {
    return this.element ? this.element.value : '';
  }
  
  setValue(value) {
    if (this.element) {
      this.element.value = value;
    }
  }
}

class TextBlock extends UIComponent {
  constructor(container, text) {
    super(container);
    this.text = text;
  }
  
  createElement() {
    this.element = document.createElement('div');
    this.element.textContent = this.text;
    this.element.className = 'text-block';
    
    return this.element;
  }
  
  setText(text) {
    this.text = text;
    if (this.element) {
      this.element.textContent = text;
    }
  }
}

// Полиморфное использование компонентов
function renderUI(components) {
  components.forEach(component => {
    // Независимо от типа компонента, мы можем вызвать метод render()
    component.render();
  });
}

// Использование
const container = document.getElementById('app') || document.body;
const components = [
  new Button(container, 'Нажми меня', () => alert('Кнопка нажата!')),
  new Input(container, 'Введите текст'),
  new TextBlock(container, 'Это текстовый блок')
];

renderUI(components);
```

## Продвинутые паттерны полиморфизма

### 1. Паттерн "Стратегия" (Strategy Pattern)

```javascript
// Интерфейс стратегии валидации
class ValidationStrategy {
  validate(value) {
    throw new Error('Метод validate должен быть реализован');
  }
  
  getErrorMessage() {
    throw new Error('Метод getErrorMessage должен быть реализован');
  }
}

// Конкретные стратегии валидации
class RequiredValidation extends ValidationStrategy {
  validate(value) {
    return value !== null && value !== undefined && value.toString().trim().length > 0;
  }
  
  getErrorMessage() {
    return 'Поле обязательно для заполнения';
  }
}

class EmailValidation extends ValidationStrategy {
  validate(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  }
  
  getErrorMessage() {
    return 'Некорректный email адрес';
  }
}

class MinLengthValidation extends ValidationStrategy {
  constructor(minLength) {
    super();
    this.minLength = minLength;
  }
  
  validate(value) {
    return value.length >= this.minLength;
  }
  
  getErrorMessage() {
    return `Минимальная длина ${this.minLength} символов`;
  }
}

class MaxLengthValidation extends ValidationStrategy {
  constructor(maxLength) {
    super();
    this.maxLength = maxLength;
  }
  
  validate(value) {
    return value.length <= this.maxLength;
  }
  
  getErrorMessage() {
    return `Максимальная длина ${this.maxLength} символов`;
  }
}

// Класс поля ввода, использующий стратегии валидации
class ValidatedInput {
  constructor(container, placeholder, strategies = []) {
    this.container = container;
    this.strategies = strategies;
    this.input = document.createElement('input');
    this.input.placeholder = placeholder;
    this.input.type = 'text';
    this.errorMessage = document.createElement('div');
    this.errorMessage.className = 'error-message';
    this.errorMessage.style.color = 'red';
    this.errorMessage.style.display = 'none';
    
    this.input.addEventListener('blur', () => this.validate());
    this.input.addEventListener('input', () => this.clearError());
  }
  
  addValidationStrategy(strategy) {
    if (strategy instanceof ValidationStrategy) {
      this.strategies.push(strategy);
    }
  }
  
  validate() {
    const value = this.input.value;
    const errors = [];
    
    for (const strategy of this.strategies) {
      if (!strategy.validate(value)) {
        errors.push(strategy.getErrorMessage());
      }
    }
    
    if (errors.length > 0) {
      this.showError(errors.join('; '));
      return false;
    } else {
      this.clearError();
      return true;
    }
  }
  
  showError(message) {
    this.errorMessage.textContent = message;
    this.errorMessage.style.display = 'block';
    this.input.style.borderColor = 'red';
  }
  
  clearError() {
    this.errorMessage.style.display = 'none';
    this.input.style.borderColor = '';
  }
  
  render() {
    const wrapper = document.createElement('div');
    wrapper.appendChild(this.input);
    wrapper.appendChild(this.errorMessage);
    this.container.appendChild(wrapper);
    return wrapper;
  }
  
  getValue() {
    return this.input.value;
  }
  
  setValue(value) {
    this.input.value = value;
    this.validate();
  }
}

// Использование паттерна стратегии
const formContainer = document.getElementById('form') || document.body;

const emailInput = new ValidatedInput(formContainer, 'Email');
emailInput.addValidationStrategy(new RequiredValidation());
emailInput.addValidationStrategy(new EmailValidation());
emailInput.render();

const nameInput = new ValidatedInput(formContainer, 'Имя');
nameInput.addValidationStrategy(new RequiredValidation());
nameInput.addValidationStrategy(new MinLengthValidation(2));
nameInput.addValidationStrategy(new MaxLengthValidation(50));
nameInput.render();
```

### 2. Полиморфизм в обработке событий

```javascript
// Базовый класс обработчика событий
class EventHandler {
  constructor(element) {
    this.element = element;
  }
  
  handle(event) {
    throw new Error('Метод handle должен быть реализован');
  }
}

// Конкретные обработчики
class ClickHandler extends EventHandler {
  constructor(element, callback) {
    super(element);
    this.callback = callback;
    this.element.addEventListener('click', (e) => this.handle(e));
  }
  
  handle(event) {
    console.log('Обработка клика');
    if (this.callback) {
      this.callback(event);
    }
  }
}

class HoverHandler extends EventHandler {
  constructor(element, onHover, onLeave) {
    super(element);
    this.onHover = onHover;
    this.onLeave = onLeave;
    
    this.element.addEventListener('mouseenter', (e) => this.handle('enter', e));
    this.element.addEventListener('mouseleave', (e) => this.handle('leave', e));
  }
  
  handle(type, event) {
    if (type === 'enter') {
      console.log('Наведение на элемент');
      if (this.onHover) {
        this.onHover(event);
      }
    } else if (type === 'leave') {
      console.log('Уход с элемента');
      if (this.onLeave) {
        this.onLeave(event);
      }
    }
  }
}

class KeyboardHandler extends EventHandler {
  constructor(element, keyMap) {
    super(element);
    this.keyMap = keyMap;
    this.element.addEventListener('keydown', (e) => this.handle(e));
  }
  
  handle(event) {
    const handler = this.keyMap[event.key];
    if (handler) {
      console.log(`Нажата клавиша: ${event.key}`);
      handler(event);
    }
  }
}

// Универсальный обработчик событий
class UniversalEventHandler {
  constructor() {
    this.handlers = [];
  }
  
  addHandler(handler) {
    if (handler instanceof EventHandler) {
      this.handlers.push(handler);
    }
  }
  
  removeHandler(handler) {
    const index = this.handlers.indexOf(handler);
    if (index > -1) {
      this.handlers.splice(index, 1);
    }
  }
}

// Использование
const button = document.createElement('button');
button.textContent = 'Нажми меня';
document.body.appendChild(button);

const handlers = new UniversalEventHandler();
handlers.addHandler(new ClickHandler(button, () => console.log('Кнопка кликнута!')));
handlers.addHandler(new HoverHandler(
  button, 
  () => button.style.backgroundColor = 'lightblue',
  () => button.style.backgroundColor = ''
));
```

### 3. Полиморфизм в API-клиентах

```javascript
// Абстрактный класс API-клиента
class ApiClient {
  async request(url, options = {}) {
    throw new Error('Метод request должен быть реализован');
  }
  
  async get(url) {
    return this.request(url, { method: 'GET' });
  }
  
  async post(url, data) {
    return this.request(url, { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
  
  async put(url, data) {
    return this.request(url, { 
      method: 'PUT', 
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
}

// Реализация для REST API
class RestApiClient extends ApiClient {
  constructor(baseURL) {
    super();
    this.baseURL = baseURL;
  }
  
  async request(url, options = {}) {
    const response = await fetch(`${this.baseURL}${url}`, options);
    
    if (!response.ok) {
      throw new Error(`HTTP ошибка! статус: ${response.status}`);
    }
    
    return response.json();
  }
}

// Реализация для GraphQL API
class GraphQlApiClient extends ApiClient {
  constructor(endpoint) {
    super();
    this.endpoint = endpoint;
  }
  
  async request(query, options = {}) {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      body: JSON.stringify({
        query: typeof query === 'string' ? query : query.query,
        variables: query.variables || options.variables || {}
      })
    });
    
    if (!response.ok) {
      throw new Error(`GraphQL ошибка: ${response.statusText}`);
    }
    
    const result = await response.json();
    
    if (result.errors) {
      throw new Error(`GraphQL ошибки: ${result.errors.map(e => e.message).join(', ')}`);
    }
    
    return result.data;
  }
  
  // Специфичный метод для GraphQL
  async query(query, variables = {}) {
    return this.request({ query, variables });
  }
}

// Реализация для Mock API (для тестирования)
class MockApiClient extends ApiClient {
  constructor(mockData = {}) {
    super();
    this.mockData = mockData;
    this.delay = 100; // имитация задержки
  }
  
  async request(url, options = {}) {
    // Имитация сетевой задержки
    await new Promise(resolve => setTimeout(resolve, this.delay));
    
    // Возвращаем mock-данные
    if (options.method === 'GET') {
      return this.mockData[url] || {};
    } else if (options.method === 'POST') {
      return { success: true, data: options.body };
    } else if (options.method === 'PUT') {
      return { success: true, updated: options.body };
    }
    
    return {};
  }
}

// Универсальный сервис, работающий с любым API-клиентом
class UserService {
  constructor(apiClient) {
    // Полиморфизм: принимаем любой класс, наследующий от ApiClient
    if (!(apiClient instanceof ApiClient)) {
      throw new Error('ApiClient должен быть экземпляром ApiClient');
    }
    this.apiClient = apiClient;
  }
  
  async getUser(id) {
    return this.apiClient.get(`/users/${id}`);
  }
  
  async createUser(userData) {
    return this.apiClient.post('/users', userData);
  }
  
  async updateUser(id, userData) {
    return this.apiClient.put(`/users/${id}`, userData);
  }
  
  async deleteUser(id) {
    return this.apiClient.request(`/users/${id}`, { method: 'DELETE' });
  }
}

// Использование с разными реализациями
const restClient = new RestApiClient('https://api.example.com');
const graphQlClient = new GraphQlApiClient('https://graphql.example.com');
const mockClient = new MockApiClient({
  '/users/1': { id: 1, name: 'Иван', email: 'ivan@example.com' }
});

// Один и тот же сервис работает с разными типами клиентов
const userService1 = new UserService(restClient);
const userService2 = new UserService(graphQlClient);
const userService3 = new UserService(mockClient);
```

## Практические примеры полиморфизма во фронтенде

### 1. Компонент уведомлений с разными стратегиями отображения

```javascript
// Абстрактный класс уведомления
class Notification {
  constructor(message, options = {}) {
    this.message = message;
    this.options = options;
    this.element = null;
  }
  
  show() {
    if (!this.element) {
      this.createElement();
    }
    
    document.body.appendChild(this.element);
    this.onShow();
    
    if (this.options.duration) {
      setTimeout(() => this.hide(), this.options.duration);
    }
  }
  
  hide() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
      this.onHide();
    }
  }
  
  createElement() {
    throw new Error('Метод createElement должен быть реализован');
  }
  
  onShow() {
    // Может быть переопределен в дочерних классах
  }
  
  onHide() {
    // Может быть переопределен в дочерних классах
  }
}

// Различные реализации уведомлений
class ToastNotification extends Notification {
  createElement() {
    this.element = document.createElement('div');
    this.element.className = 'toast-notification';
    this.element.textContent = this.message;
    
    Object.assign(this.element.style, {
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      backgroundColor: '#333',
      color: 'white',
      padding: '10px 20px',
      borderRadius: '4px',
      zIndex: '10000',
      opacity: '0',
      transition: 'opacity 0.3s'
    });
    
    // Анимация появления
    setTimeout(() => {
      this.element.style.opacity = '1';
    }, 10);
  }
  
  onShow() {
    console.log('Показ toast-уведомления');
  }
}

class AlertNotification extends Notification {
  createElement() {
    this.element = document.createElement('div');
    this.element.className = 'alert-notification';
    
    this.element.innerHTML = `
      <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin: 10px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span>${this.message}</span>
          <button onclick="this.parentElement.parentElement.remove()" 
                  style="background: none; border: none; font-size: 1.2em; cursor: pointer;">×</button>
        </div>
      </div>
    `;
  }
  
  onShow() {
    console.log('Показ alert-уведомления');
  }
}

class InlineNotification extends Notification {
  constructor(message, targetElement, options = {}) {
    super(message, options);
    this.targetElement = targetElement;
  }
  
  show() {
    if (!this.element) {
      this.createElement();
    }
    
    this.targetElement.appendChild(this.element);
    this.onShow();
    
    if (this.options.duration) {
      setTimeout(() => this.hide(), this.options.duration);
    }
  }
  
  createElement() {
    this.element = document.createElement('div');
    this.element.className = 'inline-notification';
    this.element.textContent = this.message;
    
    Object.assign(this.element.style, {
      backgroundColor: '#d4edda',
      color: '#155724',
      border: '1px solid #c3e6cb',
      borderRadius: '4px',
      padding: '8px',
      marginBottom: '10px',
      fontSize: '0.9em'
    });
  }
  
  onShow() {
    console.log('Показ inline-уведомления');
  }
}

// Менеджер уведомлений
class NotificationManager {
  constructor() {
    this.notifications = [];
  }
  
  show(notification) {
    if (!(notification instanceof Notification)) {
      throw new Error('Уведомление должно быть экземпляром Notification');
    }
    
    this.notifications.push(notification);
    notification.show();
  }
  
  hideAll() {
    this.notifications.forEach(notification => notification.hide());
    this.notifications = [];
  }
}

// Использование
const notificationManager = new NotificationManager();

// Полиморфное использование разных типов уведомлений
notificationManager.show(new ToastNotification('Операция выполнена успешно', { duration: 3000 }));
notificationManager.show(new AlertNotification('Внимание! Что-то пошло не так'));
```

### 2. Полиморфизм в системе логирования

```javascript
// Абстрактный класс логгера
class Logger {
  log(level, message, meta = {}) {
    throw new Error('Метод log должен быть реализован');
  }
  
  info(message, meta = {}) {
    this.log('info', message, meta);
  }
  
  warn(message, meta = {}) {
    this.log('warn', message, meta);
  }
  
  error(message, meta = {}) {
    this.log('error', message, meta);
  }
  
  debug(message, meta = {}) {
    this.log('debug', message, meta);
  }
}

// Консольный логгер
class ConsoleLogger extends Logger {
  log(level, message, meta = {}) {
    const timestamp = new Date().toISOString();
    const formattedMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    
    switch (level) {
      case 'error':
        console.error(formattedMessage, meta);
        break;
      case 'warn':
        console.warn(formattedMessage, meta);
        break;
      case 'debug':
        console.debug(formattedMessage, meta);
        break;
      default:
        console.log(formattedMessage, meta);
    }
  }
}

// Логгер в localStorage
class StorageLogger extends Logger {
  constructor(maxEntries = 1000) {
    super();
    this.maxEntries = maxEntries;
    this.storageKey = 'app_logs';
  }
  
  log(level, message, meta = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta
    };
    
    const logs = this.getLogs();
    logs.push(logEntry);
    
    // Ограничиваем количество записей
    if (logs.length > this.maxEntries) {
      logs.splice(0, logs.length - this.maxEntries);
    }
    
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(logs));
    } catch (e) {
      console.error('Не удалось сохранить лог в localStorage:', e);
    }
  }
  
  getLogs() {
    try {
      const logs = localStorage.getItem(this.storageKey);
      return logs ? JSON.parse(logs) : [];
    } catch {
      return [];
    }
  }
  
  clearLogs() {
    localStorage.removeItem(this.storageKey);
  }
}

// Логгер отправки на сервер
class RemoteLogger extends Logger {
  constructor(endpoint, options = {}) {
    super();
    this.endpoint = endpoint;
    this.batchSize = options.batchSize || 10;
    this.batch = [];
    this.flushInterval = options.flushInterval || 5000;
    
    // Периодическая отправка логов
    setInterval(() => this.flush(), this.flushInterval);
  }
  
  async log(level, message, meta = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.batch.push(logEntry);
    
    // Отправляем пакет, если набралось достаточно записей
    if (this.batch.length >= this.batchSize) {
      await this.flush();
    }
  }
  
  async flush() {
    if (this.batch.length === 0) return;
    
    const logsToSend = [...this.batch];
    this.batch = [];
    
    try {
      await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ logs: logsToSend })
      });
    } catch (error) {
      console.error('Ошибка отправки логов на сервер:', error);
      // Возвращаем логи в батч для повторной отправки
      this.batch = [...logsToSend, ...this.batch];
    }
  }
}

// Универсальный логгер, объединяющий несколько логгеров
class MultiLogger extends Logger {
  constructor(loggers = []) {
    super();
    this.loggers = loggers;
  }
  
  addLogger(logger) {
    if (logger instanceof Logger) {
      this.loggers.push(logger);
    }
  }
  
  log(level, message, meta = {}) {
    this.loggers.forEach(logger => {
      try {
        logger.log(level, message, meta);
      } catch (error) {
        console.error('Ошибка в логгере:', error);
      }
    });
  }
}

// Использование
const multiLogger = new MultiLogger([
  new ConsoleLogger(),
  new StorageLogger(500),
  new RemoteLogger('/api/logs', { batchSize: 5 })
]);

// Или по отдельности
const consoleLogger = new ConsoleLogger();
const storageLogger = new StorageLogger();
const remoteLogger = new RemoteLogger('/api/logs');

// Полиморфное использование
consoleLogger.info('Приложение запущено');
storageLogger.warn('Низкий уровень памяти');
remoteLogger.error('Критическая ошибка в приложении');
```

## Практические рекомендации по полиморфизму в российском фронтенде (2025)

### 1. Используйте интерфейсы и контракты
- Определите четкие контракты для полиморфных компонентов
- Используйте TypeScript для строгой типизации
- Документируйте ожидаемое поведение методов

### 2. Следите за производительностью
- Избегайте чрезмерного наследования, которое может замедлить выполнение
- Используйте полиморфизм осознанно, учитывая особенности JavaScript
- Тестируйте производительность при использовании сложных иерархий

### 3. Пишите тестируемый код
- Разделяйте полиморфные компоненты для изолированного тестирования
- Используйте заглушки и моки при тестировании полиморфного кода
- Покрывайте разные реализации одного интерфейса тестами

```javascript
// Пример полиморфного кода с TypeScript (для лучшей типизации)
class PaymentProcessor {
  process(paymentMethod, amount) {
    // Полиморфный вызов метода pay у любого объекта, 
    // реализующего соответствующий интерфейс
    if (typeof paymentMethod.pay === 'function') {
      return paymentMethod.pay(amount);
    } else {
      throw new Error('Payment method must implement pay method');
    }
  }
}

// Разные способы оплаты
class CreditCardPayment {
  constructor(cardNumber, cvv) {
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. с карты ${this.cardNumber}`);
    return { success: true, transactionId: 'tx_' + Date.now() };
  }
}

class PayPalPayment {
  constructor(email, password) {
    this.email = email;
    this.password = password;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. через PayPal`);
    return { success: true, transactionId: 'pp_' + Date.now() };
  }
}

class YooMoneyPayment {
  constructor(account) {
    this.account = account;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. через ЮMoney`);
    return { success: true, transactionId: 'ym_' + Date.now() };
  }
}

// Использование
const processor = new PaymentProcessor();
const paymentMethods = [
  new CreditCardPayment('4111-1111-1111-1111', '123'),
  new PayPalPayment('user@example.com', 'password'),
  new YooMoneyPayment('41001234567890')
];

paymentMethods.forEach(method => {
  const result = processor.process(method, 1000);
  console.log('Результат оплаты:', result);
});
```

## Заключение

Полиморфизм в фронтенд-разработке 2025 года является мощным инструментом для создания гибких, расширяемых и легко поддерживаемых приложений. Он позволяет работать с объектами разных типов через общий интерфейс, что упрощает код и делает его более универсальным. Правильное использование полиморфизма способствует созданию архитектурно правильных приложений, которые легко адаптируются к изменениям требований.

> [!tip] Совет
> При проектировании полиморфных систем начините с определения общего интерфейса, а затем создавайте конкретные реализации. Это обеспечивает согласованность поведения и упрощает понимание кода.

> [!warning] Важно
> Избегайте излишнего усложнения системы ради использования полиморфизма. Используйте его там, где он действительно добавляет гибкость и упрощает код, а не наоборот.

## Связанные темы

- [[Классы]] - основа для реализации полиморфизма
- [[Наследование]] - механизм, обеспечивающий полиморфизм
- [[Инкапсуляция]] - как полиморфизм взаимодействует с сокрытием данных
- [[ООП-в-фронтенде]] - общее применение ООП в фронтенде
- [[Архитектурные-паттерны-во-фронтенде]] - паттерны, использующие полиморфизм