---
aliases: ["Тестирование микро-фронтендов", "Тестирование МФ", "Testing"]
tags: ["#frontend-architecture", "#microfrontends", "#testing", "#javascript", "#cypress", "#jest"]
---

# Тестирование микро-фронтендов

## Общие принципы тестирования

Тестирование микро-фронтендов представляет собой сложную задачу, требующую особого подхода по сравнению с традиционными монолитными приложениями. Из-за распределенной природы микро-фронтендов тестирование должно охватывать не только отдельные компоненты, но и их интеграцию, взаимодействие и общее пользовательское восприятие.

## Типы тестирования в микро-фронтендах

### 1. Модульное тестирование (Unit Testing)

#### Описание
Тестирование отдельных компонентов и функций в изоляции от других микро-фронтендов.

#### Пример с Jest
```javascript
// Тестирование компонента пользователя
import { render, screen } from '@testing-library/react';
import UserProfile from './UserProfile';

describe('UserProfile Component', () => {
  test('renders user name correctly', () => {
    const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
    
    render(<UserProfile user={mockUser} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  test('shows loading state', () => {
    render(<UserProfile loading={true} />);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
});
```

### 2. Интеграционное тестирование (Integration Testing)

#### Описание
Тестирование взаимодействия между компонентами внутри одного микро-фронтенда или между несколькими микро-фронтендами.

#### Пример с React Testing Library
```javascript
// Тестирование взаимодействия между компонентами
import { render, fireEvent, waitFor } from '@testing-library/react';
import UserDashboard from './UserDashboard';

describe('UserDashboard Integration', () => {
  test('updates cart when adding item', async () => {
    const { getByText, getByTestId } = render(<UserDashboard />);
    
    // Имитация добавления товара в корзину
    fireEvent.click(getByText('Add to Cart'));
    
    await waitFor(() => {
      expect(getByTestId('cart-count')).toHaveTextContent('1');
    });
  });
});
```

### 3. Сквозное тестирование (End-to-End Testing)

#### Описание
Тестирование полных пользовательских сценариев, охватывающих несколько микро-фронтендов.

#### Пример с Cypress
```javascript
// cypress/e2e/checkout-flow.cy.js
describe('Checkout Flow', () => {
  it('should allow user to complete purchase', () => {
    cy.visit('/');

    // Взаимодействие с микро-фронтендом каталога товаров
    cy.get('[data-cy=product-card]').first().click();
    cy.get('[data-cy=add-to-cart]').click();

    // Переход к микро-фронтенду корзины
    cy.get('[data-cy=cart-icon]').click();
    cy.get('[data-cy=checkout-button]').click();

    // Взаимодействие с микро-фронтендом оформления заказа
    cy.get('[data-cy=shipping-form]').within(() => {
      cy.get('input[name="name"]').type('John Doe');
      cy.get('input[name="address"]').type('123 Main St');
    });

    cy.get('[data-cy=submit-order]').click();

    // Проверка результата в микро-фронтенде подтверждения
    cy.get('[data-cy=order-confirmation]').should('be.visible');
  });
});
```

## Стратегии тестирования

### 1. Тестирование изоляции

Каждый микро-фронтенд должен быть протестирован в изоляции, чтобы убедиться в его независимости:

```javascript
// Заглушка для внешних зависимостей
jest.mock('../services/api', () => ({
  getUserProfile: jest.fn().mockResolvedValue({
    id: 1,
    name: 'Test User',
    email: 'test@example.com'
  })
}));

// Тестирование изолированного компонента
describe('Isolated Component Test', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('fetches and displays user data', async () => {
    const { findByText } = render(<UserProfile userId={1} />);
    
    expect(await findByText('Test User')).toBeInTheDocument();
  });
});
```

### 2. Тестирование интеграции

Тестирование взаимодействия между микро-фронтендами:

```javascript
// Тестирование через события
describe('Cross-Microfrontend Communication', () => {
  test('cart updates when product is added', () => {
    // Подписка на события
    const eventHandler = jest.fn();
    window.addEventListener('cart-updated', eventHandler);
    
    // Имитация добавления товара
    window.dispatchEvent(new CustomEvent('product-added', {
      detail: { productId: 123, quantity: 1 }
    }));
    
    // Проверка реакции на событие
    expect(eventHandler).toHaveBeenCalled();
  });
});
```

### 3. Тестирование контрактов

Проверка соответствия интерфейсов между микро-фронтендами:

```javascript
// Тест контракта API
describe('API Contract Tests', () => {
  test('user service returns expected data structure', async () => {
    const userData = await api.getUser(123);
    
    expect(userData).toMatchObject({
      id: expect.any(Number),
      name: expect.any(String),
      email: expect.stringMatching(/.+@.+\..+/),
      createdAt: expect.any(String)
    });
  });
});
```

## Инструменты для тестирования

### 1. Jest + React Testing Library

Для модульного и интеграционного тестирования:

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/index.js',
    '!src/reportWebVitals.js',
  ],
};
```

### 2. Cypress

Для сквозного тестирования:

```javascript
// cypress.config.js
const { defineConfig } = require('cypress');

module.exports = defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
    viewportWidth: 1280,
    viewportHeight: 720,
  },
});
```

### 3. MSW (Mock Service Worker)

Для мокирования сетевых запросов:

```javascript
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users/:userId', (req, res, ctx) => {
    return res(
      ctx.json({
        id: Number(req.params.userId),
        name: 'Test User',
        email: 'test@example.com',
      })
    );
  }),
  
  rest.post('/api/cart/add', (req, res, ctx) => {
    return res(
      ctx.json({ success: true, cartId: 'cart-123' })
    );
  }),
];

// src/mocks/server.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);
```

## Практические рекомендации

### 1. Использование фикстур данных

Создайте реалистичные фикстуры данных для тестирования:

```javascript
// fixtures/users.js
export const mockUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  preferences: {
    theme: 'light',
    language: 'en',
    notifications: true
  },
  createdAt: '2023-01-01T00:00:00Z'
};

export const mockCart = {
  id: 'cart-123',
  items: [
    { id: 1, name: 'Product A', price: 100, quantity: 2 },
    { id: 2, name: 'Product B', price: 200, quantity: 1 }
  ],
  total: 400
};
```

### 2. Тестирование производительности

```javascript
// Тестирование производительности загрузки микро-фронтендов
describe('Performance Tests', () => {
  test('loads within acceptable time', async () => {
    const startTime = performance.now();
    
    // Загрузка микро-фронтенда
    await loadMicroFrontend('user-profile');
    
    const endTime = performance.now();
    const loadTime = endTime - startTime;
    
    expect(loadTime).toBeLessThan(2000); // Загрузка менее 2 секунд
  });
});
```

### 3. Тестирование отказоустойчивости

```javascript
// Тестирование поведения при отказе микро-фронтенда
describe('Resilience Tests', () => {
  test('gracefully handles micro-frontend failure', async () => {
    // Имитация отказа сервиса
    jest.spyOn(api, 'getUser').mockRejectedValue(new Error('Service unavailable'));
    
    const { getByText } = render(<App />);
    
    // Проверка отображения сообщения об ошибке
    expect(getByText(/temporarily unavailable/i)).toBeInTheDocument();
    
    // Проверка, что остальная часть приложения продолжает работать
    expect(getByText('Main Navigation')).toBeInTheDocument();
  });
});
```

## Автоматизация тестирования

### 1. Pipeline для CI/CD

```yaml
# .github/workflows/test.yml
name: Test Micro Frontends

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    - run: npm ci
    - run: npm run test:unit
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  e2e-tests:
    runs-on: ubuntu-latest
    services:
      # Определение сервисов для тестирования
      api:
        image: my-api:latest
        ports:
          - 3001:3001
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    - run: npm ci
    - name: Run E2E tests
      run: npm run test:e2e
```

### 2. Параллельное выполнение тестов

```javascript
// jest.preset.js - для параллельного выполнения тестов
module.exports = {
  projects: [
    '<rootDir>/packages/user-profile/jest.config.js',
    '<rootDir>/packages/product-catalog/jest.config.js',
    '<rootDir>/packages/shopping-cart/jest.config.js',
  ],
  collectCoverage: true,
  coverageDirectory: '<rootDir>/coverage',
  coverageReporters: ['lcov', 'text'],
};
```

## Особенности тестирования в российских реалиях 2025 года

### 1. Ограничения на использование зарубежных сервисов

В условиях санкций и ограничений, тестирование должно быть адаптировано для работы с локальными инфраструктурами:

- Использование локальных CI/CD систем
- Применение отечественных решений для тестирования
- Обеспечение автономной работы тестов без внешних зависимостей

### 2. Учет специфики пользователей

- Тестирование с учетом географического распределения пользователей
- Проверка производительности в условиях различных сетевых условий
- Адаптация интерфейсов под российские стандарты и привычки

### 3. Безопасность и конфиденциальность

- Тестирование сценариев защиты данных
- Проверка соответствия требованиям локальных законов
- Обеспечение конфиденциальности при тестировании

## Лучшие практики

### 1. Тестирование как часть разработки

Внедрите культуру тестирования на всех этапах разработки микро-фронтендов:

- Требуйте тесты к каждому новому компоненту
- Используйте TDD при разработке микро-фронтендов
- Проводите регулярные ревью тестов

### 2. Мониторинг тестов в продакшене

Используйте тесты не только в процессе разработки, но и в продакшене:

```javascript
// Запуск тестов в продакшене для проверки работоспособности
if (process.env.NODE_ENV === 'production') {
  // Запуск минимального набора тестов для проверки критических функций
  runHealthCheckTests();
}
```

### 3. Документирование тестов

Создайте документацию для тестов, особенно для интеграционных и сквозных тестов:

- Описание сценариев тестирования
- Пояснение бизнес-логики, проверяемой тестами
- Инструкции по запуску и отладке тестов

> [!tip] Совет по эффективности
> Используйте ранний тестовый запуск (early testing) для быстрого выявления проблем. Настройте локальные хуки Git для запуска быстрых тестов перед коммитом.

## Заключение

Тестирование микро-фронтендов требует комплексного подхода, сочетающего различные типы тестирования и учитывающего специфику распределенной архитектуры. Успешная стратегия тестирования должна обеспечивать высокое качество кода, надежность интеграции между компонентами и положительный пользовательский опыт. В условиях российских реалий 2025 года особое внимание следует уделять автономности решений и соответствию локальным требованиям.

См. также: [[Введение-в-микро-фронтенды]], [[Архитектурные-подходы]], [[Интеграция]], [[Управление-состоянием]]