---
aliases: ["Управление состоянием в микро-фронтендах", "Состояние МФ", "State Management"]
tags: ["#frontend-architecture", "#microfrontends", "#state-management", "#javascript", "#redux", "#zustand"]
---

# Управление состоянием в микро-фронтендах

## Общие принципы

Управление состоянием в архитектуре микро-фронтендов представляет собой одну из самых сложных задач. В отличие от традиционных монолитных приложений, где все компоненты имеют доступ к единому хранилищу состояния, микро-фронтенды должны координировать общее состояние при сохранении своей изоляции и независимости.

## Типы состояния в микро-фронтендах

### 1. Локальное состояние (Local State)

Состояние, используемое только внутри одного микро-фронтенда:

```javascript
// Локальное состояние в React-компоненте
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);

  return loading ? <div>Loading...</div> : <div>{user.name}</div>;
}
```

### 2. Общее состояние (Shared State)

Состояние, которое используется несколькими микро-фронтендами:

- Информация о пользователе
- Данные корзины покупок
- Настройки интерфейса
- Состояние аутентификации

### 3. Глобальное состояние (Global State)

Состояние, доступное для всего приложения:

- Тема оформления
- Язык интерфейса
- Информация о сессии
- Настройки производительности

## Подходы к управлению состоянием

### 1. Централизованное состояние (Centralized State)

#### Описание
Все состояние хранится в одном централизованном хранилище, доступном для всех микро-фронтендов.

#### Преимущества
- Единая точка управления
- Простота отслеживания изменений
- Легкость отладки

#### Недостатки
- Нарушение изоляции микро-фронтендов
- Зависимость от центрального хранилища
- Потенциальные проблемы с производительностью

#### Реализация с помощью Redux

```javascript
// Централизованное хранилище Redux
import { configureStore } from '@reduxjs/toolkit';
import { combineReducers } from 'redux';

// Редьюсеры от разных команд
import { userReducer } from '@team-a/user-store';
import { cartReducer } from '@team-b/cart-store';
import { uiReducer } from '@team-c/ui-store';

const rootReducer = combineReducers({
  user: userReducer,
  cart: cartReducer,
  ui: uiReducer
});

export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST'],
      },
    }),
});

// Использование в микро-фронтенде
import { useSelector, useDispatch } from 'react-redux';

function CartSummary() {
  const cartItems = useSelector(state => state.cart.items);
  const dispatch = useDispatch();
  
  const removeFromCart = (itemId) => {
    dispatch({ type: 'cart/removeItem', payload: itemId });
  };
  
  return (
    <div>
      {cartItems.map(item => (
        <div key={item.id}>
          {item.name} - {item.price}
          <button onClick={() => removeFromCart(item.id)}>Remove</button>
        </div>
      ))}
    </div>
  );
}
```

### 2. Децентрализованное состояние (Decentralized State)

#### Описание
Каждый микро-фронтенд управляет своим собственным состоянием, а взаимодействие происходит через события или API.

#### Преимущества
- Полная изоляция микро-фронтендов
- Независимое управление состоянием
- Возможность использовать разные подходы к управлению

#### Недостатки
- Сложность синхронизации состояния
- Повышенная сложность отладки
- Потенциальные конфликты данных

#### Реализация с использованием событий

```javascript
// Микро-фронтенд A - управление пользователем
class UserManagement {
  constructor() {
    this.state = { currentUser: null };
  }

  login(userData) {
    this.state.currentUser = userData;
    window.dispatchEvent(new CustomEvent('user-logged-in', {
      detail: userData
    }));
  }

  logout() {
    this.state.currentUser = null;
    window.dispatchEvent(new CustomEvent('user-logged-out'));
  }
}

// Микро-фронтенд B - использование состояния пользователя
class HeaderComponent {
  constructor() {
    this.userStatus = 'Guest';
    this.initEventListeners();
  }

  initEventListeners() {
    window.addEventListener('user-logged-in', (event) => {
      this.userStatus = event.detail.name;
      this.updateUI();
    });

    window.addEventListener('user-logged-out', () => {
      this.userStatus = 'Guest';
      this.updateUI();
    });
  }

  updateUI() {
    document.getElementById('user-status').textContent = this.userStatus;
  }
}
```

### 3. Гибридное состояние (Hybrid State)

#### Описание
Комбинация централизованного и децентрализованного подходов, где общее состояние централизовано, а локальное остается в микро-фронтендах.

#### Преимущества
- Баланс между изоляцией и согласованностью
- Гибкость в управлении
- Возможность оптимизации под конкретные сценарии

#### Недостатки
- Повышенная сложность архитектуры
- Необходимость тщательного планирования

#### Реализация с Zustand

```javascript
// Централизованное хранилище с Zustand
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

// Создание глобального хранилища
const useGlobalStore = create(
  subscribeWithSelector((set, get) => ({
    // Общее состояние
    user: null,
    theme: 'light',
    language: 'ru',
    
    // Действия
    setUser: (user) => set({ user }),
    setTheme: (theme) => set({ theme }),
    setLanguage: (language) => set({ language }),
    
    // Вычисляемые значения
    isAuthenticated: () => !!get().user,
    userRole: () => get().user?.role || 'guest'
  }))
);

// Микро-фронтенд A - профиль пользователя
function UserProfile() {
  const user = useGlobalStore(state => state.user);
  const setUser = useGlobalStore(state => state.setUser);
  
  const updateProfile = async (profileData) => {
    try {
      const updatedUser = await api.updateUserProfile(profileData);
      setUser(updatedUser);
    } catch (error) {
      console.error('Failed to update profile:', error);
    }
  };
  
  return (
    <div>
      <h2>Profile: {user?.name}</h2>
      {/* Форма обновления профиля */}
    </div>
  );
}

// Микро-фронтенд B - переключатель темы
function ThemeSwitcher() {
  const theme = useGlobalStore(state => state.theme);
  const setTheme = useGlobalStore(state => state.setTheme);
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Switch to {theme === 'light' ? 'dark' : 'light'} theme
    </button>
  );
}
```

## Паттерны управления состоянием

### 1. Паттерн "Событийный шлюз" (Event Gateway)

```javascript
// Централизованный обработчик событий
class StateGateway {
  constructor() {
    this.subscribers = new Map();
    this.state = {};
  }

  subscribe(event, callback) {
    if (!this.subscribers.has(event)) {
      this.subscribers.set(event, []);
    }
    this.subscribers.get(event).push(callback);
  }

  publish(event, data) {
    if (this.subscribers.has(event)) {
      this.subscribers.get(event).forEach(callback => callback(data));
    }
    
    // Обновление глобального состояния при необходимости
    if (event.startsWith('state:')) {
      const stateKey = event.replace('state:', '');
      this.state[stateKey] = data;
    }
  }

  getState(key) {
    return this.state[key];
  }
}

// Глобальный экземпляр
window.stateGateway = new StateGateway();

// Использование в микро-фронтендах
window.stateGateway.subscribe('user-updated', (userData) => {
  updateCurrentUser(userData);
});
```

### 2. Паттерн "Фасад состояния" (State Facade)

```javascript
// Единый интерфейс для управления состоянием
class StateFacade {
  constructor() {
    this.stores = new Map();
    this.eventBus = new EventBus();
  }

  registerStore(name, store) {
    this.stores.set(name, store);
    
    // Подписка на изменения в хранилище
    store.subscribe((state) => {
      this.eventBus.publish(`store:${name}:updated`, state);
    });
  }

  getStore(name) {
    return this.stores.get(name);
  }

  getState(path) {
    const [storeName, ...keys] = path.split('.');
    const store = this.stores.get(storeName);
    
    if (!store) return undefined;
    
    let state = store.getState();
    for (const key of keys) {
      state = state[key];
      if (state === undefined) break;
    }
    
    return state;
  }

  dispatch(storeName, action) {
    const store = this.stores.get(storeName);
    if (store) {
      store.dispatch(action);
    }
  }
}

// Инициализация фасада
window.stateFacade = new StateFacade();

// Регистрация хранилища
window.stateFacade.registerStore('user', userStore);
window.stateFacade.registerStore('cart', cartStore);
```

## Рекомендации по управлению состоянием

### 1. Минимизация общего состояния

Старайтесь минимизировать объем состояния, которое должно быть общим для всех микро-фронтендов. Храните в глобальном состоянии только действительно необходимые данные.

### 2. Использование нормализованных данных

Для избежания дублирования и несогласованности данных используйте нормализованные структуры:

```javascript
// Вместо вложенных объектов
{
  users: [
    { id: 1, name: 'John', orders: [{ id: 101, total: 100 }] }
  ]
}

// Используйте нормализованные данные
{
  users: {
    1: { id: 1, name: 'John', orderIds: [101] }
  },
  orders: {
    101: { id: 101, total: 100, userId: 1 }
  }
}
```

### 3. Управление жизненным циклом состояния

Реализуйте механизмы очистки состояния при размонтировании микро-фронтендов:

```javascript
// Очистка состояния при размонтировании
function useCleanupStateOnUnmount(storeKey, cleanupAction) {
  useEffect(() => {
    return () => {
      // Очистка состояния при размонтировании компонента
      if (cleanupAction) {
        cleanupAction();
      }
    };
  }, []);
}
```

### 4. Обработка конфликтов состояния

Реализуйте стратегии разрешения конфликтов при одновременном изменении одного состояния разными микро-фронтендами:

```javascript
// Простая стратегия "последний выигрывает"
class ConflictResolver {
  constructor() {
    this.lastUpdateTimestamps = new Map();
  }

  resolve(storeKey, newValue, timestamp) {
    const lastTimestamp = this.lastUpdateTimestamps.get(storeKey);
    
    if (!lastTimestamp || timestamp > lastTimestamp) {
      this.lastUpdateTimestamps.set(storeKey, timestamp);
      return newValue;
    }
    
    return null; // Не обновлять, если новое значение устарело
  }
}
```

## Технические решения для российских реалий 2025 года

В условиях российского ИТ-ландшафта 2025 года рекомендуется:

- Использовать локальные решения для управления состоянием вместо облачных сервисов
- Обеспечивать автономную работу микро-фронтендов при недоступности центральных сервисов
- Реализовывать резервные механизмы синхронизации данных
- Использовать решения с открытым исходным кодом с активной российской поддержкой

> [!warning] Важно
> При проектировании системы управления состоянием учитывайте не только технические аспекты, но и организационные. Четко определите, какие команды отвечают за какие части состояния.

## Заключение

Управление состоянием в микро-фронтендах требует особого внимания к архитектуре и деталям реализации. Успешная стратегия должна балансировать между изоляцией микро-фронтендов и необходимостью согласованности данных. Выбор подходящего паттерна зависит от конкретных требований проекта, но независимо от выбора важно обеспечить надежность, производительность и поддерживаемость системы управления состоянием.

См. также: [[Введение-в-микро-фронтенды]], [[Архитектурные-подходы]], [[Интеграция]], [[Тестирование]]