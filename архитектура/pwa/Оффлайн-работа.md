---
aliases: [Оффлайн работа, Offline Support, Offline Functionality]
tags: [pwa, offline, service-worker, caching, resilience]
---

# Оффлайн работа

## Обзор

Оффлайн работа - это ключевая особенность прогрессивных веб-приложений, позволяющая пользователям использовать приложение даже при отсутствии интернет-соединения. Это достигается за счет использования [[Service Workers]] и различных стратегий кэширования.

## Принципы оффлайн работы

### Кэширование ресурсов
Основой оффлайн работы является предварительное кэширование необходимых ресурсов:
- HTML-файлов (шаблон приложения)
- CSS-стилей
- JavaScript-файлов
- Изображений и других ассетов
- API-ответов для часто используемых данных

### Перехват сетевых запросов
[[Service Workers]] перехватывают сетевые запросы и могут возвращать кэшированные данные при отсутствии соединения.

### Стратегии кэширования
Различные стратегии кэширования позволяют оптимизировать производительность и пользовательский опыт в оффлайн-режиме.

## Стратегии кэширования

### 1. Cache-First (Кэш-первый)
Сначала проверяется кэш, и только если данные отсутствуют, делается сетевой запрос:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});
```

Эта стратегия подходит для:
- Статических ресурсов (CSS, JavaScript, изображения)
- Данных, которые редко изменяются
- Оффлайн-доступа к основному функционалу

### 2. Network-First (Сеть-первая)
Сначала делается сетевой запрос, и только при его неудаче используется кэш:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => {
        return caches.match(event.request);
      })
  );
});
```

Эта стратегия подходит для:
- Часто обновляемых данных
- Информации, требующей актуальности
- Контента, зависящего от времени

### 3. Stale-While-Revalidate (Устаревшее с обновлением)
Возвращает кэшированные данные, но в фоне обновляет их:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        const fetchedResponse = fetch(event.request)
          .then((networkResponse) => {
            // Обновляем кэш
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, networkResponse.clone());
            });
            return networkResponse;
          });

        return cachedResponse || fetchedResponse;
      })
  );
});
```

### 4. Cache-and-Network (Кэш и сеть)
Одновременно использует кэш и сеть, обновляя UI по мере получения новых данных:

```javascript
// Клиентский код для стратегии Cache-and-Network
async function fetchWithBoth(request) {
  // Сначала кэш
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    updateUI(cachedResponse);
  }

  // Затем сеть
  try {
    const networkResponse = await fetch(request);
    updateUI(networkResponse);
    await cacheResponse(request, networkResponse);
  } catch (error) {
    console.error('Сетевой запрос не удался:', error);
  }
}
```

## Оффлайн-стратегии для разных типов данных

### Статический контент
Для CSS, JavaScript и изображений используйте стратегию Cache-First с предварительным кэшированием:

```javascript
const STATIC_CACHE_NAME = 'static-v1';
const STATIC_FILES = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png',
  '/offline.html'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE_NAME)
      .then((cache) => cache.addAll(STATIC_FILES))
  );
});
```

### Динамический контент
Для часто изменяющихся данных используйте Network-First или Stale-While-Revalidate:

```javascript
const DYNAMIC_CACHE_NAME = 'dynamic-v1';

self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Кэшируем успешные ответы
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open(DYNAMIC_CACHE_NAME)
              .then((cache) => cache.put(event.request, responseClone));
          }
          return response;
        })
        .catch(() => {
          return caches.match(event.request)
            .then((response) => response || caches.match('/offline.html'));
        })
    );
  }
});
```

### Данные пользователя
Для персональных данных и состояния пользователя:

```javascript
// Кэширование данных пользователя с обновлением при восстановлении соединения
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/user')) {
    event.respondWith(
      caches.match(event.request)
        .then((cachedResponse) => {
          return fetch(event.request)
            .then((networkResponse) => {
              // Обновляем кэш
              caches.open('user-data')
                .then((cache) => cache.put(event.request, networkResponse.clone()));
              return networkResponse;
            })
            .catch(() => cachedResponse || caches.match('/offline.html'));
        })
    );
  }
});
```

## Обработка оффлайн-режима на клиентской стороне

### Определение статуса соединения
```javascript
// Проверка статуса соединения
function checkConnection() {
  return navigator.onLine;
}

// События изменения статуса соединения
window.addEventListener('online', () => {
  console.log('Соединение восстановлено');
  // Обновляем данные, синхронизируем изменения
});

window.addEventListener('offline', () => {
  console.log('Соединение потеряно');
  // Показываем уведомление, отключаем функции, требующие сети
});
```

### Индикация оффлайн-режима
```javascript
// Показ индикатора оффлайн-режима
function showOfflineIndicator() {
  const indicator = document.createElement('div');
  indicator.textContent = 'Оффлайн режим';
  indicator.className = 'offline-indicator';
  document.body.appendChild(indicator);
}

// Скрытие индикатора при восстановлении соединения
function hideOfflineIndicator() {
  const indicator = document.querySelector('.offline-indicator');
  if (indicator) {
    indicator.remove();
  }
}
```

## Хранение данных в оффлайн-режиме

### IndexedDB
Для хранения структурированных данных в оффлайн-режиме:

```javascript
// Пример использования IndexedDB для хранения задач
const DB_NAME = 'PWA_DB';
const DB_VERSION = 1;

let db;

function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      db = event.target.result;
      const objectStore = db.createObjectStore('tasks', { keyPath: 'id', autoIncrement: true });
      objectStore.createIndex('title', 'title', { unique: false });
      objectStore.createIndex('completed', 'completed', { unique: false });
    };
  });
}

// Сохранение задачи
function saveTask(task) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['tasks'], 'readwrite');
    const store = transaction.objectStore('tasks');
    const request = store.add(task);
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
```

### LocalStorage и SessionStorage
Для простого хранения небольших объемов данных:

```javascript
// Сохранение данных в localStorage
function saveToLocalStorage(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
  } catch (error) {
    console.error('Ошибка сохранения в localStorage:', error);
  }
}

// Чтение данных из localStorage
function getFromLocalStorage(key) {
  try {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
  } catch (error) {
    console.error('Ошибка чтения из localStorage:', error);
    return null;
  }
}
```

## Особенности для российских реалий 2025 года

В 2025 году в России при реализации оффлайн-функциональности важно учитывать:

- Нестабильность интернет-соединения в некоторых регионах
- Ограничения на доступ к зарубежным API и сервисам
- Повышенные требования к защите персональных данных при локальном хранении
- Необходимость поддержки различных провайдеров связи
- Возможные ограничения на фоновую синхронизацию данных

Разработчикам необходимо создавать приложения, которые могут функционировать автономно продолжительное время и эффективно синхронизировать данные при восстановлении соединения.

## Лучшие практики

1. **Планируйте оффлайн-архитектуру заранее**: Определите, какие функции должны работать без интернета
2. **Оптимизируйте размер кэша**: Избегайте чрезмерного кэширования для экономии места на устройстве
3. **Обеспечьте плавный переход**: Создайте понятные пользовательские интерфейсы для оффлайн-режима
4. **Тестируйте в реальных условиях**: Проверяйте работу приложения при различных уровнях соединения
5. **Обрабатывайте ошибки корректно**: Предоставляйте понятные сообщения при сбоях в сети
6. **Синхронизируйте данные при восстановлении соединения**: Обеспечьте согласованность данных

## Связанные темы

- [[Service Workers]]
- [[Кэширование]]
- [[Архитектура PWA]]
- [[Application Shell]]

## Заключение

Оффлайн работа - важнейшая характеристика современных прогрессивных веб-приложений. Правильная реализация оффлайн-функциональности значительно улучшает пользовательский опыт, особенно в условиях нестабильного интернет-соединения. В условиях российского рынка 2025 года это особенно актуально, учитывая географические и инфраструктурные особенности страны.