---
aliases: ["Чистая архитектура", "Clean Architecture"]
tags: [architecture, frontend, pattern, clean-architecture, hexagonal-architecture]
---

# Чистая архитектура (Clean Architecture)

## Обзор

Чистая архитектура (Clean Architecture) - это архитектурный паттерн, предложенный Робертом Мартином (Uncle Bob) для создания программного обеспечения, которое является:
- Независимым от фреймворков
- Тестируемым
- Независимым от UI
- Независимым от баз данных
- Независимым от внешних агентов

Этот паттерн особенно актуален в российской разработке 2025 года, когда важна гибкость и возможность адаптации к санкционным ограничениям и импортозамещению.

## Структура паттерна

Чистая архитектура организована в виде концентрических кругов, где каждый внутренний круг содержит более важные компоненты:

```
┌─────────────────────────────────────┐
│           External Agents           │
│  (Frameworks, UI, DB, External API) │
└─────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│           Interface Adapters        │
│        (Controllers, Gateways)      │
└─────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│              Use Cases              │
│         (Interactors, Services)     │
└─────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│            Entities (Domain)        │
│       (Business Rules, Models)      │
└─────────────────────────────────────┘
```

### Entities (Сущности/Домен)
- **Отвечают за**: бизнес-правила и сущности
- **Содержат**: основные бизнес-объекты и правила
- **Не зависят от**: внешних слоев

```javascript
// Пример доменной сущности
class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
  }

  updateName(newName) {
    if (!newName || newName.trim() === '') {
      throw new Error('Имя пользователя не может быть пустым');
    }
    this.name = newName;
    return this;
  }

  updateEmail(newEmail) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(newEmail)) {
      throw new Error('Некорректный формат email');
    }
    this.email = newEmail;
    return this;
  }
}

// Доменные сервисы
class UserValidator {
  static isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  static isValidName(name) {
    return name && name.trim().length > 0 && name.trim().length <= 100;
  }
}
```

### Use Cases (Сценарии использования)
- **Отвечают за**: бизнес-логику приложения
- **Содержат**: сценарии использования, интеракторы
- **Зависят только от**: Entities

```javascript
// Пример интерактора для регистрации пользователя
class RegisterUserUseCase {
  constructor(userRepository, passwordHasher) {
    this.userRepository = userRepository;
    this.passwordHasher = passwordHasher;
  }

  async execute(request) {
    // Проверяем валидность данных
    if (!UserValidator.isValidName(request.name)) {
      throw new Error('Некорректное имя пользователя');
    }

    if (!UserValidator.isValidEmail(request.email)) {
      throw new Error('Некорректный email');
    }

    // Проверяем, что пользователь с таким email не существует
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }

    // Создаем нового пользователя
    const hashedPassword = this.passwordHasher.hash(request.password);
    const user = new User(null, request.name, request.email);
    user.password = hashedPassword;

    // Сохраняем в репозитории
    const savedUser = await this.userRepository.save(user);
    
    // Здесь можно добавить логику уведомлений, аналитики и т.д.
    
    return {
      id: savedUser.id,
      name: savedUser.name,
      email: savedUser.email
    };
  }
}
```

### Interface Adapters (Адаптеры интерфейсов)
- **Отвечают за**: преобразование данных между внешними агентами и внутренними слоями
- **Содержат**: контроллеры, презентеры, преобразователи данных

```javascript
// Пример контроллера (адаптера интерфейса)
class UserController {
  constructor(registerUserUseCase, getUserUseCase) {
    this.registerUserUseCase = registerUserUseCase;
    this.getUserUseCase = getUserUseCase;
  }

  async registerUser(request, response) {
    try {
      const userData = {
        name: request.body.name,
        email: request.body.email,
        password: request.body.password
      };

      const result = await this.registerUserUseCase.execute(userData);
      
      response.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      response.status(400).json({
        success: false,
        message: error.message
      });
    }
  }

  async getUser(request, response) {
    try {
      const userId = parseInt(request.params.id);
      const user = await this.getUserUseCase.execute(userId);
      
      if (!user) {
        return response.status(404).json({
          success: false,
          message: 'Пользователь не найден'
        });
      }
      
      response.json({
        success: true,
        data: user
      });
    } catch (error) {
      response.status(500).json({
        success: false,
        message: 'Внутренняя ошибка сервера'
      });
    }
  }
}
```

### External Agents (Внешние агенты)
- **Отвечают за**: взаимодействие с внешним миром
- **Содержат**: фреймворки, UI, базы данных, внешние API

```javascript
// Пример репозитория (внешний агент)
class UserRepository {
  constructor(database) {
    this.database = database;
  }

  async findByEmail(email) {
    // Внешняя зависимость - база данных
    const result = await this.database.query(
      'SELECT * FROM users WHERE email = ?', 
      [email]
    );
    return result.length > 0 ? this.mapToEntity(result[0]) : null;
  }

  async save(user) {
    if (user.id) {
      // Обновление существующего пользователя
      await this.database.query(
        'UPDATE users SET name = ?, email = ?, password = ? WHERE id = ?',
        [user.name, user.email, user.password, user.id]
      );
    } else {
      // Создание нового пользователя
      const result = await this.database.query(
        'INSERT INTO users (name, email, password) VALUES (?, ?, ?)',
        [user.name, user.email, user.password]
      );
      user.id = result.insertId;
    }
    return user;
  }

  mapToEntity(dbRecord) {
    const user = new User(dbRecord.id, dbRecord.name, dbRecord.email);
    user.password = dbRecord.password;
    return user;
  }
}
```

## Принципы Чистой архитектуры

### Правило зависимостей
- Внешние круги зависят от внутренних кругов
- Никогда не наоборот
- Зависимости направлены внутрь

### Принцип инверсии зависимостей
- Абстракции не должны зависеть от деталей
- Детали должны зависеть от абстракций

### Принцип открытости/закрытости
- Модули должны быть открыты для расширения, но закрыты для модификации

## Преимущества Чистой архитектуры

1. **Независимость от фреймворков**: можно легко заменить фреймворки без изменения бизнес-логики
2. **Тестируемость**: внутренние слои можно тестировать без внешних зависимостей
3. **Независимость от UI**: можно изменить UI без изменения бизнес-логики
4. **Независимость от базы данных**: можно изменить базу данных без изменения бизнес-логики
5. **Независимость от внешних агентов**: бизнес-логика не зависит от внешних сервисов

## Недостатки Чистой архитектуры

1. **Сложность для маленьких приложений**: может быть избыточной
2. **Более многословный код**: требует больше шаблонного кода
3. **Сложность понимания**: требует хорошего понимания архитектурных концепций
4. **Более высокий порог входа**: сложнее для начинающих разработчиков

## Применение в российских реалиях 2025

Чистая архитектура особенно актуальна в российской разработке:

- **Импортозамещающих проектах**: где важна гибкость и возможность замены компонентов
- **Государственных системах**: где важна стабильность и долгосрочная поддержка
- **Корпоративных решениях**: где важна тестируемость и масштабируемость
- **Проектах с жесткими требованиями безопасности**: где важна изоляция бизнес-логики

В условиях санкций и необходимости адаптации к новым реалиям, чистая архитектура предоставляет гибкость для быстрого перехода на отечественные решения.

## Пример реализации в JavaScript

```javascript
// Определяем абстракции (внутренний слой)
class UserRepositoryInterface {
  async findByEmail(email) {}
  async save(user) {}
}

class PasswordHasherInterface {
  hash(password) {}
  verify(password, hash) {}
}

// Реализация внешнего агента
class BcryptPasswordHasher extends PasswordHasherInterface {
  constructor(bcrypt) {
    super();
    this.bcrypt = bcrypt;
  }

  hash(password) {
    return this.bcrypt.hashSync(password, 10);
  }

  verify(password, hash) {
    return this.bcrypt.compareSync(password, hash);
  }
}

// Связываем все вместе
class DependencyContainer {
  constructor() {
    this.userRepository = new UserRepository(/* database */);
    this.passwordHasher = new BcryptPasswordHasher(/* bcrypt instance */);
    this.registerUserUseCase = new RegisterUserUseCase(
      this.userRepository,
      this.passwordHasher
    );
    this.userController = new UserController(
      this.registerUserUseCase,
      /* getUserUseCase */
    );
  }
}
```

## Сравнение с другими паттернами

- [[MVC]]: Чистая архитектура имеет более строгую структуру и разделение слоев
- [[MVP]]: Чистая архитектура фокусируется на бизнес-логике, а не на UI
- [[MVVM]]: Чистая архитектура не использует привязку данных, а полагается на четкое разделение слоев
- [[Flux]]: Чистая архитектура фокусируется на бизнес-логике, а не на управлении состоянием UI

## Практические рекомендации

1. **Начинайте с домена**: сначала определите бизнес-правила и сущности
2. **Используйте абстракции**: определяйте интерфейсы для внешних зависимостей
3. **Следуйте правилу зависимостей**: внутрь, никогда наружу
4. **Разделяйте ответственность**: каждый слой должен иметь четкую роль
5. **Используйте Dependency Injection**: для управления зависимостями

## Заключение

Чистая архитектура - мощный паттерн для создания гибких, тестируемых и поддерживаемых приложений. Особенно актуален в условиях современных вызовов, когда важна возможность адаптации и замены компонентов без переписывания всей бизнес-логики.

## См. также

- [[MVC]]
- [[MVP]]
- [[MVVM]]
- [[Flux]]
- [[Архитектурные-паттерны]]
- [[Hexagonal Architecture]]
- [[Dependency Injection]]