---
aliases: ["Профилирование", "Анализ производительности", "Performance profiling"]
tags: [frontend-performance, profiling, optimization, monitoring]
---

# Профилирование производительности фронтенд-приложений

## Введение

Профилирование производительности является ключевым этапом оптимизации фронтенд-приложений. В 2025 году, с ростом сложности веб-приложений и разнообразия устройств в России, систематический анализ производительности позволяет выявлять узкие места, принимать обоснованные решения по оптимизации и обеспечивать стабильную работу приложений в различных условиях.

## Основные метрики производительности

### Core Web Vitals

Ключевые метрики, определяющие качество пользовательского опыта:

- **Largest Contentful Paint (LCP)** - время загрузки самого большого элемента видимой области (цель: < 2.5с)
- **First Input Delay (FID)** - время отклика на первое взаимодействие пользователя (цель: < 100мс)
- **Cumulative Layout Shift (CLS)** - стабильность макета (цель: < 0.1)

```javascript
// Измерение Core Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // Отправка метрик в аналитическую систему
  console.log(metric.name, metric.value, metric.delta, metric.id, metric.entries);
  
  // Отправка на сервер для анализа
  navigator.sendBeacon('/api/vitals', JSON.stringify({
    metric: metric.name,
    value: metric.value,
    delta: metric.delta,
    id: metric.id,
    timestamp: Date.now()
  }));
}

// Регистрация метрик
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### Дополнительные метрики

- **First Contentful Paint (FCP)** - время первого рендеринга контента
- **Time to Interactive (TTI)** - время до готовности приложения к взаимодействию
- **Total Blocking Time (TBT)** - суммарное время блокировки основного потока
- **First Meaningful Paint (FMP)** - время рендеринга основного содержимого

## Инструменты профилирования

### Chrome DevTools

#### Performance Panel

```javascript
// Пример использования Performance Observer API для мониторинга
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'measure') {
      console.log(`${entry.name}: ${entry.duration}ms`);
    } else if (entry.entryType === 'navigation') {
      console.log(`Navigation: ${entry.loadEventEnd - entry.fetchStart}ms`);
    } else if (entry.entryType === 'paint') {
      console.log(`${entry.name}: ${entry.startTime}ms`);
    }
  }
});

observer.observe({ entryTypes: ['measure', 'navigation', 'paint', 'largest-contentful-paint'] });
```

#### Memory Panel

Для анализа утечек памяти и оптимизации использования ресурсов:

- Heap snapshot - анализ использования памяти
- Allocation instrumentation - отслеживание выделения памяти
- Garbage collection - мониторинг сборки мусора

#### Network Panel

Для анализа сетевых запросов:

- Время загрузки ресурсов
- Размеры и форматы файлов
- HTTP-заголовки и кэширование

### Встроенные API браузера

#### User Timing API

```javascript
// Измерение времени выполнения конкретных операций
function measureOperation(operation, name) {
  performance.mark(`${name}-start`);
  
  const result = operation();
  
  performance.mark(`${name}-end`);
  performance.measure(name, `${name}-start`, `${name}-end`);
  
  const measure = performance.getEntriesByName(name)[0];
  console.log(`${name}: ${measure.duration}ms`);
  
  return result;
}

// Пример использования
measureOperation(() => {
  // Вычислительно сложная операция
  return heavyComputation();
}, 'heavy-computation');

// Измерение времени загрузки компонента
class ComponentWithTiming {
  constructor() {
    this.startMark = `component-init-${Date.now()}`;
    performance.mark(this.startMark);
  }
  
  initialize() {
    // Логика инициализации компонента
    this.render();
    
    performance.mark('component-init-end');
    performance.measure('component-initialization', this.startMark, 'component-init-end');
    
    const measure = performance.getEntriesByName('component-initialization')[0];
    console.log(`Время инициализации компонента: ${measure.duration}ms`);
  }
}
```

#### Navigation Timing API

```javascript
// Анализ времени загрузки страницы
function analyzeNavigationTiming() {
  const timing = performance.timing;
  
  const loadTime = timing.loadEventEnd - timing.navigationStart;
  const domReadyTime = timing.domContentLoadedEventEnd - timing.navigationStart;
  const pageUnloadTime = timing.unloadEventEnd - timing.unloadEventStart;
  const redirectTime = timing.redirectEnd - timing.redirectStart;
  const appCacheTime = timing.domainLookupStart - timing.fetchStart;
  const dnsTime = timing.domainLookupEnd - timing.domainLookupStart;
  const tcpTime = timing.connectEnd - timing.connectStart;
  const firstByteTime = timing.responseStart - timing.navigationStart;
  const downloadTime = timing.responseEnd - timing.responseStart;
  
  console.log({
    loadTime,
    domReadyTime,
    pageUnloadTime,
    redirectTime,
    appCacheTime,
    dnsTime,
    tcpTime,
    firstByteTime,
    downloadTime
  });
}

// Современный подход с Navigation Timing Level 2
function modernNavigationTiming() {
  const navigationEntries = performance.getEntriesByType('navigation');
  
  if (navigationEntries.length > 0) {
    const navEntry = navigationEntries[0];
    
    console.log({
      // Время загрузки страницы
      loadEvent: navEntry.loadEventEnd,
      
      // Время до DOMContentLoaded
      domContentLoaded: navEntry.domContentLoadedEventEnd,
      
      // Время до первого байта
      ttfb: navEntry.responseStart - navEntry.requestStart,
      
      // Время загрузки домена
      domainLookup: navEntry.domainLookupEnd - navEntry.domainLookupStart,
      
      // Время соединения
      connect: navEntry.connectEnd - navEntry.connectStart,
      
      // Время SSL-рукопожатия
      ssl: navEntry.connectEnd - navEntry.secureConnectionStart
    });
  }
}
```

### Сторонние инструменты

#### Lighthouse

```javascript
// Интеграция с Lighthouse для автоматического анализа
// Использование в CI/CD pipeline
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouse(url) {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const options = {logLevel: 'info', output: 'html', onlyCategories: ['performance']};
  const runnerResult = await lighthouse(url, options);

  // `.report` is the HTML report as a string
  const reportHtml = runnerResult.report;
  console.log('Report is done for', runnerResult.lhr.finalUrl);
  console.log('Performance score was', runnerResult.lhr.categories.performance.score * 100);

  await chrome.kill();
}
```

#### WebPageTest

Для анализа производительности на разных устройствах и сетевых условиях:

- Тестирование с различными типами соединений
- Анализ по географическому расположению
- Сравнение с конкурентами

## Профилирование JavaScript

### Выявление "горячих" функций

```javascript
// Инструментирование кода для профилирования
class Profiler {
  constructor() {
    this.metrics = new Map();
  }
  
  wrap(fn, name) {
    return (...args) => {
      const start = performance.now();
      const result = fn.apply(this, args);
      const end = performance.now();
      
      if (!this.metrics.has(name)) {
        this.metrics.set(name, { count: 0, total: 0, avg: 0 });
      }
      
      const metric = this.metrics.get(name);
      metric.count++;
      metric.total += end - start;
      metric.avg = metric.total / metric.count;
      
      return result;
    };
  }
  
  getMetrics() {
    return Object.fromEntries(this.metrics);
  }
  
  reset() {
    this.metrics.clear();
  }
}

// Использование профайлера
const profiler = new Profiler();

const expensiveFunction = profiler.wrap((data) => {
  // Вычислительно сложная операция
  return data.map(item => item * 2).filter(item => item > 10);
}, 'expensive-function');

// Вызов функции
expensiveFunction([1, 5, 10, 15, 20]);

// Анализ результатов
console.log(profiler.getMetrics());
```

### Асинхронное профилирование

```javascript
// Профилирование асинхронных операций
class AsyncProfiler {
  async measureAsync(operation, name) {
    const start = performance.now();
    
    try {
      const result = await operation();
      const end = performance.now();
      
      console.log(`${name}: ${end - start}ms`);
      return result;
    } catch (error) {
      const end = performance.now();
      console.error(`${name} failed: ${end - start}ms`, error);
      throw error;
    }
  }
  
  // Профилирование Promise-цепочек
  async measurePromiseChain(promiseFactory, name) {
    const start = performance.now();
    
    try {
      const result = await promiseFactory();
      const end = performance.now();
      
      console.log(`${name}: ${end - start}ms`);
      return result;
    } catch (error) {
      const end = performance.now();
      console.error(`${name} failed: ${end - start}ms`, error);
      throw error;
    }
  }
}

// Пример использования
const asyncProfiler = new AsyncProfiler();

async function fetchData() {
  return asyncProfiler.measureAsync(async () => {
    const response = await fetch('/api/data');
    return response.json();
  }, 'fetch-data');
}
```

## Профилирование рендеринга

### Измерение времени рендеринга

```javascript
// Профилирование рендеринга компонентов
class RenderProfiler {
  constructor() {
    this.renderTimes = new Map();
  }
  
  async measureRender(renderFunction, componentName) {
    const start = performance.now();
    
    // Ожидаем завершения всех асинхронных операций рендеринга
    await renderFunction();
    
    const end = performance.now();
    const duration = end - start;
    
    if (!this.renderTimes.has(componentName)) {
      this.renderTimes.set(componentName, []);
    }
    
    this.renderTimes.get(componentName).push(duration);
    
    // Логирование, если время рендеринга превышает порог
    if (duration > 16.67) { // Превышает 1 фрейм при 60 FPS
      console.warn(`Компонент ${componentName} рендерится слишком долго: ${duration}ms`);
    }
    
    return duration;
  }
  
  getAverageRenderTime(componentName) {
    const times = this.renderTimes.get(componentName);
    if (!times || times.length === 0) return 0;
    
    const sum = times.reduce((acc, time) => acc + time, 0);
    return sum / times.length;
  }
  
  getMetrics() {
    const metrics = {};
    for (const [name, times] of this.renderTimes) {
      metrics[name] = {
        average: this.getAverageRenderTime(name),
        count: times.length,
        max: Math.max(...times),
        min: Math.min(...times)
      };
    }
    return metrics;
  }
}

// Интеграция с React
import { useEffect } from 'react';

const renderProfiler = new RenderProfiler();

function ProfilingComponent({ children }) {
  useEffect(() => {
    renderProfiler.measureRender(() => {
      // Рендеринг компонента завершен
    }, 'ProfilingComponent');
  });
  
  return <div>{children}</div>;
}
```

### Анализ производительности анимаций

```javascript
// Профилирование анимаций
class AnimationProfiler {
  constructor() {
    this.frameTimes = [];
    this.lastFrameTime = performance.now();
    this.animationId = null;
  }
  
  startProfiling() {
    this.lastFrameTime = performance.now();
    this.animate();
  }
  
  animate = () => {
    const currentTime = performance.now();
    const frameTime = currentTime - this.lastFrameTime;
    this.lastFrameTime = currentTime;
    
    this.frameTimes.push(frameTime);
    
    // Проверка, поддерживаем ли мы 60 FPS (16.67мс на кадр)
    if (frameTime > 16.67) {
      console.warn(`Фрейм пропущен: ${frameTime}ms`);
    }
    
    this.animationId = requestAnimationFrame(this.animate);
  }
  
  stopProfiling() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    const fps = 1000 / avgFrameTime;
    
    console.log(`Среднее время фрейма: ${avgFrameTime}ms`);
    console.log(`Средний FPS: ${fps}`);
    
    return { avgFrameTime, fps, frameTimes: this.frameTimes };
  }
  
  reset() {
    this.frameTimes = [];
    this.lastFrameTime = performance.now();
  }
}

// Использование
const animationProfiler = new AnimationProfiler();
animationProfiler.startProfiling();

// Через некоторое время
const metrics = animationProfiler.stopProfiling();
```

## Профилирование сетевых запросов

### Измерение времени загрузки ресурсов

```javascript
// Профилирование сетевых запросов
class NetworkProfiler {
  constructor() {
    this.requests = [];
  }
  
  async profileRequest(url, options = {}) {
    const startTime = performance.now();
    const startTimestamp = Date.now();
    
    try {
      const response = await fetch(url, options);
      
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      // Получение дополнительной информации из Performance API
      const entries = performance.getEntriesByName(url);
      const entry = entries.length > 0 ? entries[0] : null;
      
      const requestInfo = {
        url,
        status: response.status,
        duration,
        startTime: startTimestamp,
        endTime: Date.now(),
        size: response.headers.get('Content-Length'),
        type: response.headers.get('Content-Type'),
        // Детализация времени запроса
        timing: entry ? {
          redirect: entry.redirectEnd - entry.redirectStart,
          dns: entry.domainLookupEnd - entry.domainLookupStart,
          tcp: entry.connectEnd - entry.connectStart,
          request: entry.responseStart - entry.requestStart,
          response: entry.responseEnd - entry.responseStart
        } : null
      };
      
      this.requests.push(requestInfo);
      return response;
    } catch (error) {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.requests.push({
        url,
        error: error.message,
        duration,
        startTime: startTimestamp,
        endTime: Date.now()
      });
      
      throw error;
    }
  }
  
  getSlowestRequests(limit = 5) {
    return this.requests
      .filter(req => !req.error)
      .sort((a, b) => b.duration - a.duration)
      .slice(0, limit);
  }
  
  getMetrics() {
    const successfulRequests = this.requests.filter(req => !req.error);
    const failedRequests = this.requests.filter(req => req.error);
    
    const avgDuration = successfulRequests.length > 0
      ? successfulRequests.reduce((sum, req) => sum + req.duration, 0) / successfulRequests.length
      : 0;
    
    return {
      total: this.requests.length,
      successful: successfulRequests.length,
      failed: failedRequests.length,
      avgDuration,
      slowest: this.getSlowestRequests(5)
    };
  }
}

// Использование
const networkProfiler = new NetworkProfiler();

async function fetchData() {
  const response = await networkProfiler.profileRequest('/api/data');
  return response.json();
}
```

## Автоматизированное профилирование

### Continuous Performance Monitoring

```javascript
// Система непрерывного мониторинга производительности
class ContinuousPerformanceMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 0.1, // 10% сэмплирование
      reportingThreshold: 100, // отправлять данные каждые 100ms
      ...options
    };
    
    this.metrics = {
      navigation: [],
      resource: [],
      paint: [],
      interaction: []
    };
    
    this.buffer = [];
    this.reportingInterval = null;
    
    this.init();
  }
  
  init() {
    // Случайное сэмплирование
    if (Math.random() > this.options.sampleRate) {
      return; // Не собираем данные для этого пользователя
    }
    
    this.setupPerformanceObservers();
    this.startReporting();
  }
  
  setupPerformanceObservers() {
    // Навигационные события
    const navObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.buffer.push({
          type: 'navigation',
          data: entry.toJSON(),
          timestamp: Date.now()
        });
      }
    });
    navObserver.observe({ entryTypes: ['navigation'] });
    
    // Ресурсные события
    const resourceObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.buffer.push({
          type: 'resource',
          data: entry.toJSON(),
          timestamp: Date.now()
        });
      }
    });
    resourceObserver.observe({ entryTypes: ['resource'] });
    
    // События отрисовки
    const paintObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.buffer.push({
          type: 'paint',
          data: entry.toJSON(),
          timestamp: Date.now()
        });
      }
    });
    paintObserver.observe({ entryTypes: ['paint', 'largest-contentful-paint'] });
    
    // Взаимодействие с пользователем
    this.setupInteractionMonitoring();
  }
  
  setupInteractionMonitoring() {
    let interactionStart = 0;
    
    // Мониторинг кликов
    document.addEventListener('click', () => {
      interactionStart = performance.now();
    });
    
    // Мониторинг ввода
    document.addEventListener('keydown', () => {
      interactionStart = performance.now();
    });
    
    // Измерение задержки отклика
    document.addEventListener('click', () => {
      if (interactionStart) {
        const fid = performance.now() - interactionStart;
        
        this.buffer.push({
          type: 'interaction',
          data: { fid, type: 'click' },
          timestamp: Date.now()
        });
      }
    }, true);
  }
  
  startReporting() {
    this.reportingInterval = setInterval(() => {
      if (this.buffer.length > 0) {
        this.sendPerformanceData(this.buffer);
        this.buffer = [];
      }
    }, this.options.reportingThreshold);
  }
  
  sendPerformanceData(data) {
    // Отправка данных на сервер аналитики
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/performance', JSON.stringify(data));
    } else {
      // Резервный метод для старых браузеров
      fetch('/api/performance', {
        method: 'POST',
        body: JSON.stringify(data),
        keepalive: true
      }).catch(err => console.error('Failed to send performance data:', err));
    }
  }
  
  destroy() {
    if (this.reportingInterval) {
      clearInterval(this.reportingInterval);
    }
  }
}

// Инициализация мониторинга
const monitor = new ContinuousPerformanceMonitor({
  sampleRate: 0.05, // 5% сэмплирование для продакшена
  reportingThreshold: 5000 // Отправка каждые 5 секунд
});
```

## Практические рекомендации для российских реалий

### Учет разнообразия устройств и сетей

```javascript
// Адаптивное профилирование в зависимости от характеристик устройства
class AdaptiveProfiler {
  constructor() {
    this.deviceClass = this.classifyDevice();
    this.profileSettings = this.getProfileSettings();
  }
  
  classifyDevice() {
    // Классификация устройства по характеристикам
    const connection = navigator.connection || {};
    const deviceMemory = navigator.deviceMemory || 4; // по умолчанию 4GB
    const hardwareConcurrency = navigator.hardwareConcurrency || 4;
    
    if (deviceMemory <= 2 && hardwareConcurrency <= 2) {
      return 'low-end';
    } else if (deviceMemory <= 4 && hardwareConcurrency <= 4) {
      return 'mid-range';
    } else {
      return 'high-end';
    }
  }
  
  getProfileSettings() {
    // Настройки профилирования в зависимости от класса устройства
    const settings = {
      'high-end': {
        sampleRate: 0.2, // 20% сэмплирование
        detailedMetrics: true,
        heavyProfiling: true
      },
      'mid-range': {
        sampleRate: 0.1, // 10% сэмплирование
        detailedMetrics: true,
        heavyProfiling: false
      },
      'low-end': {
        sampleRate: 0.05, // 5% сэмплирование
        detailedMetrics: false,
        heavyProfiling: false
      }
    };
    
    return settings[this.deviceClass];
  }
  
  shouldProfile() {
    return Math.random() <= this.profileSettings.sampleRate;
  }
  
  setupProfiling() {
    if (!this.shouldProfile()) {
      return; // Не запускаем профилирование на этом устройстве
    }
    
    // Устанавливаем профилирование в зависимости от возможностей устройства
    if (this.profileSettings.detailedMetrics) {
      this.setupDetailedProfiling();
    } else {
      this.setupBasicProfiling();
    }
  }
  
  setupDetailedProfiling() {
    // Подробное профилирование для мощных устройств
    console.log('Запуск подробного профилирования');
    // Установка всех наблюдателей и измерений
  }
  
  setupBasicProfiling() {
    // Базовое профилирование для слабых устройств
    console.log('Запуск базового профилирования');
    // Установка только основных измерений
  }
}
```

### Локализованные метрики

```javascript
// Сбор метрик с учетом географического положения
class RegionalPerformanceMetrics {
  constructor() {
    this.region = this.detectRegion();
    this.metrics = {
      loadTimes: [],
      errorRates: [],
      userSatisfaction: []
    };
  }
  
  async detectRegion() {
    try {
      // Определение региона пользователя
      const response = await fetch('/api/region', { 
        method: 'GET',
        cache: 'no-cache'
      });
      const regionData = await response.json();
      return regionData;
    } catch (error) {
      console.warn('Не удалось определить регион, используем значение по умолчанию');
      return { country: 'RU', city: 'Moscow' };
    }
  }
  
  collectMetrics() {
    // Сбор метрик с привязкой к региону
    this.collectLoadTimes();
    this.collectErrorRates();
    this.collectUserFeedback();
  }
  
  collectLoadTimes() {
    // Измерение времени загрузки с разбивкой по регионам
    const measureLoadTime = () => {
      const timing = performance.timing;
      const loadTime = timing.loadEventEnd - timing.navigationStart;
      
      this.metrics.loadTimes.push({
        time: loadTime,
        region: this.region,
        timestamp: Date.now(),
        connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown'
      });
    };
    
    if (performance.timing.loadEventEnd > 0) {
      measureLoadTime();
    } else {
      window.addEventListener('load', measureLoadTime);
    }
  }
  
  collectErrorRates() {
    // Сбор информации об ошибках
    window.addEventListener('error', (event) => {
      this.metrics.errorRates.push({
        error: event.error,
        url: event.filename,
        line: event.lineno,
        column: event.colno,
        region: this.region,
        timestamp: Date.now()
      });
    });
    
    // Сбор Promise ошибок
    window.addEventListener('unhandledrejection', (event) => {
      this.metrics.errorRates.push({
        error: event.reason,
        type: 'unhandled-promise-rejection',
        region: this.region,
        timestamp: Date.now()
      });
    });
  }
  
  collectUserFeedback() {
    // Сбор обратной связи от пользователей
    // Можно интегрировать с системами опросов или оценки удовлетворенности
  }
}
```

## Заключение

Профилирование производительности фронтенд-приложений в 2025 году требует комплексного подхода, включающего как локальные инструменты разработки, так и системы непрерывного мониторинга в продакшене. Особенно важно учитывать российские реалии - разнообразие устройств, сетевых условий и географических особенностей. Регулярное профилирование позволяет выявлять узкие места до того, как они повлияют на пользовательский опыт, и принимать обоснованные решения по оптимизации приложения.

## См. также

- [[Оптимизация-загрузки]]
- [[Оптимизация-рендеринга]]
- [[Оптимизация-сети]]
- [[Кэширование]]
- [[Архитектура фронтенд-приложений]]
- [[Web Performance]]
- [[Chrome DevTools]]
- [[Core Web Vitals]]