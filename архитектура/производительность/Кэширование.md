---
aliases: ["Кэширование", "HTTP кэширование", "Клиентское кэширование", "Серверное кэширование"]
tags: [frontend-performance, caching, optimization, storage]
---

# Кэширование в фронтенд-приложениях

## Введение

Кэширование является одним из ключевых методов оптимизации производительности фронтенд-приложений. В 2025 году, с учетом российских реалий и разнообразия сетевых условий, эффективное кэширование позволяет значительно сократить время загрузки, уменьшить нагрузку на сервер и улучшить пользовательский опыт. Правильная стратегия кэширования особенно важна для обеспечения быстрой работы приложений в условиях ограниченной пропускной способности интернета.

## Типы кэширования

### HTTP кэширование

HTTP кэширование является основой для большинства стратегий кэширования в веб-приложениях:

```http
# Пример HTTP-заголовков для кэширования
Cache-Control: max-age=3600, public
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
```

#### Заголовки Cache-Control

```javascript
// Пример настройки кэширования для разных типов ресурсов
const cacheStrategies = {
  // Статические ресурсы (CSS, JS, изображения) - долгосрочное кэширование
  static: 'public, max-age=31536000, immutable', // 1 год
  
  // API-ответы с коротким сроком жизни
  api: 'public, max-age=300', // 5 минут
  
  // Личные данные пользователя
  private: 'private, max-age=60', // 1 минута
  
  // Временные данные
  temporary: 'no-cache' // Проверять свежесть при каждом запросе
};

// Middleware для Express.js
function cacheMiddleware(req, res, next) {
  const path = req.path;
  
  if (path.endsWith('.css') || path.endsWith('.js')) {
    res.set('Cache-Control', cacheStrategies.static);
  } else if (path.startsWith('/api/')) {
    res.set('Cache-Control', cacheStrategies.api);
  } else if (path.startsWith('/user/')) {
    res.set('Cache-Control', cacheStrategies.private);
  }
  
  next();
}
```

#### Валидация кэша (ETag, Last-Modified)

```javascript
// Пример реализации ETag в Express.js
const crypto = require('crypto');

function generateETag(data) {
  return `"${crypto.createHash('sha1').update(data).digest('hex')}"`;
}

app.get('/api/data', (req, res) => {
  const data = getData();
  const etag = generateETag(JSON.stringify(data));
  
  // Проверяем, не изменились ли данные с последнего запроса
  if (req.headers['if-none-match'] === etag) {
    return res.status(304).end(); // Not Modified
  }
  
  res.set('ETag', etag);
  res.json(data);
});
```

### Кэширование в браузере

#### Memory Cache (In-Memory Cache)

- Кэширует ресурсы в оперативной памяти
- Самый быстрый способ доступа к данным
- Очищается при закрытии вкладки/браузера

#### Disk Cache

- Кэширует ресурсы на жестком диске
- Более медленный доступ, но данные сохраняются между сессиями
- Управляемый браузером, но подчиняется HTTP-заголовкам

#### Service Worker Cache

```javascript
// service-worker.js
const CACHE_VERSION = 'v1.0.0';
const CACHE_STATIC = `static-${CACHE_VERSION}`;
const CACHE_DYNAMIC = `dynamic-${CACHE_VERSION}`;

const STATIC_ASSETS = [
  '/',
  '/styles/main.css',
  '/js/main.js',
  '/offline.html'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_STATIC)
      .then((cache) => cache.addAll(STATIC_ASSETS))
  );
});

self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Для статических ресурсов используем cache-first стратегию
  if (isStaticAsset(request.url)) {
    event.respondWith(
      caches.match(request)
        .then((response) => response || fetch(request))
    );
  } 
  // Для API-запросов используем network-first стратегию
  else if (isApiRequest(request.url)) {
    event.respondWith(
      caches.match(request)
        .then((cachedResponse) => {
          const fetchPromise = fetch(request)
            .then((networkResponse) => {
              // Обновляем кэш свежими данными
              caches.open(CACHE_DYNAMIC)
                .then((cache) => cache.put(request, networkResponse.clone()));
              return networkResponse;
            });
          
          // Возвращаем кэшированный ответ, если сетевой запрос не удался
          return cachedResponse || fetchPromise;
        })
    );
  }
});

function isStaticAsset(url) {
  return /\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf)$/i.test(url);
}

function isApiRequest(url) {
  return /\/api\//.test(url);
}
```

## Клиентские хранилища

### localStorage

```javascript
class LocalStorageCache {
  constructor(namespace = 'app-cache') {
    this.namespace = namespace;
  }
  
  set(key, value, ttl = null) {
    const item = {
      value,
      timestamp: Date.now(),
      ttl: ttl ? Date.now() + ttl : null
    };
    
    try {
      localStorage.setItem(`${this.namespace}:${key}`, JSON.stringify(item));
    } catch (error) {
      console.warn('localStorage переполнен:', error);
      this.cleanup();
    }
  }
  
  get(key) {
    try {
      const itemStr = localStorage.getItem(`${this.namespace}:${key}`);
      if (!itemStr) return null;
      
      const item = JSON.parse(itemStr);
      
      // Проверяем, не истек ли срок действия
      if (item.ttl && Date.now() > item.ttl) {
        this.remove(key);
        return null;
      }
      
      return item.value;
    } catch (error) {
      console.error('Ошибка при чтении из localStorage:', error);
      return null;
    }
  }
  
  remove(key) {
    localStorage.removeItem(`${this.namespace}:${key}`);
  }
  
  cleanup() {
    // Удаляем устаревшие записи
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.startsWith(`${this.namespace}:`)) {
        const itemStr = localStorage.getItem(key);
        const item = JSON.parse(itemStr);
        
        if (item.ttl && Date.now() > item.ttl) {
          localStorage.removeItem(key);
        }
      }
    }
  }
}

// Использование
const cache = new LocalStorageCache('myapp');
cache.set('user-data', { name: 'Иван', role: 'admin' }, 3600000); // 1 час
const userData = cache.get('user-data');
```

### sessionStorage

```javascript
class SessionStorageCache {
  constructor(namespace = 'session-cache') {
    this.namespace = namespace;
  }
  
  set(key, value) {
    try {
      sessionStorage.setItem(`${this.namespace}:${key}`, JSON.stringify(value));
    } catch (error) {
      console.error('Ошибка при записи в sessionStorage:', error);
    }
  }
  
  get(key) {
    try {
      const itemStr = sessionStorage.getItem(`${this.namespace}:${key}`);
      return itemStr ? JSON.parse(itemStr) : null;
    } catch (error) {
      console.error('Ошибка при чтении из sessionStorage:', error);
      return null;
    }
  }
  
  remove(key) {
    sessionStorage.removeItem(`${this.namespace}:${key}`);
  }
  
  clear() {
    // Удаляем только кэшированные данные нашего приложения
    const keysToRemove = [];
    for (let i = 0; i < sessionStorage.length; i++) {
      const key = sessionStorage.key(i);
      if (key.startsWith(`${this.namespace}:`)) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => sessionStorage.removeItem(key));
  }
}
```

### IndexedDB

```javascript
class IndexedDBCache {
  constructor(dbName = 'AppCache', version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Создаем хранилище объектов для кэширования
        if (!db.objectStoreNames.contains('cache')) {
          const store = db.createObjectStore('cache', { keyPath: 'key' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('ttl', 'ttl', { unique: false });
        }
      };
    });
  }
  
  async set(key, value, ttl = null) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    const record = {
      key,
      value,
      timestamp: Date.now(),
      ttl: ttl ? Date.now() + ttl : null
    };
    
    return new Promise((resolve, reject) => {
      const request = store.put(record);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async get(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readonly');
    const store = transaction.objectStore('cache');
    const request = store.get(key);
    
    return new Promise((resolve, reject) => {
      request.onsuccess = () => {
        const result = request.result;
        
        if (!result) {
          resolve(null);
          return;
        }
        
        // Проверяем срок действия
        if (result.ttl && Date.now() > result.ttl) {
          this.remove(key); // Удаляем устаревшую запись
          resolve(null);
          return;
        }
        
        resolve(result.value);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async remove(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async cleanup() {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    const ttlIndex = store.index('ttl');
    
    // Получаем все устаревшие записи
    const request = ttlIndex.openCursor(IDBKeyRange.upperBound(Date.now()));
    
    return new Promise((resolve, reject) => {
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor && cursor.value.ttl) {
          cursor.delete();
          cursor.continue();
        } else {
          resolve();
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
}
```

## Стратегии кэширования

### Cache-First

```javascript
// Service Worker стратегия: сначала кэш, потом сеть
async function cacheFirstStrategy(request) {
  const cache = await caches.open('static-v1');
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  const networkResponse = await fetch(request);
  cache.put(request, networkResponse.clone());
  return networkResponse;
}
```

### Network-First

```javascript
// Service Worker стратегия: сначала сеть, потом кэш
async function networkFirstStrategy(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open('dynamic-v1');
      cache.put(request, networkResponse.clone());
      return networkResponse;
    }
  } catch (error) {
    console.warn('Сетевой запрос не удался, используем кэш:', error);
  }
  
  // Возвращаем кэшированный ответ
  const cache = await caches.open('dynamic-v1');
  return await cache.match(request);
}
```

### Stale-While-Revalidate

```javascript
// Service Worker стратегия: возвращаем кэшированный ответ, обновляем в фоне
async function staleWhileRevalidateStrategy(request) {
  const cache = await caches.open('dynamic-v1');
  const cachedResponse = await cache.match(request);
  
  // Запускаем обновление в фоне
  const networkPromise = fetch(request)
    .then(async (networkResponse) => {
      if (networkResponse.ok) {
        cache.put(request, networkResponse.clone());
      }
      return networkResponse;
    });
  
  // Возвращаем кэшированный ответ, если есть, иначе ждем сети
  return cachedResponse || networkPromise;
}
```

## Кэширование данных приложения

### Кэширование API-ответов

```javascript
class ApiCache {
  constructor(ttl = 300000) { // 5 минут по умолчанию
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  async get(key, fetcher) {
    const cached = this.cache.get(key);
    
    if (cached) {
      const { data, timestamp } = cached;
      if (Date.now() - timestamp < this.ttl) {
        return data;
      }
    }
    
    // Данные устарели или отсутствуют, делаем запрос
    const data = await fetcher();
    this.cache.set(key, { data, timestamp: Date.now() });
    
    return data;
  }
  
  set(key, data) {
    this.cache.set(key, { data, timestamp: Date.now() });
  }
  
  clear() {
    this.cache.clear();
  }
  
  remove(key) {
    this.cache.delete(key);
  }
}

// Использование
const apiCache = new ApiCache(60000); // 1 минута

async function fetchUserProfile(userId) {
  return apiCache.get(`user-${userId}`, async () => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  });
}
```

### Кэширование вычислений

```javascript
class MemoizationCache {
  constructor() {
    this.cache = new Map();
  }
  
  memoize(fn, keyFn = JSON.stringify) {
    return (...args) => {
      const key = keyFn(args);
      
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }
      
      const result = fn.apply(this, args);
      this.cache.set(key, result);
      
      return result;
    };
  }
  
  clear() {
    this.cache.clear();
  }
}

// Пример использования
const memoCache = new MemoizationCache();

// Вычислительно сложная функция
const expensiveCalculation = memoCache.memoize((a, b, operation) => {
  console.log('Выполняем вычисление...'); // Будет выведено только при первом вызове
  
  switch (operation) {
    case 'multiply':
      return a * b;
    case 'power':
      return Math.pow(a, b);
    default:
      return a + b;
  }
});

// Первый вызов - выполнит вычисление
console.log(expensiveCalculation(5, 3, 'multiply')); // 15

// Второй вызов - вернет кэшированный результат
console.log(expensiveCalculation(5, 3, 'multiply')); // 15 (без "Выполняем вычисление...")
```

## Практические рекомендации для российских реалий

### Учет сетевых ограничений

```javascript
// Адаптивная стратегия кэширования в зависимости от качества соединения
class AdaptiveCache {
  constructor() {
    this.cacheStrategies = {
      '4g': { ttl: 300000, maxSize: 100 }, // 5 минут, 100 записей
      '3g': { ttl: 180000, maxSize: 50 },  // 3 минуты, 50 записей
      '2g': { ttl: 60000, maxSize: 25 },   // 1 минута, 25 записей
      'slow-2g': { ttl: 30000, maxSize: 10 } // 30 секунд, 10 записей
    };
    
    this.currentStrategy = this.cacheStrategies['4g']; // по умолчанию
    this.updateStrategy();
  }
  
  updateStrategy() {
    if ('connection' in navigator) {
      const connection = navigator.connection;
      this.currentStrategy = this.cacheStrategies[connection.effectiveType] || 
                            this.cacheStrategies['4g'];
    }
  }
  
  async get(key, fetcher) {
    // Обновляем стратегию при каждом запросе
    this.updateStrategy();
    
    // Реализация кэширования с учетом текущей стратегии
    // ...
  }
}
```

### Офлайн-режим

```javascript
// Кэширование для работы в офлайн-режиме
class OfflineCache {
  constructor() {
    this.offlineData = new Map();
    this.syncQueue = [];
  }
  
  async saveForOffline(key, data) {
    this.offlineData.set(key, {
      data,
      timestamp: Date.now(),
      synced: false
    });
    
    // Сохраняем в IndexedDB для персистентности
    if ('indexedDB' in window) {
      const cache = new IndexedDBCache('offline-cache');
      await cache.set(key, data, 86400000); // 24 часа
    }
  }
  
  async getOfflineData(key) {
    // Сначала проверяем IndexedDB
    if ('indexedDB' in window) {
      const cache = new IndexedDBCache('offline-cache');
      const data = await cache.get(key);
      if (data) return data;
    }
    
    // Если нет IndexedDB или данных нет, проверяем Map
    const item = this.offlineData.get(key);
    if (item && !item.synced) {
      return item.data;
    }
    
    return null;
  }
  
  async syncWhenOnline() {
    if (navigator.onLine) {
      // Синхронизируем все данные в очереди
      for (const item of this.syncQueue) {
        try {
          await fetch('/api/sync', {
            method: 'POST',
            body: JSON.stringify(item),
            headers: { 'Content-Type': 'application/json' }
          });
          
          // Удаляем из очереди после успешной синхронизации
          this.syncQueue.splice(this.syncQueue.indexOf(item), 1);
        } catch (error) {
          console.error('Ошибка синхронизации:', error);
          // Оставляем в очереди для повторной попытки
        }
      }
    }
  }
}
```

## Мониторинг и анализ кэширования

### Измерение эффективности кэширования

```javascript
class CacheMetrics {
  constructor() {
    this.hits = 0;
    this.misses = 0;
    this.errors = 0;
  }
  
  recordHit() {
    this.hits++;
    this.sendMetrics();
  }
  
  recordMiss() {
    this.misses++;
    this.sendMetrics();
  }
  
  recordError() {
    this.errors++;
    this.sendMetrics();
  }
  
  getHitRate() {
    const total = this.hits + this.misses;
    return total > 0 ? (this.hits / total) * 100 : 0;
  }
  
  sendMetrics() {
    // Отправка метрик в систему мониторинга
    if (window.gtag) {
      gtag('event', 'cache_hit_rate', {
        event_category: 'Performance',
        value: Math.round(this.getHitRate())
      });
    }
  }
}

// Интеграция с кэшем
class MonitoredCache {
  constructor() {
    this.cache = new Map();
    this.metrics = new CacheMetrics();
  }
  
  get(key) {
    if (this.cache.has(key)) {
      this.metrics.recordHit();
      return this.cache.get(key);
    } else {
      this.metrics.recordMiss();
      return null;
    }
  }
  
  set(key, value) {
    try {
      this.cache.set(key, value);
    } catch (error) {
      this.metrics.recordError();
      throw error;
    }
  }
}
```

## Заключение

Кэширование в фронтенд-приложениях требует комплексного подхода, учитывающего типы данных, частоту обновления, качество сетевого соединения и специфику российских реалий 2025 года. Правильная стратегия кэширования может значительно улучшить производительность приложения и пользовательский опыт, особенно в условиях ограниченной пропускной способности интернета. Важно регулярно анализировать эффективность кэширования и адаптировать стратегии под изменяющиеся условия использования.

## См. также

- [[Оптимизация-загрузки]]
- [[Оптимизация-рендеринга]]
- [[Оптимизация-сети]]
- [[Профилирование]]
- [[Service Workers]]
- [[IndexedDB]]
- [[Web Storage API]]
- [[HTTP кэширование]]