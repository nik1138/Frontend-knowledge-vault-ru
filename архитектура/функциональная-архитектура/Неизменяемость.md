---
aliases: [Immutability, Неизменяемые данные, Иммутабельность]
tags: [programming, functional-programming, javascript, frontend, state-management]
---

# Неизменяемость

## Определение

**Неизменяемость** (immutability) — это свойство объекта не изменяться после его создания. В контексте программирования это означает, что после создания значения его нельзя изменить. Вместо этого создаются новые значения на основе старых.

## Принципы неизменяемости

1. **Значения не изменяются**: после создания объекта или значения его нельзя модифицировать
2. **Создание новых значений**: при необходимости изменения создается новое значение на основе старого
3. **Сохранение оригинала**: исходное значение остается неизменным
4. **Без побочных эффектов**: работа с неизменяемыми данными исключает неожиданные изменения в других частях кода

## Примеры в JavaScript

### Примитивные типы (всегда неизменяемы)
```javascript
let name = 'Alice';
name.toUpperCase(); // возвращает новое значение 'ALICE'
console.log(name); // 'Alice' - оригинальное значение не изменилось
```

### Массивы и объекты (по умолчанию изменяемы)
```javascript
// Изменяемый массив
let numbers = [1, 2, 3];
numbers.push(4); // изменяет оригинальный массив
console.log(numbers); // [1, 2, 3, 4]

// Неизменяемая альтернатива
let numbers2 = [1, 2, 3];
let newNumbers = [...numbers2, 4]; // создает новый массив
console.log(numbers2); // [1, 2, 3] - оригинальный массив не изменился
console.log(newNumbers); // [1, 2, 3, 4] - новый массив
```

### Объекты
```javascript
// Изменяемый объект
let user = { name: 'Alice', age: 30 };
user.age = 31; // изменяет оригинальный объект

// Неизменяемая альтернатива
let user2 = { name: 'Alice', age: 30 };
let updatedUser = { ...user2, age: 31 }; // создает новый объект
console.log(user2); // { name: 'Alice', age: 30 } - оригинальный объект не изменился
console.log(updatedUser); // { name: 'Alice', age: 31 } - новый объект
```

## Встроенные методы для неизменяемости

JavaScript предоставляет методы, которые создают новые значения:

### Массивы
```javascript
const originalArray = [1, 2, 3, 4, 5];

// Эти методы возвращают новые массивы
const mapped = originalArray.map(x => x * 2);
const filtered = originalArray.filter(x => x > 2);
const sliced = originalArray.slice(1, 3);
const concatenated = originalArray.concat([6, 7]);

// Оригинальный массив остается неизменным
console.log(originalArray); // [1, 2, 3, 4, 5]
```

### Объекты
```javascript
const originalObj = { name: 'Alice', age: 30 };

// Object.assign и spread-оператор создают новые объекты
const newObj1 = Object.assign({}, originalObj, { age: 31 });
const newObj2 = { ...originalObj, age: 32 };

// Оригинальный объект остается неизменным
console.log(originalObj); // { name: 'Alice', age: 30 }
```

## Библиотеки для неизменяемости

### Immer
```javascript
import { produce } from 'immer';

const originalState = {
  user: { name: 'Alice', age: 30 },
  posts: ['post1', 'post2']
};

const newState = produce(originalState, (draft) => {
  draft.user.age = 31;
  draft.posts.push('post3');
});

// Оригинальное состояние не изменилось
console.log(originalState.user.age); // 30
console.log(newState.user.age); // 31
```

### Immutable.js
```javascript
import { Map, List } from 'immutable';

const originalMap = Map({ a: 1, b: 2, c: 3 });
const newMap = originalMap.set('d', 4);

console.log(originalMap.get('d')); // undefined
console.log(newMap.get('d')); // 4
```

## Преимущества неизменяемости

- **Предотвращение побочных эффектов**: изменения в одной части приложения не влияют на другие
- **Упрощение отладки**: проще отслеживать изменения состояния
- **Улучшенная производительность**: возможность оптимизации через поверхностное сравнение
- **Безопасность в многопоточной среде**: неизменяемые данные безопасны для конкурентного доступа
- **Упрощение тестирования**: предсказуемое поведение кода
- **Упрощение логики отмены/повтора действий**: легко хранить историю состояний

## Практическое применение в фронтенд-разработке

### 1. Управление состоянием
```javascript
// Redux с неизменяемостью
const initialState = {
  todos: [],
  filter: 'all'
};

function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: action.id,
            text: action.text,
            completed: false
          }
        ]
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.id
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    default:
      return state;
  }
}
```

### 2. React компоненты
```javascript
import React, { useState } from 'react';

function TodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    // Создаем новый массив вместо изменения существующего
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };

  const toggleTodo = (id) => {
    // Создаем новый массив с обновленным элементом
    setTodos(
      todos.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };

  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          <span
            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
            onClick={() => toggleTodo(todo.id)}
          >
            {todo.text}
          </span>
        </div>
      ))}
    </div>
  );
}
```

## Практические рекомендации для российских реалий 2025

- Использование неизменяемости при работе с Redux, Zustand и другими системами управления состоянием
- Применение библиотек типа Immer для упрощения работы с неизменяемыми структурами данных
- Обучение команд работе с неизменяемыми паттернами
- Интеграция с TypeScript для документирования неизменяемых интерфейсов
- Использование ESLint-правил для предотвращения мутаций
- Применение неизменяемости в SSR для обеспечения консистентности между сервером и клиентом

## Неизменяемость и производительность

Хотя создание новых объектов может казаться ресурсоемким, современные JavaScript-движки оптимизируют эту операцию. Кроме того:

- Виртуальный DOM React эффективно обрабатывает изменения неизменяемых структур
- Алгоритмы сравнения могут использовать оптимизации при работе с неизменяемыми данными
- Некоторые библиотеки используют структурное совместное использование (structural sharing)

## Связь с другими концепциями

- [[Функциональное-программирование]] - неизменяемость как один из ключевых принципов
- [[Чистые-функции]] - часто используют неизменяемые данные
- [[Композиция]] - работает лучше с неизменяемыми структурами
- [[Тестирование]] - упрощается при работе с неизменяемыми данными

## Заключение

Неизменяемость - мощный инструмент для создания более предсказуемого и надежного кода. В условиях современной фронтенд-разработки в России в 2025 году, неизменяемость становится важной частью архитектурных решений, особенно при создании сложных приложений с высокими требованиями к надежности и производительности.