---
aliases: [Testing, Тестирование функций, Функциональное тестирование]
tags: [testing, functional-programming, javascript, frontend, architecture, quality]
---

# Тестирование

## Введение

**Тестирование** в контексте функционального программирования имеет свои особенности и преимущества. Благодаря использованию [[Чистые-функции]], [[Неизменяемость]] и [[Композиция]], функциональный подход значительно упрощает процесс тестирования и повышает надежность кода.

## Особенности тестирования функционального кода

### 1. Тестирование чистых функций

Чистые функции обладают следующими свойствами, которые делают их идеальными для тестирования:

- **Детерминированность**: одинаковые входные данные всегда дают одинаковый результат
- **Отсутствие побочных эффектов**: не зависят от внешнего состояния
- **Независимость**: не имеют скрытых зависимостей

```javascript
// Пример чистой функции для тестирования
const calculateDiscount = (price, discountPercent) => {
  if (discountPercent < 0 || discountPercent > 100) {
    throw new Error('Discount percent must be between 0 and 100');
  }
  return price - (price * discountPercent / 100);
};

// Простой тест для чистой функции
describe('calculateDiscount', () => {
  it('should calculate discount correctly', () => {
    expect(calculateDiscount(100, 20)).toBe(80);
    expect(calculateDiscount(50, 10)).toBe(45);
    expect(calculateDiscount(200, 25)).toBe(150);
  });

  it('should throw error for invalid discount percent', () => {
    expect(() => calculateDiscount(100, -1)).toThrow('Discount percent must be between 0 and 100');
    expect(() => calculateDiscount(100, 101)).toThrow('Discount percent must be between 0 and 100');
  });
});
```

### 2. Property-based testing

Одним из мощных подходов к тестированию функционального кода является property-based testing (тестирование на свойствах), который особенно эффективен для чистых функций:

```javascript
import fc from 'fast-check';

// Тестирование свойства: скидка всегда меньше или равна исходной цене
fc.assert(
  fc.property(
    fc.float({ min: 0, max: 1000000 }),
    fc.integer({ min: 0, max: 100 }),
    (price, discount) => {
      const result = calculateDiscount(price, discount);
      return result <= price;
    }
  )
);
```

## Типы тестов в функциональной архитектуре

### 1. Unit-тесты

Unit-тесты особенно эффективны для функционального кода, так как каждая функция изолирована:

```javascript
// Функция преобразования данных пользователя
const formatUserData = (userData) => ({
  id: userData.id,
  fullName: `${userData.firstName} ${userData.lastName}`,
  email: userData.email.toLowerCase(),
  age: new Date().getFullYear() - new Date(userData.birthDate).getFullYear()
});

// Unit-тест
describe('formatUserData', () => {
  it('should format user data correctly', () => {
    const input = {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      email: 'JOHN.DOE@EXAMPLE.COM',
      birthDate: '1990-01-01'
    };

    const expected = {
      id: 1,
      fullName: 'John Doe',
      email: 'john.doe@example.com',
      age: new Date().getFullYear() - 1990
    };

    expect(formatUserData(input)).toEqual(expected);
  });
});
```

### 2. Integration-тесты

При тестировании композиции функций можно проверить, как они работают вместе:

```javascript
// Композиция функций
const processUserData = pipe(
  validateUser,
  formatUserData,
  enrichWithDefaults
);

// Integration-тест
describe('processUserData', () => {
  it('should process user data through the entire pipeline', () => {
    const input = { firstName: 'Jane', lastName: 'Doe', email: 'JANE@EXAMPLE.COM' };
    const result = processUserData(input);
    
    expect(result.fullName).toBe('Jane Doe');
    expect(result.email).toBe('jane@example.com');
    expect(result.status).toBe('active'); // добавлено через enrichWithDefaults
  });
});
```

### 3. Snapshot-тесты

Snapshot-тесты особенно полезны для функций, возвращающих сложные структуры данных:

```javascript
// Функция генерации отчета
const generateReport = (data) => {
  return {
    summary: calculateSummary(data),
    charts: generateCharts(data),
    recommendations: getRecommendations(data)
  };
};

// Snapshot-тест
describe('generateReport', () => {
  it('should generate report with correct structure', () => {
    const testData = getSampleData();
    const report = generateReport(testData);
    
    expect(report).toMatchSnapshot();
  });
});
```

## Тестирование композиции функций

Тестирование композиции функций требует особого подхода:

```javascript
// Функция композиции
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

// Тестирование композиции
describe('function composition', () => {
  const add = x => x + 1;
  const multiply = x => x * 2;
  const square = x => x * x;

  it('should compose functions correctly', () => {
    const composed = pipe(add, multiply, square);
    // (3 + 1) * 2 = 8, 8 * 8 = 64
    expect(composed(3)).toBe(64);
  });

  it('should handle identity function', () => {
    const identity = x => x;
    const composed = pipe(identity, identity, identity);
    expect(composed(42)).toBe(42);
  });
});
```

## Практические рекомендации по тестированию

### 1. Использование моков и стабов

Даже в функциональном программировании могут быть зависимости, которые нужно мокать:

```javascript
// Функция с внешней зависимостью
const fetchUserData = (apiClient) => async (userId) => {
  const response = await apiClient.get(`/users/${userId}`);
  return formatUserData(response.data);
};

// Тест с моком
describe('fetchUserData', () => {
  it('should fetch and format user data', async () => {
    const mockApiClient = {
      get: jest.fn().mockResolvedValue({ data: { firstName: 'John', lastName: 'Doe', email: 'JOHN@EXAMPLE.COM' } })
    };

    const fetcher = fetchUserData(mockApiClient);
    const result = await fetcher(1);

    expect(mockApiClient.get).toHaveBeenCalledWith('/users/1');
    expect(result.fullName).toBe('John Doe');
    expect(result.email).toBe('john@example.com');
  });
});
```

### 2. Тестирование ошибок

Тестирование обработки ошибок в функциональном стиле:

```javascript
// Функция с обработкой ошибок
const safeDivide = (a, b) => {
  if (b === 0) {
    throw new Error('Division by zero');
  }
  return a / b;
};

describe('safeDivide', () => {
  it('should divide correctly when divisor is not zero', () => {
    expect(safeDivide(10, 2)).toBe(5);
    expect(safeDivide(15, 3)).toBe(5);
  });

  it('should throw error when dividing by zero', () => {
    expect(() => safeDivide(10, 0)).toThrow('Division by zero');
  });
});
```

## Практические рекомендации для российских реалий 2025

- Использование Jest, Vitest или других современных фреймворков для тестирования
- Применение property-based testing с библиотеками типа fast-check
- Интеграция тестов в CI/CD pipelines
- Обучение команд тестированию функционального кода
- Использование TypeScript для дополнительной проверки типов
- Автоматизация тестирования в системах доставки кода
- Внедрение практик TDD (Test-Driven Development) в функциональном стиле

## Инструменты для тестирования

### Jest
```javascript
// Использование Jest для тестирования функций
describe('functional utilities', () => {
  test('map function should transform array elements', () => {
    const numbers = [1, 2, 3, 4];
    const doubled = numbers.map(n => n * 2);
    
    expect(doubled).toEqual([2, 4, 6, 8]);
  });
});
```

### Testing Library
```javascript
// Тестирование компонентов с функциональной логикой
import { render, screen } from '@testing-library/react';

test('should display formatted user data', () => {
  const userData = { firstName: 'John', lastName: 'Doe' };
  render(<UserProfile user={formatUserData(userData)} />);
  
  expect(screen.getByText('John Doe')).toBeInTheDocument();
});
```

## Тестирование в контексте архитектуры

### 1. Тестирование архитектурных слоев

```javascript
// Тестирование слоя бизнес-логики
describe('business logic layer', () => {
  it('should correctly apply business rules', () => {
    const order = createOrder({ items: [item1, item2], discount: 10 });
    const processedOrder = processOrder(order);
    
    expect(processedOrder.total).toBeLessThan(processedOrder.subtotal);
    expect(processedOrder.status).toBe('processed');
  });
});
```

### 2. Тестирование состояния

При использовании неизменяемых структур данных тестирование состояния становится проще:

```javascript
// Тестирование редьюсера (Redux)
const initialState = { items: [], filter: 'all' };

describe('todo reducer', () => {
  it('should add a todo', () => {
    const action = { type: 'ADD_TODO', payload: { id: 1, text: 'Test' } };
    const newState = todosReducer(initialState, action);
    
    expect(newState.items).toHaveLength(1);
    expect(newState.items[0].text).toBe('Test');
  });
});
```

## Связь с другими концепциями

- [[Функциональное-программирование]] - тестирование как важная часть функциональной парадигмы
- [[Чистые-функции]] - упрощают процесс тестирования
- [[Неизменяемость]] - делает тестирование более предсказуемым
- [[Композиция]] - позволяет тестировать как отдельные функции, так и их комбинации

## Заключение

Тестирование в функциональной архитектуре становится более надежным и предсказуемым благодаря использованию чистых функций, неизменяемости и композиции. В условиях российского рынка фронтенд-разработки в 2025 году, качественное тестирование функционального кода становится критически важным для создания надежных и масштабируемых приложений. Понимание особенностей тестирования функционального кода позволяет разработчикам создавать более качественные продукты с меньшими затратами на сопровождение.