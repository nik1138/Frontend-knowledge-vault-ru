---
aliases: ["Паттерны архитектуры", "Архитектурные шаблоны", "Шаблоны проектирования"]
tags: [frontend, architecture, patterns, design]
---

# Архитектурные паттерны фронтенд-приложений

## Введение

Архитектурные паттерны — это проверенные временем решения типичных проблем проектирования, которые возникают при разработке фронтенд-приложений. В условиях российского ИТ-ландшафта 2025 года, с его специфическими требованиями к безопасности, независимости от западных технологий и необходимости быстрой адаптации к изменениям, знание и применение этих паттернов становится особенно важным.

## Классические архитектурные паттерны

### MVC (Model-View-Controller)

Один из самых известных архитектурных паттернов, разделяющий приложение на три основных компонента:

- **Model**: представляет данные и бизнес-логику
- **View**: отображает данные пользователю
- **Controller**: обрабатывает пользовательский ввод и координирует работу Model и View

В современном фронтенде этот паттерн адаптирован под компонентный подход:

```typescript
// Model
class UserModel {
  private data: User;
  
  async fetch(id: string) {
    this.data = await api.getUser(id);
    return this.data;
  }
  
  get() {
    return this.data;
  }
}

// Controller (в современном фронтенде это часто хуки или сервисы)
const useUserController = () => {
  const [user, setUser] = useState<User | null>(null);
  const model = new UserModel();
  
  const loadUser = async (id: string) => {
    const userData = await model.fetch(id);
    setUser(userData);
  };
  
  return { user, loadUser };
};

// View (компонент)
const UserView = () => {
  const { user, loadUser } = useUserController();
  
  useEffect(() => {
    loadUser('123');
  }, []);
  
  return <div>{user?.name}</div>;
};
```

### MVP (Model-View-Presenter)

Улучшенная версия MVC, где Presenter выступает в роли посредника между View и Model. Presenter содержит всю логику отображения, что упрощает тестирование.

```typescript
// Presenter
interface UserPresenter {
  loadUser(id: string): void;
  getUser(): User | null;
}

class UserPresenterImpl implements UserPresenter {
  private model: UserModel;
  private view: UserView;
  
  constructor(model: UserModel, view: UserView) {
    this.model = model;
    this.view = view;
  }
  
  async loadUser(id: string) {
    const user = await this.model.fetch(id);
    this.view.displayUser(user);
  }
  
  getUser() {
    return this.model.get();
  }
}
```

### MVVM (Model-View-ViewModel)

Популярен в приложениях на Angular и Vue.js, где ViewModel обеспечивает двустороннюю привязку данных между View и Model.

## Современные архитектурные паттерны

### Flux/Redux Pattern

Архитектурный паттерн, предложенный Facebook для управления состоянием в JavaScript-приложениях. Основные принципы:

- Единое хранилище состояния
- Неизменяемое состояние
- Чистые функции редьюсеров
- Действия (actions) для изменения состояния

```typescript
// Action
interface Action {
  type: string;
  payload?: any;
}

// Reducer
const userReducer = (state: UserState = initialState, action: Action): UserState => {
  switch (action.type) {
    case 'USER_LOADING':
      return { ...state, loading: true };
    case 'USER_LOADED':
      return { ...state, loading: false, user: action.payload };
    case 'USER_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

// Store
const store = createStore(userReducer);
```

### Container/Component Pattern

Разделение компонентов на:

- **Контейнеры**: отвечают за получение данных, бизнес-логику и состояние
- **Компоненты**: отвечают только за отображение (также известны как "тупые" компоненты)

```typescript
// Container
const UserProfileContainer = () => {
  const { data: user, loading, error } = useUserQuery();
  const { updateUser } = useUserMutation();
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <UserProfileComponent
      user={user}
      onUpdate={updateUser}
    />
  );
};

// Component
const UserProfileComponent = ({ 
  user, 
  onUpdate 
}: { 
  user: User; 
  onUpdate: (data: Partial<User>) => void; 
}) => (
  <div className="user-profile">
    <h2>{user.name}</h2>
    <button onClick={() => onUpdate({ name: 'New Name' })}>
      Update Name
    </button>
  </div>
);
```

### Repository Pattern

Паттерн, который абстрагирует доступ к данным и предоставляет единый интерфейс для работы с различными источниками данных:

```typescript
interface UserRepository {
  getUser(id: string): Promise<User>;
  updateUser(id: string, data: Partial<User>): Promise<User>;
  deleteUser(id: string): Promise<void>;
}

class HttpUserRepository implements UserRepository {
  async getUser(id: string): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
  
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
      headers: { 'Content-Type': 'application/json' }
    });
    return response.json();
  }
  
  async deleteUser(id: string): Promise<void> {
    await fetch(`/api/users/${id}`, { method: 'DELETE' });
  }
}
```

### Service Layer Pattern

Паттерн, который выносит бизнес-логику в отдельные сервисы, что упрощает тестирование и повторное использование:

```typescript
class UserService {
  constructor(
    private userRepository: UserRepository,
    private notificationService: NotificationService
  ) {}
  
  async updateUserProfile(userId: string, data: Partial<User>): Promise<User> {
    // Бизнес-логика проверки данных
    if (!this.isValidUser(data)) {
      throw new Error('Invalid user data');
    }
    
    const updatedUser = await this.userRepository.updateUser(userId, data);
    
    // Отправка уведомления
    await this.notificationService.notify(
      updatedUser.email, 
      'Profile updated successfully'
    );
    
    return updatedUser;
  }
  
  private isValidUser(data: Partial<User>): boolean {
    // Логика валидации
    return !!data.name && data.name.length > 2;
  }
}
```

### State Machine Pattern

Паттерн, который моделирует поведение объекта как конечный автомат. Особенно полезен для управления сложными состояниями UI:

```typescript
import { createMachine, assign } from 'xstate';

const userFormMachine = createMachine({
  id: 'userForm',
  initial: 'idle',
  context: {
    user: null,
    error: null
  },
  states: {
    idle: {
      on: { SUBMIT: 'submitting' }
    },
    submitting: {
      invoke: {
        src: 'updateUser',
        onDone: { target: 'success', actions: assign({ user: (context, event) => event.data }) },
        onError: { target: 'error', actions: assign({ error: (context, event) => event.data }) }
      }
    },
    success: {
      on: { RESET: 'idle' }
    },
    error: {
      on: { RETRY: 'submitting', RESET: 'idle' }
    }
  }
});
```

## Паттерны для модульности и масштабируемости

### Feature-Sliced Design

Современный архитектурный подход, который делит приложение на слои и срезы по фичам:

- **domain**: бизнес-сущности и логика
- **entities**: бизнес-сущности приложения
- **features**: фичи, связывающие сущности
- **pages**: страницы приложения
- **widgets**: виджеты интерфейса
- **app**: настройки и конфигурация приложения

```
src/
├── entities/
│   ├── user/
│   ├── product/
│   └── cart/
├── features/
│   ├── auth/
│   ├── add-to-cart/
│   └── user-profile/
├── pages/
│   ├── main/
│   ├── product/
│   └── profile/
├── widgets/
│   ├── header/
│   └── footer/
└── app/
    ├── providers/
    └── config/
```

### Micro-frontend Architecture

Архитектурный подход, при котором крупное приложение разбивается на независимые части, каждая из которых может разрабатываться, тестироваться и деплоиться отдельно:

```typescript
// Определение микросервиса
interface MicroFrontend {
  mount(container: HTMLElement, props?: any): void;
  unmount(): void;
}

// Реализация
class UserProfileMicroFrontend implements MicroFrontend {
  mount(container: HTMLElement, props?: any) {
    ReactDOM.render(
      <UserProfile {...props} />,
      container
    );
  }
  
  unmount() {
    ReactDOM.unmountComponentAtNode(container);
  }
}
```

## Паттерны управления состоянием

### State Colocation

Принцип, согласно которому состояние должно находиться как можно ближе к компоненту, который его использует:

```typescript
// Плохо: поднятие состояния выше необходимости
const App = () => {
  const [searchTerm, setSearchTerm] = useState('');
  
  return (
    <div>
      <SearchInput value={searchTerm} onChange={setSearchTerm} />
      <UserList searchTerm={searchTerm} />
    </div>
  );
};

// Хорошо: состояние находится ближе к компоненту, который его использует
const SearchableUserList = () => {
  const [searchTerm, setSearchTerm] = useState('');
  
  return (
    <div>
      <SearchInput value={searchTerm} onChange={setSearchTerm} />
      <UserList searchTerm={searchTerm} />
    </div>
  );
};
```

### State Normalization

Паттерн, при котором сложные данные нормализуются для упрощения управления состоянием:

```typescript
// Ненормализованные данные
const usersWithPosts = [
  {
    id: '1',
    name: 'John',
    posts: [
      { id: '1', title: 'Post 1', userId: '1' },
      { id: '2', title: 'Post 2', userId: '1' }
    ]
  }
];

// Нормализованные данные
const normalizedState = {
  users: {
    '1': { id: '1', name: 'John', postIds: ['1', '2'] }
  },
  posts: {
    '1': { id: '1', title: 'Post 1', userId: '1' },
    '2': { id: '2', title: 'Post 2', userId: '1' }
  }
};
```

## Российские особенности и специфика

### Замещение импортных решений

В условиях санкций и ограничений на использование западных технологий, архитектурные паттерны должны обеспечивать:

- Возможность быстрой замены зависимостей
- Использование отечественных решений
- Независимость от западных сервисов

### Безопасность и регулирование

- Архитектура должна обеспечивать безопасность данных
- Соответствие требованиям ФСТЭК и ФСБ
- Возможность аудита и контроля

### Локализация и доступность

- Поддержка русского языка и других языков народов РФ
- Соответствие требованиям доступности
- Учет культурных особенностей пользовательского интерфейса

## Практические рекомендации

### Выбор паттерна

При выборе архитектурного паттерна учитывайте:

1. Сложность приложения
2. Размер команды
3. Требования к производительности
4. Необходимость масштабирования
5. Специфика бизнес-логики

### Комбинация паттернов

В реальных приложениях часто используются комбинации различных паттернов:

```typescript
// Использование Repository + Service Layer + Container/Component
const UserContainer = () => {
  const userService = new UserService(
    new HttpUserRepository(),
    new EmailNotificationService()
  );
  
  const { data: user, loading, error } = useQuery(
    ['user', userId],
    () => userService.getUser(userId)
  );
  
  return <UserComponent user={user} />;
};
```

### Тестирование паттернов

Каждый паттерн должен быть легко тестируемым:

- Модульные тесты для сервисов и репозиториев
- Интеграционные тесты для взаимодействия между слоями
- E2E тесты для пользовательских сценариев

## Заключение

Архитектурные паттерны фронтенд-приложений в 2025 году должны учитывать не только теоретические аспекты, но и практические ограничения, особенно в российском контексте. Правильный выбор и комбинация паттернов позволяет создавать масштабируемые, поддерживаемые и безопасные приложения.

Ключевые моменты:

1. Понимание сильных и слабых сторон каждого паттерна
2. Учет специфики проекта и команды
3. Возможность адаптации к российским требованиям
4. Поддержка безопасности и доступности

Для более глубокого понимания организации компонентов см. [[Компонентная-архитектура]] и [[Модульность]].

## См. также

- [[Основы-архитектуры]]
- [[Принципы-архитектуры]]
- [[Компонентная-архитектура]]
- [[Модульность]]