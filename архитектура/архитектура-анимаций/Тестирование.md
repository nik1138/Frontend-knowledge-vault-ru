---
aliases: ["Тестирование анимаций", "Анимационные тесты", "Тестирование UX", "UI Animation Testing"]
tags: ["#тестирование", "#анимации", "#frontend", "#качество", "#архитектура"]
---

# Тестирование анимаций

Тестирование анимаций - важная часть архитектуры фронтенд-приложений, обеспечивающая качество пользовательского опыта. В 2025 году, с увеличением сложности интерфейсов и требований к доступности, тестирование анимаций стало неотъемлемой частью процесса разработки.

## Основные типы тестирования анимаций

### 1. Функциональное тестирование

Проверяет корректность работы анимационных эффектов:

```javascript
// Пример функционального теста с использованием Jest и Testing Library
import { render, screen } from '@testing-library/react';
import { userEvent, waitFor } from '@testing-library/user-event';
import { AnimatedButton } from './AnimatedButton';

describe('AnimatedButton', () => {
  test('должен анимировать изменение цвета при наведении', async () => {
    render(<AnimatedButton>Нажми меня</AnimatedButton>);
    
    const button = screen.getByRole('button', { name: /нажми меня/i });
    
    // Симулируем наведение
    userEvent.hover(button);
    
    // Проверяем, что анимация запустилась
    await waitFor(() => {
      expect(button).toHaveClass('hovered');
    });
    
    // Проверяем конечное состояние анимации
    expect(button).toHaveStyle({ backgroundColor: 'blue' });
  });
  
  test('должен корректно завершать анимацию при клике', async () => {
    render(<AnimatedButton>Нажми меня</AnimatedButton>);
    
    const button = screen.getByRole('button', { name: /нажми меня/i });
    
    // Кликаем по кнопке
    userEvent.click(button);
    
    // Ждем завершения анимации
    await waitFor(() => {
      expect(button).toHaveClass('clicked');
    });
    
    // Проверяем, что кнопка осталась в нужном состоянии
    expect(button).toHaveAttribute('aria-pressed', 'true');
  });
});
```

### 2. Тестирование производительности

Проверяет, что анимации не снижают производительность:

```javascript
// Пример теста производительности анимаций
describe('Performance Animation Tests', () => {
  test('анимация не должна вызывать значительное падение FPS', async () => {
    const startTime = performance.now();
    
    // Запускаем анимацию
    const animation = element.animate([
      { transform: 'translateX(0px)' },
      { transform: 'translateX(100px)' }
    ], {
      duration: 1000,
      easing: 'ease-in-out'
    });
    
    // Мониторим производительность во время анимации
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'measure') {
          console.log(`${entry.name}: ${entry.duration}ms`);
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure', 'paint'] });
    
    // Ждем завершения анимации
    await animation.finished;
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    // Проверяем, что анимация заняла примерно положенное время
    expect(duration).toBeCloseTo(1000, -1); // Погрешность в 100мс
    
    observer.disconnect();
  });
  
  test('анимация не должна вызывать layout thrashing', () => {
    const initialReflows = performance.getEntriesByType('measure')
      .filter(entry => entry.name.includes('layout'))
      .length;
    
    // Выполняем анимацию
    element.style.transform = 'translateX(100px)';
    
    // Проверяем количество layout
    const finalReflows = performance.getEntriesByType('measure')
      .filter(entry => entry.name.includes('layout'))
      .length;
    
    // Не должно быть значительного увеличения layout
    expect(finalReflows - initialReflows).toBeLessThan(2);
  });
});
```

### 3. Тестирование доступности

Проверяет, что анимации соответствуют требованиям доступности:

```javascript
// Тестирование предпочтений пользователя
describe('Accessibility Animation Tests', () => {
  test('анимации должны учитывать prefers-reduced-motion', async () => {
    // Симулируем предпочтение уменьшенных анимаций
    Object.defineProperty(window, 'matchMedia', {
      writable: true,
      value: jest.fn().mockImplementation(query => ({
        matches: query.includes('prefers-reduced-motion'),
        media: query,
        onchange: null,
        addListener: jest.fn(),
        removeListener: jest.fn(),
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
      })),
    });
    
    render(<AnimatedComponent />);
    
    const element = screen.getByTestId('animated-element');
    
    // Анимация не должна запускаться при prefers-reduced-motion
    expect(element).not.toHaveClass('animating');
    expect(element).toHaveStyle({ transition: 'none' });
  });
  
  test('анимации не должны вызывать эпилептические приступы', () => {
    // Проверяем частоту мигания
    const flashingAnimation = [
      { backgroundColor: 'white' },
      { backgroundColor: 'black' },
      { backgroundColor: 'white' }
    ];
    
    // Анимация не должна мигать слишком быстро
    const timing = {
      duration: 1000, // 1 секунда - это слишком медленно для опасного мигания
      iterations: 1
    };
    
    const animation = element.animate(flashingAnimation, timing);
    
    // Проверяем, что количество изменений цвета не превышает безопасный порог
    expect(timing.duration).toBeGreaterThan(200); // Более 200мс между изменениями
  });
});
```

## Инструменты для тестирования анимаций

### 1. Jest с Puppeteer/Playwright

```javascript
// Тестирование анимаций с использованием Puppeteer
describe('Animation Testing with Puppeteer', () => {
  let browser;
  let page;
  
  beforeAll(async () => {
    browser = await puppeteer.launch({ headless: true });
    page = await browser.newPage();
  });
  
  afterAll(async () => {
    await browser.close();
  });
  
  test('проверка CSS-анимации при загрузке страницы', async () => {
    await page.goto('http://localhost:3000/animated-page');
    
    // Ждем появления анимированного элемента
    await page.waitForSelector('.animated-element');
    
    // Получаем начальное состояние
    const initialStyle = await page.evaluate(() => {
      const element = document.querySelector('.animated-element');
      return window.getComputedStyle(element).transform;
    });
    
    // Ожидаем изменение стиля через время
    await page.waitForTimeout(500); // Ждем половину анимации
    
    const currentStyle = await page.evaluate(() => {
      const element = document.querySelector('.animated-element');
      return window.getComputedStyle(element).transform;
    });
    
    // Проверяем, что стиль изменился
    expect(initialStyle).not.toEqual(currentStyle);
  });
  
  test('проверка JavaScript-анимации', async () => {
    await page.goto('http://localhost:3000/js-animations');
    
    // Триггерим анимацию
    await page.click('#trigger-animation');
    
    // Ждем завершения анимации
    await page.waitForFunction(() => {
      const element = document.querySelector('#animated-box');
      const computedStyle = window.getComputedStyle(element);
      return computedStyle.transform.includes('translateX(200px)');
    });
    
    // Проверяем конечное состояние
    const finalPosition = await page.evaluate(() => {
      const element = document.querySelector('#animated-box');
      return window.getComputedStyle(element).transform;
    });
    
    expect(finalPosition).toContain('translateX(200px)');
  });
});
```

### 2. Использование Web Animations API для тестирования

```javascript
// Утилита для тестирования Web Animations
class AnimationTestUtils {
  static async waitForAnimation(anim) {
    return anim.finished;
  }
  
  static async simulateAnimationStep(anim, progress) {
    anim.currentTime = anim.effect.getTiming().duration * progress;
    await this.tick(16); // ~60 FPS
  }
  
  static async tick(ms = 16) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  static async getAnimationState(element) {
    const animations = element.getAnimations();
    return animations.map(anim => ({
      currentTime: anim.currentTime,
      playbackRate: anim.playbackRate,
      playState: anim.playState,
      startTime: anim.startTime
    }));
  }
  
  static async createTestAnimation(element, keyframes, options) {
    const anim = element.animate(keyframes, options);
    
    // Возвращаем промис, который резолвится при завершении анимации
    const finishedPromise = anim.finished;
    
    return {
      animation: anim,
      finished: finishedPromise,
      progress: async (value) => {
        anim.currentTime = anim.effect.getTiming().duration * value;
      }
    };
  }
}

// Использование утилиты
describe('Web Animation Tests', () => {
  test('анимация должна корректно завершаться', async () => {
    const element = document.createElement('div');
    document.body.appendChild(element);
    
    const { animation, finished } = AnimationTestUtils.createTestAnimation(
      element,
      [
        { transform: 'translateX(0px)' },
        { transform: 'translateX(100px)' }
      ],
      { duration: 500 }
    );
    
    // Ждем завершения анимации
    await finished;
    
    // Проверяем конечное состояние
    expect(animation.playState).toBe('finished');
    expect(element.style.transform).toBe('translateX(100px)');
    
    document.body.removeChild(element);
  });
});
```

## Архитектура тестирования анимаций

### 1. Слой абстракции для тестирования

```javascript
// Абстракция для тестирования анимаций
class AnimationTestLayer {
  constructor() {
    this.animations = new Map();
    this.mockTimers = false;
  }
  
  enableMockTimers() {
    jest.useFakeTimers();
    this.mockTimers = true;
  }
  
  disableMockTimers() {
    if (this.mockTimers) {
      jest.useRealTimers();
      this.mockTimers = false;
    }
  }
  
  registerAnimation(id, animation) {
    this.animations.set(id, animation);
  }
  
  async waitForAnimation(id) {
    const animation = this.animations.get(id);
    if (!animation) {
      throw new Error(`Анимация с ID ${id} не найдена`);
    }
    
    if (animation.finished) {
      return animation.finished;
    }
    
    return new Promise((resolve) => {
      animation.onfinish = resolve;
    });
  }
  
  async getAllAnimations() {
    const promises = Array.from(this.animations.values()).map(anim => 
      anim.finished || new Promise(resolve => anim.onfinish = resolve)
    );
    return Promise.all(promises);
  }
  
  clearAnimations() {
    this.animations.clear();
  }
}

const animationTestLayer = new AnimationTestLayer();
```

### 2. Специфические тесты для различных библиотек

```javascript
// Тесты для Framer Motion
describe('Framer Motion Tests', () => {
  test('variants должны корректно анимироваться', async () => {
    const user = userEvent.setup();
    
    render(
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        data-testid="animated-box"
      />
    );
    
    const element = screen.getByTestId('animated-box');
    
    // Проверяем начальное состояние
    await waitFor(() => {
      expect(element).toHaveStyle({ opacity: 1 });
    });
  });
  
  test('whileHover должен срабатывать', async () => {
    const user = userEvent.setup();
    
    render(
      <motion.div
        whileHover={{ scale: 1.2 }}
        data-testid="hoverable-box"
      />
    );
    
    const element = screen.getByTestId('hoverable-box');
    
    await user.hover(element);
    
    await waitFor(() => {
      expect(element).toHaveStyle({ transform: 'scale(1.2)' });
    });
  });
});

// Тесты для GSAP
describe('GSAP Animation Tests', () => {
  test('timeline должна корректно управляться', async () => {
    const tl = gsap.timeline({ paused: true });
    
    tl.to('.box1', { x: 100, duration: 0.5 })
      .to('.box2', { y: 100, duration: 0.5 }, '-=0.25'); // Перекрывающаяся анимация
    
    // Мокаем функции для тестирования
    const playSpy = jest.spyOn(tl, 'play');
    const progressSpy = jest.spyOn(tl, 'progress');
    
    tl.play();
    
    expect(playSpy).toHaveBeenCalled();
    
    // Проверяем прогресс анимации
    expect(tl.progress()).toBeGreaterThan(0);
    expect(tl.progress()).toBeLessThanOrEqual(1);
  });
});
```

### 3. Тестирование сложных анимационных сценариев

```javascript
// Тестирование последовательных анимаций
describe('Sequential Animation Tests', () => {
  test('анимации должны выполняться в правильном порядке', async () => {
    const animationSequence = [
      { element: '.element1', animation: { x: 100 } },
      { element: '.element2', animation: { y: 100 } },
      { element: '.element3', animation: { scale: 1.5 } }
    ];
    
    const results = [];
    
    for (const step of animationSequence) {
      const element = document.querySelector(step.element);
      const animation = element.animate([
        { transform: 'none' },
        { transform: `translateX(${step.animation.x || 0}px) translateY(${step.animation.y || 0}px) scale(${step.animation.scale || 1})` }
      ], { duration: 300 });
      
      await animation.finished;
      results.push(step.element);
    }
    
    // Проверяем порядок выполнения
    expect(results).toEqual(['.element1', '.element2', '.element3']);
  });
  
  test('параллельные анимации должны запускаться одновременно', async () => {
    const startTime = performance.now();
    
    const animations = [
      document.querySelector('.box1').animate([{ transform: 'translateX(0)' }, { transform: 'translateX(100px)' }], { duration: 500 }),
      document.querySelector('.box2').animate([{ transform: 'translateY(0)' }, { transform: 'translateY(100px)' }], { duration: 500 }),
      document.querySelector('.box3').animate([{ transform: 'scale(1)' }, { transform: 'scale(1.5)' }], { duration: 500 })
    ];
    
    // Все анимации запускаются примерно в одно время
    const promises = animations.map(anim => anim.finished);
    await Promise.all(promises);
    
    const endTime = performance.now();
    const totalDuration = endTime - startTime;
    
    // Общая продолжительность должна быть близка к продолжительности самой длинной анимации
    expect(totalDuration).toBeCloseTo(500, -1); // Погрешность в 100мс
  });
});
```

## Практические рекомендации по тестированию

### 1. Мокирование анимаций для unit-тестов

```javascript
// Мокирование анимаций в тестах
class AnimationMocker {
  static mockWebAnimations() {
    const originalAnimate = Element.prototype.animate;
    
    Element.prototype.animate = function(keyframes, options) {
      // Возвращаем мок-анимацию с мгновенным завершением
      const mockAnimation = {
        currentTime: 0,
        startTime: 0,
        playState: 'running',
        playbackRate: 1,
        finished: Promise.resolve(),
        cancel: jest.fn(),
        finish: jest.fn(),
        pause: jest.fn(),
        play: jest.fn(),
        reverse: jest.fn(),
        updatePlaybackRate: jest.fn(),
        onfinish: null,
        oncancel: null
      };
      
      // Применяем конечное состояние сразу
      if (keyframes && keyframes.length > 0) {
        const finalFrame = keyframes[keyframes.length - 1];
        Object.keys(finalFrame).forEach(prop => {
          this.style[prop] = finalFrame[prop];
        });
      }
      
      return mockAnimation;
    };
    
    return () => {
      Element.prototype.animate = originalAnimate;
    };
  }
  
  static mockRequestAnimationFrame() {
    const originalRAF = window.requestAnimationFrame;
    const originalCRAF = window.cancelAnimationFrame;
    
    let rafCallbacks = [];
    let currentId = 0;
    
    window.requestAnimationFrame = (callback) => {
      const id = currentId++;
      rafCallbacks.push({ id, callback });
      return id;
    };
    
    window.cancelAnimationFrame = (id) => {
      rafCallbacks = rafCallbacks.filter(cb => cb.id !== id);
    };
    
    return {
      runRAF: () => {
        const callbacks = [...rafCallbacks];
        rafCallbacks = [];
        callbacks.forEach(cb => cb.callback(0));
      },
      restore: () => {
        window.requestAnimationFrame = originalRAF;
        window.cancelAnimationFrame = originalCRAF;
      }
    };
  }
}

// Использование в тестах
describe('Animation Tests with Mocks', () => {
  let restoreAnimations;
  let rafMock;
  
  beforeEach(() => {
    restoreAnimations = AnimationMocker.mockWebAnimations();
    rafMock = AnimationMocker.mockRequestAnimationFrame();
  });
  
  afterEach(() => {
    restoreAnimations();
    rafMock.restore();
  });
  
  test('компонент должен корректно обрабатывать анимации', () => {
    render(<AnimatedComponent />);
    
    // Выполняем действия, которые запускают анимации
    fireEvent.click(screen.getByRole('button'));
    
    // Запускаем все requestAnimationFrame
    rafMock.runRAF();
    
    // Проверяем результаты
    expect(screen.getByText('Анимация завершена')).toBeInTheDocument();
  });
});
```

### 2. Тестирование производительности анимаций

```javascript
// Утилита для измерения производительности анимаций
class AnimationPerformanceTester {
  static async measureAnimation(animationFn) {
    const startMark = 'animation_start_' + Date.now();
    const endMark = 'animation_end_' + Date.now();
    
    performance.mark(startMark);
    
    const result = await animationFn();
    
    performance.mark(endMark);
    performance.measure('animation_duration', startMark, endMark);
    
    const measure = performance.getEntriesByName('animation_duration')[0];
    
    return {
      duration: measure.duration,
      result
    };
  }
  
  static async detectLayoutThrashing(element, animationFn) {
    const initialLayoutCount = performance.getEntriesByType('measure')
      .filter(entry => entry.name.includes('layout'))
      .length;
    
    await animationFn();
    
    const finalLayoutCount = performance.getEntriesByType('measure')
      .filter(entry => entry.name.includes('layout'))
      .length;
    
    return {
      layoutCount: finalLayoutCount - initialLayoutCount,
      isThrashing: finalLayoutCount - initialLayoutCount > 5 // Порог для layout thrashing
    };
  }
  
  static async checkFPSDuringAnimation(animationFn, acceptableFPS = 50) {
    let frameCount = 0;
    let startTime = performance.now();
    
    return new Promise((resolve) => {
      const checkFrame = () => {
        frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - startTime >= 1000) { // Проверяем за 1 секунду
          const fps = frameCount;
          resolve({
            fps,
            acceptable: fps >= acceptableFPS
          });
          return;
        }
        
        requestAnimationFrame(checkFrame);
      };
      
      // Запускаем анимацию и проверку одновременно
      animationFn().then(() => {
        // Анимация завершена, прекращаем проверку FPS
        resolve({ fps: 'animation completed', acceptable: true });
      });
      
      requestAnimationFrame(checkFrame);
    });
  }
}
```

## Интеграционные тесты

```javascript
// Интеграционные тесты для анимаций
describe('Integration Animation Tests', () => {
  test('анимации должны корректно работать с состоянием приложения', async () => {
    render(<AppWithAnimations />);
    
    const user = userEvent.setup();
    
    // Изменяем состояние приложения
    await user.click(screen.getByRole('button', { name: /toggle state/i }));
    
    // Проверяем, что анимации срабатывают при изменении состояния
    await waitFor(() => {
      const animatedElement = screen.getByTestId('animated-element');
      expect(animatedElement).toHaveClass('active');
      expect(animatedElement).toHaveStyle({ transform: 'translateX(100px)' });
    });
  });
  
  test('анимации должны корректно отменяться при изменении маршрута', async () => {
    const { unmount } = render(<AnimatedRoute />);
    
    // Начинаем анимацию
    const button = screen.getByRole('button');
    userEvent.click(button);
    
    // Отменяем компонент до завершения анимации
    setTimeout(() => {
      unmount();
    }, 100);
    
    // Проверяем, что анимации корректно отменены
    await waitFor(() => {
      expect(document.querySelectorAll('.animating').length).toBe(0);
    });
  });
});
```

## Лучшие практики тестирования в российском контексте 2025 года

1. **Соответствие требованиям доступности**
   - Обязательное тестирование с `prefers-reduced-motion`
   - Проверка анимаций на предмет потенциального риска для пользователей с эпилепсией
   - Тестирование с использованием скринридеров

2. **Тестирование на различных устройствах**
   - Проверка анимаций на бюджетных устройствах, популярных в России
   - Тестирование на устройствах различных брендов (Xiaomi, Samsung, Huawei и др.)
   - Учет различий в производительности между устройствами

3. **Производительность и энергопотребление**
   - Тестирование влияния анимаций на батарею мобильных устройств
   - Проверка производительности на слабых соединениях
   - Учет особенностей использования мобильных устройств в российских условиях

4. **Культурные особенности**
   - Тестирование восприятия анимаций российской аудиторией
   - Учет культурных различий в восприятии визуальных эффектов

## Автоматизация тестирования анимаций

### 1. GitHub Actions для тестирования анимаций

```yaml
# .github/workflows/animation-tests.yml
name: Animation Tests
on: [push, pull_request]

jobs:
  test-animations:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Run animation tests
        run: npm run test:animations
      
      - name: Run performance tests
        run: npm run test:performance
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: test-results/
```

### 2. Визуальные регрессионные тесты

```javascript
// Пример визуального теста с использованием Percy
import { mount } from '@cypress/react';
import { percySnapshot } from '@percy/cypress';
import { AnimatedComponent } from './AnimatedComponent';

describe('Visual Regression Tests for Animations', () => {
  it('should render animated component correctly', () => {
    mount(<AnimatedComponent />);
    
    // Делаем снимок до анимации
    cy.get('[data-testid="animated-element"]').should('be.visible');
    percySnapshot('Animated Component - Initial State');
    
    // Триггерим анимацию
    cy.get('button').click();
    
    // Ждем завершения анимации и делаем второй снимок
    cy.get('[data-testid="animated-element"]')
      .should('have.class', 'animated')
      .then(() => {
        percySnapshot('Animated Component - After Animation');
      });
  });
});
```

## Связь с другими архитектурными компонентами

Тестирование анимаций тесно связано с другими архитектурными элементами:

- [[CSS-анимации]] - тестирование CSS-анимаций
- [[JavaScript-анимации]] - тестирование JS-анимаций
- [[Библиотеки анимаций]] - тестирование библиотек
- [[Производительность анимаций]] - тестирование производительности
- [[Архитектура интерфейсов]] - тестирование UX-анимаций
- [[Тестирование фронтенда]] - общие принципы тестирования
- [[Доступность]] - тестирование доступности анимаций

## Заключение

Тестирование анимаций - это комплексная задача, требующая учета функциональности, производительности, доступности и пользовательского опыта. В условиях российского рынка 2025 года особенно важно обеспечивать корректную работу анимаций на различных устройствах и с учетом культурных особенностей. Правильная архитектура тестирования анимаций позволяет создавать высококачественные интерфейсы, которые работают отлично для всех пользователей.