---
aliases: ["Управление доступом", "Access Control", "Права доступа"]
tags: [безопасность, авторизация, доступ, фронтенд, права-пользователей]
---

# Авторизация в фронтенд-приложениях

## Обзор

Авторизация в фронтенд-приложениях - это процесс предоставления или ограничения доступа пользователя к определенным ресурсам и функциям системы после успешной аутентификации. В условиях российских реалий 2025 года авторизация должна учитывать требования законодательства, корпоративные политики безопасности и особенности отечественных систем управления доступом.

## Основные концепции авторизации

### 1. Управление доступом (Access Control)

Процесс определения, какие субъекты могут получить доступ к каким объектам и каким образом:

- Определение прав доступа
- Проверка прав доступа
- Логирование попыток доступа

### 2. Ролевая модель (RBAC - Role-Based Access Control)

Модель управления доступом, основанная на ролях пользователей:

- Назначение ролей пользователям
- Назначение разрешений ролям
- Наследование разрешений

### 3. Атрибутно-ориентированная модель (ABAC - Attribute-Based Access Control)

Модель управления доступом, основанная на атрибутах:

- Атрибуты субъектов (пользователей)
- Атрибуты объектов (ресурсов)
- Атрибуты окружающей среды
- Правила доступа на основе атрибутов

## Архитектурные паттерны авторизации

### 1. Централизованное управление доступом

Реализация единой точки управления авторизацией:

- Единая библиотека авторизации
- Централизованное хранение прав доступа
- Единая точка проверки доступа

```javascript
// Пример централизованной системы авторизации
class AuthorizationManager {
  constructor() {
    this.userPermissions = new Map();
    this.rolePermissions = new Map();
    this.accessRules = [];
  }
  
  async initialize(user) {
    // Загрузка прав пользователя с сервера
    this.userPermissions.set(user.id, await this.fetchUserPermissions(user.id));
    
    // Загрузка ролей и прав
    const roles = await this.fetchUserRoles(user.id);
    for (const role of roles) {
      const permissions = await this.fetchRolePermissions(role.id);
      this.rolePermissions.set(role.id, permissions);
    }
  }
  
  async hasPermission(userId, resource, action) {
    const userPermissions = this.userPermissions.get(userId) || [];
    const userRoles = await this.getUserRoles(userId);
    
    // Проверка прямых разрешений
    if (this.checkDirectPermission(userPermissions, resource, action)) {
      return true;
    }
    
    // Проверка разрешений по ролям
    for (const roleId of userRoles) {
      const rolePermissions = this.rolePermissions.get(roleId) || [];
      if (this.checkRolePermission(rolePermissions, resource, action)) {
        return true;
      }
    }
    
    return false;
  }
  
  checkDirectPermission(permissions, resource, action) {
    return permissions.some(p => 
      p.resource === resource && 
      p.action === action && 
      p.granted === true
    );
  }
  
  checkRolePermission(permissions, resource, action) {
    return permissions.some(p => 
      p.resource === resource && 
      p.action === action && 
      p.granted === true
    );
  }
  
  async fetchUserPermissions(userId) {
    // Загрузка разрешений пользователя с сервера
    const response = await fetch(`/api/auth/permissions/${userId}`);
    return response.json();
  }
  
  async fetchUserRoles(userId) {
    // Загрузка ролей пользователя с сервера
    const response = await fetch(`/api/auth/roles/${userId}`);
    return response.json();
  }
  
  async fetchRolePermissions(roleId) {
    // Загрузка разрешений роли с сервера
    const response = await fetch(`/api/auth/role-permissions/${roleId}`);
    return response.json();
  }
}
```

### 2. Мандатное управление доступом (MAC)

Управление доступом на основе меток безопасности:

- Присвоение уровня безопасности ресурсам
- Проверка соответствия уровня доступа пользователя уровню ресурса

### 3. Дискреционное управление доступом (DAC)

Управление доступом на основе владельца ресурса:

- Владелец ресурса определяет права доступа
- Гибкое управление правами

## Российские особенности 2025 года

### Интеграция с корпоративными системами

- Поддержка Active Directory и отечественных аналогов
- Интеграция с системами управления идентификацией
- Соответствие требованиям по защите информации

### Специфика государственных систем

- Требования к разграничению доступа по уровням секретности
- Поддержка систематизированных уровней доступа
- Интеграция с государственными системами управления доступом

### Импортозамещение

- Использование отечественных решений для управления доступом
- Альтернативы западным системам авторизации
- Поддержка отечественных стандартов безопасности

## Практические рекомендации

### 1. Реализация ролевой системы

```javascript
// Пример реализации ролевой системы авторизации
class RoleBasedAuthorization {
  constructor() {
    this.roles = {
      'admin': {
        permissions: ['read', 'write', 'delete', 'manage_users', 'system_config']
      },
      'manager': {
        permissions: ['read', 'write', 'manage_team']
      },
      'employee': {
        permissions: ['read', 'write_own']
      },
      'guest': {
        permissions: ['read_public']
      }
    };
    
    this.userRoles = new Map(); // userId -> [roles]
    this.userPermissionsCache = new Map(); // userId -> permissions
  }
  
  async setUserRoles(userId, roles) {
    this.userRoles.set(userId, roles);
    await this.updateUserPermissions(userId);
  }
  
  async updateUserPermissions(userId) {
    const roles = this.userRoles.get(userId) || [];
    const permissions = new Set();
    
    for (const roleName of roles) {
      const role = this.roles[roleName];
      if (role) {
        role.permissions.forEach(permission => permissions.add(permission));
      }
    }
    
    this.userPermissionsCache.set(userId, Array.from(permissions));
  }
  
  async hasPermission(userId, permission) {
    let userPermissions = this.userPermissionsCache.get(userId);
    
    if (!userPermissions) {
      await this.updateUserPermissions(userId);
      userPermissions = this.userPermissionsCache.get(userId);
    }
    
    return userPermissions.includes(permission);
  }
  
  async canAccessResource(userId, resource, action) {
    // Проверка базового разрешения
    if (await this.hasPermission(userId, `${action}_${resource}`)) {
      return true;
    }
    
    // Проверка специфических разрешений
    if (await this.hasPermission(userId, 'admin_access')) {
      return true;
    }
    
    // Проверка собственности ресурса
    if (await this.isUserResourceOwner(userId, resource) && 
        await this.hasPermission(userId, `${action}_own_${resource}`)) {
      return true;
    }
    
    return false;
  }
  
  async isUserResourceOwner(userId, resource) {
    // Проверка, является ли пользователь владельцем ресурса
    // Реализация зависит от конкретной системы
    // ...
  }
}
```

### 2. Клиентская проверка доступа

- Проверка доступа перед отображением элементов интерфейса
- Блокировка доступа к защищенным маршрутам
- Проверка доступа перед выполнением операций

### 3. Обновление прав доступа

- Динамическое обновление прав при изменении ролей
- Кэширование прав для производительности
- Инвалидация кэша при изменении прав

## Типы авторизации

| Тип | Описание | Применение | Особенности для РФ |
|-----|----------|------------|-------------------|
| RBAC | Ролевая модель доступа | Корпоративные системы | Широко используется в госсекторе |
| ABAC | Атрибутно-ориентированная модель | Сложные системы с динамическими правами | Подходит для систем с изменяющимися требованиями |
| ACL | Списки контроля доступа | Файловые системы, сетевые ресурсы | Требуется для соответствия стандартам |
| OAuth 2.0 | Делегированная авторизация | Веб-приложения, API | Актуально для интеграций |

## Защита от обхода авторизации

### 1. Повторная проверка на сервере

- Все проверки авторизации должны дублироваться на сервере
- Фронтенд не должен быть доверенным источником

### 2. Защита маршрутов

```javascript
// Пример защиты маршрутов
class RouteAuthorization {
  constructor(authManager) {
    this.authManager = authManager;
  }
  
  async checkRouteAccess(route, user) {
    const requiredPermissions = this.getRoutePermissions(route);
    
    for (const permission of requiredPermissions) {
      if (!await this.authManager.hasPermission(user.id, permission)) {
        return false;
      }
    }
    
    return true;
  }
  
  getRoutePermissions(route) {
    const routePermissions = {
      '/admin': ['admin_access'],
      '/reports': ['read_reports'],
      '/user/profile': ['read_profile', 'write_own_profile'],
      '/user/settings': ['manage_own_settings']
    };
    
    return routePermissions[route] || [];
  }
}
```

### 3. Защита API-вызовов

- Проверка прав доступа при каждом API-вызове
- Использование токенов с ограниченными правами
- Валидация параметров запроса

## Современные подходы

### 1. Zero Trust Authorization

- Постоянная проверка прав доступа
- Проверка контекста запроса
- Минимизация привилегий

### 2. Context-aware Authorization

- Учет контекста (время, местоположение, устройство)
- Адаптивные правила доступа
- Динамическое изменение прав

> [!tip]
> Всегда дублируйте проверки авторизации на сервере - клиентский код может быть обойден.

> [!warning]
> Нарушение системы авторизации может привести к несанкционированному доступу к персональным данным, что влечет административную и уголовную ответственность по законодательству РФ.

## Заключение

Авторизация в фронтенд-приложениях требует тщательной проработки с учетом архитектурных особенностей, требований безопасности и законодательства. В условиях российских реалий 2025 года особое внимание уделяется соответствию требованиям по защите информации и интеграции с отечественными системами управления доступом.

## См. также

- [[Архитектура-безопасности]]
- [[Защита-данных]]
- [[Аутентификация]]
- [[Аудит]]
- [[Frontend Authorization Patterns]]