---
aliases: [Кэширование в веб-приложениях, Стратегии кэширования]
tags: [caching, performance, frontend, optimization]
---

# Кэширование в фронтенд-приложениях

## Обзор

Кэширование - это один из ключевых механизмов оптимизации производительности веб-приложений, позволяющий уменьшить время загрузки, снизить нагрузку на сервер и улучшить пользовательский опыт. В условиях российских реалий 2025 года, когда доступ к внешним ресурсам может быть ограничен, эффективное кэширование становится особенно важным.

## Типы кэширования

### 1. Кэширование на уровне браузера

#### HTTP кэширование
- Заголовки `Cache-Control`, `ETag`, `Last-Modified`
- Стратегии: `max-age`, `no-cache`, `no-store`, `must-revalidate`
- Примеры настройки заголовков

```
Cache-Control: public, max-age=31536000
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

#### Кэширование статических ресурсов
- Изображения, CSS, JavaScript файлы
- Версионирование ассетов для эффективной инвалидации кэша

### 2. Кэширование на уровне приложения

#### Клиентское кэширование данных
- Redux Persist
- LocalStorage и SessionStorage
- IndexedDB для сложных данных
- Кэширование API ответов

```javascript
// Пример кэширования данных в Redux
const cachedData = localStorage.getItem('apiData');
if (cachedData) {
  return JSON.parse(cachedData);
}
```

#### Кэширование компонентов
- Memoization в React
- Кэширование результатов вычислений
- Использование библиотек типа Reselect

### 3. Кэширование на уровне сервис-воркеров

#### Service Worker кэширование
- Стратегии: Cache First, Network First, Cache Falling Back to Network
- Кэширование API вызовов
- Поддержка оффлайн режима

```javascript
// Пример стратегии Cache First
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});
```

## Стратегии кэширования

### 1. Cache First (кэш в первую очередь)

- Используется для статических ресурсов
- Быстрая загрузка, минимальное использование сети
- Подходит для изображений, стилей, скриптов

### 2. Network First (сеть в первую очередь)

- Для динамических данных
- Обеспечивает актуальность информации
- Резервное кэширование при ошибках сети

### 3. Cache Falling Back to Network

- Комбинация кэша и сети
- Быстрая загрузка при наличии кэша
- Обновление данных при отсутствии кэша

### 4. Cache and Network (кэш и сеть)

- Использование кэша для быстрого отображения
- Одновременное обновление данных из сети
- Подходит для часто изменяемых данных

## Практические рекомендации

### 1. Кэширование статических ресурсов

- Установка длительного срока кэширования для ассетов с версионированием
- Использование HTTP/2 для эффективной загрузки ресурсов
- Оптимизация размера ресурсов перед кэшированием

### 2. Кэширование API данных

- Определение TTL (времени жизни) для разных типов данных
- Использование заголовков `Expires` и `Cache-Control` на сервере
- Клиентская валидация актуальности данных

### 3. Управление инвалидацией кэша

- Версионирование файлов (например, hash в имени файла)
- Тегирование кэша для групповой инвалидации
- Использование сигналов для принудительной инвалидации

## Кэширование в популярных фреймворках

### React
- Использование `React.memo` для предотвращения лишних рендеров
- Кэширование результатов с помощью `useMemo` и `useCallback`
- Библиотеки типа React Query для кэширования API данных

### Vue
- Встроенное кэширование компонентов с помощью `<keep-alive>`
- Vuex Persist для кэширования состояния
- Кэширование вычисляемых свойств

### Angular
- OnPush стратегия детекции изменений
- Кэширование HTTP запросов
- Использование RxJS для управления потоками данных

## Особенности российских реалий 2025

### Ограничения доступа
- Кэширование как способ обхода ограничений доступа к внешним ресурсам
- Локальное хранение критически важных данных
- Оптимизация для работы в условиях ограниченного доступа

### Регулирование
- Соответствие требованиям по обработке персональных данных
- Учет особенностей хранения данных на территории РФ
- Использование отечественных CDN решений

## Заключение

Эффективное кэширование требует комплексного подхода:
- Правильного выбора стратегии для разных типов данных
- Учета особенностей приложения и пользовательских сценариев
- Регулярного мониторинга эффективности кэширования
- [[Архитектура-оптимизации]] - для понимания архитектурных аспектов
- [[Профилирование]] - для анализа эффективности кэширования
- [[Ленивая-загрузка]] - для оптимизации начальной загрузки