---
aliases: [Data Models, Структуры данных, Data Structures]
tags: [frontend, architecture, data-modeling, typescript]
---

# Модели данных в фронтенд-архитектуре

## Общее понятие моделей данных

Модели данных представляют собой структурированное описание данных, с которыми работает фронтенд-приложение. Они определяют, как данные хранятся, обрабатываются и передаются между различными компонентами приложения. В 2025 году в российском IT-ландшафте особенно важна реализация моделей данных, соответствующих требованиям локализации и безопасности информации.

## Типы моделей данных

### 1. Статические модели

Статические модели данных определяют структуру данных на этапе разработки. В TypeScript это достигается с помощью интерфейсов и типов:

```typescript
interface User {
  id: number;
  email: string;
  firstName: string;
  lastName: string;
  createdAt: Date;
  isActive: boolean;
}

type UserRole = 'admin' | 'moderator' | 'user';
```

### 2. Динамические модели

Динамические модели позволяют изменять структуру данных во время выполнения. Часто используются для гибких форм и настраиваемых интерфейсов:

```typescript
interface DynamicField {
  name: string;
  type: 'text' | 'number' | 'date' | 'boolean';
  required: boolean;
  validation?: ValidationRule[];
}

interface DynamicForm {
  id: string;
  fields: DynamicField[];
  schema: Record<string, any>;
}
```

### 3. Наследуемые модели

Наследование моделей позволяет создавать иерархии данных, упрощая поддержку и расширение функциональности:

```typescript
interface BaseModel {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  version: number;
}

interface UserProfile extends BaseModel {
  userId: string;
  preferences: UserPreferences;
  settings: UserSettings;
}
```

## Практические рекомендации по проектированию

### Использование Union Types

Union Types позволяют создавать гибкие модели данных, которые могут принимать несколько различных форм:

```typescript
type PaymentMethod = 
  | { type: 'card'; cardNumber: string; expiry: string }
  | { type: 'bank'; accountNumber: string; bankCode: string }
  | { type: 'crypto'; walletAddress: string; blockchain: string };
```

### Опциональные и обязательные поля

Правильное использование опциональных полей позволяет создавать более гибкие модели данных:

```typescript
interface Product {
  id: string;
  name: string;
  price: number;
  description?: string; // Необязательное поле
  categories: string[];
  metadata?: Record<string, any>; // Дополнительные данные
  discount?: {
    percentage: number;
    validUntil: Date;
  };
}
```

## Стратегии валидации моделей

### Статическая валидация

Статическая валидация происходит на этапе компиляции с использованием TypeScript:

```typescript
interface Order {
  id: string;
  items: OrderItem[];
  total: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered';
  customer: Customer;
  billingAddress: Address;
  shippingAddress: Address;
}

// Статическая проверка гарантирует, что поля соответствуют типам
const order: Order = {
  id: '123',
  items: [],
  total: 0,
  status: 'pending', // Ошибка компиляции при неправильном значении
  customer: { /* ... */ },
  billingAddress: { /* ... */ },
  shippingAddress: { /* ... */ },
};
```

### Runtime валидация

Runtime валидация необходима при работе с внешними API:

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  id: z.number(),
  email: z.string().email(),
  firstName: z.string().min(1).max(50),
  lastName: z.string().min(1).max(50),
  age: z.number().min(18).max(120).optional(),
});

type User = z.infer<typeof UserSchema>;

function validateUser(data: unknown): User {
  return UserSchema.parse(data);
}
```

## Архитектурные паттерны для моделей данных

### Repository Pattern

Repository Pattern инкапсулирует логику доступа к данным и предоставляет чистый интерфейс для работы с моделями:

```typescript
interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  create(user: Omit<User, 'id'>): Promise<User>;
  update(id: string, data: Partial<User>): Promise<User>;
  delete(id: string): Promise<boolean>;
}
```

### Data Transfer Objects (DTO)

DTO используются для передачи данных между слоями приложения и между клиентом и сервером:

```typescript
// DTO для передачи данных пользователя
interface UserDto {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  permissions: string[];
}

// DTO для создания пользователя
interface CreateUserDto {
  email: string;
  firstName: string;
  lastName: string;
  password: string;
  role?: string;
}
```

## Локализация и международизация

В российских условиях важно учитывать требования к хранению и обработке персональных данных:

```typescript
interface PersonalData {
  id: string;
  personalInfo: {
    fullName: string;
    birthDate: Date;
    passport: {
      series: string;
      number: string;
      issuedBy: string;
      issueDate: Date;
    };
  };
  contactInfo: {
    email: string;
    phone: string;
    address: Address;
  };
  consent: {
    gdpr: boolean;
    marketing: boolean;
    dataProcessing: boolean;
  };
}
```

## Архитектурные принципы

### Принцип единственной ответственности (SRP)

Каждая модель данных должна иметь одну причину для изменения:

```typescript
// Плохо: модель с множеством ответственностей
interface BadUserModel {
  id: string;
  email: string;
  // ... 20 других полей
  calculateDiscount(): number; // Метод бизнес-логики
  validate(): boolean; // Метод валидации
}

// Хорошо: раздельные модели
interface User {
  id: string;
  email: string;
  profile: UserProfile;
  preferences: UserPreferences;
}

interface UserValidator {
  validate(user: User): ValidationResult;
}

interface UserDiscountCalculator {
  calculate(user: User): number;
}
```

### Принцип открытости/закрытости (OCP)

Модели данных должны быть открыты для расширения, но закрыты для модификации:

```typescript
// Базовая модель
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

// Расширение модели
interface Product extends BaseEntity {
  name: string;
  price: number;
  // Расширения могут добавлять поля без изменения базовой модели
}
```

## Практические советы для российских разработчиков

### 1. Соответствие требованиям 152-ФЗ

При работе с персональными данными необходимо учитывать требования российского законодательства:

```typescript
interface PersonalDataModel {
  id: string;
  data: EncryptedData;
  consent: ConsentStatus;
  retentionPeriod: Date;
  processingPurpose: ProcessingPurpose;
}
```

### 2. Работа с различными временными зонами

Россия охватывает 11 часовых поясов, что требует особого подхода к работе с датами:

```typescript
interface Event {
  id: string;
  title: string;
  startTime: string; // ISO 8601
  timezone: string; // Например: 'Europe/Moscow'
  duration: number; // в минутах
}
```

### 3. Обработка кириллических данных

При работе с русским языком необходимо учитывать особенности кодирования:

```typescript
interface RussianText {
  title: string;
  content: string;
  slug: string; // транслитерация для URL
  searchIndex: string; // для поиска
}
```

## Заключение

Правильное проектирование моделей данных является ключевым аспектом архитектуры фронтенд-приложений. В условиях российского рынка особенно важно учитывать требования безопасности, локализации и соответствия законодательству. Модели данных должны быть гибкими, легко расширяемыми и соответствовать принципам чистой архитектуры.

См. также: [[Валидация]], [[Нормализация]], [[Кэширование]], [[Синхронизация]]