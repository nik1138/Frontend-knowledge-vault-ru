---
aliases: [Data Normalization, Нормализация данных, Data Structure Optimization]
tags: [frontend, architecture, data-normalization, performance]
---

# Нормализация данных в фронтенд-архитектуре

## Общее понятие нормализации

Нормализация данных в фронтенд-приложениях — это процесс организации структуры данных для уменьшения избыточности и улучшения целостности информации. В 2025 году в российском контексте нормализация особенно важна для обеспечения эффективности работы приложений, соответствия требованиям безопасности и оптимизации производительности при работе с большими объемами данных.

## Принципы нормализации данных

### 1. Устранение избыточности

Избыточные данные увеличивают объем памяти, необходимой для хранения, и создают риск несогласованности:

```typescript
// Плохо: избыточные данные
interface BadOrder {
  id: string;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  items: {
    name: string;
    price: number;
    quantity: number;
    // Дублирование информации о пользователе в каждом элементе
    customerName: string;
    customerEmail: string;
  }[];
}

// Хорошо: нормализованные данные
interface Customer {
  id: string;
  name: string;
  email: string;
  phone: string;
}

interface OrderItem {
  id: string;
  orderId: string;
  productId: string;
  name: string;
  price: number;
  quantity: number;
}

interface Order {
  id: string;
  customerId: string;
  items: string[]; // Массив ID элементов
}
```

### 2. Единственное место хранения

Каждый фрагмент данных должен храниться в одном месте и обновляться в одном месте:

```typescript
// Нормализованная структура данных
interface NormalizedState {
  users: Record<string, User>;
  posts: Record<string, Post>;
  comments: Record<string, Comment>;
  userPosts: Record<string, string[]>; // userId -> [postId, ...]
  postComments: Record<string, string[]>; // postId -> [commentId, ...]
}
```

## Уровни нормализации

### 1. Нулевая нормальная форма (0NF)

Данные не нормализованы, могут содержать повторяющиеся группы:

```typescript
// Ненормализованные данные
const unnormalizedData = [
  {
    userId: 1,
    name: "Иван Иванов",
    orders: [
      { orderId: 101, product: "Товар 1", price: 1000 },
      { orderId: 102, product: "Товар 2", price: 1500 }
    ]
  }
];
```

### 2. Первая нормальная форма (1NF)

Устранение повторяющихся групп, каждое поле содержит атомарное значение:

```typescript
// 1NF: данные без повторяющихся групп
const firstNormalForm = {
  users: [
    { userId: 1, name: "Иван Иванов" }
  ],
  orders: [
    { orderId: 101, userId: 1, product: "Товар 1", price: 1000 },
    { orderId: 102, userId: 1, product: "Товар 2", price: 1500 }
  ]
};
```

### 3. Вторая нормальная форма (2NF)

Устранение частичных зависимостей от составного ключа:

```typescript
// 2NF: устранение частичных зависимостей
interface User {
  id: string;
  name: string;
  email: string;
}

interface Order {
  id: string;
  userId: string; // Ссылка на пользователя
  date: Date;
  total: number;
}

interface OrderItem {
  id: string;
  orderId: string; // Ссылка на заказ
  productId: string; // Ссылка на продукт
  quantity: number;
  price: number;
}

interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
}
```

## Практические стратегии нормализации

### 1. Использование схем нормализации

Библиотека Normalizr помогает нормализовать сложные JSON-структуры:

```typescript
import { normalize, schema } from 'normalizr';

// Определение схем
const user = new schema.Entity('users');
const comment = new schema.Entity('comments', {
  user: user
});
const post = new schema.Entity('posts', {
  user: user,
  comments: [comment]
});

// Нормализация данных
const originalData = {
  id: '123',
  title: 'Post title',
  user: {
    id: '321',
    name: 'Paul'
  },
  comments: [
    {
      id: '456',
      comment: 'A comment about the post',
      user: {
        id: '789',
        name: 'Jane'
      }
    }
  ]
};

const normalizedData = normalize(originalData, post);
// Результат: { entities: { ... }, result: '123' }
```

### 2. Кастомные нормализаторы

Создание собственных нормализаторов для специфичных случаев:

```typescript
interface NormalizationResult<T> {
  entities: Record<string, T>;
  references: Record<string, string[]>;
}

class DataNormalizer {
  static normalizeUsers(users: User[]): NormalizationResult<User> {
    const entities: Record<string, User> = {};
    const references: Record<string, string[]> = {};
    
    users.forEach(user => {
      entities[user.id] = {
        ...user,
        // Удаление вложенных объектов
        profile: user.profile?.id || null,
        preferences: user.preferences?.id || null
      };
      
      // Сохранение ссылок на вложенные сущности
      if (user.profile) {
        references[user.id] = references[user.id] || [];
        references[user.id].push(user.profile.id);
      }
    });
    
    return { entities, references };
  }
}
```

### 3. Денормализация при выводе

Для удобства отображения данные могут быть денормализованы:

```typescript
class DataDenormalizer {
  static denormalizeOrder(
    orderId: string, 
    entities: NormalizedState
  ): DenormalizedOrder {
    const order = entities.orders[orderId];
    if (!order) return null;
    
    return {
      ...order,
      customer: entities.users[order.customerId],
      items: order.items.map(itemId => entities.orderItems[itemId]),
    };
  }
}
```

## Архитектурные паттерны нормализации

### 1. Единое хранилище сущностей

Центральное хранилище для всех нормализованных данных:

```typescript
interface AppState {
  entities: {
    users: Record<string, User>;
    products: Record<string, Product>;
    orders: Record<string, Order>;
    orderItems: Record<string, OrderItem>;
  };
  ui: {
    currentView: string;
    loading: boolean;
    errors: string[];
  };
}
```

### 2. Нормализация в слое данных

Изолирование логики нормализации в отдельном слое:

```typescript
interface DataLayer {
  normalizeApiResponse(response: any): NormalizedData;
  denormalizeForView(data: NormalizedData): ViewData;
}

class NormalizingDataLayer implements DataLayer {
  normalizeApiResponse(response: any): NormalizedData {
    // Нормализация данных из API
    return {
      users: this.normalizeUsers(response.users),
      posts: this.normalizePosts(response.posts),
      comments: this.normalizeComments(response.comments)
    };
  }
  
  denormalizeForView(data: NormalizedData): ViewData {
    // Подготовка данных для представления
    return {
      userPosts: this.createUserPostsView(data),
      postComments: this.createPostCommentsView(data)
    };
  }
}
```

## Нормализация в контексте российских требований

### 1. Обработка персональных данных

В соответствии с 152-ФЗ, персональные данные должны быть структурированы для обеспечения безопасности:

```typescript
interface PersonalData {
  id: string;
  // Основная информация
  basicInfo: BasicInfo;
  // Контактная информация
  contactInfo: ContactInfo;
  // Согласия
  consents: ConsentRecord[];
  // История доступа
  accessHistory: AccessRecord[];
}

interface ConsentRecord {
  purpose: string;
  givenAt: Date;
  expiresAt: Date;
  givenBy: string; // ID пользователя
}
```

### 2. Оптимизация для российских реалий

Учет особенностей российского рынка при нормализации:

```typescript
// Нормализация данных для российских юридических сущностей
interface RussianLegalEntity {
  id: string;
  name: string;
  fullName: string;
  inn: string; // ИНН
  kpp: string; // КПП
  ogrn: string; // ОГРН
  legalAddress: Address;
  actualAddress: Address;
  bankDetails: BankDetails;
}

interface BankDetails {
  id: string;
  bankName: string;
  bic: string;
  correspondentAccount: string;
  settlementAccount: string;
}
```

## Практические рекомендации

### 1. Оценка степени нормализации

Не всегда полная нормализация является оптимальной:

```typescript
// Для часто читаемых данных может быть лучше денормализация
interface PopularProduct {
  id: string;
  name: string;
  category: string; // Вместо ссылки на категорию
  brand: string; // Вместо ссылки на бренд
  price: number;
  rating: number;
  reviewCount: number;
}
```

### 2. Индексация нормализованных данных

Создание индексов для ускорения доступа:

```typescript
interface IndexedNormalizedState {
  entities: {
    users: Record<string, User>;
    posts: Record<string, Post>;
  };
  indexes: {
    postsByUser: Record<string, string[]>; // userId -> [postId, ...]
    postsByCategory: Record<string, string[]>; // categoryId -> [postId, ...]
    usersByEmail: Record<string, string>; // email -> userId
  };
}
```

### 3. Миграция нормализованных данных

При изменении структуры данных необходима миграция:

```typescript
class DataMigrator {
  static migrateV1ToV2(oldData: V1Data): V2Data {
    return {
      entities: {
        users: Object.values(oldData.users).reduce((acc, user) => {
          acc[user.id] = {
            ...user,
            // Добавление новых полей
            createdAt: user.createdAt || new Date(),
            updatedAt: new Date()
          };
          return acc;
        }, {} as Record<string, User>)
      },
      indexes: {
        postsByUser: this.createPostsByUserIndex(oldData)
      }
    };
  }
}
```

## Инструменты нормализации

### 1. Redux Toolkit + RTK Query

Современный подход к нормализации данных в Redux:

```typescript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['User', 'Post'],
  endpoints: (build) => ({
    getUsers: build.query<User[], void>({
      query: () => '/users',
      providesTags: ['User'],
    }),
    getUserById: build.query<User, string>({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
    }),
  }),
});
```

### 2. Apollo Client

Автоматическая нормализация данных в Apollo Client:

```typescript
const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
      posts {
        id
        title
        content
      }
    }
  }
`;

// Apollo автоматически нормализует данные по ID
```

## Заключение

Нормализация данных в фронтенд-приложениях — это важный аспект архитектуры, который влияет на производительность, поддерживаемость и безопасность приложения. В российских условиях особенно важно учитывать требования к обработке персональных данных и оптимизировать структуру данных для эффективной работы с локализованными форматами. Баланс между полной нормализацией и удобством использования должен определяться конкретными требованиями проекта.

См. также: [[Модели-данных]], [[Валидация]], [[Кэширование]], [[Синхронизация]]