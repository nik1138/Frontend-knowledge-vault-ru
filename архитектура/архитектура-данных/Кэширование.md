---
aliases: [Data Caching, Кэширование данных, Cache Strategy]
tags: [frontend, architecture, caching, performance]
---

# Кэширование данных в фронтенд-архитектуре

## Общее понятие кэширования

Кэширование данных — это стратегия хранения часто используемых или дорогостоящих в вычислении данных во временной памяти для ускорения доступа к ним. В 2025 году в российских условиях кэширование особенно важно из-за необходимости обеспечения высокой производительности приложений при ограниченной пропускной способности и необходимости соответствия требованиям локализации данных.

## Типы кэширования

### 1. Клиентское кэширование

Клиентское кэширование включает в себя хранение данных непосредственно в браузере пользователя:

```typescript
// Простая реализация кэша в памяти
class InMemoryCache {
  private cache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();
  
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    // Проверка срока действия
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data as T;
  }
  
  set<T>(key: string, data: T, ttl: number = 300000): void { // 5 минут по умолчанию
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  delete(key: string): void {
    this.cache.delete(key);
  }
  
  clear(): void {
    this.cache.clear();
  }
}
```

### 2. HTTP-кэширование

Использование заголовков HTTP для управления кэшированием на уровне браузера:

```typescript
// Пример настройки кэширования в HTTP-запросах
const fetchWithCaching = async (url: string, options: RequestInit = {}) => {
  const cacheKey = `${url}_${JSON.stringify(options)}`;
  
  // Проверка кэша
  const cachedResponse = sessionStorage.getItem(cacheKey);
  if (cachedResponse) {
    const { data, timestamp, ttl } = JSON.parse(cachedResponse);
    if (Date.now() - timestamp < ttl) {
      return JSON.parse(data);
    }
  }
  
  // Выполнение запроса
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Cache-Control': 'public, max-age=300' // 5 минут
    }
  });
  
  const data = await response.json();
  
  // Сохранение в кэш
  sessionStorage.setItem(cacheKey, JSON.stringify({
    data: JSON.stringify(data),
    timestamp: Date.now(),
    ttl: 300000 // 5 минут
  }));
  
  return data;
};
```

### 3. Кэширование на уровне приложения

Кэширование данных в рамках архитектуры приложения:

```typescript
interface CacheConfig {
  ttl: number; // Время жизни в миллисекундах
  maxSize?: number; // Максимальный размер кэша
  staleWhileRevalidate?: boolean; // Использовать устаревшие данные при перезапросе
}

class ApplicationCache {
  private cache: Map<string, CacheEntry> = new Map();
  private config: CacheConfig;
  
  constructor(config: CacheConfig) {
    this.config = config;
  }
  
  async getOrSet<T>(key: string, fetcher: () => Promise<T>): Promise<T> {
    const cached = this.cache.get(key);
    
    if (cached) {
      // Проверка срока действия
      if (Date.now() - cached.timestamp < this.config.ttl) {
        return cached.data;
      }
      
      // Если включено staleWhileRevalidate, возвращаем старые данные и обновляем
      if (this.config.staleWhileRevalidate) {
        this.updateCache(key, fetcher);
        return cached.data;
      }
    }
    
    // Загрузка новых данных
    const data = await fetcher();
    this.set(key, data);
    return data;
  }
  
  private async updateCache<T>(key: string, fetcher: () => Promise<T>) {
    try {
      const data = await fetcher();
      this.set(key, data);
    } catch (error) {
      console.error('Ошибка обновления кэша:', error);
    }
  }
  
  private set<T>(key: string, data: T) {
    if (this.config.maxSize && this.cache.size >= this.config.maxSize) {
      // Удаление старейших записей
      const oldestKey = this.cache.keys().next().value;
      if (oldestKey) {
        this.cache.delete(oldestKey);
      }
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
}
```

## Стратегии кэширования

### 1. Cache-Aside (Lazy Loading)

Данные загружаются в кэш только при первом запросе:

```typescript
class CacheAsideStrategy {
  private cache = new InMemoryCache();
  private apiClient = new ApiClient();
  
  async getData(id: string) {
    // Сначала проверяем кэш
    let data = this.cache.get<Data>(`data_${id}`);
    
    if (!data) {
      // Если данных нет в кэше, загружаем из API
      data = await this.apiClient.fetchData(id);
      // Сохраняем в кэш
      this.cache.set(`data_${id}`, data);
    }
    
    return data;
  }
}
```

### 2. Read-Through

Кэш сам отвечает за загрузку данных:

```typescript
interface CacheLoader<T> {
  load: (key: string) => Promise<T>;
}

class ReadThroughCache<T> {
  private cache: Map<string, T> = new Map();
  private loader: CacheLoader<T>;
  private ttl: number;
  
  constructor(loader: CacheLoader<T>, ttl: number = 300000) {
    this.loader = loader;
    this.ttl = ttl;
  }
  
  async get(key: string): Promise<T> {
    const cached = this.cache.get(key);
    if (cached) {
      return cached;
    }
    
    // Кэш сам загружает данные через loader
    const data = await this.loader.load(key);
    this.cache.set(key, data);
    
    return data;
  }
}
```

### 3. Write-Through

Данные записываются как в кэш, так и в основное хранилище:

```typescript
class WriteThroughCache {
  private cache = new InMemoryCache();
  private storage: StorageService;
  
  async set(key: string, value: any) {
    // Запись в кэш
    this.cache.set(key, value);
    // Запись в основное хранилище
    await this.storage.set(key, value);
  }
  
  async update(key: string, value: any) {
    // Обновление в кэше
    this.cache.set(key, value);
    // Обновление в основном хранилище
    await this.storage.update(key, value);
  }
}
```

## Кэширование в контексте российских требований

### 1. Соответствие требованиям 152-ФЗ

При кэшировании персональных данных необходимо учитывать требования к защите информации:

```typescript
interface PersonalDataCacheConfig {
  encryption: boolean;
  retentionPeriod: number; // Период хранения
  consentRequired: boolean;
}

class PersonalDataCache {
  private cache = new InMemoryCache();
  private config: PersonalDataCacheConfig;
  
  constructor(config: PersonalDataCacheConfig) {
    this.config = config;
  }
  
  async setPersonalData(key: string, data: PersonalData) {
    // Шифрование данных перед кэшированием
    const encryptedData = this.config.encryption 
      ? await this.encrypt(data) 
      : data;
      
    // Установка срока хранения в соответствии с требованиями
    this.cache.set(key, encryptedData, this.config.retentionPeriod);
  }
  
  private async encrypt(data: PersonalData): Promise<EncryptedData> {
    // Реализация шифрования данных
    return encryptData(data);
  }
}
```

### 2. Работа с российскими CDN

Оптимизация кэширования с учетом использования российских CDN:

```typescript
class RussianCDNCache {
  private regionalCDNs = {
    'moscow': 'https://cdn-moscow.example.com',
    'spb': 'https://cdn-spb.example.com',
    'nsk': 'https://cdn-nsk.example.com'
  };
  
  async getResource(resourcePath: string, region: string) {
    const cdnUrl = this.regionalCDNs[region] || this.regionalCDNs['moscow'];
    const url = `${cdnUrl}${resourcePath}`;
    
    // Кэширование с учетом региона
    const cacheKey = `resource_${region}_${resourcePath}`;
    return await this.fetchWithRegionalCache(url, cacheKey);
  }
  
  private async fetchWithRegionalCache(url: string, cacheKey: string) {
    // Проверка локального кэша
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      const { data, timestamp, ttl } = JSON.parse(cached);
      if (Date.now() - timestamp < ttl) {
        return JSON.parse(data);
      }
    }
    
    // Загрузка из регионального CDN
    const response = await fetch(url, {
      headers: {
        'Cache-Control': 'public, max-age=86400' // 24 часа
      }
    });
    
    const data = await response.json();
    
    // Сохранение в локальный кэш
    localStorage.setItem(cacheKey, JSON.stringify({
      data: JSON.stringify(data),
      timestamp: Date.now(),
      ttl: 86400000 // 24 часа
    }));
    
    return data;
  }
}
```

## Практические реализации кэширования

### 1. Кэширование API-данных с помощью RTK Query

```typescript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ 
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    }
  }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (build) => ({
    getUser: build.query<User, string>({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
      // Кэширование на 5 минут
      keepUnusedDataFor: 300,
    }),
    updateUser: build.mutation<User, { id: string; patch: Partial<User> }>({
      query: ({ id, patch }) => ({
        url: `users/${id}`,
        method: 'PATCH',
        body: patch,
      }),
      // Инвалидация кэша при обновлении
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
    }),
  }),
});
```

### 2. Кэширование с использованием SWR

```typescript
import useSWR from 'swr';

// Кастомный fetcher с кэшированием
const fetcher = async (url: string) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Ошибка загрузки данных');
  }
  return response.json();
};

// Использование SWR с кэшированием
const useUserData = (id: string) => {
  return useSWR<User>(id ? `/api/users/${id}` : null, fetcher, {
    refreshInterval: 30000, // Обновление каждые 30 секунд
    revalidateOnFocus: false, // Не обновлять при фокусе
    dedupingInterval: 2000, // Дедупликация запросов
  });
};
```

### 3. Кэширование в localStorage с сериализацией

```typescript
class LocalStorageCache {
  private prefix: string;
  
  constructor(prefix: string = 'app-cache') {
    this.prefix = prefix;
  }
  
  set<T>(key: string, data: T, ttl: number = 3600000) { // 1 час по умолчанию
    const item = {
      data: JSON.stringify(data),
      timestamp: Date.now(),
      ttl
    };
    
    try {
      localStorage.setItem(`${this.prefix}:${key}`, JSON.stringify(item));
    } catch (error) {
      console.error('Ошибка сохранения в localStorage:', error);
      // Очистка старых записей при переполнении
      this.cleanup();
    }
  }
  
  get<T>(key: string): T | null {
    const itemStr = localStorage.getItem(`${this.prefix}:${key}`);
    if (!itemStr) return null;
    
    try {
      const item = JSON.parse(itemStr);
      
      // Проверка срока действия
      if (Date.now() - item.timestamp > item.ttl) {
        localStorage.removeItem(`${this.prefix}:${key}`);
        return null;
      }
      
      return JSON.parse(item.data) as T;
    } catch (error) {
      console.error('Ошибка чтения из кэша:', error);
      localStorage.removeItem(`${this.prefix}:${key}`);
      return null;
    }
  }
  
  private cleanup() {
    // Удаление устаревших записей
    const now = Date.now();
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(`${this.prefix}:`)) {
        const itemStr = localStorage.getItem(key);
        if (itemStr) {
          try {
            const item = JSON.parse(itemStr);
            if (now - item.timestamp > item.ttl) {
              localStorage.removeItem(key);
            }
          } catch (e) {
            localStorage.removeItem(key);
          }
        }
      }
    }
  }
}
```

## Продвинутые стратегии кэширования

### 1. Кэширование с инвалидацией по зависимостям

```typescript
class DependencyAwareCache {
  private cache: Map<string, CacheEntry> = new Map();
  private dependencies: Map<string, Set<string>> = new Map(); // зависимость -> [ключи кэша]
  
  set(key: string, data: any, dependencies: string[] = [], ttl: number = 300000) {
    // Сохраняем данные
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
      dependencies
    });
    
    // Регистрируем зависимости
    for (const dep of dependencies) {
      if (!this.dependencies.has(dep)) {
        this.dependencies.set(dep, new Set());
      }
      this.dependencies.get(dep)!.add(key);
    }
  }
  
  invalidateDependency(dependency: string) {
    const keys = this.dependencies.get(dependency);
    if (keys) {
      for (const key of keys) {
        this.cache.delete(key);
      }
    }
    this.dependencies.delete(dependency);
  }
}
```

### 2. Кэширование с предварительной загрузкой

```typescript
class PrefetchingCache {
  private cache = new InMemoryCache();
  private prefetchQueue: Array<() => Promise<void>> = [];
  
  async prefetch<T>(key: string, fetcher: () => Promise<T>, ttl: number = 300000) {
    if (this.cache.get(key)) {
      return; // Уже закэшировано
    }
    
    try {
      const data = await fetcher();
      this.cache.set(key, data, ttl);
    } catch (error) {
      console.error('Ошибка предзагрузки:', error);
    }
  }
  
  // Предзагрузка связанных данных
  async prefetchRelated(userId: string) {
    await Promise.all([
      this.prefetch(`user-${userId}`, () => this.fetchUser(userId)),
      this.prefetch(`user-posts-${userId}`, () => this.fetchUserPosts(userId)),
      this.prefetch(`user-profile-${userId}`, () => this.fetchUserProfile(userId))
    ]);
  }
}
```

## Заключение

Кэширование данных в фронтенд-приложениях — это критический компонент архитектуры, обеспечивающий высокую производительность и отзывчивость интерфейса. В российских условиях важно учитывать требования безопасности, локализации и соответствия законодательству. Эффективная стратегия кэширования должна балансировать между производительностью, свежестью данных и требованиями безопасности.

См. также: [[Модели-данных]], [[Валидация]], [[Нормализация]], [[Синхронизация]]