---
aliases: [Data Synchronization, Синхронизация данных, Real-time Sync]
tags: [frontend, architecture, synchronization, real-time, offline]
---

# Синхронизация данных в фронтенд-архитектуре

## Общее понятие синхронизации

Синхронизация данных — это процесс обеспечения согласованности данных между различными источниками, устройствами или состояниями приложения. В 2025 году в российских условиях синхронизация особенно важна из-за необходимости обеспечения работоспособности приложений в условиях нестабильного интернет-соединения и требованиям к защите персональных данных.

## Типы синхронизации данных

### 1. Синхронизация в реальном времени

Синхронизация данных в реальном времени с использованием WebSocket или Server-Sent Events:

```typescript
interface SyncMessage {
  type: 'create' | 'update' | 'delete';
  entity: string;
  id: string;
  data?: any;
  timestamp: number;
}

class RealTimeSync {
  private ws: WebSocket;
  private listeners: Map<string, Set<(data: any) => void>> = new Map();
  
  constructor(url: string) {
    this.ws = new WebSocket(url);
    this.ws.onmessage = (event) => {
      const message: SyncMessage = JSON.parse(event.data);
      this.handleSyncMessage(message);
    };
  }
  
  private handleSyncMessage(message: SyncMessage) {
    const listeners = this.listeners.get(message.entity) || new Set();
    listeners.forEach(listener => {
      switch (message.type) {
        case 'create':
          listener({ ...message.data, id: message.id, action: 'created' });
          break;
        case 'update':
          listener({ ...message.data, id: message.id, action: 'updated' });
          break;
        case 'delete':
          listener({ id: message.id, action: 'deleted' });
          break;
      }
    });
  }
  
  subscribe(entity: string, callback: (data: any) => void) {
    if (!this.listeners.has(entity)) {
      this.listeners.set(entity, new Set());
    }
    this.listeners.get(entity)!.add(callback);
  }
  
  unsubscribe(entity: string, callback: (data: any) => void) {
    const listeners = this.listeners.get(entity);
    if (listeners) {
      listeners.delete(callback);
    }
  }
}
```

### 2. Синхронизация с оффлайн-режимом

Обеспечение работы приложения при отсутствии интернет-соединения:

```typescript
interface OfflineQueueItem {
  id: string;
  operation: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

class OfflineSync {
  private online: boolean = navigator.onLine;
  private queue: OfflineQueueItem[] = [];
  private storage: StorageService;
  
  constructor(storage: StorageService) {
    this.storage = storage;
    this.init();
  }
  
  private init() {
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
    
    // Восстановление очереди из localStorage
    this.loadQueueFromStorage();
  }
  
  private loadQueueFromStorage() {
    try {
      const queueStr = localStorage.getItem('offline-queue');
      if (queueStr) {
        this.queue = JSON.parse(queueStr);
      }
    } catch (e) {
      console.error('Ошибка загрузки очереди оффлайн-операций:', e);
    }
  }
  
  private saveQueueToStorage() {
    try {
      localStorage.setItem('offline-queue', JSON.stringify(this.queue));
    } catch (e) {
      console.error('Ошибка сохранения очереди оффлайн-операций:', e);
    }
  }
  
  async sync(operation: Omit<OfflineQueueItem, 'id' | 'timestamp'>) {
    const item: OfflineQueueItem = {
      ...operation,
      id: generateId(),
      timestamp: Date.now()
    };
    
    if (this.online) {
      // Прямая синхронизация
      return await this.executeSync(item);
    } else {
      // Добавление в очередь
      this.queue.push(item);
      this.saveQueueToStorage();
      return item.id;
    }
  }
  
  private async executeSync(item: OfflineQueueItem) {
    try {
      // Выполнение операции
      await this.storage[item.operation](item.entity, item.id, item.data);
      return true;
    } catch (error) {
      // При ошибке добавляем в очередь
      this.queue.push(item);
      this.saveQueueToStorage();
      throw error;
    }
  }
  
  private async handleOnline() {
    this.online = true;
    await this.processQueue();
  }
  
  private handleOffline() {
    this.online = false;
  }
  
  private async processQueue() {
    while (this.queue.length > 0) {
      const item = this.queue.shift();
      if (item) {
        try {
          await this.executeSync(item);
        } catch (error) {
          // Возвращаем элемент в очередь при ошибке
          this.queue.unshift(item);
          break; // Прекращаем обработку при ошибке
        }
      }
    }
    this.saveQueueToStorage();
  }
}
```

### 3. Синхронизация между вкладками

Синхронизация данных между вкладками одного браузера:

```typescript
class TabSync {
  private channel: BroadcastChannel;
  private listeners: Set<(data: any) => void> = new Set();
  
  constructor(channelName: string = 'app-sync') {
    this.channel = new BroadcastChannel(channelName);
    this.channel.onmessage = (event) => {
      this.listeners.forEach(listener => listener(event.data));
    };
  }
  
  broadcast(data: any) {
    this.channel.postMessage(data);
  }
  
  subscribe(callback: (data: any) => void) {
    this.listeners.add(callback);
  }
  
  unsubscribe(callback: (data: any) => void) {
    this.listeners.delete(callback);
  }
  
  close() {
    this.channel.close();
  }
}
```

## Стратегии синхронизации

### 1. Стратегия "Последний записывает — прав"

Последнее изменение перезаписывает предыдущее:

```typescript
interface VersionedData {
  id: string;
  data: any;
  version: number;
  timestamp: number;
  lastModifiedBy: string;
}

class LastWriteWinsSync {
  private storage: Map<string, VersionedData> = new Map();
  
  async sync(id: string, data: any, version: number, userId: string): Promise<boolean> {
    const existing = this.storage.get(id);
    
    if (!existing || version > existing.version) {
      this.storage.set(id, {
        id,
        data,
        version,
        timestamp: Date.now(),
        lastModifiedBy: userId
      });
      return true;
    }
    
    return false; // Данные устарели
  }
  
  get(id: string): VersionedData | undefined {
    return this.storage.get(id);
  }
}
```

### 2. Стратегия оптимистичной синхронизации

Обновление данных на клиенте без ожидания подтверждения от сервера:

```typescript
class OptimisticSync {
  private optimisticUpdates: Map<string, any> = new Map();
  
  async updateOptimistically<T>(
    id: string, 
    optimisticData: T, 
    actualUpdate: () => Promise<T>
  ): Promise<T> {
    // Оптимистичное обновление
    this.optimisticUpdates.set(id, optimisticData);
    
    try {
      // Выполнение реального обновления
      const actualData = await actualUpdate();
      this.optimisticUpdates.delete(id);
      return actualData;
    } catch (error) {
      // Откат при ошибке
      this.optimisticUpdates.delete(id);
      throw error;
    }
  }
  
  getOptimistic(id: string): any {
    return this.optimisticUpdates.get(id);
  }
}
```

### 3. Стратегия конфликтного разрешения

Разрешение конфликтов при одновременных изменениях:

```typescript
interface ConflictResolutionStrategy {
  resolve: (local: any, remote: any, base: any) => any;
}

class ConflictAwareSync {
  private conflictStrategy: ConflictResolutionStrategy;
  
  constructor(strategy: ConflictResolutionStrategy) {
    this.conflictStrategy = strategy;
  }
  
  async syncWithConflictResolution(
    id: string,
    localData: any,
    remoteData: any,
    baseData: any
  ) {
    if (this.hasConflict(localData, remoteData, baseData)) {
      return this.conflictStrategy.resolve(localData, remoteData, baseData);
    }
    
    // Нет конфликта, используем более новую версию
    return remoteData.timestamp > localData.timestamp ? remoteData : localData;
  }
  
  private hasConflict(local: any, remote: any, base: any): boolean {
    // Проверка на наличие конфликта
    return JSON.stringify(local) !== JSON.stringify(base) && 
           JSON.stringify(remote) !== JSON.stringify(base);
  }
}
```

## Синхронизация в контексте российских требований

### 1. Соответствие требованиям 152-ФЗ

При синхронизации персональных данных необходимо обеспечивать защиту информации:

```typescript
interface PersonalDataSyncConfig {
  encryption: boolean;
  consentRequired: boolean;
  retentionPeriod: number;
}

class PersonalDataSync {
  private config: PersonalDataSyncConfig;
  private encryptionService: EncryptionService;
  
  constructor(config: PersonalDataSyncConfig, encryptionService: EncryptionService) {
    this.config = config;
    this.encryptionService = encryptionService;
  }
  
  async syncPersonalData(data: PersonalData, target: string) {
    // Проверка согласия на обработку
    if (this.config.consentRequired && !this.hasConsent(data)) {
      throw new Error('Отсутствует согласие на обработку персональных данных');
    }
    
    // Шифрование данных при необходимости
    const syncData = this.config.encryption 
      ? await this.encryptionService.encrypt(data) 
      : data;
    
    // Синхронизация с учетом требований
    return await this.performSync(syncData, target);
  }
  
  private hasConsent(data: PersonalData): boolean {
    // Проверка наличия и актуальности согласия
    return data.consent && data.consent.givenAt > new Date(Date.now() - this.config.retentionPeriod);
  }
  
  private async performSync(data: any, target: string) {
    // Реализация синхронизации
    return fetch(`${target}/sync`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Consent-Token': this.getConsentToken(data)
      },
      body: JSON.stringify(data)
    });
  }
}
```

### 2. Работа с российскими регламентами

Учет требований к хранению и передаче данных:

```typescript
class RussianRegulationSync {
  private readonly RUSSIAN_SERVERS_ONLY = true;
  private readonly DATA_LOCALIZATION_REQUIRED = true;
  
  async syncData(data: any, destination: string) {
    // Проверка соответствия требованиям локализации
    if (this.DATA_LOCALIZATION_REQUIRED && !this.isRussianServer(destination)) {
      throw new Error('Передача данных за пределы России запрещена');
    }
    
    // Проверка шифрования
    if (this.requiresEncryption(data)) {
      data = await this.encryptData(data);
    }
    
    return await this.performSync(data, destination);
  }
  
  private isRussianServer(url: string): boolean {
    // Проверка, находится ли сервер в России
    const domain = new URL(url).hostname;
    return domain.endsWith('.ru') || this.isInRussianIPRange(url);
  }
  
  private requiresEncryption(data: any): boolean {
    // Проверка необходимости шифрования
    return this.containsPersonalData(data);
  }
  
  private containsPersonalData(data: any): boolean {
    // Проверка наличия персональных данных
    const personalDataFields = ['fio', 'passport', 'inn', 'birthDate', 'phone', 'email'];
    return personalDataFields.some(field => data.hasOwnProperty(field));
  }
}
```

## Практические реализации синхронизации

### 1. Синхронизация с помощью Redux и Redux Persist

```typescript
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage'; // defaults to localStorage

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['user', 'preferences'], // Синхронизировать только выбранные редьюсеры
  throttle: 1000, // Ограничение частоты синхронизации
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST'],
      },
    }),
});

export const persistor = persistStore(store);
```

### 2. Синхронизация с помощью Service Worker

```typescript
// service-worker.js
self.addEventListener('sync', (event) => {
  if (event.tag === 'offline-data-sync') {
    event.waitUntil(performSync());
  }
});

async function performSync() {
  const queue = await getOfflineQueue();
  
  for (const item of queue) {
    try {
      await fetch(`/api/sync`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(item),
      });
      
      await removeFromQueue(item.id);
    } catch (error) {
      console.error('Ошибка синхронизации:', error);
      // Оставить элемент в очереди для повторной попытки
    }
  }
}
```

### 3. Синхронизация с использованием IndexedDB

```typescript
class IndexedDBSync {
  private db: IDBDatabase | null = null;
  private dbName: string;
  private version: number;
  
  constructor(dbName: string, version: number = 1) {
    this.dbName = dbName;
    this.version = version;
  }
  
  async init() {
    return new Promise<void>((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Создание хранилищ
        if (!db.objectStoreNames.contains('users')) {
          const userStore = db.createObjectStore('users', { keyPath: 'id' });
          userStore.createIndex('email', 'email', { unique: true });
        }
        
        if (!db.objectStoreNames.contains('sync-queue')) {
          const queueStore = db.createObjectStore('sync-queue', { keyPath: 'id' });
          queueStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  async saveForSync(entity: string, operation: string, data: any) {
    if (!this.db) await this.init();
    
    const transaction = this.db!.transaction(['sync-queue'], 'readwrite');
    const store = transaction.objectStore('sync-queue');
    
    const syncItem = {
      id: generateId(),
      entity,
      operation,
      data,
      timestamp: Date.now()
    };
    
    return store.add(syncItem);
  }
  
  async getSyncQueue(): Promise<any[]> {
    if (!this.db) await this.init();
    
    const transaction = this.db!.transaction(['sync-queue'], 'readonly');
    const store = transaction.objectStore('sync-queue');
    const index = store.index('timestamp');
    
    return new Promise((resolve, reject) => {
      const request = index.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}
```

## Продвинутые стратегии синхронизации

### 1. Синхронизация с использованием CRDT

Использование CRDT (Conflict-free Replicated Data Types) для обеспечения согласованности:

```typescript
interface CRDT {
  value: any;
  timestamp: number;
  clientId: string;
  operations: any[];
}

class CRDTSync {
  private state: Map<string, CRDT> = new Map();
  
  applyOperation(operation: any) {
    // Применение операции к состоянию
    const currentState = this.state.get(operation.id);
    if (!currentState) {
      this.state.set(operation.id, this.createInitialState(operation));
      return;
    }
    
    // Объединение состояний
    this.state.set(operation.id, this.mergeStates(currentState, operation));
  }
  
  private mergeStates(state1: CRDT, state2: CRDT): CRDT {
    // Логика объединения состояний
    return {
      value: this.mergeValues(state1.value, state2.value),
      timestamp: Math.max(state1.timestamp, state2.timestamp),
      clientId: state1.timestamp > state2.timestamp ? state1.clientId : state2.clientId,
      operations: [...state1.operations, ...state2.operations]
    };
  }
  
  private mergeValues(value1: any, value2: any) {
    // Логика объединения значений
    if (typeof value1 === 'object' && typeof value2 === 'object') {
      return { ...value1, ...value2 };
    }
    return value1.timestamp > value2.timestamp ? value1 : value2;
  }
}
```

### 2. Синхронизация с приоритетами

Управление синхронизацией с учетом приоритетов:

```typescript
enum SyncPriority {
  CRITICAL = 10,
  HIGH = 7,
  MEDIUM = 5,
  LOW = 3,
  BACKGROUND = 1
}

interface PrioritySyncItem {
  id: string;
  data: any;
  priority: SyncPriority;
  entityType: string;
  timestamp: number;
}

class PrioritySyncQueue {
  private queue: PrioritySyncItem[] = [];
  
  enqueue(item: Omit<PrioritySyncItem, 'timestamp'>) {
    const queueItem: PrioritySyncItem = {
      ...item,
      timestamp: Date.now()
    };
    
    // Добавление в очередь с сортировкой по приоритету
    this.queue.push(queueItem);
    this.sortByPriority();
  }
  
  private sortByPriority() {
    this.queue.sort((a, b) => b.priority - a.priority);
  }
  
  async processNext() {
    if (this.queue.length === 0) return null;
    
    const item = this.queue.shift();
    if (item) {
      await this.performSync(item);
    }
    
    return item;
  }
  
  private async performSync(item: PrioritySyncItem) {
    // Выполнение синхронизации
    try {
      await fetch(`/api/${item.entityType}/${item.id}`, {
        method: 'PUT',
        body: JSON.stringify(item.data)
      });
    } catch (error) {
      // Возвращение элемента в очередь при ошибке
      this.queue.unshift(item);
      throw error;
    }
  }
}
```

## Заключение

Синхронизация данных в фронтенд-приложениях — это сложная, но критически важная задача, особенно в условиях российского законодательства и специфики инфраструктуры. Эффективная архитектура синхронизации должна учитывать требования безопасности, работоспособность в оффлайн-режиме и производительность. Выбор стратегии синхронизации зависит от конкретных требований приложения, типа данных и ожидаемого поведения при конфликтах.

См. также: [[Модели-данных]], [[Валидация]], [[Нормализация]], [[Кэширование]]