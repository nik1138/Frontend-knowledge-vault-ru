---
aliases: [Data Validation, Проверка данных, Input Validation]
tags: [frontend, architecture, validation, security]
---

# Валидация данных в фронтенд-архитектуре

## Общее понятие валидации

Валидация данных — это процесс проверки корректности и соответствия данных заданным правилам и ограничениям. В фронтенд-разработке валидация играет ключевую роль в обеспечении целостности данных, безопасности приложения и улучшении пользовательского опыта. В 2025 году в российских условиях особенно важно учитывать требования к защите персональных данных и безопасности веб-приложений.

## Типы валидации

### 1. Клиентская валидация

Клиентская валидация выполняется на стороне фронтенда и предоставляет мгновенную обратную связь пользователю:

```typescript
interface ValidationRule {
  validate: (value: any) => boolean;
  message: string;
}

const emailValidator: ValidationRule = {
  validate: (email: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
  message: 'Пожалуйста, введите корректный email адрес'
};

const passwordValidator: ValidationRule = {
  validate: (password: string) => password.length >= 8 && /[A-Z]/.test(password) && /[0-9]/.test(password),
  message: 'Пароль должен содержать не менее 8 символов, одну заглавную букву и одну цифру'
};
```

### 2. Серверная валидация

Серверная валидация обязательна для обеспечения безопасности, так как клиентскую валидацию можно обойти:

```typescript
// Пример серверной валидации с использованием Express.js
app.post('/api/users', async (req, res) => {
  const { email, password } = req.body;
  
  // Валидация на сервере
  if (!email || !emailValidator.validate(email)) {
    return res.status(400).json({ error: 'Некорректный email' });
  }
  
  if (!password || !passwordValidator.validate(password)) {
    return res.status(400).json({ error: 'Некорректный пароль' });
  }
  
  // Дальнейшая обработка
});
```

### 3. Схема-основанная валидация

Использование библиотек вроде Zod или Yup для определения схем данных:

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  email: z.string().email('Некорректный email адрес'),
  password: z.string()
    .min(8, 'Пароль должен содержать не менее 8 символов')
    .regex(/[A-Z]/, 'Пароль должен содержать хотя бы одну заглавную букву')
    .regex(/[0-9]/, 'Пароль должен содержать хотя бы одну цифру'),
  age: z.number().min(18, 'Вы должны быть старше 18 лет'),
  phone: z.string().regex(/^(\+7|8)[\d]{10}$/, 'Некорректный российский номер телефона'),
});

type User = z.infer<typeof UserSchema>;
```

## Практические стратегии валидации

### 1. Реализация валидации форм

Валидация форм должна быть интуитивно понятной для пользователя:

```typescript
interface FormValidationResult {
  isValid: boolean;
  errors: Record<string, string[]>;
}

class FormValidator {
  private rules: Record<string, ValidationRule[]>;
  
  constructor(rules: Record<string, ValidationRule[]>) {
    this.rules = rules;
  }
  
  validate(formData: Record<string, any>): FormValidationResult {
    const errors: Record<string, string[]> = {};
    let isValid = true;
    
    for (const field in this.rules) {
      const value = formData[field];
      const fieldErrors: string[] = [];
      
      for (const rule of this.rules[field]) {
        if (!rule.validate(value)) {
          fieldErrors.push(rule.message);
          isValid = false;
        }
      }
      
      if (fieldErrors.length > 0) {
        errors[field] = fieldErrors;
      }
    }
    
    return { isValid, errors };
  }
}
```

### 2. Валидация API-ответов

Проверка данных, полученных от сервера, критически важна:

```typescript
const ApiResponseSchema = z.object({
  status: z.literal('success'),
  data: z.object({
    users: z.array(UserSchema),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
    }),
  }),
  timestamp: z.string().datetime(),
});

type ApiResponse = z.infer<typeof ApiResponseSchema>;

function validateApiResponse(response: unknown): ApiResponse {
  return ApiResponseSchema.parse(response);
}
```

### 3. Кастомные валидаторы

Создание специфичных валидаторов для бизнес-логики:

```typescript
// Валидатор для российских ИНН
const innValidator: ValidationRule = {
  validate: (inn: string) => {
    if (!/^\d{10}$|^\d{12}$/.test(inn)) {
      return false;
    }
    
    // Логика проверки контрольных цифр
    if (inn.length === 10) {
      // Проверка для юридических лиц
      const checkSum = parseInt(inn[9]);
      const calculatedSum = calculateInnCheckSum(inn.substring(0, 9), [2, 4, 10, 3, 5, 9, 4, 6, 8]);
      return checkSum === calculatedSum;
    } else {
      // Проверка для физических лиц
      const checkSum11 = parseInt(inn[10]);
      const checkSum12 = parseInt(inn[11]);
      const calculatedSum11 = calculateInnCheckSum(inn.substring(0, 10), [7, 2, 4, 10, 3, 5, 9, 4, 6, 8]);
      const calculatedSum12 = calculateInnCheckSum(inn.substring(0, 11), [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8]);
      
      return checkSum11 === calculatedSum11 && checkSum12 === calculatedSum12;
    }
  },
  message: 'Некорректный ИНН'
};

function calculateInnCheckSum(inn: string, coefficients: number[]): number {
  let sum = 0;
  for (let i = 0; i < inn.length; i++) {
    sum += parseInt(inn[i]) * coefficients[i];
  }
  return sum % 11 % 10;
}
```

## Архитектурные паттерны валидации

### 1. Валидатор как сервис

Выделение валидации в отдельный сервис:

```typescript
interface ValidationService {
  validateUser(userData: any): ValidationResult;
  validateProduct(productData: any): ValidationResult;
  validateOrder(orderData: any): ValidationResult;
}

class DefaultValidationService implements ValidationService {
  validateUser(userData: any): ValidationResult {
    return UserSchema.safeParse(userData);
  }
  
  validateProduct(productData: any): ValidationResult {
    return ProductSchema.safeParse(productData);
  }
  
  validateOrder(orderData: any): ValidationResult {
    return OrderSchema.safeParse(orderData);
  }
}
```

### 2. Валидация на уровне домена

Интеграция валидации в доменные модели:

```typescript
class User {
  private _email: string;
  private _age: number;
  
  constructor(email: string, age: number) {
    this.setEmail(email);
    this.setAge(age);
  }
  
  setEmail(email: string): void {
    if (!emailValidator.validate(email)) {
      throw new Error('Некорректный email');
    }
    this._email = email;
  }
  
  setAge(age: number): void {
    if (age < 0 || age > 150) {
      throw new Error('Некорректный возраст');
    }
    this._age = age;
  }
  
  get email(): string {
    return this._email;
  }
  
  get age(): number {
    return this._age;
  }
}
```

## Валидация в контексте российских требований

### 1. Соответствие 152-ФЗ

При обработке персональных данных необходимо учитывать требования российского законодательства:

```typescript
interface PersonalDataValidation {
  validateFio(fio: string): boolean; // Проверка ФИО
  validatePassport(passport: PassportData): boolean; // Проверка паспортных данных
  validateConsent(consent: ConsentData): boolean; // Проверка согласия на обработку
}

const personalDataValidator: PersonalDataValidation = {
  validateFio(fio: string): boolean {
    // Проверка формата ФИО (кириллица, длина, структура)
    return /^[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+\s[А-ЯЁ][а-яё]+$/.test(fio.trim());
  },
  
  validatePassport(passport: PassportData): boolean {
    // Проверка формата паспорта
    return /^[0-9]{4}\s[0-9]{6}$/.test(passport.seriesNumber);
  },
  
  validateConsent(consent: ConsentData): boolean {
    // Проверка наличия согласия и его актуальности
    return consent.given && consent.expiresAt > new Date();
  }
};
```

### 2. Проверка российских телефонных номеров

```typescript
const russianPhoneValidator: ValidationRule = {
  validate: (phone: string) => {
    // Проверка форматов: +7 XXX XXX-XX-XX, 8 XXX XXX-XX-XX, 7 XXX XXX-XX-XX
    const normalized = phone.replace(/[^\d+]/g, '');
    return /^(\+7|8|7)9\d{9}$/.test(normalized);
  },
  message: 'Пожалуйста, введите корректный российский номер телефона'
};
```

### 3. Работа с банковскими данными

```typescript
// Валидация номера банковской карты
const cardNumberValidator: ValidationRule = {
  validate: (cardNumber: string) => {
    const cleaned = cardNumber.replace(/\s+/g, '');
    if (!/^\d{16}$/.test(cleaned)) {
      return false;
    }
    
    // Алгоритм Луна
    return validateLuhn(cleaned);
  },
  message: 'Некорректный номер банковской карты'
};

function validateLuhn(cardNumber: string): boolean {
  let sum = 0;
  let isEven = false;
  
  for (let i = cardNumber.length - 1; i >= 0; i--) {
    let digit = parseInt(cardNumber[i]);
    
    if (isEven) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }
    
    sum += digit;
    isEven = !isEven;
  }
  
  return sum % 10 === 0;
}
```

## Практические рекомендации

### 1. Оптимизация производительности

Для сложных валидаций рекомендуется использовать кэширование результатов:

```typescript
class CachedValidator {
  private cache: Map<string, boolean> = new Map();
  
  validate(data: any, schema: any): boolean {
    const key = JSON.stringify(data);
    
    if (this.cache.has(key)) {
      return this.cache.get(key)!;
    }
    
    const result = schema.safeParse(data);
    const isValid = result.success;
    
    this.cache.set(key, isValid);
    return isValid;
  }
}
```

### 2. Обработка ошибок валидации

Четкая обработка и отображение ошибок валидации:

```typescript
interface ValidationError {
  field: string;
  message: string;
  code: string;
}

class ValidationErrorHandler {
  static formatErrors(errors: z.ZodError): ValidationError[] {
    return errors.errors.map(error => ({
      field: error.path.join('.'),
      message: error.message,
      code: error.code
    }));
  }
  
  static displayErrors(errors: ValidationError[]): void {
    errors.forEach(error => {
      console.error(`Ошибка в поле "${error.field}": ${error.message}`);
    });
  }
}
```

### 3. Тестирование валидации

Необходимо тщательно тестировать все сценарии валидации:

```typescript
// Пример теста валидации
describe('User validation', () => {
  it('should validate correct user data', () => {
    const validUser = {
      email: 'test@example.com',
      password: 'Password123',
      age: 25,
      phone: '+79991234567'
    };
    
    const result = UserSchema.safeParse(validUser);
    expect(result.success).toBe(true);
  });
  
  it('should reject invalid email', () => {
    const invalidUser = {
      email: 'invalid-email',
      password: 'Password123',
      age: 25,
      phone: '+79991234567'
    };
    
    const result = UserSchema.safeParse(invalidUser);
    expect(result.success).toBe(false);
  });
});
```

## Заключение

Эффективная валидация данных в фронтенд-приложениях требует комплексного подхода, включающего как клиентскую, так и серверную валидацию. В условиях российского законодательства особенно важно учитывать требования безопасности и защиты персональных данных. Архитектура валидации должна быть гибкой, масштабируемой и легко поддерживаемой.

См. также: [[Модели-данных]], [[Нормализация]], [[Кэширование]], [[Синхронизация]]