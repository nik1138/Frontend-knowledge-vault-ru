---
aliases: [Локальное состояние, Управление локальным состоянием]
tags: [frontend, state-management, architecture, react, vue, angular]
---

# Локальное состояние

## Общее понятие

Локальное состояние (local state) - это данные, которые принадлежат и управляются конкретным компонентом или небольшой областью приложения. В отличие от глобального состояния, локальное состояние не влияет на другие части приложения и не требует сложных механизмов синхронизации.

## Особенности локального состояния

- **Изолированность**: Локальное состояние компонента не влияет на другие компоненты
- **Простота управления**: Не требует сложных библиотек или архитектурных решений
- **Производительность**: Изменения локального состояния не вызывают перерендеринга всего приложения
- **Легкость тестирования**: Компоненты с локальным состоянием проще тестировать

## Примеры локального состояния

### React
```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

### Vue.js
```vue
<template>
  <div>
    <p>Счетчик: {{ count }}</p>
    <button @click="increment">Увеличить</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  }
};
</script>
```

### Angular
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div>
      <p>Счетчик: {{ count }}</p>
      <button (click)="increment()">Увеличить</button>
    </div>
  `
})
export class CounterComponent {
  count = 0;

  increment() {
    this.count++;
  }
}
```

## Когда использовать локальное состояние

- Данные используются только в одном компоненте
- Состояние не влияет на другие части приложения
- Нет необходимости в сложной логике управления
- Данные не требуют сохранения между сессиями
- Информация временная и не критична для бизнес-логики

## Практические рекомендации

### Оптимизация локального состояния

1. **Используйте мемоизацию** для вычисляемых значений:
   ```jsx
   import React, { useMemo } from 'react';
   
   function ExpensiveComponent({ items }) {
     const expensiveValue = useMemo(() => {
       // дорогостоящие вычисления
       return items.filter(item => item.active).map(item => item.value);
     }, [items]);
     
     return <div>{expensiveValue.join(', ')}</div>;
   }
   ```

2. **Разделяйте сложное состояние** на несколько хуков:
   ```jsx
   function UserProfile() {
     const [user, setUser] = useState({ name: '', email: '' });
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState(null);
     
     // Вместо одного объекта состояния
   }
   ```

3. **Используйте useReducer для сложной логики**:
   ```jsx
   const initialState = { count: 0, step: 1 };
   
   function reducer(state, action) {
     switch (action.type) {
       case 'increment':
         return { ...state, count: state.count + state.step };
       case 'setStep':
         return { ...state, step: action.step };
       default:
         throw new Error();
     }
   }
   
   function Counter() {
     const [state, dispatch] = useReducer(reducer, initialState);
     
     return (
       <div>
         <p>Счетчик: {state.count}</p>
         <button onClick={() => dispatch({ type: 'increment' })}>
           Увеличить
         </button>
         <input
           type="number"
           value={state.step}
           onChange={(e) => dispatch({ type: 'setStep', step: Number(e.target.value) })}
         />
       </div>
     );
   }
   ```

## Российские реалии 2025

В 2025 году в российских компаниях наблюдается тенденция к использованию локального состояния в сочетании с глобальным для оптимизации производительности. Особенно актуально это для приложений, работающих в условиях ограниченной пропускной способности интернета в отдаленных регионах России.

Многие российские разработчики выбирают подход "сначала локальное состояние", а затем переходят к глобальному только при необходимости, что позволяет избежать преждевременной сложности архитектуры.

## Связанные темы

- [[Глобальное-состояние]]
- [[Паттерны-управления]]
- [[Оптимизация]]
- [[Тестирование]]