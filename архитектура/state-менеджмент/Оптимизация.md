---
aliases: [Оптимизация управления состоянием, Оптимизация state management, Performance optimization]
tags: [frontend, state-management, performance, optimization, react, vue, angular]
---

# Оптимизация управления состоянием

## Общее понятие

Оптимизация управления состоянием - это процесс улучшения производительности, уменьшения количества ненужных перерендеров и повышения отзывчивости приложения за счет эффективного управления данными и их изменениями.

## Проблемы производительности

### 1. Частые перерендеры
Часто происходят при неправильном управлении состоянием, что приводит к снижению производительности и "лагам" в интерфейсе.

### 2. Ненужные вычисления
Выполнение дорогостоящих операций при каждом изменении состояния, даже если результат не используется.

### 3. Избыточное состояние
Хранение лишних данных или дублирование информации в разных частях приложения.

### 4. Неправильная структура данных
Использование неэффективных структур данных для хранения и доступа к информации.

## Методы оптимизации

### 1. Использование мемоизации

#### React
```jsx
import React, { useMemo, useCallback } from 'react';

function ExpensiveComponent({ items, filter }) {
  // Мемоизация дорогостоящих вычислений
  const filteredItems = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);

  // Мемоизация функций для предотвращения перерендера дочерних компонентов
  const onItemClick = useCallback((id) => {
    console.log('Item clicked:', id);
  }, []);

  return (
    <div>
      {filteredItems.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onClick={onItemClick} 
        />
      ))}
    </div>
  );
}
```

#### Vue.js
```vue
<template>
  <div>
    <input v-model="searchTerm" placeholder="Поиск..." />
    <ul>
      <li v-for="item in filteredItems" :key="item.id">
        {{ item.name }}
      </li>
    </ul>
  </div>
</template>

<script>
import { computed, ref } from 'vue';

export default {
  setup() {
    const searchTerm = ref('');
    const items = ref([
      { id: 1, name: 'Яблоко', category: 'фрукты' },
      { id: 2, name: 'Апельсин', category: 'фрукты' },
      { id: 3, name: 'Молоко', category: 'молочные' }
    ]);

    // Мемоизированное вычисляемое свойство
    const filteredItems = computed(() => {
      if (!searchTerm.value) return items.value;
      return items.value.filter(item => 
        item.name.toLowerCase().includes(searchTerm.value.toLowerCase())
      );
    });

    return {
      searchTerm,
      filteredItems
    };
  }
};
</script>
```

### 2. Нормализация данных

Нормализация данных помогает избежать дублирования и упрощает обновление информации.

```javascript
// ПЛОХО: Денормализованные данные
const badState = {
  users: [
    { id: 1, name: 'Иван', posts: [
      { id: 1, title: 'Пост 1', author: { id: 1, name: 'Иван' } },
      { id: 2, title: 'Пост 2', author: { id: 1, name: 'Иван' } }
    ]}
  ]
};

// ХОРОШО: Нормализованные данные
const goodState = {
  users: {
    1: { id: 1, name: 'Иван', postIds: [1, 2] }
  },
  posts: {
    1: { id: 1, title: 'Пост 1', authorId: 1 },
    2: { id: 2, title: 'Пост 2', authorId: 1 }
  }
};
```

### 3. Использование селекторов

Селекторы позволяют извлекать только необходимые данные и избегать ненужных перерендеров.

```javascript
// Redux с Reselect
import { createSelector } from 'reselect';

const getUsers = state => state.users;
const getFilter = state => state.filter;

const getFilteredUsers = createSelector(
  [getUsers, getFilter],
  (users, filter) => users.filter(user => user.category === filter)
);

// Использование в компоненте
const filteredUsers = useSelector(getFilteredUsers);
```

### 4. Оптимизация рендера

#### React
```jsx
import React, { memo, PureComponent } from 'react';

// Оптимизация функциональных компонентов
const OptimizedComponent = memo(({ value, onChange }) => {
  return (
    <input 
      type="text" 
      value={value} 
      onChange={onChange} 
    />
  );
}, (prevProps, nextProps) => {
  // Пользовательская функция сравнения
  return prevProps.value === nextProps.value;
});

// Оптимизация классовых компонентов
class OptimizedClassComponent extends PureComponent {
  render() {
    return <div>{this.props.data}</div>;
  }
}
```

#### Vue.js
```vue
<template>
  <div>
    <UserCard 
      v-for="user in users" 
      :key="user.id" 
      :user="user"
      :is-active="activeUserId === user.id"
    />
  </div>
</template>

<script>
export default {
  // Использование оптимизаций Vue
  functional: true, // для компонентов без состояния
  props: ['users', 'activeUserId'],
  
  // Использование v-memo (Vue 3.2+)
  template: `
    <div>
      <template v-for="user in users" :key="user.id">
        <UserCard 
          :user="user"
          :is-active="activeUserId === user.id"
          v-memo="[user.id, activeUserId]"
        />
      </template>
    </div>
  `
};
</script>
```

### 5. Асинхронная загрузка данных

```jsx
import React, { Suspense } from 'react';
import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query';

// Оптимизация загрузки данных
function UserProfile({ userId }) {
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 минут
    cacheTime: 10 * 60 * 1000, // 10 минут
  });

  if (isLoading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error.message}</div>;

  return <div>{data.name}</div>;
}

// Использование suspense для компонентов
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<div>Загрузка профиля...</div>}>
        <UserProfile userId={1} />
      </Suspense>
    </QueryClientProvider>
  );
}
```

### 6. Использование виртуального скроллинга

```jsx
import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={35}
    >
      {Row}
    </List>
  );
}
```

## Инструменты оптимизации

### 1. Redux DevTools
Позволяет отслеживать изменения состояния и выявлять ненужные перерендеры.

### 2. React Profiler
Встроенный инструмент для анализа производительности компонентов.

```jsx
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log(`${id}'s ${phase} phase took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Component />
    </Profiler>
  );
}
```

### 3. Vue DevTools
Позволяет анализировать изменения состояния и производительность компонентов Vue.

### 4. Performance API
Использование встроенного API для измерения производительности:

```javascript
// Измерение времени выполнения операций
performance.mark('start-processing');
processData();
performance.mark('end-processing');
performance.measure('processing', 'start-processing', 'end-processing');

const measure = performance.getEntriesByName('processing')[0];
console.log('Время обработки:', measure.duration);
```

## Российские реалии 2025

В 2025 году российские разработчики активно используют TanStack Query (ранее React Query) и SWR для оптимизации работы с серверными данными. Это особенно актуально в условиях нестабильного интернет-соединения в некоторых регионах России.

Также наблюдается рост интереса к новым подходам в оптимизации, таким как Partial Hydration и Progressive Hydration в SSR-приложениях, что позволяет быстрее отображать интерактивные элементы на странице.

Компании уделяют особое внимание оптимизации производительности в условиях санкций, когда доступ к некоторым зарубежным CDN и сервисам ограничен, что требует более эффективного использования ресурсов и оптимизации локального кеширования.

## Практические рекомендации

1. **Измеряйте перед оптимизацией**: Используйте профилировщики для выявления реальных узких мест
2. **Не оптимизируйте преждевременно**: Сосредоточьтесь на критических путях выполнения
3. **Используйте кеширование**: Кешируйте результаты дорогостоящих вычислений
4. **Разделяйте состояние**: Разделяйте часто и редко изменяемые данные
5. **Мониторьте производительность**: Регулярно тестируйте производительность в продакшене

## Связанные темы

- [[Локальное-состояние]]
- [[Глобальное-состояние]]
- [[Паттерны-управления]]
- [[Тестирование]]
- [[React Query]]
- [[TanStack Query]]
- [[Performance]]