---
aliases: [Паттерны управления состоянием, Архитектурные паттерны, State management patterns]
tags: [frontend, state-management, architecture, patterns, react, vue, angular]
---

# Паттерны управления состоянием

## Обзор

Паттерны управления состоянием - это проверенные временем решения, которые помогают организовать хранение и изменение данных в приложении. Правильный выбор паттерна влияет на производительность, масштабируемость и поддерживаемость кода.

## Основные паттерны

### 1. Flux-паттерн

Flux - это архитектурный паттерн, предложенный Facebook, с одним направленным потоком данных.

**Принципы:**
- Данные движутся в одном направлении
- Центральный диспетчер (Dispatcher) управляет потоком данных
- Store содержит состояние и логику обновления
- View отображает данные и генерирует действия (Actions)

**Преимущества:**
- Предсказуемость изменений состояния
- Легкость отладки
- Четкое разделение ответственности

**Недостатки:**
- Сложность для простых приложений
- Много шаблонного кода

```javascript
// Пример Flux-архитектуры
class Dispatcher {
  constructor() {
    this.callbacks = [];
  }

  register(callback) {
    this.callbacks.push(callback);
  }

  dispatch(action) {
    this.callbacks.forEach(callback => callback(action));
  }
}

class Store {
  constructor(dispatcher) {
    this.state = { count: 0 };
    dispatcher.register(this.handleAction.bind(this));
  }

  handleAction(action) {
    switch (action.type) {
      case 'INCREMENT':
        this.state.count++;
        this.emitChange();
        break;
    }
  }

  emitChange() {
    // Уведомление подписчиков об изменении
  }
}
```

### 2. Redux-паттерн

Redux - это библиотека, реализующая Flux-паттерн с дополнительными возможностями.

**Принципы:**
- Единое дерево состояния
- Состояние доступно только для чтения
- Изменения происходят через чистые функции (reducers)

**Преимущества:**
- Предсказуемость
- Возможность отката изменений
- Богатая экосистема инструментов

**Недостатки:**
- Много шаблонного кода
- Сложность для новичков

```javascript
// Redux-паттерн с Redux Toolkit
import { createSlice, configureStore } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    incremented: state => {
      state.value += 1;
    },
    decremented: state => {
      state.value -= 1;
    },
  }
});

export const { incremented, decremented } = counterSlice.actions;
export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
  }
});
```

### 3. Reactive-паттерн (MobX)

Reactive-паттерн использует реактивное программирование для автоматического обновления данных.

**Принципы:**
- Иммутабельность не обязательна
- Автоматическое отслеживание зависимостей
- Простота в использовании

**Преимущества:**
- Меньше шаблонного кода
- Интуитивное понимание
- Высокая производительность

**Недостатки:**
- Сложность отладки
- Меньше предсказуемости

```javascript
import { makeAutoObservable, reaction } from 'mobx';

class TodoStore {
  todos = [];
  filter = 'all';

  constructor() {
    makeAutoObservable(this);
    
    // Реакция на изменение фильтра
    reaction(
      () => this.filter,
      (filter) => console.log(`Фильтр изменен на: ${filter}`)
    );
  }

  addTodo(title) {
    this.todos.push({
      id: Date.now(),
      title,
      completed: false
    });
  }

  toggleTodo(id) {
    const todo = this.todos.find(todo => todo.id === id);
    if (todo) todo.completed = !todo.completed;
  }
}
```

### 4. Context-паттерн (React)

Context позволяет передавать данные через дерево компонентов без явной передачи props.

**Преимущества:**
- Встроен в React
- Прост в использовании
- Хорош для средних приложений

**Недостатки:**
- Может вызвать ненужные перерендеры
- Не подходит для частых изменений

```jsx
import React, { createContext, useContext, useReducer } from 'react';

const AppContext = createContext();

const initialState = { user: null, theme: 'light' };

function appReducer(state, action) {
  switch (action.type) {
    case 'LOGIN':
      return { ...state, user: action.payload };
    case 'LOGOUT':
      return { ...state, user: null };
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };
    default:
      return state;
  }
}

export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
}
```

### 5. State Machine-паттерн

State Machine - это паттерн, который моделирует поведение системы как конечный автомат.

**Преимущества:**
- Ясное определение состояний
- Предсказуемые переходы
- Отлично подходит для сложной логики

**Недостатки:**
- Сложность для простых случаев
- Требует изучения дополнительных концепций

```javascript
import { createMachine, interpret } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

const toggleService = interpret(toggleMachine)
  .onTransition(state => console.log(state.value))
  .start();

toggleService.send('TOGGLE'); // 'active'
toggleService.send('TOGGLE'); // 'inactive'
```

## Выбор паттерна

### Для маленьких приложений
- Локальное состояние компонентов
- Context API (для общих данных)

### Для средних приложений
- Redux Toolkit или Zustand
- Context API для UI-состояния

### Для больших приложений
- Redux с Redux Toolkit
- MobX для сложных реактивных сценариев
- Смешанный подход с разными паттернами для разных частей приложения

## Российские реалии 2025

В 2025 году российское сообщество разработчиков активно переходит от традиционного Redux к более легковесным решениям, таким как Zustand и Jotai. Однако в корпоративных приложениях с высокими требованиями к безопасности и предсказуемости Redux остается предпочтительным выбором.

Наблюдается рост интереса к State Machine-паттерну, особенно в приложениях с сложной бизнес-логикой, где важна надежность и предсказуемость переходов между состояниями.

## Практические рекомендации

1. **Начинайте с простого**: Используйте локальное состояние и постепенно переходите к глобальному при необходимости
2. **Разделяйте типы состояния**: UI-состояние, данные приложения и сессионные данные могут использовать разные подходы
3. **Документируйте архитектуру**: Особенно важно для командной разработки
4. **Тестируйте логику состояния**: Используйте unit-тесты для проверки reducers и actions

## Связанные темы

- [[Локальное-состояние]]
- [[Глобальное-состояние]]
- [[Оптимизация]]
- [[Тестирование]]
- [[Архитектурные-паттерны]]
- [[Redux]]
- [[MobX]]