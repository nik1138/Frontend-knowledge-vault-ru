---
aliases: [Глобальное состояние, Управление глобальным состоянием, Shared state]
tags: [frontend, state-management, architecture, react, vue, angular, redux, mobx]
---

# Глобальное состояние

## Общее понятие

Глобальное состояние (global state) - это данные, которые доступны для всего приложения и могут быть изменены и считаны из любой части приложения. В отличие от локального состояния, глобальное состояние обеспечивает централизованный доступ к данным и позволяет избежать передачи props на несколько уровней вложенности.

## Особенности глобального состояния

- **Централизованный доступ**: Все компоненты могут получить доступ к одним и тем же данным
- **Единый источник истины**: Все изменения происходят через централизованный механизм
- **Сложность управления**: Требует более сложных архитектурных решений
- **Влияние на производительность**: Изменения могут вызвать перерендеринг нескольких компонентов
- **Тестирование**: Требует более сложных подходов к тестированию

## Популярные библиотеки для управления глобальным состоянием

### Redux
Redux остается одной из самых популярных библиотек для управления состоянием в React-приложениях. В 2025 году Redux Toolkit стал стандартом для настройки Redux.

```jsx
// store.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './userSlice';

export const store = configureStore({
  reducer: {
    user: userReducer,
  },
});

// userSlice.js
import { createSlice } from '@reduxjs/toolkit';

const userSlice = createSlice({
  name: 'user',
  initialState: {
    name: '',
    email: '',
    isAuthenticated: false,
  },
  reducers: {
    login: (state, action) => {
      state.name = action.payload.name;
      state.email = action.payload.email;
      state.isAuthenticated = true;
    },
    logout: (state) => {
      state.name = '';
      state.email = '';
      state.isAuthenticated = false;
    },
  },
});

export const { login, logout } = userSlice.actions;
export default userSlice.reducer;
```

### Zustand
Zustand - легковесная альтернатива Redux с минимальной настройкой:

```jsx
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

function Counter() {
  const { count, increment, decrement } = useStore();
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

### MobX
MobX предоставляет реактивное управление состоянием:

```javascript
import { makeAutoObservable } from 'mobx';
import { observer } from 'mobx-react-lite';

class UserStore {
  user = { name: '', email: '' };
  isAuthenticated = false;

  constructor() {
    makeAutoObservable(this);
  }

  login(userData) {
    this.user = userData;
    this.isAuthenticated = true;
  }

  logout() {
    this.user = { name: '', email: '' };
    this.isAuthenticated = false;
  }
}

const userStore = new UserStore();

const UserComponent = observer(() => {
  return (
    <div>
      {userStore.isAuthenticated ? (
        <p>Привет, {userStore.user.name}!</p>
      ) : (
        <p>Пожалуйста, войдите</p>
      )}
    </div>
  );
});
```

## Практические рекомендации

### Когда использовать глобальное состояние

- Данные используются в нескольких компонентах
- Необходимость синхронизации данных между разными частями приложения
- Хранение аутентификационных данных, настроек пользователя, корзины покупок
- Сложные бизнес-процессы, требующие согласованности данных
- Необходимость отката изменений (undo/redo)

### Архитектурные паттерны

1. **Flux-архитектура**: Один направленный поток данных
2. **Redux-архитектура**: Иммутабельное состояние и чистые функции
3. **Reactive-архитектура**: Автоматическое обновление при изменении зависимостей

### Оптимизация производительности

1. **Используйте селекторы** для избежания ненужных перерендеров:
   ```jsx
   import { useSelector } from 'react-redux';
   
   // Вместо этого:
   const user = useSelector(state => state.user);
   
   // Используйте мемоизированные селекторы:
   const userName = useSelector(state => state.user.name);
   ```

2. **Разделяйте состояние** на логические части:
   ```javascript
   // store.js
   export const store = configureStore({
     reducer: {
       user: userReducer,
       products: productsReducer,
       cart: cartReducer,
       ui: uiReducer,
     },
   });
   ```

3. **Используйте нормализацию данных** для избежания дублирования:
   ```javascript
   // Вместо вложенных объектов:
   {
     users: [
       { id: 1, name: 'Иван', orders: [{ id: 1, product: 'Книга' }] }
     ]
   }
   
   // Используйте нормализованную структуру:
   {
     users: { 1: { id: 1, name: 'Иван', orderIds: [1] } },
     orders: { 1: { id: 1, productId: 1, userId: 1 } },
     products: { 1: { id: 1, name: 'Книга' } }
   }
   ```

## Российские реалии 2025

В 2025 году российские компании все чаще выбирают Zustand и Jotai вместо традиционного Redux из-за их простоты и меньшего объема шаблонного кода. Однако в крупных корпоративных приложениях Redux остается популярным благодаря своей предсказуемости и богатой экосистеме инструментов отладки.

Важной тенденцией в российском сообществе является использование глобального состояния в сочетании с серверными данными через React Query (TanStack Query) или SWR, что позволяет эффективно кешировать данные и управлять синхронизацией с сервером.

## Связанные темы

- [[Локальное-состояние]]
- [[Паттерны-управления]]
- [[Оптимизация]]
- [[Тестирование]]
- [[React Query]]
- [[TanStack Query]]