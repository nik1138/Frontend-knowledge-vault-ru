---
aliases: [Тестирование управления состоянием, Тестирование state management, State testing]
tags: [frontend, state-management, testing, unit-test, integration-test, react, vue, angular]
---

# Тестирование управления состоянием

## Общее понятие

Тестирование управления состоянием - это процесс проверки корректности работы логики хранения, изменения и доступа к данным в приложении. Правильное тестирование обеспечивает надежность и предсказуемость работы приложения при изменении состояния.

## Типы тестов для управления состоянием

### 1. Модульные тесты (Unit Tests)

Тестируют отдельные части логики управления состоянием: reducers, actions, селекторы, store.

#### Тестирование Redux-редьюсеров
```javascript
// counterReducer.js
export function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { value: state.value + 1 };
    case 'DECREMENT':
      return { value: state.value - 1 };
    case 'SET_VALUE':
      return { value: action.payload };
    default:
      return state;
  }
}

// counterReducer.test.js
import { counterReducer } from './counterReducer';

describe('counterReducer', () => {
  it('должен возвращать начальное состояние', () => {
    expect(counterReducer(undefined, {})).toEqual({ value: 0 });
  });

  it('должен увеличивать значение при INCREMENT', () => {
    expect(counterReducer({ value: 1 }, { type: 'INCREMENT' })).toEqual({ value: 2 });
  });

  it('должен уменьшать значение при DECREMENT', () => {
    expect(counterReducer({ value: 1 }, { type: 'DECREMENT' })).toEqual({ value: 0 });
  });

  it('должен устанавливать значение при SET_VALUE', () => {
    expect(counterReducer({ value: 0 }, { type: 'SET_VALUE', payload: 42 })).toEqual({ value: 42 });
  });
});
```

#### Тестирование Redux-действий (Actions)
```javascript
// actions.js
export const increment = () => ({ type: 'INCREMENT' });
export const decrement = () => ({ type: 'DECREMENT' });
export const setValue = (value) => ({ type: 'SET_VALUE', payload: value });

// actions.test.js
import { increment, decrement, setValue } from './actions';

describe('actions', () => {
  it('должно создать действие INCREMENT', () => {
    expect(increment()).toEqual({ type: 'INCREMENT' });
  });

  it('должно создать действие DECREMENT', () => {
    expect(decrement()).toEqual({ type: 'DECREMENT' });
  });

  it('должно создать действие SET_VALUE с payload', () => {
    expect(setValue(42)).toEqual({ type: 'SET_VALUE', payload: 42 });
  });
});
```

#### Тестирование селекторов
```javascript
// selectors.js
export const selectCounterValue = state => state.counter.value;
export const selectDoubleCounterValue = state => state.counter.value * 2;

// selectors.test.js
import { selectCounterValue, selectDoubleCounterValue } from './selectors';

describe('selectors', () => {
  const state = { counter: { value: 5 } };

  it('selectCounterValue должен возвращать значение счетчика', () => {
    expect(selectCounterValue(state)).toBe(5);
  });

  it('selectDoubleCounterValue должен возвращать удвоенное значение', () => {
    expect(selectDoubleCounterValue(state)).toBe(10);
  });
});
```

### 2. Интеграционные тесты

Тестируют взаимодействие между различными частями системы управления состоянием.

#### Тестирование Redux store
```javascript
// store.test.js
import { createStore } from 'redux';
import { counterReducer } from './counterReducer';

describe('Redux store', () => {
  let store;

  beforeEach(() => {
    store = createStore(counterReducer, { value: 0 });
  });

  it('должно изменять состояние при dispatch действий', () => {
    store.dispatch({ type: 'INCREMENT' });
    expect(store.getState()).toEqual({ value: 1 });

    store.dispatch({ type: 'INCREMENT' });
    expect(store.getState()).toEqual({ value: 2 });

    store.dispatch({ type: 'SET_VALUE', payload: 10 });
    expect(store.getState()).toEqual({ value: 10 });
  });

  it('должно подписываться на изменения', () => {
    const listener = jest.fn();
    store.subscribe(listener);

    store.dispatch({ type: 'INCREMENT' });
    expect(listener).toHaveBeenCalledTimes(1);
  });
});
```

### 3. Тестирование компонентов со состоянием

#### Тестирование React-компонентов с Redux
```jsx
// UserProfile.jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';

export function UserProfile() {
  const user = useSelector(state => state.user);
  const loading = useSelector(state => state.loading);
  const dispatch = useDispatch();

  const handleLogin = () => {
    dispatch({ type: 'LOGIN_START' });
    // имитация асинхронного запроса
    setTimeout(() => {
      dispatch({ 
        type: 'LOGIN_SUCCESS', 
        payload: { id: 1, name: 'Иван', email: 'ivan@example.com' } 
      });
    }, 100);
  };

  if (loading) return <div>Загрузка...</div>;
  if (!user) return <button onClick={handleLogin}>Войти</button>;

  return (
    <div>
      <h2>Профиль: {user.name}</h2>
      <p>Email: {user.email}</p>
      <button onClick={() => dispatch({ type: 'LOGOUT' })}>Выйти</button>
    </div>
  );
}

// UserProfile.test.jsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { UserProfile } from './UserProfile';

// Создаем тестовый store
function renderWithRedux(component, { initialState } = {}) {
  const store = configureStore({
    reducer: {
      user: (state = null, action) => {
        switch (action.type) {
          case 'LOGIN_SUCCESS':
            return action.payload;
          case 'LOGOUT':
            return null;
          default:
            return state;
        }
      },
      loading: (state = false, action) => {
        switch (action.type) {
          case 'LOGIN_START':
            return true;
          case 'LOGIN_SUCCESS':
          case 'LOGIN_ERROR':
            return false;
          default:
            return state;
        }
      }
    },
    preloadedState: initialState
  });

  return {
    ...render(<Provider store={store}>{component}</Provider>),
    store
  };
}

describe('UserProfile', () => {
  it('отображает кнопку входа, когда пользователь не авторизован', () => {
    renderWithRedux(<UserProfile />);
    expect(screen.getByText('Войти')).toBeInTheDocument();
  });

  it('отображает профиль после успешного входа', async () => {
    renderWithRedux(<UserProfile />);
    
    fireEvent.click(screen.getByText('Войти'));
    
    await waitFor(() => {
      expect(screen.getByText('Профиль: Иван')).toBeInTheDocument();
      expect(screen.getByText('Email: ivan@example.com')).toBeInTheDocument();
    });
  });

  it('отображает состояние загрузки', () => {
    renderWithRedux(<UserProfile />, { 
      initialState: { user: null, loading: true } 
    });
    
    expect(screen.getByText('Загрузка...')).toBeInTheDocument();
  });
});
```

### 4. Тестирование с Zustand

```javascript
// userStore.js
import { create } from 'zustand';

export const useUserStore = create((set, get) => ({
  user: null,
  loading: false,
  
  login: async (credentials) => {
    set({ loading: true });
    try {
      // имитация API-запроса
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify(credentials)
      });
      const userData = await response.json();
      set({ user: userData, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },
  
  logout: () => set({ user: null }),
  
  updateUser: (newData) => set((state) => ({
    user: { ...state.user, ...newData }
  }))
}));

// userStore.test.js
import { useUserStore } from './userStore';

// Утилита для сброса store между тестами
const resetStore = () => {
  useUserStore.setState({
    user: null,
    loading: false
  });
};

describe('userStore', () => {
  beforeEach(() => {
    resetStore();
  });

  it('должен устанавливать пользователя при входе', async () => {
    const credentials = { email: 'test@example.com', password: 'password' };
    
    // Мокаем fetch
    global.fetch = jest.fn().mockResolvedValue({
      json: jest.fn().mockResolvedValue({
        id: 1,
        name: 'Тестовый пользователь',
        email: 'test@example.com'
      })
    });

    await useUserStore.getState().login(credentials);
    
    expect(useUserStore.getState().user).toEqual({
      id: 1,
      name: 'Тестовый пользователь',
      email: 'test@example.com'
    });
    
    expect(useUserStore.getState().loading).toBe(false);
  });

  it('должен очищать пользователя при выходе', () => {
    useUserStore.setState({ user: { id: 1, name: 'Иван' } });
    
    useUserStore.getState().logout();
    
    expect(useUserStore.getState().user).toBeNull();
  });

  it('должен обновлять данные пользователя', () => {
    useUserStore.setState({ user: { id: 1, name: 'Иван', email: 'ivan@example.com' } });
    
    useUserStore.getState().updateUser({ name: 'Петр' });
    
    expect(useUserStore.getState().user).toEqual({
      id: 1,
      name: 'Петр',
      email: 'ivan@example.com'
    });
  });
});
```

### 5. Тестирование с MobX

```javascript
// userStore.test.js
import { UserStore } from './userStore';

describe('UserStore', () => {
  let store;

  beforeEach(() => {
    store = new UserStore();
  });

  it('должен изменять аутентификационное состояние при входе', () => {
    store.login({ name: 'Иван', email: 'ivan@example.com' });
    
    expect(store.user.name).toBe('Иван');
    expect(store.user.email).toBe('ivan@example.com');
    expect(store.isAuthenticated).toBe(true);
  });

  it('должен очищать данные при выходе', () => {
    store.login({ name: 'Иван', email: 'ivan@example.com' });
    store.logout();
    
    expect(store.user.name).toBe('');
    expect(store.user.email).toBe('');
    expect(store.isAuthenticated).toBe(false);
  });

  it('должен корректно обновлять данные пользователя', () => {
    store.login({ name: 'Иван', email: 'ivan@example.com' });
    store.updateProfile({ name: 'Петр' });
    
    expect(store.user.name).toBe('Петр');
    expect(store.user.email).toBe('ivan@example.com');
  });
});
```

## Инструменты тестирования

### 1. Jest
Основной фреймворк для модульного тестирования JavaScript/TypeScript кода.

### 2. React Testing Library
Предпочтительный способ тестирования React-компонентов, фокусируется на пользовательском взаимодействии.

### 3. Cypress
Инструмент для интеграционного и end-to-end тестирования, особенно полезен для тестирования состояния приложения в реальных условиях.

### 4. Testing Library
Семейство библиотек для тестирования компонентов в различных фреймворках (React, Vue, Angular).

## Российские реалии 2025

В 2025 году российские компании уделяют особое внимание автоматизированному тестированию как способу обеспечения качества приложений в условиях санкций и ограниченного доступа к некоторым зарубежным сервисам поддержки и мониторинга.

Наблюдается рост интереса к property-based testing и model-based testing для более надежного тестирования сложной логики управления состоянием. Компании активно внедряют тестирование в CI/CD процессы и используют локальные инфраструктуры для тестирования.

Также важной тенденцией является тестирование в условиях ограниченного интернет-соединения, что особенно актуально для российских регионов с нестабильным доступом в интернет.

## Практические рекомендации

1. **Тестируйте бизнес-логику**: Сосредоточьтесь на тестировании важной для бизнеса логики изменения состояния
2. **Изолируйте тесты**: Убедитесь, что каждый тест независим и не зависит от состояния других тестов
3. **Используйте фикстуры**: Создавайте предсказуемые начальные состояния для тестов
4. **Тестируйте крайние случаи**: Проверяйте поведение при ошибках, пустых данных, конфликтах
5. **Мониторьте покрытие**: Следите за покрытием кода тестами, особенно критических путей
6. **Автоматизируйте**: Интегрируйте тесты в процесс разработки для быстрого получения обратной связи

## Связанные темы

- [[Локальное-состояние]]
- [[Глобальное-состояние]]
- [[Паттерны-управления]]
- [[Оптимизация]]
- [[Тестирование компонентов]]
- [[CI/CD]]
- [[Jest]]