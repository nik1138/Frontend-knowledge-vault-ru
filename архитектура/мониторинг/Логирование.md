---
aliases: ["Фронтенд логирование", "Системы логирования", "Логи фронтенд-приложений"]
tags: [logging, frontend, monitoring, observability, error-handling]
---

# Логирование фронтенд-приложений

## Общее понимание

Логирование в фронтенд-приложениях представляет собой процесс фиксации событий, ошибок, предупреждений и других значимых происшествий, происходящих в браузере пользователя. В условиях российских реалий 2025 года, логирование становится особенно важным для обеспечения стабильности приложений и анализа пользовательского опыта в условиях возможных ограничений и санкций.

## Типы логов

### 1. Ошибки приложения

#### Runtime Errors
- Синтаксические ошибки JavaScript
- Ошибки выполнения
- Ошибки типизации
- Ошибки при работе с DOM

#### Network Errors
- Ошибки HTTP-запросов
- Ошибки CORS
- Ошибки подключения к WebSocket
- Ошибки загрузки ресурсов

#### Логика приложения
- Ошибки бизнес-логики
- Ошибки валидации данных
- Ошибки авторизации/аутентификации

### 2. Информационные логи

- События пользовательских взаимодействий
- Состояния приложения
- События загрузки модулей
- События кеширования

### 3. Предупреждения

- Устаревшие API
- Потенциальные утечки памяти
- Неоптимальные операции
- Предупреждения о производительности

## Архитектура логирования

### 1. Уровни логирования

Согласно стандарту RFC 5424, выделяются следующие уровни:
- **Emergency** - система не функционирует
- **Alert** - требуется немедленное вмешательство
- **Critical** - критические ошибки
- **Error** - ошибки приложения
- **Warning** - предупреждения
- **Notice** - нормальные, но значимые события
- **Info** - информационные сообщения
- **Debug** - отладочная информация

### 2. Структура лог-записи

Каждая лог-запись должна содержать:
- Уровень важности
- Временную метку
- Идентификатор сессии пользователя
- Тип события
- Сообщение об ошибке
- Стек вызовов
- Данные о пользовательском устройстве
- Данные о браузере
- URL страницы
- Дополнительный контекст

## Реализация логирования

### 1. Встроенные методы браузера

#### console.* методы
```javascript
console.log('Информационное сообщение');
console.warn('Предупреждение');
console.error('Ошибка');
console.debug('Отладочное сообщение');
console.info('Информационное сообщение');
```

#### Error boundaries (для React)
```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Логирование ошибки
    logError(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```

### 2. Кастомная система логирования

```javascript
class FrontendLogger {
  constructor(options = {}) {
    this.level = options.level || 'info';
    this.transports = options.transports || [new ConsoleTransport()];
    this.sessionId = this.generateSessionId();
    this.userId = options.userId || null;
  }

  generateSessionId() {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }

  log(level, message, meta = {}) {
    if (this.getLogLevelIndex(level) < this.getLogLevelIndex(this.level)) {
      return;
    }

    const logEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      sessionId: this.sessionId,
      userId: this.userId,
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...meta
    };

    this.transports.forEach(transport => {
      transport.write(logEntry);
    });
  }

  getLogLevelIndex(level) {
    const levels = ['debug', 'info', 'warn', 'error', 'fatal'];
    return levels.indexOf(level.toLowerCase()) || 0;
  }

  debug(message, meta) { this.log('debug', message, meta); }
  info(message, meta) { this.log('info', message, meta); }
  warn(message, meta) { this.log('warn', message, meta); }
  error(message, meta) { this.log('error', message, meta); }
  fatal(message, meta) { this.log('fatal', message, meta); }
}
```

### 3. Транспорты логирования

#### Console Transport
```javascript
class ConsoleTransport {
  write(logEntry) {
    const { level, message, timestamp, ...meta } = logEntry;
    const formattedMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    
    switch(level) {
      case 'error':
      case 'fatal':
        console.error(formattedMessage, meta);
        break;
      case 'warn':
        console.warn(formattedMessage, meta);
        break;
      case 'info':
        console.info(formattedMessage, meta);
        break;
      case 'debug':
        console.debug(formattedMessage, meta);
        break;
      default:
        console.log(formattedMessage, meta);
    }
  }
}
```

#### HTTP Transport
```javascript
class HTTPTransport {
  constructor(url, options = {}) {
    this.url = url;
    this.batchSize = options.batchSize || 10;
    this.batch = [];
    this.flushInterval = options.flushInterval || 5000;
    
    // Устанавливаем интервал для отправки батчей
    setInterval(() => this.flush(), this.flushInterval);
  }

  write(logEntry) {
    this.batch.push(logEntry);
    
    if (this.batch.length >= this.batchSize) {
      this.flush();
    }
  }

  flush() {
    if (this.batch.length === 0) return;

    const batchToSend = [...this.batch];
    this.batch = [];

    // Используем sendBeacon для надежной отправки
    if (navigator.sendBeacon) {
      navigator.sendBeacon(
        this.url,
        JSON.stringify(batchToSend)
      );
    } else {
      // Резервный метод отправки
      fetch(this.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(batchToSend),
        keepalive: true
      }).catch(err => console.error('Failed to send logs:', err));
    }
  }
}
```

## Обработка ошибок

### 1. Global Error Handler
```javascript
window.addEventListener('error', (event) => {
  logger.error('Global error occurred', {
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    error: event.error
  });
});

window.addEventListener('unhandledrejection', (event) => {
  logger.error('Unhandled promise rejection', {
    reason: event.reason,
    promise: event.promise
  });
});
```

### 2. Resource Error Handler
```javascript
// Логирование ошибок загрузки ресурсов
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    logger.warn('Resource loading error', {
      src: event.target.src,
      type: event.type,
      tagName: event.target.tagName
    });
  }
}, true);
```

## Российские особенности 2025 года

### 1. Отказ от зарубежных решений

В связи с санкционными ограничениями, в 2025 году происходит переход от зарубежных решений логирования к:
- Российским системам мониторинга
- Локальным решениям на базе ClickHouse, Elasticsearch
- Внутренним разработкам компаний

### 2. Безопасность и конфиденциальность

- Обезличивание данных пользователей в логах
- Соответствие требованиям 152-ФЗ "О персональных данных"
- Локальное хранение логов без передачи за границу
- Шифрование чувствительной информации

### 3. Инфраструктурные ограничения

- Учет особенностей работы в сетях российских провайдеров
- Адаптация к возможным ограничениям на доступ к зарубежным сервисам
- Резервные механизмы отправки логов

## Практические рекомендации

### 1. Стратегии сэмплирования логов

```javascript
class LogSampler {
  constructor(samplingRates = {}) {
    this.samplingRates = {
      debug: 0.1,    // 10% отладочных сообщений
      info: 0.3,     // 30% информационных сообщений
      warn: 0.7,     // 70% предупреждений
      error: 1.0,    // 100% ошибок
      fatal: 1.0,    // 100% критических ошибок
      ...samplingRates
    };
  }

  shouldLog(level) {
    const rate = this.samplingRates[level.toLowerCase()] || 0;
    return Math.random() < rate;
  }
}
```

### 2. Агрегация логов

```javascript
class LogAggregator {
  constructor(windowMs = 60000) { // 1 минута
    this.windowMs = windowMs;
    this.aggregatedLogs = new Map();
  }

  add(logEntry) {
    const key = this.generateKey(logEntry);
    const now = Date.now();
    
    if (!this.aggregatedLogs.has(key)) {
      this.aggregatedLogs.set(key, {
        firstOccurrence: now,
        count: 0,
        entries: []
      });
    }
    
    const aggregated = this.aggregatedLogs.get(key);
    aggregated.count++;
    aggregated.entries.push(logEntry);
    
    // Отправляем агрегированные логи по истечении окна
    if (now - aggregated.firstOccurrence >= this.windowMs) {
      this.sendAggregated(key, aggregated);
      this.aggregatedLogs.delete(key);
    }
  }
  
  generateKey(logEntry) {
    return `${logEntry.level}-${logEntry.message.substring(0, 50)}`;
  }
  
  sendAggregated(key, aggregated) {
    const summary = {
      message: `Aggregated ${aggregated.count} logs`,
      count: aggregated.count,
      firstOccurrence: aggregated.firstOccurrence,
      lastOccurrence: Date.now(),
      sampleEntries: aggregated.entries.slice(0, 3) // Первые 3 записи
    };
    
    // Отправляем агрегированный лог
    logger.info('Log aggregation summary', summary);
  }
}
```

### 3. Фильтрация чувствительных данных

```javascript
class LogSanitizer {
  constructor() {
    this.sensitivePatterns = [
      /password/gi,
      /token/gi,
      /secret/gi,
      /key/gi,
      /authorization/gi,
      /[A-Z0-9]{8,}/gi // потенциальные токены
    ];
  }

  sanitize(obj) {
    if (typeof obj !== 'object' || obj === null) {
      return this.sanitizeValue(obj);
    }

    const sanitized = Array.isArray(obj) ? [] : {};
    
    for (const [key, value] of Object.entries(obj)) {
      const sanitizedKey = this.sanitizeValue(key);
      sanitized[sanitizedKey] = this.sanitize(value);
    }
    
    return sanitized;
  }

  sanitizeValue(value) {
    if (typeof value === 'string') {
      let sanitized = value;
      for (const pattern of this.sensitivePatterns) {
        sanitized = sanitized.replace(pattern, '[REDACTED]');
      }
      return sanitized;
    }
    return value;
  }
}
```

## Интеграция с системами мониторинга

### 1. ELK Stack (Elasticsearch, Logstash, Kibana)

Для российских компаний часто используются локальные установки ELK или их отечественные аналоги:
- Elasticsearch для хранения логов
- Logstash для обработки и фильтрации
- Kibana для визуализации

### 2. ClickHouse

Российская колоночная СУБД, активно используемая для хранения и анализа логов:
```javascript
// Пример отправки логов в ClickHouse
class ClickHouseTransport {
  constructor(host, database = 'logs', table = 'frontend_logs') {
    this.url = `${host}/?query=INSERT%20INTO%20${database}.${table}%20FORMAT%20JSONEachRow`;
  }

  write(logEntry) {
    fetch(this.url, {
      method: 'POST',
      body: JSON.stringify(logEntry),
      headers: { 'Content-Type': 'application/x-ndjson' }
    }).catch(err => console.error('Failed to send to ClickHouse:', err));
  }
}
```

## Заключение

Эффективное логирование фронтенд-приложений в 2025 году требует учета как международных практик, так и российской специфики. Важно строить гибкую систему логирования, обеспечивающую надежную фиксацию событий при соблюдении требований безопасности и конфиденциальности данных.

> [!tip] Совет
> Регулярно пересматривайте стратегию логирования, удаляя избыточные логи и добавляя новые важные события для более точного мониторинга состояния приложения.

> [!warning] Важно
> При логировании строго соблюдайте требования законодательства о защите персональных данных и не передавайте чувствительную информацию за границу.