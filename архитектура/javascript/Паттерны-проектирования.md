---
aliases: [JS Design Patterns, Паттерны проектирования JavaScript]
tags: [javascript, architecture, design-patterns, programming]
---

# Паттерны проектирования в JavaScript

## Введение

Паттерны проектирования - это проверенные временем решения типичных проблем в программировании. В JavaScript, как и в других языках, паттерны помогают разработчикам создавать более гибкий, масштабируемый и поддерживаемый код. В условиях российского рынка 2025 года, знание паттернов проектирования становится особенно важным для создания конкурентоспособных решений.

## Основные категории паттернов

### Порождающие паттерны

Эти паттерны отвечают за создание объектов, скрывая логику создания и позволяя более гибко управлять процессом инстанцирования.

#### Фабричный метод (Factory Method)

```javascript
class DeveloperFactory {
  createDeveloper(type) {
    switch(type) {
      case 'frontend':
        return new FrontendDeveloper();
      case 'backend':
        return new BackendDeveloper();
      case 'fullstack':
        return new FullstackDeveloper();
      default:
        throw new Error('Неподдерживаемый тип разработчика');
    }
  }
}

class FrontendDeveloper {
  writeCode() {
    console.log('Пишет JavaScript/TypeScript код для фронтенда');
  }
}
```

#### Абстрактная фабрика (Abstract Factory)

Позволяет создавать семейства связанных объектов без указания конкретных классов.

#### Синглтон (Singleton)

Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к нему.

```javascript
class DatabaseConnection {
  constructor() {
    if (DatabaseConnection.instance) {
      return DatabaseConnection.instance;
    }
    
    this.connection = this.createConnection();
    DatabaseConnection.instance = this;
    return this;
  }

  createConnection() {
    // Логика создания подключения к базе данных
    console.log('Создание подключения к базе данных');
    return { connected: true };
  }
}

const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();
console.log(db1 === db2); // true
```

### Структурные паттерны

Эти паттерны облегчают проектирование за счет идентификации простого способа реализации отношений между сущностями.

#### Адаптер (Adapter)

Позволяет объектам с несовместимыми интерфейсами работать вместе.

```javascript
class OldPaymentSystem {
  makePayment(amount) {
    console.log(`Старая система: оплата ${amount} рублей`);
  }
}

class NewPaymentSystem {
  pay({ amount, currency }) {
    console.log(`Новая система: оплата ${amount} ${currency}`);
  }
}

class PaymentAdapter {
  constructor(paymentSystem) {
    this.paymentSystem = paymentSystem;
  }

  makePayment(amount) {
    if (this.paymentSystem instanceof NewPaymentSystem) {
      this.paymentSystem.pay({ amount, currency: 'RUB' });
    } else {
      this.paymentSystem.makePayment(amount);
    }
  }
}
```

#### Декоратор (Decorator)

Позволяет динамически добавлять новую функциональность объектам, оборачивая их в полезные "обертки".

```javascript
function withLogging(fn) {
  return function(...args) {
    console.log(`Вызов функции: ${fn.name} с аргументами:`, args);
    const result = fn.apply(this, args);
    console.log(`Результат:`, result);
    return result;
  };
}

const calculateTax = (amount) => amount * 0.13; // НДФЛ в России
const loggedCalculateTax = withLogging(calculateTax);

loggedCalculateTax(100000); // Для российского рынка
```

#### Фасад (Facade)

Предоставляет упрощенный интерфейс к сложной системе классов, библиотеке или фреймворку.

```javascript
class TaxCalculator {
  calculateNDFL(amount) { return amount * 0.13; }
  calculatePensionContribution(amount) { return amount * 0.22; }
}

class PaymentProcessor {
  process(amount) {
    const taxCalculator = new TaxCalculator();
    const ndfl = taxCalculator.calculateNDFL(amount);
    const pension = taxCalculator.calculatePensionContribution(amount);
    
    return {
      amount,
      ndfl,
      pension,
      total: amount - ndfl - pension
    };
  }
}

// Фасад для упрощения работы с платежами
class PaymentFacade {
  static processPayment(amount) {
    const processor = new PaymentProcessor();
    return processor.process(amount);
  }
}

const payment = PaymentFacade.processPayment(100000);
console.log(payment);
```

### Поведенческие паттерны

Эти паттерны отвечают за эффективное взаимодействие между объектами, определяя способы передачи информации и управления состоянием.

#### Наблюдатель (Observer)

Определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются автоматически.

```javascript
class EventSystem {
  constructor() {
    this.events = {};
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  unsubscribe(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }
}

const eventSystem = new EventSystem();

eventSystem.subscribe('userLogin', (user) => {
  console.log(`Пользователь ${user.name} вошел в систему`);
});

eventSystem.subscribe('userLogin', (user) => {
  // Отправка уведомления в чат поддержки
  console.log(`Уведомление отправлено в чат поддержки`);
});

eventSystem.emit('userLogin', { name: 'Иван Петров', id: 123 });
```

#### Команда (Command)

Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать и откатывать операции.

```javascript
class BankAccount {
  constructor(balance = 0) {
    this.balance = balance;
  }

  deposit(amount) {
    this.balance += amount;
    console.log(`Депозит: +${amount}, Баланс: ${this.balance}`);
  }

  withdraw(amount) {
    if (this.balance >= amount) {
      this.balance -= amount;
      console.log(`Снятие: -${amount}, Баланс: ${this.balance}`);
    } else {
      console.log('Недостаточно средств');
    }
  }
}

class Command {
  constructor(account, action, amount) {
    this.account = account;
    this.action = action;
    this.amount = amount;
  }

  execute() {
    this.account[this.action](this.amount);
  }

  undo() {
    const oppositeAction = this.action === 'deposit' ? 'withdraw' : 'deposit';
    this.account[oppositeAction](this.amount);
  }
}

const account = new BankAccount(1000);
const depositCommand = new Command(account, 'deposit', 500);
const withdrawCommand = new Command(account, 'withdraw', 200);

depositCommand.execute(); // Депозит: +500, Баланс: 1500
withdrawCommand.execute(); // Снятие: -200, Баланс: 1300

// Откат последней операции
withdrawCommand.undo(); // Снятие: +200, Баланс: 1500
```

## Современные паттерны в JavaScript

### Модульный паттерн (Module Pattern)

Позволяет инкапсулировать код и избегать загрязнения глобального пространства имен.

```javascript
const CalculatorModule = (function() {
  // Приватные переменные и функции
  const taxRate = 0.13; // НДФЛ в России

  function calculateTax(amount) {
    return amount * taxRate;
  }

  // Публичный API
  return {
    addTax: function(amount) {
      return amount + calculateTax(amount);
    },
    
    calculateNet: function(grossAmount) {
      return grossAmount / (1 + taxRate);
    }
  };
})();

console.log(CalculatorModule.addTax(100000)); // 113000
```

### Итератор (Iterator)

Предоставляет способ последовательного доступа ко всем элементам сложного объекта, не раскрывая его внутреннего представления.

```javascript
class RussianCities {
  constructor() {
    this.cities = ['Москва', 'Санкт-Петербург', 'Новосибирск', 'Екатеринбург'];
  }

  *[Symbol.iterator]() {
    for (let city of this.cities) {
      yield city;
    }
  }
}

const cities = new RussianCities();
for (let city of cities) {
  console.log(city);
}
```

## Применение паттернов в российском контексте

В 2025 году российские разработчики сталкиваются с рядом специфических требований:

- **Соответствие законодательству**: Паттерны должны учитывать требования российского законодательства, такие как хранение персональных данных на серверах, расположенных в России
- **Интернационализация**: Поддержка русского языка и других языков народов России
- **Локализация**: Учет российских стандартов (например, формат даты, валюты, систем налогообложения)

```javascript
class LocalizationManager {
  constructor() {
    this.currentLocale = 'ru-RU';
  }

  formatDate(date) {
    return new Intl.DateTimeFormat(this.currentLocale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }).format(date);
  }

  formatCurrency(amount) {
    return new Intl.NumberFormat(this.currentLocale, {
      style: 'currency',
      currency: 'RUB'
    }).format(amount);
  }
}

const localization = new LocalizationManager();
console.log(localization.formatDate(new Date())); // Формат даты по-русски
console.log(localization.formatCurrency(100000)); // 100 000,00 ₽
```

## Заключение

Паттерны проектирования в JavaScript помогают создавать более структурированный, понятный и поддерживаемый код. В условиях российского рынка 2025 года, знание и применение этих паттернов позволяет разработчикам создавать решения, которые соответствуют местным требованиям и стандартам.

> [!tip] Совет
> При выборе паттерна всегда учитывайте конкретные требования проекта, а не используйте паттерны ради использования. Паттерн должен решать реальную проблему, а не усложнять код.

См. также: [[Архитектура-приложений]], [[Компонентная-архитектура]], [[Модульность]]