# Хуки

Хуки - это функции, которые позволяют использовать состояние и другие возможности React без написания классов. Они были представлены в React 16.8 и стали фундаментальной частью современной разработки компонентов.

## Встроенные хуки React

### useState
Позволяет добавить состояние в функциональный компонент:

```javascript
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}
```

### useEffect
Позволяет выполнять побочные эффекты в функциональном компоненте:

```javascript
import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]); // Зависимость от userId

  return user ? <div>{user.name}</div> : <div>Загрузка...</div>;
}
```

### useContext
Позволяет подписываться на контекст React:

```javascript
import React, { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      Я стилизован с помощью контекста!
    </button>
  );
}
```

### useReducer
Альтернатива useState для сложной логики состояния:

```javascript
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      Счетчик: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Сброс</button>
    </div>
  );
}
```

### useCallback
Возвращает мемоизированную версию обратного вызова:

```javascript
import React, { useState, useCallback } from 'react';

const Button = React.memo(({ onClick, children }) => {
  console.log('Кнопка перерендерилась');
  return <button onClick={onClick}>{children}</button>;
});

function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []); // Пустой массив зависимостей

  return (
    <div>
      <Button onClick={handleClick}>Нажми меня</Button>
      <p>Счетчик: {count}</p>
    </div>
  );
}
```

### useMemo
Возвращает мемоизированное значение:

```javascript
import React, { useState, useMemo } from 'react';

function ExpensiveComponent({ items, filter }) {
  const filteredItems = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);

  return (
    <div>
      {filteredItems.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

### useRef
Позволяет хранить изменяемое значение, которое не вызывает перерендер:

```javascript
import React, { useRef, useEffect } from 'react';

function FocusInput() {
  const inputRef = useRef();

  useEffect(() => {
    inputRef.current.focus();
  }, []);

  return <input ref={inputRef} type="text" />;
}
```

## Пользовательские хуки

Пользовательские хуки позволяют извлекать логику компонента в повторно используемые функции:

```javascript
import { useState, useEffect } from 'react';

// Пользовательский хук для отслеживания размера окна
function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: undefined,
    height: undefined,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    handleResize(); // Устанавливаем начальное значение

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// Использование пользовательского хука
function MyComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      Размер окна: {width} x {height}
    </div>
  );
}
```

## Правила использования хуков

1. **Вызывайте хуки только на верхнем уровне**: не вызывайте хуки внутри циклов, условий или вложенных функций.
2. **Вызывайте хуки только из React-функций**: не вызывайте хуки из обычных функций JavaScript.

## Пользовательские хуки для компонентной архитектуры

### useApi
Хук для управления API-запросами:

```javascript
import { useState, useEffect } from 'react';

function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}
```

### useLocalStorage
Хук для работы с localStorage:

```javascript
import { useState } from 'react';

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}
```

## Лучшие практики

1. **Именование**: пользовательские хуки должны начинаться с `use`
2. **Изолированность**: каждый хук должен решать одну конкретную задачу
3. **Повторное использование**: выносите общую логику в пользовательские хуки
4. **Оптимизация**: используйте useCallback и useMemo для предотвращения ненужных перерендеров
5. **Чистка**: используйте возвращаемую функцию в useEffect для очистки ресурсов

## Связанные Концепции

- [[React Архитектура]]
- [[Компонентная Архитектура]]
- [[Управление Состоянием]]
- [[TypeScript в Компонентах]]

## Теги

#react #hooks #frontend #javascript #components #state-management #custom-hooks