---
tags: [react, virtual-dom, performance, rendering]
aliases: [React Virtual DOM, Виртуальный DOM React]
---

# Подробное руководство по Virtual DOM в React

## Что такое Virtual DOM

Virtual DOM (виртуальный DOM) - это концепция программирования, при которой виртуальное представление UI хранится в памяти и синхронизируется с "реальным" DOM с помощью библиотеки, такой как ReactDOM. Это позволяет React оптимизировать обновления DOM, минимизируя количество дорогостоящих операций с DOM.

> [!note]
> Virtual DOM не является частью спецификации DOM, а представляет собой паттерн программирования, реализованный в библиотеках, таких как React.

## Как работает Virtual DOM

Когда состояние компонента изменяется, React создает новое дерево Virtual DOM, которое представляет собой структуру данных, описывающую UI. Затем React сравнивает новое дерево с предыдущим (с помощью алгоритма диффинга) и вычисляет минимальный набор изменений, необходимых для обновления реального DOM.

```jsx
// Пример: изменение состояния вызывает перерисовку
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}
```

## Сравнение с реальным DOM

| Характеристика | Реальный DOM | Virtual DOM |
|----------------|--------------|-------------|
| Производительность | Низкая при частых обновлениях | Высокая благодаря оптимизациям |
| Обновления | Прямые операции в браузере | Сравнение в памяти, затем минимальные обновления |
| Сложность | Высокая при сложных обновлениях | Упрощенная для разработчиков |
| Память | Низкое использование | Дополнительное дерево в памяти |

## Преимущества производительности Virtual DOM

- **Минимизация операций DOM**: React вычисляет минимальный набор изменений для обновления реального DOM
- **Батчинг обновлений**: Несколько изменений состояния объединяются в одно обновление DOM
- **Оптимизация рендеринга**: Повторное использование неизменившихся элементов
- **Избегание ненужных перерисовок**: Только измененные компоненты перерисовываются

## Алгоритм согласования (Reconciliation)

Reconciliation - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React строит новое Virtual DOM и сравнивает его с предыдущим деревом, чтобы определить минимальный набор изменений для обновления реального DOM.

### Основные принципы алгоритма:
1. **Использование ключей (keys)**: React использует ключи для идентификации элементов
2. **Сравнение по типу**: Элементы одного типа обновляются, разного типа - заменяются
3. **Рекурсивное сравнение**: Дочерние элементы сравниваются рекурсивно

## Реализация React Fiber

React Fiber - это внутренняя реализация алгоритма согласования, введенная в React 16. Она позволяет:
- Прерывать и возобновлять рендеринг
- Приоритезировать обновления
- Делать рендеринг асинхронным

> [!info]
> Fiber реализует концепцию "incremental rendering", позволяя React разбивать работу по обновлению дерева на фрагменты и при необходимости прерывать их для обработки более приоритетных задач.

## Детали алгоритма диффинга

React использует эвристический алгоритм O(n) для сравнения деревьев, основанный на нескольких предположениях:
- Если элементы имеют разные типы, React создает новое поддерево
- Элементы одного типа обновляются инкрементально
- Использование ключей позволяет React идентифицировать перемещенные элементы

```jsx
// Правильное использование ключей
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}> // Используйте уникальный ID, а не индекс
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

## Когда происходят повторные рендеры

React перерисовывает компоненты в следующих случаях:
- Изменение состояния компонента (useState)
- Изменение свойств (props)
- Вызов forceUpdate (редко используется)
- Изменение контекста (Context)

## Оптимизация рендеров

### React.memo
Позволяет избежать повторных рендеров функциональных компонентов при неизменных props:

```jsx
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  // Компонент будет перерисован только при изменении data
  return <div>{data}</div>;
});
```

### useCallback и useMemo
Помогают избежать ненужных перерисовок дочерних компонентов:

```jsx
function Parent({ items }) {
  const handleClick = useCallback((id) => {
    // Обработчик, который не будет пересоздаваться при каждом рендере
  }, []);

  const expensiveValue = useMemo(() => {
    // Вычисление, которое будет выполнено только при изменении зависимостей
    return items.reduce((sum, item) => sum + item.value, 0);
  }, [items]);

  return (
    <div>
      {items.map(item => (
        <ChildComponent 
          key={item.id} 
          onClick={handleClick} 
          value={expensiveValue} 
        />
      ))}
    </div>
  );
}
```

## Пакетные обновления (Batched Updates)

React объединяет несколько обновлений состояния в одну перерисовку для повышения производительности:

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handlePress() {
    setCount(c => c + 1); // Не вызывает перерисовку
    setFlag(f => !f);     // Не вызывает перерисовку
    // Оба обновления будут объединены в одну перерисовку
  }
}
```

## Неизменяемые vs изменяемые паттерны данных

React лучше работает с неизменяемыми данными, так как это позволяет эффективно определять изменения:

```jsx
// Не рекомендуется - изменяемые данные
function handleAddItem(item) {
  items.push(item); // Мутация
  setState({ items }); // Может не вызвать перерисовку
}

// Рекомендуется - неизменяемые данные
function handleAddItem(item) {
  setState(prev => ({
    ...prev,
    items: [...prev.items, item] // Создание нового массива
  }));
}
```

## Оптимизации рендеринга в React

- Использование `React.memo` для функциональных компонентов
- Использование `PureComponent` для классовых компонентов
- Правильное использование ключей
- Избегание создания функций в рендере
- Использование `useCallback` и `useMemo` при необходимости

## Проблемы с Virtual DOM

- **Дополнительное использование памяти**: Хранение дополнительного дерева в памяти
- **Сложность отладки**: Сложнее отследить изменения по сравнению с прямым манипулированием DOM
- **Оверхед для простых приложений**: Для простых приложений может быть избыточным
- **Неправильное использование ключей**: Может привести к проблемам с производительностью

## Альтернативы Virtual DOM

- **Incremental DOM**: Google Closure Library, использует подход "построения пошагово"
- **Native DOM manipulation**: Прямое манипулирование DOM (jQuery, vanilla JS)
- **Template-based**: Angular использует шаблоны с изменением детекции
- **Fine-grained reactivity**: Svelte и SolidJS компилируют компоненты в эффективные обновления

## Будущее Virtual DOM

React продолжает развивать свою архитектуру:
- Улучшения в Fiber для лучшей производительности
- Поддержка новых возможностей браузеров
- Интеграция с Web Components
- Возможности для лучшей оптимизации сборки

## Связи с другими файлами React

- [[react/basics/components]] - основы компонентов
- [[react/basics/state-and-props]] - управление состоянием и свойствами
- [[react/performance/optimization-techniques]] - дополнительные техники оптимизации
- [[react/hooks/useEffect]] - эффекты и жизненный цикл компонентов
- [[react/architecture/fiber-architecture]] - подробная архитектура Fiber
- [[react/basics/react-lifecycle]] - жизненный цикл компонентов