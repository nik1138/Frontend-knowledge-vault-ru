---
aliases: ["Компонентный подход", "Декомпозиция React", "Архитектура React"]
tags: 
  - #react
  - #react/basics
  - #component-design
  - #state-management
  - #frontend-architecture
---

# Thinking in React: Компонентный подход к построению интерфейсов

## Введение

"Thinking in React" — это философия и методология построения пользовательских интерфейсов с использованием React. Это не просто библиотека, а подход к мышлению о пользовательском интерфейсе как о совокупности компонентов, каждый из которых имеет свои данные, поведение и связи с другими компонентами.

## Основные принципы React

### Компонентный подход

React строится на компонентной архитектуре, где интерфейс разбивается на независимые, повторно используемые блоки — компоненты. Каждый компонент инкапсулирует свою логику, стили и данные.

```jsx
function UserCard({ user }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}
```

### Однонаправленный поток данных

В React данные всегда передаются сверху вниз по иерархии компонентов. Родительские компоненты передают данные дочерним через [[props]], что обеспечивает предсказуемость и легкость отладки.

> [!info] Информация
> Однонаправленный поток данных — это ключевая особенность React, обеспечивающая предсказуемость состояния приложения.

## Процесс декомпозиции компонентов

### 1. Разделение интерфейса на компоненты

Первый шаг — визуальное разбиение интерфейса на логические блоки. Каждый блок может стать отдельным компонентом. Ориентируйтесь на:
- Повторяющиеся элементы (списки, карточки)
- Логически связанные элементы
- Функциональные блоки (формы, навигация, контент)

### 2. Идентификация минимального представления состояния

Определите минимальный набор изменяемых данных (state), который необходим для работы приложения. Избегайте дублирования данных и вычисляемых значений.

```jsx
// Плохо: дублирование данных
const [users, setUsers] = useState([]);
const [filteredUsers, setFilteredUsers] = useState([]);

// Хорошо: минимальное состояние
const [users, setUsers] = useState([]);
const [filter, setFilter] = useState('');
```

### 3. Поднятие состояния (Lifting State Up)

Когда несколько компонентов нуждаются в доступе к одному состоянию, его нужно поднять до ближайшего общего предка. Это обеспечивает согласованность данных.

```jsx
function UserList() {
  const [selectedUser, setSelectedUser] = useState(null);
  
  return (
    <div>
      <UserSelector 
        users={users} 
        onSelect={setSelectedUser} 
      />
      <UserDetails user={selectedUser} />
    </div>
  );
}
```

## Обработка пользовательского ввода

Компоненты React могут обрабатывать события и изменять состояние при взаимодействии пользователя. Используйте хуки [[useState]] и [[useEffect]] для управления состоянием.

```jsx
function SearchInput({ onSearch }) {
  const [query, setQuery] = useState('');
  
  const handleChange = (e) => {
    const newQuery = e.target.value;
    setQuery(newQuery);
    onSearch(newQuery);
  };
  
  return (
    <input
      type="text"
      value={query}
      onChange={handleChange}
      placeholder="Поиск..."
    />
  );
}
```

## Иерархия компонентов

Создание четкой иерархии компонентов помогает поддерживать структуру приложения. Следуйте принципам:
- Компоненты высокого уровня управляют состоянием
- Компоненты низкого уровня отвечают за отображение
- Используйте композицию для построения сложных интерфейсов

## Практическое упражнение: Создание списка задач

Рассмотрим процесс создания простого приложения "Список задач":

1. **Декомпозиция**:
   - `TaskApp` (корневой компонент)
   - `TaskList` (список задач)
   - `TaskItem` (одна задача)
   - `TaskForm` (форма добавления задачи)

2. **Управление состоянием**:
   - Состояние задач поднимается до `TaskApp`

3. **Обработка ввода**:
   - Форма отправляет новые задачи в родительский компонент

```jsx
function TaskApp() {
  const [tasks, setTasks] = useState([]);
  const [nextId, setNextId] = useState(1);
  
  const addTask = (text) => {
    setTasks([...tasks, { id: nextId, text, completed: false }]);
    setNextId(nextId + 1);
  };
  
  const toggleTask = (id) => {
    setTasks(tasks.map(task => 
      task.id === id ? { ...task, completed: !task.completed } : task
    ));
  };
  
  return (
    <div>
      <h1>Список задач</h1>
      <TaskForm onAdd={addTask} />
      <TaskList tasks={tasks} onToggle={toggleTask} />
    </div>
  );
}
```

## Функциональное программирование в React

React поощряет функциональный подход:
- Чистые компоненты без побочных эффектов
- Иммутабельные изменения состояния
- Функции высшего порядка для переиспользуемой логики

## Ментальная модель React

При разработке с React думайте:
- Какие данные нужны компоненту?
- Какие действия пользователь может выполнить?
- Как состояние изменяется при этих действиях?
- Как компоненты связаны друг с другом?

## Заключение

"Thinking in React" — это подход к разработке интерфейсов, основанный на компонентах, однонаправленном потоке данных и минимальном состоянии. Понимание этих концепций позволяет создавать масштабируемые и поддерживаемые приложения.

## Связанные темы

- [[React State Management]]
- [[Component Architecture]]
- [[Props vs State]]
- [[React Hooks]]
- [[Functional Components]]
- [[React Lifecycle]]

## Дополнительные ресурсы

- [Официальная документация React](https://react.dev/learn/thinking-in-react)
- [[React Best Practices]]
- [[React Design Patterns]]