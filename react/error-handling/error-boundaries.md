---
aliases: ["Обработка ошибок в React", "React Error Boundaries"]
tags: 
  - #react
  - #error-handling
  - #component-lifecycle
  - #javascript
---

# Обработка ошибок в React: Error Boundaries

## Введение

Error boundaries (границы ошибок) — это компоненты React, которые перехватывают JavaScript-ошибки в дереве компонентов дочерних элементов, регистрируют эти ошибки и отображают резервный UI вместо краша компонента. Error boundaries обрабатывают ошибки во время рендеринга, в методах жизненного цикла и в конструкторах всех дочерних компонентов.

## Что такое Error Boundaries

Error boundaries — это специальные React-компоненты, реализующие один или оба метода жизненного цикла:
- `static getDerivedStateFromError()`
- `componentDidCatch()`

Они перехватывают ошибки, возникающие во время рендеринга дочерних компонентов, и позволяют отобразить резервный интерфейс вместо пустой страницы.

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновить состояние, чтобы следующий рендер показал резервный UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Логирование ошибки в сервис отчетов
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Можно вернуть любой резервный UI
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```

## Методы жизненного цикла Error Boundaries

### getDerivedStateFromError

Статический метод, вызываемый после возникновения ошибки в дереве дочерних компонентов. Он получает ошибку в качестве параметра и должен вернуть объект состояния для обновления состояния компонента.

```jsx
static getDerivedStateFromError(error) {
  // Обновление состояния, чтобы показать резервный UI
  return { hasError: true };
}
```

> [!note] Важно
> `getDerivedStateFromError()` вызывается во время фазы "рендеринга", поэтому здесь нельзя использовать побочные эффекты. Для побочных эффектов (например, логирования ошибки) используйте `componentDidCatch()`.

### componentDidCatch

Метод, вызываемый сразу после возникновения ошибки в дереве дочерних компонентов. Он получает два параметра:
- `error` — сам объект ошибки
- `errorInfo` — объект с информацией о местоположении ошибки

```jsx
componentDidCatch(error, errorInfo) {
  // Логирование ошибки для последующего анализа
  logErrorToService(error, errorInfo);
}
```

## Где размещать Error Boundaries

Размещение Error Boundaries зависит от требований к пользовательскому интерфейсу и архитектуре приложения:

1. **Корневой уровень приложения** — для отображения глобального сообщения об ошибке
2. **Отдельные компоненты** — для изоляции ошибок конкретных частей интерфейса
3. **Группы компонентов** — для защиты целых секций приложения
4. **Критические компоненты** — для обеспечения стабильности важных частей UI

## Как работают Error Boundaries

Error boundaries перехватывают ошибки, возникающие во время рендеринга, в методах жизненного цикла и в конструкторах дочерних компонентов. Они НЕ перехватывают:
- Обработчики событий (для этого используйте try/catch)
- Асинхронные функции (setTimeout, Promise и т.д.)
- Серверный рендеринг
- Ошибки в самом error boundary

## Резервные компоненты (Fallback Components)

Резервный компонент отображается вместо компонента, в котором произошла ошибка. Он может содержать:
- Сообщение об ошибке
- Кнопку перезагрузки
- Контактную информацию
- Ссылки на справку

```jsx
function FallbackComponent({ error, resetError }) {
  return (
    <div role="alert">
      <p>Произошла ошибка:</p>
      <pre>{error.message}</pre>
      <button onClick={resetError}>Попробовать снова</button>
    </div>
  );
}
```

## Лучшие практики Error Boundaries

1. **Изолируйте критические компоненты** — оборачивайте важные части UI отдельными boundaries
2. **Не создавайте слишком много boundaries** — избегайте избыточного использования
3. **Логируйте ошибки** — используйте сервисы логирования для анализа проблем
4. **Предоставляйте пользовательский опыт** — показывайте понятные сообщения об ошибках
5. **Используйте семантические атрибуты** — для доступности (role="alert")

## componentDidCatch vs getDerivedStateFromError

| Метод | Назначение | Фаза вызова | Побочные эффекты |
|-------|------------|-------------|------------------|
| `getDerivedStateFromError` | Обновление состояния для отображения резервного UI | Фаза рендеринга | Нет |
| `componentDidCatch` | Логирование ошибки, отправка в сервисы отчетов | Фаза коммита | Да |

## Обработка ошибок в функциональных компонентах

Функциональные компоненты не могут использовать методы жизненного цикла, поэтому для них используются хуки и HOC:

```jsx
// С использованием хука
function withErrorBoundary(WrappedComponent) {
  return function ErrorBoundary(props) {
    const [hasError, setHasError] = useState(false);
    
    if (hasError) {
      return <div>Произошла ошибка</div>;
    }
    
    return <WrappedComponent {...props} />;
  };
}

// С использованием библиотеки
import ErrorBoundary from '@sentry/react';

function App() {
  return (
    <ErrorBoundary fallback={<div>Что-то пошло не так</div>}>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

## Error Boundaries vs try-catch

| Error Boundaries | try-catch |
|------------------|-----------|
| Работают на уровне компонентов | Работают в синхронном коде |
| Перехватывают ошибки в рендере | Перехватывают ошибки в обработчиках событий |
| Автоматически обрабатывают ошибки дочерних компонентов | Требуют ручного обнаружения ошибок |
| Обеспечивают резервный UI | Требуют ручной обработки ошибок |

## Ограничения Error Boundaries

Error boundaries НЕ перехватывают:
- Обработчики событий
- Асинхронный код (setTimeout, Promise)
- Серверный рендеринг
- Ошибки в самих error boundaries
- Ошибки в портале (React.createPortal)

## Тестирование Error Boundaries

Для тестирования error boundaries рекомендуется:

1. Создавать компонент, который выбрасывает ошибку
2. Проверять, что резервный UI отображается корректно
3. Проверять, что методы жизненного цикла вызываются

```jsx
// Тестовый компонент, выбрасывающий ошибку
function BrokenComponent() {
  throw new Error('Тестовая ошибка');
}

// Тест с использованием React Testing Library
test('Error boundary показывает резервный UI при ошибке', () => {
  render(
    <ErrorBoundary>
      <BrokenComponent />
    </ErrorBoundary>
  );
  
  expect(screen.getByText('Что-то пошло не так.')).toBeInTheDocument();
});
```

## Распространенные паттерны ошибок

1. **Ошибки в рендере** — при неправильных данных или отсутствии свойств
2. **Ошибки в методах жизненного цикла** — при неправильной инициализации
3. **Ошибки в библиотеках** — при некорректной работе внешних зависимостей

## Обработка асинхронных ошибок

Для асинхронных ошибок (Promise, async/await) используйте try/catch внутри обработчиков:

```jsx
function AsyncComponent() {
  const [error, setError] = useState(null);
  
  const handleClick = async () => {
    try {
      await fetchData();
    } catch (err) {
      setError(err.message);
    }
  };
  
  if (error) return <div>Ошибка: {error}</div>;
  
  return <button onClick={handleClick}>Загрузить данные</button>;
}
```

## Стратегии логирования ошибок

1. **Консольное логирование** — для разработки
2. **Сервисы отчетов** — Sentry, LogRocket, Bugsnag
3. **Собственные системы** — для внутреннего анализа
4. **Аналитика** — Google Analytics, Mixpanel

## Инструменты отчета об ошибках

- [[react/error-handling/sentry-integration|Sentry]] — популярный сервис для отслеживания ошибок
- LogRocket — для записи сессий пользователей
- Bugsnag — для мониторинга производительности
- Rollbar — для управления ошибками

## Паттерны восстановления ошибок

1. **Автоматическое восстановление** — повторные попытки после ошибки
2. **Ручное восстановление** — кнопка "Попробовать снова"
3. **Градуированное восстановление** — постепенное восстановление функций
4. **Альтернативные пути** — предоставление альтернативных способов выполнения действий

## Плавная деградация ошибок

При возникновении ошибок важно обеспечить:
- Понятное сообщение пользователю
- Возможность продолжить работу с другими частями приложения
- Сохранение важных данных
- Минимальное влияние на пользовательский опыт

## Философия обработки ошибок в React

React придерживается подхода "ошибки должны быть локализованы", где:
- Ошибки в одном компоненте не должны крашить все приложение
- Пользовательский интерфейс должен оставаться стабильным
- Ошибки должны быть видимыми для разработчиков
- Система должна быть устойчивой к частичным сбоям

## Связанные темы

- [[react/components/error-handling|Обработка ошибок в компонентах]]
- [[react/error-handling/sentry-integration|Интеграция Sentry]]
- [[react/hooks/use-error-boundary|Хук для Error Boundary]]
- [[react/error-handling/async-error-handling|Обработка асинхронных ошибок]]
- [[react/testing/error-boundary-testing|Тестирование Error Boundaries]]

## Заключение

Error boundaries — важный инструмент для создания устойчивых React-приложений. Правильное использование error boundaries позволяет изолировать ошибки, обеспечивать стабильную работу приложения и улучшать пользовательский опыт при возникновении непредвиденных ситуаций.
