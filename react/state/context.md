---
aliases: ["Контекст API", "React Context", "Контекст в React"]
tags: 
  - #react
  - #state-management
  - #context-api
  - #hooks
---

# React Context API: Полное руководство

## Что такое Context API

Context API - это встроенный механизм React для передачи данных через дерево компонентов без необходимости передавать пропсы на каждом уровне. Он решает проблему "prop drilling", когда данные должны проходить через множество компонентов, которые их не используют.

Context позволяет создать "глобальное" хранилище данных, доступное для всех компонентов в дереве. Это особенно полезно для таких данных, как пользовательская сессия, тема оформления, язык интерфейса и другие настройки приложения.

## Создание контекста с помощью createContext

Для создания контекста используется функция `createContext`, экспортируемая из React:

```jsx
import React, { createContext } from 'react';

const MyContext = createContext();
```

Функция `createContext` принимает необязательный параметр - значение по умолчанию, которое будет использоваться, если компонент не имеет ближайшего Provider выше в дереве:

```jsx
const ThemeContext = createContext('light'); // значение по умолчанию
```

## Provider компонент

Provider компонент позволяет дочерним компонентам использовать значение контекста. Он принимает пропс `value`, который определяет, какие данные будут доступны:

```jsx
<MyContext.Provider value={someValue}>
  <ChildComponent />
</MyContext.Provider>
```

Provider можно вкладывать друг в друга, создавая иерархию значений. Дочерние компоненты будут использовать значение ближайшего Provider выше в дереве.

## useContext хук

Для получения значения контекста в функциональном компоненте используется хук `useContext`:

```jsx
import React, { useContext } from 'react';

function MyComponent() {
  const contextValue = useContext(MyContext);
  
  return <div>{contextValue}</div>;
}
```

> [!tip] Совет
> `useContext` всегда ссылается на ближайший Provider выше в дереве компонентов. Если Provider не найден, будет использовано значение по умолчанию, переданное в `createContext`.

## Вложенные контексты

Контексты могут быть вложенными друг в друга, создавая сложные структуры данных:

```jsx
<UserContext.Provider value={user}>
  <ThemeContext.Provider value={theme}>
    <AppContent />
  </ThemeContext.Provider>
</UserContext.Provider>
```

Каждый контекст может иметь свои собственные значения и провайдеры, что позволяет изолировать разные аспекты состояния приложения.

## Производительность и оптимизация контекста

Context может вызывать повторный рендеринг всех компонентов, использующих его значение. Для оптимизации:

1. Разделяйте контексты по функциональности
2. Используйте `React.memo` для компонентов
3. Избегайте создания новых объектов в `value` при каждом рендере

```jsx
// Плохо - вызывает перерендер при каждом рендере
<Context.Provider value={{ count, increment }}>
  {children}
</Context.Provider>

// Хорошо - значение стабильно
const contextValue = useMemo(() => ({ count, increment }), [count]);
<Context.Provider value={contextValue}>
  {children}
</Context.Provider>
```

## Сценарии использования

Context API особенно полезен для:

- Управления темой приложения
- Аутентификации пользователей
- Локализации
- Общего состояния приложения
- Настроек приложения

## Расширенные паттерны с контекстом

### Контекст с локальным состоянием

Контекст можно комбинировать с `useState` для создания локального состояния:

```jsx
const CountProvider = ({ children }) => {
  const [count, setCount] = useState(0);
  
  return (
    <CountContext.Provider value={{ count, setCount }}>
      {children}
    </CountContext.Provider>
  );
};
```

### Контекст с функциями

Контекст может содержать не только данные, но и функции для их изменения:

```jsx
const AppContext = createContext();

const AppProvider = ({ children }) => {
  const [state, setState] = useState(initialState);
  
  const updateValue = (newValue) => {
    setState(prev => ({ ...prev, value: newValue }));
  };
  
  return (
    <AppContext.Provider value={{ state, updateValue }}>
      {children}
    </AppContext.Provider>
  );
};
```

## Комбинирование контекста и редюсера

Контекст часто используется вместе с `useReducer` для сложного управления состоянием:

```jsx
const AppReducer = (state, action) => {
  switch(action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    default:
      return state;
  }
};

const AppStateProvider = ({ children }) => {
  const [state, dispatch] = useReducer(AppReducer, initialState);
  
  return (
    <AppStateContext.Provider value={{ state, dispatch }}>
      {children}
    </AppStateContext.Provider>
  );
};
```

## Сравнение с другими решениями управления состоянием

| Решение | Преимущества | Недостатки |
|---------|--------------|------------|
| Context API | Встроенный в React, прост в использовании | Может вызывать лишние перерендеры |
| Redux | Структурированный подход, инструменты разработчика | Более сложная настройка |
| Zustand | Простой и легковесный | Меньше экосистемы |
| MobX | Реактивность, простота | Может быть сложнее для понимания |

Context API подходит для большинства приложений средней сложности, но для очень крупных приложений могут потребоваться более мощные решения.

## Лучшие практики

1. **Разделяйте контексты** - не помещайте все в один контекст
2. **Используйте TypeScript** для типизации значений контекста
3. **Оптимизируйте значения** - избегайте создания новых объектов при каждом рендере
4. **Изолируйте провайдеры** - используйте отдельные компоненты-обертки
5. **Документируйте контексты** - описывайте, что содержит каждый контекст

## Распространенные ошибки

1. **Слишком широкий контекст** - помещение всех данных в один контекст
2. **Частые изменения значений** - приводит к лишним перерендерам
3. **Отсутствие типизации** - затрудняет поддержку кода
4. **Неправильная иерархия провайдеров** - может привести к неожиданному поведению

> [!warning] Важно
> Избегайте использования контекста для часто изменяющихся данных, так как это может негативно сказаться на производительности.

## Связи с другими файлами

- [[react/hooks/useContext]] - подробное руководство по хуку `useContext`
- [[react/hooks/useReducer]] - использование редюсера с контекстом
- [[react/state-management]] - общее руководство по управлению состоянием
- [[react/performance]] - рекомендации по оптимизации производительности
- [[typescript/react-context]] - использование контекста с TypeScript

## Заключение

Context API - мощный инструмент для управления состоянием в React-приложениях. Он особенно полезен для передачи данных, которые используются во многих компонентах, таких как тема, аутентификация и локализация. Правильное использование контекста помогает избежать "prop drilling" и упрощает архитектуру приложения.

При использовании контекста важно учитывать производительность и правильно структурировать данные, разделяя их на логически связанные группы.