---
aliases: ["Оптимизация производительности React", "React производительность"]
tags: 
  - #react
  - #performance
  - #optimization
  - #best-practices
---

# Лучшие практики оптимизации производительности React

## Введение

Оптимизация производительности в React - это комплекс мер, направленных на улучшение скорости рендеринга, уменьшение количества ненужных перерисовок и повышение отзывчивости приложения. Эффективная оптимизация может значительно улучшить пользовательский опыт и снизить нагрузку на устройства пользователей.

## Основы рендеринга React

React использует виртуальный DOM для эффективного обновления реального DOM. При изменении состояния или пропсов компонент перерисовывается, и React вычисляет минимальные изменения для применения в браузере. Однако избыточные перерисовки могут замедлить приложение.

> [!NOTE]
> Понимание жизненного цикла компонентов и процесса reconciliation (согласования) критично для эффективной оптимизации.

## Техники мемоизации

### React.memo

`React.memo` - это функция высшего порядка, которая мемоизирует компонент, предотвращая его перерисовку при неизменности пропсов:

```jsx
const MyComponent = React.memo(function MyComponent({ name, age }) {
  return <div>{name} is {age} years old</div>;
});
```

### useMemo

`useMemo` позволяет мемоизировать вычисления, чтобы они не пересчитывались при каждой перерисовке:

```jsx
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]); // Зависимости
```

### useCallback

`useCallback` мемоизирует функции, предотвращая создание новых функций при каждой перерисовке:

```jsx
const handleClick = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

> [!WARNING]
> Избыточное использование мемоизации может ухудшить производительность из-за накладных расходов на сравнение зависимостей.

## Стратегии разделения кода

### Lazy Loading и Suspense

React позволяет откладывать загрузку компонентов до момента их необходимости:

```jsx
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

### Code Splitting

Разделение кода позволяет загружать только необходимые части приложения:

```jsx
// Разделение по маршрутам
const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));
```

## Виртуализация и оконные техники

### Virtualization

Для списков с большим количеством элементов используйте виртуализацию:

```jsx
import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>{items[index]}</div>
  );

  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={50}
    >
      {Row}
    </List>
  );
}
```

## Избегание ненужных перерисовок

### Правильное управление состоянием

Избегайте ненужных изменений объектов и массивов:

```jsx
// Плохо
setState(prev => ({ ...prev, newProp: value }));

// Хорошо - если newProp не изменился
setState(prev => {
  if (prev.newProp === value) return prev;
  return { ...prev, newProp: value };
});
```

### Оптимизация контекста

Контекст может вызывать перерисовку всех потребителей при изменении:

```jsx
// Разделяйте контексты по частям состояния
const UserContext = createContext();
const ThemeContext = createContext();
```

## Оптимизация сборки

### Tree Shaking

Tree shaking позволяет удалять неиспользуемый код из финальной сборки:

```js
// Импортируйте только нужные функции
import { debounce } from 'lodash/debounce';
// Вместо
import { debounce } from 'lodash';
```

### Bundle Optimization

- Используйте асинхронные импорты для разделения кода
- Оптимизируйте зависимости
- Используйте CDN для часто используемых библиотек

## Профилирование производительности

### React DevTools Profiler

React DevTools предоставляет инструменты для анализа производительности:

1. Установите расширение React DevTools
2. Используйте вкладку Profiler
3. Запишите сессию и анализируйте перерисовки

### Измерение производительности

```jsx
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log(`${id} took ${actualDuration}ms to render`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Component />
    </Profiler>
  );
}
```

## Распространенные ошибки производительности

- Создание новых объектов/функций в рендере
- Избыточное использование контекста
- Неправильное использование мемоизации
- Загрузка большого количества данных без пагинации
- Неправильное управление состоянием

## Оптимизация в продакшене

- Используйте продакшен-сборку React
- Включите сжатие (Gzip/Brotli)
- Используйте CDN для статических ресурсов
- Оптимизируйте изображения и медиафайлы
- Внедрите кеширование на уровне HTTP

## Связанные темы

- [[react/hooks]] - для понимания правильного использования хуков
- [[react/context]] - для оптимизации работы с контекстом
- [[react/state-management]] - для эффективного управления состоянием
- [[react/components]] - для понимания архитектуры компонентов
- [[react/testing]] - для обеспечения производительности в тестах

## Заключение

Оптимизация производительности - это непрерывный процесс. Важно измерять, а не предполагать, где происходят узкие места. Начинайте с оптимизации пользовательского опыта и переходите к технической оптимизации только при наличии реальных проблем с производительностью.