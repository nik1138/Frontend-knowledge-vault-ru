---
aliases: ["Серверная валидация", "Валидация на стороне сервера", "Backend validation"]
tags: ["#validation", "#backend", "#security", "#api"]
---

# Валидация на сервере

**Валидация на сервере** - это критически важный этап проверки данных, поступающих от клиентов, на стороне сервера. Это основной уровень защиты приложения от некорректных, вредоносных или неполных данных.

## Общие сведения

Серверная валидация является обязательной частью безопасного веб-приложения. Независимо от того, насколько надежной кажется клиентская валидация, сервер должен всегда проверять полученные данные, поскольку клиентский код может быть обойден или изменен.

## Почему важна серверная валидация

- **Безопасность**: Защита от вредоносных данных и атак (SQL-инъекции, XSS и т.д.)
- **Целостность данных**: Обеспечение корректности данных в базе
- **Надежность**: Приложение должно корректно обрабатывать любые входные данные
- **Соответствие требованиям**: Некоторые стандарты безопасности требуют серверной валидации

## Основные принципы серверной валидации

- **Never trust client data**: Всегда проверять все данные, поступающие от клиента
- **Fail securely**: При ошибках валидации возвращать минимальную информацию об ошибке
- **Early validation**: Проверять данные как можно раньше в процессе обработки
- **Comprehensive validation**: Проверять не только формат, но и бизнес-логику

## Валидация в Node.js

### С использованием Joi

```javascript
const Joi = require('joi');

const userSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(8).pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)')).required(),
  age: Joi.number().integer().min(18).max(120),
  role: Joi.string().valid('user', 'admin', 'moderator').default('user')
});

app.post('/api/users', async (req, res) => {
  try {
    const { error, value } = userSchema.validate(req.body);
    
    if (error) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.details.map(detail => detail.message)
      });
    }
    
    // Данные валидны, продолжаем обработку
    const user = await createUser(value);
    res.status(201).json(user);
  } catch (err) {
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### С использованием express-validator

```javascript
const { body, validationResult } = require('express-validator');

app.post('/api/users', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
  body('age').isInt({ min: 18, max: 120 }),
  body('role').isIn(['user', 'admin', 'moderator'])
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  // Данные валидны
  createUser(req.body)
    .then(user => res.status(201).json(user))
    .catch(err => res.status(500).json({ error: 'Server error' }));
});
```

## Валидация в Python (Django)

```python
from django.core.exceptions import ValidationError
from django.core.validators import EmailValidator
from django.http import JsonResponse
import json

def validate_user_data(data):
    errors = {}
    
    # Валидация email
    email = data.get('email')
    if not email:
        errors['email'] = 'Email обязателен'
    else:
        try:
            validator = EmailValidator()
            validator(email)
        except ValidationError:
            errors['email'] = 'Некорректный email'
    
    # Валидация пароля
    password = data.get('password')
    if not password:
        errors['password'] = 'Пароль обязателен'
    elif len(password) < 8:
        errors['password'] = 'Пароль должен быть не менее 8 символов'
    elif not any(c.isupper() for c in password):
        errors['password'] = 'Пароль должен содержать заглавную букву'
    
    return errors

def create_user_view(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        errors = validate_user_data(data)
        
        if errors:
            return JsonResponse({'errors': errors}, status=400)
        
        # Данные валидны, создаем пользователя
        user = create_user(data)
        return JsonResponse({'user': user}, status=201)
```

## Валидация в Python (Pydantic)

```python
from pydantic import BaseModel, EmailStr, validator
from typing import Optional
import re

class UserCreateRequest(BaseModel):
    email: EmailStr
    password: str
    age: int
    role: Optional[str] = 'user'
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Пароль должен быть не менее 8 символов')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Пароль должен содержать заглавную букву')
        if not re.search(r'[a-z]', v):
            raise ValueError('Пароль должен содержать строчную букву')
        if not re.search(r'\d', v):
            raise ValueError('Пароль должен содержать цифру')
        return v
    
    @validator('age')
    def validate_age(cls, v):
        if v < 18 or v > 120:
            raise ValueError('Возраст должен быть от 18 до 120')
        return v

# Использование
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.post('/users')
def create_user(user_data: UserCreateRequest):
    # Pydantic автоматически валидирует данные
    # Если данные некорректны, будет выброшено исключение
    user = create_user_in_db(user_data.dict())
    return {'user': user}
```

## Валидация в Java (Spring Boot)

```java
import javax.validation.constraints.*;
import javax.validation.Valid;
import org.springframework.validation.annotation.Validated;

@Validated
@RestController
public class UserController {
    
    public static class UserDTO {
        @NotNull(message = "Email обязателен")
        @Email(message = "Некорректный email")
        private String email;
        
        @NotNull(message = "Пароль обязателен")
        @Size(min = 8, message = "Пароль должен быть не менее 8 символов")
        @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)", 
                 message = "Пароль должен содержать заглавную, строчную буквы и цифру")
        private String password;
        
        @Min(value = 18, message = "Возраст должен быть не менее 18")
        @Max(value = 120, message = "Возраст должен быть не более 120")
        private Integer age;
        
        @Pattern(regexp = "user|admin|moderator", message = "Некорректная роль")
        private String role = "user";
        
        // getters and setters
    }
    
    @PostMapping("/api/users")
    public ResponseEntity<?> createUser(@Valid @RequestBody UserDTO userDTO) {
        // Данные уже валидированы, создаем пользователя
        User user = userService.createUser(userDTO);
        return ResponseEntity.ok(user);
    }
}
```

## Валидация в Go

```go
package main

import (
    "encoding/json"
    "net/http"
    "regexp"
    "strconv"
    "strings"
)

type User struct {
    Email    string `json:"email"`
    Password string `json:"password"`
    Age      int    `json:"age"`
    Role     string `json:"role"`
}

type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
}

func validateUser(user User) []ValidationError {
    var errors []ValidationError
    
    // Валидация email
    if user.Email == "" {
        errors = append(errors, ValidationError{
            Field:   "email",
            Message: "Email обязателен",
        })
    } else if !isValidEmail(user.Email) {
        errors = append(errors, ValidationError{
            Field:   "email",
            Message: "Некорректный email",
        })
    }
    
    // Валидация пароля
    if user.Password == "" {
        errors = append(errors, ValidationError{
            Field:   "password",
            Message: "Пароль обязателен",
        })
    } else if len(user.Password) < 8 {
        errors = append(errors, ValidationError{
            Field:   "password",
            Message: "Пароль должен быть не менее 8 символов",
        })
    } else if !isValidPassword(user.Password) {
        errors = append(errors, ValidationError{
            Field:   "password",
            Message: "Пароль должен содержать заглавную, строчную буквы и цифру",
        })
    }
    
    // Валидация возраста
    if user.Age < 18 || user.Age > 120 {
        errors = append(errors, ValidationError{
            Field:   "age",
            Message: "Возраст должен быть от 18 до 120",
        })
    }
    
    // Валидация роли
    if user.Role != "" && user.Role != "user" && user.Role != "admin" && user.Role != "moderator" {
        errors = append(errors, ValidationError{
            Field:   "role",
            Message: "Некорректная роль",
        })
    }
    
    return errors
}

func isValidEmail(email string) bool {
    // Простая проверка email
    return strings.Contains(email, "@") && strings.Contains(email, ".")
}

func isValidPassword(password string) bool {
    hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
    hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
    hasDigit := regexp.MustCompile(`\d`).MatchString(password)
    return hasUpper && hasLower && hasDigit
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    errors := validateUser(user)
    if len(errors) > 0 {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]interface{}{
            "error": "Validation failed",
            "details": errors,
        })
        return
    }
    
    // Данные валидны, создаем пользователя
    createdUser := createUserInDB(user)
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(createdUser)
}
```

## Лучшие практики серверной валидации

- **Проверять все входные данные**: GET-параметры, POST-данные, заголовки, файлы
- **Использовать белый список**: Разрешать только известные и безопасные значения
- **Ограничивать размеры данных**: Защита от DoS-атак
- **Проверять бизнес-логику**: Убедиться, что данные соответствуют бизнес-правилам
- **Возвращать информативные, но безопасные сообщения об ошибках**
- **Использовать готовые библиотеки валидации**: Не изобретать велосипед
- **Проводить валидацию на разных уровнях**: Маршрутизация, контроллер, сервис

## Связанные темы

- [[Валидация-на-клиенте]]
- [[Валидация-в-React]]
- [[Валидация-в-Vue]]
- [[Валидация-в-Svelte]]
- [[Безопасность-веб-приложений]]
- [[API-валидация]]

## Теги

#validation #backend #security #api #server #web-development #data-validation