# Встраиваемые системы

Встраиваемые системы — это специализированные компьютерные системы, которые встроены в другие устройства для выполнения конкретных функций. Они характеризуются ограниченными ресурсами, реальными сроками выполнения и высокой надежностью. Встраиваемые системы находят применение в автомобилях, медицинском оборудовании, бытовой электронике, промышленной автоматизации и многих других областях.

## Основные характеристики

### Ограниченные ресурсы
Встраиваемые системы работают с ограниченными ресурсами памяти, процессора и энергии.

```c
// Пример кода для микроконтроллера
#include <avr/io.h>
#include <util/delay.h>

#define LED_PIN PB0

void init_gpio() {
    // Настройка пина как выхода
    DDRB |= (1 << LED_PIN);  // Установка бита в 1 (выход)
}

void toggle_led() {
    // Переключение состояния светодиода
    PORTB ^= (1 << LED_PIN);  // XOR для переключения
}

int main(void) {
    init_gpio();
    
    while(1) {
        toggle_led();
        _delay_ms(1000);  // Задержка 1 секунда
    }
    
    return 0;
}
```

### Реальное время
Встраиваемые системы часто должны реагировать на события в строго определенные сроки.

```c
// Пример системы реального времени
#include <stdint.h>
#include <stdbool.h>

#define MAX_TASKS 10
#define TICK_RATE_MS 10

typedef struct {
    void (*function)(void);
    uint32_t period;
    uint32_t delay;
    bool enabled;
} Task;

Task task_list[MAX_TASKS];
uint8_t task_count = 0;

void scheduler_add_task(void (*function)(void), uint32_t period_ms) {
    if (task_count < MAX_TASKS) {
        task_list[task_count].function = function;
        task_list[task_count].period = period_ms / TICK_RATE_MS;
        task_list[task_count].delay = task_list[task_count].period;
        task_list[task_count].enabled = true;
        task_count++;
    }
}

void scheduler_tick() {
    for (int i = 0; i < task_count; i++) {
        if (task_list[i].enabled) {
            if (task_list[i].delay == 0) {
                task_list[i].function();
                task_list[i].delay = task_list[i].period;
            } else {
                task_list[i].delay--;
            }
        }
    }
}
```

### Надежность и отказоустойчивость
Встраиваемые системы должны работать надежно в течение длительного времени без сбоев.

```c
// Пример механизма самоконтроля
#include <stdint.h>
#include <stdbool.h>

#define WATCHDOG_TIMEOUT 1000  // 1 секунда

static volatile uint32_t watchdog_counter = 0;
static volatile bool system_ok = true;

void watchdog_reset() {
    watchdog_counter = 0;
}

void watchdog_check() {
    watchdog_counter++;
    if (watchdog_counter > WATCHDOG_TIMEOUT) {
        system_ok = false;
        // Здесь можно добавить код перезагрузки системы
    }
}

bool system_is_ok() {
    return system_ok;
}

// Пример использования в основном цикле
int main() {
    while(1) {
        // Выполнение основных задач
        perform_tasks();
        
        // Сброс сторожевого таймера
        watchdog_reset();
        
        // Проверка состояния системы
        if (!system_is_ok()) {
            // Аварийная остановка или перезагрузка
            emergency_shutdown();
        }
        
        delay_ms(10);
    }
}
```

## Архитектура встраиваемых систем

### Микроконтроллеры
Микроконтроллеры — это интегральные схемы, содержащие процессор, память и периферийные устройства.

```c
// Пример работы с периферией микроконтроллера
#include <stm32f4xx.h>

void init_adc() {
    // Включение тактирования ADC и GPIO
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    
    // Настройка пина PA0 как аналоговый вход
    GPIOA->MODER |= GPIO_MODER_MODER0;
    
    // Настройка ADC
    ADC1->CR2 |= ADC_CR2_ADON;  // Включение ADC
    ADC1->SQR3 = 0;             // Выбор канала 0
}

uint16_t read_adc() {
    ADC1->CR2 |= ADC_CR2_SWSTART;  // Запуск преобразования
    
    // Ожидание завершения преобразования
    while (!(ADC1->SR & ADC_SR_EOC));
    
    return ADC1->DR;  // Чтение результата
}
```

### Операционные системы реального времени (RTOS)
RTOS обеспечивают управление задачами и ресурсами в системах реального времени.

```c
// Пример использования FreeRTOS
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

QueueHandle_t sensor_queue;

void sensor_task(void *pvParameters) {
    uint16_t sensor_value;
    
    while(1) {
        // Чтение данных с датчика
        sensor_value = read_sensor();
        
        // Отправка данных в очередь
        if (xQueueSend(sensor_queue, &sensor_value, 0) != pdTRUE) {
            // Очередь переполнена
        }
        
        vTaskDelay(pdMS_TO_TICKS(100));  // Задержка 100 мс
    }
}

void processing_task(void *pvParameters) {
    uint16_t received_value;
    
    while(1) {
        // Получение данных из очереди
        if (xQueueReceive(sensor_queue, &received_value, portMAX_DELAY) == pdTRUE) {
            // Обработка данных
            process_sensor_data(received_value);
        }
    }
}

int main(void) {
    // Создание очереди
    sensor_queue = xQueueCreate(10, sizeof(uint16_t));
    
    // Создание задач
    xTaskCreate(sensor_task, "Sensor", 128, NULL, 1, NULL);
    xTaskCreate(processing_task, "Processing", 256, NULL, 2, NULL);
    
    // Запуск планировщика
    vTaskStartScheduler();
    
    // Этот код никогда не выполнится
    return 0;
}
```

## Протоколы связи

### Последовательные интерфейсы
Встраиваемые системы часто используют последовательные интерфейсы для связи с другими устройствами.

```c
// Пример реализации UART
#include <stdint.h>

#define UART_BUFFER_SIZE 64

typedef struct {
    uint8_t buffer[UART_BUFFER_SIZE];
    uint8_t head;
    uint8_t tail;
    uint8_t count;
} uart_buffer_t;

static uart_buffer_t rx_buffer;
static uart_buffer_t tx_buffer;

void uart_init(uint32_t baud_rate) {
    // Настройка регистров UART
    // (Зависит от конкретного микроконтроллера)
    
    // Включение прерываний
    UART->CR1 |= UART_CR1_RXNEIE;  // Прерывание по приему
    NVIC_EnableIRQ(USART1_IRQn);   // Включение в NVIC
}

void uart_send_byte(uint8_t data) {
    while (!(UART->SR & UART_SR_TXE));  // Ожидание готовности передатчика
    UART->DR = data;                    // Отправка байта
}

uint8_t uart_receive_byte() {
    while (!(UART->SR & UART_SR_RXNE));  // Ожидание приема данных
    return UART->DR;                     // Чтение принятого байта
}
```

### Промышленные протоколы
В промышленной автоматизации используются специализированные протоколы.

```c
// Пример реализации Modbus RTU
#include <stdint.h>

#define MODBUS_BUFFER_SIZE 256

typedef struct {
    uint8_t slave_id;
    uint8_t function_code;
    uint16_t start_address;
    uint16_t quantity;
    uint16_t crc;
} modbus_request_t;

uint16_t calculate_crc(uint8_t *data, uint16_t length) {
    uint16_t crc = 0xFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= data[i];
        
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    
    return crc;
}

int modbus_process_request(uint8_t *request, uint16_t length) {
    if (length < 4) return -1;  // Слишком короткий запрос
    
    // Проверка CRC
    uint16_t received_crc = (request[length-1] << 8) | request[length-2];
    uint16_t calculated_crc = calculate_crc(request, length-2);
    
    if (received_crc != calculated_crc) return -2;  // Ошибка CRC
    
    // Обработка запроса
    switch (request[1]) {  // function_code
        case 0x03:  // Read Holding Registers
            return modbus_read_holding_registers(request, length);
        case 0x06:  // Write Single Register
            return modbus_write_single_register(request, length);
        case 0x10:  // Write Multiple Registers
            return modbus_write_multiple_registers(request, length);
        default:
            return -3;  // Неподдерживаемая функция
    }
}
```

## Преимущества встраиваемых систем

1. **Специализация** — Оптимизация под конкретные задачи
2. **Энергоэффективность** — Минимальное потребление энергии
3. **Компактность** — Малые размеры и вес
4. **Надежность** — Высокая отказоустойчивость
5. **Стоимость** — Низкая себестоимость при массовом производстве

## Связанные концепции

- [[Императивное программирование]] - Встраиваемые системы часто используют императивный подход
- [[Структурное программирование]] - Встраиваемые программы следуют принципам структурного программирования
- [[DRY (Don't Repeat Yourself)]] - В встраиваемых системах важно избегать дублирования для повышения надежности
- [[KISS (Keep It Simple, Stupid)]] - Встраиваемые системы должны быть простыми и надежными
- [[Чистый код]] - Чистый код особенно важен во встраиваемых системах из-за критичности ошибок

## В других технологиях

### В [[c]]
Язык C является основным языком для программирования встраиваемых систем:

```c
// Пример работы с прерываниями
#include <avr/io.h>
#include <avr/interrupt.h>

volatile uint16_t timer_count = 0;

// Обработчик прерывания таймера
ISR(TIMER0_OVF_vect) {
    timer_count++;
    
    // Каждые 1000 прерываний
    if (timer_count % 1000 == 0) {
        // Переключение светодиода
        PORTB ^= (1 << PB5);
    }
}

void init_timer() {
    // Настройка таймера 0
    TCCR0B |= (1 << CS02) | (1 << CS00);  // Предделитель 1024
    TIMSK0 |= (1 << TOIE0);               // Разрешение прерывания переполнения
    sei();                                // Глобальное разрешение прерываний
}

int main(void) {
    // Настройка пина PB5 как выхода
    DDRB |= (1 << PB5);
    
    // Инициализация таймера
    init_timer();
    
    // Бесконечный цикл
    while(1) {
        // Основная программа
    }
}
```

### В [[python]]
Python может использоваться для разработки и тестирования встраиваемых систем:

```python
# Инструменты для разработки встраиваемых систем на Python
import serial
import struct
import time

class EmbeddedTester:
    def __init__(self, port, baudrate=9600):
        self.serial = serial.Serial(port, baudrate, timeout=1)
        time.sleep(2)  # Ожидание инициализации
    
    def send_command(self, command, data=None):
        """Отправка команды встраиваемому устройству"""
        packet = struct.pack('B', command)
        if data:
            packet += struct.pack('B' * len(data), *data)
        
        # Добавление CRC
        crc = self.calculate_crc(packet)
        packet += struct.pack('H', crc)
        
        self.serial.write(packet)
        
    def read_response(self, expected_length):
        """Чтение ответа от встраиваемого устройства"""
        response = self.serial.read(expected_length)
        if len(response) == expected_length:
            # Проверка CRC
            data = response[:-2]
            received_crc = struct.unpack('H', response[-2:])[0]
            calculated_crc = self.calculate_crc(data)
            
            if received_crc == calculated_crc:
                return data
        return None
    
    def calculate_crc(self, data):
        """Вычисление CRC"""
        crc = 0xFFFF
        for byte in data:
            crc ^= byte
            for _ in range(8):
                if crc & 0x0001:
                    crc >>= 1
                    crc ^= 0xA001
                else:
                    crc >>= 1
        return crc

# Использование
tester = EmbeddedTester('/dev/ttyUSB0')
tester.send_command(0x01, [0x00, 0x01])  # Чтение регистра
response = tester.read_response(4)
```

## Теги
#embedded-systems #microcontrollers #real-time #iot #automation