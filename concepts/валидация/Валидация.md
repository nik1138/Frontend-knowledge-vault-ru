---
aliases: ["Фронтенд валидация", "Проверка данных", "Валидация форм"]
tags: [frontend, validation, forms, javascript, security]
---

# Валидация в фронтенд-разработке

## Обзор

**Валидация** — это процесс проверки корректности вводимых пользователем данных на стороне клиента. В контексте фронтенд-разработки, валидация помогает обеспечить, что пользователь ввел правильные данные перед отправкой формы или выполнением других действий.

> [!note] 
> Валидация на фронтенде **не заменяет** серверную валидацию. Это первый уровень проверки, улучшающий UX и снижающий нагрузку на сервер.

## Типы валидации

### 1. Клиентская валидация

Проверка данных происходит на стороне клиента (браузера) до отправки на сервер.

#### Преимущества:
- Быстрая обратная связь пользователю
- Снижение нагрузки на сервер
- Улучшенный пользовательский опыт

#### Недостатки:
- Не может быть доверена как единственный уровень проверки
- Может быть обойдена пользователем

### 2. Серверная валидация

Проверка данных происходит на сервере. Является обязательной для обеспечения безопасности и целостности данных.

> [!important]
> Серверная валидация всегда должна присутствовать, независимо от клиентской валидации.

## Валидация форм в HTML

HTML5 предоставляет встроенные средства валидации:

```html
<form>
  <label for="email">Email:</label>
  <input 
    type="email" 
    id="email" 
    name="email" 
    required 
    pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
  >
  
  <label for="password">Пароль:</label>
  <input 
    type="password" 
    id="password" 
    name="password" 
    required 
    minlength="8"
  >
  
  <button type="submit">Отправить</button>
</form>
```

### Атрибуты валидации HTML

| Атрибут | Описание |
|---------|----------|
| `required` | Поле обязательно для заполнения |
| `minlength` | Минимальная длина строки |
| `maxlength` | Максимальная длина строки |
| `min` | Минимальное значение (для чисел и дат) |
| `max` | Максимальное значение (для чисел и дат) |
| `pattern` | Регулярное выражение для проверки |
| `type` | Тип данных (email, url, number и т.д.) |

## JavaScript валидация

Для более сложной логики валидации используется JavaScript:

```javascript
function validateForm(formData) {
  const errors = {};
  
  // Проверка email
  if (!formData.email) {
    errors.email = 'Email обязателен';
  } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
    errors.email = 'Email введен некорректно';
  }
  
  // Проверка пароля
  if (!formData.password) {
    errors.password = 'Пароль обязателен';
  } else if (formData.password.length < 8) {
    errors.password = 'Пароль должен содержать минимум 8 символов';
  }
  
  // Проверка подтверждения пароля
  if (formData.password !== formData.confirmPassword) {
    errors.confirmPassword = 'Пароли не совпадают';
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}

// Использование
const form = document.querySelector('form');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  const formData = new FormData(form);
  const data = Object.fromEntries(formData);
  const result = validateForm(data);
  
  if (result.isValid) {
    console.log('Форма валидна, отправляем данные');
    // Отправка данных
  } else {
    console.log('Ошибки валидации:', result.errors);
    displayErrors(result.errors);
  }
});

function displayErrors(errors) {
  // Очистка предыдущих ошибок
  document.querySelectorAll('.error-message').forEach(el => el.remove());
  
  // Отображение новых ошибок
  Object.keys(errors).forEach(fieldName => {
    const field = document.querySelector(`[name="${fieldName}"]`);
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = errors[fieldName];
    errorDiv.style.color = 'red';
    field.parentNode.insertBefore(errorDiv, field.nextSibling);
  });
}
```

## Библиотеки валидации

### Yup

Популярная библиотека для валидации схем:

```javascript
import * as yup from 'yup';

const userSchema = yup.object({
  name: yup.string().required('Имя обязательно'),
  email: yup.string().email('Некорректный email').required('Email обязателен'),
  age: yup.number().positive().integer().min(18, 'Возраст должен быть 18+'),
  website: yup.string().url('Некорректный URL').nullable()
});

// Использование
const userData = {
  name: 'Иван',
  email: 'ivan@example.com',
  age: 25
};

try {
  await userSchema.validate(userData);
  console.log('Данные валидны');
} catch (error) {
  console.log('Ошибка валидации:', error.message);
}
```

### Joi

Альтернативная библиотека валидации:

```javascript
import Joi from 'joi';

const schema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  password: Joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')),
  email: Joi.string().email({
    minDomainSegments: 2,
    tlds: { allow: ['com', 'net'] }
  })
});

const { error, value } = schema.validate({
  username: 'abc',
  password: 'password',
  email: 'mail@example.com'
});
```

## Валидация в React

### С использованием хуков

```jsx
import React, { useState } from 'react';

const FormValidation = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  
  const [errors, setErrors] = useState({});
  
  const validateField = (name, value) => {
    switch (name) {
      case 'email':
        if (!value) return 'Email обязателен';
        if (!/\S+@\S+\.\S+/.test(value)) return 'Email введен некорректно';
        return '';
      case 'password':
        if (!value) return 'Пароль обязателен';
        if (value.length < 8) return 'Пароль должен содержать минимум 8 символов';
        return '';
      default:
        return '';
    }
  };
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Валидация в реальном времени
    const error = validateField(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Полная валидация при отправке
    const newErrors = {};
    Object.keys(formData).forEach(key => {
      const error = validateField(key, formData[key]);
      if (error) newErrors[key] = error;
    });
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Форма валидна', formData);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          className={errors.email ? 'error' : ''}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <label>Пароль:</label>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          className={errors.password ? 'error' : ''}
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <button type="submit">Отправить</button>
    </form>
  );
};
```

### С использованием react-hook-form

```jsx
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().email('Некорректный email').required('Email обязателен'),
  password: yup.string().min(8, 'Минимум 8 символов').required('Пароль обязателен')
}).required();

const FormWithReactHookForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(schema)
  });
  
  const onSubmit = (data) => {
    console.log(data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input 
          {...register("email")} 
          placeholder="Email" 
        />
        {errors.email && <span>{errors.email.message}</span>}
      </div>
      
      <div>
        <input 
          {...register("password")} 
          type="password" 
          placeholder="Пароль" 
        />
        {errors.password && <span>{errors.password.message}</span>}
      </div>
      
      <button type="submit">Отправить</button>
    </form>
  );
};
```

## Лучшие практики

### 1. Валидация в реальном времени
Показывайте ошибки по мере ввода, но не слишком часто (например, с задержкой в 300-500мс).

### 2. Понятные сообщения об ошибках
Сообщения должны быть понятны пользователю и содержать инструкции по исправлению.

### 3. Стилизация ошибок
Используйте визуальные индикаторы для полей с ошибками (цвет, иконки, подчеркивания).

### 4. Комбинированная валидация
Используйте как клиентскую, так и серверную валидацию.

### 5. Проверка доступности
Убедитесь, что сообщения об ошибках доступны для пользователей с ограниченными возможностями.

## Расширенные концепции

### Кастомные валидаторы

```javascript
// Валидация ИНН
function validateINN(value) {
  if (!/^\d{10}(\d{2})?$/.test(value)) return false;
  
  const checkDigit = (inn, coefficients) => {
    return inn.substr(-1) === (
      coefficients.reduce((acc, coeff, i) => acc + coeff * +inn[i], 0) % 11
    ) % 10;
  };
  
  if (value.length === 10) {
    return checkDigit(value, [2, 4, 10, 3, 5, 9, 4, 6, 8]);
  } else {
    return checkDigit(value, [7, 2, 4, 10, 3, 5, 9, 4, 6, 8]) && 
           checkDigit(value, [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8]);
  }
}

// Валидация даты рождения
function validateBirthDate(value) {
  const date = new Date(value);
  const today = new Date();
  const minDate = new Date();
  minDate.setFullYear(today.getFullYear() - 150); // Не старше 150 лет
  
  return date >= minDate && date <= today;
}
```

## Связанные концепции

- [[Формы в React]]
- [[Безопасность веб-приложений]]
- [[Регулярные выражения]]
- [[Обработка ошибок]]
- [[UX/UI дизайн]]
- [[Тестирование веб-приложений]]

## Заключение

Валидация данных — важная часть фронтенд-разработки, обеспечивающая качество пользовательских данных и улучшающая пользовательский опыт. Правильная реализация валидации включает в себя сочетание HTML-атрибутов, JavaScript-логики и, при необходимости, специализированных библиотек.

Помните, что клиентская валидация не должна использоваться как единственный уровень защиты данных — всегда проводите серверную валидацию для обеспечения безопасности и целостности данных.

## Теги

#frontend #validation #javascript #forms #security #user-experience #react #html