---
aliases: ["Фабрика и DI", "Factory and Dependency Injection", "DI Factory"]
tags: [factory, dependency-injection, di, javascript, patterns, oop]
---

# Фабрика-и-инъекция-зависимостей

Фабрика-и-инъекция-зависимостей - это комбинация двух важных паттернов проектирования, которые вместе обеспечивают гибкость, тестируемость и модульность в приложениях. Фабрика отвечает за создание объектов, а инъекция зависимостей управляет тем, какие зависимости передаются этим объектам при создании.

## Обзор

Комбинация фабрики и инъекции зависимостей позволяет создавать объекты с заранее определенными зависимостями, что делает код более гибким и легко тестируемым. Фабрика может использовать контейнер инъекции зависимостей для получения необходимых зависимостей при создании объектов.

## Простая реализация фабрики с инъекцией зависимостей

```javascript
// Простой контейнер инъекции зависимостей
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }
  
  // Регистрация сервиса
  register(name, factory, options = {}) {
    this.services.set(name, { factory, options });
    return this;
  }
  
  // Регистрация синглтона
  registerSingleton(name, factory) {
    this.services.set(name, { factory, options: { singleton: true } });
    return this;
  }
  
  // Получение сервиса
  get(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Сервис "${name}" не зарегистрирован`);
    }
    
    // Если это синглтон и уже создан, возвращаем существующий экземпляр
    if (service.options.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }
    
    // Создаем новый экземпляр
    const instance = typeof service.factory === 'function' 
      ? service.factory(this) 
      : service.factory;
    
    // Если это синглтон, сохраняем экземпляр
    if (service.options.singleton) {
      this.singletons.set(name, instance);
    }
    
    return instance;
  }
  
  // Проверка наличия сервиса
  has(name) {
    return this.services.has(name);
  }
}

// Пример сервисов
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
  
  error(message) {
    console.error(`[ERROR] ${message}`);
  }
}

class Database {
  constructor(connectionString) {
    this.connectionString = connectionString || 'default://connection';
  }
  
  connect() {
    console.log(`Подключение к базе данных: ${this.connectionString}`);
    return true;
  }
  
  query(sql) {
    console.log(`Выполнение запроса: ${sql}`);
    return [{ id: 1, name: 'test' }];
  }
}

class UserService {
  constructor(database, logger) {
    this.database = database;
    this.logger = logger;
  }
  
  getUser(id) {
    this.logger.log(`Получение пользователя с ID: ${id}`);
    const result = this.database.query(`SELECT * FROM users WHERE id = ${id}`);
    this.logger.log(`Пользователь найден: ${result.length > 0 ? result[0].name : 'не найден'}`);
    return result[0];
  }
  
  createUser(userData) {
    this.logger.log(`Создание пользователя: ${userData.name}`);
    // Логика создания пользователя
    this.logger.log(`Пользователь ${userData.name} создан`);
    return { id: Date.now(), ...userData };
  }
}

// Фабрика с инъекцией зависимостей
class ServiceFactory {
  constructor(container) {
    this.container = container;
  }
  
  // Создание сервиса пользователя
  createUserService() {
    const database = this.container.get('database');
    const logger = this.container.get('logger');
    return new UserService(database, logger);
  }
  
  // Создание других сервисов
  createOrderService() {
    const database = this.container.get('database');
    const logger = this.container.get('logger');
    const emailService = this.container.get('emailService');
    
    return {
      database,
      logger,
      emailService,
      createOrder: (orderData) => {
        logger.log(`Создание заказа для пользователя ${orderData.userId}`);
        // Логика создания заказа
        logger.log(`Заказ создан: ${orderData.id}`);
        return { id: Date.now(), status: 'pending', ...orderData };
      }
    };
  }
}

// Настройка контейнера и фабрики
const container = new DIContainer();

// Регистрация сервисов
container
  .registerSingleton('logger', () => new Logger())
  .registerSingleton('database', (container) => {
    const logger = container.get('logger');
    logger.log('Инициализация подключения к базе данных');
    return new Database('postgresql://localhost:5432/myapp');
  })
  .register('emailService', (container) => {
    const logger = container.get('logger');
    return {
      logger,
      send: (to, subject, body) => {
        logger.log(`Отправка email на ${to}: ${subject}`);
        // Логика отправки email
      }
    };
  });

// Создание фабрики
const factory = new ServiceFactory(container);

// Использование
const userService = factory.createUserService();
const user = userService.getUser(123);
console.log(user);

const orderService = factory.createOrderService();
const order = orderService.createOrder({ userId: 123, items: ['item1', 'item2'] });
console.log(order);
```

## Фабрика с автоматической инъекцией зависимостей

```javascript
// Фабрика с автоматической инъекцией зависимостей
class AutoDIContainer {
  constructor() {
    this.services = new Map();
    this.cache = new Map();
  }
  
  // Регистрация сервиса с автоматическим определением зависимостей
  register(name, constructorFn, options = {}) {
    // Извлечение зависимостей из строки конструктора
    const deps = this.extractDependencies(constructorFn);
    
    this.services.set(name, {
      constructor: constructorFn,
      dependencies: deps,
      options
    });
    
    return this;
  }
  
  // Извлечение зависимостей из конструктора
  extractDependencies(fn) {
    const fnStr = fn.toString();
    const args = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(',');
    return args
      .map(arg => arg.trim())
      .filter(arg => arg && arg !== '...args'); // Исключаем rest параметры
  }
  
  // Получение сервиса с автоматической инъекцией зависимостей
  get(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Сервис "${name}" не зарегистрирован`);
    }
    
    // Если это синглтон и уже создан, возвращаем кэшированный экземпляр
    if (service.options.singleton && this.cache.has(name)) {
      return this.cache.get(name);
    }
    
    // Получаем зависимости
    const dependencies = service.dependencies.map(dep => this.get(dep));
    
    // Создаем экземпляр с внедренными зависимостями
    const instance = new service.constructor(...dependencies);
    
    // Кэшируем синглтон
    if (service.options.singleton) {
      this.cache.set(name, instance);
    }
    
    return instance;
  }
  
  // Фабрика для создания объектов с инъекцией зависимостей
  create(Constructor, ...additionalArgs) {
    const dependencies = this.extractDependencies(Constructor);
    const resolvedDeps = dependencies.map(dep => this.get(dep));
    
    return new Constructor(...resolvedDeps, ...additionalArgs);
  }
}

// Пример использования
class NotificationService {
  constructor(logger) {
    this.logger = logger;
  }
  
  sendNotification(message, userId) {
    this.logger.log(`Отправка уведомления пользователю ${userId}: ${message}`);
    // Логика отправки уведомления
  }
}

class PaymentService {
  constructor(database, logger) {
    this.database = database;
    this.logger = logger;
  }
  
  processPayment(amount, userId) {
    this.logger.log(`Обработка платежа на сумму ${amount} для пользователя ${userId}`);
    // Логика обработки платежа
    this.logger.log(`Платеж обработан успешно`);
    return { success: true, transactionId: Date.now() };
  }
}

class OrderService {
  constructor(database, paymentService, notificationService) {
    this.database = database;
    this.paymentService = paymentService;
    this.notificationService = notificationService;
  }
  
  async createOrder(orderData) {
    // Обработка заказа с использованием зависимостей
    const paymentResult = await this.paymentService.processPayment(
      orderData.amount, 
      orderData.userId
    );
    
    if (paymentResult.success) {
      this.notificationService.sendNotification(
        'Ваш заказ создан', 
        orderData.userId
      );
      
      return {
        orderId: Date.now(),
        status: 'completed',
        paymentId: paymentResult.transactionId
      };
    }
    
    return { status: 'failed' };
  }
}

// Настройка контейнера
const autoContainer = new AutoDIContainer();

autoContainer
  .register('logger', () => new Logger(), { singleton: true })
  .register('database', () => new Database(), { singleton: true })
  .register('notificationService', NotificationService, { singleton: true })
  .register('paymentService', PaymentService, { singleton: true })
  .register('orderService', OrderService, { singleton: true });

// Использование
const orderService = autoContainer.get('orderService');
const result = await orderService.createOrder({
  userId: 123,
  amount: 99.99
});
console.log(result);
```

## Фабрика с условной инъекцией зависимостей

```javascript
// Фабрика с условной инъекцией зависимостей
class ConditionalFactory {
  constructor(container) {
    this.container = container;
    this.config = {};
  }
  
  // Установка конфигурации
  setConfig(config) {
    this.config = { ...this.config, ...config };
    return this;
  }
  
  // Создание сервиса с условной инъекцией
  createService(serviceName, options = {}) {
    const serviceConfig = this.config[serviceName] || {};
    
    // Определение зависимостей на основе конфигурации
    const dependencies = this.resolveDependencies(serviceName, serviceConfig, options);
    
    switch (serviceName) {
      case 'emailService':
        return this.createEmailService(dependencies, serviceConfig);
      case 'fileService':
        return this.createFileService(dependencies, serviceConfig);
      case 'cacheService':
        return this.createCacheService(dependencies, serviceConfig);
      default:
        throw new Error(`Неизвестный сервис: ${serviceName}`);
    }
  }
  
  resolveDependencies(serviceName, serviceConfig, options) {
    const dependencies = {};
    
    // Общие зависимости
    dependencies.logger = this.container.get('logger');
    
    // Условные зависимости
    if (serviceConfig.useDatabase) {
      dependencies.database = this.container.get('database');
    }
    
    if (serviceConfig.useCache) {
      dependencies.cache = this.container.get('cache');
    }
    
    if (serviceConfig.useExternalApi) {
      dependencies.apiClient = this.container.get('apiClient');
    }
    
    // Добавляем опции как зависимости
    dependencies.options = { ...serviceConfig, ...options };
    
    return dependencies;
  }
  
  createEmailService(deps, config) {
    const { logger, options } = deps;
    
    return {
      logger,
      provider: options.provider || 'smtp',
      send: (to, subject, body) => {
        logger.log(`Отправка email через ${this.provider}: ${subject}`);
        // Логика отправки email
      }
    };
  }
  
  createFileService(deps, config) {
    const { logger, database, options } = deps;
    
    return {
      logger,
      storagePath: options.storagePath || './uploads',
      database,
      save: (fileData, fileName) => {
        logger.log(`Сохранение файла: ${fileName}`);
        // Логика сохранения файла
        if (database) {
          // Сохраняем метаданные в базу данных
          logger.log(`Метаданные файла сохранены в базу данных`);
        }
      }
    };
  }
  
  createCacheService(deps, config) {
    const { logger, options } = deps;
    
    return {
      logger,
      ttl: options.ttl || 3600, // время жизни в секундах
      store: new Map(),
      get: (key) => {
        const item = this.store.get(key);
        if (item && item.expiry > Date.now()) {
          return item.value;
        } else if (item) {
          this.store.delete(key); // Удаляем просроченный элемент
        }
        return null;
      },
      set: (key, value) => {
        this.store.set(key, {
          value,
          expiry: Date.now() + (this.ttl * 1000)
        });
        logger.log(`Кэширование данных по ключу: ${key}`);
      }
    };
  }
}

// Использование
const conditionalContainer = new DIContainer();
conditionalContainer
  .registerSingleton('logger', () => new Logger())
  .registerSingleton('database', () => new Database())
  .register('cache', () => ({ /* реализация кэша */ }))
  .register('apiClient', () => ({ /* реализация API клиента */ }));

const conditionalFactory = new ConditionalFactory(conditionalContainer);
conditionalFactory.setConfig({
  emailService: {
    provider: 'sendgrid',
    useExternalApi: true
  },
  fileService: {
    storagePath: '/var/uploads',
    useDatabase: true
  },
  cacheService: {
    ttl: 7200,
    useCache: true
  }
});

const emailService = conditionalFactory.createService('emailService');
const fileService = conditionalFactory.createService('fileService');
const cacheService = conditionalFactory.createService('cacheService');

console.log(emailService.provider); // sendgrid
console.log(fileService.storagePath); // /var/uploads
console.log(cacheService.ttl); // 7200
```

## Фабрика с асинхронной инъекцией зависимостей

```javascript
// Фабрика с асинхронной инъекцией зависимостей
class AsyncDIContainer {
  constructor() {
    this.services = new Map();
    this.initialized = new Map();
    this.initQueue = new Map();
  }
  
  // Регистрация асинхронного сервиса
  registerAsync(name, asyncFactory, options = {}) {
    this.services.set(name, { factory: asyncFactory, options });
    return this;
  }
  
  // Асинхронное получение сервиса
  async getAsync(name) {
    // Проверяем, инициализирован ли сервис
    if (this.initialized.has(name)) {
      return this.initialized.get(name);
    }
    
    // Проверяем, находится ли сервис в процессе инициализации
    if (this.initQueue.has(name)) {
      return this.initQueue.get(name);
    }
    
    // Создаем промис инициализации
    const initPromise = this.initializeService(name);
    this.initQueue.set(name, initPromise);
    
    try {
      const service = await initPromise;
      this.initialized.set(name, service);
      this.initQueue.delete(name);
      return service;
    } catch (error) {
      this.initQueue.delete(name);
      throw error;
    }
  }
  
  async initializeService(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Сервис "${name}" не зарегистрирован`);
    }
    
    // Получаем зависимости асинхронно
    const dependencies = {};
    if (service.options.dependencies) {
      for (const depName of service.options.dependencies) {
        dependencies[depName] = await this.getAsync(depName);
      }
    }
    
    // Создаем сервис с зависимостями
    const instance = await service.factory(this, dependencies);
    return instance;
  }
}

// Пример асинхронных сервисов
class ApiService {
  constructor(config) {
    this.config = config;
    this.initialized = false;
  }
  
  async initialize() {
    // Симуляция асинхронной инициализации
    await new Promise(resolve => setTimeout(resolve, 100));
    this.initialized = true;
    console.log('API сервис инициализирован');
  }
  
  async request(endpoint, options = {}) {
    if (!this.initialized) {
      await this.initialize();
    }
    console.log(`Запрос к API: ${endpoint}`);
    return { data: 'response data', endpoint };
  }
}

class AuthService {
  constructor(apiService, token) {
    this.apiService = apiService;
    this.token = token;
  }
  
  async authenticate(credentials) {
    console.log('Аутентификация пользователя');
    const response = await this.apiService.request('/auth', { 
      method: 'POST', 
      body: credentials 
    });
    return response.data;
  }
  
  async refreshAccessToken() {
    console.log('Обновление токена доступа');
    const response = await this.apiService.request('/refresh');
    this.token = response.data.newToken;
    return this.token;
  }
}

// Настройка асинхронного контейнера
const asyncContainer = new AsyncDIContainer();

asyncContainer
  .registerAsync('apiService', async (container) => {
    const apiService = new ApiService({ baseUrl: 'https://api.example.com' });
    await apiService.initialize();
    return apiService;
  })
  .registerAsync('authService', async (container) => {
    const apiService = await container.getAsync('apiService');
    return new AuthService(apiService, 'initial-token');
  }, { dependencies: ['apiService'] });

// Использование
async function example() {
  const authService = await asyncContainer.getAsync('authService');
  const result = await authService.authenticate({ username: 'user', password: 'pass' });
  console.log(result);
}

example().catch(console.error);
```

## Интеграция с фронтенд-фреймворками

```javascript
// Пример интеграции с React
import React, { createContext, useContext, useState, useEffect } from 'react';

// Контекст для DI контейнера
const DIContainerContext = createContext();

// Провайдер DI контейнера
export const DIContainerProvider = ({ container, children }) => {
  return (
    <DIContainerContext.Provider value={container}>
      {children}
    </DIContainerContext.Provider>
  );
};

// Хук для получения сервиса
export const useService = (serviceName) => {
  const container = useContext(DIContainerContext);
  if (!container) {
    throw new Error('useService must be used within DIContainerProvider');
  }
  return container.get(serviceName);
};

// Фабрика компонентов с инъекцией зависимостей
export const withServices = (servicesMap) => (Component) => {
  return (props) => {
    const container = useContext(DIContainerContext);
    if (!container) {
      throw new Error('withServices must be used within DIContainerProvider');
    }
    
    const injectedServices = {};
    for (const [propName, serviceName] of Object.entries(servicesMap)) {
      injectedServices[propName] = container.get(serviceName);
    }
    
    return <Component {...props} {...injectedServices} />;
  };
};

// Пример использования в React
const UserServiceComponent = ({ userService, logger }) => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      logger.log('Загрузка данных пользователя');
      const userData = await userService.getUser(123);
      setUser(userData);
    };
    
    fetchUser();
  }, [userService, logger]);
  
  if (!user) return <div>Загрузка...</div>;
  
  return (
    <div>
      <h2>Пользователь: {user.name}</h2>
      <p>Email: {user.email}</p>
    </div>
  );
};

// Обернем компонент для внедрения зависимостей
const UserServiceWithDeps = withServices({
  userService: 'userService',
  logger: 'logger'
})(UserServiceComponent);

// В приложении
const App = () => {
  const container = new DIContainer();
  container
    .registerSingleton('logger', () => new Logger())
    .registerSingleton('database', () => new Database())
    .register('userService', (container) => {
      const db = container.get('database');
      const logger = container.get('logger');
      return new UserService(db, logger);
    });
  
  return (
    <DIContainerProvider container={container}>
      <UserServiceWithDeps />
    </DIContainerProvider>
  );
};
```

## Преимущества комбинации фабрики и DI

- **Модульность**: Четкое разделение ответственности между созданием объектов и управлением зависимостями
- **Тестируемость**: Легко заменять зависимости для тестирования
- **Гибкость**: Возможность настройки зависимостей в зависимости от окружения
- **Повторное использование**: Компоненты могут использовать одни и те же зависимости
- **Изолированность**: Компоненты не зависят от конкретных реализаций зависимостей

## Недостатки комбинации фабрики и DI

- **Сложность**: Добавляет уровень абстракции, что может усложнить понимание кода
- **Производительность**: Дополнительные вычисления для разрешения зависимостей
- **Настройка**: Требует дополнительной настройки и конфигурации

## Лучшие практики

- **Явные зависимости**: Четко определяйте зависимости в конструкторах или фабричных методах
- **Конфигурация**: Используйте конфигурационные файлы для управления зависимостями
- **Синглтоны**: Используйте синглтоны для сервисов, которые должны быть общими
- **Асинхронная инициализация**: Обрабатывайте асинхронные зависимости корректно
- **Типизация**: Используйте TypeScript для лучшей типизации зависимостей

## Ключевые выводы

- Комбинация фабрики и инъекции зависимостей обеспечивает гибкость и тестируемость
- Позволяет изолировать создание объектов от управления зависимостями
- Особенно полезна в крупных приложениях с множеством взаимозависимых компонентов
- Требует тщательной настройки и понимания принципов работы обоих паттернов

## См. также

- [[Инъекция зависимостей]]
- [[Паттерн-фабрика]]
- [[Функция-фабрика]]
- [[Контейнер]]
- [[Синглтоны]]
- [[Компонентная архитектура]]

#javascript #фабрика #инъекция-зависимостей #паттерны #frontend #архитектура