---
aliases: ["Объектная фабрика", "Object Factory", "Factory Objects"]
tags: [objects, factory, javascript, oop, patterns]
---

# Фабрика-объектов

Фабрика-объектов - это паттерн проектирования, который предоставляет интерфейс для создания объектов без указания их конкретных классов. В отличие от обычной фабрики, фабрика-объектов сама является объектом, который инкапсулирует логику создания других объектов. Этот паттерн особенно полезен при работе с объектами, требующими сложной инициализации или конфигурации.

## Обзор

Фабрика-объектов представляет собой объект, который отвечает за создание других объектов. Вместо прямого вызова конструктора, клиентский код делегирует создание объекта фабрике. Это позволяет изолировать процесс создания объектов и упрощает добавление новых типов объектов без изменения существующего кода.

## Простая реализация фабрики-объекта

```javascript
// Простая фабрика-объект для создания пользователей
const UserFactory = {
  // Конфигурация фабрики
  defaultRole: 'user',
  defaultPermissions: ['read'],
  
  // Метод создания пользователя
  create(userData) {
    return {
      id: userData.id || Date.now(),
      name: userData.name,
      email: userData.email,
      role: userData.role || this.defaultRole,
      permissions: userData.permissions || [...this.defaultPermissions],
      createdAt: new Date(),
      
      // Методы объекта
      hasPermission(permission) {
        return this.permissions.includes(permission);
      },
      
      addPermission(permission) {
        if (!this.hasPermission(permission)) {
          this.permissions.push(permission);
        }
      },
      
      removePermission(permission) {
        this.permissions = this.permissions.filter(p => p !== permission);
      }
    };
  },
  
  // Метод для создания администратора
  createAdmin(userData) {
    const admin = this.create(userData);
    admin.role = 'admin';
    admin.permissions = [...this.defaultPermissions, 'write', 'delete', 'manage'];
    return admin;
  },
  
  // Метод для создания гостя
  createGuest(userData) {
    const guest = this.create(userData);
    guest.role = 'guest';
    guest.permissions = ['read'];
    return guest;
  }
};

// Использование
const regularUser = UserFactory.create({ name: 'John Doe', email: 'john@example.com' });
const adminUser = UserFactory.createAdmin({ name: 'Jane Admin', email: 'jane@example.com' });
const guestUser = UserFactory.createGuest({ name: 'Guest User', email: 'guest@example.com' });

console.log(regularUser.role); // 'user'
console.log(adminUser.permissions); // ['read', 'write', 'delete', 'manage']
console.log(guestUser.hasPermission('write')); // false
```

## Фабрика-объект с прототипами

```javascript
// Фабрика-объект с использованием прототипов
function createVehicleFactory() {
  // Базовый прототип для всех транспортных средств
  const vehiclePrototype = {
    start() {
      console.log(`${this.type} ${this.brand} запущен`);
      this.isRunning = true;
    },
    
    stop() {
      console.log(`${this.type} ${this.brand} остановлен`);
      this.isRunning = false;
    },
    
    getStatus() {
      return this.isRunning ? 'работает' : 'остановлен';
    }
  };
  
  return {
    // Создание автомобиля
    createCar(options = {}) {
      return Object.create(vehiclePrototype, {
        type: { value: 'автомобиль', writable: true },
        brand: { value: options.brand || 'Generic', writable: true },
        doors: { value: options.doors || 4, writable: true },
        isRunning: { value: false, writable: true }
      });
    },
    
    // Создание мотоцикла
    createMotorcycle(options = {}) {
      return Object.create(vehiclePrototype, {
        type: { value: 'мотоцикл', writable: true },
        brand: { value: options.brand || 'Generic', writable: true },
        engineSize: { value: options.engineSize || '125cc', writable: true },
        isRunning: { value: false, writable: true }
      });
    },
    
    // Создание велосипеда
    createBicycle(options = {}) {
      return Object.create(vehiclePrototype, {
        type: { value: 'велосипед', writable: true },
        brand: { value: options.brand || 'Generic', writable: true },
        gears: { value: options.gears || 1, writable: true },
        isRunning: { value: false, writable: true }
      });
    }
  };
}

// Использование
const vehicleFactory = createVehicleFactory();

const car = vehicleFactory.createCar({ brand: 'Toyota', doors: 4 });
const motorcycle = vehicleFactory.createMotorcycle({ brand: 'Honda', engineSize: '600cc' });
const bicycle = vehicleFactory.createBicycle({ brand: 'Giant', gears: 21 });

car.start(); // автомобиль Toyota запущен
console.log(car.getStatus()); // работает
console.log(motorcycle.type); // мотоцикл
console.log(bicycle.gears); // 21
```

## Фабрика-объект с конфигурацией и валидацией

```javascript
// Фабрика-объект с конфигурацией и валидацией
class ProductFactory {
  constructor(config = {}) {
    this.config = {
      defaultCategory: 'general',
      defaultPrice: 0,
      validateOnCreate: true,
      ...config
    };
  }
  
  // Валидация данных продукта
  validate(productData) {
    const errors = [];
    
    if (!productData.name || typeof productData.name !== 'string') {
      errors.push('Имя продукта обязательно и должно быть строкой');
    }
    
    if (typeof productData.price !== 'number' || productData.price < 0) {
      errors.push('Цена должна быть положительным числом');
    }
    
    if (productData.category && typeof productData.category !== 'string') {
      errors.push('Категория должна быть строкой');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  // Создание продукта
  create(productData) {
    // Валидация данных
    if (this.config.validateOnCreate) {
      const validation = this.validate(productData);
      if (!validation.isValid) {
        throw new Error(`Валидация не пройдена: ${validation.errors.join(', ')}`);
      }
    }
    
    // Создание объекта продукта
    return {
      id: productData.id || `prod_${Date.now()}`,
      name: productData.name,
      price: productData.price,
      category: productData.category || this.config.defaultCategory,
      description: productData.description || '',
      inStock: productData.inStock !== undefined ? productData.inStock : true,
      createdAt: new Date(),
      
      // Методы
      updatePrice(newPrice) {
        if (typeof newPrice === 'number' && newPrice >= 0) {
          this.price = newPrice;
        } else {
          throw new Error('Цена должна быть положительным числом');
        }
      },
      
      toggleStock() {
        this.inStock = !this.inStock;
      },
      
      getFormattedPrice() {
        return `₽${this.price.toFixed(2)}`;
      }
    };
  }
  
  // Создание специализированных продуктов
  createDigitalProduct(productData) {
    const product = this.create(productData);
    product.isDigital = true;
    product.downloadCount = 0;
    
    // Добавляем методы для цифрового продукта
    product.download = function() {
      this.downloadCount++;
      console.log(`Продукт "${this.name}" скачан. Всего скачиваний: ${this.downloadCount}`);
    };
    
    return product;
  }
  
  createPhysicalProduct(productData) {
    const product = this.create(productData);
    product.isDigital = false;
    product.weight = productData.weight || 0;
    product.dimensions = productData.dimensions || { width: 0, height: 0, depth: 0 };
    
    // Добавляем методы для физического продукта
    product.getShippingInfo = function() {
      return {
        weight: this.weight,
        dimensions: this.dimensions,
        requiresFragileHandling: productData.fragile || false
      };
    };
    
    return product;
  }
}

// Использование
const productFactory = new ProductFactory({ defaultCategory: 'electronics' });

try {
  const laptop = productFactory.createPhysicalProduct({
    name: 'Ноутбук',
    price: 59990,
    weight: 2.5,
    dimensions: { width: 35, height: 25, depth: 2 },
    fragile: true
  });
  
  const ebook = productFactory.createDigitalProduct({
    name: 'Электронная книга',
    price: 990,
    description: 'Интересная книга о программировании'
  });
  
  console.log(laptop.getFormattedPrice()); // ₽59990.00
  console.log(laptop.getShippingInfo());
  ebook.download(); // Продукт "Электронная книга" скачан. Всего скачиваний: 1
  
} catch (error) {
  console.error('Ошибка создания продукта:', error.message);
}
```

## Фабрика-объект с кэшированием

```javascript
// Фабрика-объект с кэшированием созданных объектов
function createCachedFactory() {
  const cache = new Map();
  
  return {
    // Создание объекта с кэшированием
    create(type, config, useCache = true) {
      // Генерация ключа для кэширования
      const cacheKey = `${type}_${JSON.stringify(config)}`;
      
      // Проверка кэша
      if (useCache && cache.has(cacheKey)) {
        console.log(`Возвращаем кэшированный объект для ключа: ${cacheKey}`);
        return cache.get(cacheKey);
      }
      
      // Создание нового объекта
      let obj;
      switch (type) {
        case 'user':
          obj = {
            type: 'user',
            name: config.name || 'Anonymous',
            email: config.email || 'no-email@example.com',
            preferences: config.preferences || {},
            createdAt: new Date()
          };
          break;
          
        case 'config':
          obj = {
            type: 'config',
            settings: { ...config },
            updatedAt: new Date(),
            updateSetting(key, value) {
              this.settings[key] = value;
              this.updatedAt = new Date();
            }
          };
          break;
          
        default:
          throw new Error(`Неизвестный тип объекта: ${type}`);
      }
      
      // Кэширование объекта
      if (useCache) {
        cache.set(cacheKey, obj);
      }
      
      return obj;
    },
    
    // Очистка кэша
    clearCache() {
      cache.clear();
      console.log('Кэш очищен');
    },
    
    // Получение статистики кэша
    getCacheStats() {
      return {
        size: cache.size,
        keys: Array.from(cache.keys())
      };
    }
  };
}

// Использование
const cachedFactory = createCachedFactory();

const user1 = cachedFactory.create('user', { name: 'John', email: 'john@example.com' });
const user2 = cachedFactory.create('user', { name: 'John', email: 'john@example.com' }); // Из кэша
const user3 = cachedFactory.create('user', { name: 'Jane', email: 'jane@example.com' });

console.log(user1 === user2); // true (один и тот же объект из кэша)
console.log(user1 === user3); // false (разные объекты)

console.log(cachedFactory.getCacheStats()); // { size: 2, keys: [...] }
```

## Фабрика-объект с плагинами

```javascript
// Фабрика-объект с поддержкой плагинов
class ExtensibleFactory {
  constructor() {
    this.plugins = [];
    this.objectModifiers = [];
  }
  
  // Регистрация плагина
  registerPlugin(plugin) {
    if (typeof plugin === 'function') {
      this.plugins.push(plugin);
    } else if (plugin && typeof plugin.enhance === 'function') {
      this.objectModifiers.push(plugin.enhance.bind(plugin));
    }
    return this;
  }
  
  // Создание объекта с применением плагинов
  create(type, config) {
    let obj;
    
    // Создание базового объекта
    switch (type) {
      case 'service':
        obj = {
          type: 'service',
          name: config.name,
          endpoint: config.endpoint,
          options: config.options || {},
          
          async call(data) {
            console.log(`Вызов сервиса ${this.name} с данными:`, data);
            // Здесь мог бы быть реальный вызов API
            return { success: true, data };
          }
        };
        break;
        
      case 'repository':
        obj = {
          type: 'repository',
          name: config.name,
          tableName: config.tableName,
          schema: config.schema || {},
          
          async find(id) {
            console.log(`Поиск записи с ID ${id} в таблице ${this.tableName}`);
            // Здесь могла бы быть реальная логика поиска
            return { id, name: 'Sample Record' };
          },
          
          async save(data) {
            console.log(`Сохранение данных в таблицу ${this.tableName}:`, data);
            return { success: true, id: Date.now() };
          }
        };
        break;
        
      default:
        throw new Error(`Неизвестный тип объекта: ${type}`);
    }
    
    // Применение плагинов
    this.objectModifiers.forEach(modifier => {
      obj = modifier(obj, config) || obj;
    });
    
    // Вызов плагинов
    this.plugins.forEach(plugin => {
      plugin(obj, config);
    });
    
    return obj;
  }
}

// Пример плагина для логирования
const loggingPlugin = {
  enhance(obj, config) {
    // Добавляем методы логирования
    obj.log = function(message) {
      console.log(`[${this.type}] ${this.name}: ${message}`);
    };
    
    // Оборачиваем существующие методы для логирования
    if (obj.call) {
      const originalCall = obj.call;
      obj.call = async function(data) {
        this.log(`Вызов метода call с данными: ${JSON.stringify(data)}`);
        const result = await originalCall.call(this, data);
        this.log(`Метод call завершен, результат: ${JSON.stringify(result)}`);
        return result;
      };
    }
    
    return obj;
  }
};

// Пример плагина для аутентификации
const authPlugin = (obj, config) => {
  if (config.requiresAuth) {
    obj.authenticated = false;
    
    const originalCall = obj.call || (() => {});
    obj.call = async function(data) {
      if (!this.authenticated) {
        throw new Error(`Для вызова ${this.name} требуется аутентификация`);
      }
      return await originalCall.call(this, data);
    };
    
    obj.authenticate = function(credentials) {
      // Здесь могла бы быть реальная логика аутентификации
      this.authenticated = true;
      this.log('Аутентификация прошла успешно');
    };
  }
};

// Использование
const factory = new ExtensibleFactory();
factory.registerPlugin(loggingPlugin);
factory.registerPlugin(authPlugin);

const service = factory.create('service', {
  name: 'UserService',
  endpoint: '/api/users',
  requiresAuth: true
});

service.log('Создан сервис пользователей');
try {
  await service.call({ userId: 123 });
} catch (error) {
  console.log('Ошибка:', error.message); // Требуется аутентификация
}

service.authenticate({ token: 'valid-token' });
await service.call({ userId: 123 }); // Теперь вызов пройдет успешно
```

## Преимущества фабрики-объектов

- **Инкапсуляция логики создания**: Вся логика создания объектов сосредоточена в одном месте
- **Гибкость**: Легко добавлять новые типы объектов без изменения клиентского кода
- **Конфигурируемость**: Возможность настройки параметров создания объектов
- **Повторное использование**: Одна фабрика может создавать множество объектов
- **Тестируемость**: Легко тестировать создание объектов отдельно от остального кода

## Недостатки фабрики-объектов

- **Сложность**: Может усложнить простые сценарии создания объектов
- **Централизация**: Все создание объектов проходит через один компонент
- **Зависимость**: Клиентский код зависит от фабрики

## Когда использовать фабрику-объектов

- При создании объектов с сложной инициализацией
- Когда нужно централизовать создание объектов
- При необходимости конфигурировать создаваемые объекты
- При работе с объектами, требующими валидации данных

## Ключевые выводы

- Фабрика-объектов - это объект, который отвечает за создание других объектов
- Она особенно полезна при работе со сложными объектами с требовательной инициализацией
- Паттерн улучшает модульность и поддерживаемость кода
- Можно расширять фабрики с помощью плагинов и других механизмов

## См. также

- [[Паттерн-фабрика]]
- [[Функция-фабрика]]
- [[Объекты]]
- [[Объектно-ориентированное программирование]]
- [[Композиция и агрегация]]

#javascript #объекты #фабрика #паттерны #oop #frontend