---
aliases: ["Функциональная фабрика", "Function Factory", "Factory Function"]
tags: [function, factory, javascript, functional-programming, patterns]
---

# Функция-фабрика

Функция-фабрика (Factory Function) - это функция, которая возвращает новый объект. В отличие от классов, функции-фабрики в JavaScript не требуют использования ключевого слова `new` и обеспечивают более гибкий способ создания объектов. Это один из ключевых паттернов функционального программирования в JavaScript.

## Обзор

Функция-фабрика - это просто функция, которая создает и возвращает объект. Она не использует прототипы или `new`, что делает её особенно подходящей для функционального стиля программирования. В JavaScript функции-фабрики часто предпочтительнее классов из-за их простоты и гибкости.

## Основная реализация

```javascript
// Простая функция-фабрика
function createUser(name, email) {
  return {
    name,
    email,
    isActive: true,
    login() {
      console.log(`${this.name} logged in`);
    },
    updateEmail(newEmail) {
      this.email = newEmail;
    }
  };
}

// Использование
const user1 = createUser('John', 'john@example.com');
const user2 = createUser('Jane', 'jane@example.com');

user1.login(); // John logged in
console.log(user1.email); // john@example.com
user2.updateEmail('jane.doe@example.com');
console.log(user2.email); // jane.doe@example.com
```

## Функция-фабрика с приватными методами

```javascript
// Функция-фабрика с приватными методами
function createCounter(initialValue = 0) {
  // Приватная переменная
  let count = initialValue;
  
  return {
    // Публичные методы
    increment() {
      count++;
      return this;
    },
    decrement() {
      count--;
      return this;
    },
    getValue() {
      return count;
    },
    reset() {
      count = initialValue;
      return this;
    }
  };
}

// Использование
const counter = createCounter(5);
console.log(counter.getValue()); // 5
counter.increment().increment();
console.log(counter.getValue()); // 7
counter.decrement();
console.log(counter.getValue()); // 6
```

## Функция-фабрика с замыканием

```javascript
// Функция-фабрика с замыканием для создания конфигурируемых валидаторов
function createValidator(validationRules) {
  return function(value) {
    const errors = [];
    
    for (const [ruleName, rule] of Object.entries(validationRules)) {
      if (!rule.test(value)) {
        errors.push(rule.message || `Validation failed for ${ruleName}`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  };
}

// Создание конкретных валидаторов
const emailValidator = createValidator({
  email: {
    test: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    message: 'Invalid email format'
  }
});

const passwordValidator = createValidator({
  minLength: {
    test: (value) => value.length >= 8,
    message: 'Password must be at least 8 characters'
  },
  hasNumber: {
    test: (value) => /\d/.test(value),
    message: 'Password must contain at least one number'
  }
});

// Использование
console.log(emailValidator('test@example.com')); // { isValid: true, errors: [] }
console.log(emailValidator('invalid-email'));    // { isValid: false, errors: ['Invalid email format'] }
console.log(passwordValidator('short'));         // { isValid: false, errors: ['Password must be at least 8 characters'] }
```

## Функция-фабрика с наследованием

```javascript
// Базовая функция-фабрика
function createShape(type, options = {}) {
  const shape = {
    type,
    color: options.color || 'black',
    x: options.x || 0,
    y: options.y || 0,
    draw() {
      console.log(`Drawing ${this.type} at (${this.x}, ${this.y})`);
    }
  };
  
  // Возвращаем объект с методами рендеринга
  return shape;
}

// Функция-фабрика для круга
function createCircle(options) {
  const circle = createShape('circle', options);
  
  // Добавляем специфичные свойства и методы
  circle.radius = options.radius || 10;
  circle.area = function() {
    return Math.PI * this.radius * this.radius;
  };
  
  return circle;
}

// Функция-фабрика для прямоугольника
function createRectangle(options) {
  const rect = createShape('rectangle', options);
  
  // Добавляем специфичные свойства и методы
  rect.width = options.width || 10;
  rect.height = options.height || 10;
  rect.area = function() {
    return this.width * this.height;
  };
  
  return rect;
}

// Использование
const circle = createCircle({ radius: 5, color: 'red', x: 10, y: 10 });
const rectangle = createRectangle({ width: 20, height: 15, color: 'blue', x: 5, y: 5 });

circle.draw(); // Drawing circle at (10, 10)
console.log(circle.area()); // 78.53981633974483

rectangle.draw(); // Drawing rectangle at (5, 5)
console.log(rectangle.area()); // 300
```

## Функция-фабрика в контексте компонентов

```javascript
// Функция-фабрика для создания компонентов формы
function createFormComponent(config) {
  const { 
    type = 'input', 
    label = '', 
    name = '', 
    value = '', 
    validation = null,
    onChange = () => {}
  } = config;
  
  let isValid = true;
  let errorMessage = '';
  
  return {
    type,
    label,
    name,
    value,
    validation,
    
    // Методы
    render() {
      const wrapper = document.createElement('div');
      wrapper.className = 'form-component';
      
      if (label) {
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        labelEl.htmlFor = name;
        wrapper.appendChild(labelEl);
      }
      
      const input = document.createElement(type === 'textarea' ? 'textarea' : 'input');
      input.type = type;
      input.name = name;
      input.value = value;
      input.id = name;
      
      // Добавляем обработчик изменения
      input.addEventListener('input', (e) => {
        this.setValue(e.target.value);
        onChange(e);
      });
      
      wrapper.appendChild(input);
      
      // Показываем ошибку валидации, если есть
      if (!isValid && errorMessage) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error';
        errorEl.textContent = errorMessage;
        wrapper.appendChild(errorEl);
      }
      
      return wrapper;
    },
    
    setValue(newValue) {
      this.value = newValue;
      
      // Проверяем валидацию
      if (validation) {
        const result = validation(newValue);
        isValid = result.isValid;
        errorMessage = result.errors.join(', ');
      }
    },
    
    getValue() {
      return this.value;
    },
    
    validate() {
      if (validation) {
        const result = validation(this.value);
        isValid = result.isValid;
        errorMessage = result.errors.join(', ');
        return result;
      }
      return { isValid: true, errors: [] };
    }
  };
}

// Использование
const emailValidation = (value) => {
  const errors = [];
  if (!value) {
    errors.push('Email is required');
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
    errors.push('Invalid email format');
  }
  return { isValid: errors.length === 0, errors };
};

const emailField = createFormComponent({
  type: 'input',
  label: 'Email',
  name: 'email',
  value: '',
  validation: emailValidation
});

// Использование в DOM (в реальном приложении)
// const formContainer = document.getElementById('form');
// formContainer.appendChild(emailField.render());
```

## Преимущества функций-фабрик

- **Простота**: Не требуют использования `new`, прототипов или классов
- **Гибкость**: Легко создавать объекты с различными свойствами и методами
- **Инкапсуляция**: Замыкания позволяют создавать приватные переменные и методы
- **Композиция**: Легко комбинировать разные функции-фабрики
- **Функциональный стиль**: Соответствует парадигме функционального программирования

## Недостатки функций-фабрик

- **Производительность**: Каждый объект имеет свою копию методов
- **Отсутствие наследования**: Не так просто реализовать классическое наследование
- **Меньше инструментов**: Меньше поддержки в IDE и инструментах по сравнению с классами

## Когда использовать функции-фабрики

- При создании простых объектов с небольшим количеством методов
- При необходимости инкапсуляции приватных данных
- При работе в функциональном стиле
- При создании конфигурируемых объектов

## Сравнение с классами

| Характеристика | Функция-фабрика | Класс |
|----------------|----------------|-------|
| Синтаксис | Простой | Более формальный |
| Приватные поля | Замыкания | `#` префикс |
| Наследование | Композиция | Классическое |
| Методы | Каждый объект имеет свою копию | Общие через прототип |
| Производительность | Ниже при большом количестве методов | Выше |

## Ключевые выводы

- Функция-фабрика - это функция, возвращающая объект
- В JavaScript функции-фабрики обеспечивают гибкость и инкапсуляцию
- Они особенно полезны в функциональном программировании
- Подходят для создания конфигурируемых и сложных объектов

## См. также

- [[Паттерн-фабрика]]
- [[Фабрика-компонентов]]
- [[Функциональное программирование]]
- [[Замыкания]]

#javascript #функции #фабрика #функциональное-программирование #frontend