---
aliases: [Тестирование удобства использования, Юзабилити-тестирование, Проверка удобства]
tags: [юзабилити, тестирование, ux, frontend, пользовательский-опыт]
---

# Тестирование юзабилити

## Определение

Тестирование юзабилити (usability testing) — это метод оценки удобства использования продукта, при котором реальные пользователи выполняют определенные задачи в контролируемой среде. Цель тестирования — выявить проблемы с интерфейсом и получить представление о том, насколько продукт соответствует ожиданиям и потребностям пользователей.

## Основные цели юзабилити-тестирования

### 1. Оценка эффективности
- Насколько быстро пользователи могут выполнять задачи
- Количество ошибок при выполнении задач
- Уровень удовлетворенности пользователя

### 2. Выявление проблем
- Непонятные элементы интерфейса
- Запутанная навигация
- Неочевидные функции

### 3. Проверка гипотез
- Подтверждение или опровержение предположений о пользовательском поведении
- Проверка эффективности новых функций
- Оценка влияния изменений интерфейса

## Методы юзабилити-тестирования

### 1. Тестирование с наблюдением

Классическое тестирование, при котором пользователь выполняет задачи под наблюдением исследователя:

```javascript
// Пример системы для проведения юзабилити-тестирования
class UsabilityTestSession {
  constructor(testScenario) {
    this.testScenario = testScenario;
    this.participant = null;
    this.tasks = testScenario.tasks;
    this.currentTaskIndex = 0;
    this.results = {
      taskCompletion: [],
      timeSpent: {},
      errors: {},
      satisfaction: {}
    };
    this.observations = [];
  }
  
  startSession(participant) {
    this.participant = participant;
    console.log(`Начата сессия юзабилити-тестирования для участника: ${participant.id}`);
    
    // Начинаем выполнение первой задачи
    this.startCurrentTask();
  }
  
  startCurrentTask() {
    if (this.currentTaskIndex >= this.tasks.length) {
      this.endSession();
      return;
    }
    
    const currentTask = this.tasks[this.currentTaskIndex];
    console.log(`Выполнение задачи: ${currentTask.description}`);
    
    // Начинаем отслеживание времени
    this.taskStartTime = Date.now();
    
    // В реальности здесь пользователь будет выполнять задачу
    // Мы симулируем выполнение
    this.simulateTaskExecution(currentTask);
  }
  
  simulateTaskExecution(task) {
    // Симуляция выполнения задачи пользователем
    setTimeout(() => {
      const completionResult = this.evaluateTaskCompletion(task);
      this.recordTaskResult(completionResult);
      
      this.currentTaskIndex++;
      this.startCurrentTask(); // Переход к следующей задаче
    }, 3000 + Math.random() * 5000); // Случайное время выполнения
  }
  
  evaluateTaskCompletion(task) {
    // Симуляция результата выполнения задачи
    const successRate = 0.8; // 80% успешных выполнений
    const isSuccess = Math.random() < successRate;
    
    return {
      taskId: task.id,
      success: isSuccess,
      time: Date.now() - this.taskStartTime,
      errors: isSuccess ? 0 : Math.floor(Math.random() * 3) + 1,
      difficulty: ['easy', 'medium', 'hard'][Math.floor(Math.random() * 3)]
    };
  }
  
  recordTaskResult(result) {
    this.results.taskCompletion.push(result);
    this.results.timeSpent[result.taskId] = result.time;
    this.results.errors[result.taskId] = result.errors;
    
    console.log(`Результат задачи ${result.taskId}:`, result);
  }
  
  recordSatisfaction(taskId, rating) {
    this.results.satisfaction[taskId] = rating;
  }
  
  addObservation(observation) {
    this.observations.push({
      timestamp: new Date(),
      observation: observation
    });
  }
  
  endSession() {
    console.log('Сессия юзабилити-тестирования завершена');
    console.log('Результаты:', this.getSummary());
  }
  
  getSummary() {
    const totalTasks = this.tasks.length;
    const completedTasks = this.results.taskCompletion.filter(r => r.success).length;
    const successRate = (completedTasks / totalTasks) * 100;
    
    const avgTime = Object.values(this.results.timeSpent).reduce((a, b) => a + b, 0) / totalTasks;
    const totalErrors = Object.values(this.results.errors).reduce((a, b) => a + b, 0);
    
    return {
      successRate: `${successRate.toFixed(2)}%`,
      avgTimePerTask: `${(avgTime / 1000).toFixed(2)} сек`,
      totalErrors: totalErrors,
      satisfactionAvg: this.calculateSatisfactionAverage()
    };
  }
  
  calculateSatisfactionAverage() {
    const satisfactionValues = Object.values(this.results.satisfaction);
    if (satisfactionValues.length === 0) return 'N/A';
    
    const avg = satisfactionValues.reduce((a, b) => a + b, 0) / satisfactionValues.length;
    return avg.toFixed(2);
  }
}

// Пример сценария тестирования
const testScenario = {
  name: 'Тестирование формы регистрации',
  description: 'Проверка удобства процесса регистрации нового пользователя',
  tasks: [
    {
      id: 'task-1',
      description: 'Найти и перейти на страницу регистрации',
      goal: 'Пользователь должен найти ссылку "Регистрация" и перейти по ней'
    },
    {
      id: 'task-2',
      description: 'Заполнить форму регистрации',
      goal: 'Пользователь должен заполнить все обязательные поля формы'
    },
    {
      id: 'task-3',
      description: 'Отправить форму и получить подтверждение',
      goal: 'Пользователь должен успешно отправить форму и получить сообщение об успехе'
    }
  ]
};

// Пример участника тестирования
const participant = {
  id: 'user-test-001',
  age: 28,
  techSavvy: 'high',
  experience: 'regular user'
};

// Проведение теста
const testSession = new UsabilityTestSession(testScenario);
testSession.startSession(participant);

// Симуляция добавления наблюдений
setTimeout(() => {
  testSession.addObservation('Пользователь колебался при выборе ссылки регистрации');
  testSession.addObservation('Форма показалась интуитивно понятной');
}, 2000);
</script>
```

### 2. A/B тестирование

Сравнение двух или более версий интерфейса:

```html
<!-- Пример A/B тестирования для кнопки -->
<div class="ab-test-container">
  <h2>Тестирование дизайна кнопки</h2>
  
  <!-- Версия A: Классический дизайн -->
  <div class="version-a" id="version-a">
    <h3>Версия A</h3>
    <button class="btn btn-version-a">Нажми меня</button>
  </div>
  
  <!-- Версия B: Современный дизайн -->
  <div class="version-b" id="version-b">
    <h3>Версия B</h3>
    <button class="btn btn-version-b">Нажми меня</button>
  </div>
</div>

<script>
class ABTestManager {
  constructor() {
    this.testId = 'button-design-test';
    this.variants = ['A', 'B'];
    this.currentVariant = this.assignVariant();
    this.impressions = 0;
    this.conversions = 0;
    
    this.initializeTest();
  }
  
  assignVariant() {
    // Рандомное присвоение варианта (50/50)
    return Math.random() > 0.5 ? 'A' : 'B';
  }
  
  initializeTest() {
    // Показываем только выбранный вариант
    document.querySelectorAll('.version-a, .version-b').forEach(el => {
      el.style.display = 'none';
    });
    
    document.getElementById(`version-${this.currentVariant.toLowerCase()}`).style.display = 'block';
    
    // Отслеживаем показ
    this.trackImpression();
    
    // Добавляем обработчики кликов
    const button = document.querySelector(`.btn-version-${this.currentVariant.toLowerCase()}`);
    button.addEventListener('click', () => {
      this.trackConversion();
    });
  }
  
  trackImpression() {
    this.impressions++;
    console.log(`Показ версии ${this.currentVariant}, всего: ${this.impressions}`);
    
    // В реальности отправляем данные на сервер
    this.sendAnalytics('impression', {
      testId: this.testId,
      variant: this.currentVariant,
      timestamp: new Date()
    });
  }
  
  trackConversion() {
    this.conversions++;
    console.log(`Конверсия версии ${this.currentVariant}, всего: ${this.conversions}`);
    
    // В реальности отправляем данные на сервер
    this.sendAnalytics('conversion', {
      testId: this.testId,
      variant: this.currentVariant,
      timestamp: new Date()
    });
  }
  
  sendAnalytics(eventType, data) {
    // В реальности отправляем на аналитический сервер
    console.log(`Отправка аналитики: ${eventType}`, data);
  }
  
  getResults() {
    const conversionRate = this.impressions > 0 ? (this.conversions / this.impressions) * 100 : 0;
    return {
      variant: this.currentVariant,
      impressions: this.impressions,
      conversions: this.conversions,
      conversionRate: `${conversionRate.toFixed(2)}%`
    };
  }
}

// Инициализация A/B теста
const abTest = new ABTestManager();

// Периодический вывод результатов
setInterval(() => {
  console.log('Результаты A/B теста:', abTest.getResults());
}, 10000);
</script>

<style>
.ab-test-container {
  display: flex;
  justify-content: space-around;
  align-items: flex-start;
  padding: 2rem;
  max-width: 800px;
  margin: 0 auto;
}

.version-a, .version-b {
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  width: 45%;
}

.btn {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.btn-version-a {
  background-color: #3498db;
  color: white;
}

.btn-version-a:hover {
  background-color: #2980b9;
}

.btn-version-b {
  background-color: #2ecc71;
  color: white;
  border-radius: 20px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.btn-version-b:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.2);
}
</style>
```

### 3. Тестирование на мобильных устройствах

```html
<!-- Компонент для тестирования мобильного интерфейса -->
<div class="mobile-usability-tester">
  <h2>Тестирование мобильного интерфейса</h2>
  
  <div class="mobile-frame">
    <div class="mobile-content">
      <form class="mobile-form" id="mobile-form">
        <div class="form-group">
          <label for="mobile-email">Email</label>
          <input 
            type="email" 
            id="mobile-email" 
            name="email" 
            class="mobile-input"
            required
          >
        </div>
        
        <div class="form-group">
          <label for="mobile-password">Пароль</label>
          <input 
            type="password" 
            id="mobile-password" 
            name="password" 
            class="mobile-input"
            required
          >
        </div>
        
        <button type="submit" class="mobile-btn">Войти</button>
      </form>
    </div>
  </div>
  
  <div class="test-results" id="test-results">
    <h3>Результаты тестирования:</h3>
    <ul id="results-list"></ul>
  </div>
</div>

<script>
class MobileUsabilityTester {
  constructor() {
    this.testResults = [];
    this.tapTargets = [];
    this.init();
  }
  
  init() {
    this.setupFormValidation();
    this.analyzeTapTargets();
    this.setupTouchTracking();
  }
  
  setupFormValidation() {
    const form = document.getElementById('mobile-form');
    
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      
      const formData = new FormData(form);
      const isValid = this.validateFormData(formData);
      
      if (isValid) {
        this.recordTestResult('form_submission', 'success', 'Форма успешно отправлена');
      } else {
        this.recordTestResult('form_submission', 'error', 'Ошибка валидации формы');
      }
    });
  }
  
  validateFormData(formData) {
    const email = formData.get('email');
    const password = formData.get('password');
    
    // Простая валидация
    const isValidEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    const isValidPassword = password.length >= 6;
    
    return isValidEmail && isValidPassword;
  }
  
  analyzeTapTargets() {
    // Анализ размеров целевых областей для касания
    const tapTargets = document.querySelectorAll('input, button, select, textarea, a');
    
    tapTargets.forEach((target, index) => {
      const rect = target.getBoundingClientRect();
      const size = {
        width: rect.width,
        height: rect.height,
        area: rect.width * rect.height
      };
      
      // Рекомендуемый размер: не менее 44x44 пикселей
      const isAdequateSize = size.width >= 44 && size.height >= 44;
      
      this.tapTargets.push({
        element: target.tagName.toLowerCase(),
        id: target.id || `element-${index}`,
        size: size,
        adequate: isAdequateSize,
        position: { x: rect.left, y: rect.top }
      });
      
      if (!isAdequateSize) {
        this.recordTestResult(
          'tap_target_size', 
          'warning', 
          `Маленькая целевая область: ${target.tagName} с ID "${target.id}"`
        );
      }
    });
  }
  
  setupTouchTracking() {
    // Отслеживание жестов и взаимодействий
    const touchableElements = document.querySelectorAll('input, button, select, textarea, a');
    
    touchableElements.forEach(element => {
      element.addEventListener('touchstart', (e) => {
        this.recordTouchStart(element, e);
      });
      
      element.addEventListener('touchend', (e) => {
        this.recordTouchEnd(element, e);
      });
    });
  }
  
  recordTouchStart(element, event) {
    const touch = event.touches[0];
    this.currentTouch = {
      element: element,
      startTime: Date.now(),
      startX: touch.clientX,
      startY: touch.clientY
    };
  }
  
  recordTouchEnd(element, event) {
    if (!this.currentTouch) return;
    
    const touch = event.changedTouches[0];
    const endTime = Date.now();
    const duration = endTime - this.currentTouch.startTime;
    
    // Проверяем, был ли это клик или жест
    const distance = Math.sqrt(
      Math.pow(touch.clientX - this.currentTouch.startX, 2) +
      Math.pow(touch.clientY - this.currentTouch.startY, 2)
    );
    
    if (distance < 10 && duration < 1000) { // Скорее всего клик
      this.recordTestResult(
        'tap_execution', 
        'success', 
        `Успешный тап по элементу: ${element.tagName}`
      );
    } else { // Скорее всего жест
      this.recordTestResult(
        'gesture', 
        'info', 
        `Жест по элементу: ${element.tagName}, дистанция: ${distance.toFixed(2)}px`
      );
    }
    
    this.currentTouch = null;
  }
  
  recordTestResult(type, level, message) {
    const result = {
      type: type,
      level: level, // success, error, warning, info
      message: message,
      timestamp: new Date()
    };
    
    this.testResults.push(result);
    this.displayResult(result);
  }
  
  displayResult(result) {
    const resultsList = document.getElementById('results-list');
    const listItem = document.createElement('li');
    listItem.className = `result-item result-${result.level}`;
    listItem.textContent = `[${result.timestamp.toLocaleTimeString()}] ${result.message}`;
    
    resultsList.appendChild(listItem);
  }
  
  getAccessibilityScore() {
    // Простой подсчет проблем доступности
    const issues = this.testResults.filter(r => r.level === 'error' || r.level === 'warning');
    const score = Math.max(0, 100 - (issues.length * 10)); // 10 баллов за каждую проблему
    
    return {
      score: score,
      totalIssues: issues.length,
      issueBreakdown: {
        tapTargets: this.testResults.filter(r => r.type === 'tap_target_size').length,
        formErrors: this.testResults.filter(r => r.type === 'form_submission').length,
        other: issues.length - 
               this.testResults.filter(r => r.type === 'tap_target_size').length - 
               this.testResults.filter(r => r.type === 'form_submission').length
      }
    };
  }
  
  generateReport() {
    const score = this.getAccessibilityScore();
    const report = {
      timestamp: new Date(),
      totalTests: this.testResults.length,
      accessibilityScore: score,
      tapTargetAnalysis: this.tapTargets,
      recommendations: this.generateRecommendations()
    };
    
    console.log('Отчет о мобильном юзабилити:', report);
    return report;
  }
  
  generateRecommendations() {
    const recommendations = [];
    
    // Рекомендации на основе результатов тестирования
    const smallTapTargets = this.tapTargets.filter(t => !t.adequate);
    if (smallTapTargets.length > 0) {
      recommendations.push(
        `Увеличьте размер ${smallTapTargets.length} целевых областей до минимального 44x44 пикселей`
      );
    }
    
    const formErrors = this.testResults.filter(r => r.type === 'form_submission' && r.level === 'error');
    if (formErrors.length > 0) {
      recommendations.push('Улучшите валидацию и обратную связь в формах');
    }
    
    return recommendations;
  }
}

// Инициализация мобильного тестера
const mobileTester = new MobileUsabilityTester();

// Генерация отчета каждые 30 секунд
setInterval(() => {
  mobileTester.generateReport();
}, 30000);
</script>

<style>
.mobile-usability-tester {
  padding: 1rem;
  max-width: 1000px;
  margin: 0 auto;
}

.mobile-frame {
  width: 375px;
  height: 667px;
  border: 10px solid #333;
  border-radius: 40px;
  margin: 0 auto;
  overflow: hidden;
  position: relative;
  background: white;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.mobile-content {
  height: 100%;
  padding: 1rem;
  overflow-y: auto;
}

.mobile-form {
  width: 100%;
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.mobile-input {
  width: 100%;
  padding: 1rem;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 1rem;
  box-sizing: border-box;
}

.mobile-input:focus {
  border-color: #3498db;
  outline: none;
}

.mobile-btn {
  width: 100%;
  padding: 1rem;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1.1rem;
  cursor: pointer;
}

.mobile-btn:hover {
  background-color: #2980b9;
}

.test-results {
  margin-top: 2rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 8px;
}

.result-item {
  padding: 0.5rem 0;
  border-bottom: 1px solid #eee;
}

.result-success { color: #27ae60; }
.result-error { color: #e74c3c; }
.result-warning { color: #f39c12; }
.result-info { color: #3498db; }
</style>
```

## Инструменты для юзабилити-тестирования

### 1. Heatmap-анализ

```javascript
// Пример системы Heatmap для анализа взаимодействия
class HeatmapAnalyzer {
  constructor() {
    this.clickData = [];
    this.mouseMoveData = [];
    this.scrollData = [];
    
    this.initTracking();
  }
  
  initTracking() {
    // Отслеживание кликов
    document.addEventListener('click', (e) => {
      this.recordClick(e.clientX, e.clientY);
    });
    
    // Отслеживание движения мыши (упрощенное)
    let mouseMoveTimeout;
    document.addEventListener('mousemove', (e) => {
      clearTimeout(mouseMoveTimeout);
      mouseMoveTimeout = setTimeout(() => {
        this.recordMouseMove(e.clientX, e.clientY);
      }, 100); // Записываем каждые 100мс
    });
    
    // Отслеживание прокрутки
    window.addEventListener('scroll', () => {
      this.recordScroll(window.scrollY);
    });
  }
  
  recordClick(x, y) {
    this.clickData.push({
      x: x,
      y: y,
      timestamp: new Date(),
      pageX: window.pageXOffset,
      pageY: window.pageYOffset
    });
    
    this.visualizeClick(x, y);
  }
  
  recordMouseMove(x, y) {
    this.mouseMoveData.push({
      x: x,
      y: y,
      timestamp: new Date()
    });
  }
  
  recordScroll(scrollY) {
    this.scrollData.push({
      position: scrollY,
      timestamp: new Date()
    });
  }
  
  visualizeClick(x, y) {
    // Создание визуального индикатора клика
    const clickIndicator = document.createElement('div');
    clickIndicator.className = 'click-indicator';
    clickIndicator.style.position = 'absolute';
    clickIndicator.style.left = `${x - 10}px`;
    clickIndicator.style.top = `${y - 10}px`;
    clickIndicator.style.width = '20px';
    clickIndicator.style.height = '20px';
    clickIndicator.style.borderRadius = '50%';
    clickIndicator.style.backgroundColor = 'rgba(231, 76, 60, 0.7)';
    clickIndicator.style.pointerEvents = 'none';
    clickIndicator.style.zIndex = '9999';
    clickIndicator.style.animation = 'clickPulse 0.5s ease-out';
    
    document.body.appendChild(clickIndicator);
    
    // Удаление индикатора через 0.5 секунды
    setTimeout(() => {
      document.body.removeChild(clickIndicator);
    }, 500);
  }
  
  generateHeatmap() {
    // Простой алгоритм генерации heatmap
    const heatmapData = this.clickData.reduce((acc, click) => {
      const key = `${Math.floor(click.x / 50)}_${Math.floor(click.y / 50)}`; // Группировка по 50px
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {});
    
    return heatmapData;
  }
  
  getInteractionReport() {
    const totalClicks = this.clickData.length;
    const totalMouseMoves = this.mouseMoveData.length;
    const scrollDepth = this.scrollData.length > 0 ? 
      Math.max(...this.scrollData.map(s => s.position)) : 0;
    
    // Вычисление самых активных зон
    const heatmap = this.generateHeatmap();
    const hotspots = Object.entries(heatmap)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5); // Топ 5 самых активных зон
    
    return {
      totalClicks,
      totalMouseMoves,
      scrollDepth,
      hotspots,
      engagementMetrics: this.calculateEngagementMetrics()
    };
  }
  
  calculateEngagementMetrics() {
    // Расчет метрик вовлеченности
    const duration = this.calculateSessionDuration();
    const clicksPerMinute = duration > 0 ? 
      (this.clickData.length / (duration / 60000)).toFixed(2) : 0;
    
    // Оценка активности на основе частоты взаимодействий
    const activityLevel = clicksPerMinute > 5 ? 'high' : 
                         clicksPerMinute > 2 ? 'medium' : 'low';
    
    return {
      sessionDuration: duration,
      clicksPerMinute: parseFloat(clicksPerMinute),
      activityLevel: activityLevel
    };
  }
  
  calculateSessionDuration() {
    if (this.clickData.length === 0) return 0;
    
    const firstEvent = new Date(Math.min(
      ...this.clickData.map(c => new Date(c.timestamp))
    ));
    const lastEvent = new Date(Math.max(
      ...this.clickData.map(c => new Date(c.timestamp))
    ));
    
    return lastEvent - firstEvent; // в миллисекундах
  }
}

// Инициализация heatmap-анализатора
const heatmapAnalyzer = new HeatmapAnalyzer();

// Периодический вывод отчета
setInterval(() => {
  console.log('Отчет Heatmap-анализа:', heatmapAnalyzer.getInteractionReport());
}, 15000);

// Добавление стилей для визуализации кликов
const heatmapStyles = document.createElement('style');
heatmapStyles.textContent = `
  @keyframes clickPulse {
    0% { transform: scale(0.1); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
  }
`;
document.head.appendChild(heatmapStyles);
</script>
```

### 2. Тестирование с экранного диктора

```html
<!-- Компонент для тестирования с использованием скринридера -->
<div class="screen-reader-test">
  <h2>Тестирование с экранного диктора</h2>
  
  <div class="sr-test-content">
    <nav aria-label="Основная навигация">
      <ul>
        <li><a href="#home" tabindex="0">Главная</a></li>
        <li><a href="#products" tabindex="0">Продукты</a></li>
        <li><a href="#services" tabindex="0">Услуги</a></li>
        <li><a href="#about" tabindex="0">О нас</a></li>
      </ul>
    </nav>
    
    <main>
      <section id="home" tabindex="-1">
        <h1>Добро пожаловать на наш сайт</h1>
        <p>Это пример контента для тестирования с использованием скринридера.</p>
        <button id="cta-button" aria-describedby="cta-description">Начать</button>
        <div id="cta-description" class="sr-only">Кнопка для начала использования сервиса</div>
      </section>
      
      <section id="products" tabindex="-1">
        <h2>Наши продукты</h2>
        <ul>
          <li>Продукт 1 - описание продукта</li>
          <li>Продукт 2 - описание продукта</li>
          <li>Продукт 3 - описание продукта</li>
        </ul>
      </section>
    </main>
  </div>
  
  <div class="sr-test-results">
    <h3>Результаты тестирования:</h3>
    <ul id="sr-results-list"></ul>
  </div>
</div>

<script>
class ScreenReaderTester {
  constructor() {
    this.testResults = [];
    this.focusHistory = [];
    this.ariaIssues = [];
    
    this.init();
  }
  
  init() {
    this.setupFocusTracking();
    this.checkAriaCompliance();
    this.testKeyboardNavigation();
  }
  
  setupFocusTracking() {
    // Отслеживание фокуса на элементах
    document.addEventListener('focusin', (e) => {
      this.recordFocus(e.target);
    });
  }
  
  recordFocus(element) {
    const focusRecord = {
      element: element.tagName.toLowerCase(),
      id: element.id || 'no-id',
      className: element.className || 'no-class',
      tabIndex: element.getAttribute('tabindex'),
      timestamp: new Date()
    };
    
    this.focusHistory.push(focusRecord);
    
    // Проверка, является ли элемент доступным для скринридера
    if (this.isScreenReaderAccessible(element)) {
      this.recordTestResult('focus_accessibility', 'success', 
        `Элемент ${element.tagName} доступен для скринридера`);
    } else {
      this.recordTestResult('focus_accessibility', 'warning', 
        `Элемент ${element.tagName} может быть недоступен для скринридера`);
    }
  }
  
  isScreenReaderAccessible(element) {
    // Проверка доступности элемента для скринридера
    const isHidden = element.hidden || 
                    element.style.display === 'none' || 
                    element.style.visibility === 'hidden' ||
                    element.getAttribute('aria-hidden') === 'true';
    
    const hasTabIndex = element.getAttribute('tabindex') !== null;
    const hasAriaLabel = element.getAttribute('aria-label') || 
                        element.getAttribute('aria-labelledby');
    
    return !isHidden || hasAriaLabel || hasTabIndex;
  }
  
  checkAriaCompliance() {
    // Проверка использования ARIA-атрибутов
    const ariaElements = document.querySelectorAll('[role], [aria-*]');
    
    ariaElements.forEach(element => {
      const role = element.getAttribute('role');
      const ariaAttrs = Array.from(element.attributes)
        .filter(attr => attr.name.startsWith('aria-'))
        .map(attr => attr.name);
      
      if (role) {
        this.validateRole(element, role);
      }
      
      ariaAttrs.forEach(attr => {
        this.validateAriaAttribute(element, attr);
      });
    });
  }
  
  validateRole(element, role) {
    // Простая валидация ролей (в реальности использовать полную спецификацию ARIA)
    const validRoles = [
      'button', 'link', 'main', 'navigation', 'banner', 'contentinfo',
      'complementary', 'region', 'form', 'search', 'alert', 'dialog'
    ];
    
    if (!validRoles.includes(role)) {
      this.recordTestResult('aria_role', 'error', 
        `Недопустимая роль ARIA "${role}" для элемента ${element.tagName}`);
    } else {
      this.recordTestResult('aria_role', 'success', 
        `Допустимая роль ARIA "${role}" для элемента ${element.tagName}`);
    }
  }
  
  validateAriaAttribute(element, attr) {
    // Простая валидация атрибутов ARIA
    const validAttrs = [
      'aria-label', 'aria-labelledby', 'aria-describedby', 'aria-hidden',
      'aria-live', 'aria-atomic', 'aria-relevant', 'aria-busy',
      'aria-expanded', 'aria-controls', 'aria-haspopup', 'aria-pressed'
    ];
    
    if (!validAttrs.includes(attr)) {
      this.recordTestResult('aria_attribute', 'error', 
        `Недопустимый атрибут ARIA "${attr}" для элемента ${element.tagName}`);
    }
  }
  
  testKeyboardNavigation() {
    // Проверка логичного порядка фокуса
    const focusableElements = Array.from(
      document.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])')
    );
    
    // Проверка, что все интерактивные элементы доступны через Tab
    focusableElements.forEach((element, index) => {
      if (element.getAttribute('tabindex') === '-1') {
        this.recordTestResult('keyboard_navigation', 'info', 
          `Элемент ${element.tagName} исключен из порядка табуляции`);
      }
    });
    
    // Проверка видимости фокуса
    this.checkFocusVisibility(focusableElements);
  }
  
  checkFocusVisibility(elements) {
    elements.forEach(element => {
      // В реальности проверять стили фокуса
      const hasFocusStyle = window.getComputedStyle(element).outline !== 'none';
      
      if (!hasFocusStyle) {
        this.recordTestResult('focus_visibility', 'warning', 
          `Элемент ${element.tagName} не имеет видимого стиля фокуса`);
      }
    });
  }
  
  recordTestResult(type, level, message) {
    const result = {
      type: type,
      level: level, // success, error, warning, info
      message: message,
      timestamp: new Date()
    };
    
    this.testResults.push(result);
    this.displayResult(result);
  }
  
  displayResult(result) {
    const resultsList = document.getElementById('sr-results-list');
    const listItem = document.createElement('li');
    listItem.className = `result-item result-${result.level}`;
    listItem.textContent = `[${result.timestamp.toLocaleTimeString()}] ${result.message}`;
    
    resultsList.appendChild(listItem);
  }
  
  getAccessibilityReport() {
    const report = {
      totalResults: this.testResults.length,
      focusHistory: this.focusHistory,
      ariaIssues: this.ariaIssues,
      complianceSummary: this.calculateCompliance()
    };
    
    return report;
  }
  
  calculateCompliance() {
    const totalTests = this.testResults.length;
    if (totalTests === 0) return { score: 0, breakdown: {} };
    
    const errors = this.testResults.filter(r => r.level === 'error').length;
    const warnings = this.testResults.filter(r => r.level === 'warning').length;
    const successes = this.testResults.filter(r => r.level === 'success').length;
    
    const score = Math.max(0, 100 - (errors * 10) - (warnings * 3));
    
    return {
      score: score,
      breakdown: {
        errors: errors,
        warnings: warnings,
        successes: successes
      }
    };
  }
}

// Инициализация тестера скринридера
const srTester = new ScreenReaderTester();

// Периодический вывод отчета
setInterval(() => {
  console.log('Отчет тестирования скринридера:', srTester.getAccessibilityReport());
}, 20000);
</script>

<style>
.screen-reader-test {
  padding: 1rem;
  max-width: 800px;
  margin: 0 auto;
}

.sr-test-content {
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  margin-bottom: 1rem;
}

.sr-test-content nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
}

.sr-test-content nav a {
  padding: 0.5rem 1rem;
  text-decoration: none;
  background-color: #f8f9fa;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.sr-test-content nav a:focus {
  background-color: #e9ecef;
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

.sr-test-content section {
  padding: 1rem;
  border: 1px solid #eee;
  border-radius: 4px;
  margin-bottom: 1rem;
}

.sr-test-content button {
  padding: 0.5rem 1rem;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.sr-test-content button:focus {
  outline: 2px solid #0056b3;
  outline-offset: 2px;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.sr-test-results {
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 8px;
}

.result-item {
  padding: 0.5rem 0;
  border-bottom: 1px solid #eee;
}

.result-success { color: #27ae60; }
.result-error { color: #e74c3c; }
.result-warning { color: #f39c12; }
.result-info { color: #3498db; }
</style>
```

## Практические рекомендации для фронтенд-разработчиков

### 1. Раннее тестирование

```javascript
// Пример системы автоматического юзабилити-тестирования
class AutomatedUsabilityTester {
  constructor() {
    this.testResults = [];
    this.checks = [
      this.checkFormLabels,
      this.checkAltText,
      this.checkLinkText,
      this.checkColorContrast,
      this.checkFocusIndicators
    ];
  }
  
  runAutomatedTests() {
    console.log('Запуск автоматического юзабилити-тестирования...');
    
    this.checks.forEach(check => {
      try {
        check.call(this);
      } catch (error) {
        console.error('Ошибка при выполнении проверки:', error);
      }
    });
    
    return this.testResults;
  }
  
  checkFormLabels() {
    const inputs = document.querySelectorAll('input, textarea, select');
    
    inputs.forEach(input => {
      const hasLabel = this.hasAssociatedLabel(input);
      
      if (!hasLabel) {
        this.recordIssue(
          'form_label',
          'error',
          `Поле ввода ${input.tagName} не имеет связанной метки`,
          input
        );
      } else {
        this.recordIssue(
          'form_label',
          'success',
          `Поле ввода ${input.tagName} имеет связанную метку`,
          input
        );
      }
    });
  }
  
  hasAssociatedLabel(element) {
    // Проверка наличия связанной метки
    const id = element.id;
    
    if (id) {
      const associatedLabel = document.querySelector(`label[for="${id}"]`);
      if (associatedLabel) return true;
    }
    
    // Проверка, является ли элемент потомком метки
    let parent = element.parentElement;
    while (parent) {
      if (parent.tagName === 'LABEL') return true;
      parent = parent.parentElement;
    }
    
    return false;
  }
  
  checkAltText() {
    const images = document.querySelectorAll('img');
    
    images.forEach(img => {
      const alt = img.getAttribute('alt');
      
      if (!alt) {
        this.recordIssue(
          'alt_text',
          'error',
          `Изображение не имеет атрибута alt`,
          img
        );
      } else if (alt.trim() === '') {
        this.recordIssue(
          'alt_text',
          'warning',
          `Изображение имеет пустой атрибут alt`,
          img
        );
      } else {
        this.recordIssue(
          'alt_text',
          'success',
          `Изображение имеет атрибут alt: "${alt}"`,
          img
        );
      }
    });
  }
  
  checkLinkText() {
    const links = document.querySelectorAll('a');
    
    links.forEach(link => {
      const text = link.textContent.trim();
      const ariaLabel = link.getAttribute('aria-label');
      
      // Проверка общего текста ссылки
      const genericTexts = ['кликните здесь', 'читать далее', 'подробнее'];
      const isGeneric = genericTexts.some(generic => text.toLowerCase().includes(generic));
      
      if (isGeneric) {
        this.recordIssue(
          'link_text',
          'warning',
          `Ссылка использует общий текст: "${text}"`,
          link
        );
      } else if (text.length < 2) {
        this.recordIssue(
          'link_text',
          'warning',
          `Ссылка имеет слишком короткий текст: "${text}"`,
          link
        );
      } else {
        this.recordIssue(
          'link_text',
          'success',
          `Ссылка имеет описательный текст: "${text}"`,
          link
        );
      }
    });
  }
  
  checkColorContrast() {
    const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, div, a, li');
    
    textElements.forEach(element => {
      const computedStyle = window.getComputedStyle(element);
      const bgColor = this.getBackgroundColor(element);
      const textColor = this.getTextColor(element);
      
      const contrastRatio = this.calculateContrastRatio(bgColor, textColor);
      
      if (contrastRatio < 4.5) {
        this.recordIssue(
          'color_contrast',
          'error',
          `Недостаточный контраст текста (${contrastRatio.toFixed(2)})`,
          element
        );
      } else {
        this.recordIssue(
          'color_contrast',
          'success',
          `Достаточный контраст текста (${contrastRatio.toFixed(2)})`,
          element
        );
      }
    });
  }
  
  getBackgroundColor(element) {
    let currentElement = element;
    let bgColor;
    
    do {
      bgColor = window.getComputedStyle(currentElement).backgroundColor;
      if (bgColor !== 'transparent' && bgColor !== 'rgba(0, 0, 0, 0)') {
        break;
      }
      currentElement = currentElement.parentElement;
    } while (currentElement);
    
    return bgColor || 'rgb(255, 255, 255)';
  }
  
  getTextColor(element) {
    return window.getComputedStyle(element).color;
  }
  
  calculateContrastRatio(bgColor, textColor) {
    // Преобразование цветов в RGB
    const bgRGB = this.parseColor(bgColor);
    const textRGB = this.parseColor(textColor);
    
    // Вычисление относительной яркости
    const bgLuminance = this.relativeLuminance(bgRGB);
    const textLuminance = this.relativeLuminance(textRGB);
    
    // Вычисление коэффициента контраста
    const lighter = Math.max(bgLuminance, textLuminance);
    const darker = Math.min(bgLuminance, textLuminance);
    
    return (lighter + 0.05) / (darker + 0.05);
  }
  
  parseColor(colorStr) {
    // Простой парсер цветов (в реальности использовать более полный парсер)
    if (colorStr.startsWith('rgb')) {
      const match = colorStr.match(/\d+/g);
      return {
        r: parseInt(match[0]),
        g: parseInt(match[1]),
        b: parseInt(match[2])
      };
    }
    
    // Для простоты возвращаем белый цвет
    return { r: 255, g: 255, b: 255 };
  }
  
  relativeLuminance(color) {
    const [r, g, b] = [color.r, color.g, color.b].map(c => {
      c = c / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
  
  checkFocusIndicators() {
    const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex]');
    
    focusableElements.forEach(element => {
      const outline = window.getComputedStyle(element).outline;
      
      if (outline === 'none' || outline === '0px none rgb(0, 0, 0)') {
        this.recordIssue(
          'focus_indicator',
          'error',
          `Элемент не имеет видимого индикатора фокуса`,
          element
        );
      } else {
        this.recordIssue(
          'focus_indicator',
          'success',
          `Элемент имеет индикатор фокуса`,
          element
        );
      }
    });
  }
  
  recordIssue(type, level, message, element) {
    const issue = {
      type: type,
      level: level,
      message: message,
      element: {
        tagName: element.tagName,
        id: element.id,
        className: element.className
      },
      timestamp: new Date()
    };
    
    this.testResults.push(issue);
  }
  
  generateReport() {
    const report = {
      timestamp: new Date(),
      totalIssues: this.testResults.length,
      breakdown: {
        errors: this.testResults.filter(r => r.level === 'error').length,
        warnings: this.testResults.filter(r => r.level === 'warning').length,
        successes: this.testResults.filter(r => r.level === 'success').length
      },
      issues: this.testResults.filter(r => r.level !== 'success')
    };
    
    return report;
  }
}

// Использование автоматического тестера
const autoTester = new AutomatedUsabilityTester();
const results = autoTester.runAutomatedTests();

console.log('Результаты автоматического юзабилити-тестирования:', autoTester.generateReport());
</style>
```

## Связанные концепции

- [[UX-дизайн]] - общие принципы пользовательского опыта
- [[Исследование-пользователей]] - понимание потребностей пользователей
- [[UI-дизайн]] - визуальное оформление интерфейса
- [[доступность]] - обеспечение доступности для всех пользователей
- [[обратная-связь]] - информирование пользователя о результатах действий
- [[Тестирование-компонентов]] - проверка отдельных компонентов интерфейса

## Заключение

Тестирование юзабилити является критически важным этапом разработки пользовательских интерфейсов. Фронтенд-разработчики должны регулярно проводить такие тестирования, чтобы выявлять и устранять проблемы удобства использования. Комбинация ручного тестирования, автоматических проверок и аналитики позволяет создавать более удобные и эффективные интерфейсы для пользователей.