---
aliases: [Персонализация интерфейса, Адаптивный интерфейс, Индивидуальные настройки]
tags: [персонализация, ux, frontend, пользовательский-опыт]
---

# Персонализация

## Определение

Персонализация — это процесс адаптации пользовательского интерфейса и функциональности продукта под индивидуальные предпочтения, поведение и потребности конкретного пользователя. Это позволяет создать более релевантный и удобный опыт для каждого пользователя.

## Основные принципы персонализации

### 1. Индивидуальный подход
- Адаптация контента под интересы пользователя
- Учет предыдущего поведения и предпочтений
- Персонализированные рекомендации

### 2. Контроль со стороны пользователя
- Возможность настройки предпочтений
- Прозрачность в использовании данных
- Управление уровнями персонализации

### 3. Контекстуальная релевантность
- Учет времени суток, дня недели
- Геолокация и местоположение
- Тип устройства и соединение

## Техники персонализации

### 1. Адаптивный интерфейс

```javascript
// Пример системы персонализации интерфейса
class PersonalizationEngine {
  constructor() {
    this.userPreferences = this.loadUserPreferences();
    this.behavioralData = this.loadBehavioralData();
    this.context = this.getContext();
  }
  
  loadUserPreferences() {
    // Загрузка предпочтений пользователя из localStorage или API
    const savedPrefs = localStorage.getItem('userPreferences');
    return savedPrefs ? JSON.parse(savedPrefs) : {
      theme: 'light',
      language: 'ru',
      fontSize: 'medium',
      layout: 'standard',
      notifications: true,
      privacy: 'standard'
    };
  }
  
  loadBehavioralData() {
    // Загрузка данных о поведении пользователя
    const savedBehavior = localStorage.getItem('userBehavior');
    return savedBehavior ? JSON.parse(savedBehavior) : {
      visitedPages: [],
      interactionHistory: [],
      preferredFeatures: [],
      usageTime: { morning: 0, afternoon: 0, evening: 0 }
    };
  }
  
  getContext() {
    // Сбор текущего контекста пользователя
    return {
      time: new Date(),
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      device: this.getDeviceType(),
      location: this.getLocation(),
      connection: this.getConnectionSpeed()
    };
  }
  
  getDeviceType() {
    const width = window.innerWidth;
    if (width < 768) return 'mobile';
    if (width < 1024) return 'tablet';
    return 'desktop';
  }
  
  getLocation() {
    // В реальности использовать геолокацию с разрешения пользователя
    return { lat: 55.7558, lng: 37.6173, city: 'Москва' }; // Пример для Москвы
  }
  
  getConnectionSpeed() {
    // Определение скорости соединения (упрощенно)
    return navigator.connection ? navigator.connection.effectiveType : '4g';
  }
  
  applyPersonalization() {
    // Применение персонализации к интерфейсу
    this.applyTheme();
    this.applyLanguage();
    this.applyLayout();
    this.updateContentBasedOnPreferences();
    this.showPersonalizedRecommendations();
  }
  
  applyTheme() {
    const theme = this.userPreferences.theme;
    document.body.classList.remove('light-theme', 'dark-theme', 'high-contrast-theme');
    document.body.classList.add(`${theme}-theme`);
    
    // Обновление цветовой схемы
    this.updateColorScheme(theme);
  }
  
  updateColorScheme(theme) {
    const root = document.documentElement;
    
    if (theme === 'dark') {
      root.style.setProperty('--primary-color', '#3498db');
      root.style.setProperty('--background-color', '#2c3e50');
      root.style.setProperty('--text-color', '#ecf0f1');
      root.style.setProperty('--surface-color', '#34495e');
    } else if (theme === 'high-contrast') {
      root.style.setProperty('--primary-color', '#000000');
      root.style.setProperty('--background-color', '#ffffff');
      root.style.setProperty('--text-color', '#000000');
      root.style.setProperty('--surface-color', '#ffffff');
    } else {
      // light theme (default)
      root.style.setProperty('--primary-color', '#3498db');
      root.style.setProperty('--background-color', '#ffffff');
      root.style.setProperty('--text-color', '#2c3e50');
      root.style.setProperty('--surface-color', '#f8f9fa');
    }
  }
  
  applyLanguage() {
    // Установка языка интерфейса
    document.documentElement.lang = this.userPreferences.language;
    
    // Обновление текстов интерфейса
    this.updateInterfaceTexts();
  }
  
  updateInterfaceTexts() {
    // Обновление текстов на основе выбранного языка
    const language = this.userPreferences.language;
    const translations = this.getTranslations(language);
    
    // Обновление элементов с data-i18n атрибутами
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      const translation = translations[key];
      
      if (translation) {
        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
          element.placeholder = translation;
        } else {
          element.textContent = translation;
        }
      }
    });
  }
  
  getTranslations(language) {
    // Простая система локализации (в реальности использовать полноценный i18n фреймворк)
    const translations = {
      ru: {
        welcome: 'Добро пожаловать',
        settings: 'Настройки',
        profile: 'Профиль',
        notifications: 'Уведомления',
        search_placeholder: 'Поиск...'
      },
      en: {
        welcome: 'Welcome',
        settings: 'Settings',
        profile: 'Profile',
        notifications: 'Notifications',
        search_placeholder: 'Search...'
      }
    };
    
    return translations[language] || translations.ru;
  }
  
  applyLayout() {
    const layout = this.userPreferences.layout;
    document.body.classList.remove('standard-layout', 'compact-layout', 'spacious-layout');
    document.body.classList.add(`${layout}-layout`);
    
    // Обновление структуры интерфейса
    this.updateLayout(layout);
  }
  
  updateLayout(layout) {
    // Настройка интерфейса в зависимости от предпочтений пользователя
    const layoutStyles = {
      compact: {
        '--font-size': '14px',
        '--line-height': '1.4',
        '--spacing': '8px',
        '--element-height': '32px'
      },
      spacious: {
        '--font-size': '18px',
        '--line-height': '1.6',
        '--spacing': '20px',
        '--element-height': '48px'
      },
      standard: {
        '--font-size': '16px',
        '--line-height': '1.5',
        '--spacing': '12px',
        '--element-height': '40px'
      }
    };
    
    const styles = layoutStyles[layout] || layoutStyles.standard;
    const root = document.documentElement;
    
    Object.entries(styles).forEach(([prop, value]) => {
      root.style.setProperty(prop, value);
    });
  }
  
  updateContentBasedOnPreferences() {
    // Обновление контента на основе предпочтений и поведения
    this.updateNavigationBasedOnUsage();
    this.updateContentPriority();
  }
  
  updateNavigationBasedOnUsage() {
    // Перестановка элементов навигации на основе частоты использования
    const frequentlyUsed = this.behavioralData.preferredFeatures.slice(0, 5);
    
    // В реальности обновлять DOM-структуру навигации
    console.log('Часто используемые функции:', frequentlyUsed);
  }
  
  updateContentPriority() {
    // Приоритезация контента на основе интересов пользователя
    const userInterests = this.extractUserInterests();
    
    // В реальности фильтровать и сортировать контент
    console.log('Интересы пользователя:', userInterests);
  }
  
  extractUserInterests() {
    // Извлечение интересов из поведения пользователя
    const interests = {};
    
    // Анализ посещенных страниц
    this.behavioralData.visitedPages.forEach(page => {
      const category = this.getPageCategory(page);
      interests[category] = (interests[category] || 0) + 1;
    });
    
    // Анализ взаимодействий
    this.behavioralData.interactionHistory.forEach(interaction => {
      if (interaction.type === 'click' && interaction.target) {
        const category = this.getElementCategory(interaction.target);
        interests[category] = (interests[category] || 0) + 1;
      }
    });
    
    return interests;
  }
  
  getPageCategory(pageUrl) {
    // Простая категоризация страниц (в реальности более сложная логика)
    if (pageUrl.includes('news')) return 'news';
    if (pageUrl.includes('products')) return 'products';
    if (pageUrl.includes('settings')) return 'settings';
    return 'general';
  }
  
  getElementCategory(element) {
    // Категоризация элементов интерфейса
    if (element.includes('button')) return 'actions';
    if (element.includes('link')) return 'navigation';
    if (element.includes('form')) return 'input';
    return 'general';
  }
  
  showPersonalizedRecommendations() {
    // Показ персонализированных рекомендаций
    const recommendations = this.generateRecommendations();
    this.displayRecommendations(recommendations);
  }
  
  generateRecommendations() {
    // Генерация рекомендаций на основе поведения и предпочтений
    const recommendations = [];
    
    // Рекомендации на основе посещенных страниц
    const visitedCategories = [...new Set(this.behavioralData.visitedPages.map(p => this.getPageCategory(p)))];
    
    visitedCategories.forEach(category => {
      recommendations.push({
        type: 'content',
        category: category,
        reason: 'based_on_visited_pages',
        score: 0.8
      });
    });
    
    // Рекомендации на основе времени суток
    const currentHour = new Date().getHours();
    let timeBasedRecommendation;
    
    if (currentHour >= 6 && currentHour < 12) {
      timeBasedRecommendation = { type: 'morning_news', reason: 'time_based', score: 0.9 };
    } else if (currentHour >= 12 && currentHour < 18) {
      timeBasedRecommendation = { type: 'lunch_reading', reason: 'time_based', score: 0.7 };
    } else {
      timeBasedRecommendation = { type: 'evening_entertainment', reason: 'time_based', score: 0.8 };
    }
    
    recommendations.push(timeBasedRecommendation);
    
    // Сортировка по релевантности
    return recommendations.sort((a, b) => b.score - a.score);
  }
  
  displayRecommendations(recommendations) {
    // Отображение рекомендаций в интерфейсе
    const recommendationsContainer = document.getElementById('personalized-recommendations');
    
    if (recommendationsContainer) {
      recommendationsContainer.innerHTML = recommendations.map(rec => `
        <div class="recommendation-item" data-reason="${rec.reason}">
          <h4>Рекомендация: ${rec.type}</h4>
          <p>Причина: ${rec.reason}</p>
          <p>Релевантность: ${(rec.score * 100).toFixed(0)}%</p>
        </div>
      `).join('');
    }
  }
  
  trackUserInteraction(interactionType, target, value = null) {
    // Отслеживание взаимодействий пользователя для улучшения персонализации
    const interaction = {
      type: interactionType,
      target: target,
      value: value,
      timestamp: new Date(),
      context: this.getContext()
    };
    
    this.behavioralData.interactionHistory.push(interaction);
    
    // Ограничение истории до последних 1000 взаимодействий
    if (this.behavioralData.interactionHistory.length > 1000) {
      this.behavioralData.interactionHistory = 
        this.behavioralData.interactionHistory.slice(-1000);
    }
    
    // Сохранение обновленных данных
    this.saveBehavioralData();
  }
  
  saveBehavioralData() {
    localStorage.setItem('userBehavior', JSON.stringify(this.behavioralData));
  }
  
  updateUserPreferences(newPreferences) {
    // Обновление предпочтений пользователя
    this.userPreferences = { ...this.userPreferences, ...newPreferences };
    localStorage.setItem('userPreferences', JSON.stringify(this.userPreferences));
    
    // Применение новых настроек
    this.applyPersonalization();
  }
  
  getPersonalizationReport() {
    // Генерация отчета о персонализации
    return {
      preferences: this.userPreferences,
      behavioralInsights: {
        totalInteractions: this.behavioralData.interactionHistory.length,
        preferredFeatures: this.behavioralData.preferredFeatures,
        visitPatterns: this.analyzeVisitPatterns()
      },
      context: this.context,
      recommendationsShown: this.generateRecommendations().length
    };
  }
  
  analyzeVisitPatterns() {
    // Анализ паттернов посещений
    const patterns = {
      mostActiveTime: this.findMostActiveTime(),
      preferredDevices: this.findPreferredDevices(),
      favoriteSections: this.findFavoriteSections()
    };
    
    return patterns;
  }
  
  findMostActiveTime() {
    // Определение времени суток с наибольшей активностью
    const timeCounts = this.behavioralData.interactionHistory.reduce((acc, interaction) => {
      const hour = new Date(interaction.timestamp).getHours();
      const period = hour < 12 ? 'morning' : hour < 18 ? 'afternoon' : 'evening';
      acc[period] = (acc[period] || 0) + 1;
      return acc;
    }, {});
    
    return Object.entries(timeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'unknown';
  }
  
  findPreferredDevices() {
    // Определение предпочтительных устройств (в реальности использовать данные о сессиях)
    return ['desktop', 'mobile']; // Пример
  }
  
  findFavoriteSections() {
    // Определение любимых разделов на основе посещений
    const sectionCounts = {};
    this.behavioralData.visitedPages.forEach(page => {
      const category = this.getPageCategory(page);
      sectionCounts[category] = (sectionCounts[category] || 0) + 1;
    });
    
    return Object.entries(sectionCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(entry => entry[0]);
  }
}

// Инициализация персонализации
const personalizationEngine = new PersonalizationEngine();
personalizationEngine.applyPersonalization();

// Пример использования - отслеживание взаимодействий
document.addEventListener('click', (e) => {
  personalizationEngine.trackUserInteraction('click', e.target.tagName, e.target.textContent);
});

// Пример обновления предпочтений
function updateUserTheme(newTheme) {
  personalizationEngine.updateUserPreferences({ theme: newTheme });
}

function updateUserLayout(newLayout) {
  personalizationEngine.updateUserPreferences({ layout: newLayout });
}
</script>
```

### 2. Персонализированные настройки интерфейса

```html
<!-- Панель настроек персонализации -->
<div class="personalization-settings" id="personalization-settings">
  <h2>Настройки персонализации</h2>
  
  <div class="settings-section">
    <h3>Внешний вид</h3>
    
    <div class="setting-group">
      <label for="theme-selector">Тема оформления</label>
      <select id="theme-selector" class="setting-input">
        <option value="light">Светлая</option>
        <option value="dark">Темная</option>
        <option value="high-contrast">Высокая контрастность</option>
      </select>
    </div>
    
    <div class="setting-group">
      <label for="layout-selector">Размер интерфейса</label>
      <select id="layout-selector" class="setting-input">
        <option value="compact">Компактный</option>
        <option value="standard" selected>Стандартный</option>
        <option value="spacious">Просторный</option>
      </select>
    </div>
    
    <div class="setting-group">
      <label for="font-size-selector">Размер шрифта</label>
      <select id="font-size-selector" class="setting-input">
        <option value="small">Маленький</option>
        <option value="medium" selected>Средний</option>
        <option value="large">Большой</option>
      </select>
    </div>
  </div>
  
  <div class="settings-section">
    <h3>Функциональность</h3>
    
    <div class="setting-group">
      <label class="checkbox-label">
        <input type="checkbox" id="notifications-toggle" checked>
        Показывать уведомления
      </label>
    </div>
    
    <div class="setting-group">
      <label class="checkbox-label">
        <input type="checkbox" id="personalization-toggle" checked>
        Использовать персонализацию
      </label>
    </div>
    
    <div class="setting-group">
      <label for="language-selector">Язык интерфейса</label>
      <select id="language-selector" class="setting-input">
        <option value="ru">Русский</option>
        <option value="en">English</option>
        <option value="es">Español</option>
        <option value="fr">Français</option>
      </select>
    </div>
  </div>
  
  <div class="settings-section">
    <h3>Контент</h3>
    
    <div class="interests-selection">
      <h4>Выберите интересы:</h4>
      <div class="interests-grid">
        <label class="checkbox-label">
          <input type="checkbox" value="technology" checked> Технологии
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="business"> Бизнес
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="health" checked> Здоровье
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="sports"> Спорт
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="entertainment"> Развлечения
        </label>
        <label class="checkbox-label">
          <input type="checkbox" value="science"> Наука
        </label>
      </div>
    </div>
  </div>
  
  <div class="settings-actions">
    <button id="save-settings" class="btn btn-primary">Сохранить настройки</button>
    <button id="reset-settings" class="btn btn-secondary">Сбросить</button>
  </div>
</div>

<script>
class PersonalizationSettings {
  constructor() {
    this.settingsForm = document.getElementById('personalization-settings');
    this.loadSavedSettings();
    this.bindEvents();
  }
  
  loadSavedSettings() {
    // Загрузка сохраненных настроек
    const savedSettings = localStorage.getItem('userPreferences');
    if (savedSettings) {
      const settings = JSON.parse(savedSettings);
      
      // Установка значений в элементы управления
      if (settings.theme) {
        document.getElementById('theme-selector').value = settings.theme;
      }
      if (settings.layout) {
        document.getElementById('layout-selector').value = settings.layout;
      }
      if (settings.language) {
        document.getElementById('language-selector').value = settings.language;
      }
      if (settings.fontSize) {
        document.getElementById('font-size-selector').value = settings.fontSize;
      }
      if (settings.notifications !== undefined) {
        document.getElementById('notifications-toggle').checked = settings.notifications;
      }
      if (settings.personalization !== undefined) {
        document.getElementById('personalization-toggle').checked = settings.personalization;
      }
    }
  }
  
  bindEvents() {
    // Привязка событий к элементам управления
    document.getElementById('save-settings').addEventListener('click', () => {
      this.saveSettings();
    });
    
    document.getElementById('reset-settings').addEventListener('click', () => {
      this.resetSettings();
    });
    
    // Привязка событий к каждому элементу управления для мгновенного применения
    document.getElementById('theme-selector').addEventListener('change', (e) => {
      this.applySetting('theme', e.target.value);
    });
    
    document.getElementById('layout-selector').addEventListener('change', (e) => {
      this.applySetting('layout', e.target.value);
    });
    
    document.getElementById('font-size-selector').addEventListener('change', (e) => {
      this.applySetting('fontSize', e.target.value);
    });
    
    document.getElementById('language-selector').addEventListener('change', (e) => {
      this.applySetting('language', e.target.value);
    });
    
    document.getElementById('notifications-toggle').addEventListener('change', (e) => {
      this.applySetting('notifications', e.target.checked);
    });
    
    document.getElementById('personalization-toggle').addEventListener('change', (e) => {
      this.applySetting('personalization', e.target.checked);
    });
    
    // Обработка интересов
    document.querySelectorAll('.interests-grid input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        this.updateInterests();
      });
    });
  }
  
  saveSettings() {
    // Сбор всех настроек в объект
    const settings = {
      theme: document.getElementById('theme-selector').value,
      layout: document.getElementById('layout-selector').value,
      fontSize: document.getElementById('font-size-selector').value,
      language: document.getElementById('language-selector').value,
      notifications: document.getElementById('notifications-toggle').checked,
      personalization: document.getElementById('personalization-toggle').checked,
      interests: this.getSelectedInterests()
    };
    
    // Сохранение в localStorage
    localStorage.setItem('userPreferences', JSON.stringify(settings));
    
    // Применение настроек через основной движок персонализации
    if (window.personalizationEngine) {
      window.personalizationEngine.updateUserPreferences(settings);
    }
    
    // Показ сообщения об успешном сохранении
    this.showNotification('Настройки сохранены', 'success');
  }
  
  resetSettings() {
    // Сброс к настройкам по умолчанию
    const defaultSettings = {
      theme: 'light',
      layout: 'standard',
      fontSize: 'medium',
      language: 'ru',
      notifications: true,
      personalization: true,
      interests: ['technology', 'health']
    };
    
    // Применение настроек по умолчанию
    document.getElementById('theme-selector').value = defaultSettings.theme;
    document.getElementById('layout-selector').value = defaultSettings.layout;
    document.getElementById('font-size-selector').value = defaultSettings.fontSize;
    document.getElementById('language-selector').value = defaultSettings.language;
    document.getElementById('notifications-toggle').checked = defaultSettings.notifications;
    document.getElementById('personalization-toggle').checked = defaultSettings.personalization;
    
    // Сброс интересов
    document.querySelectorAll('.interests-grid input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = defaultSettings.interests.includes(checkbox.value);
    });
    
    // Сохранение и применение
    localStorage.setItem('userPreferences', JSON.stringify(defaultSettings));
    
    if (window.personalizationEngine) {
      window.personalizationEngine.updateUserPreferences(defaultSettings);
    }
    
    this.showNotification('Настройки сброшены к значениям по умолчанию', 'info');
  }
  
  applySetting(settingName, value) {
    // Мгновенное применение отдельной настройки
    const settings = JSON.parse(localStorage.getItem('userPreferences') || '{}');
    settings[settingName] = value;
    localStorage.setItem('userPreferences', JSON.stringify(settings));
    
    if (window.personalizationEngine) {
      window.personalizationEngine.updateUserPreferences({ [settingName]: value });
    }
  }
  
  getSelectedInterests() {
    const selectedInterests = [];
    document.querySelectorAll('.interests-grid input[type="checkbox"]:checked').forEach(checkbox => {
      selectedInterests.push(checkbox.value);
    });
    return selectedInterests;
  }
  
  updateInterests() {
    const interests = this.getSelectedInterests();
    this.applySetting('interests', interests);
  }
  
  showNotification(message, type) {
    // Простое уведомление (в реальности использовать полноценный компонент уведомлений)
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 15px;
      border-radius: 4px;
      color: white;
      z-index: 10000;
      ${type === 'success' ? 'background-color: #27ae60;' : 
        type === 'error' ? 'background-color: #e74c3c;' : 'background-color: #3498db;'}
    `;
    
    document.body.appendChild(notification);
    
    // Удаление уведомления через 3 секунды
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 3000);
  }
}

// Инициализация панели настроек
document.addEventListener('DOMContentLoaded', () => {
  new PersonalizationSettings();
});
</script>

<style>
.personalization-settings {
  max-width: 600px;
  margin: 2rem auto;
  padding: 2rem;
  background: var(--surface-color);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.settings-section {
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border-color);
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: 1rem;
  color: var(--text-primary);
}

.setting-group {
  margin-bottom: 1rem;
}

.setting-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: var(--text-primary);
}

.setting-input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 1rem;
}

.checkbox-label {
  display: flex;
  align-items: center;
  margin-bottom: 0.5rem;
  cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
  margin-right: 0.5rem;
}

.interests-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 0.5rem;
}

.settings-actions {
  display: flex;
  gap: 1rem;
  justify-content: flex-end;
}

.btn {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
}

.btn-primary {
  background-color: #3498db;
  color: white;
}

.btn-primary:hover {
  background-color: #2980b9;
}

.btn-secondary {
  background-color: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background-color: #7f8c8d;
}

.notification {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 10px 15px;
  border-radius: 4px;
  color: white;
  z-index: 10000;
}

.notification-success { background-color: #27ae60; }
.notification-error { background-color: #e74c3c; }
.notification-info { background-color: #3498db; }
</style>
```

### 3. Контекстуальная персонализация

```javascript
// Пример системы контекстуальной персонализации
class ContextualPersonalization {
  constructor() {
    this.userContext = this.analyzeContext();
    this.contextualRules = this.loadContextualRules();
    this.adaptInterface();
  }
  
  analyzeContext() {
    // Анализ текущего контекста пользователя
    return {
      time: new Date(),
      location: this.getUserLocation(),
      device: this.getDeviceContext(),
      network: this.getNetworkContext(),
      applicationState: this.getApplicationState(),
      recentActivities: this.getRecentActivities()
    };
  }
  
  getUserLocation() {
    // Получение геолокации (с разрешения пользователя)
    return new Promise((resolve) => {
      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            resolve({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy
            });
          },
          () => {
            // В случае ошибки или отказа в геолокации
            resolve({ latitude: 55.7558, longitude: 37.6173 }); // Москва по умолчанию
          }
        );
      } else {
        resolve({ latitude: 55.7558, longitude: 37.6173 }); // Москва по умолчанию
      }
    });
  }
  
  getDeviceContext() {
    return {
      type: /mobile|android|iphone|ipod|ipad/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
      screen: {
        width: window.screen.width,
        height: window.screen.height,
        availWidth: window.screen.availWidth,
        availHeight: window.screen.availHeight
      },
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      pixelRatio: window.devicePixelRatio || 1
    };
  }
  
  getNetworkContext() {
    return {
      effectiveType: navigator.connection ? navigator.connection.effectiveType : '4g',
      downlink: navigator.connection ? navigator.connection.downlink : 10,
      rtt: navigator.connection ? navigator.connection.rtt : 50
    };
  }
  
  getApplicationState() {
    // Состояние приложения (активные функции, открытые модули и т.д.)
    return {
      activeModules: this.getActiveModules(),
      currentView: window.location.pathname,
      sessionDuration: this.getSessionDuration()
    };
  }
  
  getActiveModules() {
    // В реальности определять активные модули приложения
    return ['dashboard', 'notifications', 'messages'];
  }
  
  getSessionDuration() {
    // Определение продолжительности сессии
    const sessionStart = sessionStorage.getItem('sessionStart');
    if (sessionStart) {
      return Date.now() - parseInt(sessionStart);
    } else {
      sessionStorage.setItem('sessionStart', Date.now().toString());
      return 0;
    }
  }
  
  getRecentActivities() {
    // Получение последних действий пользователя
    const activities = JSON.parse(localStorage.getItem('userActivities') || '[]');
    return activities.slice(-20); // Последние 20 действий
  }
  
  loadContextualRules() {
    // Загрузка правил контекстуальной персонализации
    return [
      {
        condition: (context) => context.time.getHours() >= 22 || context.time.getHours() <= 6,
        action: () => this.activateNightMode(),
        description: 'Ночное время - активация темной темы'
      },
      {
        condition: (context) => context.device.type === 'mobile',
        action: () => this.optimizeForMobile(),
        description: 'Мобильное устройство - оптимизация интерфейса'
      },
      {
        condition: (context) => context.network.effectiveType === 'slow-2g' || context.network.effectiveType === '2g',
        action: () => this.reduceDataUsage(),
        description: 'Медленное соединение - уменьшение использования данных'
      },
      {
        condition: (context) => context.applicationState.sessionDuration > 3600000, // 1 час
        action: () => this.showBreakReminder(),
        description: 'Длительная сессия - напоминание о перерыве'
      },
      {
        condition: (context) => this.isFrequentAction('dashboard_view'),
        action: () => this.simplifyDashboard(),
        description: 'Частое посещение дашборда - упрощение интерфейса'
      }
    ];
  }
  
  adaptInterface() {
    // Применение адаптаций на основе контекста
    this.contextualRules.forEach(rule => {
      if (rule.condition(this.userContext)) {
        console.log('Применение правила:', rule.description);
        rule.action();
      }
    });
  }
  
  activateNightMode() {
    // Активация ночной темы
    document.body.classList.add('night-mode');
    document.documentElement.style.setProperty('--primary-color', '#2980b9');
    document.documentElement.style.setProperty('--background-color', '#1a252f');
    document.documentElement.style.setProperty('--text-color', '#ecf0f1');
  }
  
  optimizeForMobile() {
    // Оптимизация интерфейса для мобильных устройств
    document.body.classList.add('mobile-optimized');
    
    // Увеличение размера сенсорных областей
    const touchTargets = document.querySelectorAll('button, a, input, select, textarea');
    touchTargets.forEach(target => {
      if (target.style.minHeight !== '44px') {
        target.style.minHeight = '44px';
        target.style.minWidth = '44px';
      }
    });
  }
  
  reduceDataUsage() {
    // Уменьшение использования данных (снижение качества изображений, отложенная загрузка и т.д.)
    document.body.classList.add('data-saving-mode');
    
    // Отложенная загрузка изображений
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => {
      if (!img.src) {
        img.src = img.getAttribute('data-src');
      }
    });
    
    // Отключение анимаций
    document.body.classList.add('reduce-animations');
  }
  
  showBreakReminder() {
    // Показ напоминания о перерыве
    if (!localStorage.getItem('breakReminderShown') || 
        Date.now() - parseInt(localStorage.getItem('breakReminderShown')) > 7200000) { // 2 часа
      
      const reminder = document.createElement('div');
      reminder.className = 'break-reminder';
      reminder.innerHTML = `
        <div class="reminder-content">
          <h3>Время перерыва!</h3>
          <p>Вы долго работаете. Рекомендуется сделать небольшой перерыв.</p>
          <button id="dismiss-break-reminder">Закрыть</button>
        </div>
      `;
      
      document.body.appendChild(reminder);
      
      document.getElementById('dismiss-break-reminder').addEventListener('click', () => {
        document.body.removeChild(reminder);
        localStorage.setItem('breakReminderShown', Date.now().toString());
      });
    }
  }
  
  simplifyDashboard() {
    // Упрощение дашборда для частых пользователей
    const dashboardElements = document.querySelectorAll('.dashboard-element');
    dashboardElements.forEach(element => {
      // Скрытие сложных элементов управления
      const complexControls = element.querySelectorAll('.complex-control');
      complexControls.forEach(control => control.style.display = 'none');
      
      // Показ упрощенных элементов
      const simpleControls = element.querySelectorAll('.simple-control');
      simpleControls.forEach(control => control.style.display = 'block');
    });
  }
  
  isFrequentAction(actionType) {
    // Проверка, является ли действие частым
    const recentActivities = this.userContext.recentActivities;
    const actionCount = recentActivities.filter(activity => activity.type === actionType).length;
    
    // Если действие выполнялось более 5 раз за последние 30 минут
    const recentTime = Date.now() - 1800000; // 30 минут
    const recentActionCount = recentActivities.filter(
      activity => activity.type === actionType && 
      new Date(activity.timestamp).getTime() > recentTime
    ).length;
    
    return recentActionCount > 5;
  }
  
  trackActivity(activityType, details = {}) {
    // Отслеживание активности пользователя
    const activity = {
      type: activityType,
      details: details,
      timestamp: new Date().toISOString(),
      context: {
        url: window.location.href,
        referrer: document.referrer,
        userAgent: navigator.userAgent
      }
    };
    
    const activities = JSON.parse(localStorage.getItem('userActivities') || '[]');
    activities.push(activity);
    
    // Ограничение истории до последних 1000 действий
    if (activities.length > 1000) {
      activities.shift();
    }
    
    localStorage.setItem('userActivities', JSON.stringify(activities));
  }
  
  getContextReport() {
    // Генерация отчета о контексте
    return {
      currentContext: this.userContext,
      appliedAdaptations: this.getAppliedAdaptations(),
      nextAdaptationOpportunities: this.getNextAdaptationOpportunities()
    };
  }
  
  getAppliedAdaptations() {
    // Получение списка примененных адаптаций
    const adaptations = [];
    
    if (document.body.classList.contains('night-mode')) adaptations.push('night_mode');
    if (document.body.classList.contains('mobile-optimized')) adaptations.push('mobile_optimization');
    if (document.body.classList.contains('data-saving-mode')) adaptations.push('data_saving');
    if (document.body.classList.contains('reduce-animations')) adaptations.push('animation_reduction');
    
    return adaptations;
  }
  
  getNextAdaptationOpportunities() {
    // Определение возможных будущих адаптаций
    const opportunities = [];
    
    // Временные возможности
    const nextHour = new Date();
    nextHour.setHours(nextHour.getHours() + 1);
    if (nextHour.getHours() >= 22 || nextHour.getHours() <= 6) {
      opportunities.push('night_mode_activation');
    }
    
    // Основанные на поведении
    if (this.userContext.recentActivities.length > 50) {
      opportunities.push('behavioral_adaptation');
    }
    
    return opportunities;
  }
}

// Инициализация контекстуальной персонализации
const contextualPersonalization = new ContextualPersonalization();

// Пример отслеживания активности
document.addEventListener('click', (e) => {
  contextualPersonalization.trackActivity('click', {
    element: e.target.tagName,
    id: e.target.id,
    class: e.target.className
  });
});

document.addEventListener('keypress', (e) => {
  contextualPersonalization.trackActivity('keypress', {
    key: e.key,
    target: e.target.tagName
  });
});
</script>

<style>
/* Стили для контекстуальных адаптаций */
.night-mode {
  background-color: #1a252f !important;
  color: #ecf0f1 !important;
}

.night-mode * {
  background-color: inherit !important;
  color: inherit !important;
}

.data-saving-mode img {
  max-width: 100%;
  height: auto;
}

.reduce-animations * {
  animation-duration: 0.01ms !important;
  animation-iteration-count: 1 !important;
  transition-duration: 0.01ms !important;
}

.break-reminder {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.break-reminder .reminder-content {
  background: white;
  padding: 2rem;
  border-radius: 8px;
  text-align: center;
  max-width: 400px;
}

.break-reminder h3 {
  margin-top: 0;
  color: #2c3e50;
}

.break-reminder p {
  color: #7f8c8d;
  margin-bottom: 1.5rem;
}

.break-reminder button {
  background: #3498db;
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 4px;
  cursor: pointer;
}

.mobile-optimized .dashboard-element .complex-control {
  display: none;
}

.mobile-optimized .dashboard-element .simple-control {
  display: block;
}
</style>
```

## Практические рекомендации для фронтенд-разработчиков

### 1. Баланс между персонализацией и контролем

```javascript
// Пример системы управления персонализацией с балансом
class BalancedPersonalizationManager {
  constructor() {
    this.privacyLevel = this.getPrivacyLevel();
    this.personalizationLevel = this.getPersonalizationLevel();
    this.userControlOptions = this.initializeUserControls();
  }
  
  getPrivacyLevel() {
    // Уровень конфиденциальности (low, medium, high)
    return localStorage.getItem('privacyLevel') || 'medium';
  }
  
  getPersonalizationLevel() {
    // Уровень персонализации (none, basic, advanced)
    return localStorage.getItem('personalizationLevel') || 'basic';
  }
  
  initializeUserControls() {
    // Инициализация элементов управления персонализацией
    return {
      allowBehavioralTracking: this.privacyLevel !== 'high',
      allowDataSharing: this.privacyLevel === 'low',
      showPersonalizedAds: this.personalizationLevel === 'advanced',
      useBrowsingHistory: this.personalizationLevel !== 'none'
    };
  }
  
  applyBalancedPersonalization() {
    // Применение персонализации с учетом баланса
    if (this.userControlOptions.allowBehavioralTracking) {
      this.enableBehavioralTracking();
    }
    
    if (this.userControlOptions.useBrowsingHistory) {
      this.useBrowsingHistoryForRecommendations();
    }
    
    if (this.userControlOptions.showPersonalizedAds) {
      this.showPersonalizedAds();
    }
  }
  
  enableBehavioralTracking() {
    // Включение отслеживания поведения в пределах разрешенного уровня
    console.log('Отслеживание поведения включено');
    
    // Ограничение сбора данных в зависимости от уровня конфиденциальности
    switch (this.privacyLevel) {
      case 'low':
        // Сбор расширенных данных
        this.setupExtendedTracking();
        break;
      case 'medium':
        // Сбор базовых данных
        this.setupBasicTracking();
        break;
      case 'high':
        // Минимальный сбор данных
        this.setupMinimalTracking();
        break;
    }
  }
  
  setupExtendedTracking() {
    // Расширенное отслеживание (в пределах разрешенного)
    this.setupClickTracking();
    this.setupScrollTracking();
    this.setupTimeOnPageTracking();
    this.setupFormInteractionTracking();
  }
  
  setupBasicTracking() {
    // Базовое отслеживание
    this.setupPageViewTracking();
    this.setupMajorActionTracking();
  }
  
  setupMinimalTracking() {
    // Минимальное отслеживание
    this.setupEssentialTracking();
  }
  
  setupPageViewTracking() {
    // Отслеживание просмотров страниц
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.trackPageView(entry.target);
        }
      });
    });
    
    // Наблюдение за основными разделами страницы
    document.querySelectorAll('main, section, article').forEach(section => {
      observer.observe(section);
    });
  }
  
  trackPageView(element) {
    // Отслеживание просмотра элемента
    if (this.userControlOptions.allowBehavioralTracking) {
      const viewRecord = {
        element: element.tagName,
        id: element.id,
        timestamp: new Date(),
        privacyLevel: this.privacyLevel
      };
      
      this.storeViewData(viewRecord);
    }
  }
  
  storeViewData(data) {
    // Сохранение данных с учетом приватности
    const storedViews = JSON.parse(localStorage.getItem('pageViews') || '[]');
    storedViews.push(data);
    
    // Ограничение количества записей
    if (storedViews.length > 100) {
      storedViews.shift();
    }
    
    localStorage.setItem('pageViews', JSON.stringify(storedViews));
  }
  
  useBrowsingHistoryForRecommendations() {
    // Использование истории просмотров для рекомендаций
    const viewHistory = JSON.parse(localStorage.getItem('pageViews') || '[]');
    const recommendations = this.generateRecommendationsFromHistory(viewHistory);
    
    this.displayRecommendations(recommendations);
  }
  
  generateRecommendationsFromHistory(viewHistory) {
    // Генерация рекомендаций на основе истории просмотров
    const contentCategories = {};
    
    viewHistory.forEach(view => {
      const category = this.categorizeContent(view);
      contentCategories[category] = (contentCategories[category] || 0) + 1;
    });
    
    // Сортировка по частоте просмотра
    return Object.entries(contentCategories)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([category, count]) => ({
        category: category,
        relevance: count / viewHistory.length,
        type: 'content_suggestion'
      }));
  }
  
  categorizeContent(view) {
    // Категоризация контента (упрощенно)
    if (view.id.includes('news')) return 'news';
    if (view.id.includes('product')) return 'products';
    if (view.id.includes('tutorial')) return 'tutorials';
    return 'general';
  }
  
  displayRecommendations(recommendations) {
    // Отображение рекомендаций с возможностью отключения
    const container = document.getElementById('recommendations-container');
    if (!container) return;
    
    container.innerHTML = `
      <div class="recommendations-header">
        <h3>Персональные рекомендации</h3>
        <button id="disable-recommendations" class="btn btn-small">Отключить</button>
      </div>
      <div class="recommendations-list">
        ${recommendations.map(rec => `
          <div class="recommendation-item" data-category="${rec.category}">
            <h4>${rec.category}</h4>
            <p>Релевантность: ${(rec.relevance * 100).toFixed(0)}%</p>
            <button class="btn btn-outline" onclick="this.rateRecommendation('${rec.category}')">Нравится</button>
            <button class="btn btn-outline" onclick="this.rateRecommendation('${rec.category}', false)">Не интересует</button>
          </div>
        `).join('')}
      </div>
    `;
    
    // Добавление обработчиков
    document.getElementById('disable-recommendations').addEventListener('click', () => {
      this.disableRecommendations();
    });
  }
  
  rateRecommendation(category, liked = true) {
    // Оценка рекомендации пользователем
    const ratings = JSON.parse(localStorage.getItem('recommendationRatings') || '{}');
    ratings[category] = ratings[category] || { liked: 0, disliked: 0 };
    
    if (liked) {
      ratings[category].liked++;
    } else {
      ratings[category].disliked++;
    }
    
    localStorage.setItem('recommendationRatings', JSON.stringify(ratings));
  }
  
  disableRecommendations() {
    // Отключение персонализированных рекомендаций
    this.updatePersonalizationLevel('none');
    const container = document.getElementById('recommendations-container');
    if (container) {
      container.style.display = 'none';
    }
  }
  
  updatePrivacyLevel(level) {
    // Обновление уровня конфиденциальности
    localStorage.setItem('privacyLevel', level);
    this.privacyLevel = level;
    this.userControlOptions = this.initializeUserControls();
    this.applyBalancedPersonalization();
  }
  
  updatePersonalizationLevel(level) {
    // Обновление уровня персонализации
    localStorage.setItem('personalizationLevel', level);
    this.personalizationLevel = level;
    this.userControlOptions = this.initializeUserControls();
    this.applyBalancedPersonalization();
  }
  
  getUserControlPanel() {
    // Получение панели управления персонализацией для пользователя
    return {
      privacyLevel: this.privacyLevel,
      personalizationLevel: this.personalizationLevel,
      trackingStatus: this.getTrackingStatus(),
      dataUsage: this.getDataUsage(),
      controlOptions: this.userControlOptions
    };
  }
  
  getTrackingStatus() {
    // Получение статуса отслеживания
    return {
      behavioralTracking: this.userControlOptions.allowBehavioralTracking,
      dataSharing: this.userControlOptions.allowDataSharing,
      adPersonalization: this.userControlOptions.showPersonalizedAds
    };
  }
  
  getDataUsage() {
    // Получение информации об использовании данных
    return {
      storedViews: JSON.parse(localStorage.getItem('pageViews') || '[]').length,
      recommendationRatings: Object.keys(JSON.parse(localStorage.getItem('recommendationRatings') || '{}')).length,
      totalInteractions: JSON.parse(localStorage.getItem('userInteractions') || '[]').length
    };
  }
}

// Инициализация менеджера с балансом
const balancedPersonalization = new BalancedPersonalizationManager();
balancedPersonalization.applyBalancedPersonalization();
</style>
```

## Связанные концепции

- [[UX-дизайн]] - общие принципы пользовательского опыта
- [[UI-дизайн]] - визуальное оформление интерфейса
- [[Исследование-пользователей]] - понимание потребностей пользователей
- [[Тестирование-юзабилити]] - проверка удобства использования
- [[доступность]] - обеспечение доступности для всех пользователей
- [[обратная-связь]] - информирование пользователя о результатах действий
- [[Дизайн-системы]] - унификация элементов интерфейса

## Заключение

Персонализация играет ключевую роль в создании индивидуального и релевантного пользовательского опыта. Фронтенд-разработчики должны внедрять персонализацию с учетом конфиденциальности пользователей и предоставлять им контроль над уровнем персонализации. Успешная персонализация повышает вовлеченность пользователей и удовлетворенность продуктом, но требует баланса между удобством и приватностью.