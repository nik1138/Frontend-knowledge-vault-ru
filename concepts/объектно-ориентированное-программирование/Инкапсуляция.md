---
aliases: [Инкапсуляция в OOP, Access Modifiers, Приватные методы]
tags: [programming, oop, javascript, typescript, frontend, encapsulation, access-modifiers, private, public, protected]
---

# Инкапсуляция

**Инкапсуляция** - это одна из ключевых концепций объектно-ориентированного программирования, которая заключается в сокрытии внутренней реализации объекта от внешнего мира. Инкапсуляция позволяет контролировать доступ к данным и методам объекта, защищая их от несанкционированного изменения и обеспечивая целостность состояния объекта.

## Основные принципы инкапсуляции

- **Сокрытие данных** - внутренние данные объекта недоступны напрямую извне
- **Контроль доступа** - предоставление ограниченного интерфейса для взаимодействия с объектом
- **Защита целостности** - предотвращение изменения внутреннего состояния объекта недопустимыми способами
- **Модульность** - отделение реализации от интерфейса

## Уровни доступа в TypeScript

TypeScript предоставляет три уровня доступа к свойствам и методам класса:

- **`public`** - элемент доступен из любого места (по умолчанию)
- **`private`** - элемент доступен только внутри класса
- **`protected`** - элемент доступен внутри класса и его подклассов

## Примеры в JavaScript и TypeScript

### Инкапсуляция в TypeScript с использованием модификаторов доступа

```typescript
class BankAccount {
  // Приватные свойства - не доступны извне
  private accountNumber: string;
  private balance: number;
  
  // Защищенное свойство - доступно в классе и подклассах
  protected accountHolderName: string;

  constructor(accountNumber: string, accountHolderName: string, initialBalance: number) {
    this.accountNumber = accountNumber;
    this.accountHolderName = accountHolderName;
    this.balance = initialBalance;
  }

  // Публичные методы для безопасного взаимодействия
  public getBalance(): number {
    return this.balance;
  }

  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
      console.log(`Внесено: ${amount}. Новый баланс: ${this.balance}`);
    } else {
      console.error('Сумма должна быть положительной');
    }
  }

  public withdraw(amount: number): boolean {
    if (amount > 0 && amount <= this.balance) {
      this.balance -= amount;
      console.log(`Снято: ${amount}. Новый баланс: ${this.balance}`);
      return true;
    } else {
      console.error('Недостаточно средств или неверная сумма');
      return false;
    }
  }

  // Публичный метод для получения информации об аккаунте
  public getAccountInfo(): string {
    return `Владелец: ${this.accountHolderName}, Номер: ${this.accountNumber}, Баланс: ${this.balance}`;
  }
}

const account = new BankAccount('123456789', 'Иван Иванов', 1000);
console.log(account.getAccountInfo());
account.deposit(500);
console.log(account.getBalance()); // 1500

// Следующая строка вызовет ошибку компиляции, так как balance приватный
// console.log(account.balance); // Ошибка!
```

### Использование геттеров и сеттеров для контроля доступа

```typescript
class Temperature {
  private _celsius: number;

  constructor(celsius: number) {
    this._celsius = celsius;
  }

  // Геттер для получения температуры в Цельсиях
  public get celsius(): number {
    return this._celsius;
  }

  // Сеттер с валидацией
  public set celsius(value: number) {
    if (value < -273.15) {
      console.error('Температура не может быть ниже абсолютного нуля!');
      return;
    }
    this._celsius = value;
  }

  // Геттер для температуры в Фаренгейтах
  public get fahrenheit(): number {
    return (this._celsius * 9/5) + 32;
  }

  // Сеттер для температуры в Фаренгейтах
  public set fahrenheit(value: number) {
    const celsius = (value - 32) * 5/9;
    if (celsius < -273.15) {
      console.error('Температура не может быть ниже абсолютного нуля!');
      return;
    }
    this._celsius = celsius;
  }

  // Геттер для температуры в Кельвинах
  public get kelvin(): number {
    return this._celsius + 273.15;
  }
}

const temp = new Temperature(25);
console.log(`Цельсий: ${temp.celsius}`); // Цельсий: 25
console.log(`Фаренгейт: ${temp.fahrenheit}`); // Фаренгейт: 77
console.log(`Кельвин: ${temp.kelvin}`); // Кельвин: 298.15

temp.celsius = 30;
console.log(`Новая температура: ${temp.celsius}`); // Новая температура: 30

temp.celsius = -300; // Попытка установить температуру ниже абсолютного нуля
console.log(`Температура: ${temp.celsius}`); // Температура: 30 (не изменилась)
```

### Инкапсуляция в JavaScript (ES6+)

JavaScript не имеет встроенной поддержки приватных свойств до ES2022, но можно использовать символы или замыкания:

```javascript
// Использование приватных полей (ES2022+)
class Counter {
  #count; // Приватное поле
  #maxValue;

  constructor(maxValue = 100) {
    this.#count = 0;
    this.#maxValue = maxValue;
  }

  increment() {
    if (this.#count < this.#maxValue) {
      this.#count++;
    }
  }

  decrement() {
    if (this.#count > 0) {
      this.#count--;
    }
  }

  getCount() {
    return this.#count;
  }

  reset() {
    this.#count = 0;
  }
}

const counter = new Counter(10);
counter.increment();
console.log(counter.getCount()); // 1

// Следующая строка не будет работать, так как #count приватное
// console.log(counter.#count); // SyntaxError!
```

### Использование замыканий для инкапсуляции в JavaScript

```javascript
function createBankAccount(accountNumber, accountHolderName, initialBalance) {
  // Приватные переменные
  let balance = initialBalance;
  
  // Приватная функция
  function validateAmount(amount) {
    return typeof amount === 'number' && amount > 0;
  }

  // Возвращаем объект с публичным интерфейсом
  return {
    getAccountInfo: function() {
      return `Владелец: ${accountHolderName}, Номер: ${accountNumber}, Баланс: ${balance}`;
    },
    
    getBalance: function() {
      return balance;
    },
    
    deposit: function(amount) {
      if (validateAmount(amount)) {
        balance += amount;
        console.log(`Внесено: ${amount}. Новый баланс: ${balance}`);
      } else {
        console.error('Неверная сумма');
      }
    },
    
    withdraw: function(amount) {
      if (validateAmount(amount) && amount <= balance) {
        balance -= amount;
        console.log(`Снято: ${amount}. Новый баланс: ${balance}`);
        return true;
      } else {
        console.error('Недостаточно средств или неверная сумма');
        return false;
      }
    }
  };
}

const account2 = createBankAccount('987654321', 'Мария Петрова', 2000);
console.log(account2.getAccountInfo());
account2.deposit(300);
console.log(account2.getBalance()); // 2300
```

## Практическое применение в фронтенд-разработке

### 1. Управление состоянием компонента

```typescript
class TodoList {
  private todos: string[] = [];
  private maxItems: number;

  constructor(maxItems: number = 100) {
    this.maxItems = maxItems;
  }

  public addTodo(item: string): boolean {
    if (this.todos.length < this.maxItems && item.trim() !== '') {
      this.todos.push(item.trim());
      return true;
    }
    return false;
  }

  public removeTodo(index: number): boolean {
    if (index >= 0 && index < this.todos.length) {
      this.todos.splice(index, 1);
      return true;
    }
    return false;
  }

  public getTodos(): readonly string[] {
    // Возвращаем копию массива для защиты от внешних изменений
    return [...this.todos];
  }

  public getTodoCount(): number {
    return this.todos.length;
  }

  public clear(): void {
    this.todos = [];
  }
}

const todoList = new TodoList(10);
todoList.addTodo('Изучить инкапсуляцию');
todoList.addTodo('Практиковать ООП');
console.log(todoList.getTodos()); // ['Изучить инкапсуляцию', 'Практиковать ООП']
console.log(todoList.getTodoCount()); // 2
```

### 2. Управление сессией пользователя

```typescript
class SessionManager {
  private static instance: SessionManager;
  private userSession: { 
    userId: string; 
    token: string; 
    expiresAt: Date; 
  } | null = null;
  private autoRefresh: boolean = true;

  private constructor() {}

  public static getInstance(): SessionManager {
    if (!SessionManager.instance) {
      SessionManager.instance = new SessionManager();
    }
    return SessionManager.instance;
  }

  public login(userId: string, token: string, expiresInHours: number): void {
    this.userSession = {
      userId,
      token,
      expiresAt: new Date(Date.now() + expiresInHours * 60 * 60 * 1000)
    };
    this.setupAutoRefresh();
  }

  public logout(): void {
    this.userSession = null;
    this.clearAutoRefresh();
  }

  public isAuthenticated(): boolean {
    if (!this.userSession) {
      return false;
    }
    return new Date() < this.userSession.expiresAt;
  }

  public getAuthToken(): string | null {
    if (this.isAuthenticated()) {
      return this.userSession.token;
    }
    return null;
  }

  private setupAutoRefresh(): void {
    if (this.autoRefresh && this.userSession) {
      const timeUntilExpiry = this.userSession.expiresAt.getTime() - Date.now();
      setTimeout(() => {
        // Логика обновления токена
        console.log('Обновление токена сессии...');
      }, timeUntilExpiry - 5 * 60 * 1000); // Обновляем за 5 минут до истечения
    }
  }

  private clearAutoRefresh(): void {
    // Очистка таймеров автосохранения
  }
}

// Использование синглтона
const session = SessionManager.getInstance();
session.login('user123', 'token456', 24);
console.log(session.isAuthenticated()); // true
```

## Преимущества инкапсуляции

- **Безопасность данных** - предотвращает несанкционированный доступ к внутренним данным
- **Управляемость** - позволяет контролировать, как данные изменяются
- **Поддерживаемость** - изменения во внутренней реализации не влияют на внешний код
- **Повторное использование** - инкапсулированные классы легче переиспользовать

## Заключение

Инкапсуляция играет ключевую роль в создании надежных и безопасных приложений. Она защищает внутреннее состояние объектов и предоставляет контролируемый интерфейс для взаимодействия с ними. В фронтенд-разработке инкапсуляция особенно важна для управления состоянием приложения, обработки пользовательских данных и обеспечения безопасности.

Для полного понимания ООП также рекомендуется изучить другие концепции: [[Классы-и-объекты]], [[Наследование]], [[Полиморфизм]] и [[Абстракция]].
