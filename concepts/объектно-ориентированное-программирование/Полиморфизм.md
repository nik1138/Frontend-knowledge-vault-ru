---
aliases: [Полиморфизм в OOP, Polymorphism, Интерфейсы, Абстрактные классы]
tags: [programming, oop, javascript, typescript, frontend, polymorphism, interface, abstract-class]
---

# Полиморфизм

**Полиморфизм** - это одна из ключевых концепций объектно-ориентированного программирования, позволяющая объектам разных классов обрабатываться с использованием одного и того же интерфейса. Слово "полиморфизм" происходит от греческих "poly" (много) и "morph" (форма), что означает "много форм". В контексте программирования это означает, что один и тот же метод может работать по-разному в зависимости от типа объекта, на котором он вызывается.

## Основные понятия полиморфизма

- **Интерфейс** - контракт, определяющий методы, которые должны быть реализованы
- **Переопределение методов** - возможность дочернего класса изменить поведение метода родительского класса
- **Единый интерфейс** - возможность обращения с объектами разных типов через общий интерфейс
- **Позднее связывание** - механизм, при котором вызов метода разрешается во время выполнения

## Виды полиморфизма

- **Подтиповский полиморфизм** - использование объектов подклассов там, где ожидается суперкласс
- **Параметрический полиморфизм** - использование универсальных типов (дженерики)
- **Перегрузка методов** - несколько методов с одинаковым именем, но разными параметрами

## Примеры в JavaScript и TypeScript

### Полиморфизм через наследование

```typescript
// Базовый класс
abstract class Shape {
  protected color: string;

  constructor(color: string) {
    this.color = color;
  }

  // Абстрактный метод, который должен быть реализован в подклассах
  abstract calculateArea(): number;

  // Общий метод для всех фигур
  getColor(): string {
    return this.color;
  }

  // Общий метод, который можно переопределить
  getInfo(): string {
    return `Фигура цвета ${this.color} с площадью ${this.calculateArea()}`;
  }
}

// Конкретные реализации
class Circle extends Shape {
  private radius: number;

  constructor(color: string, radius: number) {
    super(color);
    this.radius = radius;
  }

  calculateArea(): number {
    return Math.PI * this.radius * this.radius;
  }

  getInfo(): string {
    return `Круг цвета ${this.color} с радиусом ${this.radius} и площадью ${this.calculateArea()}`;
  }
}

class Rectangle extends Shape {
  private width: number;
  private height: number;

  constructor(color: string, width: number, height: number) {
    super(color);
    this.width = width;
    this.height = height;
  }

  calculateArea(): number {
    return this.width * this.height;
  }

  getInfo(): string {
    return `Прямоугольник цвета ${this.color} с размерами ${this.width}x${this.height} и площадью ${this.calculateArea()}`;
  }
}

class Triangle extends Shape {
  private base: number;
  private height: number;

  constructor(color: string, base: number, height: number) {
    super(color);
    this.base = base;
    this.height = height;
  }

  calculateArea(): number {
    return 0.5 * this.base * this.height;
  }

  getInfo(): string {
    return `Треугольник цвета ${this.color} с основанием ${this.base}, высотой ${this.height} и площадью ${this.calculateArea()}`;
  }
}

// Демонстрация полиморфизма
const shapes: Shape[] = [
  new Circle('красный', 5),
  new Rectangle('синий', 4, 6),
  new Triangle('зеленый', 3, 8)
];

// Полиморфный вызов метода - каждый объект использует свою реализацию
shapes.forEach(shape => {
  console.log(shape.getInfo());
  console.log(`Площадь: ${shape.calculateArea()}`);
});
```

### Полиморфизм через интерфейсы

```typescript
interface Drawable {
  draw(): void;
}

interface Resizable {
  resize(factor: number): void;
}

// Класс может реализовывать несколько интерфейсов
class Button implements Drawable, Resizable {
  private text: string;
  private width: number;
  private height: number;

  constructor(text: string, width: number, height: number) {
    this.text = text;
    this.width = width;
    this.height = height;
  }

  draw(): void {
    console.log(`Отрисовка кнопки с текстом: ${this.text}`);
  }

  resize(factor: number): void {
    this.width *= factor;
    this.height *= factor;
    console.log(`Кнопка изменена: ${this.width}x${this.height}`);
  }
}

class Image implements Drawable, Resizable {
  private src: string;
  private width: number;
  private height: number;

  constructor(src: string, width: number, height: number) {
    this.src = src;
    this.width = width;
    this.height = height;
  }

  draw(): void {
    console.log(`Отрисовка изображения: ${this.src}`);
  }

  resize(factor: number): void {
    this.width *= factor;
    this.height *= factor;
    console.log(`Изображение изменено: ${this.width}x${this.height}`);
  }
}

// Массив с разными объектами, реализующими один интерфейс
const drawables: Drawable[] = [
  new Button('Нажми меня', 100, 50),
  new Image('photo.jpg', 200, 150)
];

// Полиморфный вызов метода draw
drawables.forEach(item => item.draw());
```

### Полиморфизм с функциями

```typescript
// Функция, принимающая объект, реализующий интерфейс
function renderShape(shape: Shape): void {
  console.log('--- Новая фигура ---');
  console.log(shape.getInfo());
}

// Та же функция работает с разными типами фигур
const circle = new Circle('красный', 3);
const rectangle = new Rectangle('синий', 4, 5);

renderShape(circle);      // Вызовет реализацию Circle
renderShape(rectangle);   // Вызовет реализацию Rectangle
```

### Пример с обработкой событий

```typescript
interface EventHandler {
  handleEvent(event: string): void;
}

class ClickHandler implements EventHandler {
  handleEvent(event: string): void {
    console.log(`Обработка клика: ${event}`);
  }
}

class KeyboardHandler implements EventHandler {
  handleEvent(event: string): void {
    console.log(`Обработка клавиатуры: ${event}`);
  }
}

class MouseHandler implements EventHandler {
  handleEvent(event: string): void {
    console.log(`Обработка мыши: ${event}`);
  }
}

// Единая функция для обработки событий
function processEvent(handler: EventHandler, event: string): void {
  handler.handleEvent(event);
}

// Полиморфное использование обработчиков
const handlers: EventHandler[] = [
  new ClickHandler(),
  new KeyboardHandler(),
  new MouseHandler()
];

handlers.forEach(handler => {
  processEvent(handler, 'тестовое событие');
});
```

## Практическое применение в фронтенд-разработке

### 1. Компонентная система

```typescript
interface Component {
  render(): string;
  update(props: any): void;
}

class ButtonComponent implements Component {
  private text: string;
  private onClick: () => void;

  constructor(text: string, onClick: () => void) {
    this.text = text;
    this.onClick = onClick;
  }

  render(): string {
    return `<button onclick="${this.onClick}">${this.text}</button>`;
  }

  update(props: { text?: string, onClick?: () => void }): void {
    if (props.text) this.text = props.text;
    if (props.onClick) this.onClick = props.onClick;
  }
}

class InputComponent implements Component {
  private value: string;
  private type: string;

  constructor(value: string, type: string = 'text') {
    this.value = value;
    this.type = type;
  }

  render(): string {
    return `<input type="${this.type}" value="${this.value}" />`;
  }

  update(props: { value?: string, type?: string }): void {
    if (props.value) this.value = props.value;
    if (props.type) this.type = props.type;
  }
}

class TextComponent implements Component {
  private content: string;

  constructor(content: string) {
    this.content = content;
  }

  render(): string {
    return `<p>${this.content}</p>`;
  }

  update(props: { content?: string }): void {
    if (props.content) this.content = props.content;
  }
}

// Фреймворк может работать с любыми компонентами через единый интерфейс
class ComponentRenderer {
  private components: Component[] = [];

  addComponent(component: Component): void {
    this.components.push(component);
  }

  renderAll(): string {
    return this.components.map(comp => comp.render()).join('');
  }

  updateAll(props: any[]): void {
    this.components.forEach((comp, index) => {
      comp.update(props[index]);
    });
  }
}
```

### 2. API сервисы с разными реализациями

```typescript
interface ApiService {
  getData<T>(endpoint: string): Promise<T>;
  postData<T>(endpoint: string, data: any): Promise<T>;
}

class RestApiService implements ApiService {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async getData<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}/${endpoint}`);
    return response.json();
  }

  async postData<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseUrl}/${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}

class MockApiService implements ApiService {
  private mockData: { [key: string]: any } = {
    'users': [{ id: 1, name: 'Алексей' }, { id: 2, name: 'Мария' }],
    'products': [{ id: 1, name: 'Ноутбук', price: 50000 }]
  };

  async getData<T>(endpoint: string): Promise<T> {
    return new Promise(resolve => {
      setTimeout(() => resolve(this.mockData[endpoint]), 100);
    });
  }

  async postData<T>(endpoint: string, data: any): Promise<T> {
    console.log(`Мок-данные POST для ${endpoint}:`, data);
    return new Promise(resolve => setTimeout(() => resolve(data as T), 100));
  }
}

// Единая функция может работать с разными реализациями API
function useApi(apiService: ApiService) {
  return {
    getUsers: () => apiService.getData<any[]>('users'),
    getProducts: () => apiService.getData<any[]>('products'),
    createUser: (user: any) => apiService.postData('users', user)
  };
}

// В зависимости от окружения можно использовать разные реализации
const apiService: ApiService = process.env.NODE_ENV === 'production' 
  ? new RestApiService('https://api.example.com') 
  : new MockApiService();

const api = useApi(apiService);
```

### 3. Стратегия рендеринга

```typescript
interface Renderer {
  render(data: any): string;
}

class HTMLRenderer implements Renderer {
  render(data: any): string {
    return `<div class="html-content">${JSON.stringify(data)}</div>`;
  }
}

class JSONRenderer implements Renderer {
  render(data: any): string {
    return JSON.stringify(data, null, 2);
  }
}

class ChartRenderer implements Renderer {
  render(data: any): string {
    // В реальном приложении здесь будет логика рендеринга диаграммы
    return `<canvas class="chart">График на основе ${JSON.stringify(data)}</canvas>`;
  }
}

class DataVisualizer {
  private renderer: Renderer;

  constructor(renderer: Renderer) {
    this.renderer = renderer;
  }

  visualize(data: any): string {
    return this.renderer.render(data);
  }

  // Возможность смены стратегии рендеринга
  setRenderer(renderer: Renderer): void {
    this.renderer = renderer;
  }
}

// Использование разных стратегий рендеринга для одних и тех же данных
const data = { sales: [100, 150, 200], profit: [20, 30, 40] };

const htmlVisualizer = new DataVisualizer(new HTMLRenderer());
const jsonVisualizer = new DataVisualizer(new JSONRenderer());
const chartVisualizer = new DataVisualizer(new ChartRenderer());

console.log('HTML:', htmlVisualizer.visualize(data));
console.log('JSON:', jsonVisualizer.visualize(data));
console.log('Chart:', chartVisualizer.visualize(data));
```

## Преимущества полиморфизма

- **Гибкость** - возможность использовать разные реализации через единый интерфейс
- **Расширяемость** - легко добавлять новые типы, не изменяя существующий код
- **Поддерживаемость** - уменьшение связанности между компонентами
- **Тестируемость** - возможность подставлять mock-объекты для тестирования

## Заключение

Полиморфизм позволяет создавать гибкие и расширяемые системы, где разные объекты могут обрабатываться одинаково через общий интерфейс. В фронтенд-разработке полиморфизм особенно полезен при создании компонентных систем, API-сервисов и стратегий обработки данных.

Для полного понимания ООП также рекомендуется изучить другие концепции: [[Классы-и-объекты]], [[Наследование]], [[Инкапсуляция]] и [[Абстракция]].
