---
aliases: [ООП, OOP]
tags: [programming, frontend, javascript, paradigm]
---

# Объектно-ориентированное программирование

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, основанная на понятии "объектов", которые содержат данные (атрибуты) и код (методы). ООП организует код вокруг объектов, а не функций и логики.

## Основные принципы ООП

### 1. Инкапсуляция

**Инкапсуляция** — это принцип сокрытия внутренней реализации объекта от внешнего мира. Она позволяет контролировать доступ к данным и методам объекта.

```javascript
class User {
  #name; // приватное поле (ES2022+)
  #email;
  
  constructor(name, email) {
    this.#name = name;
    this.#email = email;
  }
  
  getName() {
    return this.#name;
  }
  
  setName(name) {
    if (typeof name === 'string' && name.length > 0) {
      this.#name = name;
    }
  }
  
  // Публичный метод
  getPublicInfo() {
    return {
      name: this.#name,
      email: this.#email
    };
  }
}
```

### 2. Наследование

**Наследование** позволяет создавать новые классы на основе существующих, наследуя их свойства и методы.

```javascript
class Component {
  constructor(elementId) {
    this.element = document.getElementById(elementId);
    this.state = {};
  }
  
  render() {
    // Базовая логика рендеринга
    console.log('Рендеринг компонента');
  }
  
  update() {
    // Базовая логика обновления
    this.render();
  }
}

// Наследование
class Button extends Component {
  constructor(elementId, text) {
    super(elementId); // Вызов конструктора родителя
    this.text = text;
  }
  
  render() {
    if (this.element) {
      this.element.textContent = this.text;
    }
  }
  
  onClick(callback) {
    this.element.addEventListener('click', callback);
  }
}
```

### 3. Полиморфизм

**Полиморфизм** позволяет объектам разных классов использовать один и тот же интерфейс, но реализовывать его по-разному.

```javascript
class Shape {
  area() {
    throw new Error('Метод area() должен быть реализован');
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

// Полиморфное использование
const shapes = [
  new Rectangle(5, 3),
  new Circle(4),
  new Rectangle(2, 8)
];

shapes.forEach(shape => console.log(shape.area()));
```

### 4. Абстракция

**Абстракция** — это процесс сокрытия сложных реализаций и показа только важных характеристик объекта.

```javascript
class ApiClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  
  // Абстрактный метод для выполнения запросов
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
  
  // Конкретные методы, использующие абстрактный метод
  async get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }
  
  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}
```

## Применение в фронтенд-разработке

### Компоненты интерфейса

```javascript
class Modal {
  constructor(selector) {
    this.element = document.querySelector(selector);
    this.isOpen = false;
  }
  
  open() {
    this.element.style.display = 'block';
    this.isOpen = true;
    this.onOpen();
  }
  
  close() {
    this.element.style.display = 'none';
    this.isOpen = false;
    this.onClose();
  }
  
  onOpen() {
    // Метод может быть переопределен в подклассах
  }
  
  onClose() {
    // Метод может быть переопределен в подклассах
  }
}

// Конкретные типы модальных окон
class ConfirmationModal extends Modal {
  onOpen() {
    console.log('Открыто модальное окно подтверждения');
  }
  
  onClose() {
    console.log('Закрыто модальное окно подтверждения');
  }
}
```

### Управление состоянием

```javascript
class StateManager {
  constructor(initialState = {}) {
    this.state = { ...initialState };
    this.listeners = [];
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notifyListeners();
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  notifyListeners() {
    this.listeners.forEach(listener => listener(this.getState()));
  }
}

// Расширение для специфичного поведения
class TodoManager extends StateManager {
  constructor() {
    super({ todos: [] });
  }
  
  addTodo(text) {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false
    };
    
    this.setState({
      todos: [...this.state.todos, newTodo]
    });
  }
  
  toggleTodo(id) {
    const todos = this.state.todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    );
    
    this.setState({ todos });
  }
}
```

## Преимущества в фронтенде

- **Организация кода**: логически связанные методы и свойства группируются вместе
- **Повторное использование**: наследование позволяет переиспользовать код
- **Поддерживаемость**: изменения в одном классе не влияют на другие
- **Читаемость**: код легче понимать и документировать

## Современные подходы

### ES6 Классы

```javascript
class FormValidator {
  constructor(formElement) {
    this.form = formElement;
    this.rules = new Map();
  }
  
  addRule(fieldName, validatorFn) {
    if (!this.rules.has(fieldName)) {
      this.rules.set(fieldName, []);
    }
    this.rules.get(fieldName).push(validatorFn);
  }
  
  validate() {
    const errors = {};
    
    for (const [fieldName, validators] of this.rules) {
      const field = this.form.elements[fieldName];
      if (field) {
        for (const validator of validators) {
          const error = validator(field.value);
          if (error) {
            errors[fieldName] = error;
            break;
          }
        }
      }
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }
}
```

### Прототипное наследование

```javascript
// Создание через функцию-конструктор
function FormValidator(formElement) {
  this.form = formElement;
  this.rules = {};
}

FormValidator.prototype.addRule = function(fieldName, validatorFn) {
  if (!this.rules[fieldName]) {
    this.rules[fieldName] = [];
  }
  this.rules[fieldName].push(validatorFn);
};

FormValidator.prototype.validate = function() {
  // Реализация валидации
  return this._performValidation();
};
```

## Связанные концепции

- [[Инкапсуляция]] - один из основных принципов ООП
- [[Наследование]] - механизм для создания новых классов
- [[Полиморфизм]] - возможность использования объектов разных типов через общий интерфейс
- [[Абстракция]] - скрытие сложной реализации
- [[Компонентный-подход]] - часто реализуется с помощью ООП-принципов
- [[Модульность]] - ООП способствует модульной организации кода

## Лучшие практики

1. **Следуйте принципам SOLID** - создавайте гибкие и поддерживаемые системы
2. **Используйте наследование осознанно** - не злоупотребляйте им
3. **Предпочитайте композицию наследованию** - когда это уместно
4. **Создавайте четкие интерфейсы** - документируйте публичные методы
5. **Используйте модификаторы доступа** - для лучшей инкапсуляции

## Заключение

Объектно-ориентированное программирование остается важным подходом в фронтенд-разработке, особенно при создании сложных интерфейсов и архитектур. Понимание его принципов помогает создавать более структурированный и поддерживаемый код.