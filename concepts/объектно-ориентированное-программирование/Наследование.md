---
aliases: [Наследование в OOP, Extends, Наследование классов]
tags: [programming, oop, javascript, typescript, frontend, inheritance, extends]
---

# Наследование

**Наследование** - одна из ключевых концепций объектно-ориентированного программирования, позволяющая создавать новые классы на основе существующих. Новый класс (дочерний) наследует свойства и методы родительского класса, что способствует повторному использованию кода и созданию иерархии классов.

## Основные понятия

- **Родительский класс (superclass)** - класс, на основе которого создается другой класс
- **Дочерний класс (subclass)** - класс, который наследует от родительского класса
- **Наследование реализуется с помощью ключевого слова `extends`** в JavaScript и TypeScript

## Преимущества наследования

- **Повторное использование кода** - дочерний класс может использовать методы и свойства родительского класса
- **Расширение функциональности** - дочерний класс может добавлять новые методы и свойства
- **Изменение поведения** - дочерний класс может переопределять методы родительского класса
- **Создание иерархий** - позволяет организовать код в логическую структуру

## Примеры в JavaScript и TypeScript

### Простое наследование в JavaScript

```javascript
// Родительский класс
class Animal {
  constructor(name, species) {
    this.name = name;
    this.species = species;
  }

  makeSound() {
    return `${this.name} издает звук`;
  }

  getInfo() {
    return `Животное: ${this.name}, Вид: ${this.species}`;
  }
}

// Дочерний класс
class Dog extends Animal {
  constructor(name, breed) {
    // Вызов конструктора родительского класса
    super(name, 'Собака');
    this.breed = breed;
  }

  // Переопределение метода
  makeSound() {
    return `${this.name} лает: Гав-гав!`;
  }

  // Добавление нового метода
  fetch() {
    return `${this.name} принесает палку`;
  }
}

const myDog = new Dog('Бобик', 'Лабрадор');
console.log(myDog.getInfo()); // Животное: Бобик, Вид: Собака
console.log(myDog.makeSound()); // Бобик лает: Гав-гав!
console.log(myDog.fetch()); // Бобик принесает палку
```

### Наследование в TypeScript с типами

```typescript
// Родительский класс
class Vehicle {
  protected brand: string;
  protected model: string;
  protected year: number;

  constructor(brand: string, model: string, year: number) {
    this.brand = brand;
    this.model = model;
    this.year = year;
  }

  getVehicleInfo(): string {
    return `${this.year} ${this.brand} ${this.model}`;
  }

  start(): void {
    console.log(`${this.getVehicleInfo()} запускается`);
  }
}

// Дочерний класс
class Car extends Vehicle {
  private doors: number;

  constructor(brand: string, model: string, year: number, doors: number) {
    super(brand, model, year); // Вызов конструктора родительского класса
    this.doors = doors;
  }

  // Переопределение метода
  start(): void {
    console.log(`${this.getVehicleInfo()} заводится с помощью ключа`);
  }

  // Новый метод
  openTrunk(): void {
    console.log('Багажник открыт');
  }
}

// Еще один дочерний класс
class Motorcycle extends Vehicle {
  private engineType: string;

  constructor(brand: string, model: string, year: number, engineType: string) {
    super(brand, model, year);
    this.engineType = engineType;
  }

  // Переопределение метода
  start(): void {
    console.log(`${this.getVehicleInfo()} заводится с помощью кнопки`);
  }

  wheelie(): void {
    console.log('Мотоцикл делает вилли!');
  }
}

const myCar = new Car('Toyota', 'Camry', 2022, 4);
const myMotorcycle = new Motorcycle('Yamaha', 'R1', 2023, '4-цилиндровый');

myCar.start(); // Toyota Camry 2022 заводится с помощью ключа
myMotorcycle.start(); // Yamaha R1 2023 заводится с помощью кнопки
```

### Использование абстрактных классов

```typescript
abstract class Shape {
  protected color: string;

  constructor(color: string) {
    this.color = color;
  }

  // Абстрактный метод, который должен быть реализован в дочерних классах
  abstract calculateArea(): number;

  // Общий метод для всех фигур
  getColor(): string {
    return this.color;
  }
}

class Circle extends Shape {
  private radius: number;

  constructor(color: string, radius: number) {
    super(color);
    this.radius = radius;
  }

  // Реализация абстрактного метода
  calculateArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  private width: number;
  private height: number;

  constructor(color: string, width: number, height: number) {
    super(color);
    this.width = width;
    this.height = height;
  }

  // Реализация абстрактного метода
  calculateArea(): number {
    return this.width * this.height;
  }
}

const circle = new Circle('красный', 5);
const rectangle = new Rectangle('синий', 4, 6);

console.log(`Площадь круга: ${circle.calculateArea()}`); // Площадь круга: 78.53981633974483
console.log(`Площадь прямоугольника: ${rectangle.calculateArea()}`); // Площадь прямоугольника: 24
```

## Практическое применение в фронтенд-разработке

### 1. Компонентная архитектура

```typescript
abstract class Component {
  protected element: HTMLElement;

  constructor(selector: string) {
    this.element = document.querySelector(selector) as HTMLElement;
  }

  abstract render(): void;

  public show(): void {
    this.element.style.display = 'block';
  }

  public hide(): void {
    this.element.style.display = 'none';
  }
}

class ButtonComponent extends Component {
  private text: string;

  constructor(selector: string, text: string) {
    super(selector);
    this.text = text;
  }

  render(): void {
    this.element.innerHTML = `<button>${this.text}</button>`;
  }
}

class ModalComponent extends Component {
  constructor(selector: string) {
    super(selector);
  }

  render(): void {
    this.element.innerHTML = `
      <div class="modal">
        <div class="modal-content">
          <span class="close">&times;</span>
          <p>Содержимое модального окна</p>
        </div>
      </div>
    `;
  }
}
```

### 2. Службы с различными реализациями

```typescript
abstract class ApiService {
  protected baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  abstract getData<T>(endpoint: string): Promise<T>;
  abstract postData<T>(endpoint: string, data: any): Promise<T>;

  protected async request<T>(url: string, options?: RequestInit): Promise<T> {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`Ошибка запроса: ${response.status}`);
    }
    return response.json();
  }
}

class UserApiService extends ApiService {
  async getData<T>(endpoint: string): Promise<T> {
    return this.request<T>(`${this.baseUrl}/users/${endpoint}`);
  }

  async postData<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(`${this.baseUrl}/users/${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
  }
}

class ProductApiService extends ApiService {
  async getData<T>(endpoint: string): Promise<T> {
    return this.request<T>(`${this.baseUrl}/products/${endpoint}`);
  }

  async postData<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(`${this.baseUrl}/products/${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
  }
}
```

## Заключение

Наследование - мощный инструмент объектно-ориентированного программирования, позволяющий создавать иерархии классов и повторно использовать код. В фронтенд-разработке наследование помогает создавать структурированные компоненты и сервисы, что упрощает поддержку и расширение приложений.

Однако важно использовать наследование разумно, чтобы не создавать чрезмерно сложные иерархии классов. В некоторых случаях более подходящими могут быть другие паттерны, такие как композиция.

Для полного понимания ООП также рекомендуется изучить другие концепции: [[Классы-и-объекты]], [[Инкапсуляция]], [[Полиморфизм]] и [[Абстракция]].
