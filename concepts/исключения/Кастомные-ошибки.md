---
aliases: ["Пользовательские ошибки", "Кастомные классы ошибок", "Расширение Error"]
tags: [javascript, error-handling, custom-errors, exceptions, oop]
---

# Кастомные ошибки

Кастомные ошибки позволяют создавать специфичные типы исключений, которые делают код более понятным и облегчают диагностику проблем. В JavaScript можно создавать свои классы ошибок, расширяя встроенный объект `Error`.

## Создание базовой кастомной ошибки

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

// Использование
try {
  throw new CustomError('Произошла пользовательская ошибка');
} catch (error) {
  if (error instanceof CustomError) {
    console.log('Перехвачена кастомная ошибка:', error.message);
  }
}
```

## Распространенные типы кастомных ошибок

### Ошибки валидации

```javascript
class ValidationError extends Error {
  constructor(field, message) {
    super(message || `Неверное значение поля: ${field}`);
    this.name = 'ValidationError';
    this.field = field;
  }
}

// Пример использования
function validateEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ValidationError('email', 'Некорректный формат email');
  }
  return true;
}
```

### Ошибки аутентификации

```javascript
class AuthenticationError extends Error {
  constructor(message = 'Требуется аутентификация') {
    super(message);
    this.name = 'AuthenticationError';
    this.status = 401;
  }
}

class AuthorizationError extends Error {
  constructor(message = 'Недостаточно прав для выполнения операции') {
    super(message);
    this.name = 'AuthorizationError';
    this.status = 403;
  }
}
```

### Ошибки API

```javascript
class APIError extends Error {
  constructor(status, message, endpoint) {
    super(message);
    this.name = 'APIError';
    this.status = status;
    this.endpoint = endpoint;
  }
}

class NetworkError extends Error {
  constructor(message = 'Ошибка сети') {
    super(message);
    this.name = 'NetworkError';
    this.retryable = true;
  }
}
```

### Ошибки бизнес-логики

```javascript
class InsufficientFundsError extends Error {
  constructor(balance, requestedAmount) {
    super(`Недостаточно средств: баланс ${balance}, запрошено ${requestedAmount}`);
    this.name = 'InsufficientFundsError';
    this.balance = balance;
    this.requestedAmount = requestedAmount;
  }
}

class UserNotFoundError extends Error {
  constructor(userId) {
    super(`Пользователь с ID ${userId} не найден`);
    this.name = 'UserNotFoundError';
    this.userId = userId;
  }
}
```

## Расширенные кастомные ошибки

### Ошибка с дополнительной информацией

```javascript
class DetailedError extends Error {
  constructor(message, details) {
    super(message);
    this.name = 'DetailedError';
    this.details = details;
    this.timestamp = new Date().toISOString();
    this.stack = new Error().stack; // Сохраняем стек вызовов
  }
}

// Использование
try {
  throw new DetailedError('Ошибка обработки данных', {
    userId: 123,
    action: 'updateProfile',
    input: { name: null }
  });
} catch (error) {
  if (error instanceof DetailedError) {
    console.error('Детали ошибки:', {
      message: error.message,
      details: error.details,
      timestamp: error.timestamp
    });
  }
}
```

### Ошибка с кодом ошибки

```javascript
class ErrorCodeError extends Error {
  constructor(code, message, ...params) {
    super(message);
    this.name = 'ErrorCodeError';
    this.code = code;
    this.params = params;
  }
  
  // Метод для получения перевода сообщения
  getLocalizedMessage(locale = 'ru') {
    const messages = {
      ru: {
        'USER_EXISTS': 'Пользователь уже существует',
        'INVALID_CREDENTIALS': 'Неверные учетные данные',
        'RATE_LIMIT_EXCEEDED': 'Превышен лимит запросов'
      },
      en: {
        'USER_EXISTS': 'User already exists',
        'INVALID_CREDENTIALS': 'Invalid credentials',
        'RATE_LIMIT_EXCEEDED': 'Rate limit exceeded'
      }
    };
    
    return messages[locale][this.code] || this.message;
  }
}

// Использование
try {
  throw new ErrorCodeError('INVALID_CREDENTIALS', 'Неверный логин или пароль');
} catch (error) {
  if (error instanceof ErrorCodeError) {
    console.log('Код ошибки:', error.code);
    console.log('Сообщение:', error.getLocalizedMessage());
  }
}
```

## Практические примеры использования

### Валидация данных с кастомными ошибками

```javascript
class DataValidator {
  static validateUser(userData) {
    const errors = [];
    
    if (!userData.email) {
      errors.push(new ValidationError('email', 'Email обязателен'));
    } else if (!this.isValidEmail(userData.email)) {
      errors.push(new ValidationError('email', 'Некорректный формат email'));
    }
    
    if (!userData.password) {
      errors.push(new ValidationError('password', 'Пароль обязателен'));
    } else if (userData.password.length < 8) {
      errors.push(new ValidationError('password', 'Пароль должен быть не менее 8 символов'));
    }
    
    if (errors.length > 0) {
      throw new AggregateError(errors, 'Валидация не пройдена');
    }
    
    return true;
  }
  
  static isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

// Использование
try {
  DataValidator.validateUser({ email: 'invalid-email', password: '123' });
} catch (error) {
  if (error instanceof AggregateError) {
    console.error('Ошибки валидации:');
    for (const validationError of error.errors) {
      console.error(`- ${validationError.field}: ${validationError.message}`);
    }
  }
}
```

### Использование в асинхронных операциях

```javascript
class AsyncOperationError extends Error {
  constructor(operation, originalError) {
    super(`Ошибка асинхронной операции "${operation}": ${originalError.message}`);
    this.name = 'AsyncOperationError';
    this.operation = operation;
    this.originalError = originalError;
    this.timestamp = new Date().toISOString();
  }
}

async function safeAsyncOperation(operationName, asyncFn) {
  try {
    return await asyncFn();
  } catch (error) {
    throw new AsyncOperationError(operationName, error);
  }
}

// Использование
async function fetchUserData(userId) {
  try {
    const response = await safeAsyncOperation(
      'fetchUserData',
      () => fetch(`/api/users/${userId}`)
    );
    
    if (!response.ok) {
      throw new APIError(response.status, 'Не удалось получить данные пользователя');
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof AsyncOperationError) {
      console.error(`Ошибка в операции "${error.operation}":`, error.originalError.message);
      // Логика обработки ошибки
    }
    throw error;
  }
}
```

### Ошибки с иерархией

```javascript
// Базовая ошибка приложения
class AppError extends Error {
  constructor(message, code = 'APP_ERROR') {
    super(message);
    this.name = 'AppError';
    this.code = code;
  }
}

// Ошибки домена
class DomainError extends AppError {
  constructor(message, code = 'DOMAIN_ERROR') {
    super(message, code);
    this.name = 'DomainError';
  }
}

// Конкретные ошибки домена
class UserDomainError extends DomainError {
  constructor(message, code = 'USER_DOMAIN_ERROR') {
    super(message, code);
    this.name = 'UserDomainError';
  }
}

class PaymentDomainError extends DomainError {
  constructor(message, code = 'PAYMENT_DOMAIN_ERROR') {
    super(message, code);
    this.name = 'PaymentDomainError';
  }
}

// Использование
try {
  throw new PaymentDomainError('Ошибка обработки платежа');
} catch (error) {
  if (error instanceof PaymentDomainError) {
    console.log('Ошибка платежного домена:', error.message);
  } else if (error instanceof DomainError) {
    console.log('Ошибка домена:', error.message);
  } else if (error instanceof AppError) {
    console.log('Ошибка приложения:', error.message);
  }
}
```

## Практические рекомендации

### 1. Используйте осмысленные имена для классов ошибок

```javascript
// Хорошо
class DatabaseConnectionError extends Error { /* ... */ }
class FileUploadError extends Error { /* ... */ }
class CacheMissError extends Error { /* ... */ }

// Плохо
class MyError extends Error { /* ... */ }
class Error1 extends Error { /* ... */ }
```

### 2. Включайте контекстную информацию в ошибки

```javascript
class ProcessingError extends Error {
  constructor(message, context = {}) {
    super(message);
    this.name = 'ProcessingError';
    this.context = context;
  }
}

// Использование
try {
  processPayment(paymentData);
} catch (error) {
  throw new ProcessingError('Ошибка обработки платежа', {
    paymentId: paymentData.id,
    userId: paymentData.userId,
    amount: paymentData.amount,
    timestamp: new Date().toISOString()
  });
}
```

### 3. Создайте фабрику для часто используемых ошибок

```javascript
class ErrorFactory {
  static create(errorType, ...args) {
    const errorMap = {
      validation: (field, message) => new ValidationError(field, message),
      authentication: (message) => new AuthenticationError(message),
      authorization: (message) => new AuthorizationError(message),
      api: (status, message, endpoint) => new APIError(status, message, endpoint),
      network: (message) => new NetworkError(message)
    };
    
    const errorConstructor = errorMap[errorType];
    if (!errorConstructor) {
      throw new Error(`Неизвестный тип ошибки: ${errorType}`);
    }
    
    return errorConstructor(...args);
  }
}

// Использование
const validationError = ErrorFactory.create('validation', 'email', 'Некорректный email');
const authError = ErrorFactory.create('authentication', 'Требуется аутентификация');
```

### 4. Используйте кастомные ошибки для логирования

```javascript
class Logger {
  static logError(error, context = {}) {
    const errorInfo = {
      name: error.name,
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    };
    
    if (error instanceof APIError) {
      errorInfo.status = error.status;
      errorInfo.endpoint = error.endpoint;
    } else if (error instanceof ValidationError) {
      errorInfo.field = error.field;
    }
    
    console.error('ЛОГ ОШИБКИ:', errorInfo);
    
    // Отправка в систему мониторинга
    this.sendToMonitoring(errorInfo);
  }
  
  static sendToMonitoring(errorInfo) {
    // Реализация отправки в систему мониторинга
    fetch('/api/error-log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorInfo)
    }).catch(console.error);
  }
}
```

## Совместимость с современными фреймворками

### В React компонентах

```javascript
import { useState, useEffect } from 'react';

class ComponentError extends Error {
  constructor(componentName, originalError) {
    super(`Ошибка в компоненте ${componentName}: ${originalError.message}`);
    this.name = 'ComponentError';
    this.componentName = componentName;
    this.originalError = originalError;
  }
}

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadUser() {
      try {
        const userData = await fetchUser(userId);
        setUser(userData);
      } catch (err) {
        const componentError = new ComponentError('UserProfile', err);
        setError(componentError);
        Logger.logError(componentError, { userId });
      }
    }

    loadUser();
  }, [userId]);

  if (error) {
    return <div>Ошибка: {error.message}</div>;
  }

  return <div>{/* Рендер профиля */}</div>;
}
```

## Заключение

Кастомные ошибки значительно улучшают читаемость и сопровождаемость кода, позволяя точно определять типы ошибок и обрабатывать их соответствующим образом. Они особенно полезны в крупных приложениях, где важно различать разные виды исключений и реагировать на них по-разному.

См. также:
- [[Обработка-ошибок]]
- [[Try-Catch-Finally]]
- [[Асинхронные-исключения]]
- [[Обработка-ошибок-в-компонентах]]
- [[Логирование]]
- [[Тестирование]]