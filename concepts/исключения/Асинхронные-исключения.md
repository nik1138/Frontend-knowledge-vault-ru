---
aliases: ["Асинхронные исключения", "Обработка ошибок в асинхронном коде", "Async/Await ошибки"]
tags: [javascript, async-await, error-handling, promises, exceptions]
---

# Асинхронные исключения

Асинхронные исключения требуют особого подхода к обработке, поскольку обычные блоки `try-catch` не перехватывают ошибки, возникающие в асинхронных операциях, если они не используются правильно. В JavaScript существует несколько способов обработки асинхронных исключений.

## Проблема асинхронных исключений

Рассмотрим пример, который **не работает**:

```javascript
// НЕПРАВИЛЬНО - ошибка не будет перехвачена
try {
  setTimeout(() => {
    throw new Error('Асинхронная ошибка');
  }, 1000);
} catch (error) {
  console.error('Ошибка перехвачена:', error.message); // Не выполнится
}
```

Функция `setTimeout` выполняется асинхронно, и ошибка выбрасывается уже после завершения блока `try-catch`.

## Обработка асинхронных исключений с Promise

### С использованием .catch()

```javascript
function asyncOperation() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve('Успешный результат');
      } else {
        reject(new Error('Произошла ошибка'));
      }
    }, 1000);
  });
}

// Обработка ошибки через .catch()
asyncOperation()
  .then(result => {
    console.log('Результат:', result);
  })
  .catch(error => {
    console.error('Ошибка в промисе:', error.message);
  });
```

### С использованием async/await

```javascript
async function handleAsyncOperation() {
  try {
    const result = await asyncOperation();
    console.log('Результат:', result);
    return result;
  } catch (error) {
    console.error('Ошибка в асинхронной функции:', error.message);
    throw error; // Перебрасываем ошибку при необходимости
  }
}
```

## Обработка ошибок в цепочках Promise

```javascript
function complexAsyncOperation() {
  return fetch('/api/data')
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ошибка: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.isValid) {
        throw new ValidationError('Данные не прошли валидацию');
      }
      return processData(data);
    })
    .catch(error => {
      if (error instanceof ValidationError) {
        console.error('Ошибка валидации:', error.message);
      } else if (error instanceof TypeError) {
        console.error('Ошибка сети:', error.message);
      } else {
        console.error('Неизвестная ошибка:', error.message);
      }
      // Возвращаем значение по умолчанию или пробрасываем ошибку дальше
      throw error;
    });
}
```

## Обработка ошибок в параллельных операциях

### Promise.all()

```javascript
async function handleMultiplePromises() {
  const promises = [
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments')
  ];

  try {
    // Если хотя бы один промис завершится ошибкой, Promise.all тоже завершится ошибкой
    const results = await Promise.all(promises);
    return results;
  } catch (error) {
    console.error('Ошибка при выполнении одной из операций:', error.message);
    // Возвращаем частичные результаты или значения по умолчанию
    return await Promise.allSettled(promises);
  }
}
```

### Promise.allSettled()

```javascript
async function handleMultiplePromisesWithAllSettled() {
  const promises = [
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments')
  ];

  const results = await Promise.allSettled(promises);
  
  const successfulResults = [];
  const errors = [];
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      successfulResults.push(result.value);
    } else {
      errors.push({
        index,
        error: result.reason
      });
      console.error(`Операция ${index} завершилась ошибкой:`, result.reason.message);
    }
  });
  
  return { successfulResults, errors };
}
```

### Promise.race()

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Таймаут запроса')), timeout);
  });

  try {
    const response = await Promise.race([
      fetch(url),
      timeoutPromise
    ]);
    
    return response;
  } catch (error) {
    if (error.message === 'Таймаут запроса') {
      console.error('Запрос превысил время ожидания');
    } else {
      console.error('Ошибка запроса:', error.message);
    }
    throw error;
  }
}
```

## Обработка ошибок в циклах с асинхронными операциями

```javascript
async function processItems(items) {
  const results = [];
  const errors = [];

  for (const item of items) {
    try {
      const result = await processItem(item);
      results.push(result);
    } catch (error) {
      errors.push({
        item,
        error: error.message
      });
      console.error(`Ошибка при обработке элемента:`, error.message);
      // Продолжаем обработку следующего элемента
    }
  }

  return { results, errors };
}
```

## Глобальная обработка асинхронных ошибок

### В браузере

```javascript
// Обработка неперехваченных асинхронных ошибок
window.addEventListener('unhandledrejection', event => {
  console.error('Неперехваченная асинхронная ошибка:', event.reason);
  
  // Отправка ошибки в систему мониторинга
  if (typeof window !== 'undefined') {
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'unhandledrejection',
        message: event.reason.message || String(event.reason),
        stack: event.reason.stack,
        timestamp: new Date().toISOString()
      })
    }).catch(console.error);
  }
  
  // Предотвращение вывода ошибки в консоль по умолчанию (опционально)
  // event.preventDefault();
});

// Обработка ошибок, не перехваченных в синхронном коде
window.addEventListener('error', event => {
  console.error('Неперехваченная ошибка:', event.error);
});
```

### В Node.js

```javascript
// Обработка неперехваченных асинхронных ошибок
process.on('unhandledRejection', (reason, promise) => {
  console.error('Неперехваченная асинхронная ошибка:', {
    reason: reason.message || String(reason),
    stack: reason.stack,
    promise: promise
  });
  
  // В продакшене может потребоваться завершение процесса
  // process.exit(1);
});

// Обработка ошибок, не перехваченных в синхронном коде
process.on('uncaughtException', (error) => {
  console.error('Неперехваченная синхронная ошибка:', error);
  process.exit(1);
});
```

## Практические рекомендации

### 1. Используйте async/await для лучшей читаемости

```javascript
// Менее читаемо
fetch('/api/data')
  .then(response => response.json())
  .then(data => {
    if (!data.isValid) {
      throw new Error('Невалидные данные');
    }
    return processData(data);
  })
  .catch(error => console.error('Ошибка:', error.message));

// Более читаемо
async function handleData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    
    if (!data.isValid) {
      throw new Error('Невалидные данные');
    }
    
    return await processData(data);
  } catch (error) {
    console.error('Ошибка:', error.message);
  }
}
```

### 2. Создайте универсальную функцию для обработки асинхронных операций

```javascript
async function safeAsyncOperation(operation, options = {}) {
  const { retries = 3, delay = 1000, onError = null } = options;
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.warn(`Попытка ${attempt} не удалась:`, error.message);
      
      if (onError) {
        onError(error, attempt);
      }
      
      if (attempt === retries) {
        throw error; // Все попытки исчерпаны
      }
      
      // Ждем перед следующей попыткой
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Использование
const result = await safeAsyncOperation(
  () => fetch('/api/data').then(res => res.json()),
  {
    retries: 3,
    delay: 2000,
    onError: (error, attempt) => {
      console.log(`Ошибка при попытке ${attempt}:`, error.message);
    }
  }
);
```

### 3. Обработка ошибок в React компонентах

```javascript
import { useState, useEffect } from 'react';

function DataComponent({ userId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          throw new Error(`HTTP ошибка: ${response.status}`);
        }
        
        const userData = await response.json();
        setData(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    if (userId) {
      fetchData();
    }
  }, [userId]);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  
  return <div>{/* Рендер данных */}</div>;
}
```

## Заключение

Обработка асинхронных исключений требует особого внимания, так как стандартные механизмы `try-catch` не работают с асинхронным кодом без использования `async/await`. Важно использовать подходящие методы в зависимости от ситуации: `.catch()` для цепочек Promise, `try-catch` с `await` для асинхронных функций, и глобальные обработчики для отлова неперехваченных ошибок.

См. также:
- [[Try-Catch-Finally]]
- [[Обработка-ошибок]]
- [[Кастомные-ошибки]]
- [[Обработка-ошибок-в-компонентах]]
- [[Promise]]
- [[Async-Await]]