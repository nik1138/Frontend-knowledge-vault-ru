---
aliases: [Object-Properties, Properties-of-Objects, Свойства-объектов]
tags: [javascript, programming, objects, frontend]
---

# Объекты и их свойства

Свойства объектов - это основа структурирования данных в JavaScript. Понимание различных типов свойств, способов их определения и управления ими критически важно для эффективного программирования.

## Типы свойств

### Свойства данных (data properties)

Свойства данных содержат значение и имеют следующие атрибуты:
- `value` - значение свойства
- `writable` - можно ли изменить значение
- `enumerable` - перечисляется ли свойство в циклах
- `configurable` - можно ли изменить атрибуты или удалить свойство

```javascript
const obj = {};
Object.defineProperty(obj, 'name', {
  value: 'Иван',
  writable: true,
  enumerable: true,
  configurable: true
});

console.log(obj.name); // 'Иван'

// Проверка атрибутов свойства
const descriptor = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(descriptor);
// {
//   value: 'Иван',
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

### Свойства-аксессоры (accessor properties)

Свойства-аксессоры определяются с помощью геттеров и сеттеров:

```javascript
const person = {
  firstName: 'Иван',
  lastName: 'Иванов',
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(value) {
    const parts = value.split(' ');
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
};

console.log(person.fullName); // 'Иван Иванов'
person.fullName = 'Петр Петров';
console.log(person.firstName); // 'Петр'
console.log(person.lastName); // 'Петров'
```

## Определение свойств

### Литеральный синтаксис

```javascript
const obj = {
  // Свойство данных
  name: 'Иван',
  
  // Метод (тоже свойство данных)
  greet() {
    return `Привет, ${this.name}`;
  },
  
  // Вычисляемое имя свойства
  ['computed_' + Date.now()]: 'значение',
  
  // Свойство-аксессор в литерале (ES2015+)
  get age() {
    return this._age || 0;
  },
  set age(value) {
    this._age = value > 0 ? value : 0;
  }
};
```

### Object.defineProperty()

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'Иван',
  writable: true,
  enumerable: true,
  configurable: true
});

// Свойство только для чтения
Object.defineProperty(obj, 'id', {
  value: 12345,
  writable: false, // нельзя изменить
  enumerable: true,
  configurable: false // нельзя изменить атрибуты или удалить
});

// Свойство-аксессор
Object.defineProperty(obj, 'description', {
  get() {
    return `${this.name} (ID: ${this.id})`;
  },
  set(value) {
    const [name, idStr] = value.split(' (ID: ');
    this.name = name;
    this.id = parseInt(idStr);
  },
  enumerable: true,
  configurable: true
});

console.log(obj.description); // 'Иван (ID: 12345)'
```

### Object.defineProperties()

```javascript
const obj = {};

Object.defineProperties(obj, {
  name: {
    value: 'Иван',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: true,
    enumerable: true,
    configurable: true
  },
  adult: {
    get() {
      return this.age >= 18;
    },
    enumerable: true,
    configurable: true
  }
});

console.log(obj.adult); // true
```

## Перечисляемость свойств

### enumerable атрибут

```javascript
const obj = {};
Object.defineProperty(obj, 'public', {
  value: 'публичное свойство',
  enumerable: true
});
Object.defineProperty(obj, 'private', {
  value: 'приватное свойство',
  enumerable: false
});

// Цикл for...in перебирает только enumerable свойства
for (let key in obj) {
  console.log(key); // 'public' (только)
}

// Object.keys() тоже возвращает только enumerable свойства
console.log(Object.keys(obj)); // ['public']

// Object.getOwnPropertyNames() возвращает все свойства
console.log(Object.getOwnPropertyNames(obj)); // ['public', 'private']

// Object.getOwnPropertyDescriptors() возвращает все дескрипторы
console.log(Object.getOwnPropertyDescriptors(obj));
```

## Наследование свойств

### Прототипное наследование

```javascript
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  return `${this.name} издает звук`;
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Свойства экземпляра
const dog = new Dog('Рекс', 'Лабрадор');
console.log(dog.name); // 'Рекс' (свойство экземпляра)
console.log(dog.breed); // 'Лабрадор' (свойство экземпляра)

// Наследуемые свойства
console.log(dog.speak()); // 'Рекс издает звук' (унаследованный метод)

// Проверка принадлежности свойства
console.log(dog.hasOwnProperty('name')); // true
console.log(dog.hasOwnProperty('speak')); // false
console.log('speak' in dog); // true (наследуемое свойство)
```

### Проверка свойств

```javascript
const obj = { name: 'Иван' };
obj.__proto__.age = 30; // добавляем в прототип

// Проверка существования свойства
console.log('name' in obj); // true
console.log('age' in obj); // true (наследуемое)

// Проверка собственного свойства
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('age')); // false

// Современный способ проверки свойства
console.log(Object.hasOwn(obj, 'name')); // true
console.log(Object.hasOwn(obj, 'age')); // false
```

## Специальные свойства и символы

### Symbol-свойства

```javascript
const id = Symbol('id');
const name = Symbol('name');

const obj = {
  [id]: 12345,
  [name]: 'Иван',
  regular: 'обычное свойство'
};

// Symbol-свойства не перечисляются в for...in
for (let key in obj) {
  console.log(key); // 'regular' (только)
}

// Object.keys() не возвращает Symbol-свойства
console.log(Object.keys(obj)); // ['regular']

// Object.getOwnPropertyNames() не возвращает Symbol-свойства
console.log(Object.getOwnPropertyNames(obj)); // ['regular']

// Object.getOwnPropertySymbols() возвращает только Symbol-свойства
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id), Symbol(name)]

// Reflect.ownKeys() возвращает все ключи (включая Symbol)
console.log(Reflect.ownKeys(obj)); // ['regular', Symbol(id), Symbol(name)]
```

### Скрытые свойства и приватные поля (ES2022+)

```javascript
class Person {
  // Приватное поле (не свойство в традиционном смысле)
  #name;
  #age;
  
  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }
  
  getName() {
    return this.#name;
  }
  
  getAge() {
    return this.#age;
  }
  
  setAge(age) {
    if (age > 0) {
      this.#age = age;
    }
  }
}

const person = new Person('Иван', 30);
// console.log(person.#name); // Ошибка - приватное поле
console.log(person.getName()); // 'Иван'
```

## Методы для работы со свойствами

### Object.keys(), Object.values(), Object.entries()

```javascript
const obj = {
  name: 'Иван',
  age: 30,
  city: 'Москва'
};

console.log(Object.keys(obj)); // ['name', 'age', 'city']
console.log(Object.values(obj)); // ['Иван', 30, 'Москва']
console.log(Object.entries(obj)); // [['name', 'Иван'], ['age', 30], ['city', 'Москва']]

// Использование в циклах
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}
```

### Object.getOwnPropertyNames() и Object.getOwnPropertyDescriptors()

```javascript
const obj = {};
Object.defineProperty(obj, 'name', {
  value: 'Иван',
  writable: true,
  enumerable: true,
  configurable: true
});
Object.defineProperty(obj, 'id', {
  value: 12345,
  writable: false,
  enumerable: false,
  configurable: false
});

console.log(Object.getOwnPropertyNames(obj)); // ['name', 'id']
console.log(Object.getOwnPropertyDescriptors(obj));
// {
//   name: { value: 'Иван', writable: true, enumerable: true, configurable: true },
//   id: { value: 12345, writable: false, enumerable: false, configurable: false }
// }
```

### Object.getPrototypeOf() и Object.setPrototypeOf()

```javascript
function Parent() {
  this.parentProp = 'родительское свойство';
}
Parent.prototype.parentMethod = function() {
  return 'родительский метод';
};

function Child() {
  Parent.call(this);
  this.childProp = 'дочернее свойство';
}
Child.prototype = Object.create(Parent.prototype);

const child = new Child();

console.log(Object.getPrototypeOf(child) === Child.prototype); // true
console.log(Object.getPrototypeOf(Child.prototype) === Parent.prototype); // true

// Проверка цепочки прототипов
console.log(child.parentMethod()); // 'родительский метод'
```

## Защита объектов

### Object.freeze()

```javascript
const obj = {
  name: 'Иван',
  details: {
    age: 30
  }
};

Object.freeze(obj);

// Изменения основных свойств игнорируются (в non-strict mode)
obj.name = 'Петр';
obj.newProp = 'новое свойство';
delete obj.name;

console.log(obj.name); // 'Иван' - не изменилось
console.log(obj.newProp); // undefined

// Вложенные объекты всё ещё изменяемы!
obj.details.age = 31;
console.log(obj.details.age); // 31

// Глубокая заморозка
function deepFreeze(obj) {
  Object.getOwnPropertyNames(obj).forEach(prop => {
    if (obj[prop] !== null && typeof obj[prop] === 'object') {
      deepFreeze(obj[prop]);
    }
  });
  return Object.freeze(obj);
}

const deepObj = deepFreeze({
  name: 'Иван',
  details: {
    age: 30
  }
});

// Теперь вложенные свойства тоже защищены
deepObj.details.age = 25;
console.log(deepObj.details.age); // 30 - не изменилось
```

### Object.seal()

```javascript
const obj = {
  name: 'Иван'
};

Object.seal(obj);

// Изменять существующие свойства можно
obj.name = 'Петр';
console.log(obj.name); // 'Петр'

// Нельзя добавлять новые свойства
obj.newProp = 'новое свойство';
console.log(obj.newProp); // undefined

// Нельзя удалять свойства
delete obj.name;
console.log(obj.name); // 'Петр' - всё ещё существует

console.log(Object.isSealed(obj)); // true
```

### Object.preventExtensions()

```javascript
const obj = {
  name: 'Иван'
};

Object.preventExtensions(obj);

// Можно изменять существующие свойства
obj.name = 'Петр';

// Нельзя добавлять новые свойства
obj.newProp = 'новое свойство';
console.log(obj.newProp); // undefined

console.log(Object.isExtensible(obj)); // false
```

## Расширение объектов

### Object.assign()

```javascript
const target = { a: 1, b: 2 };
const source1 = { b: 4, c: 5 };
const source2 = { c: 6, d: 7 };

const result = Object.assign(target, source1, source2);

console.log(result); // { a: 1, b: 4, c: 6, d: 7 }
console.log(target); // { a: 1, b: 4, c: 6, d: 7 } - изменён!

// Копирование объекта
const original = { name: 'Иван', age: 30 };
const copy = Object.assign({}, original);

// Объединение нескольких объектов
const combined = Object.assign(
  { type: 'user' },
  original,
  { timestamp: Date.now() }
);
```

### Spread-оператор

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

// Объединение объектов
const combined = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// Переопределение свойств
const modified = { ...obj1, b: 20, e: 5 }; // { a: 1, b: 20, e: 5 }

// Копирование объекта
const copy = { ...original };

// Работа с массивами (преобразование в объект)
const arr = [1, 2, 3];
const objFromArr = { ...arr }; // { '0': 1, '1': 2, '2': 3 }

// Копирование с преобразованием
const original = { name: 'Иван', age: 30 };
const withDefaults = { 
  role: 'user', 
  permissions: [], 
  ...original 
};
```

## Практические применения

### Создание объекта конфигурации

```javascript
function createConfig(defaults, userConfig = {}) {
  return Object.freeze({
    ...defaults,
    ...userConfig,
    // Обработка специфичных свойств
    features: {
      ...defaults.features,
      ...(userConfig.features || {})
    }
  });
}

const defaultConfig = Object.freeze({
  api: {
    baseUrl: 'https://api.example.com',
    timeout: 5000
  },
  ui: {
    theme: 'light',
    language: 'en'
  },
  features: {
    notifications: true,
    darkMode: false
  }
});

const userConfig = {
  ui: {
    theme: 'dark'
  },
  features: {
    darkMode: true
  }
};

const finalConfig = createConfig(defaultConfig, userConfig);
```

### Объекты для валидации

```javascript
const validationRules = {
  email: {
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    message: 'Неверный формат email'
  },
  password: {
    pattern: /^.{6,}$/,
    message: 'Пароль должен содержать минимум 6 символов'
  },
  name: {
    pattern: /^[a-zA-Zа-яА-ЯёЁ\s]+$/,
    message: 'Имя должно содержать только буквы'
  }
};

function validateField(fieldName, value) {
  const rule = validationRules[fieldName];
  if (!rule) return true;
  
  return rule.pattern.test(value);
}

function validateForm(formData) {
  const errors = {};
  
  for (const [field, value] of Object.entries(formData)) {
    if (!validateField(field, value)) {
      errors[field] = validationRules[field].message;
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}
```

### Объекты для управления состоянием

```javascript
class StateManager {
  constructor(initialState = {}) {
    this.state = { ...initialState };
    this.listeners = [];
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(newState) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...newState };
    
    // Уведомляем слушателей об изменении
    this.listeners.forEach(listener => {
      listener(this.state, prevState);
    });
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    // Возвращаем функцию для отписки
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
}

// Использование
const stateManager = new StateManager({
  user: null,
  loading: false,
  error: null
});

const unsubscribe = stateManager.subscribe((newState, prevState) => {
  console.log('Состояние изменилось:', newState);
});
```

## Заключение

Свойства объектов в JavaScript предоставляют мощный и гибкий способ структурирования и управления данными. Понимание различных типов свойств, способов их определения и управления позволяет создавать более надежные и эффективные приложения. Использование современных возможностей языка в сочетании с правильными паттернами проектирования делает код более читаемым и поддерживаемым.

См. также:
- [[Объекты-в-JavaScript]]
- [[Объекты-в-TypeScript]]
- [[Объекты-в-React-компонентах]]
- [[Объекты-в-Vue-компонентах]]
- [[Прототипы-в-JavaScript]]