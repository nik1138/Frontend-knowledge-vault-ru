---
aliases: ["Модель-Представление-Модель представления", "Model-View-ViewModel"]
tags: ["#архитектурный-паттерн", "#frontend", "#data-binding"]
---

# MVVM-паттерн (Model-View-ViewModel)

## Обзор

MVVM (Model-View-ViewModel) - это архитектурный паттерн, разработанный Microsoft для упрощения разработки пользовательских интерфейсов. Он особенно популярен в клиентских JavaScript-фреймворках благодаря встроенной поддержке двустороннего связывания данных.

## Компоненты

### Модель (Model)
- **Отражает бизнес-логику и данные приложения**
- Работает с источниками данных (API, базы данных, локальное хранилище)
- Не зависит от представления и ViewModel

### Представление (View)
- **Определяет структуру, макет и внешний вид пользовательского интерфейса**
- Связывается с ViewModel через декларативные привязки данных
- Отправляет пользовательские действия в ViewModel

### Модель представления (ViewModel)
- **Абстракция представления, содержащая состояние и поведение представления**
- Обеспечивает двустороннюю привязку данных между View и Model
- Реализует команды и события для взаимодействия с View

## Диаграмма взаимодействия

```
[View] <-> [ViewModel] <-> [Model]
```

## Пример реализации на JavaScript

```javascript
// Модель
class UserModel {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  
  updateName(newName) {
    this.name = newName;
  }
  
  updateEmail(newEmail) {
    this.email = newEmail;
  }
}

// Модель представления
class UserViewModel {
  constructor(model) {
    this.model = model;
    this.name = ko.observable(model.name);
    this.email = ko.observable(model.email);
    
    // Связываем изменения в ViewModel с моделью
    this.name.subscribe(value => {
      this.model.updateName(value);
    });
    
    this.email.subscribe(value => {
      this.model.updateEmail(value);
    });
    
    // Команды для взаимодействия с View
    this.saveUser = () => {
      console.log('Сохраняем пользователя:', this.model);
    };
  }
  
  // Методы для обновления состояния
  setName(value) {
    this.name(value);
  }
  
  setEmail(value) {
    this.email(value);
  }
}

// Использование (предполагается наличие Knockout.js или аналогичной библиотеки)
const model = new UserModel('Иван', 'ivan@example.com');
const viewModel = new UserViewModel(model);

// В реальном приложении ViewModel связывается с View через фреймворк
// Например, с использованием Knockout.js:
// ko.applyBindings(viewModel, document.getElementById('userForm'));
```

## Современная реализация с использованием Vue.js

```javascript
// Vue.js компонент, демонстрирующий концепцию MVVM
Vue.component('user-profile', {
  template: `
    <div class="user-profile">
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
      <input v-model="user.name" placeholder="Имя" />
      <input v-model="user.email" placeholder="Email" />
      <button @click="saveUser">Сохранить</button>
    </div>
  `,
  data() {
    return {
      user: {
        name: 'Иван',
        email: 'ivan@example.com'
      }
    };
  },
  methods: {
    saveUser() {
      console.log('Сохраняем пользователя:', this.user);
      // Здесь могла бы быть логика сохранения в API
    }
  }
});
```

## Преимущества

- **Четкое разделение** между UI-логикой и бизнес-логикой
- **Двустороннее связывание данных** упрощает синхронизацию View и Model
- **Упрощение тестирования** - ViewModel можно тестировать независимо от View
- **Повторное использование компонентов** - ViewModel может использоваться с разными View

## Недостатки

- **Сложность для новичков** - требует понимания концепции привязки данных
- **Производительность** - двусторонняя привязка может вызывать лишние перерисовки
- **Отладка** - изменения данных могут происходить в разных местах, усложняя отладку

## Когда использовать

- В приложениях с богатым пользовательским интерфейсом
- Когда необходима синхронизация данных между несколькими элементами UI
- В приложениях, где часто изменяются данные (например, формы)
- В сочетании с фреймворками, поддерживающими привязку данных (Vue.js, Angular, Knockout.js)

## Связанные концепции

- [[Архитектурные-паттерны]] - общее понятие о паттернах архитектуры
- [[MVC-паттерн]] - родительский паттерн для MVVM
- [[Flux-паттерн]] - альтернативный подход к управлению состоянием
- [[Двустороннее-связывание-данных]] - ключевая концепция MVVM
- [[Компонентная-архитектура]] - современный подход к построению UI

## Заключение

MVVM особенно эффективен в приложениях с активным взаимодействием с пользователем, где важна синхронизация данных между представлением и моделью. Он формирует основу для многих современных фреймворков и библиотек.