---
aliases: [Примеры медиатора, Практические примеры, Реальные кейсы медиатора]
tags: [паттерны-проектирования, медиатор, примеры, фронтенд]
---

# Примеры использования паттерна Медиатор

## Обзор

Паттерн Медиатор находит широкое применение в различных сценариях разработки, особенно во фронтенд-приложениях. Ниже приведены практические примеры использования паттерна в реальных ситуациях.

## Пример 1: Чат-приложение

### Сценарий
Реализация чат-приложения с несколькими пользователями, где сообщения должны доставляться всем участникам комнаты.

```javascript
// Медиатор чата
class ChatRoom {
  constructor() {
    this.users = new Map();
  }

  addUser(user) {
    this.users.set(user.id, user);
    user.setChatRoom(this);
    this.broadcast('system', `${user.name} присоединился к чату`, user.id);
  }

  removeUser(userId) {
    const user = this.users.get(userId);
    if (user) {
      this.broadcast('system', `${user.name} покинул чат`, userId);
      this.users.delete(userId);
    }
  }

  sendMessage(message, senderId) {
    const sender = this.users.get(senderId);
    if (sender) {
      this.broadcast('message', {
        text: message,
        sender: sender.name,
        timestamp: new Date()
      }, senderId);
    }
  }

  broadcast(type, content, excludeUserId = null) {
    for (const [userId, user] of this.users) {
      if (userId !== excludeUserId) {
        user.receive(type, content);
      }
    }
  }
}

// Пользователь чата
class ChatUser {
  constructor(id, name) {
    this.id = id;
    this.name = name;
    this.chatRoom = null;
  }

  setChatRoom(chatRoom) {
    this.chatRoom = chatRoom;
  }

  sendMessage(message) {
    if (this.chatRoom) {
      this.chatRoom.sendMessage(message, this.id);
    }
  }

  receive(type, content) {
    console.log(`[${this.name}] Получено ${type}:`, content);
    // Здесь можно обновить UI
  }
}

// Использование
const chatRoom = new ChatRoom();

const user1 = new ChatUser('1', 'Алексей');
const user2 = new ChatUser('2', 'Мария');
const user3 = new ChatUser('3', 'Иван');

chatRoom.addUser(user1);
chatRoom.addUser(user2);
chatRoom.addUser(user3);

user1.sendMessage('Привет всем!');
user2.sendMessage('Привет, Алексей!');
```

## Пример 2: Управление формой с валидацией

### Сценарий
Комплексная форма с несколькими полями, где изменение одного поля может влиять на другие.

```javascript
class FormMediator {
  constructor() {
    this.fields = new Map();
    this.validationRules = new Map();
  }

  registerField(fieldName, fieldComponent) {
    this.fields.set(fieldName, fieldComponent);
    fieldComponent.setMediator(this);
  }

  setValidationRule(fieldName, rule) {
    this.validationRules.set(fieldName, rule);
  }

  notifyFieldChange(fieldName, value) {
    // Валидация поля
    const rule = this.validationRules.get(fieldName);
    let isValid = true;
    let error = null;
    
    if (rule) {
      const result = rule(value);
      isValid = result.isValid;
      error = result.error;
    }

    // Обновление состояния поля
    const field = this.fields.get(fieldName);
    if (field) {
      field.setValidationStatus(isValid, error);
    }

    // Проверка зависимости полей
    this.checkFieldDependencies(fieldName, value);

    // Проверка общей валидности формы
    this.checkFormValidity();
  }

  checkFieldDependencies(changedFieldName, changedValue) {
    // Пример зависимости: если страна = 'Россия', показать российские регионы
    if (changedFieldName === 'country') {
      const regionField = this.fields.get('region');
      if (regionField) {
        if (changedValue === 'Россия') {
          regionField.showRussianRegions();
        } else {
          regionField.showAllRegions();
        }
      }
    }

    // Пример зависимости: если выбрана подписка, показать поле оплаты
    if (changedFieldName === 'subscription') {
      const paymentField = this.fields.get('payment');
      if (paymentField) {
        paymentField.setVisible(!!changedValue);
      }
    }
  }

  checkFormValidity() {
    let isFormValid = true;
    
    for (const [fieldName, field] of this.fields) {
      if (!field.isValid && field.isRequired()) {
        isFormValid = false;
        break;
      }
    }

    // Уведомление кнопки отправки о состоянии валидности
    const submitButton = this.fields.get('submitButton');
    if (submitButton) {
      submitButton.setFormValid(isFormValid);
    }
  }
}

// Компонент поля ввода
class FormField {
  constructor(element, name, isRequired = false) {
    this.element = element;
    this.name = name;
    this.isRequiredValue = isRequired;
    this.mediator = null;
    this.isValid = true;
    this.error = null;
    
    this.element.addEventListener('input', (e) => {
      this.mediator.notifyFieldChange(this.name, e.target.value);
    });
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  setValidationStatus(isValid, error) {
    this.isValid = isValid;
    this.error = error;
    
    if (isValid) {
      this.element.classList.remove('invalid');
      this.element.classList.add('valid');
    } else {
      this.element.classList.remove('valid');
      this.element.classList.add('invalid');
    }
    
    // Показ ошибки
    const errorElement = document.querySelector(`#${this.name}-error`);
    if (errorElement) {
      errorElement.textContent = error || '';
    }
  }

  isRequired() {
    return this.isRequiredValue;
  }
}

// Использование
const formMediator = new FormMediator();

// Регистрация полей
const nameField = new FormField(document.getElementById('name'), 'name', true);
const emailField = new FormField(document.getElementById('email'), 'email', true);
const countryField = new FormField(document.getElementById('country'), 'country', true);
const regionField = new FormField(document.getElementById('region'), 'region', false);
const subscriptionField = new FormField(document.getElementById('subscription'), 'subscription', false);
const paymentField = new FormField(document.getElementById('payment'), 'payment', false);
const submitButton = new FormField(document.getElementById('submit'), 'submitButton', false);

formMediator.registerField('name', nameField);
formMediator.registerField('email', emailField);
formMediator.registerField('country', countryField);
formMediator.registerField('region', regionField);
formMediator.registerField('subscription', subscriptionField);
formMediator.registerField('payment', paymentField);
formMediator.registerField('submitButton', submitButton);

// Установка правил валидации
formMediator.setValidationRule('email', (value) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return {
    isValid: emailRegex.test(value),
    error: emailRegex.test(value) ? null : 'Некорректный email'
  };
});

formMediator.setValidationRule('name', (value) => {
  return {
    isValid: value.length >= 2,
    error: value.length >= 2 ? null : 'Имя должно быть не менее 2 символов'
  };
});
```

## Пример 3: Управление UI-компонентами в админ-панели

### Сценарий
Админ-панель с фильтрами, таблицей данных и элементами управления, которые должны синхронизироваться между собой.

```javascript
class AdminPanelMediator {
  constructor() {
    this.components = new Map();
    this.state = {
      filters: {},
      sort: { field: 'id', direction: 'asc' },
      pagination: { page: 1, limit: 10 },
      selectedItems: []
    };
  }

  registerComponent(name, component) {
    this.components.set(name, component);
    component.setMediator(this);
  }

  updateFilters(newFilters) {
    this.state.filters = { ...this.state.filters, ...newFilters };
    this.refreshData();
  }

  updateSort(field, direction) {
    this.state.sort = { field, direction };
    this.refreshData();
  }

  updatePagination(page, limit) {
    this.state.pagination = { page, limit };
    this.refreshData();
  }

  toggleItemSelection(itemId) {
    const index = this.state.selectedItems.indexOf(itemId);
    if (index > -1) {
      this.state.selectedItems.splice(index, 1);
    } else {
      this.state.selectedItems.push(itemId);
    }
    
    this.notifyComponent('selection', {
      selectedItems: [...this.state.selectedItems]
    });
  }

  selectAllItems(selectAll) {
    if (selectAll) {
      // Выбрать все отображаемые элементы
      const displayedItems = this.getCurrentlyDisplayedItems();
      this.state.selectedItems = [...new Set([...this.state.selectedItems, ...displayedItems])];
    } else {
      // Снять выделение с отображаемых элементов
      const displayedItems = this.getCurrentlyDisplayedItems();
      this.state.selectedItems = this.state.selectedItems.filter(
        id => !displayedItems.includes(id)
      );
    }
    
    this.notifyComponent('selection', {
      selectedItems: [...this.state.selectedItems]
    });
  }

  getCurrentlyDisplayedItems() {
    // В реальном приложении это будет получено из таблицы данных
    return [1, 2, 3, 4, 5]; // Пример
  }

  refreshData() {
    // Уведомление компонентов о необходимости обновления данных
    this.notifyComponent('dataRefresh', {
      filters: this.state.filters,
      sort: this.state.sort,
      pagination: this.state.pagination
    });
  }

  notifyComponent(componentName, data) {
    const component = this.components.get(componentName);
    if (component && typeof component.handleNotification === 'function') {
      component.handleNotification(data);
    }
  }

  getComponent(name) {
    return this.components.get(name);
  }
}

// Компонент фильтров
class FilterComponent {
  constructor(container) {
    this.container = container;
    this.mediator = null;
    this.init();
  }

  init() {
    // Создание элементов фильтрации
    const statusFilter = document.createElement('select');
    statusFilter.id = 'status-filter';
    statusFilter.innerHTML = `
      <option value="">Все статусы</option>
      <option value="active">Активный</option>
      <option value="inactive">Неактивный</option>
    `;
    
    statusFilter.addEventListener('change', (e) => {
      this.mediator.updateFilters({ status: e.target.value });
    });
    
    this.container.appendChild(statusFilter);
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  handleNotification(data) {
    if (data.filters) {
      // Обновление состояния фильтров
      document.getElementById('status-filter').value = data.filters.status || '';
    }
  }
}

// Компонент таблицы
class TableComponent {
  constructor(container) {
    this.container = container;
    this.mediator = null;
    this.data = [];
    this.init();
  }

  init() {
    this.table = document.createElement('table');
    this.table.innerHTML = `
      <thead>
        <tr>
          <th><input type="checkbox" id="select-all"></th>
          <th>Имя</th>
          <th>Email</th>
          <th>Статус</th>
        </tr>
      </thead>
      <tbody id="table-body"></tbody>
    `;
    
    document.getElementById('select-all').addEventListener('change', (e) => {
      this.mediator.selectAllItems(e.target.checked);
    });
    
    this.container.appendChild(this.table);
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  handleNotification(data) {
    if (data.dataRefresh) {
      this.refreshTable(data.dataRefresh);
    }
  }

  refreshTable(refreshData) {
    // В реальном приложении здесь будет AJAX-запрос
    console.log('Обновление таблицы с фильтрами:', refreshData);
    
    // Обновление данных в таблице
    const tbody = document.getElementById('table-body');
    tbody.innerHTML = this.generateTableRows();
  }

  generateTableRows() {
    // Генерация строк таблицы
    return `
      <tr>
        <td><input type="checkbox" data-id="1"></td>
        <td>Иван Иванов</td>
        <td>ivan@example.com</td>
        <td>Активный</td>
      </tr>
      <tr>
        <td><input type="checkbox" data-id="2"></td>
        <td>Мария Петрова</td>
        <td>maria@example.com</td>
        <td>Неактивный</td>
      </tr>
    `;
  }
}

// Использование
const adminMediator = new AdminPanelMediator();

const filterComponent = new FilterComponent(document.getElementById('filters'));
const tableComponent = new TableComponent(document.getElementById('table'));

adminMediator.registerComponent('filters', filterComponent);
adminMediator.registerComponent('table', tableComponent);
```

## Пример 4: Игровой движок с взаимодействием объектов

### Сценарий
Игровой движок, где различные игровые объекты (персонажи, предметы, события) взаимодействуют друг с другом через медиатор.

```javascript
class GameMediator {
  constructor() {
    this.entities = new Map();
    this.eventQueue = [];
  }

  registerEntity(entity) {
    this.entities.set(entity.id, entity);
    entity.setMediator(this);
  }

  unregisterEntity(entityId) {
    this.entities.delete(entityId);
  }

  processCollision(entity1, entity2) {
    // Проверка коллизии между объектами
    if (this.checkCollision(entity1, entity2)) {
      this.handleCollision(entity1, entity2);
    }
  }

  checkCollision(entity1, entity2) {
    // Простая проверка коллизии (в реальном приложении будет сложнее)
    const dx = entity1.x - entity2.x;
    const dy = entity1.y - entity2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < (entity1.radius + entity2.radius);
  }

  handleCollision(entity1, entity2) {
    // Обработка коллизии
    if (entity1.type === 'player' && entity2.type === 'enemy') {
      this.publishEvent('player:hit', { player: entity1, enemy: entity2 });
    } else if (entity1.type === 'player' && entity2.type === 'item') {
      this.publishEvent('item:collected', { player: entity1, item: entity2 });
      this.unregisterEntity(entity2.id); // Удаление собранного предмета
    }
  }

  publishEvent(eventType, data) {
    this.eventQueue.push({ type: eventType, data });
    
    // Уведомление всех подписчиков
    for (const [id, entity] of this.entities) {
      if (entity.handleEvent) {
        entity.handleEvent(eventType, data);
      }
    }
  }

  update() {
    // Обработка очереди событий
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift();
      // В реальном приложении здесь будет дополнительная логика
    }
    
    // Обновление всех сущностей
    for (const [id, entity] of this.entities) {
      if (entity.update) {
        entity.update();
      }
    }
    
    // Проверка коллизий
    const entitiesArray = Array.from(this.entities.values());
    for (let i = 0; i < entitiesArray.length; i++) {
      for (let j = i + 1; j < entitiesArray.length; j++) {
        this.processCollision(entitiesArray[i], entitiesArray[j]);
      }
    }
  }
}

// Базовый класс игровой сущности
class GameEntity {
  constructor(id, type, x, y, radius) {
    this.id = id;
    this.type = type;
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }
}

// Игрок
class Player extends GameEntity {
  constructor(id, x, y) {
    super(id, 'player', x, y, 20);
    this.health = 100;
    this.score = 0;
  }

  update() {
    // Логика обновления игрока
    // Например, обработка ввода
  }

  handleEvent(eventType, data) {
    if (eventType === 'player:hit') {
      this.health -= 10;
      console.log(`Игрок ранен! Здоровье: ${this.health}`);
      if (this.health <= 0) {
        this.mediator.publishEvent('player:dead', { player: this });
      }
    } else if (eventType === 'item:collected') {
      this.score += data.item.value;
      console.log(`Предмет собран! Счет: ${this.score}`);
    }
  }
}

// Враг
class Enemy extends GameEntity {
  constructor(id, x, y) {
    super(id, 'enemy', x, y, 15);
    this.speed = 1;
  }

  update() {
    // Простая логика движения врага (в сторону игрока)
    if (this.mediator) {
      const player = Array.from(this.mediator.entities.values())
        .find(e => e.type === 'player');
      
      if (player) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          this.x += (dx / distance) * this.speed;
          this.y += (dy / distance) * this.speed;
        }
      }
    }
  }
}

// Предмет
class GameItem extends GameEntity {
  constructor(id, x, y, value) {
    super(id, 'item', x, y, 10);
    this.value = value;
  }

  update() {
    // Предметы обычно не двигаются
  }
}

// Использование
const gameMediator = new GameMediator();

const player = new Player('player1', 100, 100);
const enemy1 = new Enemy('enemy1', 200, 200);
const enemy2 = new Enemy('enemy2', 300, 300);
const item1 = new GameItem('item1', 150, 150, 50);

gameMediator.registerEntity(player);
gameMediator.registerEntity(enemy1);
gameMediator.registerEntity(enemy2);
gameMediator.registerEntity(item1);

// Имитация игрового цикла
setInterval(() => {
  gameMediator.update();
}, 100);
```

## Пример 5: Система уведомлений

### Сценарий
Система уведомлений, где различные компоненты приложения могут отправлять и получать уведомления.

```javascript
class NotificationMediator {
  constructor() {
    this.subscribers = new Map(); // тип -> [callback1, callback2, ...]
    this.history = []; // История уведомлений
    this.maxHistorySize = 100;
  }

  subscribe(notificationType, callback) {
    if (!this.subscribers.has(notificationType)) {
      this.subscribers.set(notificationType, []);
    }
    
    this.subscribers.get(notificationType).push(callback);
    
    // Возвращаем функцию отписки
    return () => {
      const callbacks = this.subscribers.get(notificationType) || [];
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
  }

  publish(notification) {
    // Добавление в историю
    this.history.push(notification);
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    }

    // Уведомление подписчиков
    const callbacks = this.subscribers.get(notification.type) || [];
    callbacks.forEach(callback => callback(notification));
  }

  getHistory(notificationType = null) {
    if (notificationType) {
      return this.history.filter(n => n.type === notificationType);
    }
    return [...this.history];
  }

  clearHistory(notificationType = null) {
    if (notificationType) {
      this.history = this.history.filter(n => n.type !== notificationType);
    } else {
      this.history = [];
    }
  }
}

// Компонент отправки уведомлений
class NotificationSender {
  constructor(mediator) {
    this.mediator = mediator;
  }

  send(type, message, data = {}) {
    const notification = {
      id: Date.now(),
      type,
      message,
      data,
      timestamp: new Date()
    };
    
    this.mediator.publish(notification);
  }

  info(message, data) {
    this.send('info', message, data);
  }

  error(message, data) {
    this.send('error', message, data);
  }

  warning(message, data) {
    this.send('warning', message, data);
  }

  success(message, data) {
    this.send('success', message, data);
  }
}

// Компонент отображения уведомлений
class NotificationDisplay {
  constructor(container, mediator) {
    this.container = container;
    this.mediator = mediator;
    this.init();
  }

  init() {
    this.unsubscribe = this.mediator.subscribe('info', (notification) => {
      this.showNotification(notification, 'info');
    });
    
    this.mediator.subscribe('error', (notification) => {
      this.showNotification(notification, 'error');
    });
    
    this.mediator.subscribe('warning', (notification) => {
      this.showNotification(notification, 'warning');
    });
    
    this.mediator.subscribe('success', (notification) => {
      this.showNotification(notification, 'success');
    });
  }

  showNotification(notification, type) {
    const notificationElement = document.createElement('div');
    notificationElement.className = `notification ${type}`;
    notificationElement.innerHTML = `
      <div class="notification-content">
        <strong>${notification.type.toUpperCase()}:</strong> 
        ${notification.message}
        <small>${notification.timestamp.toLocaleTimeString()}</small>
      </div>
      <button class="close-btn">&times;</button>
    `;
    
    // Добавление обработчика закрытия
    notificationElement.querySelector('.close-btn').addEventListener('click', () => {
      notificationElement.remove();
    });
    
    this.container.appendChild(notificationElement);
    
    // Автоматическое удаление через 5 секунд
    setTimeout(() => {
      if (notificationElement.parentNode) {
        notificationElement.remove();
      }
    }, 5000);
  }
}

// Использование
const notificationMediator = new NotificationMediator();
const notificationSender = new NotificationSender(notificationMediator);

// Создание дисплея уведомлений
const notificationDisplay = new NotificationDisplay(
  document.getElementById('notifications'),
  notificationMediator
);

// Отправка уведомлений
notificationSender.info('Приложение запущено');
notificationSender.success('Данные успешно сохранены');
notificationSender.warning('Скоро закончится срок действия подписки');
notificationSender.error('Ошибка подключения к серверу');
```

## Преимущества использования медиатора в этих примерах

- **Снижение связанности**: Компоненты не зависят напрямую друг от друга
- **Упрощение тестирования**: Каждый компонент можно тестировать изолированно
- **Гибкость**: Легко добавлять новые компоненты или изменять логику взаимодействия
- **Централизованное управление**: Логика взаимодействия сосредоточена в одном месте

## Возможные проблемы

- **Сложность медиатора**: При большом количестве компонентов медиатор может стать слишком сложным
- **Производительность**: Дополнительный уровень абстракции может повлиять на производительность
- **Отладка**: Сложнее отслеживать поток данных в системе

## Заключение

Паттерн Медиатор эффективно решает задачу управления сложными взаимодействиями между объектами. Он особенно полезен в сценариях, где множество компонентов должны взаимодействовать друг с другом, но при этом важно сохранить их независимость и тестируемость.

Для изучения теоретических аспектов паттерна см. [[Паттерн-медиатор]].
Для реализации в конкретных технологиях см.:
- [[Реализация-в-JavaScript]]
- [[Реализация-в-React]]
- [[Реализация-в-Vue]]
