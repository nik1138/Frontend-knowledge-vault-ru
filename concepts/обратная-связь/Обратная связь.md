---
aliases: ["Обратная связь", "Feedback", "User Feedback", "Frontend Feedback"]
tags: ["#frontend", "#feedback", "#user-experience", "#ux", "#communication"]
---

# Обратная связь

**Обратная связь** — это процесс получения, обработки и реагирования на информацию от пользователей о работе приложения, его функциональности и пользовательском опыте. В контексте фронтенд-разработки обратная связь включает в себя сбор мнений пользователей, уведомления о статусе операций, визуальные индикаторы и системы для получения и анализа отзывов.

## Основные виды обратной связи

### 1. Визуальная обратная связь

**Визуальная обратная связь** — это немедленная визуальная реакция интерфейса на действия пользователя.

```javascript
// Система визуальной обратной связи
class VisualFeedback {
    constructor() {
        this.activeIndicators = new Set();
    }
    
    // Показ индикатора загрузки
    showLoader(element, options = {}) {
        const loaderOptions = {
            type: 'spinner', // spinner, progress, dots
            message: 'Загрузка...',
            position: 'overlay', // overlay, inline, fixed
            ...options
        };
        
        const indicator = this.createLoader(loaderOptions);
        
        if (loaderOptions.position === 'overlay') {
            this.showOverlayLoader(element, indicator);
        } else if (loaderOptions.position === 'inline') {
            this.showInlineLoader(element, indicator);
        }
        
        this.activeIndicators.add({ element, indicator, options: loaderOptions });
        return indicator;
    }
    
    // Создание индикатора загрузки
    createLoader(options) {
        const loader = document.createElement('div');
        loader.className = `feedback-loader feedback-loader-${options.type}`;
        
        switch (options.type) {
            case 'spinner':
                loader.innerHTML = `
                    <div class="spinner">
                        <div class="spinner-ring"></div>
                        ${options.message ? `<div class="loader-message">${options.message}</div>` : ''}
                    </div>
                `;
                break;
                
            case 'progress':
                loader.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                        <div class="progress-text">${options.message || 'Загрузка...'}</div>
                    </div>
                `;
                break;
                
            case 'dots':
                loader.innerHTML = `
                    <div class="loading-dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                        ${options.message ? `<div class="loader-message">${options.message}</div>` : ''}
                    </div>
                `;
                break;
        }
        
        return loader;
    }
    
    showOverlayLoader(targetElement, loader) {
        targetElement.style.position = 'relative';
        targetElement.appendChild(loader);
        loader.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        `;
    }
    
    showInlineLoader(targetElement, loader) {
        targetElement.appendChild(loader);
    }
    
    // Скрытие индикатора загрузки
    hideLoader(element) {
        const indicator = this.activeIndicators.values().next().value;
        if (indicator && indicator.element === element && indicator.indicator.parentNode) {
            indicator.indicator.parentNode.removeChild(indicator.indicator);
            this.activeIndicators.delete(indicator);
        }
    }
    
    // Показ уведомления
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span class="notification-message">${message}</span>
                <button class="notification-close" onclick="this.parentNode.parentNode.remove()">&times;</button>
            </div>
        `;
        
        // Добавление в DOM
        document.body.appendChild(notification);
        
        // Анимация появления
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);
        
        // Автоматическое скрытие
        if (duration > 0) {
            setTimeout(() => {
                this.hideNotification(notification);
            }, duration);
        }
        
        return notification;
    }
    
    hideNotification(notification) {
        notification.classList.remove('show');
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }
    
    // Показ временного сообщения
    showTemporaryMessage(element, message, options = {}) {
        const tempOptions = {
            duration: 2000,
            position: 'top', // top, bottom, left, right
            style: 'default', // default, success, error, warning
            ...options
        };
        
        const messageEl = document.createElement('div');
        messageEl.className = `temp-message temp-message-${tempOptions.style}`;
        messageEl.textContent = message;
        
        // Позиционирование
        const rect = element.getBoundingClientRect();
        messageEl.style.cssText = `
            position: fixed;
            top: ${rect.top + window.scrollY}px;
            left: ${rect.left + window.scrollX}px;
            transform: translateY(-100%);
            background: ${this.getMessageColor(tempOptions.style)};
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            z-index: 10000;
            white-space: nowrap;
        `;
        
        document.body.appendChild(messageEl);
        
        setTimeout(() => {
            if (messageEl.parentNode) {
                messageEl.parentNode.removeChild(messageEl);
            }
        }, tempOptions.duration);
    }
    
    getMessageColor(style) {
        const colors = {
            default: '#333',
            success: '#28a745',
            error: '#dc3545',
            warning: '#ffc107',
            info: '#17a2b8'
        };
        return colors[style] || colors.default;
    }
    
    // Анимация при наведении
    addHoverFeedback(element, options = {}) {
        const hoverOptions = {
            scale: 1.05,
            shadow: '0 4px 8px rgba(0,0,0,0.2)',
            transition: '0.2s ease',
            ...options
        };
        
        element.style.cssText += `
            transition: transform ${hoverOptions.transition}, box-shadow ${hoverOptions.transition};
        `;
        
        element.addEventListener('mouseenter', () => {
            element.style.transform = `scale(${hoverOptions.scale})`;
            element.style.boxShadow = hoverOptions.shadow;
        });
        
        element.addEventListener('mouseleave', () => {
            element.style.transform = 'scale(1)';
            element.style.boxShadow = 'none';
        });
    }
}

// Использование
const feedback = new VisualFeedback();

// Показ индикатора загрузки
const button = document.getElementById('submitBtn');
const loader = feedback.showLoader(button, { message: 'Отправка данных...' });

// Скрытие через 2 секунды
setTimeout(() => {
    feedback.hideLoader(button);
    feedback.showNotification('Данные успешно отправлены!', 'success');
}, 2000);
```

### 2. Интерактивная обратная связь

**Интерактивная обратная связь** — это возможность пользователю взаимодействовать с системой и получать мгновенную реакцию.

```javascript
// Система интерактивной обратной связи
class InteractiveFeedback {
    constructor() {
        this.subscribers = new Map();
        this.feedbackQueue = [];
    }
    
    // Подписка на события обратной связи
    subscribe(eventType, callback) {
        if (!this.subscribers.has(eventType)) {
            this.subscribers.set(eventType, []);
        }
        this.subscribers.get(eventType).push(callback);
        
        return () => {
            const callbacks = this.subscribers.get(eventType);
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        };
    }
    
    // Публикация события
    publish(eventType, data) {
        const callbacks = this.subscribers.get(eventType) || [];
        callbacks.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error('Ошибка в обработчике события обратной связи:', error);
            }
        });
        
        // Добавление в очередь для анализа
        this.feedbackQueue.push({
            type: eventType,
            data,
            timestamp: Date.now()
        });
    }
    
    // Система голосования/рейтинга
    createRatingSystem(container, options = {}) {
        const ratingOptions = {
            maxRating: 5,
            allowHalfStars: false,
            showText: true,
            initialRating: 0,
            ...options
        };
        
        const ratingContainer = document.createElement('div');
        ratingContainer.className = 'rating-system';
        
        // Создание звезд
        const starsContainer = document.createElement('div');
        starsContainer.className = 'stars-container';
        
        for (let i = 1; i <= ratingOptions.maxRating; i++) {
            const star = document.createElement('span');
            star.className = 'star';
            star.innerHTML = '★';
            star.dataset.rating = i;
            star.addEventListener('click', () => {
                this.setRating(container, i, ratingOptions);
                this.publish('rating:changed', {
                    rating: i,
                    maxRating: ratingOptions.maxRating,
                    element: container
                });
            });
            star.addEventListener('mouseover', () => {
                this.highlightStars(container, i);
            });
            starsContainer.appendChild(star);
        }
        
        // Текст рейтинга
        if (ratingOptions.showText) {
            const ratingText = document.createElement('span');
            ratingText.className = 'rating-text';
            ratingText.textContent = ratingOptions.initialRating;
            starsContainer.appendChild(ratingText);
        }
        
        ratingContainer.appendChild(starsContainer);
        container.appendChild(ratingContainer);
        
        // Установка начального рейтинга
        if (ratingOptions.initialRating > 0) {
            this.setRating(container, ratingOptions.initialRating, ratingOptions);
        }
        
        return ratingContainer;
    }
    
    setRating(container, rating, options) {
        const stars = container.querySelectorAll('.star');
        const ratingText = container.querySelector('.rating-text');
        
        stars.forEach((star, index) => {
            const starRating = parseInt(star.dataset.rating);
            star.style.color = starRating <= rating ? '#ffd700' : '#ddd';
        });
        
        if (ratingText) {
            ratingText.textContent = rating;
        }
    }
    
    highlightStars(container, rating) {
        const stars = container.querySelectorAll('.star');
        stars.forEach((star, index) => {
            const starRating = parseInt(star.dataset.rating);
            if (starRating <= rating) {
                star.style.color = '#ffed4e';
            } else {
                star.style.color = '#ddd';
            }
        });
    }
    
    // Система отзывов
    createFeedbackForm(container, options = {}) {
        const formOptions = {
            fields: ['rating', 'comment', 'email'],
            showEmail: false,
            requiredFields: ['comment'],
            submitCallback: null,
            ...options
        };
        
        const form = document.createElement('form');
        form.className = 'feedback-form';
        
        // Заголовок
        const title = document.createElement('h3');
        title.textContent = 'Оставьте ваш отзыв';
        form.appendChild(title);
        
        // Поля формы
        if (formOptions.fields.includes('rating')) {
            const ratingField = this.createRatingField();
            form.appendChild(ratingField);
        }
        
        if (formOptions.fields.includes('comment')) {
            const commentField = this.createCommentField(formOptions.requiredFields.includes('comment'));
            form.appendChild(commentField);
        }
        
        if (formOptions.fields.includes('email') && formOptions.showEmail) {
            const emailField = this.createEmailField(formOptions.requiredFields.includes('email'));
            form.appendChild(emailField);
        }
        
        // Кнопка отправки
        const submitBtn = document.createElement('button');
        submitBtn.type = 'submit';
        submitBtn.textContent = 'Отправить';
        submitBtn.className = 'feedback-submit-btn';
        form.appendChild(submitBtn);
        
        // Обработчик отправки
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleFeedbackSubmit(form, formOptions);
        });
        
        container.appendChild(form);
        return form;
    }
    
    createRatingField() {
        const field = document.createElement('div');
        field.className = 'feedback-field';
        field.innerHTML = `
            <label>Оценка:</label>
            <div class="rating-input">
                <span class="star" data-value="1">★</span>
                <span class="star" data-value="2">★</span>
                <span class="star" data-value="3">★</span>
                <span class="star" data-value="4">★</span>
                <span class="star" data-value="5">★</span>
            </div>
        `;
        
        const stars = field.querySelectorAll('.star');
        stars.forEach(star => {
            star.addEventListener('click', () => {
                const value = star.dataset.value;
                stars.forEach(s => s.classList.remove('selected'));
                star.classList.add('selected');
                // Выделяем все звезды до выбранной
                const allStars = Array.from(stars);
                const selectedIndex = allStars.indexOf(star);
                allStars.forEach((s, i) => {
                    if (i <= selectedIndex) s.classList.add('selected');
                });
            });
        });
        
        return field;
    }
    
    createCommentField(required) {
        const field = document.createElement('div');
        field.className = 'feedback-field';
        field.innerHTML = `
            <label for="feedback-comment">Комментарий:</label>
            <textarea 
                id="feedback-comment" 
                name="comment" 
                placeholder="Поделитесь вашим мнением..."
                ${required ? 'required' : ''}
            ></textarea>
        `;
        return field;
    }
    
    createEmailField(required) {
        const field = document.createElement('div');
        field.className = 'feedback-field';
        field.innerHTML = `
            <label for="feedback-email">Email (опционально):</label>
            <input 
                type="email" 
                id="feedback-email" 
                name="email" 
                placeholder="your@email.com"
                ${required ? 'required' : ''}
            />
        `;
        return field;
    }
    
    async handleFeedbackSubmit(form, options) {
        const formData = new FormData(form);
        const feedbackData = Object.fromEntries(formData);
        
        // Получение рейтинга
        const ratingStars = form.querySelectorAll('.rating-input .star.selected');
        if (ratingStars.length > 0) {
            feedbackData.rating = ratingStars.length;
        }
        
        // Валидация
        if (options.requiredFields.some(field => !feedbackData[field])) {
            this.publish('feedback:validation-error', {
                errors: options.requiredFields.filter(field => !feedbackData[field])
            });
            return;
        }
        
        try {
            // Показ индикатора загрузки
            const submitBtn = form.querySelector('.feedback-submit-btn');
            const originalText = submitBtn.textContent;
            submitBtn.textContent = 'Отправка...';
            submitBtn.disabled = true;
            
            // Отправка данных
            if (options.submitCallback) {
                await options.submitCallback(feedbackData);
            } else {
                // В реальности это будет запрос на сервер
                await this.sendFeedbackToServer(feedbackData);
            }
            
            // Успешная отправка
            this.publish('feedback:submitted', feedbackData);
            
            // Сброс формы
            form.reset();
            form.querySelectorAll('.star').forEach(star => star.classList.remove('selected'));
            
            // Показ сообщения об успехе
            const feedback = new VisualFeedback();
            feedback.showNotification('Спасибо за ваш отзыв!', 'success');
            
        } catch (error) {
            this.publish('feedback:error', { error, data: feedbackData });
            const feedback = new VisualFeedback();
            feedback.showNotification('Ошибка отправки отзыва', 'error');
        } finally {
            const submitBtn = form.querySelector('.feedback-submit-btn');
            submitBtn.textContent = 'Отправить';
            submitBtn.disabled = false;
        }
    }
    
    async sendFeedbackToServer(feedbackData) {
        // В реальности отправка на сервер
        console.log('Отправка отзыва:', feedbackData);
        // return fetch('/api/feedback', {
        //     method: 'POST',
        //     headers: { 'Content-Type': 'application/json' },
        //     body: JSON.stringify(feedbackData)
        // });
    }
    
    // Получение истории обратной связи
    getFeedbackHistory() {
        return [...this.feedbackQueue];
    }
    
    // Очистка истории
    clearHistory() {
        this.feedbackQueue = [];
    }
}

// Использование
const interactiveFeedback = new InteractiveFeedback();

// Подписка на события
interactiveFeedback.subscribe('rating:changed', (data) => {
    console.log('Рейтинг изменен:', data);
});

interactiveFeedback.subscribe('feedback:submitted', (data) => {
    console.log('Отзыв отправлен:', data);
    // Здесь можно обновить статистику, отправить в аналитику и т.д.
});
```

## Системы обратной связи в фронтенд-фреймворках

### React система обратной связи

```jsx
import React, { useState, useEffect, useCallback, createContext, useContext } from 'react';

// Контекст для системы обратной связи
const FeedbackContext = createContext();

// Провайдер системы обратной связи
export const FeedbackProvider = ({ children }) => {
    const [notifications, setNotifications] = useState([]);
    const [feedbackForms, setFeedbackForms] = useState(new Map());
    
    // Добавление уведомления
    const addNotification = useCallback((message, type = 'info', duration = 3000) => {
        const id = Date.now() + Math.random();
        const notification = {
            id,
            message,
            type,
            timestamp: Date.now()
        };
        
        setNotifications(prev => [...prev, notification]);
        
        // Автоматическое удаление
        if (duration > 0) {
            setTimeout(() => {
                removeNotification(id);
            }, duration);
        }
        
        return id;
    }, []);
    
    // Удаление уведомления
    const removeNotification = useCallback((id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
    }, []);
    
    // Открытие формы обратной связи
    const openFeedbackForm = useCallback((formId, options = {}) => {
        setFeedbackForms(prev => new Map(prev).set(formId, {
            ...options,
            isOpen: true
        }));
    }, []);
    
    // Закрытие формы обратной связи
    const closeFeedbackForm = useCallback((formId) => {
        setFeedbackForms(prev => {
            const newMap = new Map(prev);
            const form = newMap.get(formId);
            if (form) {
                newMap.set(formId, { ...form, isOpen: false });
            }
            return newMap;
        });
    }, []);
    
    const value = {
        notifications,
        addNotification,
        removeNotification,
        feedbackForms,
        openFeedbackForm,
        closeFeedbackForm
    };
    
    return (
        <FeedbackContext.Provider value={value}>
            {children}
            <NotificationContainer />
        </FeedbackContext.Provider>
    );
};

// Контейнер для уведомлений
const NotificationContainer = () => {
    const { notifications, removeNotification } = useContext(FeedbackContext);
    
    return (
        <div className="notification-container">
            {notifications.map(notification => (
                <Notification
                    key={notification.id}
                    notification={notification}
                    onClose={() => removeNotification(notification.id)}
                />
            ))}
        </div>
    );
};

// Компонент уведомления
const Notification = ({ notification, onClose }) => {
    const [isVisible, setIsVisible] = useState(false);
    
    useEffect(() => {
        // Анимация появления
        const timer = setTimeout(() => setIsVisible(true), 10);
        return () => clearTimeout(timer);
    }, []);
    
    const typeClasses = {
        success: 'notification-success',
        error: 'notification-error',
        warning: 'notification-warning',
        info: 'notification-info'
    };
    
    return (
        <div className={`notification ${typeClasses[notification.type]} ${isVisible ? 'show' : ''}`}>
            <div className="notification-content">
                <span className="notification-message">{notification.message}</span>
                <button className="notification-close" onClick={onClose}>
                    &times;
                </button>
            </div>
        </div>
    );
};

// Хук для использования системы обратной связи
export const useFeedback = () => {
    const context = useContext(FeedbackContext);
    if (!context) {
        throw new Error('useFeedback must be used within FeedbackProvider');
    }
    return context;
};

// Компонент формы обратной связи
export const FeedbackForm = ({ formId, title = "Обратная связь", onSubmit }) => {
    const { feedbackForms, closeFeedbackForm, addNotification } = useFeedback();
    const [formData, setFormData] = useState({
        rating: 0,
        comment: '',
        email: ''
    });
    const [isSubmitting, setIsSubmitting] = useState(false);
    
    const formState = feedbackForms.get(formId);
    
    if (!formState?.isOpen) return null;
    
    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);
        
        try {
            await onSubmit(formData);
            addNotification('Спасибо за ваш отзыв!', 'success');
            setFormData({ rating: 0, comment: '', email: '' });
            closeFeedbackForm(formId);
        } catch (error) {
            addNotification('Ошибка отправки отзыва', 'error');
        } finally {
            setIsSubmitting(false);
        }
    };
    
    const handleStarClick = (rating) => {
        setFormData(prev => ({ ...prev, rating }));
    };
    
    return (
        <div className="feedback-modal">
            <div className="feedback-modal-content">
                <div className="feedback-modal-header">
                    <h3>{title}</h3>
                    <button className="close-btn" onClick={() => closeFeedbackForm(formId)}>
                        &times;
                    </button>
                </div>
                
                <form onSubmit={handleSubmit} className="feedback-form">
                    <div className="rating-section">
                        <label>Ваша оценка:</label>
                        <div className="stars">
                            {[1, 2, 3, 4, 5].map(star => (
                                <span
                                    key={star}
                                    className={`star ${star <= formData.rating ? 'active' : ''}`}
                                    onClick={() => handleStarClick(star)}
                                >
                                    ★
                                </span>
                            ))}
                        </div>
                    </div>
                    
                    <div className="comment-section">
                        <label htmlFor="comment">Комментарий:</label>
                        <textarea
                            id="comment"
                            value={formData.comment}
                            onChange={(e) => setFormData(prev => ({ ...prev, comment: e.target.value }))}
                            placeholder="Поделитесь вашим мнением..."
                            required
                        />
                    </div>
                    
                    <div className="email-section">
                        <label htmlFor="email">Email (опционально):</label>
                        <input
                            type="email"
                            id="email"
                            value={formData.email}
                            onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
                            placeholder="your@email.com"
                        />
                    </div>
                    
                    <div className="form-actions">
                        <button type="button" onClick={() => closeFeedbackForm(formId)}>
                            Отмена
                        </button>
                        <button type="submit" disabled={isSubmitting}>
                            {isSubmitting ? 'Отправка...' : 'Отправить'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

// Компонент индикатора загрузки
export const LoadingIndicator = ({ message = "Загрузка...", show = true }) => {
    if (!show) return null;
    
    return (
        <div className="loading-indicator">
            <div className="spinner">
                <div className="spinner-ring"></div>
            </div>
            {message && <span className="loading-message">{message}</span>}
        </div>
    );
};

// Компонент для показа состояния операции
export const StatusIndicator = ({ status, message }) => {
    const statusClasses = {
        loading: 'status-loading',
        success: 'status-success',
        error: 'status-error',
        warning: 'status-warning'
    };
    
    const statusIcons = {
        loading: '⏳',
        success: '✓',
        error: '✗',
        warning: '⚠'
    };
    
    if (!status) return null;
    
    return (
        <div className={`status-indicator ${statusClasses[status]}`}>
            <span className="status-icon">{statusIcons[status]}</span>
            <span className="status-message">{message}</span>
        </div>
    );
};
```

### Vue система обратной связи

```vue
<template>
    <div class="feedback-system">
        <!-- Контейнер для уведомлений -->
        <div class="notification-container">
            <transition-group name="notification">
                <div 
                    v-for="notification in notifications" 
                    :key="notification.id"
                    :class="['notification', `notification-${notification.type}`]"
                    @mouseenter="clearAutoHide(notification.id)"
                    @mouseleave="setAutoHide(notification.id)"
                >
                    <div class="notification-content">
                        <span class="notification-message">{{ notification.message }}</span>
                        <button class="notification-close" @click="removeNotification(notification.id)">
                            &times;
                        </button>
                    </div>
                </div>
            </transition-group>
        </div>
        
        <!-- Модальное окно обратной связи -->
        <div v-if="activeForm" class="feedback-modal-overlay" @click="closeActiveForm">
            <div class="feedback-modal" @click.stop>
                <div class="feedback-modal-header">
                    <h3>{{ activeForm.title || 'Обратная связь' }}</h3>
                    <button class="close-btn" @click="closeActiveForm">&times;</button>
                </div>
                
                <form @submit.prevent="submitFeedback" class="feedback-form">
                    <div class="rating-section">
                        <label>Ваша оценка:</label>
                        <div class="stars">
                            <span
                                v-for="star in 5"
                                :key="star"
                                :class="['star', { active: star <= formData.rating }]"
                                @click="setRating(star)"
                            >
                                ★
                            </span>
                        </div>
                    </div>
                    
                    <div class="comment-section">
                        <label for="comment">Комментарий:</label>
                        <textarea
                            id="comment"
                            v-model="formData.comment"
                            placeholder="Поделитесь вашим мнением..."
                            required
                        ></textarea>
                    </div>
                    
                    <div class="email-section">
                        <label for="email">Email (опционально):</label>
                        <input
                            type="email"
                            id="email"
                            v-model="formData.email"
                            placeholder="your@email.com"
                        />
                    </div>
                    
                    <div class="form-actions">
                        <button type="button" @click="closeActiveForm">Отмена</button>
                        <button type="submit" :disabled="isSubmitting">
                            {{ isSubmitting ? 'Отправка...' : 'Отправить' }}
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Слот для основного контента -->
        <slot></slot>
    </div>
</template>

<script>
import { defineComponent, ref, reactive, provide } from 'vue';

export default defineComponent({
    name: 'FeedbackSystem',
    setup() {
        // Уведомления
        const notifications = ref([]);
        let notificationIdCounter = 0;
        
        // Активная форма
        const activeForm = ref(null);
        const isSubmitting = ref(false);
        
        // Данные формы
        const formData = reactive({
            rating: 0,
            comment: '',
            email: ''
        });
        
        // Таймеры для авто-скрытия
        const autoHideTimers = new Map();
        
        // Методы
        const addNotification = (message, type = 'info', duration = 3000) => {
            const id = ++notificationIdCounter;
            const notification = {
                id,
                message,
                type,
                timestamp: Date.now()
            };
            
            notifications.value.push(notification);
            
            if (duration > 0) {
                setAutoHide(id, duration);
            }
            
            return id;
        };
        
        const removeNotification = (id) => {
            clearAutoHide(id);
            const index = notifications.value.findIndex(n => n.id === id);
            if (index > -1) {
                notifications.value.splice(index, 1);
            }
        };
        
        const setAutoHide = (id, duration = 3000) => {
            if (autoHideTimers.has(id)) {
                clearTimeout(autoHideTimers.get(id));
            }
            
            const timer = setTimeout(() => {
                removeNotification(id);
            }, duration);
            
            autoHideTimers.set(id, timer);
        };
        
        const clearAutoHide = (id) => {
            if (autoHideTimers.has(id)) {
                clearTimeout(autoHideTimers.get(id));
                autoHideTimers.delete(id);
            }
        };
        
        const openFeedbackForm = (options = {}) => {
            activeForm.value = {
                title: options.title || 'Обратная связь',
                submitCallback: options.submitCallback
            };
            
            // Сброс формы
            formData.rating = 0;
            formData.comment = '';
            formData.email = '';
        };
        
        const closeActiveForm = () => {
            activeForm.value = null;
        };
        
        const setRating = (rating) => {
            formData.rating = rating;
        };
        
        const submitFeedback = async () => {
            isSubmitting.value = true;
            
            try {
                if (activeForm.value?.submitCallback) {
                    await activeForm.value.submitCallback({ ...formData });
                }
                
                addNotification('Спасибо за ваш отзыв!', 'success');
                closeActiveForm();
            } catch (error) {
                addNotification('Ошибка отправки отзыва', 'error');
            } finally {
                isSubmitting.value = false;
            }
        };
        
        // Предоставление методов для использования в дочерних компонентах
        provide('feedback', {
            addNotification,
            removeNotification,
            openFeedbackForm
        });
        
        return {
            notifications,
            activeForm,
            isSubmitting,
            formData,
            addNotification,
            removeNotification,
            setAutoHide,
            clearAutoHide,
            openFeedbackForm,
            closeActiveForm,
            setRating,
            submitFeedback
        };
    }
});
</script>

<style scoped>
.feedback-system {
    position: relative;
}

.notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.notification {
    padding: 12px 16px;
    border-radius: 4px;
    color: white;
    min-width: 250px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.notification-success {
    background-color: #28a745;
}

.notification-error {
    background-color: #dc3545;
}

.notification-warning {
    background-color: #ffc107;
    color: #212529;
}

.notification-info {
    background-color: #17a2b8;
}

.notification-message {
    flex: 1;
    margin-right: 8px;
}

.notification-close {
    background: none;
    border: none;
    color: inherit;
    font-size: 18px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.notification-enter-active, .notification-leave-active {
    transition: all 0.3s ease;
}

.notification-enter-from {
    opacity: 0;
    transform: translateX(100%);
}

.notification-leave-to {
    opacity: 0;
    transform: translateX(100%);
}

.feedback-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.feedback-modal {
    background: white;
    border-radius: 8px;
    padding: 20px;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.feedback-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.close-btn {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.stars {
    display: flex;
    gap: 4px;
    margin: 10px 0;
}

.star {
    font-size: 24px;
    cursor: pointer;
    color: #ddd;
}

.star.active {
    color: #ffd700;
}

.form-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}
</style>
```

## Практические примеры обратной связи

### Система опросов и голосований

```javascript
// Система опросов и голосований
class SurveySystem {
    constructor() {
        this.surveys = new Map();
        this.responses = new Map();
        this.subscribers = [];
    }
    
    // Создание опроса
    createSurvey(id, config) {
        const survey = {
            id,
            title: config.title,
            description: config.description,
            questions: config.questions || [],
            isActive: true,
            createdAt: new Date(),
            expiresAt: config.expiresAt || null,
            allowMultiple: config.allowMultiple || false,
            requireAuth: config.requireAuth || false
        };
        
        this.surveys.set(id, survey);
        return survey;
    }
    
    // Отображение опроса
    renderSurvey(surveyId, container) {
        const survey = this.surveys.get(surveyId);
        if (!survey || !survey.isActive) {
            return null;
        }
        
        const surveyElement = document.createElement('div');
        surveyElement.className = 'survey-container';
        
        surveyElement.innerHTML = `
            <div class="survey-header">
                <h3>${survey.title}</h3>
                ${survey.description ? `<p class="survey-description">${survey.description}</p>` : ''}
            </div>
            
            <form class="survey-form" data-survey-id="${survey.id}">
                ${survey.questions.map((question, index) => this.renderQuestion(question, index)).join('')}
                
                <div class="survey-actions">
                    <button type="submit" class="survey-submit-btn">Отправить</button>
                    <button type="button" class="survey-cancel-btn" onclick="this.closest('.survey-container').remove()">Закрыть</button>
                </div>
            </form>
        `;
        
        // Добавление обработчиков
        const form = surveyElement.querySelector('.survey-form');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.submitSurvey(surveyId, new FormData(form));
        });
        
        container.appendChild(surveyElement);
        return surveyElement;
    }
    
    // Рендер вопроса
    renderQuestion(question, index) {
        const questionId = `question-${index}`;
        
        switch (question.type) {
            case 'multiple-choice':
                return this.renderMultipleChoice(question, questionId, index);
            case 'rating':
                return this.renderRating(question, questionId, index);
            case 'text':
                return this.renderText(question, questionId, index);
            case 'yes-no':
                return this.renderYesNo(question, questionId, index);
            default:
                return '';
        }
    }
    
    renderMultipleChoice(question, questionId, index) {
        return `
            <div class="survey-question" data-question="${index}">
                <label class="question-label">${question.label}</label>
                ${question.options.map((option, optIndex) => `
                    <label class="option-label">
                        <input 
                            type="${question.allowMultiple ? 'checkbox' : 'radio'}" 
                            name="question-${index}" 
                            value="${option.value}"
                            ${question.required ? 'required' : ''}
                        >
                        <span class="option-text">${option.label}</span>
                    </label>
                `).join('')}
            </div>
        `;
    }
    
    renderRating(question, questionId, index) {
        return `
            <div class="survey-question" data-question="${index}">
                <label class="question-label">${question.label}</label>
                <div class="rating-input" data-question="${index}">
                    ${[1, 2, 3, 4, 5].map(star => `
                        <span class="star" data-value="${star}">★</span>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    renderText(question, questionId, index) {
        return `
            <div class="survey-question" data-question="${index}">
                <label class="question-label">${question.label}</label>
                <textarea 
                    name="question-${index}" 
                    placeholder="${question.placeholder || ''}"
                    ${question.required ? 'required' : ''}
                    ${question.maxLength ? `maxlength="${question.maxLength}"` : ''}
                ></textarea>
            </div>
        `;
    }
    
    renderYesNo(question, questionId, index) {
        return `
            <div class="survey-question" data-question="${index}">
                <label class="question-label">${question.label}</label>
                <label class="option-label">
                    <input type="radio" name="question-${index}" value="yes" required>
                    <span class="option-text">Да</span>
                </label>
                <label class="option-label">
                    <input type="radio" name="question-${index}" value="no" required>
                    <span class="option-text">Нет</span>
                </label>
            </div>
        `;
    }
    
    // Отправка опроса
    async submitSurvey(surveyId, formData) {
        const survey = this.surveys.get(surveyId);
        if (!survey) {
            throw new Error('Опрос не найден');
        }
        
        // Сбор ответов
        const responses = {};
        const questions = survey.questions;
        
        for (let i = 0; i < questions.length; i++) {
            const question = questions[i];
            const values = formData.getAll(`question-${i}`);
            
            if (question.type === 'rating') {
                // Для рейтинга получаем значение из DOM
                const ratingElement = document.querySelector(`[data-question="${i}"]`);
                const selectedStars = ratingElement.querySelectorAll('.star.selected');
                responses[i] = selectedStars.length;
            } else {
                responses[i] = question.allowMultiple ? values : values[0];
            }
        }
        
        // Проверка обязательных полей
        const requiredQuestions = questions.filter(q => q.required);
        for (const req of requiredQuestions) {
            const questionIndex = questions.indexOf(req);
            if (!responses[questionIndex] || 
                (Array.isArray(responses[questionIndex]) && responses[questionIndex].length === 0) ||
                (typeof responses[questionIndex] === 'string' && responses[questionIndex].trim() === '')) {
                throw new Error(`Ответ на вопрос "${req.label}" обязателен`);
            }
        }
        
        // Сохранение ответа
        const response = {
            surveyId,
            responses,
            timestamp: new Date(),
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        
        if (!this.responses.has(surveyId)) {
            this.responses.set(surveyId, []);
        }
        this.responses.get(surveyId).push(response);
        
        // Уведомление подписчиков
        this.notifySubscribers('survey:submitted', { surveyId, response });
        
        // Показ сообщения об успехе
        const feedback = new VisualFeedback();
        feedback.showNotification('Спасибо за участие в опросе!', 'success');
        
        // Закрытие формы
        const surveyContainer = document.querySelector(`[data-survey-id="${surveyId}"]`)?.closest('.survey-container');
        if (surveyContainer) {
            surveyContainer.remove();
        }
        
        return response;
    }
    
    // Подписка на события
    subscribe(callback) {
        this.subscribers.push(callback);
        return () => {
            const index = this.subscribers.indexOf(callback);
            if (index > -1) {
                this.subscribers.splice(index, 1);
            }
        };
    }
    
    notifySubscribers(event, data) {
        this.subscribers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('Ошибка в обработчике события опроса:', error);
            }
        });
    }
    
    // Получение результатов опроса
    getSurveyResults(surveyId) {
        const responses = this.responses.get(surveyId) || [];
        const survey = this.surveys.get(surveyId);
        
        if (!survey) {
            return null;
        }
        
        const results = {
            totalResponses: responses.length,
            questions: survey.questions.map((question, qIndex) => {
                const questionResponses = responses.map(r => r.responses[qIndex]);
                
                switch (question.type) {
                    case 'multiple-choice':
                        const optionCounts = {};
                        question.options.forEach(opt => optionCounts[opt.value] = 0);
                        
                        questionResponses.forEach(resp => {
                            if (Array.isArray(resp)) {
                                resp.forEach(r => optionCounts[r] = (optionCounts[r] || 0) + 1);
                            } else {
                                optionCounts[resp] = (optionCounts[resp] || 0) + 1;
                            }
                        });
                        
                        return {
                            question,
                            responses: optionCounts,
                            percentages: Object.keys(optionCounts).reduce((acc, key) => {
                                acc[key] = responses.length > 0 ? 
                                    (optionCounts[key] / responses.length * 100).toFixed(2) + '%' : '0%';
                                return acc;
                            }, {})
                        };
                        
                    case 'rating':
                        const ratings = questionResponses.filter(r => r && r !== 0);
                        const average = ratings.length > 0 ? 
                            ratings.reduce((sum, r) => sum + r, 0) / ratings.length : 0;
                        
                        return {
                            question,
                            average: parseFloat(average.toFixed(2)),
                            distribution: [1, 2, 3, 4, 5].map(star => ({
                                star,
                                count: questionResponses.filter(r => r === star).length,
                                percentage: responses.length > 0 ? 
                                    (questionResponses.filter(r => r === star).length / responses.length * 100).toFixed(2) + '%' : '0%'
                            }))
                        };
                        
                    default:
                        return {
                            question,
                            responses: questionResponses
                        };
                }
            })
        };
        
        return results;
    }
}

// Использование
const surveySystem = new SurveySystem();

// Создание опроса
const userSatisfactionSurvey = surveySystem.createSurvey('user-satisfaction', {
    title: 'Оценка удовлетворенности',
    description: 'Пожалуйста, ответьте на несколько вопросов о вашем опыте использования нашего приложения',
    questions: [
        {
            type: 'rating',
            label: 'Насколько вы удовлетворены нашим приложением?',
            required: true
        },
        {
            type: 'multiple-choice',
            label: 'Какими функциями вы чаще всего пользуетесь?',
            options: [
                { value: 'feature1', label: 'Функция 1' },
                { value: 'feature2', label: 'Функция 2' },
                { value: 'feature3', label: 'Функция 3' }
            ],
            allowMultiple: true,
            required: true
        },
        {
            type: 'text',
            label: 'Какие улучшения вы бы хотели видеть?',
            placeholder: 'Опишите ваши идеи...',
            required: false
        }
    ],
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 дней
});

// Отображение опроса
const surveyContainer = document.getElementById('survey-container');
surveySystem.renderSurvey('user-satisfaction', surveyContainer);
```

## Лучшие практики обратной связи

### 1. Немедленная обратная связь

```javascript
// Система немедленной обратной связи
class ImmediateFeedback {
    constructor() {
        this.setupGlobalListeners();
    }
    
    setupGlobalListeners() {
        // Обработка кликов
        document.addEventListener('click', (e) => {
            this.handleElementInteraction(e.target, 'click');
        }, true);
        
        // Обработка фокуса
        document.addEventListener('focus', (e) => {
            this.handleElementInteraction(e.target, 'focus');
        }, true);
        
        // Обработка ввода
        document.addEventListener('input', (e) => {
            this.handleElementInteraction(e.target, 'input');
        }, true);
    }
    
    handleElementInteraction(element, interactionType) {
        // Проверка, есть ли у элемента обратная связь
        const feedbackConfig = this.getElementFeedbackConfig(element);
        
        if (feedbackConfig) {
            this.applyImmediateFeedback(element, interactionType, feedbackConfig);
        }
    }
    
    getElementFeedbackConfig(element) {
        // Проверка атрибутов обратной связи
        const config = {
            showOn: element.getAttribute('data-feedback-show')?.split(',') || [],
            hideAfter: parseInt(element.getAttribute('data-feedback-duration')) || 0,
            type: element.getAttribute('data-feedback-type') || 'visual',
            message: element.getAttribute('data-feedback-message') || null
        };
        
        return config.showOn.includes('all') || config.showOn.includes('click') ? config : null;
    }
    
    applyImmediateFeedback(element, interactionType, config) {
        switch (config.type) {
            case 'visual':
                this.applyVisualFeedback(element, interactionType);
                break;
            case 'notification':
                if (config.message) {
                    const feedback = new VisualFeedback();
                    feedback.showNotification(config.message, 'info', config.hideAfter);
                }
                break;
        }
    }
    
    applyVisualFeedback(element, interactionType) {
        // Краткая анимация для указания взаимодействия
        element.style.transform = 'scale(0.98)';
        element.style.transition = 'transform 0.1s ease';
        
        setTimeout(() => {
            element.style.transform = '';
        }, 100);
        
        // Добавление временного класса
        element.classList.add('interacted');
        setTimeout(() => {
            element.classList.remove('interacted');
        }, 200);
    }
}

// Инициализация
const immediateFeedback = new ImmediateFeedback();
```

### 2. Система анализа и отчетности

```javascript
// Система анализа обратной связи
class FeedbackAnalytics {
    constructor() {
        this.collectedData = {
            userInteractions: [],
            systemEvents: [],
            feedbackSubmissions: [],
            errorReports: []
        };
        
        this.metrics = {
            engagementRate: 0,
            satisfactionScore: 0,
            responseTime: 0
        };
    }
    
    // Сбор данных
    collectData(type, data) {
        if (this.collectedData[type]) {
            this.collectedData[type].push({
                ...data,
                timestamp: Date.now(),
                sessionId: this.getSessionId()
            });
        }
    }
    
    // Расчет метрик
    calculateMetrics() {
        // Степень вовлеченности
        const totalUsers = new Set(this.collectedData.userInteractions.map(i => i.userId)).size;
        const activeUsers = new Set(this.collectedData.userInteractions
            .filter(i => Date.now() - i.timestamp < 24 * 60 * 60 * 1000) // за последние 24 часа
            .map(i => i.userId)
        ).size;
        
        this.metrics.engagementRate = totalUsers > 0 ? (activeUsers / totalUsers) * 100 : 0;
        
        // Удовлетворенность (средняя оценка)
        const ratings = this.collectedData.feedbackSubmissions
            .map(f => f.rating)
            .filter(r => r > 0);
        
        this.metrics.satisfactionScore = ratings.length > 0 ? 
            ratings.reduce((sum, r) => sum + r, 0) / ratings.length : 0;
        
        // Среднее время отклика
        const responseTimes = this.collectedData.systemEvents
            .filter(e => e.type === 'response_time')
            .map(e => e.duration);
        
        this.metrics.responseTime = responseTimes.length > 0 ?
            responseTimes.reduce((sum, t) => sum + t, 0) / responseTimes.length : 0;
    }
    
    // Генерация отчета
    generateReport() {
        this.calculateMetrics();
        
        return {
            summary: {
                totalInteractions: this.collectedData.userInteractions.length,
                totalFeedback: this.collectedData.feedbackSubmissions.length,
                totalErrors: this.collectedData.errorReports.length,
                ...this.metrics
            },
            trends: this.calculateTrends(),
            recommendations: this.generateRecommendations()
        };
    }
    
    calculateTrends() {
        const now = Date.now();
        const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
        
        const recentInteractions = this.collectedData.userInteractions
            .filter(i => i.timestamp > weekAgo);
        
        const dailyTrend = {};
        recentInteractions.forEach(interaction => {
            const date = new Date(interaction.timestamp).toDateString();
            dailyTrend[date] = (dailyTrend[date] || 0) + 1;
        });
        
        return {
            dailyActivity: dailyTrend,
            weeklyGrowth: this.calculateWeeklyGrowth()
        };
    }
    
    calculateWeeklyGrowth() {
        const now = Date.now();
        const currentWeek = this.collectedData.userInteractions
            .filter(i => i.timestamp > (now - 7 * 24 * 60 * 60 * 1000));
        const previousWeek = this.collectedData.userInteractions
            .filter(i => i.timestamp > (now - 14 * 24 * 60 * 60 * 1000) && i.timestamp <= (now - 7 * 24 * 60 * 60 * 1000));
        
        const currentCount = currentWeek.length;
        const previousCount = previousWeek.length;
        
        return previousCount > 0 ? ((currentCount - previousCount) / previousCount) * 100 : currentCount > 0 ? 100 : 0;
    }
    
    generateRecommendations() {
        const recommendations = [];
        
        if (this.metrics.engagementRate < 30) {
            recommendations.push('Увеличить вовлеченность пользователей через персонализированный контент');
        }
        
        if (this.metrics.satisfactionScore < 3.5) {
            recommendations.push('Провести анализ причин низкого удовлетворения пользователей');
        }
        
        if (this.metrics.responseTime > 2000) {
            recommendations.push('Оптимизировать производительность для уменьшения времени отклика');
        }
        
        return recommendations;
    }
    
    getSessionId() {
        if (!window.sessionId) {
            window.sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        return window.sessionId;
    }
}

// Использование
const analytics = new FeedbackAnalytics();

// Пример использования для сбора данных
analytics.collectData('userInteractions', {
    userId: 'user123',
    action: 'click',
    element: 'button',
    page: '/home'
});

analytics.collectData('feedbackSubmissions', {
    userId: 'user123',
    rating: 5,
    comment: 'Отличное приложение!'
});
```

## Связанные концепции

- [[Пользовательский-опыт]]
- [[Мониторинг]]
- [[Тестирование]]
- [[Отладка]]
- [[Анализ-данных]]

## Ключевые теги

#feedback #user-experience #ux #frontend #interaction #notifications #surveys #analytics #user-engagement #customer-feedback