---
aliases: ["Behavioral Patterns", "Поведенческие паттерны"]
tags: ["#programming", "#design-patterns", "#frontend", "#javascript"]
---

# Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны проектирования сосредоточены на взаимодействии между объектами и распределении обязанностей. Они определяют, как объекты общаются друг с другом, и помогают обеспечить гибкость в выборе способа этого взаимодействия.

## Обзор

Поведенческие паттерны описывают распространенные способы взаимодействия объектов и реализуют эти взаимодействия. Они сосредоточены на том, как объекты выполняют свою работу, как они обмениваются данными и как распределяются обязанности.

## Паттерны

### 1. Observer (Наблюдатель)

Паттерн, позволяющий объектам наблюдать за изменениями других объектов и реагировать на них.

#### Проблема
Когда один объект должен уведомлять другие объекты об изменениях своего состояния, без жесткой зависимости между ними.

#### Решение
Создать механизм подписки, позволяющий одному объекту (наблюдаемому) уведомлять другие объекты (наблюдателей) об изменениях.

#### Пример на JavaScript
```javascript
// Наблюдаемый объект
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

// Наблюдатель
class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} получил уведомление: ${data}`);
  }
}

// Использование
const subject = new Subject();

const observer1 = new Observer('Наблюдатель 1');
const observer2 = new Observer('Наблюдатель 2');
const observer3 = new Observer('Наблюдатель 3');

subject.subscribe(observer1);
subject.subscribe(observer2);

subject.notify('Событие 1'); 
// Наблюдатель 1 получил уведомление: Событие 1
// Наблюдатель 2 получил уведомление: Событие 1

subject.unsubscribe(observer2);
subject.notify('Событие 2');
// Наблюдатель 1 получил уведомление: Событие 2
```

#### Пример на TypeScript
```typescript
// Интерфейс наблюдателя
interface ObserverInterface {
  update(data: any): void;
}

// Наблюдаемый объект
class Subject {
  private observers: ObserverInterface[] = [];
  
  public subscribe(observer: ObserverInterface): void {
    this.observers.push(observer);
  }
  
  public unsubscribe(observer: ObserverInterface): void {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }
  
  public notify(data: any): void {
    this.observers.forEach(observer => observer.update(data));
  }
}

// Наблюдатель
class Observer implements ObserverInterface {
  private name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  public update(data: any): void {
    console.log(`${this.name} получил уведомление: ${data}`);
  }
}

// Использование
const subject = new Subject();

const observer1 = new Observer('Наблюдатель 1');
const observer2 = new Observer('Наблюдатель 2');
const observer3 = new Observer('Наблюдатель 3');

subject.subscribe(observer1);
subject.subscribe(observer2);

subject.notify('Событие 1'); 
// Наблюдатель 1 получил уведомление: Событие 1
// Наблюдатель 2 получил уведомление: Событие 1

subject.unsubscribe(observer2);
subject.notify('Событие 2');
// Наблюдатель 1 получил уведомление: Событие 2
```

#### Когда использовать
- Когда изменения одного объекта должны приводить к изменениям других объектов
- Когда нужно избежать жесткой зависимости между объектами
- Когда один объект должен уведомлять другие объекты о своих изменениях

#### Преимущества
- Устанавливает динамические отношения между объектами
- Позволяет формировать сложные зависимости
- Следует принципу открытости/закрытости

#### Недостатки
- Может усложнить отладку
- Наблюдатели могут оставаться в памяти, если не отписаться явно

### 2. Strategy (Стратегия)

Паттерн, позволяющий определять семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми.

#### Проблема
Когда нужно выбрать алгоритм во время выполнения или иметь возможность легко переключаться между различными алгоритмами.

#### Решение
Определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми.

#### Пример на JavaScript
```javascript
// Стратегии
class PaymentStrategy {
  pay(amount) {
    throw new Error('Pay method must be implemented');
  }
}

class CreditCardStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. по кредитной карте ${this.cardNumber}`);
    return true;
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email) {
    super();
    this.email = email;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. через PayPal на ${this.email}`);
    return true;
  }
}

class BitcoinStrategy extends PaymentStrategy {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} руб. через Bitcoin кошелек ${this.wallet}`);
    return true;
  }
}

// Контекст
class PaymentProcessor {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  processPayment(amount) {
    return this.strategy.pay(amount);
  }
}

// Использование
const paymentProcessor = new PaymentProcessor(new CreditCardStrategy('1234-5678-9012-3456', '123'));
paymentProcessor.processPayment(100); // Оплата 100 руб. по кредитной карте 1234-5678-9012-3456

paymentProcessor.setStrategy(new PayPalStrategy('user@example.com'));
paymentProcessor.processPayment(200); // Оплата 200 руб. через PayPal на user@example.com
```

#### Пример на TypeScript
```typescript
// Интерфейс стратегии
interface PaymentStrategy {
  pay(amount: number): boolean;
}

// Конкретные стратегии
class CreditCardStrategy implements PaymentStrategy {
  private cardNumber: string;
  private cvv: string;
  
  constructor(cardNumber: string, cvv: string) {
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }
  
  public pay(amount: number): boolean {
    console.log(`Оплата ${amount} руб. по кредитной карте ${this.cardNumber}`);
    return true;
  }
}

class PayPalStrategy implements PaymentStrategy {
  private email: string;
  
  constructor(email: string) {
    this.email = email;
  }
  
  public pay(amount: number): boolean {
    console.log(`Оплата ${amount} руб. через PayPal на ${this.email}`);
    return true;
  }
}

class BitcoinStrategy implements PaymentStrategy {
  private wallet: string;
  
  constructor(wallet: string) {
    this.wallet = wallet;
  }
  
  public pay(amount: number): boolean {
    console.log(`Оплата ${amount} руб. через Bitcoin кошелек ${this.wallet}`);
    return true;
  }
}

// Контекст
class PaymentProcessor {
  private strategy: PaymentStrategy;
  
  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }
  
  public setStrategy(strategy: PaymentStrategy): void {
    this.strategy = strategy;
  }
  
  public processPayment(amount: number): boolean {
    return this.strategy.pay(amount);
  }
}

// Использование
const paymentProcessor = new PaymentProcessor(
  new CreditCardStrategy('1234-5678-9012-3456', '123')
);
paymentProcessor.processPayment(100); // Оплата 100 руб. по кредитной карте 1234-5678-9012-3456

paymentProcessor.setStrategy(new PayPalStrategy('user@example.com'));
paymentProcessor.processPayment(200); // Оплата 200 руб. через PayPal на user@example.com
```

#### Когда использовать
- Когда нужно выбирать алгоритм во время выполнения
- Когда нужно избежать условных операторов при выборе алгоритма
- Когда нужно использовать разные варианты алгоритма

#### Преимущества
- Позволяет переключаться между алгоритмами во время выполнения
- Изолирует код и данные алгоритмов
- Следует принципу открытости/закрытости

#### Недостатки
- Может увеличить количество классов
- Клиент должен знать о разных стратегиях

### 3. Command (Команда)

Паттерн, превращающий запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать и поддерживать отмену операций.

#### Проблема
Когда нужно параметризовать объекты выполняемым действием, ставить операции в очередь или поддерживать отмену операций.

#### Решение
Обернуть команду в объект, который содержит всю информацию о команде и может выполнить её.

#### Пример на JavaScript
```javascript
// Команда
class Command {
  execute() {
    throw new Error('Execute method must be implemented');
  }
  
  undo() {
    throw new Error('Undo method must be implemented');
  }
}

// Конкретные команды
class LightOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class LightOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

// Получатель
class Light {
  constructor(name) {
    this.name = name;
    this.isOn = false;
  }
  
  turnOn() {
    this.isOn = true;
    console.log(`${this.name} свет включен`);
  }
  
  turnOff() {
    this.isOn = false;
    console.log(`${this.name} свет выключен`);
  }
}

// Вызывающий
class RemoteControl {
  constructor() {
    this.commands = [];
    this.currentPosition = 0;
  }
  
  executeCommand(command) {
    command.execute();
    this.commands.push(command);
    this.currentPosition++;
  }
  
  undoCommand() {
    if (this.currentPosition > 0) {
      const command = this.commands[--this.currentPosition];
      command.undo();
    }
  }
}

// Использование
const livingRoomLight = new Light('Гостиная');
const kitchenLight = new Light('Кухня');

const livingRoomLightOn = new LightOnCommand(livingRoomLight);
const kitchenLightOn = new LightOnCommand(kitchenLight);
const kitchenLightOff = new LightOffCommand(kitchenLight);

const remote = new RemoteControl();

remote.executeCommand(livingRoomLightOn); // Гостиная свет включен
remote.executeCommand(kitchenLightOn); // Кухня свет включен
remote.executeCommand(kitchenLightOff); // Кухня свет выключен

remote.undoCommand(); // Кухня свет включен (отмена выключения)
```

#### Пример на TypeScript
```typescript
// Интерфейс команды
interface Command {
  execute(): void;
  undo(): void;
}

// Получатель
class Light {
  private name: string;
  private isOn: boolean = false;
  
  constructor(name: string) {
    this.name = name;
  }
  
  public turnOn(): void {
    this.isOn = true;
    console.log(`${this.name} свет включен`);
  }
  
  public turnOff(): void {
    this.isOn = false;
    console.log(`${this.name} свет выключен`);
  }
}

// Конкретные команды
class LightOnCommand implements Command {
  private light: Light;
  
  constructor(light: Light) {
    this.light = light;
  }
  
  public execute(): void {
    this.light.turnOn();
  }
  
  public undo(): void {
    this.light.turnOff();
  }
}

class LightOffCommand implements Command {
  private light: Light;
  
  constructor(light: Light) {
    this.light = light;
  }
  
  public execute(): void {
    this.light.turnOff();
  }
  
  public undo(): void {
    this.light.turnOn();
  }
}

// Вызывающий
class RemoteControl {
  private commands: Command[] = [];
  private currentPosition: number = 0;
  
  public executeCommand(command: Command): void {
    command.execute();
    this.commands.push(command);
    this.currentPosition++;
  }
  
  public undoCommand(): void {
    if (this.currentPosition > 0) {
      const command = this.commands[--this.currentPosition];
      command.undo();
    }
  }
}

// Использование
const livingRoomLight = new Light('Гостиная');
const kitchenLight = new Light('Кухня');

const livingRoomLightOn = new LightOnCommand(livingRoomLight);
const kitchenLightOn = new LightOnCommand(kitchenLight);
const kitchenLightOff = new LightOffCommand(kitchenLight);

const remote = new RemoteControl();

remote.executeCommand(livingRoomLightOn); // Гостиная свет включен
remote.executeCommand(kitchenLightOn); // Кухня свет включен
remote.executeCommand(kitchenLightOff); // Кухня свет выключен

remote.undoCommand(); // Кухня свет включен (отмена выключения)
```

#### Когда использовать
- Когда нужно параметризовать объекты выполняемым действием
- Когда нужно ставить операции в очередь
- Когда нужно поддерживать отмену операций
- Когда нужно логировать операции

#### Преимущества
- Позволяет реализовать отмену операций
- Позволяет ставить операции в очередь
- Позволяет создавать составные команды
- Следует принципу открытости/закрытости

#### Недостатки
- Может привести к созданию большого количества классов
- Может усложнить код для простых операций

### 4. State (Состояние)

Паттерн, позволяющий объекту изменять свое поведение в зависимости от внутреннего состояния.

#### Проблема
Когда поведение объекта зависит от его состояния и должно изменяться во время выполнения.

#### Решение
Создать класс для каждого состояния, реализующий общий интерфейс, и позволить объекту изменять свое состояние.

#### Пример на JavaScript
```javascript
// Состояние
class State {
  handle(context) {
    throw new Error('Handle method must be implemented');
  }
}

// Конкретные состояния
class ReadyState extends State {
  handle(context) {
    console.log('Плеер готов к воспроизведению');
    context.setState(new PlayingState());
  }
}

class PlayingState extends State {
  handle(context) {
    console.log('Плеер воспроизводит трек');
    context.setState(new PausedState());
  }
}

class PausedState extends State {
  handle(context) {
    console.log('Плеер приостановлен');
    context.setState(new PlayingState());
  }
}

class StoppedState extends State {
  handle(context) {
    console.log('Плеер остановлен');
    context.setState(new ReadyState());
  }
}

// Контекст
class MediaPlayer {
  constructor() {
    this.state = new ReadyState();
  }
  
  setState(state) {
    this.state = state;
  }
  
  clickPlay() {
    this.state.handle(this);
  }
  
  getState() {
    return this.state.constructor.name;
  }
}

// Использование
const player = new MediaPlayer();
console.log(`Текущее состояние: ${player.getState()}`); // ReadyState

player.clickPlay(); // Плеер готов к воспроизведению
console.log(`Текущее состояние: ${player.getState()}`); // PlayingState

player.clickPlay(); // Плеер воспроизводит трек
console.log(`Текущее состояние: ${player.getState()}`); // PausedState

player.clickPlay(); // Плеер приостановлен
console.log(`Текущее состояние: ${player.getState()}`); // PlayingState
```

#### Пример на TypeScript
```typescript
// Интерфейс состояния
interface State {
  handle(context: MediaPlayer): void;
}

// Контекст
class MediaPlayer {
  private state: State;
  
  constructor() {
    this.state = new ReadyState();
  }
  
  public setState(state: State): void {
    this.state = state;
  }
  
  public clickPlay(): void {
    this.state.handle(this);
  }
  
  public getState(): string {
    return this.state.constructor.name;
  }
}

// Конкретные состояния
class ReadyState implements State {
  public handle(context: MediaPlayer): void {
    console.log('Плеер готов к воспроизведению');
    context.setState(new PlayingState());
  }
}

class PlayingState implements State {
  public handle(context: MediaPlayer): void {
    console.log('Плеер воспроизводит трек');
    context.setState(new PausedState());
  }
}

class PausedState implements State {
  public handle(context: MediaPlayer): void {
    console.log('Плеер приостановлен');
    context.setState(new PlayingState());
  }
}

class StoppedState implements State {
  public handle(context: MediaPlayer): void {
    console.log('Плеер остановлен');
    context.setState(new ReadyState());
  }
}

// Использование
const player = new MediaPlayer();
console.log(`Текущее состояние: ${player.getState()}`); // ReadyState

player.clickPlay(); // Плеер готов к воспроизведению
console.log(`Текущее состояние: ${player.getState()}`); // PlayingState

player.clickPlay(); // Плеер воспроизводит трек
console.log(`Текущее состояние: ${player.getState()}`); // PausedState

player.clickPlay(); // Плеер приостановлен
console.log(`Текущее состояние: ${player.getState()}`); // PlayingState
```

#### Когда использовать
- Когда поведение объекта зависит от его состояния
- Когда в коде много условных операторов, зависящих от состояния
- Когда состояний много и поведение сильно различается

#### Преимущества
- Позволяет изменять поведение во время выполнения
- Изолирует код, связанный с каждым состоянием
- Позволяет легко добавлять новые состояния

#### Недостатки
- Может усложнить код для простых случаев
- Может привести к созданию большого количества классов

### 5. Template Method (Шаблонный метод)

Паттерн, определяющий основу алгоритма и позволяющий подклассам переопределять определенные шаги алгоритма без изменения его структуры.

#### Проблема
Когда нужно определить алгоритм в базовом классе, но позволить подклассам переопределять определенные шаги.

#### Решение
Определить основу алгоритма в базовом классе и позволить подклассам переопределять определенные шаги.

#### Пример на JavaScript
```javascript
// Абстрактный класс
class DataProcessor {
  // Шаблонный метод
  process() {
    const data = this.loadData();
    const processedData = this.transformData(data);
    this.saveData(processedData);
    this.onComplete();
  }
  
  loadData() {
    throw new Error('LoadData method must be implemented');
  }
  
  transformData(data) {
    throw new Error('TransformData method must be implemented');
  }
  
  saveData(data) {
    throw new Error('SaveData method must be implemented');
  }
  
  // Хук
  onComplete() {
    console.log('Обработка данных завершена');
  }
}

// Конкретные реализации
class CSVDataProcessor extends DataProcessor {
  loadData() {
    console.log('Загрузка CSV данных');
    return 'CSV data';
  }
  
  transformData(data) {
    console.log('Преобразование CSV данных');
    return `Transformed ${data}`;
  }
  
  saveData(data) {
    console.log(`Сохранение преобразованных данных: ${data}`);
  }
}

class JSONDataProcessor extends DataProcessor {
  loadData() {
    console.log('Загрузка JSON данных');
    return 'JSON data';
  }
  
  transformData(data) {
    console.log('Преобразование JSON данных');
    return `Transformed ${data}`;
  }
  
  saveData(data) {
    console.log(`Сохранение преобразованных данных: ${data}`);
  }
}

// Использование
const csvProcessor = new CSVDataProcessor();
csvProcessor.process();
// Загрузка CSV данных
// Преобразование CSV данных
// Сохранение преобразованных данных: Transformed CSV data
// Обработка данных завершена

const jsonProcessor = new JSONDataProcessor();
jsonProcessor.process();
// Загрузка JSON данных
// Преобразование JSON данных
// Сохранение преобразованных данных: Transformed JSON data
// Обработка данных завершена
```

#### Пример на TypeScript
```typescript
// Абстрактный класс
abstract class DataProcessor {
  // Шаблонный метод
  public process(): void {
    const data = this.loadData();
    const processedData = this.transformData(data);
    this.saveData(processedData);
    this.onComplete();
  }
  
  protected abstract loadData(): any;
  protected abstract transformData(data: any): any;
  protected abstract saveData(data: any): void;
  
  // Хук
  protected onComplete(): void {
    console.log('Обработка данных завершена');
  }
}

// Конкретные реализации
class CSVDataProcessor extends DataProcessor {
  protected loadData(): any {
    console.log('Загрузка CSV данных');
    return 'CSV data';
  }
  
  protected transformData(data: any): any {
    console.log('Преобразование CSV данных');
    return `Transformed ${data}`;
  }
  
  protected saveData(data: any): void {
    console.log(`Сохранение преобразованных данных: ${data}`);
  }
}

class JSONDataProcessor extends DataProcessor {
  protected loadData(): any {
    console.log('Загрузка JSON данных');
    return 'JSON data';
  }
  
  protected transformData(data: any): any {
    console.log('Преобразование JSON данных');
    return `Transformed ${data}`;
  }
  
  protected saveData(data: any): void {
    console.log(`Сохранение преобразованных данных: ${data}`);
  }
}

// Использование
const csvProcessor = new CSVDataProcessor();
csvProcessor.process();
// Загрузка CSV данных
// Преобразование CSV данных
// Сохранение преобразованных данных: Transformed CSV data
// Обработка данных завершена

const jsonProcessor = new JSONDataProcessor();
jsonProcessor.process();
// Загрузка JSON данных
// Преобразование JSON данных
// Сохранение преобразованных данных: Transformed JSON data
// Обработка данных завершена
```

#### Когда использовать
- Когда нужно определить алгоритм в базовом классе
- Когда нужно позволить подклассам переопределять определенные шаги
- Когда нужно избежать дублирования кода

#### Преимущества
- Позволяет повторно использовать код
- Позволяет легко добавлять новые реализации
- Позволяет инвертировать зависимость

#### Недостатки
- Может усложнить отладку
- Подклассы могут быть ограниченными в переопределении

### 6. Iterator (Итератор)

Паттерн, предоставляющий способ последовательного доступа ко всем элементам составного объекта без раскрытия его внутреннего представления.

#### Проблема
Когда нужно обеспечить последовательный доступ к элементам объекта без раскрытия его внутренней структуры.

#### Решение
Создать интерфейс итератора, который предоставляет методы для доступа к элементам объекта.

#### Пример на JavaScript
```javascript
// Итератор
class Iterator {
  hasNext() {
    throw new Error('HasNext method must be implemented');
  }
  
  next() {
    throw new Error('Next method must be implemented');
  }
}

// Конкретный итератор
class ArrayIterator extends Iterator {
  constructor(array) {
    super();
    this.array = array;
    this.index = 0;
  }
  
  hasNext() {
    return this.index < this.array.length;
  }
  
  next() {
    if (this.hasNext()) {
      return this.array[this.index++];
    }
    return null;
  }
}

// Агрегат
class Collection {
  constructor(items = []) {
    this.items = items;
  }
  
  createIterator() {
    return new ArrayIterator(this.items);
  }
}

// Использование
const collection = new Collection([1, 2, 3, 4, 5]);
const iterator = collection.createIterator();

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// 1
// 2
// 3
// 4
// 5
```

#### Пример на TypeScript
```typescript
// Интерфейс итератора
interface Iterator<T> {
  hasNext(): boolean;
  next(): T | null;
}

// Конкретный итератор
class ArrayIterator<T> implements Iterator<T> {
  private array: T[];
  private index: number = 0;
  
  constructor(array: T[]) {
    this.array = array;
  }
  
  public hasNext(): boolean {
    return this.index < this.array.length;
  }
  
  public next(): T | null {
    if (this.hasNext()) {
      return this.array[this.index++];
    }
    return null;
  }
}

// Агрегат
class Collection<T> {
  private items: T[];
  
  constructor(items: T[] = []) {
    this.items = items;
  }
  
  public createIterator(): Iterator<T> {
    return new ArrayIterator<T>(this.items);
  }
}

// Использование
const collection = new Collection<number>([1, 2, 3, 4, 5]);
const iterator = collection.createIterator();

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// 1
// 2
// 3
// 4
// 5
```

#### Когда использовать
- Когда нужно обеспечить последовательный доступ к элементам объекта
- Когда нужно избежать раскрытия внутренней структуры объекта
- Когда нужно поддерживать несколько способов обхода

#### Преимущества
- Позволяет обходить объекты последовательно
- Позволяет использовать разные способы обхода
- Скрывает внутреннюю структуру объекта

#### Недостатки
- Может быть неэффективным для простых коллекций
- Может усложнить код для простых случаев

### 7. Mediator (Посредник)

Паттерн, определяющий объект, инкапсулирующий способ взаимодействия множества объектов.

#### Проблема
Когда объекты напрямую связаны друг с другом, создавая сложную сеть зависимостей.

#### Решение
Создать посредника, который управляет взаимодействием между объектами.

#### Пример на JavaScript
```javascript
// Посредник
class ChatRoom {
  showMessage(user, message) {
    const time = new Date().toLocaleTimeString();
    const sender = user.getName();
    console.log(`[${time}] ${sender}: ${message}`);
  }
}

// Коллега
class User {
  constructor(name, chatRoom) {
    this.name = name;
    this.chatRoom = chatRoom;
  }
  
  getName() {
    return this.name;
  }
  
  send(message) {
    this.chatRoom.showMessage(this, message);
  }
}

// Использование
const chatRoom = new ChatRoom();

const user1 = new User('Алексей', chatRoom);
const user2 = new User('Мария', chatRoom);

user1.send('Привет, Мария!');
user2.send('Привет, Алексей!');
// [10:30:15] Алексей: Привет, Мария!
// [10:30:16] Мария: Привет, Алексей!
```

#### Пример на TypeScript
```typescript
// Посредник
class ChatRoom {
  public showMessage(user: User, message: string): void {
    const time = new Date().toLocaleTimeString();
    const sender = user.getName();
    console.log(`[${time}] ${sender}: ${message}`);
  }
}

// Коллега
class User {
  private name: string;
  private chatRoom: ChatRoom;
  
  constructor(name: string, chatRoom: ChatRoom) {
    this.name = name;
    this.chatRoom = chatRoom;
  }
  
  public getName(): string {
    return this.name;
  }
  
  public send(message: string): void {
    this.chatRoom.showMessage(this, message);
  }
}

// Использование
const chatRoom = new ChatRoom();

const user1 = new User('Алексей', chatRoom);
const user2 = new User('Мария', chatRoom);

user1.send('Привет, Мария!');
user2.send('Привет, Алексей!');
// [10:30:15] Алексей: Привет, Мария!
// [10:30:16] Мария: Привет, Алексей!
```

#### Когда использовать
- Когда объекты связаны сложной сетью зависимостей
- Когда нужно избежать прямых ссылок между объектами
- Когда нужно централизовать управление взаимодействием

#### Преимущества
- Уменьшает зависимости между объектами
- Упрощает взаимодействие между объектами
- Централизует управление

#### Недостатки
- Посредник может стать слишком сложным
- Может создать точку отказа

### 8. Memento (Снимок)

Паттерн, позволяющий сохранять и восстанавливать предыдущие состояния объекта без раскрытия его внутренней структуры.

#### Проблема
Когда нужно сохранить и восстановить состояние объекта, но при этом избежать раскрытия внутренней структуры.

#### Решение
Создать снимок состояния объекта, который может быть использован для восстановления.

#### Пример на JavaScript
```javascript
// Снимок
class Memento {
  constructor(state) {
    this.state = state;
  }
  
  getState() {
    return this.state;
  }
}

// Создатель
class Editor {
  constructor() {
    this.content = '';
  }
  
  type(words) {
    this.content = this.content + words;
  }
  
  getContent() {
    return this.content;
  }
  
  save() {
    return new Memento(this.content);
  }
  
  restore(memento) {
    this.content = memento.getState();
  }
}

// Опекун
class Caretaker {
  constructor() {
    this.mementos = [];
  }
  
  addMemento(memento) {
    this.mementos.push(memento);
  }
  
  getMemento() {
    return this.mementos.pop();
  }
  
  getHistory() {
    return this.mementos.map((memento, index) => `Снимок ${index + 1}: ${memento.getState()}`);
  }
}

// Использование
const editor = new Editor();
const caretaker = new Caretaker();

editor.type('Первая строка\n');
caretaker.addMemento(editor.save());

editor.type('Вторая строка\n');
caretaker.addMemento(editor.save());

editor.type('Третья строка\n');
console.log('Текущий контент:');
console.log(editor.getContent());

console.log('История снимков:');
console.log(caretaker.getHistory());

editor.restore(caretaker.getMemento());
console.log('После восстановления:');
console.log(editor.getContent());
```

#### Пример на TypeScript
```typescript
// Снимок
class Memento {
  private state: string;
  
  constructor(state: string) {
    this.state = state;
  }
  
  public getState(): string {
    return this.state;
  }
}

// Создатель
class Editor {
  private content: string = '';
  
  public type(words: string): void {
    this.content = this.content + words;
  }
  
  public getContent(): string {
    return this.content;
  }
  
  public save(): Memento {
    return new Memento(this.content);
  }
  
  public restore(memento: Memento): void {
    this.content = memento.getState();
  }
}

// Опекун
class Caretaker {
  private mementos: Memento[] = [];
  
  public addMemento(memento: Memento): void {
    this.mementos.push(memento);
  }
  
  public getMemento(): Memento | undefined {
    return this.mementos.pop();
  }
  
  public getHistory(): string[] {
    return this.mementos.map((memento, index) => `Снимок ${index + 1}: ${memento.getState()}`);
  }
}

// Использование
const editor = new Editor();
const caretaker = new Caretaker();

editor.type('Первая строка\n');
caretaker.addMemento(editor.save());

editor.type('Вторая строка\n');
caretaker.addMemento(editor.save());

editor.type('Третья строка\n');
console.log('Текущий контент:');
console.log(editor.getContent());

console.log('История снимков:');
console.log(caretaker.getHistory());

editor.restore(caretaker.getMemento()!);
console.log('После восстановления:');
console.log(editor.getContent());
```

#### Когда использовать
- Когда нужно сохранить и восстановить состояние объекта
- Когда прямое получение состояния нарушает инкапсуляцию
- Когда нужно реализовать отмену операций

#### Преимущества
- Позволяет восстановить предыдущее состояние
- Сохраняет инкапсуляцию объекта
- Позволяет реализовать отмену операций

#### Недостатки
- Может потреблять много памяти
- Может усложнить код

### 9. Visitor (Посетитель)

Паттерн, позволяющий добавлять новые операции к объектам без изменения их классов.

#### Проблема
Когда нужно добавить новые операции к объектам, но изменение их классов невозможно или нежелательно.

#### Решение
Создать посетителя, который реализует операции для разных типов объектов.

#### Пример на JavaScript
```javascript
// Интерфейс элемента
class Element {
  accept(visitor) {
    throw new Error('Accept method must be implemented');
  }
}

// Конкретные элементы
class Shape extends Element {
  constructor(name) {
    super();
    this.name = name;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super('Circle');
    this.radius = radius;
  }
  
  accept(visitor) {
    visitor.visitCircle(this);
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super('Rectangle');
    this.width = width;
    this.height = height;
  }
  
  accept(visitor) {
    visitor.visitRectangle(this);
  }
}

// Посетитель
class AreaCalculator {
  visitCircle(circle) {
    const area = Math.PI * circle.radius * circle.radius;
    console.log(`Площадь круга с радиусом ${circle.radius}: ${area.toFixed(2)}`);
  }
  
  visitRectangle(rectangle) {
    const area = rectangle.width * rectangle.height;
    console.log(`Площадь прямоугольника ${rectangle.width}x${rectangle.height}: ${area}`);
  }
}

class PerimeterCalculator {
  visitCircle(circle) {
    const perimeter = 2 * Math.PI * circle.radius;
    console.log(`Периметр круга с радиусом ${circle.radius}: ${perimeter.toFixed(2)}`);
  }
  
  visitRectangle(rectangle) {
    const perimeter = 2 * (rectangle.width + rectangle.height);
    console.log(`Периметр прямоугольника ${rectangle.width}x${rectangle.height}: ${perimeter}`);
  }
}

// Использование
const shapes = [
  new Circle(5),
  new Rectangle(4, 6)
];

const areaCalculator = new AreaCalculator();
const perimeterCalculator = new PerimeterCalculator();

shapes.forEach(shape => {
  shape.accept(areaCalculator);
  shape.accept(perimeterCalculator);
});
```

#### Пример на TypeScript
```typescript
// Интерфейс элемента
interface Element {
  accept(visitor: Visitor): void;
}

// Интерфейс посетителя
interface Visitor {
  visitCircle(circle: Circle): void;
  visitRectangle(rectangle: Rectangle): void;
}

// Конкретные элементы
abstract class Shape implements Element {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  public abstract accept(visitor: Visitor): void;
}

class Circle extends Shape {
  public radius: number;
  
  constructor(radius: number) {
    super('Circle');
    this.radius = radius;
  }
  
  public accept(visitor: Visitor): void {
    visitor.visitCircle(this);
  }
}

class Rectangle extends Shape {
  public width: number;
  public height: number;
  
  constructor(width: number, height: number) {
    super('Rectangle');
    this.width = width;
    this.height = height;
  }
  
  public accept(visitor: Visitor): void {
    visitor.visitRectangle(this);
  }
}

// Посетители
class AreaCalculator implements Visitor {
  public visitCircle(circle: Circle): void {
    const area = Math.PI * circle.radius * circle.radius;
    console.log(`Площадь круга с радиусом ${circle.radius}: ${area.toFixed(2)}`);
  }
  
  public visitRectangle(rectangle: Rectangle): void {
    const area = rectangle.width * rectangle.height;
    console.log(`Площадь прямоугольника ${rectangle.width}x${rectangle.height}: ${area}`);
  }
}

class PerimeterCalculator implements Visitor {
  public visitCircle(circle: Circle): void {
    const perimeter = 2 * Math.PI * circle.radius;
    console.log(`Периметр круга с радиусом ${circle.radius}: ${perimeter.toFixed(2)}`);
  }
  
  public visitRectangle(rectangle: Rectangle): void {
    const perimeter = 2 * (rectangle.width + rectangle.height);
    console.log(`Периметр прямоугольника ${rectangle.width}x${rectangle.height}: ${perimeter}`);
  }
}

// Использование
const shapes: Shape[] = [
  new Circle(5),
  new Rectangle(4, 6)
];

const areaCalculator = new AreaCalculator();
const perimeterCalculator = new PerimeterCalculator();

shapes.forEach(shape => {
  shape.accept(areaCalculator);
  shape.accept(perimeterCalculator);
});
```

#### Когда использовать
- Когда нужно добавить новые операции к объектам без изменения их классов
- Когда у объектов сложная структура и нужно выполнить операции над ними
- Когда операции часто изменяются

#### Преимущества
- Позволяет добавлять новые операции без изменения классов
- Позволяет группировать связанные операции
- Позволяет выполнять операции над сложными структурами

#### Недостатки
- Может усложнить код
- Требует обновления посетителя при добавлении новых классов

## Практические рекомендации для фронтенд-разработчиков

### 1. Observer в фронтенде
В фронтенд-разработке Observer широко используется для:
- Управления состоянием приложения (Redux, Vuex)
- Обработки событий DOM
- Реализации реактивных систем (React, Vue, Angular)
- Подписки на изменения данных

> [!tip] Совет
> В современных фреймворках Observer часто реализован под капотом. Например, в React это работает через хуки useState и useEffect, а в Vue - через реактивную систему.

### 2. Strategy в фронтенде
Strategy полезен для:
- Выбора различных методов валидации форм
- Выбора стратегии рендеринга (SSR, CSR, SSG)
- Выбора различных способов аутентификации
- Выбора стратегии кэширования данных

### 3. Command в фронтенде
Command особенно полезен для:
- Реализации отмены/повтора действий (например, в редакторах)
- Логирования операций пользователя
- Создания очередей задач
- Реализации транзакций

### 4. State в фронтенде
State может быть использован для:
- Управления состоянием UI-компонентов (например, кнопки с разными состояниями)
- Управления процессом аутентификации (неавторизован, авторизован, ошибка)
- Управления загрузкой данных (загрузка, успех, ошибка)

### 5. Template Method в фронтенде
Template Method полезен для:
- Создания шаблонов компонентов
- Реализации общих процессов (например, процесс загрузки данных)
- Создания каркасов для страниц с разными реализациями

### 6. Iterator в фронтенде
Iterator особенно полезен для:
- Обхода коллекций данных
- Реализации пользовательских переборов
- Создания сложных структур данных с пользовательской логикой перебора

### 7. Mediator в фронтенде
Mediator может быть использован для:
- Централизованного управления событиями
- Коммуникации между компонентами
- Управления маршрутами
- Централизованного управления состоянием

### 8. Memento в фронтенде
Memento особенно полезен для:
- Реализации отмены/повтора действий
- Сохранения состояния формы
- Создания точек восстановления в приложении

### 9. Visitor в фронтенде
Visitor может быть использован для:
- Обработки сложных структур данных
- Анализа AST (Abstract Syntax Tree) в компиляторах/транспайлерах
- Применения различных операций к компонентам дерева

## Заключение

Поведенческие паттерны проектирования играют ключевую роль в создании гибких и поддерживаемых приложений. Они определяют, как объекты взаимодействуют друг с другом, и обеспечивают четкое распределение обязанностей.

В контексте фронтенд-разработки эти паттерны особенно важны, поскольку они помогают управлять сложными взаимодействиями между компонентами, обрабатывать пользовательские события и управлять состоянием приложения. Понимание этих паттернов позволяет разработчикам создавать более предсказуемые и надежные приложения.

[[Порождающие-паттерны]] | [[Структурные-паттерны]] | [[Архитектурные-паттерны]] | [[Паттерны-для-фронтенда]]