---
aliases: ["Structural Patterns", "Структурные паттерны"]
tags: ["#programming", "#design-patterns", "#frontend", "#javascript"]
---

# Структурные паттерны (Structural Patterns)

Структурные паттерны проектирования связаны с композицией классов и объектов. Они помогают обеспечить, чтобы если одна часть системы изменяется, все остальные части системы не требуют изменений. Эти паттерны фокусируются на создании связей между сущностями, позволяя им работать вместе эффективно.

## Обзор

Структурные паттерны обеспечивают гибкие способы построения отношений между классами и объектами. Они помогают объединять классы и объекты в более крупные структуры, сохраняя при этом гибкость и эффективность этих структур.

## Паттерны

### 1. Adapter (Адаптер)

Паттерн, позволяющий объектам с несовместимыми интерфейсами работать вместе.

#### Проблема
Иногда возникает необходимость использовать класс, который не подходит для текущей задачи из-за несовместимого интерфейса.

#### Решение
Создать адаптер, который выступает в роли посредника между двумя классами с несовместимыми интерфейсами.

#### Пример на JavaScript
```javascript
// Старый интерфейс
class OldSystem {
  oldRequest() {
    return 'Старый формат данных';
  }
}

// Новый интерфейс
class NewSystem {
  newRequest() {
    return 'Новый формат данных';
  }
}

// Адаптер
class SystemAdapter {
  constructor(legacySystem) {
    this.legacySystem = legacySystem;
  }
  
  newRequest() {
    const oldData = this.legacySystem.oldRequest();
    return `Адаптированные данные: ${oldData}`;
  }
}

// Использование
const oldSystem = new OldSystem();
const adapter = new SystemAdapter(oldSystem);

console.log(adapter.newRequest()); // Адаптированные данные: Старый формат данных
```

#### Пример на TypeScript
```typescript
// Старый интерфейс
class OldSystem {
  public oldRequest(): string {
    return 'Старый формат данных';
  }
}

// Новый интерфейс
interface NewSystemInterface {
  newRequest(): string;
}

class NewSystem implements NewSystemInterface {
  public newRequest(): string {
    return 'Новый формат данных';
  }
}

// Адаптер
class SystemAdapter implements NewSystemInterface {
  private legacySystem: OldSystem;
  
  constructor(legacySystem: OldSystem) {
    this.legacySystem = legacySystem;
  }
  
  public newRequest(): string {
    const oldData = this.legacySystem.oldRequest();
    return `Адаптированные данные: ${oldData}`;
  }
}

// Использование
const oldSystem = new OldSystem();
const adapter = new SystemAdapter(oldSystem);

console.log(adapter.newRequest()); // Адаптированные данные: Старый формат данных
```

#### Когда использовать
- Когда нужно использовать существующий класс, но его интерфейс не соответствует потребностям
- Когда нужно создать класс, который совместим с другими классами с разными интерфейсами
- Когда нужно использовать несколько существующих подклассов, отличающихся только поведением

#### Преимущества
- Позволяет использовать классы с несовместимыми интерфейсами
- Повышает повторное использование существующего кода
- Позволяет отделить новую функциональность от старой

#### Недостатки
- Усложняет код из-за дополнительного слоя абстракции
- Может привести к трудностям в отладке

### 2. Bridge (Мост)

Паттерн, разделяющий абстракцию и реализацию, чтобы их можно было изменять независимо друг от друга.

#### Проблема
Когда изменения в абстракции требуют изменений в реализации, и наоборот, создается жесткая связь между ними.

#### Решение
Создать структуру, в которой абстракция и реализация могут изменяться независимо друг от друга.

#### Пример на JavaScript
```javascript
// Реализация
class Implementation {
  operationImplementation() {
    return 'Реализация по умолчанию';
  }
}

class ConcreteImplementationA extends Implementation {
  operationImplementation() {
    return 'Реализация A';
  }
}

class ConcreteImplementationB extends Implementation {
  operationImplementation() {
    return 'Реализация B';
  }
}

// Абстракция
class Abstraction {
  constructor(implementation) {
    this.implementation = implementation;
  }
  
  operation() {
    const result = this.implementation.operationImplementation();
    return `Абстракция: ${result}`;
  }
}

class ExtendedAbstraction extends Abstraction {
  operation() {
    const result = this.implementation.operationImplementation();
    return `Расширенная абстракция: ${result}`;
  }
}

// Использование
const implementationA = new ConcreteImplementationA();
const abstraction = new Abstraction(implementationA);
console.log(abstraction.operation()); // Абстракция: Реализация A

const implementationB = new ConcreteImplementationB();
const extendedAbstraction = new ExtendedAbstraction(implementationB);
console.log(extendedAbstraction.operation()); // Расширенная абстракция: Реализация B
```

#### Пример на TypeScript
```typescript
// Интерфейс реализации
interface ImplementationInterface {
  operationImplementation(): string;
}

// Конкретные реализации
class ConcreteImplementationA implements ImplementationInterface {
  public operationImplementation(): string {
    return 'Реализация A';
  }
}

class ConcreteImplementationB implements ImplementationInterface {
  public operationImplementation(): string {
    return 'Реализация B';
  }
}

// Абстракция
abstract class Abstraction {
  protected implementation: ImplementationInterface;
  
  constructor(implementation: ImplementationInterface) {
    this.implementation = implementation;
  }
  
  public abstract operation(): string;
}

class RefinedAbstraction extends Abstraction {
  constructor(implementation: ImplementationInterface) {
    super(implementation);
  }
  
  public operation(): string {
    const result = this.implementation.operationImplementation();
    return `Уточненная абстракция: ${result}`;
  }
}

// Использование
const implementationA = new ConcreteImplementationA();
const abstraction = new RefinedAbstraction(implementationA);
console.log(abstraction.operation()); // Уточненная абстракция: Реализация A

const implementationB = new ConcreteImplementationB();
const extendedAbstraction = new RefinedAbstraction(implementationB);
console.log(extendedAbstraction.operation()); // Уточненная абстракция: Реализация B
```

#### Когда использовать
- Когда нужно изменять реализацию независимо от абстракции
- Когда нужно избежать жесткой связи между абстракцией и реализацией
- Когда нужно разделить монолитный класс на несколько иерархий

#### Преимущества
- Позволяет изменять абстракцию и реализацию независимо
- Следует принципу открытости/закрытости
- Позволяет использовать реализацию в нескольких абстракциях

#### Недостатки
- Может усложнить код из-за дополнительного уровня абстракции
- Требует более сложного понимания архитектуры

### 3. Composite (Компоновщик)

Паттерн, позволяющий клиентскому коду обрабатывать группы объектов так же, как и отдельные объекты.

#### Проблема
Когда нужно обрабатывать древовидные структуры, где элементы могут быть как отдельными объектами, так и составными.

#### Решение
Создать иерархию компонентов, где отдельные объекты и группы объектов обрабатываются одинаково.

#### Пример на JavaScript
```javascript
// Компонент
class Component {
  constructor(name) {
    this.name = name;
  }
  
  add(component) {
    throw new Error('Add method must be implemented');
  }
  
  remove(component) {
    throw new Error('Remove method must be implemented');
  }
  
  display(depth = 0) {
    throw new Error('Display method must be implemented');
  }
}

// Листовой элемент
class Leaf extends Component {
  constructor(name) {
    super(name);
  }
  
  add(component) {
    console.log('Cannot add to a leaf');
  }
  
  remove(component) {
    console.log('Cannot remove from a leaf');
  }
  
  display(depth = 0) {
    console.log(' '.repeat(depth) + this.name);
  }
}

// Композитный элемент
class Composite extends Component {
  constructor(name) {
    super(name);
    this.children = [];
  }
  
  add(component) {
    this.children.push(component);
  }
  
  remove(component) {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  display(depth = 0) {
    console.log(' '.repeat(depth) + this.name);
    this.children.forEach(child => {
      child.display(depth + 2);
    });
  }
}

// Использование
const root = new Composite('root');
const branch1 = new Composite('branch1');
const branch2 = new Composite('branch2');

const leaf1 = new Leaf('leaf1');
const leaf2 = new Leaf('leaf2');
const leaf3 = new Leaf('leaf3');

root.add(branch1);
root.add(branch2);

branch1.add(leaf1);
branch1.add(leaf2);

branch2.add(leaf3);

root.display();
// Вывод:
// root
//   branch1
//     leaf1
//     leaf2
//   branch2
//     leaf3
```

#### Пример на TypeScript
```typescript
// Интерфейс компонента
interface ComponentInterface {
  add(component: ComponentInterface): void;
  remove(component: ComponentInterface): void;
  display(depth?: number): void;
}

// Листовой элемент
class Leaf implements ComponentInterface {
  private name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  public add(component: ComponentInterface): void {
    console.log('Cannot add to a leaf');
  }
  
  public remove(component: ComponentInterface): void {
    console.log('Cannot remove from a leaf');
  }
  
  public display(depth: number = 0): void {
    console.log(' '.repeat(depth) + this.name);
  }
}

// Композитный элемент
class Composite implements ComponentInterface {
  private name: string;
  private children: ComponentInterface[] = [];
  
  constructor(name: string) {
    this.name = name;
  }
  
  public add(component: ComponentInterface): void {
    this.children.push(component);
  }
  
  public remove(component: ComponentInterface): void {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  public display(depth: number = 0): void {
    console.log(' '.repeat(depth) + this.name);
    this.children.forEach(child => {
      child.display(depth + 2);
    });
  }
}

// Использование
const root = new Composite('root');
const branch1 = new Composite('branch1');
const branch2 = new Composite('branch2');

const leaf1 = new Leaf('leaf1');
const leaf2 = new Leaf('leaf2');
const leaf3 = new Leaf('leaf3');

root.add(branch1);
root.add(branch2);

branch1.add(leaf1);
branch1.add(leaf2);

branch2.add(leaf3);

root.display();
// Вывод:
// root
//   branch1
//     leaf1
//     leaf2
//   branch2
//     leaf3
```

#### Когда использовать
- Когда нужно представлять древовидные структуры
- Когда клиентский код должен обрабатывать как отдельные объекты, так и группы объектов
- Когда нужно обеспечить единообразную обработку всех элементов структуры

#### Преимущества
- Позволяет легко добавлять новые типы компонентов
- Упрощает архитектуру клиента
- Облегчает добавление новых функций

#### Недостатки
- Может привести к созданию слишком общих классов
- Трудно ограничить типы компонентов в композите

### 4. Decorator (Декоратор)

Паттерн, позволяющий динамически добавлять объектам новую функциональность, оборачивая их в полезные "обертки".

#### Проблема
Когда нужно добавить дополнительную функциональность объекту, но наследование не подходит.

#### Решение
Обернуть объект в декоратор, который добавляет новую функциональность.

#### Пример на JavaScript
```javascript
// Базовый интерфейс
class Coffee {
  cost() {
    return 5;
  }
  
  description() {
    return 'Обычный кофе';
  }
}

// Декоратор
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost();
  }
  
  description() {
    return this.coffee.description();
  }
}

// Конкретные декораторы
class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2;
  }
  
  description() {
    return `${this.coffee.description()}, молоко`;
  }
}

class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1;
  }
  
  description() {
    return `${this.coffee.description()}, сахар`;
  }
}

class WhipDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 3;
  }
  
  description() {
    return `${this.coffee.description()}, взбитые сливки`;
  }
}

// Использование
let coffee = new Coffee();
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе: $5

coffee = new MilkDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко: $7

coffee = new SugarDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко, сахар: $8

coffee = new WhipDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко, сахар, взбитые сливки: $11
```

#### Пример на TypeScript
```typescript
// Базовый интерфейс
interface CoffeeInterface {
  cost(): number;
  description(): string;
}

class Coffee implements CoffeeInterface {
  public cost(): number {
    return 5;
  }
  
  public description(): string {
    return 'Обычный кофе';
  }
}

// Абстрактный декоратор
abstract class CoffeeDecorator implements CoffeeInterface {
  protected coffee: CoffeeInterface;
  
  constructor(coffee: CoffeeInterface) {
    this.coffee = coffee;
  }
  
  public abstract cost(): number;
  public abstract description(): string;
}

// Конкретные декораторы
class MilkDecorator extends CoffeeDecorator {
  public cost(): number {
    return this.coffee.cost() + 2;
  }
  
  public description(): string {
    return `${this.coffee.description()}, молоко`;
  }
}

class SugarDecorator extends CoffeeDecorator {
  public cost(): number {
    return this.coffee.cost() + 1;
  }
  
  public description(): string {
    return `${this.coffee.description()}, сахар`;
  }
}

class WhipDecorator extends CoffeeDecorator {
  public cost(): number {
    return this.coffee.cost() + 3;
  }
  
  public description(): string {
    return `${this.coffee.description()}, взбитые сливки`;
  }
}

// Использование
let coffee: CoffeeInterface = new Coffee();
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе: $5

coffee = new MilkDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко: $7

coffee = new SugarDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко, сахар: $8

coffee = new WhipDecorator(coffee);
console.log(`${coffee.description()}: $${coffee.cost()}`); // Обычный кофе, молоко, сахар, взбитые сливки: $11
```

#### Когда использовать
- Когда нужно добавить функциональность объекту во время выполнения
- Когда наследование не подходит для добавления функциональности
- Когда нужно добавить несколько функций к объекту

#### Преимущества
- Позволяет добавлять функциональность во время выполнения
- Позволяет комбинировать несколько функций
- Следует принципу открытости/закрытости

#### Недостатки
- Может привести к созданию множества маленьких объектов
- Усложняет отладку из-за сложной структуры объектов

### 5. Facade (Фасад)

Паттерн, предоставляющий упрощенный интерфейс к сложной системе классов, библиотеке или фреймворку.

#### Проблема
Когда система имеет сложный интерфейс, и клиентскому коду нужно взаимодействовать с несколькими частями системы.

#### Решение
Создать фасад, который предоставляет упрощенный интерфейс к сложной системе.

#### Пример на JavaScript
```javascript
// Подсистемы
class CPU {
  freeze() {
    console.log('CPU заморожен');
  }
  
  jump(position) {
    console.log(`CPU перешел к позиции ${position}`);
  }
  
  execute() {
    console.log('CPU выполняет команды');
  }
}

class Memory {
  load(position, data) {
    console.log(`Память загрузила данные ${data} в позицию ${position}`);
    return data;
  }
}

class HardDrive {
  read(lba, size) {
    console.log(`Жесткий диск прочитал ${size} байт с LBA ${lba}`);
    return 'boot data';
  }
}

// Фасад
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    console.log('Компьютер запускается...');
    this.cpu.freeze();
    const data = this.hardDrive.read(0, 1024);
    this.memory.load(0, data);
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('Компьютер запущен');
  }
}

// Использование
const computer = new ComputerFacade();
computer.start();
// Вывод:
// Компьютер запускается...
// CPU заморожен
// Жесткий диск прочитал 1024 байт с LBA 0
// Память загрузила данные boot data в позицию 0
// CPU перешел к позиции 0
// CPU выполняет команды
// Компьютер запущен
```

#### Пример на TypeScript
```typescript
// Подсистемы
class CPU {
  public freeze(): void {
    console.log('CPU заморожен');
  }
  
  public jump(position: number): void {
    console.log(`CPU перешел к позиции ${position}`);
  }
  
  public execute(): void {
    console.log('CPU выполняет команды');
  }
}

class Memory {
  public load(position: number, data: string): string {
    console.log(`Память загрузила данные ${data} в позицию ${position}`);
    return data;
  }
}

class HardDrive {
  public read(lba: number, size: number): string {
    console.log(`Жесткий диск прочитал ${size} байт с LBA ${lba}`);
    return 'boot data';
  }
}

// Фасад
class ComputerFacade {
  private cpu: CPU;
  private memory: Memory;
  private hardDrive: HardDrive;
  
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  public start(): void {
    console.log('Компьютер запускается...');
    this.cpu.freeze();
    const data = this.hardDrive.read(0, 1024);
    this.memory.load(0, data);
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('Компьютер запущен');
  }
}

// Использование
const computer = new ComputerFacade();
computer.start();
// Вывод:
// Компьютер запускается...
// CPU заморожен
// Жесткий диск прочитал 1024 байт с LBA 0
// Память загрузила данные boot data в позицию 0
// CPU перешел к позиции 0
// CPU выполняет команды
// Компьютер запущен
```

#### Когда использовать
- Когда нужно предоставить простой интерфейс к сложной системе
- Когда нужно уменьшить зависимости между клиентским кодом и подсистемами
- Когда нужно структурировать подсистемы в слои

#### Преимущества
- Упрощает интерфейс сложной системы
- Уменьшает зависимости между клиентским кодом и подсистемами
- Централизует управление подсистемами

#### Недостатки
- Может скрыть возможности подсистем
- Может стать бутылочным горлышком

### 6. Flyweight (Приспособленец)

Паттерн, позволяющий вместить больше объектов в доступную оперативную память, разделяя общее состояние между несколькими объектами.

#### Проблема
Когда создание большого количества похожих объектов приводит к нехватке памяти.

#### Решение
Разделить состояние объекта на внутреннее (общее) и внешнее (уникальное), и использовать кэширование общего состояния.

#### Пример на JavaScript
```javascript
// Легковесный объект
class TreeType {
  constructor(name, color, texture) {
    this.name = name;
    this.color = color;
    this.texture = texture;
  }
  
  draw(canvas, x, y) {
    console.log(`Рисуем ${this.name} дерево цвета ${this.color} на позиции (${x}, ${y})`);
  }
}

// Фабрика легковесных объектов
class TreeTypeFactory {
  constructor() {
    this.types = {};
  }
  
  getTreeType(name, color, texture) {
    if (!this.types[name]) {
      this.types[name] = new TreeType(name, color, texture);
    }
    return this.types[name];
  }
  
  getTreeTypesCount() {
    return Object.keys(this.types).length;
  }
}

// Контекстный объект
class Tree {
  constructor(x, y, treeType) {
    this.x = x;
    this.y = y;
    this.treeType = treeType;
  }
  
  draw(canvas) {
    this.treeType.draw(canvas, this.x, this.y);
  }
}

// Клиентский код
class Forest {
  constructor() {
    this.trees = [];
    this.treeFactory = new TreeTypeFactory();
  }
  
  plantTree(x, y, name, color, texture) {
    const treeType = this.treeFactory.getTreeType(name, color, texture);
    const tree = new Tree(x, y, treeType);
    this.trees.push(tree);
  }
  
  draw(canvas) {
    this.trees.forEach(tree => tree.draw(canvas));
  }
}

// Использование
const forest = new Forest();
forest.plantTree(1, 1, 'Дуб', 'зеленый', 'гладкая');
forest.plantTree(2, 2, 'Ель', 'темно-зеленый', 'шероховатая');
forest.plantTree(3, 3, 'Дуб', 'зеленый', 'гладкая'); // Использует уже созданный тип

console.log(`Всего уникальных типов деревьев: ${forest.treeFactory.getTreeTypesCount()}`); // 2
```

#### Пример на TypeScript
```typescript
// Легковесный объект
class TreeType {
  public name: string;
  public color: string;
  public texture: string;
  
  constructor(name: string, color: string, texture: string) {
    this.name = name;
    this.color = color;
    this.texture = texture;
  }
  
  public draw(canvas: string, x: number, y: number): void {
    console.log(`Рисуем ${this.name} дерево цвета ${this.color} на позиции (${x}, ${y})`);
  }
}

// Фабрика легковесных объектов
class TreeTypeFactory {
  private types: { [key: string]: TreeType } = {};
  
  public getTreeType(name: string, color: string, texture: string): TreeType {
    if (!this.types[name]) {
      this.types[name] = new TreeType(name, color, texture);
    }
    return this.types[name];
  }
  
  public getTreeTypesCount(): number {
    return Object.keys(this.types).length;
  }
}

// Контекстный объект
class Tree {
  private x: number;
  private y: number;
  private treeType: TreeType;
  
  constructor(x: number, y: number, treeType: TreeType) {
    this.x = x;
    this.y = y;
    this.treeType = treeType;
  }
  
  public draw(canvas: string): void {
    this.treeType.draw(canvas, this.x, this.y);
  }
}

// Клиентский код
class Forest {
  private trees: Tree[] = [];
  private treeFactory: TreeTypeFactory;
  
  constructor() {
    this.treeFactory = new TreeTypeFactory();
  }
  
  public plantTree(x: number, y: number, name: string, color: string, texture: string): void {
    const treeType = this.treeFactory.getTreeType(name, color, texture);
    const tree = new Tree(x, y, treeType);
    this.trees.push(tree);
  }
  
  public draw(canvas: string): void {
    this.trees.forEach(tree => tree.draw(canvas));
  }
}

// Использование
const forest = new Forest();
forest.plantTree(1, 1, 'Дуб', 'зеленый', 'гладкая');
forest.plantTree(2, 2, 'Ель', 'темно-зеленый', 'шероховатая');
forest.plantTree(3, 3, 'Дуб', 'зеленый', 'гладкая'); // Использует уже созданный тип

console.log(`Всего уникальных типов деревьев: ${forest['treeFactory'].getTreeTypesCount()}`); // 2
```

#### Когда использовать
- Когда приложение использует большое количество похожих объектов
- Когда создание объектов дорого обходится
- Когда большая часть состояния объекта может быть вынесена во внешнее состояние

#### Преимущества
- Уменьшает использование памяти
- Позволяет создавать большое количество объектов
- Ускоряет работу приложения

#### Недостатки
- Усложняет код из-за разделения состояния
- Может замедлить выполнение из-за дополнительных вызовов методов

### 7. Proxy (Заместитель)

Паттерн, позволяющий подставлять вместо реальных объектов специальные объекты-заменители, которые контролируют доступ к оригинальному объекту.

#### Проблема
Когда нужно контролировать доступ к объекту или добавить дополнительное поведение при обращении к объекту.

#### Решение
Создать заместителя, который действует как посредник между клиентом и реальным объектом.

#### Пример на JavaScript
```javascript
// Субъект
class RealImage {
  constructor(filename) {
    this.filename = filename;
    this.loadFromDisk();
  }
  
  loadFromDisk() {
    console.log(`Загружаем изображение: ${this.filename}`);
  }
  
  display() {
    console.log(`Отображаем изображение: ${this.filename}`);
  }
}

// Заместитель
class ProxyImage {
  constructor(filename) {
    this.filename = filename;
    this.realImage = null;
  }
  
  display() {
    if (!this.realImage) {
      this.realImage = new RealImage(this.filename);
    }
    this.realImage.display();
  }
}

// Использование
const image1 = new ProxyImage('фото1.jpg');
const image2 = new ProxyImage('фото2.jpg');

// Изображения не загружаются до вызова display()
image1.display(); // Загружаем изображение: фото1.jpg, Отображаем изображение: фото1.jpg
image1.display(); // Отображаем изображение: фото1.jpg (не загружаем снова)

image2.display(); // Загружаем изображение: фото2.jpg, Отображаем изображение: фото2.jpg
```

#### Пример на TypeScript
```typescript
// Субъект
interface ImageInterface {
  display(): void;
}

class RealImage implements ImageInterface {
  private filename: string;
  
  constructor(filename: string) {
    this.filename = filename;
    this.loadFromDisk();
  }
  
  private loadFromDisk(): void {
    console.log(`Загружаем изображение: ${this.filename}`);
  }
  
  public display(): void {
    console.log(`Отображаем изображение: ${this.filename}`);
  }
}

// Заместитель
class ProxyImage implements ImageInterface {
  private filename: string;
  private realImage: RealImage | null = null;
  
  constructor(filename: string) {
    this.filename = filename;
  }
  
  public display(): void {
    if (!this.realImage) {
      this.realImage = new RealImage(this.filename);
    }
    this.realImage.display();
  }
}

// Использование
const image1 = new ProxyImage('фото1.jpg');
const image2 = new ProxyImage('фото2.jpg');

// Изображения не загружаются до вызова display()
image1.display(); // Загружаем изображение: фото1.jpg, Отображаем изображение: фото1.jpg
image1.display(); // Отображаем изображение: фото1.jpg (не загружаем снова)

image2.display(); // Загружаем изображение: фото2.jpg, Отображаем изображение: фото2.jpg
```

#### Когда использовать
- Когда нужно отложенно создавать ресурсоемкий объект
- Когда нужно контролировать доступ к объекту
- Когда нужно добавить кэширование

#### Преимущества
- Позволяет контролировать объект
- Позволяет отложить создание ресурсоемких объектов
- Позволяет добавить дополнительное поведение

#### Недостатки
- Может усложнить код
- Может добавить дополнительную задержку

## Практические рекомендации для фронтенд-разработчиков

### 1. Adapter в фронтенде
В фронтенд-разработке Adapter часто используется для:
- Интеграции с внешними API, которые имеют несовместимый формат данных
- Обеспечения совместимости между различными версиями библиотек
- Адаптации данных от backend для использования в компонентах

> [!tip] Совет
> Используйте Adapter для преобразования ответов API в формат, удобный для использования в компонентах. Это упрощает поддержку кода и позволяет легко изменять формат данных.

### 2. Bridge в фронтенде
Bridge полезен для:
- Разделения логики компонентов от их представления
- Создания универсальных компонентов с различными реализациями
- Разделения бизнес-логики от UI-логики

### 3. Composite в фронтенде
Composite особенно полезен для:
- Создания древовидных структур компонентов (например, меню, навигация)
- Работы с DOM-элементами
- Создания композитных компонентов

### 4. Decorator в фронтенде
Decorator может быть использован для:
- Добавления функциональности к компонентам (например, логирование, аутентификация)
- Обертывания компонентов в HOC (Higher-Order Components)
- Добавления middleware к функциям

### 5. Facade в фронтенде
Facade полезен для:
- Создания простого интерфейса для сложных библиотек
- Упрощения работы с API
- Централизации вызовов различных сервисов

### 6. Flyweight в фронтенде
Flyweight может быть полезен для:
- Оптимизации производительности при работе с большим количеством однотипных элементов
- Экономии памяти при работе с DOM-элементами
- Создания виртуальных списков

### 7. Proxy в фронтенде
Proxy особенно полезен для:
- Создания реактивных систем (как в Vue.js)
- Валидации данных
- Кэширования
- Отложенной загрузки данных

> [!warning] Важно
> Proxy - это мощный инструмент, но его использование может повлиять на производительность. Используйте его с осторожностью и только когда действительно необходима дополнительная логика при доступе к объекту.

## Заключение

Структурные паттерны проектирования играют важную роль в создании гибких и масштабируемых приложений. Они помогают управлять отношениями между классами и объектами, обеспечивая чистую архитектуру и упрощая сопровождение кода.

В контексте фронтенд-разработки эти паттерны особенно полезны для управления сложностью UI-компонентов, оптимизации производительности и обеспечения совместимости между различными частями приложения. Понимание этих паттернов позволяет разработчикам создавать более надежные и поддерживаемые приложения.

[[Порождающие-паттерны]] | [[Поведенческие-паттерны]] | [[Архитектурные-паттерны]] | [[Паттерны-для-фронтенда]]