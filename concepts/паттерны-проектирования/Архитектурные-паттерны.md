---
aliases: ["Architectural Patterns", "Архитектурные паттерны"]
tags: ["#programming", "#design-patterns", "#frontend", "#javascript", "#architecture"]
---

# Архитектурные паттерны (Architectural Patterns)

Архитектурные паттерны определяют структуру и организацию программного приложения в целом. Они описывают, как компоненты приложения взаимодействуют друг с другом и как приложение в целом организовано. Эти паттерны помогают разработчикам принимать архитектурные решения на высоком уровне.

## Обзор

Архитектурные паттерны обеспечивают каркас для организации кода приложения. Они определяют основные слои приложения, их ответственность и способы взаимодействия. Эти паттерны особенно важны для масштабируемых приложений, где важно разделение ответственности и легкость сопровождения.

## Паттерны

### 1. MVC (Model-View-Controller)

Паттерн, разделяющий приложение на три основных компонента: модель, представление и контроллер.

#### Структура
- **Model (Модель)**: Отвечает за данные и бизнес-логику
- **View (Представление)**: Отвечает за отображение данных
- **Controller (Контроллер)**: Обрабатывает пользовательский ввод и координирует модель и представление

#### Проблема
Когда логика представления и бизнес-логика перемешаны, код становится трудным для сопровождения и тестирования.

#### Решение
Разделить приложение на три компонента с четкими обязанностями.

#### Пример на JavaScript
```javascript
// Модель
class UserModel {
  constructor() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
  }
  
  getUsers() {
    return this.users;
  }
  
  getUserById(id) {
    return this.users.find(user => user.id === id);
  }
}

// Представление
class UserView {
  displayUsers(users) {
    console.log('Список пользователей:');
    users.forEach(user => {
      console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    });
  }
  
  displayUser(user) {
    console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
  }
}

// Контроллер
class UserController {
  constructor(model, view) {
    this.model = model;
    this.view = view;
  }
  
  addUser(user) {
    this.model.addUser(user);
  }
  
  listUsers() {
    const users = this.model.getUsers();
    this.view.displayUsers(users);
  }
  
  findUser(id) {
    const user = this.model.getUserById(id);
    if (user) {
      this.view.displayUser(user);
    } else {
      console.log(`Пользователь с ID ${id} не найден`);
    }
  }
}

// Использование
const userModel = new UserModel();
const userView = new UserView();
const userController = new UserController(userModel, userView);

userController.addUser({ id: 1, name: 'Алексей', email: 'alex@example.com' });
userController.addUser({ id: 2, name: 'Мария', email: 'maria@example.com' });

userController.listUsers();
// Список пользователей:
// ID: 1, Имя: Алексей, Email: alex@example.com
// ID: 2, Имя: Мария, Email: maria@example.com

userController.findUser(1);
// Пользователь: ID: 1, Имя: Алексей, Email: alex@example.com
```

#### Пример на TypeScript
```typescript
// Интерфейс пользователя
interface User {
  id: number;
  name: string;
  email: string;
}

// Модель
class UserModel {
  private users: User[] = [];
  
  public addUser(user: User): void {
    this.users.push(user);
  }
  
  public getUsers(): User[] {
    return this.users;
  }
  
  public getUserById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
}

// Представление
class UserView {
  public displayUsers(users: User[]): void {
    console.log('Список пользователей:');
    users.forEach(user => {
      console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    });
  }
  
  public displayUser(user: User): void {
    console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
  }
}

// Контроллер
class UserController {
  private model: UserModel;
  private view: UserView;
  
  constructor(model: UserModel, view: UserView) {
    this.model = model;
    this.view = view;
  }
  
  public addUser(user: User): void {
    this.model.addUser(user);
  }
  
  public listUsers(): void {
    const users = this.model.getUsers();
    this.view.displayUsers(users);
  }
  
  public findUser(id: number): void {
    const user = this.model.getUserById(id);
    if (user) {
      this.view.displayUser(user);
    } else {
      console.log(`Пользователь с ID ${id} не найден`);
    }
  }
}

// Использование
const userModel = new UserModel();
const userView = new UserView();
const userController = new UserController(userModel, userView);

userController.addUser({ id: 1, name: 'Алексей', email: 'alex@example.com' });
userController.addUser({ id: 2, name: 'Мария', email: 'maria@example.com' });

userController.listUsers();
// Список пользователей:
// ID: 1, Имя: Алексей, Email: alex@example.com
// ID: 2, Имя: Мария, Email: maria@example.com

userController.findUser(1);
// Пользователь: ID: 1, Имя: Алексей, Email: alex@example.com
```

#### Когда использовать
- Когда нужно разделить бизнес-логику и представление
- Когда приложение имеет сложный пользовательский интерфейс
- Когда требуется поддержка нескольких представлений одного и того же набора данных

#### Преимущества
- Четкое разделение ответственности
- Повторное использование компонентов
- Легкость тестирования
- Поддержка нескольких представлений

#### Недостатки
- Может быть избыточным для простых приложений
- Сложность в реализации для начинающих
- Возможное увеличение сложности кода

### 2. MVP (Model-View-Presenter)

Паттерн, похожий на MVC, но с более тесной связью между представлением и презентером.

#### Структура
- **Model (Модель)**: Отвечает за данные и бизнес-логику
- **View (Представление)**: Отвечает за отображение и пользовательский интерфейс
- **Presenter (Презентер)**: Выступает посредником между моделью и представлением

#### Проблема
В MVC представление может напрямую взаимодействовать с моделью, что нарушает принципы разделения ответственности.

#### Решение
Ввести презентер, который полностью управляет взаимодействием между моделью и представлением.

#### Пример на JavaScript
```javascript
// Модель
class UserModel {
  constructor() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
  }
  
  getUsers() {
    return this.users;
  }
  
  getUserById(id) {
    return this.users.find(user => user.id === id);
  }
}

// Интерфейс представления
class UserViewInterface {
  showUsers(users) {
    throw new Error('ShowUsers method must be implemented');
  }
  
  showUser(user) {
    throw new Error('ShowUser method must be implemented');
  }
  
  showError(message) {
    throw new Error('ShowError method must be implemented');
  }
}

// Конкретное представление
class UserView extends UserViewInterface {
  showUsers(users) {
    console.log('Список пользователей:');
    users.forEach(user => {
      console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    });
  }
  
  showUser(user) {
    console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
  }
  
  showError(message) {
    console.log(`Ошибка: ${message}`);
  }
}

// Презентер
class UserPresenter {
  constructor(model, view) {
    this.model = model;
    this.view = view;
  }
  
  loadUsers() {
    try {
      const users = this.model.getUsers();
      this.view.showUsers(users);
    } catch (error) {
      this.view.showError('Ошибка при загрузке пользователей');
    }
  }
  
  findUser(id) {
    try {
      const user = this.model.getUserById(id);
      if (user) {
        this.view.showUser(user);
      } else {
        this.view.showError(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      this.view.showError('Ошибка при поиске пользователя');
    }
  }
  
  addUser(user) {
    try {
      this.model.addUser(user);
      this.loadUsers(); // Обновляем список после добавления
    } catch (error) {
      this.view.showError('Ошибка при добавлении пользователя');
    }
  }
}

// Использование
const userModel = new UserModel();
const userView = new UserView();
const userPresenter = new UserPresenter(userModel, userView);

userPresenter.addUser({ id: 1, name: 'Алексей', email: 'alex@example.com' });
userPresenter.addUser({ id: 2, name: 'Мария', email: 'maria@example.com' });

userPresenter.loadUsers();
// Список пользователей:
// ID: 1, Имя: Алексей, Email: alex@example.com
// ID: 2, Имя: Мария, Email: maria@example.com

userPresenter.findUser(1);
// Пользователь: ID: 1, Имя: Алексей, Email: alex@example.com
```

#### Пример на TypeScript
```typescript
// Интерфейс пользователя
interface User {
  id: number;
  name: string;
  email: string;
}

// Модель
class UserModel {
  private users: User[] = [];
  
  public addUser(user: User): void {
    this.users.push(user);
  }
  
  public getUsers(): User[] {
    return this.users;
  }
  
  public getUserById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
}

// Интерфейс представления
interface UserViewInterface {
  showUsers(users: User[]): void;
  showUser(user: User): void;
  showError(message: string): void;
}

// Конкретное представление
class UserView implements UserViewInterface {
  public showUsers(users: User[]): void {
    console.log('Список пользователей:');
    users.forEach(user => {
      console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    });
  }
  
  public showUser(user: User): void {
    console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
  }
  
  public showError(message: string): void {
    console.log(`Ошибка: ${message}`);
  }
}

// Презентер
class UserPresenter {
  private model: UserModel;
  private view: UserViewInterface;
  
  constructor(model: UserModel, view: UserViewInterface) {
    this.model = model;
    this.view = view;
  }
  
  public loadUsers(): void {
    try {
      const users = this.model.getUsers();
      this.view.showUsers(users);
    } catch (error) {
      this.view.showError('Ошибка при загрузке пользователей');
    }
  }
  
  public findUser(id: number): void {
    try {
      const user = this.model.getUserById(id);
      if (user) {
        this.view.showUser(user);
      } else {
        this.view.showError(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      this.view.showError('Ошибка при поиске пользователя');
    }
  }
  
  public addUser(user: User): void {
    try {
      this.model.addUser(user);
      this.loadUsers(); // Обновляем список после добавления
    } catch (error) {
      this.view.showError('Ошибка при добавлении пользователя');
    }
  }
}

// Использование
const userModel = new UserModel();
const userView = new UserView();
const userPresenter = new UserPresenter(userModel, userView);

userPresenter.addUser({ id: 1, name: 'Алексей', email: 'alex@example.com' });
userPresenter.addUser({ id: 2, name: 'Мария', email: 'maria@example.com' });

userPresenter.loadUsers();
// Список пользователей:
// ID: 1, Имя: Алексей, Email: alex@example.com
// ID: 2, Имя: Мария, Email: maria@example.com

userPresenter.findUser(1);
// Пользователь: ID: 1, Имя: Алексей, Email: alex@example.com
```

#### Когда использовать
- Когда нужно упростить тестирование представления
- Когда нужно уменьшить зависимость представления от модели
- Когда требуется более строгое разделение ответственности

#### Преимущества
- Лучшая тестируемость
- Четкое разделение ответственности
- Уменьшенная связанность между компонентами

#### Недостатки
- Может увеличить количество кода
- Сложность в управлении большим количеством презентеров

### 3. MVVM (Model-View-ViewModel)

Паттерн, разделяющий разработку графического пользовательского интерфейса на три части: модель, представление и модель представления.

#### Структура
- **Model (Модель)**: Отвечает за данные и бизнес-логику
- **View (Представление)**: Отвечает за отображение данных
- **ViewModel (Модель представления)**: Связывает представление и модель, обеспечивая двустороннюю привязку данных

#### Проблема
Когда представление напрямую связано с моделью, изменения в одной части могут повлиять на другую.

#### Решение
Ввести модель представления, которая обеспечивает двустороннюю привязку данных между представлением и моделью.

#### Пример на JavaScript
```javascript
// Модель
class UserModel {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  updateName(newName) {
    this.name = newName;
  }
  
  updateEmail(newEmail) {
    this.email = newEmail;
  }
}

// Модель представления
class UserViewModel {
  constructor(model) {
    this.model = model;
    this.name = model.name;
    this.email = model.email;
    
    // Двусторонняя привязка данных
    this.bindModelToViewModel();
    this.bindViewModelToView();
  }
  
  bindModelToViewModel() {
    // При изменении модели обновляем ViewModel
    const originalUpdateName = this.model.updateName.bind(this.model);
    this.model.updateName = (newName) => {
      originalUpdateName(newName);
      this.name = newName;
      this.notifyView();
    };
    
    const originalUpdateEmail = this.model.updateEmail.bind(this.model);
    this.model.updateEmail = (newEmail) => {
      originalUpdateEmail(newEmail);
      this.email = newEmail;
      this.notifyView();
    };
  }
  
  bindViewModelToView() {
    // При изменении ViewModel обновляем модель
    Object.defineProperty(this, 'name', {
      set: (value) => {
        this._name = value;
        this.model.updateName(value);
      },
      get: () => this._name
    });
    
    Object.defineProperty(this, 'email', {
      set: (value) => {
        this._email = value;
        this.model.updateEmail(value);
      },
      get: () => this._email
    });
    
    // Устанавливаем начальные значения
    this._name = this.model.name;
    this._email = this.model.email;
  }
  
  notifyView() {
    if (this.viewUpdateCallback) {
      this.viewUpdateCallback();
    }
  }
  
  setViewUpdateCallback(callback) {
    this.viewUpdateCallback = callback;
  }
  
  updateView() {
    console.log(`Обновление представления: ${this.name}, ${this.email}`);
  }
}

// Представление
class UserView {
  constructor(viewModel) {
    this.viewModel = viewModel;
    this.viewModel.setViewUpdateCallback(() => this.render());
  }
  
  render() {
    console.log(`Представление: Имя - ${this.viewModel.name}, Email - ${this.viewModel.email}`);
  }
}

// Использование
const userModel = new UserModel(1, 'Алексей', 'alex@example.com');
const userViewModel = new UserViewModel(userModel);
const userView = new UserView(userViewModel);

// Изменение через ViewModel
userViewModel.name = 'Александр';
// Это автоматически обновит модель и вызовет обновление представления

// Изменение через модель
userModel.updateEmail('alexander@example.com');
// Это автоматически обновит ViewModel и вызовет обновление представления
```

#### Пример на TypeScript
```typescript
// Интерфейс пользователя
interface User {
  id: number;
  name: string;
  email: string;
}

// Модель
class UserModel implements User {
  public id: number;
  public name: string;
  public email: string;
  
  constructor(id: number, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  public updateName(newName: string): void {
    this.name = newName;
  }
  
  public updateEmail(newEmail: string): void {
    this.email = newEmail;
  }
}

// Модель представления
class UserViewModel {
  private model: UserModel;
  private _name: string;
  private _email: string;
  private viewUpdateCallback?: () => void;
  
  constructor(model: UserModel) {
    this.model = model;
    this._name = model.name;
    this._email = model.email;
    
    // Двусторонняя привязка данных
    this.bindModelToViewModel();
  }
  
  private bindModelToViewModel(): void {
    // При изменении модели обновляем ViewModel
    const originalUpdateName = this.model.updateName.bind(this.model);
    this.model.updateName = (newName: string) => {
      originalUpdateName(newName);
      this._name = newName;
      this.notifyView();
    };
    
    const originalUpdateEmail = this.model.updateEmail.bind(this.model);
    this.model.updateEmail = (newEmail: string) => {
      originalUpdateEmail(newEmail);
      this._email = newEmail;
      this.notifyView();
    };
  }
  
  public setViewUpdateCallback(callback: () => void): void {
    this.viewUpdateCallback = callback;
  }
  
  private notifyView(): void {
    if (this.viewUpdateCallback) {
      this.viewUpdateCallback();
    }
  }
  
  // Геттеры и сеттеры для двусторонней привязки
  public get name(): string {
    return this._name;
  }
  
  public set name(value: string) {
    this._name = value;
    this.model.updateName(value);
  }
  
  public get email(): string {
    return this._email;
  }
  
  public set email(value: string) {
    this._email = value;
    this.model.updateEmail(value);
  }
  
  public updateView(): void {
    console.log(`Обновление представления: ${this.name}, ${this.email}`);
  }
}

// Представление
class UserView {
  private viewModel: UserViewModel;
  
  constructor(viewModel: UserViewModel) {
    this.viewModel = viewModel;
    this.viewModel.setViewUpdateCallback(() => this.render());
  }
  
  public render(): void {
    console.log(`Представление: Имя - ${this.viewModel.name}, Email - ${this.viewModel.email}`);
  }
}

// Использование
const userModel = new UserModel(1, 'Алексей', 'alex@example.com');
const userViewModel = new UserViewModel(userModel);
const userView = new UserView(userViewModel);

// Изменение через ViewModel
userViewModel.name = 'Александр';
// Это автоматически обновит модель и вызовет обновление представления

// Изменение через модель
userModel.updateEmail('alexander@example.com');
// Это автоматически обновит ViewModel и вызовет обновление представления
```

#### Когда использовать
- Когда требуется двусторонняя привязка данных
- Когда нужно упростить синхронизацию между представлением и моделью
- Когда используется фреймворк с поддержкой привязки данных (Angular, Vue)

#### Преимущества
- Двусторонняя привязка данных
- Упрощение синхронизации представления и модели
- Уменьшение кода для обновления интерфейса

#### Недостатки
- Может усложнить понимание потока данных
- Сложность в отладке привязок
- Может повлиять на производительность при частых обновлениях

### 4. Layered Architecture (Многоуровневая архитектура)

Паттерн, разделяющий приложение на несколько уровней, каждый из которых имеет свою специфическую ответственность.

#### Структура
- **Presentation Layer (Уровень представления)**: Отвечает за пользовательский интерфейс
- **Business Logic Layer (Уровень бизнес-логики)**: Содержит бизнес-правила
- **Data Access Layer (Уровень доступа к данным)**: Отвечает за взаимодействие с базой данных

#### Проблема
Когда все компоненты приложения перемешаны, становится трудно поддерживать и масштабировать приложение.

#### Решение
Разделить приложение на уровни с четкими границами ответственности.

#### Пример на JavaScript
```javascript
// Уровень доступа к данным
class UserRepository {
  constructor() {
    this.users = [
      { id: 1, name: 'Алексей', email: 'alex@example.com' },
      { id: 2, name: 'Мария', email: 'maria@example.com' }
    ];
  }
  
  findAll() {
    return this.users;
  }
  
  findById(id) {
    return this.users.find(user => user.id === id);
  }
  
  save(user) {
    if (!user.id) {
      user.id = this.users.length + 1;
    }
    this.users.push(user);
    return user;
  }
  
  update(id, userData) {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      this.users[index] = { ...this.users[index], ...userData };
      return this.users[index];
    }
    return null;
  }
  
  delete(id) {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  }
}

// Уровень бизнес-логики
class UserService {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }
  
  getAllUsers() {
    return this.userRepository.findAll();
  }
  
  getUserById(id) {
    if (id <= 0) {
      throw new Error('ID должен быть положительным числом');
    }
    return this.userRepository.findById(id);
  }
  
  createUser(userData) {
    // Бизнес-проверки
    if (!userData.name || !userData.email) {
      throw new Error('Имя и email обязательны');
    }
    
    if (userData.email.indexOf('@') === -1) {
      throw new Error('Некорректный email');
    }
    
    return this.userRepository.save(userData);
  }
  
  updateUser(id, userData) {
    const existingUser = this.userRepository.findById(id);
    if (!existingUser) {
      throw new Error('Пользователь не найден');
    }
    
    // Бизнес-проверки
    if (userData.email && userData.email.indexOf('@') === -1) {
      throw new Error('Некорректный email');
    }
    
    return this.userRepository.update(id, userData);
  }
  
  deleteUser(id) {
    const user = this.userRepository.findById(id);
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    // Бизнес-логика удаления
    return this.userRepository.delete(id);
  }
}

// Уровень представления
class UserController {
  constructor(userService) {
    this.userService = userService;
  }
  
  listUsers() {
    try {
      const users = this.userService.getAllUsers();
      console.log('Список пользователей:');
      users.forEach(user => {
        console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      });
    } catch (error) {
      console.error(`Ошибка при получении пользователей: ${error.message}`);
    }
  }
  
  getUser(id) {
    try {
      const user = this.userService.getUserById(id);
      if (user) {
        console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при получении пользователя: ${error.message}`);
    }
  }
  
  createUser(userData) {
    try {
      const user = this.userService.createUser(userData);
      console.log(`Пользователь создан: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    } catch (error) {
      console.error(`Ошибка при создании пользователя: ${error.message}`);
    }
  }
  
  updateUser(id, userData) {
    try {
      const user = this.userService.updateUser(id, userData);
      if (user) {
        console.log(`Пользователь обновлен: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при обновлении пользователя: ${error.message}`);
    }
  }
  
  deleteUser(id) {
    try {
      const user = this.userService.deleteUser(id);
      if (user) {
        console.log(`Пользователь удален: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при удалении пользователя: ${error.message}`);
    }
  }
}

// Использование
const userRepository = new UserRepository();
const userService = new UserService(userRepository);
const userController = new UserController(userService);

userController.createUser({ name: 'Иван', email: 'ivan@example.com' });
userController.listUsers();
userController.getUser(1);
```

#### Пример на TypeScript
```typescript
// Интерфейс пользователя
interface User {
  id: number;
  name: string;
  email: string;
}

// Уровень доступа к данным
class UserRepository {
  private users: User[] = [
    { id: 1, name: 'Алексей', email: 'alex@example.com' },
    { id: 2, name: 'Мария', email: 'maria@example.com' }
  ];
  
  public findAll(): User[] {
    return this.users;
  }
  
  public findById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
  
  public save(user: Partial<User>): User {
    if (!user.id) {
      user.id = this.users.length + 1;
    }
    const fullUser: User = user as User;
    this.users.push(fullUser);
    return fullUser;
  }
  
  public update(id: number, userData: Partial<User>): User | null {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      this.users[index] = { ...this.users[index], ...userData } as User;
      return this.users[index];
    }
    return null;
  }
  
  public delete(id: number): User | null {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  }
}

// Уровень бизнес-логики
class UserService {
  private userRepository: UserRepository;
  
  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
  }
  
  public getAllUsers(): User[] {
    return this.userRepository.findAll();
  }
  
  public getUserById(id: number): User | undefined {
    if (id <= 0) {
      throw new Error('ID должен быть положительным числом');
    }
    return this.userRepository.findById(id);
  }
  
  public createUser(userData: Partial<User>): User {
    // Бизнес-проверки
    if (!userData.name || !userData.email) {
      throw new Error('Имя и email обязательны');
    }
    
    if (userData.email && (userData.email as string).indexOf('@') === -1) {
      throw new Error('Некорректный email');
    }
    
    return this.userRepository.save(userData);
  }
  
  public updateUser(id: number, userData: Partial<User>): User | null {
    const existingUser = this.userRepository.findById(id);
    if (!existingUser) {
      throw new Error('Пользователь не найден');
    }
    
    // Бизнес-проверки
    if (userData.email && (userData.email as string).indexOf('@') === -1) {
      throw new Error('Некорректный email');
    }
    
    return this.userRepository.update(id, userData);
  }
  
  public deleteUser(id: number): User | null {
    const user = this.userRepository.findById(id);
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    // Бизнес-логика удаления
    return this.userRepository.delete(id);
  }
}

// Уровень представления
class UserController {
  private userService: UserService;
  
  constructor(userService: UserService) {
    this.userService = userService;
  }
  
  public listUsers(): void {
    try {
      const users = this.userService.getAllUsers();
      console.log('Список пользователей:');
      users.forEach(user => {
        console.log(`ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      });
    } catch (error) {
      console.error(`Ошибка при получении пользователей: ${(error as Error).message}`);
    }
  }
  
  public getUser(id: number): void {
    try {
      const user = this.userService.getUserById(id);
      if (user) {
        console.log(`Пользователь: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при получении пользователя: ${(error as Error).message}`);
    }
  }
  
  public createUser(userData: Partial<User>): void {
    try {
      const user = this.userService.createUser(userData);
      console.log(`Пользователь создан: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
    } catch (error) {
      console.error(`Ошибка при создании пользователя: ${(error as Error).message}`);
    }
  }
  
  public updateUser(id: number, userData: Partial<User>): void {
    try {
      const user = this.userService.updateUser(id, userData);
      if (user) {
        console.log(`Пользователь обновлен: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при обновлении пользователя: ${(error as Error).message}`);
    }
  }
  
  public deleteUser(id: number): void {
    try {
      const user = this.userService.deleteUser(id);
      if (user) {
        console.log(`Пользователь удален: ID: ${user.id}, Имя: ${user.name}, Email: ${user.email}`);
      } else {
        console.log(`Пользователь с ID ${id} не найден`);
      }
    } catch (error) {
      console.error(`Ошибка при удалении пользователя: ${(error as Error).message}`);
    }
  }
}

// Использование
const userRepository = new UserRepository();
const userService = new UserService(userRepository);
const userController = new UserController(userService);

userController.createUser({ name: 'Иван', email: 'ivan@example.com' });
userController.listUsers();
userController.getUser(1);
```

#### Когда использовать
- Когда приложение имеет четко определенные области ответственности
- Когда нужно обеспечить тестируемость и поддерживаемость
- Когда требуется масштабируемость приложения

#### Преимущества
- Четкое разделение ответственности
- Легкость тестирования
- Повторное использование компонентов
- Простота сопровождения

#### Недостатки
- Может быть избыточным для простых приложений
- Возможное увеличение сложности архитектуры
- Потенциальные проблемы с производительностью из-за дополнительных слоев

### 5. Repository Pattern (Паттерн репозитория)

Паттерн, обеспечивающий абстракцию слоя доступа к данным и позволяющий работать с данными как с коллекцией объектов.

#### Проблема
Когда код напрямую взаимодействует с базой данных, он становится тесно связанным с конкретной реализацией хранения данных.

#### Решение
Создать репозиторий, который предоставляет абстракцию для доступа к данным.

#### Пример на JavaScript
```javascript
// Интерфейс репозитория
class RepositoryInterface {
  findAll() {
    throw new Error('FindAll method must be implemented');
  }
  
  findById(id) {
    throw new Error('FindById method must be implemented');
  }
  
  save(entity) {
    throw new Error('Save method must be implemented');
  }
  
  update(id, entity) {
    throw new Error('Update method must be implemented');
  }
  
  delete(id) {
    throw new Error('Delete method must be implemented');
  }
}

// Репозиторий пользователей
class UserRepository extends RepositoryInterface {
  constructor() {
    super();
    this.users = [
      { id: 1, name: 'Алексей', email: 'alex@example.com' },
      { id: 2, name: 'Мария', email: 'maria@example.com' }
    ];
    this.nextId = 3;
  }
  
  findAll() {
    return this.users;
  }
  
  findById(id) {
    return this.users.find(user => user.id === id);
  }
  
  save(user) {
    if (!user.id) {
      user.id = this.nextId++;
    }
    this.users.push(user);
    return user;
  }
  
  update(id, userData) {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      this.users[index] = { ...this.users[index], ...userData };
      return this.users[index];
    }
    return null;
  }
  
  delete(id) {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  }
  
  findByEmail(email) {
    return this.users.find(user => user.email === email);
  }
}

// Сервис пользователей
class UserService {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }
  
  registerUser(userData) {
    // Проверка на уникальность email
    const existingUser = this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }
    
    return this.userRepository.save(userData);
  }
  
  getUserProfile(userId) {
    const user = this.userRepository.findById(userId);
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    // Возвращаем только публичные данные
    return {
      id: user.id,
      name: user.name
    };
  }
}

// Использование
const userRepository = new UserRepository();
const userService = new UserService(userRepository);

try {
  const newUser = userService.registerUser({
    name: 'Иван',
    email: 'ivan@example.com'
  });
  console.log('Пользователь зарегистрирован:', newUser);
  
  const userProfile = userService.getUserProfile(1);
  console.log('Профиль пользователя:', userProfile);
} catch (error) {
  console.error('Ошибка:', error.message);
}
```

#### Пример на TypeScript
```typescript
// Интерфейс сущности
interface Entity {
  id?: number;
}

// Интерфейс репозитория
interface RepositoryInterface<T extends Entity> {
  findAll(): T[];
  findById(id: number): T | undefined;
  save(entity: Partial<T>): T;
  update(id: number, entity: Partial<T>): T | null;
  delete(id: number): T | null;
}

// Интерфейс пользователя
interface User extends Entity {
  name: string;
  email: string;
}

// Репозиторий пользователей
class UserRepository implements RepositoryInterface<User> {
  private users: User[] = [
    { id: 1, name: 'Алексей', email: 'alex@example.com' },
    { id: 2, name: 'Мария', email: 'maria@example.com' }
  ];
  private nextId: number = 3;
  
  public findAll(): User[] {
    return this.users;
  }
  
  public findById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
  
  public save(user: Partial<User>): User {
    if (!user.id) {
      user.id = this.nextId++;
    }
    const fullUser: User = user as User;
    this.users.push(fullUser);
    return fullUser;
  }
  
  public update(id: number, userData: Partial<User>): User | null {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      this.users[index] = { ...this.users[index], ...userData } as User;
      return this.users[index];
    }
    return null;
  }
  
  public delete(id: number): User | null {
    const index = this.users.findIndex(user => user.id === id);
    if (index !== -1) {
      return this.users.splice(index, 1)[0];
    }
    return null;
  }
  
  public findByEmail(email: string): User | undefined {
    return this.users.find(user => user.email === email);
  }
}

// Сервис пользователей
class UserService {
  private userRepository: RepositoryInterface<User>;
  
  constructor(userRepository: RepositoryInterface<User>) {
    this.userRepository = userRepository;
  }
  
  public registerUser(userData: Partial<User>): User {
    // Проверка на уникальность email
    const existingUser = (this.userRepository as UserRepository).findByEmail(userData.email as string);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }
    
    return this.userRepository.save(userData);
  }
  
  public getUserProfile(userId: number): Partial<User> {
    const user = this.userRepository.findById(userId);
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    // Возвращаем только публичные данные
    return {
      id: user.id,
      name: user.name
    };
  }
}

// Использование
const userRepository = new UserRepository();
const userService = new UserService(userRepository);

try {
  const newUser = userService.registerUser({
    name: 'Иван',
    email: 'ivan@example.com'
  });
  console.log('Пользователь зарегистрирован:', newUser);
  
  const userProfile = userService.getUserProfile(1);
  console.log('Профиль пользователя:', userProfile);
} catch (error) {
  console.error('Ошибка:', (error as Error).message);
}
```

#### Когда использовать
- Когда нужно абстрагировать слой доступа к данным
- Когда требуется тестирование бизнес-логики без зависимости от базы данных
- Когда нужно поддерживать несколько источников данных

#### Преимущества
- Абстракция от конкретной реализации хранения данных
- Упрощение тестирования
- Централизация операций доступа к данным
- Легкость замены источника данных

#### Недостатки
- Может добавить дополнительный уровень сложности
- Потенциальное снижение производительности
- Может быть избыточным для простых приложений

### 6. Service Layer (Слой сервисов)

Паттерн, определяющий уровень приложения, который содержит бизнес-логику и управляет транзакциями.

#### Проблема
Когда бизнес-логика распределена по разным частям приложения, становится трудно управлять транзакциями и обеспечивать согласованность.

#### Решение
Создать слой сервисов, который инкапсулирует бизнес-логику и управляет транзакциями.

#### Пример на JavaScript
```javascript
// Репозиторий пользователей
class UserRepository {
  constructor() {
    this.users = [
      { id: 1, name: 'Алексей', email: 'alex@example.com', balance: 1000 },
      { id: 2, name: 'Мария', email: 'maria@example.com', balance: 500 }
    ];
  }
  
  findById(id) {
    return this.users.find(user => user.id === id);
  }
  
  updateBalance(id, newBalance) {
    const user = this.findById(id);
    if (user) {
      user.balance = newBalance;
      return user;
    }
    return null;
  }
}

// Репозиторий транзакций
class TransactionRepository {
  constructor() {
    this.transactions = [];
    this.nextId = 1;
  }
  
  create(transactionData) {
    const transaction = {
      id: this.nextId++,
      ...transactionData,
      timestamp: new Date()
    };
    this.transactions.push(transaction);
    return transaction;
  }
}

// Слой сервисов
class TransferService {
  constructor(userRepository, transactionRepository) {
    this.userRepository = userRepository;
    this.transactionRepository = transactionRepository;
  }
  
  async transferMoney(fromUserId, toUserId, amount) {
    // Начало транзакции (в реальном приложении это будет настоящая транзакция БД)
    try {
      const fromUser = this.userRepository.findById(fromUserId);
      const toUser = this.userRepository.findById(toUserId);
      
      if (!fromUser) {
        throw new Error(`Пользователь отправителя (ID: ${fromUserId}) не найден`);
      }
      
      if (!toUser) {
        throw new Error(`Пользователь получателя (ID: ${toUserId}) не найден`);
      }
      
      if (fromUser.balance < amount) {
        throw new Error(`Недостаточно средств. Баланс: ${fromUser.balance}, Запрошено: ${amount}`);
      }
      
      // Выполняем транзакцию
      fromUser.balance -= amount;
      toUser.balance += amount;
      
      // Обновляем балансы в репозитории
      this.userRepository.updateBalance(fromUserId, fromUser.balance);
      this.userRepository.updateBalance(toUserId, toUser.balance);
      
      // Создаем запись о транзакции
      const transaction = this.transactionRepository.create({
        fromUserId,
        toUserId,
        amount,
        status: 'completed'
      });
      
      console.log(`Перевод ${amount} от пользователя ${fromUserId} к пользователю ${toUserId} успешно выполнен`);
      return transaction;
    } catch (error) {
      // В реальном приложении здесь была бы откат транзакции
      console.error('Ошибка при выполнении перевода:', error.message);
      throw error;
    }
  }
  
  getTransferHistory(userId) {
    return this.transactionRepository.transactions.filter(
      t => t.fromUserId === userId || t.toUserId === userId
    );
  }
}

// Использование
const userRepository = new UserRepository();
const transactionRepository = new TransactionRepository();
const transferService = new TransferService(userRepository, transactionRepository);

try {
  console.log('Балансы до перевода:');
  console.log('Алексей:', userRepository.findById(1).balance); // 1000
  console.log('Мария:', userRepository.findById(2).balance); // 500
  
  transferService.transferMoney(1, 2, 200);
  
  console.log('Балансы после перевода:');
  console.log('Алексей:', userRepository.findById(1).balance); // 800
  console.log('Мария:', userRepository.findById(2).balance); // 700
  
  console.log('История переводов для Алексея:');
  console.log(transferService.getTransferHistory(1));
} catch (error) {
  console.error('Ошибка:', error.message);
}
```

#### Пример на TypeScript
```typescript
// Интерфейс пользователя
interface User {
  id: number;
  name: string;
  email: string;
  balance: number;
}

// Интерфейс транзакции
interface Transaction {
  id: number;
  fromUserId: number;
  toUserId: number;
  amount: number;
  status: string;
  timestamp: Date;
}

// Репозиторий пользователей
class UserRepository {
  private users: User[] = [
    { id: 1, name: 'Алексей', email: 'alex@example.com', balance: 1000 },
    { id: 2, name: 'Мария', email: 'maria@example.com', balance: 500 }
  ];
  
  public findById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
  
  public updateBalance(id: number, newBalance: number): User | null {
    const user = this.findById(id);
    if (user) {
      user.balance = newBalance;
      return user;
    }
    return null;
  }
}

// Репозиторий транзакций
class TransactionRepository {
  private transactions: Transaction[] = [];
  private nextId: number = 1;
  
  public create(transactionData: Omit<Transaction, 'id' | 'timestamp'>): Transaction {
    const transaction: Transaction = {
      id: this.nextId++,
      ...transactionData,
      timestamp: new Date()
    };
    this.transactions.push(transaction);
    return transaction;
  }
  
  public getTransactions(): Transaction[] {
    return this.transactions;
  }
}

// Слой сервисов
class TransferService {
  private userRepository: UserRepository;
  private transactionRepository: TransactionRepository;
  
  constructor(userRepository: UserRepository, transactionRepository: TransactionRepository) {
    this.userRepository = userRepository;
    this.transactionRepository = transactionRepository;
  }
  
  public async transferMoney(fromUserId: number, toUserId: number, amount: number): Promise<Transaction> {
    // Начало транзакции (в реальном приложении это будет настоящая транзакция БД)
    try {
      const fromUser = this.userRepository.findById(fromUserId);
      const toUser = this.userRepository.findById(toUserId);
      
      if (!fromUser) {
        throw new Error(`Пользователь отправителя (ID: ${fromUserId}) не найден`);
      }
      
      if (!toUser) {
        throw new Error(`Пользователь получателя (ID: ${toUserId}) не найден`);
      }
      
      if (fromUser.balance < amount) {
        throw new Error(`Недостаточно средств. Баланс: ${fromUser.balance}, Запрошено: ${amount}`);
      }
      
      // Выполняем транзакцию
      fromUser.balance -= amount;
      toUser.balance += amount;
      
      // Обновляем балансы в репозитории
      this.userRepository.updateBalance(fromUserId, fromUser.balance);
      this.userRepository.updateBalance(toUserId, toUser.balance);
      
      // Создаем запись о транзакции
      const transaction = this.transactionRepository.create({
        fromUserId,
        toUserId,
        amount,
        status: 'completed'
      });
      
      console.log(`Перевод ${amount} от пользователя ${fromUserId} к пользователю ${toUserId} успешно выполнен`);
      return transaction;
    } catch (error) {
      // В реальном приложении здесь была бы откат транзакции
      console.error('Ошибка при выполнении перевода:', (error as Error).message);
      throw error;
    }
  }
  
  public getTransferHistory(userId: number): Transaction[] {
    return this.transactionRepository.getTransactions().filter(
      t => t.fromUserId === userId || t.toUserId === userId
    );
  }
}

// Использование
const userRepository = new UserRepository();
const transactionRepository = new TransactionRepository();
const transferService = new TransferService(userRepository, transactionRepository);

try {
  console.log('Балансы до перевода:');
  console.log('Алексей:', userRepository.findById(1)?.balance); // 1000
  console.log('Мария:', userRepository.findById(2)?.balance); // 500
  
  transferService.transferMoney(1, 2, 200);
  
  console.log('Балансы после перевода:');
  console.log('Алексей:', userRepository.findById(1)?.balance); // 800
  console.log('Мария:', userRepository.findById(2)?.balance); // 700
  
  console.log('История переводов для Алексея:');
  console.log(transferService.getTransferHistory(1));
} catch (error) {
  console.error('Ошибка:', (error as Error).message);
}
```

#### Когда использовать
- Когда приложение имеет сложную бизнес-логику
- Когда нужно управлять транзакциями
- Когда требуется централизация бизнес-операций

#### Преимущества
- Централизация бизнес-логики
- Упрощение управления транзакциями
- Повторное использование бизнес-логики
- Легкость тестирования

#### Недостатки
- Может создать толстые классы сервисов
- Потенциальное нарушение принципа единственной ответственности
- Может усложнить архитектуру приложения

## Практические рекомендации для фронтенд-разработчиков

### 1. MVC в фронтенде
В фронтенд-разработке MVC реализуется по-разному в зависимости от фреймворка:
- В классических веб-приложениях (например, с использованием jQuery) - JavaScript как контроллер, HTML как представление, данные как модель
- В современных фреймворках MVC часто трансформируется в другие паттерны (например, Flux в React)

### 2. MVP в фронтенде
MVP особенно полезен в фронтенде для:
- Улучшения тестируемости компонентов
- Создания слабосвязанных компонентов
- Разделения логики представления и бизнес-логики

### 3. MVVM в фронтенде
MVVM широко используется в фронтенде:
- Angular использует концепцию компонентов с двусторонней привязкой
- Vue.js предоставляет реактивность, близкую к MVVM
- Knockout.js - классический пример MVVM в JavaScript

> [!tip] Совет
> В современных фреймворках часто используются гибридные паттерны, сочетающие элементы MVC, MVP и MVVM. Например, React с Redux реализует элементы Flux-архитектуры, которая похожа на MVC.

### 4. Layered Architecture в фронтенде
В фронтенде многоуровневая архитектура может быть реализована как:
- Уровень представления (UI-компоненты)
- Уровень бизнес-логики (хуки, сервисы, утилиты)
- Уровень доступа к данным (API-клиенты, репозитории)

### 5. Repository Pattern в фронтенде
Repository Pattern в фронтенде используется для:
- Абстракции работы с API
- Централизации логики доступа к данным
- Упрощения тестирования компонентов

### 6. Service Layer в фронтенде
Service Layer в фронтенде может быть реализован как:
- Сервисы для работы с API
- Сервисы бизнес-логики
- Утилиты для обработки данных

## Заключение

Архитектурные паттерны играют ключевую роль в создании масштабируемых и поддерживаемых приложений. Они определяют общую структуру приложения и помогают разработчикам принимать обоснованные архитектурные решения.

Хотя в современных фреймворках и библиотеках (React, Vue, Angular) многие из этих паттернов уже частично реализованы или трансформированы, понимание их работы позволяет лучше использовать возможности этих инструментов и создавать более надежные архитектуры.

Выбор архитектурного паттерна должен основываться на конкретных требованиях проекта, его сложности и команде разработчиков. Важно помнить, что архитектура должна служить целям приложения, а не наоборот.

[[Порождающие-паттерны]] | [[Структурные-паттерны]] | [[Поведенческие-паттерны]] | [[Паттерны-для-фронтенда]]