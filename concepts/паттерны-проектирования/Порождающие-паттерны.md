---
aliases: ["Creational Patterns", "Порождающие паттерны"]
tags: ["#programming", "#design-patterns", "#frontend", "#javascript"]
---

# Порождающие паттерны (Creational Patterns)

Порождающие паттерны проектирования сосредоточены на процессе создания объектов. Они обеспечивают гибкость при решении задач создания экземпляров объектов, позволяя системе быть независимой от способа создания, композиции и представления объектов.

## Обзор

Порождающие паттерны решают проблемы инстанцирования объектов, скрывая логику создания. Это позволяет программе быть более гибкой и масштабируемой, так как код не жестко привязан к конкретным классам объектов.

## Паттерны

### 1. Singleton (Одиночка)

Паттерн, гарантирующий, что будет создан только один экземпляр класса, и предоставляющий глобальную точку доступа к этому экземпляру.

#### Проблема
Иногда необходимо обеспечить, чтобы класс имел только один экземпляр. Это может быть нужно для объектов, таких как менеджеры конфигурации, логгеры, кэши и т.д.

#### Решение
Создать класс, который контролирует создание своего единственного экземпляра и предоставляет метод для доступа к нему.

#### Пример на JavaScript
```javascript
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }
    
    // Инициализация объекта
    this.config = {};
    
    Singleton.instance = this;
    return this;
  }
  
  setConfig(key, value) {
    this.config[key] = value;
  }
  
  getConfig(key) {
    return this.config[key];
  }
}

// Использование
const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true
```

#### Пример на TypeScript
```typescript
class Singleton {
  private static instance: Singleton;
  private config: Map<string, any> = new Map();

  private constructor() {}

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }

  public setConfig(key: string, value: any): void {
    this.config.set(key, value);
  }

  public getConfig(key: string): any {
    return this.config.get(key);
  }
}

// Использование
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true
```

#### Когда использовать
- Когда класс должен иметь только один экземпляр
- Когда необходимо контролировать создание экземпляров класса
- Когда необходима глобальная точка доступа к экземпляру

#### Преимущества
- Гарантирует наличие единственного экземпляра
- Предоставляет глобальную точку доступа
- Отложенная инициализация

#### Недостатки
- Нарушает принцип единственной ответственности
- Создает глобальное состояние
- Может усложнить тестирование

### 2. Factory Method (Фабричный метод)

Паттерн, предоставляющий интерфейс для создания экземпляров объектов, но позволяющий подклассам изменять тип создаваемых объектов.

#### Проблема
Класс не может предугадать, какие объекты ему нужно будет создать.

#### Решение
Определить интерфейс создания объекта, но предоставить подклассам возможность решать, какой класс инстанцировать.

#### Пример на JavaScript
```javascript
// Базовый класс для продуктов
class Product {
  constructor(name) {
    this.name = name;
  }
  
  describe() {
    return `Product: ${this.name}`;
  }
}

// Конкретные продукты
class ConcreteProductA extends Product {
  constructor() {
    super('Product A');
  }
  
  describe() {
    return `ConcreteProductA: ${this.name}`;
  }
}

class ConcreteProductB extends Product {
  constructor() {
    super('Product B');
  }
  
  describe() {
    return `ConcreteProductB: ${this.name}`;
  }
}

// Класс-создатель
class Creator {
  factoryMethod() {
    throw new Error('Factory method must be implemented');
  }
  
  createProduct() {
    const product = this.factoryMethod();
    return product;
  }
}

// Конкретные создатели
class ConcreteCreatorA extends Creator {
  factoryMethod() {
    return new ConcreteProductA();
  }
}

class ConcreteCreatorB extends Creator {
  factoryMethod() {
    return new ConcreteProductB();
  }
}

// Использование
const creatorA = new ConcreteCreatorA();
const productA = creatorA.createProduct();
console.log(productA.describe()); // ConcreteProductA: Product A

const creatorB = new ConcreteCreatorB();
const productB = creatorB.createProduct();
console.log(productB.describe()); // ConcreteProductB: Product B
```

#### Пример на TypeScript
```typescript
// Базовый интерфейс для продуктов
interface Product {
  describe(): string;
}

// Конкретные продукты
class ConcreteProductA implements Product {
  private name: string = 'Product A';
  
  describe(): string {
    return `ConcreteProductA: ${this.name}`;
  }
}

class ConcreteProductB implements Product {
  private name: string = 'Product B';
  
  describe(): string {
    return `ConcreteProductB: ${this.name}`;
  }
}

// Абстрактный создатель
abstract class Creator {
  public abstract factoryMethod(): Product;
  
  public createProduct(): Product {
    const product = this.factoryMethod();
    return product;
  }
}

// Конкретные создатели
class ConcreteCreatorA extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProductA();
  }
}

class ConcreteCreatorB extends Creator {
  public factoryMethod(): Product {
    return new ConcreteProductB();
  }
}

// Использование
const creatorA = new ConcreteCreatorA();
const productA = creatorA.createProduct();
console.log(productA.describe()); // ConcreteProductA: Product A

const creatorB = new ConcreteCreatorB();
const productB = creatorB.createProduct();
console.log(productB.describe()); // ConcreteProductB: Product B
```

#### Когда использовать
- Когда класс делегирует свои обязанности подклассам
- Когда родительский класс хочет, чтобы его подклассы определяли тип создаваемого объекта
- Когда класс не знает, какие объекты ему нужно создать

#### Преимущества
- Изолирует конкретные классы от клиентского кода
- Позволяет легко добавлять новые типы продуктов
- Позволяет настраивать создаваемые объекты

#### Недостатки
- Может привести к увеличению количества классов
- Усложняет код из-за большого количества классов

### 3. Abstract Factory (Абстрактная фабрика)

Паттерн, позволяющий создавать семейства связанных объектов без указания их конкретных классов.

#### Проблема
Необходимо создавать семейства связанных объектов, но не хотелось бы зависеть от конкретных классов создаваемых объектов.

#### Решение
Определить интерфейс для создания семейств связанных или зависимых объектов без указания их конкретных классов.

#### Пример на JavaScript
```javascript
// Абстрактные продукты
class Button {
  render() {
    throw new Error('Render method must be implemented');
  }
}

class Checkbox {
  render() {
    throw new Error('Render method must be implemented');
  }
}

// Конкретные продукты для Windows
class WindowsButton extends Button {
  render() {
    return 'Render a Windows button';
  }
}

class WindowsCheckbox extends Checkbox {
  render() {
    return 'Render a Windows checkbox';
  }
}

// Конкретные продукты для macOS
class MacButton extends Button {
  render() {
    return 'Render a Mac button';
  }
}

class MacCheckbox extends Checkbox {
  render() {
    return 'Render a Mac checkbox';
  }
}

// Абстрактная фабрика
class GUIFactory {
  createButton() {
    throw new Error('Create button method must be implemented');
  }
  
  createCheckbox() {
    throw new Error('Create checkbox method must be implemented');
  }
}

// Конкретные фабрики
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }
  
  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacFactory extends GUIFactory {
  createButton() {
    return new MacButton();
  }
  
  createCheckbox() {
    return new MacCheckbox();
  }
}

// Клиентский код
function clientCode(factory) {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  
  console.log(button.render());
  console.log(checkbox.render());
}

// Использование
const windowsFactory = new WindowsFactory();
clientCode(windowsFactory);
// Вывод:
// Render a Windows button
// Render a Windows checkbox

const macFactory = new MacFactory();
clientCode(macFactory);
// Вывод:
// Render a Mac button
// Render a Mac checkbox
```

#### Пример на TypeScript
```typescript
// Абстрактные продукты
interface Button {
  render(): string;
}

interface Checkbox {
  render(): string;
}

// Конкретные продукты для Windows
class WindowsButton implements Button {
  render(): string {
    return 'Render a Windows button';
  }
}

class WindowsCheckbox implements Checkbox {
  render(): string {
    return 'Render a Windows checkbox';
  }
}

// Конкретные продукты для macOS
class MacButton implements Button {
  render(): string {
    return 'Render a Mac button';
  }
}

class MacCheckbox implements Checkbox {
  render(): string {
    return 'Render a Mac checkbox';
  }
}

// Абстрактная фабрика
interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

// Конкретные фабрики
class WindowsFactory implements GUIFactory {
  createButton(): Button {
    return new WindowsButton();
  }
  
  createCheckbox(): Checkbox {
    return new WindowsCheckbox();
  }
}

class MacFactory implements GUIFactory {
  createButton(): Button {
    return new MacButton();
  }
  
  createCheckbox(): Checkbox {
    return new MacCheckbox();
  }
}

// Клиентский код
function clientCode(factory: GUIFactory): void {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  
  console.log(button.render());
  console.log(checkbox.render());
}

// Использование
const windowsFactory = new WindowsFactory();
clientCode(windowsFactory);
// Вывод:
// Render a Windows button
// Render a Windows checkbox

const macFactory = new MacFactory();
clientCode(macFactory);
// Вывод:
// Render a Mac button
// Render a Mac checkbox
```

#### Когда использовать
- Когда система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты
- Когда создаваемые объекты должны использоваться совместно
- Когда нужно создавать семейства связанных объектов

#### Преимущества
- Изолирует конкретные классы
- Позволяет легко переключаться между семействами продуктов
- Обеспечивает согласованность между продуктами

#### Недостатки
- Усложняет систему из-за большого количества интерфейсов
- Трудно добавить поддержку нового типа продукта

### 4. Builder (Строитель)

Паттерн, позволяющий создавать сложные объекты пошагово. Паттерн позволяет использовать один и тот же процесс построения для создания различных представлений.

#### Проблема
Конструктор класса имеет слишком много параметров, и его трудно использовать.

#### Решение
Разделить процесс создания объекта на несколько шагов, каждый из которых может быть выполнен независимо.

#### Пример на JavaScript
```javascript
class Car {
  constructor() {
    this.type = '';
    this.engine = '';
    this.wheels = 4;
    this.color = 'white';
    this.doors = 4;
  }
  
  toString() {
    return `Car: ${this.type}, Engine: ${this.engine}, Wheels: ${this.wheels}, Color: ${this.color}, Doors: ${this.doors}`;
  }
}

class CarBuilder {
  constructor() {
    this.car = new Car();
  }
  
  setType(type) {
    this.car.type = type;
    return this;
  }
  
  setEngine(engine) {
    this.car.engine = engine;
    return this;
  }
  
  setWheels(wheels) {
    this.car.wheels = wheels;
    return this;
  }
  
  setColor(color) {
    this.car.color = color;
    return this;
  }
  
  setDoors(doors) {
    this.car.doors = doors;
    return this;
  }
  
  build() {
    return this.car;
  }
}

// Использование
const car = new CarBuilder()
  .setType('Sedan')
  .setEngine('V6')
  .setColor('Red')
  .setDoors(4)
  .build();

console.log(car.toString());
// Вывод: Car: Sedan, Engine: V6, Wheels: 4, Color: Red, Doors: 4
```

#### Пример на TypeScript
```typescript
class Car {
  public type: string = '';
  public engine: string = '';
  public wheels: number = 4;
  public color: string = 'white';
  public doors: number = 4;
  
  public toString(): string {
    return `Car: ${this.type}, Engine: ${this.engine}, Wheels: ${this.wheels}, Color: ${this.color}, Doors: ${this.doors}`;
  }
}

class CarBuilder {
  private car: Car;
  
  constructor() {
    this.car = new Car();
  }
  
  public setType(type: string): CarBuilder {
    this.car.type = type;
    return this;
  }
  
  public setEngine(engine: string): CarBuilder {
    this.car.engine = engine;
    return this;
  }
  
  public setWheels(wheels: number): CarBuilder {
    this.car.wheels = wheels;
    return this;
  }
  
  public setColor(color: string): CarBuilder {
    this.car.color = color;
    return this;
  }
  
  public setDoors(doors: number): CarBuilder {
    this.car.doors = doors;
    return this;
  }
  
  public build(): Car {
    return this.car;
  }
}

// Использование
const car = new CarBuilder()
  .setType('Sedan')
  .setEngine('V6')
  .setColor('Red')
  .setDoors(4)
  .build();

console.log(car.toString());
// Вывод: Car: Sedan, Engine: V6, Wheels: 4, Color: Red, Doors: 4
```

#### Когда использовать
- Когда объект имеет много параметров для конфигурации
- Когда необходимо создавать различные представления объекта
- Когда процесс создания должен быть изолирован от кода, который использует созданный объект

#### Преимущества
- Позволяет изменять внутреннее представление продукта
- Позволяет контролировать процесс построения
- Позволяет создавать объекты пошагово

#### Недостатки
- Увеличивает количество классов
- Может усложнить код для простых объектов

### 5. Prototype (Прототип)

Паттерн, позволяющий копировать объекты, не создавая зависимости от их классов.

#### Проблема
Необходимо создавать новые объекты, основанные на существующих, без создания зависимостей от их классов.

#### Решение
Определить интерфейс клонирования объектов, который позволяет создавать копии существующих объектов.

#### Пример на JavaScript
```javascript
class Prototype {
  constructor(name) {
    this.name = name;
    this.properties = {};
  }
  
  clone() {
    const cloned = new this.constructor(this.name);
    // Глубокое копирование свойств
    cloned.properties = JSON.parse(JSON.stringify(this.properties));
    return cloned;
  }
  
  setProperty(key, value) {
    this.properties[key] = value;
  }
  
  getProperty(key) {
    return this.properties[key];
  }
}

// Использование
const original = new Prototype('Original');
original.setProperty('color', 'red');
original.setProperty('size', 'large');

const clone = original.clone();
clone.setProperty('color', 'blue');

console.log(original.getProperty('color')); // 'red'
console.log(clone.getProperty('color')); // 'blue'
```

#### Пример на TypeScript
```typescript
abstract class Prototype {
  public name: string;
  public properties: Map<string, any> = new Map();
  
  constructor(name: string) {
    this.name = name;
  }
  
  public abstract clone(): Prototype;
  
  public setProperty(key: string, value: any): void {
    this.properties.set(key, value);
  }
  
  public getProperty(key: string): any {
    return this.properties.get(key);
  }
}

class ConcretePrototype extends Prototype {
  constructor(name: string) {
    super(name);
  }
  
  public clone(): Prototype {
    const cloned = new ConcretePrototype(this.name);
    // Глубокое копирование свойств
    cloned.properties = new Map(this.properties);
    return cloned;
  }
}

// Использование
const original = new ConcretePrototype('Original');
original.setProperty('color', 'red');
original.setProperty('size', 'large');

const clone = original.clone();
clone.setProperty('color', 'blue');

console.log(original.getProperty('color')); // 'red'
console.log(clone.getProperty('color')); // 'blue'
```

#### Когда использовать
- Когда создание новых объектов дороже, чем клонирование существующих
- Когда необходимо создавать новые объекты с определенными состояниями
- Когда классы создаваемых объектов определяются во время выполнения

#### Преимущества
- Позволяет избежать создания зависимостей от конкретных классов
- Упрощает создание сложных объектов
- Позволяет динамически изменять структуру объектов

#### Недостатки
- Сложно клонировать объекты с циклическими ссылками
- Может быть неэффективным для простых объектов

## Практические рекомендации для фронтенд-разработчиков

### 1. Singleton в фронтенде
В фронтенд-разработке Singleton часто используется для:
- Управления состоянием приложения (например, Redux store)
- Логгирования
- Управления конфигурацией
- Кэширования данных

> [!warning] Важно
> Используйте Singleton с осторожностью в фронтенд-приложениях, так как это создает глобальное состояние, которое может усложнить тестирование и привести к проблемам с производительностью.

### 2. Factory Method в фронтенде
Factory Method полезен для:
- Создания компонентов в зависимости от условий
- Создания экземпляров API-клиентов
- Создания различных видов обработчиков событий

### 3. Abstract Factory в фронтенде
Abstract Factory может быть использован для:
- Создания тем оформления (светлая/темная тема)
- Создания компонентов для разных платформ (веб/мобильное приложение)
- Создания UI-компонентов по дизайн-системе

### 4. Builder в фронтенде
Builder особенно полезен для:
- Создания сложных объектов конфигурации
- Построения сложных форм
- Создания объектов запросов HTTP

### 5. Prototype в фронтенде
Prototype может быть полезен для:
- Клонирования сложных объектов данных
- Создания новых экземпляров объектов с измененными свойствами
- Оптимизации производительности при создании похожих объектов

## Заключение

Порождающие паттерны проектирования играют важную роль в создании гибких и масштабируемых приложений. В контексте фронтенд-разработки они помогают управлять созданием компонентов, состояний и других объектов, обеспечивая чистую архитектуру и упрощая сопровождение кода.

Хотя в современных фреймворках и библиотеках (React, Vue, Angular) многие из этих паттернов уже реализованы под капотом, понимание их работы позволяет лучше использовать возможности этих инструментов и принимать обоснованные архитектурные решения.

[[Структурные-паттерны]] | [[Поведенческие-паттерны]] | [[Архитектурные-паттерны]] | [[Паттерны-для-фронтенда]]