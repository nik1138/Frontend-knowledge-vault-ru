---
aliases: ["Связность и зацепление", "Когезия и связность", "Модульность"]
tags: 
  - #programming #software-architecture #design-principles
  - #best-practices #modularity
---

# Связность и зацепление (Cohesion и Coupling)

## Определение связности и зацепления

**Связность (Cohesion)** - это мера степени, в которой элементы внутри модуля (класса, функции, компонента) связаны между собой и работают вместе для выполнения одной четко определенной цели. Высокая связность означает, что все элементы модуля тесно связаны и выполняют одну задачу.

**Зацепление (Coupling)** - это мера зависимости между различными модулями системы. Низкое зацепление означает, что модули слабо связаны друг с другом и могут изменяться независимо.

> [!info] Важно
> Хороший дизайн программного обеспечения стремится к высокой связности и низкому зацеплению.

## Типы связности (от высокой к низкой)

### 1. Функциональная связность (Functional Cohesion)
Максимальная степень связности. Все элементы модуля работают вместе для выполнения одной функции.

```javascript
// Пример: модуль для работы с файлами
class FileProcessor {
  readFile(path) { /* ... */ }
  writeFile(path, content) { /* ... */ }
  deleteFile(path) { /* ... */ }
}
```

### 2. Последовательная связность (Sequential Cohesion)
Выход одной функции является входом для другой функции.

```javascript
// Пример: обработка данных
class DataProcessor {
  validateData(data) { /* ... */ }
  transformData(validatedData) { /* ... */ }
  saveData(transformedData) { /* ... */ }
}
```

### 3. Коммуникативная связность (Communicational Cohesion)
Функции используют одни и те же данные или входят в состав одного процесса.

```javascript
// Пример: работа с пользовательским профилем
class UserProfile {
  updateEmail(userId, email) { /* ... */ }
  updatePhone(userId, phone) { /* ... */ }
  // Обе функции работают с одним и тем же пользовательским профилем
}
```

### 4. Процедурная связность (Procedural Cohesion)
Функции объединены в модуль, потому что они выполняются в определенном порядке.

```javascript
// Пример: шаги инициализации
class SystemInitializer {
  initializeDatabase() { /* ... */ }
  loadConfiguration() { /* ... */ }
  startServices() { /* ... */ }
  // Выполняются в определенном порядке при запуске системы
}
```

### 5. Временная связность (Temporal Cohesion)
Функции объединены, потому что они выполняются в одно и то же время.

```javascript
// Пример: инициализация системы
class Startup {
  initializeLogging() { /* ... */ }
  initializeCache() { /* ... */ }
  initializeMonitoring() { /* ... */ }
  // Выполняются во время запуска приложения
}
```

### 6. Логическая связность (Logical Cohesion)
Функции объединены по логическому признаку, но не имеют тесной связи.

```javascript
// ПЛОХО: низкая связность
class InputHandler {
  handleMouseInput() { /* ... */ }
  handleKeyboardInput() { /* ... */ }
  handleTouchInput() { /* ... */ }
  // Разные типы ввода, не связанные между собой
}
```

### 7. Совпадающая связность (Coincidental Cohesion)
Минимальная степень связности. Функции объединены случайно.

```javascript
// ПЛОХО: совпадающая связность
class Utility {
  calculateTax() { /* ... */ }
  sendEmail() { /* ... */ }
  formatCurrency() { /* ... */ }
  // Нет логической связи между этими функциями
}
```

## Типы зацепления (от низкого к высокому)

### 1. Независимое зацепление (Non-structural Coupling)
Модули не зависят друг от друга.

```javascript
// Модули, не взаимодействующие друг с другом
class Logger { /* ... */ }
class Calculator { /* ... */ }
```

### 2. Данныйное зацепление (Data Coupling)
Модули обмениваются простыми параметрами.

```javascript
// Хорошо: передача простых данных
function calculateTotal(items, taxRate) {
  // ...
}
```

### 3. Заголовочное зацепление (Stamp Coupling)
Модули обмениваются структурами данных, но используют только часть полей.

```javascript
// Передача объекта с большим количеством полей
function processUser(userData) {
  // использует только имя и email
  return `${userData.firstName} ${userData.email}`;
}
```

### 4. Общее зацепление (Common Coupling)
Несколько модулей используют общую глобальную переменную.

```javascript
// ПЛОХО: общий доступ к глобальной переменной
let globalConfig = { /* ... */ };

function moduleA() {
  // изменяет globalConfig
}

function moduleB() {
  // зависит от globalConfig
}
```

### 5. Внешнее зацепление (External Coupling)
Модули зависят от внешней среды или формата данных.

```javascript
// Зависимость от внешнего формата
function parseXML(xmlString) {
  // жестко привязан к структуре XML
}
```

### 6. Контрольное зацепление (Control Coupling)
Один модуль передает другой информацию о том, как должен выполняться процесс.

```javascript
// ПЛОХО: передача флага управления
function processData(data, operationType) {
  if (operationType === 'validate') {
    // ...
  } else if (operationType === 'transform') {
    // ...
  }
}
```

### 7. Содержательное зацепление (Content Coupling)
Наихудший тип - один модуль напрямую изменяет внутренние данные другого.

```javascript
// ПЛОХО: прямой доступ к внутренним данным
function modifyInternalState() {
  someModule.internalVariable = 'new value';
}
```

## Измерение связности и зацепления

### Измерение связности:
- **LCOM (Lack of Cohesion of Methods)**: чем ближе к 0, тем выше связность
- **TCC (Tight Class Cohesion)**: чем ближе к 1, тем выше связность
- **Ручная оценка**: анализ целей модуля и взаимосвязей его элементов

### Измерение зацепления:
- **ATFD (Access to Foreign Data)**: количество обращений к данным других классов
- **NOC (Number of Children)**: количество дочерних классов
- **CBO (Coupling Between Objects)**: количество зависимостей между классами

## Преимущества высокой связности и низкого зацепления

- **Легкость сопровождения**: изменения в одном модуле не влияют на другие
- **Повторное использование**: модули с высокой связностью легче использовать повторно
- **Тестируемость**: модули легче тестировать изолированно
- **Понятность**: код легче понимать и анализировать
- **Гибкость**: легче вносить изменения и расширять функциональность

## Компромиссы и соображения

- **Баланс**: слишком высокая связность может привести к чрезмерной фрагментации
- **Производительность**: низкое зацепление может увеличить накладные расходы на вызовы
- **Сложность архитектуры**: соблюдение принципов может усложнить начальную архитектуру
- **Командная разработка**: разные разработчики могут по-разному интерпретировать "связность"

## Практические примеры: хорошая vs плохая связность/зацепление

### Плохой пример:
```javascript
// ПЛОХО: низкая связность и высокое зацепление
class UserManager {
  sendEmail(to, subject, body) { /* ... */ }
  calculateTax(income) { /* ... */ }
  validateUser(userData) { /* ... */ }
  connectToDatabase() { /* ... */ }
  processPayment(amount) { /* ... */ }
}
```

### Хороший пример:
```javascript
// ХОРОШО: высокая связность и низкое зацепление
class UserValidator {
  validate(userData) { /* ... */ }
  validateEmail(email) { /* ... */ }
}

class EmailService {
  send(to, subject, body) { /* ... */ }
  format(message) { /* ... */ }
}

class User {
  constructor(data) {
    this.validator = new UserValidator();
    this.emailService = new EmailService();
  }
  
  async register(userData) {
    if (this.validator.validate(userData)) {
      // регистрация пользователя
    }
  }
}
```

## Рефакторинг для улучшения связности и зацепления

### Признаки необходимости рефакторинга:
- Класс/функция делает слишком много разных вещей
- Изменение в одном месте требует изменений в других местах
- Трудности с тестированием из-за зависимостей
- Классы/функции слишком велики

### Техники рефакторинга:
- **Разделение ответственности**: разбиение модуля на более мелкие с одной ответственностью
- **Инверсия зависимостей**: использование абстракций вместо конкретных реализаций
- **Введение фасадов**: уменьшение зацепления через интерфейсы
- **Удаление дублирования**: объединение схожих функций

## Связи с другими концепциями

- [[single-responsibility-principle]] - каждая сущность должна иметь одну причину для изменения
- [[dependency-inversion-principle]] - зависимости на абстракциях, а не на деталях
- [[architecture/component-architecture/component-architecture]] - организация компонентов
- [[architecture/design-patterns/dependency-injection]] - снижение зацепления через внедрение зависимостей
- [[architecture/caching/caching]] - архитектурные паттерны для снижения зацепления

## Заключение

Связность и зацепление являются фундаментальными принципами проектирования программного обеспечения. Следование этим принципам позволяет создавать более гибкие, тестируемые и поддерживаемые системы. Важно стремиться к балансу между этими двумя характеристиками, учитывая специфику конкретного проекта.

## Теги

#programming #software-architecture #design-principles #best-practices #modularity #refactoring #object-oriented-design