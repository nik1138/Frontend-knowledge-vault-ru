---
aliases: [Профилирование, Оптимизация производительности, Performance Profiling]
tags: [performance, profiling, optimization, frontend, development]
---

# Профилирование производительности

## Обзор

Профилирование производительности - это процесс анализа работы веб-приложения с целью выявления узких мест, оптимизации скорости загрузки, улучшения пользовательского опыта и устранения проблем с производительностью.

## Основные аспекты производительности

### 1. Время загрузки страницы

- First Contentful Paint (FCP) - время до первого отображения контента
- Largest Contentful Paint (LCP) - время до отображения самого большого элемента
- Cumulative Layout Shift (CLS) - стабильность визуального отображения
- First Input Delay (FID) - время реакции на первый пользовательский ввод

### 2. Время выполнения JavaScript

- Время парсинга и компиляции JavaScript
- Время выполнения скриптов
- Частота и продолжительность garbage collection

### 3. Рендеринг и анимации

- Производительность анимаций
- Частота кадров (FPS)
- Проблемы с layout thrashing

## Инструменты профилирования

### 1. Chrome DevTools

#### Performance вкладка

- Запись и анализ сессий производительности
- Визуализация timeline событий
- Анализ CPU и памяти
- Профилирование стека вызовов

```javascript
// Пример использования Performance API
performance.mark('start-operation');
// код для анализа
performance.mark('end-operation');
performance.measure('operation', 'start-operation', 'end-operation');

const measures = performance.getEntriesByName('operation');
console.log('Время выполнения:', measures[0].duration);
```

#### Memory вкладка

- Анализ утечек памяти
- Проверка garbage collection
- Сравнение snapshot'ов памяти

#### Network вкладка

- Анализ времени загрузки ресурсов
- Проверка размера и количества запросов
- Анализ времени ожидания (TTFB)

### 2. Lighthouse

Инструмент для аудита производительности:

- Оценка производительности (0-100)
- Рекомендации по оптимизации
- Проверка доступности и SEO
- Аудит PWA

### 3. WebPageTest

- Анализ производительности с разных геолокаций
- Визуальный анализ прогресса загрузки
- Сравнение производительности разных версий

## Типичные проблемы производительности

### 1. Большой JavaScript-бандл

```javascript
// Проблема: загрузка всего приложения сразу
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import HeavyComponent1 from './HeavyComponent1';
import HeavyComponent2 from './HeavyComponent2';
// ... много других компонентов

// Решение: ленивая загрузка
const LazyComponent = React.lazy(() => import('./HeavyComponent1'));

function App() {
    return (
        <React.Suspense fallback={<div>Загрузка...</div>}>
            <LazyComponent />
        </React.Suspense>
    );
}
```

### 2. Частые перерисовки

```javascript
// Проблема: ненужные перерисовки
function ExpensiveComponent({ data }) {
    // Этот компонент перерисовывается при каждом изменении родителя
    return <div>{JSON.stringify(data)}</div>;
}

// Решение: memo или useCallback
const MemoizedComponent = React.memo(ExpensiveComponent);
```

### 3. Утечки памяти

```javascript
// Проблема: утечка памяти из-за неправильного управления событиями
class Component extends React.Component {
    componentDidMount() {
        window.addEventListener('resize', this.handleResize);
    }

    // Забыли удалить обработчик!
}

// Решение: правильная очистка
class Component extends React.Component {
    componentDidMount() {
        window.addEventListener('resize', this.handleResize);
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.handleResize);
    }
}
```

## Техники оптимизации

### 1. Оптимизация ресурсов

- Минификация и сжатие CSS, JavaScript и изображений
- Использование CDN
- Кэширование ресурсов
- Преждевременная загрузка (preload/prefetch)

```html
<!-- Пример использования preload -->
<link rel="preload" href="critical.css" as="style">
<link rel="prefetch" href="non-critical.js" as="script">
```

### 2. Оптимизация изображений

- Использование современных форматов (WebP, AVIF)
- Lazy loading изображений
- Адаптивные изображения для разных разрешений

```html
<picture>
    <source srcset="image.webp" type="image/webp">
    <source srcset="image.avif" type="image/avif">
    <img src="image.jpg" alt="Описание изображения">
</picture>
```

### 3. Оптимизация JavaScript

- Code splitting и lazy loading
- Tree shaking для удаления неиспользуемого кода
- Оптимизация алгоритмов и структур данных
- Использование веб-воркеров для тяжелых вычислений

```javascript
// Использование веб-воркера для тяжелых вычислений
const worker = new Worker('heavy-computation.js');

worker.postMessage({ data: largeDataSet });

worker.onmessage = function(e) {
    console.log('Результат:', e.data);
};
```

## Метрики производительности

### 1. Core Web Vitals

- Largest Contentful Paint (LCP) < 2.5s
- First Input Delay (FID) < 100ms
- Cumulative Layout Shift (CLS) < 0.1

### 2. Дополнительные метрики

- Time to Interactive (TTI)
- Total Blocking Time (TBT)
- First Meaningful Paint (FMP)

## Практические советы

### 1. Мониторинг производительности в продакшене

```javascript
// Логирование производительности в реальном времени
function measurePerformance() {
    const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
            if (entry.hadRecentInput) continue; // Игнорировать после пользовательского ввода
            
            // Отправка метрик на сервер аналитики
            analytics.track('CLS', { value: entry.value });
        }
    });
    
    observer.observe({ entryTypes: ['layout-shift'] });
}
```

### 2. Использование Performance API

```javascript
// Измерение производительности конкретных операций
function measureFunction(fn, name) {
    performance.mark(`${name}-start`);
    const result = fn();
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);
    
    const measure = performance.getEntriesByName(name)[0];
    console.log(`${name} took ${measure.duration} milliseconds`);
    
    return result;
}
```

### 3. Оптимизация рендеринга

```css
/* Использование will-change для оптимизации анимаций */
.animated-element {
    will-change: transform;
    /* или */
    transform: translateZ(0); /* активирует аппаратное ускорение */
}

/* Избегать свойств, вызывающих layout и paint */
.bad-performance {
    width: 100px; /* вызывает layout */
    height: 100px; /* вызывает layout */
    background-color: red; /* вызывает paint */
}

.good-performance {
    transform: translateX(100px); /* только composite */
    opacity: 0.5; /* только composite */
}
```

## Современные подходы к профилированию

### 1. Continuous Performance Monitoring

- Интеграция метрик производительности в CI/CD
- Мониторинг производительности в реальном времени
- Автоматические алерты при ухудшении производительности

### 2. Synthetic vs Real User Monitoring (RUM)

- Synthetic: тестирование в контролируемых условиях
- RUM: мониторинг реальных пользовательских сессий

### 3. Performance Budget

- Установка лимитов на размер бандла
- Ограничения по времени загрузки
- Контроль количества HTTP-запросов

## Заключение

Профилирование производительности - это непрерывный процесс, требующий системного подхода. Регулярный анализ и оптимизация производительности позволяют обеспечить высокий уровень пользовательского опыта и конкурентоспособность веб-приложения.

См. также:
- [[Инструменты-отладки]]
- [[Отладка-JavaScript]]
- [[Отладка-CSS]]
- [[Отладка-сетевых-запросов]]