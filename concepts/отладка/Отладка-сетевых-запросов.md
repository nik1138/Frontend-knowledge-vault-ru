---
aliases: [Сетевые запросы отладка, Network Debugging, Отладка HTTP]
tags: [network, debugging, http, frontend, development]
---

# Отладка сетевых запросов

## Обзор

Отладка сетевых запросов - важная часть веб-разработки, позволяющая анализировать взаимодействие между клиентом и сервером, выявлять проблемы с API, оптимизировать загрузку ресурсов и обеспечивать надежную работу приложения.

## Основные аспекты отладки сетевых запросов

### 1. Типы сетевых запросов

- XMLHttpRequest (XHR)
- Fetch API
- WebSocket-соединения
- Server-Sent Events (SSE)
- JSONP-запросы

### 2. Компоненты HTTP-запроса

- Метод (GET, POST, PUT, DELETE и др.)
- URL и параметры запроса
- Заголовки (headers)
- Тело запроса (request body)
- Коды ответа (status codes)
- Заголовки ответа (response headers)
- Тело ответа (response body)

## Инструменты отладки

### 1. Network вкладка в DevTools

#### Основные функции:

- Мониторинг всех HTTP-запросов
- Анализ времени загрузки и задержек
- Просмотр заголовков запросов и ответов
- Проверка содержимого тела запросов и ответов
- Фильтрация запросов по типу
- Эмуляция медленных соединений

#### Практическое использование:

```javascript
// Пример запроса для отладки
fetch('/api/users', {
    method: 'GET',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
    }
})
.then(response => {
    console.log('Статус ответа:', response.status);
    return response.json();
})
.then(data => console.log('Данные:', data))
.catch(error => console.error('Ошибка:', error));
```

### 2. Таблица Network

Колонки в Network вкладке:

- **Name** - имя ресурса
- **Status** - HTTP статус код
- **Type** - MIME тип ресурса
- **Size** - размер ответа и заголовков
- **Time** - общее время запроса
- **Waterfall** - визуализация фаз запроса

### 3. Детали запроса

- Headers: заголовки запроса и ответа
- Preview: предварительный просмотр ответа
- Response: полное тело ответа
- Timing: детализация временных метрик

## Распространенные проблемы и решения

### 1. CORS ошибки

#### Проблема: Cross-Origin Resource Sharing ошибки

```javascript
// Проблема: CORS ошибка при запросе с localhost на другой домен
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('CORS ошибка:', error));

// В Network вкладке будет ошибка CORS
```

**Решение:**
- Настройка сервера для отправки правильных CORS заголовков
- Использование прокси в процессе разработки
- Настройка сервера разработки для проксирования запросов

```javascript
// Пример CORS заголовков на сервере
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    next();
});
```

### 2. Проблемы с аутентификацией

#### Проблема: 401 Unauthorized ошибки

```javascript
// Проблема: токен аутентификации не отправляется или просрочен
const response = await fetch('/api/protected', {
    headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
});

if (response.status === 401) {
    // Требуется повторная аутентификация
    redirectToLogin();
}
```

### 3. Проблемы с кэшированием

#### Проблема: получение закэшированных данных

```javascript
// Решение: добавление cache-busting параметра
const cacheBuster = new Date().getTime();
fetch(`/api/data?_=${cacheBuster}`)
    .then(response => response.json())
    .then(data => console.log(data));
```

## Практические техники отладки

### 1. Логирование запросов

```javascript
// Создание обертки для отслеживания запросов
async function debugFetch(url, options = {}) {
    console.group(`Запрос: ${options.method || 'GET'} ${url}`);
    
    const startTime = performance.now();
    const response = await fetch(url, options);
    const endTime = performance.now();
    
    console.log('Заголовки запроса:', options.headers);
    if (options.body) {
        console.log('Тело запроса:', options.body);
    }
    
    console.log('Статус ответа:', response.status);
    console.log('Заголовки ответа:', [...response.headers.entries()]);
    
    const responseClone = response.clone();
    const responseBody = await responseClone.text();
    console.log('Тело ответа:', responseBody);
    
    console.log(`Время выполнения: ${endTime - startTime}ms`);
    console.groupEnd();
    
    return response;
}
```

### 2. Перехват и анализ запросов

```javascript
// Перехват всех fetch-запросов
const originalFetch = window.fetch;
window.fetch = function(...args) {
    console.log('Перехваченный fetch:', args[0]);
    
    return originalFetch.apply(this, args)
        .then(response => {
            console.log('Ответ от fetch:', response.status, response.url);
            return response;
        })
        .catch(error => {
            console.error('Ошибка fetch:', error);
            throw error;
        });
};
```

### 3. Использование Proxy для отладки

Настройка прокси в webpack для разработки:

```javascript
// webpack.config.js
module.exports = {
    devServer: {
        proxy: {
            '/api': {
                target: 'https://api.example.com',
                changeOrigin: true,
                pathRewrite: {
                    '^/api': ''
                }
            }
        }
    }
};
```

## Анализ производительности сетевых запросов

### 1. Временные метрики

- **Queueing** - ожидание в очереди
- **Stalled** - задержка перед отправкой
- **DNS Lookup** - время поиска DNS
- **Initial Connection** - установление соединения
- **SSL** - время SSL-рукопожатия
- **Request Sent** - время отправки запроса
- **Waiting (TTFB)** - время до первого байта
- **Content Download** - время загрузки содержимого

### 2. Оптимизация сетевых запросов

```javascript
// Пакетная загрузка данных
async function fetchMultiple(endpoints) {
    const requests = endpoints.map(url => fetch(url));
    const responses = await Promise.all(requests);
    return Promise.all(responses.map(r => r.json()));
}

// Кэширование ответов
const cache = new Map();

async function cachedFetch(url) {
    if (cache.has(url)) {
        console.log('Возврат из кэша:', url);
        return cache.get(url);
    }
    
    const response = await fetch(url);
    const data = await response.json();
    cache.set(url, data);
    
    return data;
}
```

## Отладка WebSocket-соединений

```javascript
// Отладка WebSocket-соединений
const ws = new WebSocket('ws://localhost:8080');

ws.onopen = function(event) {
    console.log('WebSocket соединение открыто');
};

ws.onmessage = function(event) {
    console.log('Получено сообщение:', event.data);
};

ws.onerror = function(error) {
    console.error('WebSocket ошибка:', error);
};

ws.onclose = function(event) {
    console.log('WebSocket соединение закрыто:', event.code, event.reason);
};
```

## Современные подходы к отладке сетевых запросов

### 1. Использование Mock-серверов

Для изоляции проблем на клиенте:

```javascript
// Использование MSW (Mock Service Worker) для мокирования API
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
    rest.get('/api/users', (req, res, ctx) => {
        return res(
            ctx.json([
                { id: 1, name: 'John Doe' },
                { id: 2, name: 'Jane Smith' }
            ])
        );
    })
);

server.listen();
```

### 2. Инструменты третьих сторон

- Postman для ручного тестирования API
- Insomnia для тестирования и документирования API
- Charles Proxy для анализа трафика
- Fiddler для анализа HTTP(S) трафика

### 3. Логирование в продакшене

```javascript
// Логирование сетевых ошибок в продакшене
window.addEventListener('unhandledrejection', event => {
    if (event.reason && event.reason.name === 'TypeError' && 
        event.reason.message.includes('fetch')) {
        // Логирование сетевых ошибок
        analytics.track('Network Error', {
            message: event.reason.message,
            url: window.location.href,
            timestamp: new Date().toISOString()
        });
    }
});
```

## Практические советы

### 1. Проверка статусов ответов

```javascript
async function safeFetch(url, options) {
    const response = await fetch(url, options);
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response;
}
```

### 2. Обработка ошибок сети

```javascript
async function robustFetch(url, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response;
        } catch (error) {
            if (i === retries - 1) throw error; // Последняя попытка
            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Экспоненциальная задержка
        }
    }
}
```

### 3. Отладка с различными типами контента

```javascript
// Отправка и получение различных типов данных
async function handleDifferentContentTypes() {
    // JSON
    const jsonResp = await fetch('/api/json', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ key: 'value' })
    });
    
    // Форм-данные
    const formData = new FormData();
    formData.append('file', fileInput.files[0]);
    const formResp = await fetch('/api/upload', {
        method: 'POST',
        body: formData // Не устанавливаем Content-Type для FormData
    });
    
    // Текст
    const textResp = await fetch('/api/text');
    const text = await textResp.text();
}
```

## Заключение

Эффективная отладка сетевых запросов требует понимания HTTP-протокола, умения использовать инструменты браузера и знания типичных проблем. Регулярный анализ сетевых запросов помогает выявлять и устранять проблемы, оптимизировать производительность и обеспечивать стабильную работу веб-приложения.

См. также:
- [[Инструменты-отладки]]
- [[Отладка-JavaScript]]
- [[Отладка-CSS]]
- [[Профилирование-производительности]]