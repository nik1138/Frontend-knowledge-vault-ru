# Композиция

Композиция — это принцип объектно-ориентированного программирования, при котором классы создаются путем объединения других классов или объектов для получения более сложной функциональности. В отличие от наследования, где класс расширяет другой класс, композиция предполагает, что класс содержит экземпляры других классов как свои компоненты.

## Основные характеристики композиции

### Отношение "имеет"
Композиция выражает отношение "имеет" между объектами. Например, автомобиль имеет двигатель, колеса и т.д.

### Жизненный цикл
В композиции содержащиеся объекты полностью зависят от контейнера. Когда контейнер уничтожается, все содержащиеся в нем объекты также уничтожаются.

### Сильная связанность
Композиция создает сильную связанность между контейнером и содержащимися объектами.

## Примеры композиции

### В JavaScript
```javascript
// Композиция в JavaScript
class Engine {
  start() {
    console.log('Двигатель запущен');
  }
  
  stop() {
    console.log('Двигатель остановлен');
  }
}

class Wheel {
  constructor(position) {
    this.position = position;
  }
  
  rotate() {
    console.log(`Колесо ${this.position} вращается`);
  }
}

class Car {
  constructor() {
    // Композиция - Car содержит экземпляры других классов
    this.engine = new Engine();
    this.wheels = [
      new Wheel('front-left'),
      new Wheel('front-right'),
      new Wheel('rear-left'),
      new Wheel('rear-right')
    ];
    this.isRunning = false;
  }
  
  start() {
    this.engine.start();
    this.isRunning = true;
    console.log('Автомобиль запущен');
  }
  
  drive() {
    if (this.isRunning) {
      this.wheels.forEach(wheel => wheel.rotate());
      console.log('Автомобиль движется');
    } else {
      console.log('Сначала запустите двигатель');
    }
  }
  
  stop() {
    this.engine.stop();
    this.isRunning = false;
    console.log('Автомобиль остановлен');
  }
}

// Использование
const car = new Car();
car.start();
car.drive();
car.stop();
```

### В TypeScript
```typescript
// Композиция в TypeScript
class CPU {
  private frequency: number;
  
  constructor(frequency: number) {
    this.frequency = frequency;
  }
  
  process(): void {
    console.log(`Процессор работает на частоте ${this.frequency} ГГц`);
  }
}

class RAM {
  private size: number;
  
  constructor(size: number) {
    this.size = size;
  }
  
  load(data: string): void {
    console.log(`Загружено в память: ${data} (${this.size} ГБ)`);
  }
}

class Storage {
  private capacity: number;
  
  constructor(capacity: number) {
    this.capacity = capacity;
  }
  
  save(data: string): void {
    console.log(`Сохранено в хранилище: ${data} (${this.capacity} ГБ)`);
  }
}

class Computer {
  private cpu: CPU;
  private ram: RAM;
  private storage: Storage;
  
  constructor(cpuFreq: number, ramSize: number, storageCapacity: number) {
    // Композиция - Computer содержит экземпляры других классов
    this.cpu = new CPU(cpuFreq);
    this.ram = new RAM(ramSize);
    this.storage = new Storage(storageCapacity);
  }
  
  boot(): void {
    console.log('Запуск компьютера...');
    this.cpu.process();
    this.ram.load('ОС');
    console.log('Компьютер готов к работе');
  }
  
  work(data: string): void {
    this.ram.load(data);
    this.cpu.process();
    this.storage.save(data);
    console.log('Работа завершена');
  }
}

// Использование
const computer = new Computer(3.5, 16, 512);
computer.boot();
computer.work('Мои документы');
```

## Преимущества композиции

### Гибкость
Композиция обеспечивает большую гибкость по сравнению с наследованием, так как поведение можно изменять во время выполнения.

### Повторное использование кода
Существующие классы могут быть повторно использованы в различных контекстах через композицию.

### Тестирование
Компоненты можно тестировать отдельно, что упрощает модульное тестирование.

### Слабое зацепление
При правильной реализации композиция может привести к слабому зацеплению между компонентами.

## Недостатки композиции

### Сложность проектирования
Правильное проектирование композиции может быть сложнее, чем использование наследования.

### Накладные расходы
Композиция может привести к увеличению количества объектов в системе.

### Косвенность
Доступ к функциональности компонентов может быть менее прямым по сравнению с наследованием.

## Композиция vs Наследование

### Когда использовать композицию
- Когда нужно изменять поведение во время выполнения
- Когда отношения между классами выражаются как "имеет"
- Когда необходимо повторно использовать код в различных контекстах
- Когда нужно избежать жесткой иерархии наследования

### Когда использовать наследование
- Когда отношения между классами выражаются как "является"
- Когда необходимо расширить существующий функционал
- Когда иерархия классов стабильна и не изменяется часто

## Паттерны, использующие композицию

### Декоратор (Decorator)
```javascript
// Декоратор использует композицию
class Component {
  operation() {
    return 'Базовая операция';
  }
}

class Decorator {
  constructor(component) {
    this.component = component; // Композиция
  }
  
  operation() {
    return `Декорированная: ${this.component.operation()}`;
  }
}

class ConcreteDecorator extends Decorator {
  operation() {
    return `Конкретная декорация -> ${super.operation()}`;
  }
}

// Использование
const component = new Component();
const decorated = new ConcreteDecorator(component);
console.log(decorated.operation());
```

### Компоновщик (Composite)
```javascript
// Компоновщик использует композицию
class Component {
  operation() {
    throw new Error('Метод operation должен быть реализован');
  }
}

class Leaf extends Component {
  operation() {
    return 'Листовой элемент';
  }
}

class Composite extends Component {
  constructor() {
    super();
    this.children = []; // Композиция - содержит другие компоненты
  }
  
  add(component) {
    this.children.push(component);
  }
  
  remove(component) {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  operation() {
    return this.children.map(child => child.operation()).join(', ');
  }
}

// Использование
const composite = new Composite();
composite.add(new Leaf());
composite.add(new Leaf());

const topLevel = new Composite();
topLevel.add(composite);
topLevel.add(new Leaf());

console.log(topLevel.operation());
```

## Связь с другими концепциями

- [[Объектно-ориентированное программирование]] - Композиция является одним из основных принципов ООП
- [[SOLID]] - Принцип инверсии зависимостей (DIP) и принцип открытости/закрытости (OCP) связаны с композицией
- [[GRASP (General Responsibility Assignment Software Patterns)]] - Паттерн "Чистая выдумка" (Pure Fabrication) часто реализуется через композицию
- [[DRY (Don't Repeat Yourself)]] - Композиция способствует повторному использованию кода
- [[Разделение ответственности]] - Композиция помогает разделить ответственность между компонентами

## Применение в современных технологиях

### В [[ts]]
TypeScript поддерживает композицию через:
- Классы и интерфейсы
- Дженерики для создания гибких компонентов
- Миксины для множественной композиции

### В [[js]]
JavaScript поддерживает композицию через:
- Классы (ES6+)
- Функции высшего порядка
- Объекты и прототипы

### В [[react]]
React компоненты используют композицию:
- Компоненты как составные части других компонентов
- Children API для передачи компонентов
- Композиция через props

## Теги
#composition #oop #programming-concepts #design-principles #software-design