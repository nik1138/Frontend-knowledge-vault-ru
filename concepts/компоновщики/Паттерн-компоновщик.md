---
aliases: ["Компоновщик паттерн", "Composite Pattern", "Паттерн Composite"]
tags: ["#design-patterns", "#architectural-patterns", "#oop", "#javascript", "#frontend"]
---

# Паттерн Компоновщик

Паттерн **Компоновщик** (Composite) - это структурный паттерн проектирования, который позволяет клиентскому коду обрабатывать отдельные объекты и составные структуры однородным образом. Он особенно полезен при работе с древовидными структурами данных, где отдельные элементы могут быть как листовыми узлами, так и контейнерами, содержащими другие элементы.

## Основные понятия

Паттерн Компоновщик определяет иерархию классов, состоящую из двух типов объектов:

- **Компонент** (Component) - абстрактный класс или интерфейс, определяющий общее поведение для всех элементов дерева
- **Лист** (Leaf) - объект, не содержащий дочерних элементов
- **Контейнер** (Composite) - объект, содержащий дочерние элементы (как листовые, так и другие контейнеры)

## Когда использовать

- Когда нужно работать с древовидными структурами данных
- Когда клиентский код должен обрабатывать простые и составные объекты одинаково
- Когда структура дерева может изменяться динамически

## Структура паттерна

```
Component
├── Operation()
├── Add(child)
├── Remove(child)
├── GetChild(index)
├── Leaf
│   └── Operation() // конкретная реализация
└── Composite
    ├── children[]
    ├── Operation() // делегирует операции дочерним элементам
    ├── Add(child)
    ├── Remove(child)
    └── GetChild(index)
```

## Пример на JavaScript

```javascript
// Абстрактный класс компонента
class Component {
  constructor(name) {
    this.name = name;
  }

  operation() {
    throw new Error("Метод operation() должен быть реализован");
  }

  add(component) {
    throw new Error("Метод add() не поддерживается");
  }

  remove(component) {
    throw new Error("Метод remove() не поддерживается");
  }

  getChild(index) {
    throw new Error("Метод getChild() не поддерживается");
  }
}

// Листовой элемент
class Leaf extends Component {
  operation() {
    return `Лист ${this.name}: выполнение операции`;
  }
}

// Контейнер
class Composite extends Component {
  constructor(name) {
    super(name);
    this.children = [];
  }

  add(component) {
    this.children.push(component);
  }

  remove(component) {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  getChild(index) {
    return this.children[index];
  }

  operation() {
    let result = `Контейнер ${this.name}: выполнение операции\n`;
    for (const child of this.children) {
      result += `  ${child.operation()}\n`;
    }
    return result;
  }
}

// Пример использования
const tree = new Composite("Дерево");

const branch1 = new Composite("Ветвь 1");
const branch2 = new Composite("Ветвь 2");

const leaf1 = new Leaf("Лист 1");
const leaf2 = new Leaf("Лист 2");
const leaf3 = new Leaf("Лист 3");

branch1.add(leaf1);
branch1.add(leaf2);
branch2.add(leaf3);

tree.add(branch1);
tree.add(branch2);

console.log(tree.operation());
```

## Преимущества

- Позволяет работать с древовидными структурами единообразно
- Упрощает добавление новых типов компонентов
- Облегчает рекурсивную обработку структур

## Недостатки

- Может привести к созданию слишком общих классов
- Типы компонентов не проверяются на этапе компиляции

## Применение в веб-разработке

Паттерн Компоновщик часто используется в фронтенд-разработке:

- [[Компоновщики-в-React]] - для построения иерархии компонентов
- [[Компоновщики-в-Vue]] - для управления древовидными структурами
- [[Компоновщики-в-JavaScript]] - для построения DOM-дерева
- [[Компонентная-архитектура]] - как основа для построения интерфейсов
- [[Директивы]] - для управления сложными элементами управления

## Связь с другими паттернами

- [[Декораторы]] - может использоваться совместно для добавления функциональности
- [[Итераторы]] - для обхода древовидных структур
- [[Стратегия]] - для определения поведения компонентов

## Заключение

Паттерн Компоновщик - мощный инструмент для работы с древовидными структурами данных. Он позволяет создавать гибкие и расширяемые архитектуры, особенно полезные в фронтенд-разработке для построения сложных интерфейсов.

> [!tip] 
> Используйте паттерн Компоновщик, когда вам нужно обрабатывать простые и составные объекты одинаково, особенно в контексте построения пользовательских интерфейсов.

> [!warning] 
> Убедитесь, что структура действительно имеет древовидную природу, чтобы избежать излишней сложности.
