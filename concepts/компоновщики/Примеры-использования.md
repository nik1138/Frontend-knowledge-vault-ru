---
aliases: ["Примеры использования компоновщика", "Composite Pattern Examples", "Практические примеры компоновщика"]
tags: ["#design-patterns", "#javascript", "#react", "#vue", "#frontend", "#examples"]
---

# Примеры использования паттерна Компоновщик

Паттерн **Компоновщик** находит широкое применение в современной веб-разработке. Ниже приведены практические примеры его использования в различных контекстах фронтенд-разработки.

## Пример 1: Дерево файловой системы

Классический пример паттерна Компоновщик - представление файловой системы:

```javascript
class FileSystemItem {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }

  getSize() {
    throw new Error("Метод должен быть реализован");
  }
}

class File extends FileSystemItem {
  constructor(name, size) {
    super(name);
    this.size = size;
  }

  getSize() {
    return this.size;
  }
}

class Directory extends FileSystemItem {
  constructor(name) {
    super(name);
    this.children = [];
  }

  add(item) {
    this.children.push(item);
  }

  remove(item) {
    const index = this.children.indexOf(item);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  getSize() {
    return this.children.reduce((total, child) => total + child.getSize(), 0);
  }

  getContents() {
    return this.children;
  }
}

// Использование
const root = new Directory("root");
const documents = new Directory("Документы");
const photos = new Directory("Фото");

const file1 = new File("документ.txt", 1024);
const file2 = new File("фото.jpg", 2048);
const file3 = new File("портрет.png", 3072);

documents.add(file1);
photos.add(file2);
photos.add(file3);

root.add(documents);
root.add(photos);

console.log(`Размер корневой директории: ${root.getSize()} байт`);
```

## Пример 2: Компонент формы в React

Создание гибкой формы с использованием паттерна Компоновщик:

```jsx
// Field.jsx
function Field({ label, children, error }) {
  return (
    <div className="form-field">
      <label>{label}</label>
      {children}
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// FormSection.jsx
function FormSection({ title, children }) {
  return (
    <div className="form-section">
      <h3>{title}</h3>
      {children}
    </div>
  );
}

// ContactForm.jsx
function ContactForm() {
  const [formData, setFormData] = React.useState({
    name: '',
    email: '',
    phone: ''
  });

  const [errors, setErrors] = React.useState({});

  const handleChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Очистка ошибки при изменении поля
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }
  };

  const validate = () => {
    const newErrors = {};
    
    if (!formData.name.trim()) {
      newErrors.name = 'Имя обязательно';
    }
    
    if (!formData.email.includes('@')) {
      newErrors.email = 'Некорректный email';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validate()) {
      console.log('Форма отправлена:', formData);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <FormSection title="Контактная информация">
        <Field label="Имя" error={errors.name}>
          <input 
            type="text" 
            value={formData.name}
            onChange={(e) => handleChange('name', e.target.value)}
          />
        </Field>
        
        <Field label="Email" error={errors.email}>
          <input 
            type="email" 
            value={formData.email}
            onChange={(e) => handleChange('email', e.target.value)}
          />
        </Field>
        
        <Field label="Телефон">
          <input 
            type="tel" 
            value={formData.phone}
            onChange={(e) => handleChange('phone', e.target.value)}
          />
        </Field>
      </FormSection>
      
      <button type="submit">Отправить</button>
    </form>
  );
}
```

## Пример 3: Компонент меню в Vue

Создание рекурсивного меню с использованием паттерна Компоновщик:

```vue
<!-- MenuItem.vue -->
<template>
  <li class="menu-item">
    <a 
      v-if="!item.children" 
      :href="item.url" 
      :class="{ 'active': item.active }"
    >
      {{ item.label }}
    </a>
    
    <a 
      v-else 
      href="#" 
      class="menu-parent"
      @click.prevent="toggleExpanded"
    >
      {{ item.label }}
      <span class="expand-icon">{{ expanded ? '▼' : '►' }}</span>
    </a>
    
    <ul 
      v-if="item.children && expanded" 
      class="submenu"
    >
      <MenuItem 
        v-for="child in item.children" 
        :key="child.id"
        :item="child"
      />
    </ul>
  </li>
</template>

<script setup>
import { ref } from 'vue';
import { defineProps } from 'vue';

const props = defineProps({
  item: {
    type: Object,
    required: true
  }
});

const expanded = ref(false);

const toggleExpanded = () => {
  expanded.value = !expanded.value;
};
</script>
```

```vue
<!-- MainMenu.vue -->
<template>
  <nav class="main-menu">
    <ul class="menu">
      <MenuItem 
        v-for="item in menuItems" 
        :key="item.id"
        :item="item"
      />
    </ul>
  </nav>
</template>

<script setup>
import { ref } from 'vue';
import MenuItem from './MenuItem.vue';

const menuItems = ref([
  {
    id: 1,
    label: 'Главная',
    url: '/'
  },
  {
    id: 2,
    label: 'Продукты',
    children: [
      {
        id: 21,
        label: 'Категория 1',
        children: [
          { id: 211, label: 'Товар 1', url: '/product/1' },
          { id: 212, label: 'Товар 2', url: '/product/2' }
        ]
      },
      {
        id: 22,
        label: 'Категория 2',
        url: '/category/2'
      }
    ]
  },
  {
    id: 3,
    label: 'О нас',
    url: '/about'
  }
]);
</script>
```

## Пример 4: Система валидации форм

Создание гибкой системы валидации с использованием компоновщика:

```javascript
class ValidationRule {
  constructor(message) {
    this.message = message;
  }

  validate(value) {
    throw new Error("Метод validate должен быть реализован");
  }
}

class RequiredRule extends ValidationRule {
  constructor(message = "Поле обязательно") {
    super(message);
  }

  validate(value) {
    return value && value.toString().trim().length > 0;
  }
}

class EmailRule extends ValidationRule {
  constructor(message = "Некорректный email") {
    super(message);
  }

  validate(value) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  }
}

class MinLengthRule extends ValidationRule {
  constructor(minLength, message) {
    super(message || `Минимальная длина ${minLength} символов`);
    this.minLength = minLength;
  }

  validate(value) {
    return value && value.length >= this.minLength;
  }
}

class CompositeRule extends ValidationRule {
  constructor(rules = [], message = "") {
    super(message);
    this.rules = rules;
  }

  add(rule) {
    this.rules.push(rule);
  }

  validate(value) {
    for (const rule of this.rules) {
      if (!rule.validate(value)) {
        this.message = rule.message;
        return false;
      }
    }
    return true;
  }
}

// Использование
const emailValidation = new CompositeRule();
emailValidation.add(new RequiredRule("Email обязателен"));
emailValidation.add(new EmailRule());

const passwordValidation = new CompositeRule();
passwordValidation.add(new RequiredRule());
passwordValidation.add(new MinLengthRule(8));

const userData = {
  email: "user@example.com",
  password: "password123"
};

console.log(emailValidation.validate(userData.email)); // true
console.log(passwordValidation.validate(userData.password)); // true
```

## Пример 5: Система рендеринга UI-компонентов

Создание системы рендеринга с поддержкой различных типов компонентов:

```javascript
class UIComponent {
  constructor(props = {}) {
    this.props = props;
    this.children = [];
  }

  add(child) {
    this.children.push(child);
  }

  remove(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  render() {
    throw new Error("Метод render должен быть реализован");
  }
}

class TextElement extends UIComponent {
  render() {
    return `<span>${this.props.text || ''}</span>`;
  }
}

class ButtonElement extends UIComponent {
  render() {
    const { text, onClick, disabled } = this.props;
    const disabledAttr = disabled ? 'disabled' : '';
    return `<button ${disabledAttr} onclick="${onClick || ''}">${text}</button>`;
  }
}

class ContainerElement extends UIComponent {
  render() {
    const childrenHtml = this.children.map(child => child.render()).join('');
    return `<div class="${this.props.className || ''}">${childrenHtml}</div>`;
  }
}

class LayoutElement extends UIComponent {
  render() {
    let html = '<div class="layout">';
    
    for (const child of this.children) {
      html += child.render();
    }
    
    html += '</div>';
    return html;
  }
}

// Использование
const layout = new LayoutElement();
const header = new ContainerElement({ className: 'header' });
const body = new ContainerElement({ className: 'body' });

const title = new TextElement({ text: 'Заголовок' });
const button = new ButtonElement({ text: 'Нажми меня', onClick: 'handleClick()' });

header.add(title);
body.add(button);

layout.add(header);
layout.add(body);

document.getElementById('app').innerHTML = layout.render();
```

## Пример 6: Система управления доступом (ACL)

Использование компоновщика для создания гибкой системы управления доступом:

```javascript
class Permission {
  constructor(name, description) {
    this.name = name;
    this.description = description;
  }

  check(user) {
    throw new Error("Метод check должен быть реализован");
  }
}

class UserPermission extends Permission {
  check(user) {
    return user.permissions.includes(this.name);
  }
}

class RolePermission extends Permission {
  constructor(name, description, roles) {
    super(name, description);
    this.roles = roles;
  }

  check(user) {
    return this.roles.includes(user.role);
  }
}

class CompositePermission extends Permission {
  constructor(name, description) {
    super(name, description);
    this.permissions = [];
  }

  add(permission) {
    this.permissions.push(permission);
  }

  remove(permission) {
    const index = this.permissions.indexOf(permission);
    if (index !== -1) {
      this.permissions.splice(index, 1);
    }
  }

  check(user) {
    return this.permissions.some(permission => permission.check(user));
  }
}

// Использование
const viewDashboard = new UserPermission('view_dashboard', 'Просмотр панели управления');
const editContent = new RolePermission('edit_content', 'Редактирование контента', ['admin', 'editor']);

const adminPermissions = new CompositePermission('admin', 'Права администратора');
adminPermissions.add(viewDashboard);
adminPermissions.add(editContent);

const user = {
  role: 'admin',
  permissions: ['view_dashboard']
};

console.log(adminPermissions.check(user)); // true
```

## Практические рекомендации

1. **Используйте паттерн Компоновщик для создания иерархических структур** - особенно когда нужно обрабатывать простые и составные элементы одинаково
2. **Реализуйте общие методы в базовом классе** - это обеспечивает единообразие в работе с разными типами компонентов
3. **Используйте TypeScript для лучшей типизации** - это особенно важно при работе с композицией компонентов
4. **Ограничьте глубину вложенности** - слишком глубокие иерархии могут быть сложны в отладке и поддержке

## Когда использовать

- При создании древовидных структур (меню, навигация, файловая система)
- При построении компонентной архитектуры
- При реализации систем валидации
- При создании систем управления доступом
- При построении сложных форм с вложенными элементами

## Связь с другими концепциями

- [[Паттерн-компоновщик]] - основная концепция
- [[Компоновщики-в-React]] - реализация в React
- [[Компоновщики-в-Vue]] - реализация в Vue
- [[Компоновщики-в-JavaScript]] - реализация в чистом JS
- [[Компонентная-архитектура]] - архитектурный подход
- [[Валидация-форм]] - практическое применение

## Заключение

Паттерн Компоновщик предоставляет гибкий способ организации сложных структур данных и UI-компонентов. Его правильное применение позволяет создавать масштабируемые и поддерживаемые приложения.

> [!tip]
> Используйте паттерн Компоновщик, когда вам нужно работать с древовидными структурами, где элементы могут быть как простыми, так и составными.

> [!example]
> Все примеры в этом файле демонстрируют практическое применение паттерна Компоновщик в реальных сценариях разработки.
