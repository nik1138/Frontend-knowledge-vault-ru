---
aliases: ["Итератор (паттерн)", "Шаблон итератора", "Iterator Pattern"]
tags: [programming-patterns, javascript, design-patterns, frontend-development]
---

# Паттерн Итератор

## Обзор

Паттерн Итератор (Iterator Pattern) — это поведенческий паттерн проектирования, который предоставляет способ последовательного доступа к элементам объекта-коллекции без раскрытия его внутреннего представления. Итератор позволяет обходить элементы коллекции поочередно, не завися от типа коллекции и ее внутренней структуры.

В JavaScript и других языках программирования итераторы играют ключевую роль в обработке коллекций данных, таких как массивы, списки и другие структуры данных. Они обеспечивают унифицированный способ перебора элементов, что упрощает написание кода и делает его более читаемым и поддерживаемым.

## Основные понятия

### Что такое итератор?

Итератор — это объект, который реализует интерфейс итератора, предоставляемый языком или библиотекой. В JavaScript итераторы определяются как объекты, у которых есть метод `next()`, возвращающий объект с двумя свойствами:
- `value` — значение текущего элемента
- `done` — логическое значение, указывающее, достигнут ли конец коллекции

```javascript
const iterator = {
  current: 0,
  items: ['один', 'два', 'три'],
  
  next() {
    if (this.current < this.items.length) {
      return {
        value: this.items[this.current++],
        done: false
      };
    } else {
      return {
        done: true
      };
    }
  }
};

console.log(iterator.next()); // { value: 'один', done: false }
console.log(iterator.next()); // { value: 'два', done: false }
console.log(iterator.next()); // { value: 'три', done: false }
console.log(iterator.next()); // { done: true }
```

### Протокол итератора

В JavaScript протокол итератора определяет два метода:
- `Symbol.iterator` — возвращает итератор для объекта
- `next()` — возвращает следующий элемент последовательности

Объекты, реализующие протокол итератора, называются итерируемыми. Примеры встроенных итерируемых объектов в JavaScript: массивы, строки, Map, Set и другие.

```javascript
const arr = [1, 2, 3];
const iter = arr[Symbol.iterator]();

console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

## Преимущества паттерна итератора

- **Унификация доступа к коллекциям** — позволяет использовать одинаковый интерфейс для перебора различных типов коллекций
- **Инкапсуляция структуры данных** — внутреннее представление коллекции остается скрытым
- **Поддержка различных способов обхода** — можно реализовать разные стратегии итерации (например, прямой, обратный, случайный порядок)
- **Ленивое вычисление** — элементы могут вычисляться по мере необходимости, а не сразу все

## Примеры использования в JavaScript

### Встроенные итераторы

JavaScript предоставляет несколько встроенных способов работы с итераторами:

```javascript
// for...of цикл
const iterable = [10, 20, 30];
for (const value of iterable) {
  console.log(value);
}

// Spread оператор
const arr = [...iterable];
console.log(arr); // [10, 20, 30]

// Деструктуризация
const [first, ...rest] = iterable;
console.log(first); // 10
console.log(rest); // [20, 30]
```

### Создание пользовательского итератора

```javascript
class Range {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }

  [Symbol.iterator]() {
    return {
      current: this.start,
      end: this.end,
      next() {
        if (this.current < this.end) {
          return { value: this.current++, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
}

const range = new Range(1, 4);
for (const num of range) {
  console.log(num); // 1, 2, 3
}
```

## Итераторы и функциональное программирование

Итераторы тесно связаны с концепциями функционального программирования, особенно с методами массивов, такими как `map`, `filter`, `reduce`, которые возвращают новые массивы на основе итерации по исходному массиву.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Использование методов массива
const doubled = numbers.map(n => n * 2);
const evens = doubled.filter(n => n % 2 === 0);
const sum = evens.reduce((acc, n) => acc + n, 0);

console.log(sum); // 24
```

## Итераторы и асинхронные операции

Существует также концепция асинхронных итераторов, которые позволяют работать с асинхронными потоками данных:

```javascript
async function* asyncGenerator() {
  let i = 0;
  while (i < 3) {
    yield await new Promise(resolve => setTimeout(() => resolve(i++), 1000));
  }
}

async function processAsyncIterator() {
  for await (const value of asyncGenerator()) {
    console.log(value); // 0, 1, 2 (с задержкой в 1 секунду)
  }
}

processAsyncIterator();
```

## Связь с другими паттернами

- [[Компоновщики]] — итераторы могут использоваться для обхода дерева компоновщиков
- [[Декораторы]] — декораторы могут изменять поведение итераторов
- [[Фабрики]] — фабрики могут создавать различные типы итераторов

## Практические рекомендации

- Используйте встроенные итераторы, когда это возможно, для лучшей читаемости кода
- Реализуйте протокол итератора для пользовательских коллекций, чтобы обеспечить совместимость с циклами `for...of` и другими итерирующими конструкциями
- Используйте генераторы для создания сложных итераторов с минимальным объемом кода
- Будьте осторожны с производительностью при работе с большими коллекциями — рассмотрите использование ленивых итераторов

## Заключение

Паттерн итератора является фундаментальным инструментом в программировании, особенно в JavaScript, где он тесно интегрирован с языком. Понимание и эффективное использование итераторов позволяет писать более чистый, поддерживаемый и эффективный код при работе с коллекциями данных.

## См. также

- [[Итераторы-в-JavaScript]]
- [[Итераторы-в-React]]
- [[Итераторы-в-Vue]]
- [[Итераторы-и-производительность]]
- [[Алгоритмы-и-структуры-данных]]
- [[Функциональное-программирование]]
