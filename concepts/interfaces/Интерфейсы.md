# Интерфейсы

Интерфейсы — это контракты в объектно-ориентированном программировании, которые определяют набор методов и свойств, которые должен реализовать класс. Интерфейсы не содержат реализации, а лишь описывают, какие методы и свойства должны быть у класса, реализующего этот интерфейс. Интерфейсы являются мощным инструментом для достижения слабой связанности и полиморфного поведения.

## Основные характеристики интерфейсов

### Контракт
Интерфейс определяет контракт, которому должны следовать реализующие его классы.

### Отсутствие реализации
Интерфейсы содержат только объявления методов и свойств без их реализации.

### Множественная реализация
Класс может реализовывать несколько интерфейсов одновременно.

### Слабое зацепление
Интерфейсы способствуют слабому зацеплению между компонентами системы.

## Примеры интерфейсов

### В TypeScript
```typescript
// Интерфейсы в TypeScript
interface Drawable {
  draw(): void;
}

interface Resizable {
  resize(factor: number): void;
}

interface Shape extends Drawable, Resizable {
  getArea(): number;
  getColor(): string;
}

// Класс реализует интерфейс
class Rectangle implements Shape {
  private width: number;
  private height: number;
  private color: string;
  
  constructor(width: number, height: number, color: string) {
    this.width = width;
    this.height = height;
    this.color = color;
  }
  
  // Реализация методов интерфейса
  draw(): void {
    console.log(`Рисуем прямоугольник ${this.width}x${this.height} цвета ${this.color}`);
  }
  
  resize(factor: number): void {
    this.width *= factor;
    this.height *= factor;
    console.log(`Размеры изменены в ${factor} раз`);
  }
  
  getArea(): number {
    return this.width * this.height;
  }
  
  getColor(): string {
    return this.color;
  }
}

class Circle implements Shape {
  private radius: number;
  private color: string;
  
  constructor(radius: number, color: string) {
    this.radius = radius;
    this.color = color;
  }
  
  // Реализация методов интерфейса
  draw(): void {
    console.log(`Рисуем круг радиусом ${this.radius} цвета ${this.color}`);
  }
  
  resize(factor: number): void {
    this.radius *= factor;
    console.log(`Радиус изменен в ${factor} раз`);
  }
  
  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
  
  getColor(): string {
    return this.color;
  }
}

// Полиморфное использование через интерфейс
function processShape(shape: Shape): void {
  shape.draw();
  console.log(`Площадь: ${shape.getArea()}`);
  shape.resize(1.5);
  shape.draw();
  console.log(`Новая площадь: ${shape.getArea()}`);
}

// Использование
const rectangle = new Rectangle(10, 5, 'красный');
const circle = new Circle(7, 'синий');

processShape(rectangle);
processShape(circle);
```

### В Java
```java
// Интерфейсы в Java
interface Drawable {
  void draw();
}

interface Resizable {
  void resize(double factor);
}

interface Shape extends Drawable, Resizable {
  double getArea();
  String getColor();
}

// Класс реализует интерфейс
class Rectangle implements Shape {
  private double width;
  private double height;
  private String color;
  
  public Rectangle(double width, double height, String color) {
    this.width = width;
    this.height = height;
    this.color = color;
  }
  
  // Реализация методов интерфейса
  @Override
  public void draw() {
    System.out.println("Рисуем прямоугольник " + width + "x" + height + " цвета " + color);
  }
  
  @Override
  public void resize(double factor) {
    this.width *= factor;
    this.height *= factor;
    System.out.println("Размеры изменены в " + factor + " раз");
  }
  
  @Override
  public double getArea() {
    return width * height;
  }
  
  @Override
  public String getColor() {
    return color;
  }
}

class Circle implements Shape {
  private double radius;
  private String color;
  
  public Circle(double radius, String color) {
    this.radius = radius;
    this.color = color;
  }
  
  // Реализация методов интерфейса
  @Override
  public void draw() {
    System.out.println("Рисуем круг радиусом " + radius + " цвета " + color);
  }
  
  @Override
  public void resize(double factor) {
    this.radius *= factor;
    System.out.println("Радиус изменен в " + factor + " раз");
  }
  
  @Override
  public double getArea() {
    return Math.PI * radius * radius;
  }
  
  @Override
  public String getColor() {
    return color;
  }
}

// Полиморфное использование через интерфейс
public class InterfaceExample {
  public static void processShape(Shape shape) {
    shape.draw();
    System.out.println("Площадь: " + shape.getArea());
    shape.resize(1.5);
    shape.draw();
    System.out.println("Новая площадь: " + shape.getArea());
  }
  
  public static void main(String[] args) {
    Shape rectangle = new Rectangle(10, 5, "красный");
    Shape circle = new Circle(7, "синий");
    
    processShape(rectangle);
    processShape(circle);
  }
}
```

## Типы интерфейсов

### Нормальные интерфейсы
Содержат объявления методов, которые должны быть реализованы.

### Функциональные интерфейсы
Содержат только один абстрактный метод (в Java).

### Маркерные интерфейсы
Пустые интерфейсы, которые используются для маркировки классов (например, Serializable в Java).

### Интерфейсы с реализацией по умолчанию
Интерфейсы, которые могут содержать реализацию методов по умолчанию (в Java 8+).

## Преимущества интерфейсов

### Слабое зацепление
Интерфейсы уменьшают связанность между компонентами системы.

### Тестируемость
Интерфейсы облегчают модульное тестирование через моки и стабы.

### Гибкость
Интерфейсы позволяют легко заменять реализации без изменения клиентского кода.

### Полиморфизм
Интерфейсы обеспечивают основу для полиморфного поведения.

### Документирование
Интерфейсы служат формальной документацией контрактов.

## Недостатки интерфейсов

### Сложность проектирования
Правильное проектирование интерфейсов может быть сложным.

### Избыточность
Для простых случаев интерфейсы могут быть избыточными.

### Накладные расходы
Использование интерфейсов может добавить небольшие накладные расходы.

## Паттерны, использующие интерфейсы

### Стратегия (Strategy)
```typescript
// Стратегия использует интерфейсы
interface SortStrategy {
  sort(data: number[]): number[];
}

class QuickSort implements SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка быстрой сортировкой');
    return [...data].sort((a, b) => a - b);
  }
}

class MergeSort implements SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка сортировкой слиянием');
    return [...data].sort((a, b) => a - b);
  }
}

class Sorter {
  private strategy: SortStrategy;
  
  constructor(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  sort(data: number[]): number[] {
    return this.strategy.sort(data);
  }
}
```

### Адаптер (Adapter)
```typescript
// Адаптер использует интерфейсы
interface MediaPlayer {
  play(audioType: string, fileName: string): void;
}

interface AdvancedMediaPlayer {
  playVlc(fileName: string): void;
  playMp4(fileName: string): void;
}

class VlcPlayer implements AdvancedMediaPlayer {
  playVlc(fileName: string): void {
    console.log("Воспроизведение VLC файла: " + fileName);
  }
  
  playMp4(fileName: string): void {
    // Ничего не делаем
  }
}

class Mp4Player implements AdvancedMediaPlayer {
  playVlc(fileName: string): void {
    // Ничего не делаем
  }
  
  playMp4(fileName: string): void {
    console.log("Воспроизведение MP4 файла: " + fileName);
  }
}

class MediaAdapter implements MediaPlayer {
  private advancedPlayer: AdvancedMediaPlayer;
  
  constructor(audioType: string) {
    if (audioType === "vlc") {
      this.advancedPlayer = new VlcPlayer();
    } else if (audioType === "mp4") {
      this.advancedPlayer = new Mp4Player();
    }
  }
  
  play(audioType: string, fileName: string): void {
    if (audioType === "vlc") {
      this.advancedPlayer.playVlc(fileName);
    } else if (audioType === "mp4") {
      this.advancedPlayer.playMp4(fileName);
    }
  }
}
```

### Фабрика (Factory)
```typescript
// Фабрика использует интерфейсы
interface Animal {
  makeSound(): void;
}

class Dog implements Animal {
  makeSound(): void {
    console.log("Собака лает");
  }
}

class Cat implements Animal {
  makeSound(): void {
    console.log("Кошка мяукает");
  }
}

class AnimalFactory {
  static createAnimal(type: string): Animal {
    switch(type) {
      case "dog":
        return new Dog();
      case "cat":
        return new Cat();
      default:
        throw new Error("Неизвестный тип животного");
    }
  }
}

// Использование
const dog = AnimalFactory.createAnimal("dog");
const cat = AnimalFactory.createAnimal("cat");

dog.makeSound(); // Собака лает
cat.makeSound(); // Кошка мяукает
```

## Интерфейсы в функциональном программировании

Интерфейсы также применимы в функциональном программировании:

```javascript
// Функциональные интерфейсы
const createProcessor = (processFn) => {
  return {
    process: processFn
  };
};

// Разные реализации одного интерфейса
const doubleProcessor = createProcessor((x) => x * 2);
const squareProcessor = createProcessor((x) => x * x);
const toStringProcessor = createProcessor((x) => x.toString());

// Полиморфное использование
const processData = (processor, data) => {
  return data.map(processor.process);
};

const numbers = [1, 2, 3, 4, 5];

console.log(processData(doubleProcessor, numbers)); // [2, 4, 6, 8, 10]
console.log(processData(squareProcessor, numbers)); // [1, 4, 9, 16, 25]
console.log(processData(toStringProcessor, numbers)); // ['1', '2', '3', '4', '5']
```

## Связь с другими концепциями

- [[Объектно-ориентированное программирование]] - Интерфейсы являются важным элементом ООП
- [[Полиморфизм]] - Интерфейсы обеспечивают основу для полиморфного поведения
- [[SOLID]] - Принцип инверсии зависимостей (DIP) использует интерфейсы
- [[GRASP (General Responsibility Assignment Software Patterns)]] - Интерфейсы помогают достигать слабого зацепления
- [[DRY (Don't Repeat Yourself)]] - Интерфейсы помогают избежать дублирования контрактов
- [[Чистый код]] - Интерфейсы способствуют написанию чистого, понятного кода

## Применение в современных технологиях

### В [[ts]]
TypeScript активно использует интерфейсы:
- Определение контрактов для классов
- Описание структуры объектов
- Дженерики для создания гибких интерфейсов
- Расширение и реализация интерфейсов

### В [[js]]
JavaScript косвенно поддерживает интерфейсы через:
- Duck typing (если что-то ведет себя как утка, значит это утка)
- Библиотеки для проверки типов (JSDoc, Flow)
- Прототипное наследование

### В [[react]]
React использует интерфейсы:
- Props как интерфейсы для компонентов
- TypeScript интерфейсы для типизации компонентов
- Контекст как интерфейс для передачи данных

## Теги
#interfaces #oop #programming-concepts #design-principles #software-design #contracts