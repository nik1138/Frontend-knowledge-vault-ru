---
aliases: [Реактивность, Reactive Programming]
tags: [programming, frontend, javascript, paradigm]
---

# Реактивное программирование

**Реактивное программирование** — это парадигма программирования, ориентированная на потоки данных и распространение изменений. В этой парадигме приложение реагирует на изменения данных, событий или других источников, автоматически обновляя зависимые значения.

## Основные понятия

### Потоки данных (Data Streams)

В реактивном программировании все рассматривается как поток данных: события пользовательского интерфейса, HTTP-запросы, таймеры и т.д.

```javascript
// Пример потока данных с использованием RxJS
import { fromEvent, interval } from 'rxjs';
import { map, filter, debounceTime } from 'rxjs/operators';

// Поток событий клика
const clickStream = fromEvent(document, 'click');

// Поток с интервалом
const intervalStream = interval(1000);

// Комбинирование потоков
clickStream.pipe(
  map(event => ({ x: event.clientX, y: event.clientY })),
  filter(position => position.x > 100) // Фильтрация по координате
).subscribe(position => {
  console.log('Клик в позиции:', position);
});
```

### Реактивные переменные

В отличие от традиционных переменных, реактивные переменные автоматически обновляют все зависимости при изменении значения:

```javascript
// Пример с реактивным состоянием (на примере Vue.js)
import { reactive, computed } from 'vue';

const state = reactive({
  count: 0,
  name: 'Пользователь'
});

// Вычисляемое свойство, которое автоматически обновляется
const greeting = computed(() => `Привет, ${state.name}! Вы нажали ${state.count} раз`);

// При изменении state.count, greeting автоматически обновляется
state.count++;
console.log(greeting.value); // "Привет, Пользователь! Вы нажали 1 раз"
```

## Применение в фронтенд-разработке

### Реактивное управление состоянием

```javascript
// Пример реактивного хранения и обновления данных
class ReactiveStore {
  constructor(initialState = {}) {
    this.state = this.makeReactive(initialState);
    this.watchers = [];
  }
  
  makeReactive(obj) {
    return new Proxy(obj, {
      set: (target, property, value) => {
        const oldValue = target[property];
        target[property] = value;
        
        if (oldValue !== value) {
          this.notifyWatchers(property, value, oldValue);
        }
        
        return true;
      }
    });
  }
  
  watch(callback) {
    this.watchers.push(callback);
  }
  
  notifyWatchers(property, newValue, oldValue) {
    this.watchers.forEach(watcher => watcher(property, newValue, oldValue));
  }
  
  getState() {
    return this.state;
  }
}

// Использование
const store = new ReactiveStore({ count: 0, user: { name: 'Иван' } });

store.watch((property, newValue, oldValue) => {
  console.log(`Свойство ${property} изменилось с ${oldValue} на ${newValue}`);
});

store.state.count = 5; // Автоматически вызовет watcher
```

### Реактивные компоненты

```jsx
// Пример с React и хуками (реактивный подход)
import React, { useState, useEffect, useMemo } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Реактивное получение данных
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Ошибка загрузки пользователя:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]); // Реакция на изменение userId
  
  // Реактивное вычисление зависимых значений
  const userStatus = useMemo(() => {
    if (!user) return '';
    return user.active ? 'Активен' : 'Неактивен';
  }, [user]);
  
  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div>
      <h2>{user?.name}</h2>
      <p>Статус: {userStatus}</p>
    </div>
  );
}
```

### Обработка событий в реальном времени

```javascript
// Пример реактивной обработки событий формы
import { fromEvent } from 'rxjs';
import { map, filter, debounceTime, distinctUntilChanged } from 'rxjs/operators';

function setupFormReactivity() {
  const input = document.getElementById('search-input');
  const resultsContainer = document.getElementById('results');
  
  const input$ = fromEvent(input, 'input');
  
  input$.pipe(
    map(event => event.target.value),
    filter(value => value.length >= 3),
    debounceTime(300),
    distinctUntilChanged()
  ).subscribe(async searchTerm => {
    try {
      const results = await searchAPI(searchTerm);
      displayResults(results);
    } catch (error) {
      console.error('Ошибка поиска:', error);
    }
  });
}
```

## Преимущества в фронтенде

- **Автоматическое обновление UI**: изменения данных автоматически отражаются в интерфейсе
- **Уменьшение boilerplate кода**: не нужно вручную обновлять DOM при изменении данных
- **Лучшая производительность**: обновления происходят только при необходимости
- **Простота сложной логики**: реактивные паттерны упрощают обработку сложных зависимостей

## Инструменты и библиотеки

### RxJS (Reactive Extensions for JavaScript)

```javascript
import { Observable, Subject } from 'rxjs';
import { map, filter, switchMap, catchError } from 'rxjs/operators';

// Создание пользовательского потока
const dataStream = new Subject();

// Обработка потока данных
dataStream.pipe(
  filter(data => data.type === 'USER_UPDATE'),
  map(data => data.payload),
  switchMap(user => fetchUserDetails(user.id)),
  catchError(error => {
    console.error('Ошибка обработки данных:', error);
    return of(null);
  })
).subscribe(userDetails => {
  updateUI(userDetails);
});
```

### MobX (альтернатива Redux)

```javascript
import { makeObservable, observable, action, computed } from 'mobx';

class TodoStore {
  todos = [];
  
  constructor() {
    makeObservable(this, {
      todos: observable,
      completedCount: computed,
      addTodo: action,
      removeTodo: action
    });
  }
  
  get completedCount() {
    return this.todos.filter(todo => todo.completed).length;
  }
  
  addTodo(text) {
    this.todos.push({
      id: Date.now(),
      text,
      completed: false
    });
  }
  
  removeTodo(id) {
    this.todos = this.todos.filter(todo => todo.id !== id);
  }
}
```

## Связанные концепции

- [[Потоки данных]] - основа реактивного программирования
- [[Управление состоянием]] - реактивные подходы к управлению состоянием
- [[Асинхронное программирование]] - часто используется в реактивных системах
- [[Декларативное программирование]] - связанная парадигма
- [[Иммутабельность]] - часто используется в реактивных системах
- [[Компонентный-подход]] - реактивность в компонентных архитектурах

## Лучшие практики

1. **Избегайте чрезмерной реактивности** - не все данные должны быть реактивными
2. **Управление производительностью** - используйте debounce и throttle для частых событий
3. **Очистка подписок** - избегайте утечек памяти
4. **Ясные зависимости** - четко определяйте, какие данные зависят от каких
5. **Избегайте циклических зависимостей** - они могут привести к бесконечным циклам обновлений

## Заключение

Реактивное программирование особенно эффективно в фронтенд-разработке, где интерфейс должен постоянно реагировать на изменения данных и пользовательские действия. Понимание реактивных паттернов позволяет создавать более отзывчивые и поддерживаемые веб-приложения.