---
aliases: ["React Hooks", "Frontend Hooks", "Hooks в React", "Функциональные компоненты"]
tags: ["frontend", "react", "hooks", "javascript", "programming"]
---

# Хуки в Фронтенд-Разработке

## Обзор

Хуки (Hooks) — это особенность, появившаяся в React 16.8, которая позволяет использовать состояние и другие возможности React без написания классовых компонентов. Они позволяют повторно использовать логику состояния между компонентами и упрощают сложные компоненты.

## Основные понятия

Хуки — это функции, которые позволяют "подключиться" к React состоянию и методам жизненного цикла из функциональных компонентов. Они не работают внутри классов, но позволяют использовать React без классов.

> [!note] Важно
> Хуки не заменяют знание концепций React, они предоставляют более прямой API к тем же возможностям React.

## Стандартные хуки

### useState

`useState` — это хук, который позволяет добавить состояние в функциональные компоненты.

```javascript
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
```

В этом примере `useState` принимает начальное значение (0) и возвращает массив с двумя значениями: текущим состоянием и функцией для его обновления.

### useEffect

`useEffect` позволяет выполнять побочные эффекты в функциональных компонентах. Это объединяет методы жизненного цикла `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в один API.

```javascript
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Аналогично componentDidMount и componentDidUpdate
  useEffect(() => {
    // Обновляем заголовок документа с помощью API браузера
    document.title = `Вы нажали ${count} раз`;
  });

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
```

### useContext

`useContext` позволяет подписаться на React контекст без введения вложенности.

```javascript
import React, { useState, useContext } from 'react';

const ThemeContext = React.createContext();

function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      Я стилизован с помощью контекста!
    </button>
  );
}
```

### useReducer

`useReducer` — это альтернатива `useState`, которая подходит для сложной логики состояния, когда следующее состояние зависит от предыдущего.

```javascript
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <>
      Счет: {state.count}
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </>
  );
}
```

## Пользовательские хуки

Пользовательские хуки позволяют извлекать логику компонентов в повторно используемые функции.

```javascript
import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}

// Использование пользовательского хука
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'Онлайн' : 'Офлайн';
}
```

## Правила использования хуков

1. **Вызывайте хуки только на верхнем уровне** — не вызывайте хуки внутри циклов, условий или вложенных функций.
2. **Вызывайте хуки только из React функций** — не вызывайте хуки из обычных JavaScript функций.

## Продвинутые хуки

### useMemo

`useMemo` позволяет мемоизировать вычисления между рендерами, что может улучшить производительность.

```javascript
import React, { useMemo } from 'react';

function ExpensiveComponent({ items, multiplier }) {
  const expensiveValue = useMemo(() => {
    // Вычислительно сложная операция
    return items.map(item => item * multiplier).reduce((a, b) => a + b, 0);
  }, [items, multiplier]); // Зависимости

  return <div>{expensiveValue}</div>;
}
```

### useCallback

`useCallback` возвращает мемоизированную версию колбэка, который изменяется только при изменении одного из зависимостей.

```javascript
import React, { useCallback, useState } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);

  const memoizedCallback = useCallback(() => {
    console.log('Callback вызван');
    setCount(prevCount => prevCount + 1);
  }, []); // Пустой массив зависимостей означает, что колбэк не будет пересоздаваться

  return (
    <div>
      <p>Счет: {count}</p>
      <ChildComponent onClick={memoizedCallback} />
    </div>
  );
}
```

## Практические применения

Хуки особенно полезны для:

- [[Функциональные компоненты]] — позволяют использовать состояние и другие возможности React
- [[Состояние компонента]] — управление внутренним состоянием компонентов
- [[Побочные эффекты]] — выполнение операций после рендеринга
- [[Переиспользуемая логика]] — извлечение общей логики в пользовательские хуки
- [[Оптимизация производительности]] — с помощью `useMemo` и `useCallback`

## Популярные библиотеки хуков

- [[react-use]] — коллекция полезных хуков
- [[swr]] — хуки для получения данных
- [[react-query]] — хуки для управления серверным состоянием

## Заключение

Хуки значительно изменили подход к разработке на React, сделав код более читаемым и позволяя легче делиться логикой между компонентами. Они позволяют использовать преимущества функциональных компонентов при сохранении всей мощности React.

## См. также

- [[React]]
- [[Функциональные компоненты]]
- [[Состояние компонента]]
- [[Жизненный цикл компонентов]]
- [[Контекст в React]]
- [[Пользовательские хуки]]