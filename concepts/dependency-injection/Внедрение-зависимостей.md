---
tags: 
  - programming
  - architecture
  - design-patterns
  - dependency-injection
  - solid-principles
  - inversion-of-control
---

# Внедрение зависимостей (Dependency Injection)

## Введение

**Внедрение зависимостей (Dependency Injection, DI)** — это шаблон проектирования программного обеспечения, в котором один или несколько объектов (зависимостей) передаются в другой объект (клиент), чтобы клиент мог использовать эти зависимости. Это позволяет разорвать жесткие связи между компонентами и улучшить тестируемость, повторное использование и модульность кода.

DI является важным аспектом принципа инверсии зависимостей (Dependency Inversion Principle, DIP), одного из пяти принципов SOLID, и тесно связан с концепцией инверсии управления (Inversion of Control, IoC).

## Теоретическая основа

### Проблема, которую решает DI

Традиционный подход к созданию зависимостей внутри класса приводит к жесткой связанности (tight coupling):

```javascript
class UserService {
  constructor() {
    this.database = new DatabaseConnection(); // Жесткая связанность
  }
  
  getUser(id) {
    return this.database.findById(id);
  }
}
```

Такой подход создает несколько проблем:
- Классы трудно тестировать из-за невозможности подменить зависимости
- Сложно изменить реализацию зависимости без изменения клиентского кода
- Классы тесно связаны с конкретными реализациями

### Решение через DI

DI решает эти проблемы, позволяя внедрять зависимости извне:

```javascript
class UserService {
  constructor(database) {
    this.database = database; // Зависимость внедряется извне
  }
  
  getUser(id) {
    return this.database.findById(id);
  }
}
```

## Принципы и преимущества

### Основные принципы

1. **Разделение ответственности**: клиент не отвечает за создание своих зависимостей
2. **Инверсия управления**: управление зависимостями передается внешнему механизму
3. **Абстракция**: зависимости часто реализуются через интерфейсы или абстракции

### Преимущества DI

- **Улучшенная тестируемость**: легко подставлять мок-объекты для тестирования
- **Повышенная гибкость**: возможность легко изменять реализации зависимостей
- **Повторное использование**: компоненты становятся более универсальными
- **Упрощение управления жизненным циклом**: централизованное управление объектами
- **Снижение связанности**: уменьшение зависимости между компонентами

## Паттерны внедрения зависимостей

Существует три основных способа внедрения зависимостей:

### 1. Внедрение через конструктор (Constructor Injection)

Наиболее распространенный и предпочтительный способ:

```javascript
class EmailService {
  constructor(smtpConfig) {
    this.smtpConfig = smtpConfig;
  }
  
  sendEmail(to, message) {
    // Отправка email с использованием smtpConfig
  }
}

class UserService {
  constructor(emailService) {
    this.emailService = emailService;
  }
  
  registerUser(userData) {
    // Регистрация пользователя
    this.emailService.sendEmail(userData.email, 'Welcome!');
  }
}

// Использование
const emailService = new EmailService(smtpConfig);
const userService = new UserService(emailService);
```

### 2. Внедрение через свойство (Property Injection)

Используется, когда зависимость не обязательна или может изменяться в процессе работы:

```javascript
class OrderProcessor {
  constructor() {
    // Необязательная зависимость
    this.logger = null;
  }
  
  setLogger(logger) {
    this.logger = logger;
  }
  
  processOrder(order) {
    if (this.logger) {
      this.logger.log(`Processing order ${order.id}`);
    }
    // Обработка заказа
  }
}
```

### 3. Внедрение через метод (Method Injection)

Зависимость внедряется через метод в момент использования:

```javascript
class ReportGenerator {
  generateReport(data, formatter) {
    // Использование переданного formatter
    return formatter.format(data);
  }
}
```

## Контейнеры внедрения зависимостей

Контейнеры DI автоматизируют процесс внедрения зависимостей:

### Ручное внедрение

```javascript
// Ручное создание зависимостей
const database = new DatabaseConnection(config);
const emailService = new EmailService(smtpConfig);
const userService = new UserService(database, emailService);
const orderService = new OrderService(database, emailService);
```

### Контейнерная реализация

```javascript
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }
  
  register(name, factory, isSingleton = false) {
    this.services.set(name, { factory, isSingleton });
  }
  
  resolve(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }
    
    if (service.isSingleton) {
      if (!this.singletons.has(name)) {
        this.singletons.set(name, service.factory(this));
      }
      return this.singletons.get(name);
    }
    
    return service.factory(this);
  }
}

// Регистрация сервисов
const container = new DIContainer();
container.register('database', () => new DatabaseConnection(config));
container.register('emailService', (container) => 
  new EmailService(container.resolve('database'))
);
container.register('userService', (container) => 
  new UserService(container.resolve('database'), container.resolve('emailService'))
);

// Использование
const userService = container.resolve('userService');
```

## Связь с принципами SOLID

### Принцип инверсии зависимостей (DIP)

DI напрямую реализует DIP, позволяя зависеть от абстракций, а не от конкретных реализаций:

```javascript
// Плохо: зависимость от конкретной реализации
class UserService {
  constructor() {
    this.storage = new MySQLDatabase(); // Конкретная реализация
  }
}

// Хорошо: зависимость от абстракции
class UserService {
  constructor(database) {
    this.database = database; // Абстракция (интерфейс/протокол)
  }
}
```

## Практические примеры

### Пример на TypeScript с интерфейсами

```typescript
// Интерфейс репозитория
interface IUserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// Конкретная реализация
class MySQLUserRepository implements IUserRepository {
  async findById(id: string): Promise<User | null> {
    // Реализация для MySQL
  }
  
  async save(user: User): Promise<void> {
    // Сохранение в MySQL
  }
}

// Сервис, использующий репозиторий
class UserService {
  constructor(private userRepository: IUserRepository) {}
  
  async getUserProfile(userId: string) {
    const user = await this.userRepository.findById(userId);
    return user;
  }
}

// Использование
const userRepository = new MySQLUserRepository();
const userService = new UserService(userRepository);
```

## Сравнение с другими подходами

### Внедрение зависимостей vs Service Locator

| Характеристика | DI | Service Locator |
|----------------|----|-----------------|
| Прозрачность | Явные зависимости | Скрытые зависимости |
| Тестируемость | Высокая | Средняя |
| Связанность | Низкая | Высокая (клиент зависит от локатора) |
| Гибкость | Высокая | Средняя |

Service Locator создает скрытые зависимости, что затрудняет понимание структуры приложения.

## Заключение

Внедрение зависимостей — мощный шаблон проектирования, который способствует созданию гибких, тестируемых и поддерживаемых приложений. Он тесно связан с другими важными концепциями, такими как:

- [[Inversion of Control]] - более общая концепция, частью которой является DI
- [[SOLID Principles]] - особенно принцип инверсии зависимостей (DIP)
- [[Interfaces]] - обеспечивают абстракции, необходимые для DI
- [[Clean Architecture]] - активно использует DI для обеспечения независимости слоев
- [[Abstraction]] - ключевая концепция, лежащая в основе DI

Следующие статьи в этой серии охватывают более продвинутые темы:
- [[DI Patterns and Implementation]]
- [[Testing with Dependency Injection]]
- [[DI in Different Languages]]
