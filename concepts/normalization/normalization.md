# Нормализация в базах данных

## Определение нормализации

**Нормализация** — это процесс организации структуры базы данных для уменьшения избыточности данных и улучшения целостности. Это систематический подход к проектированию реляционных баз данных, при котором таблицы разбиваются на более мелкие и связанные таблицы, сохраняя при этом связи между ними.

Цель нормализации — исключить аномалии при вставке, обновлении и удалении данных, а также минимизировать дублирование информации. Нормализация помогает поддерживать согласованность данных и упрощает поддержку базы данных в долгосрочной перспективе.

## Нормальные формы

Существует несколько уровней нормализации, называемых нормальными формами. Каждая следующая нормальная форма накладывает более строгие требования на структуру таблицы.

### Первая нормальная форма (1NF)

Таблица находится в **первой нормальной форме (1NF)**, если:

- Все значения в ячейках атомарны (неделимы)
- В каждой ячейке только одно значение
- Порядок строк не имеет значения
- Каждая строка уникальна

**Пример нарушения 1NF:**
```sql
-- Ненормализованная таблица
CREATE TABLE students (
    id INT,
    name VARCHAR(100),
    courses VARCHAR(255) -- содержит список курсов
);
-- Пример строки: (1, "Иван Иванов", "Математика, Физика, Программирование")
```

**Пример исправления до 1NF:**
```sql
-- Нормализованная таблица
CREATE TABLE student_courses (
    student_id INT,
    course_name VARCHAR(100)
);
-- Строки: (1, "Математика"), (1, "Физика"), (1, "Программирование")
```

### Вторая нормальная форма (2NF)

Таблица находится во **второй нормальной форме (2NF)**, если:

- Она находится в 1NF
- Все неключевые атрибуты полностью функционально зависят от первичного ключа (а не от его части)

**Пример нарушения 2NF:**
```sql
-- Ненормализованная таблица
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    customer_name VARCHAR(100), -- зависит только от order_id, а не от (order_id, product_id)
    product_price DECIMAL(10,2),
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

**Пример исправления до 2NF:**
```sql
-- Разделение на две таблицы
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_name VARCHAR(100)
);

CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    product_price DECIMAL(10,2),
    quantity INT,
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);
```

### Третья нормальная форма (3NF)

Таблица находится в **третьей нормальной форме (3NF)**, если:

- Она находится в 2NF
- Все неключевые атрибуты не транзитивно зависят от первичного ключа

**Пример нарушения 3NF:**
```sql
-- Ненормализованная таблица
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100),
    dept_id INT,
    dept_name VARCHAR(100), -- зависит от dept_id, а не напрямую от emp_id
    dept_manager VARCHAR(100) -- зависит от dept_id, а не напрямую от emp_id
);
```

**Пример исправления до 3NF:**
```sql
-- Разделение на две таблицы
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(100),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(100),
    dept_manager VARCHAR(100)
);
```

### Нормальная форма Бойса-Кодда (BCNF)

**Нормальная форма Бойса-Кодда (BCNF)** — это усиленная версия 3NF. Таблица находится в BCNF, если:

- Она находится в 3NF
- Для каждой нетривиальной функциональной зависимости X → Y, X является суперключом

**Пример:**
```sql
-- Таблица с нарушением BCNF
CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    instructor VARCHAR(100),
    PRIMARY KEY (student_id, course_id),
    -- Если каждый курс всегда читается одним преподавателем,
    -- то course_id → instructor, но course_id не является суперключом
);

-- Исправление:
CREATE TABLE course_instructors (
    course_id INT PRIMARY KEY,
    instructor VARCHAR(100)
);

CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (course_id) REFERENCES course_instructors(course_id)
);
```

## Функциональные зависимости

**Функциональная зависимость** — это отношение между атрибутами, при котором значение одного атрибута (или набора атрибутов) определяет значение другого атрибута.

Если A → B, это означает, что для каждого значения A существует только одно возможное значение B.

**Примеры:**
- employee_id → employee_name (ID сотрудника определяет его имя)
- social_security_number → person_name (номер социального страхования определяет имя человека)

Функциональные зависимости являются основой для определения нормальных форм и помогают выявить потенциальные проблемы в структуре базы данных.

## Аномалии в ненормализованных данных

Ненормализованные данные могут привести к трем основным типам аномалий:

### Аномалия вставки

Невозможно вставить данные без ввода дополнительной информации, которая может быть недоступна.

**Пример:** Невозможно добавить новый курс в базу данных, если нет студентов, записавшихся на него.

### Аномалия обновления

Обновление данных в одном месте требует обновления в нескольких местах, что может привести к несогласованности.

**Пример:** Изменение имени преподавателя требует обновления всех записей, связанных с этим преподавателем.

### Аномалия удаления

Удаление данных может привести к потере информации, которая не должна быть удалена.

**Пример:** Удаление последнего студента, записавшегося на курс, может привести к удалению информации о курсе.

## Преимущества нормализации

1. **Сокращение избыточности данных** — уменьшается объем дублирующихся данных
2. **Повышение согласованности** — изменения в одном месте автоматически распространяются на все связанные данные
3. **Улучшение целостности данных** — снижается риск возникновения противоречий
4. **Легкость обслуживания** — обновление структуры базы данных становится проще
5. **Экономия места** — уменьшение дублирования снижает требования к хранилищу

## Денормализация: компромиссы и применение

**Денормализация** — это процесс преднамеренного введения избыточности в нормализованную базу данных для повышения производительности.

### Когда использовать денормализацию:

- При высоких требованиях к производительности запросов
- Для аналитических систем (OLAP)
- Когда операции чтения происходят чаще, чем операции записи
- При сложных запросах с множественными соединениями

### Компромиссы:

- Увеличение избыточности данных
- Повышенный риск нарушения целостности данных
- Более сложное обслуживание
- Потенциальные аномалии обновления

**Пример денормализации:**
```sql
-- Нормализованная структура
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    city VARCHAR(50)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- Денормализованная версия для ускорения отчетов
CREATE TABLE orders_with_customer (
    order_id INT PRIMARY KEY,
    customer_id INT,
    customer_name VARCHAR(100), -- дублирование для избежания JOIN
    customer_city VARCHAR(50),  -- дублирование для избежания JOIN
    order_date DATE,
    total_amount DECIMAL(10,2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

## Нормализация в документных базах данных

В отличие от реляционных баз данных, документные базы данных (например, MongoDB) имеют другие подходы к нормализации:

### Встраивание (Embedding)
- Хранение связанных данных в одном документе
- Подходит для отношений "один ко многим" или "многие к одному"
- Повышает производительность чтения

```json
{
  "_id": "order123",
  "customer": {
    "name": "Иван Иванов",
    "email": "ivan@example.com"
  },
  "items": [
    {
      "product": "Ноутбук",
      "quantity": 1,
      "price": 50000
    }
  ],
  "order_date": "2023-01-15"
}
```

### Ссылки (Referencing)
- Хранение идентификаторов связанных документов
- Подходит для отношений "многие ко многим"
- Сохраняет нормализацию данных

```json
{
  "_id": "order123",
  "customer_id": "customer456",
  "item_ids": ["item789", "item012"],
  "order_date": "2023-01-15"
}
```

Выбор между встраиванием и ссылками зависит от:
- Паттернов доступа к данным
- Частоты операций чтения и записи
- Требований к целостности данных

## Практические примеры

### Пример нормализации базы данных университета

**Исходная таблица (ненормализованная):**
```sql
CREATE TABLE university_schedule (
    student_id INT,
    student_name VARCHAR(100),
    student_major VARCHAR(50),
    course_code VARCHAR(10),
    course_name VARCHAR(100),
    instructor_name VARCHAR(100),
    classroom VARCHAR(20),
    schedule_time VARCHAR(20)
);
```

**Результат нормализации:**
```sql
-- Студенты
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100),
    major VARCHAR(50)
);

-- Курсы
CREATE TABLE courses (
    course_code VARCHAR(10) PRIMARY KEY,
    name VARCHAR(100),
    instructor_name VARCHAR(100)
);

-- Расписание
CREATE TABLE schedules (
    schedule_id INT PRIMARY KEY,
    course_code VARCHAR(10),
    classroom VARCHAR(20),
    schedule_time VARCHAR(20),
    FOREIGN KEY (course_code) REFERENCES courses(course_code)
);

-- Запись студентов на курсы
CREATE TABLE enrollments (
    student_id INT,
    schedule_id INT,
    PRIMARY KEY (student_id, schedule_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (schedule_id) REFERENCES schedules(schedule_id)
);
```

## Связи с другими концепциями

Нормализация тесно связана с другими концепциями программирования:

- [[data-structures]] - выбор структуры данных влияет на нормализацию
- [[database-design]] - нормализация является ключевым аспектом проектирования баз данных
- [[performance-optimization]] - баланс между нормализацией и производительностью
- [[separation-of-concerns]] - нормализация способствует разделению ответственности в данных
- [[modularity]] - нормализованные таблицы создают более модульную структуру

## Заключение

Нормализация — это важный процесс в проектировании баз данных, который помогает устранить избыточность и обеспечить целостность данных. Понимание нормальных форм и функциональных зависимостей позволяет создавать более надежные и эффективные системы хранения данных. Однако важно помнить, что нормализация не всегда является оптимальным решением, и в некоторых случаях денормализация может быть оправдана для повышения производительности.

> [!tip] Практический совет
> Начинайте с нормализованной структуры, а затем при необходимости вносите денормализацию для оптимизации производительности. Это позволяет сохранить преимущества нормализации при достижении требуемых характеристик производительности.

> [!warning] Важно
> Нормализация до BCNF не всегда возможна без потерь, особенно при наличии сложных ограничений. В таких случаях необходимо найти компромисс между нормализацией и функциональностью системы.

#database #normalization #data-structures #database-design #performance-optimization