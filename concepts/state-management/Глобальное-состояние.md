---
aliases: [глобальное состояние, global state, global state management]
tags: [frontend, state-management, architecture, react, vue, angular]
---

# Глобальное состояние

Глобальное состояние - это централизованное хранилище данных приложения, доступное для всех компонентов. Оно позволяет избежать передачи props на несколько уровней вложенности (prop drilling) и обеспечивает согласованность данных по всему приложению.

## Основные понятия

Глобальное состояние представляет собой **единственный источник правды** (single source of truth) для данных, которые используются несколькими компонентами приложения. В отличие от локального состояния компонента, глобальное состояние доступно из любого места приложения.

### Когда использовать глобальное состояние?

- Когда данные используются несколькими компонентами
- Когда состояние должно сохраняться между навигацией
- Когда необходимо синхронизировать данные между разными частями приложения
- Когда требуется централизованное управление сложными бизнес-логиками

> [!note] Примечание
> Не все данные должны быть в глобальном состоянии. Локальное состояние компонента остается предпочтительным для данных, используемых только внутри одного компонента.

## Архитектура глобального состояния

Глобальное состояние обычно состоит из следующих элементов:

- **Хранилище** (store) - центральное место хранения данных
- **Селекторы** (selectors) - функции для получения части состояния
- **Мутаторы** (mutators) - функции для изменения состояния
- **Подписчики** (subscribers) - компоненты, отслеживающие изменения состояния

## Реализации в популярных фреймворках

### React

В React для управления глобальным состоянием используются различные библиотеки:

#### Redux

```javascript
// store.js
import { configureStore } from '@reduxjs/toolkit'
import userReducer from './userSlice'
import postsReducer from './postsSlice'

export const store = configureStore({
  reducer: {
    user: userReducer,
    posts: postsReducer,
  },
})

// userSlice.js
import { createSlice } from '@reduxjs/toolkit'

const userSlice = createSlice({
  name: 'user',
  initialState: {
    id: null,
    name: '',
    email: '',
    isLoggedIn: false,
  },
  reducers: {
    login: (state, action) => {
      state.id = action.payload.id
      state.name = action.payload.name
      state.email = action.payload.email
      state.isLoggedIn = true
    },
    logout: (state) => {
      state.id = null
      state.name = ''
      state.email = ''
      state.isLoggedIn = false
    },
  },
})

export const { login, logout } = userSlice.actions
export default userSlice.reducer
```

#### Zustand

```javascript
// store/useUserStore.js
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

const useUserStore = create(
  devtools((set, get) => ({
    user: null,
    isLoggedIn: false,
    
    login: (userData) => 
      set({ user: userData, isLoggedIn: true }, false, 'user/login'),
    
    logout: () => 
      set({ user: null, isLoggedIn: false }, false, 'user/logout'),
    
    updateUser: (newData) => 
      set((state) => ({ 
        user: { ...state.user, ...newData } 
      }), false, 'user/update'),
  }))
)

export default useUserStore
```

#### Context API

```javascript
// context/UserContext.js
import React, { createContext, useContext, useReducer } from 'react'

const UserContext = createContext()

const userReducer = (state, action) => {
  switch (action.type) {
    case 'LOGIN':
      return {
        ...state,
        user: action.payload,
        isLoggedIn: true,
      }
    case 'LOGOUT':
      return {
        ...state,
        user: null,
        isLoggedIn: false,
      }
    default:
      return state
  }
}

export const UserProvider = ({ children }) => {
  const [state, dispatch] = useReducer(userReducer, {
    user: null,
    isLoggedIn: false,
  })

  return (
    <UserContext.Provider value={{ state, dispatch }}>
      {children}
    </UserContext.Provider>
  )
}

export const useUser = () => {
  const context = useContext(UserContext)
  if (!context) {
    throw new Error('useUser must be used within a UserProvider')
  }
  return context
}
```

### Vue.js

В Vue.js глобальное состояние можно реализовать с помощью Pinia или Vuex:

#### Pinia

```javascript
// stores/user.js
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    user: null,
    isLoggedIn: false,
  }),

  getters: {
    fullName: (state) => {
      return state.user ? `${state.user.firstName} ${state.user.lastName}` : ''
    },
    isAuthenticated: (state) => {
      return state.isLoggedIn && !!state.user
    },
  },

  actions: {
    login(userData) {
      this.user = userData
      this.isLoggedIn = true
    },
    
    logout() {
      this.user = null
      this.isLoggedIn = false
    },
    
    updateProfile(updates) {
      if (this.user) {
        Object.assign(this.user, updates)
      }
    },
  },
  
  // Persisting state in localStorage
  persist: {
    key: 'user-info',
    storage: localStorage,
  },
})
```

### Angular

В Angular для управления глобальным состоянием используется NgRx:

```typescript
// store/user.actions.ts
import { createAction, props } from '@ngrx/store';

export const login = createAction(
  '[Auth] Login',
  props<{ user: any }>()
);

export const logout = createAction('[Auth] Logout');

// store/user.reducer.ts
import { createReducer, on } from '@ngrx/store';
import { login, logout } from './user.actions';

export interface UserState {
  user: any | null;
  isLoggedIn: boolean;
}

const initialState: UserState = {
  user: null,
  isLoggedIn: false,
};

export const userReducer = createReducer(
  initialState,
  on(login, (state, { user }) => ({
    ...state,
    user,
    isLoggedIn: true,
  })),
  on(logout, (state) => ({
    ...state,
    user: null,
    isLoggedIn: false,
  }))
);
```

## Лучшие практики

### 1. Нормализация данных

Для эффективного управления глобальным состоянием рекомендуется нормализовать данные:

```javascript
// Плохо: дублирование данных
const badState = {
  posts: [
    { id: 1, title: 'Post 1', author: { id: 1, name: 'John' } },
    { id: 2, title: 'Post 2', author: { id: 1, name: 'John' } }, // дублирование автора
  ],
}

// Хорошо: нормализованные данные
const goodState = {
  posts: {
    1: { id: 1, title: 'Post 1', authorId: 1 },
    2: { id: 2, title: 'Post 2', authorId: 1 },
  },
  authors: {
    1: { id: 1, name: 'John' },
  },
  postIds: [1, 2],
}
```

### 2. Иммутабельность

Всегда создавайте новые объекты при изменении состояния:

```javascript
// Плохо: мутация существующего состояния
state.items.push(newItem)

// Хорошо: создание нового состояния
state.items = [...state.items, newItem]
```

### 3. Селекторы

Используйте селекторы для вычисления производных данных:

```javascript
// selectors/userSelectors.js
export const selectCurrentUser = (state) => state.user.user;
export const selectIsLoggedIn = (state) => state.user.isLoggedIn;
export const selectUserPermissions = (state) => {
  const user = selectCurrentUser(state);
  return user ? user.permissions || [] : [];
};

// Использование useMemo для оптимизации
const currentUser = useSelector(selectCurrentUser);
const permissions = useSelector(selectUserPermissions);
```

## Преимущества и недостатки

### Преимущества

- **Централизованное управление**: все данные в одном месте
- **Предсказуемость**: легче отлаживать и тестировать
- **Повторное использование**: компоненты могут использовать одни и те же данные
- **Синхронизация**: изменения в одном месте отражаются везде

### Недостатки

- **Сложность**: увеличение архитектурной сложности
- **Производительность**: потенциальные проблемы с производительностью при неправильном использовании
- **Переинжиниринг**: избыточное усложнение для простых приложений

## Интеграция с [[state|локальным состоянием]]

Глобальное и локальное состояния должны работать вместе. Глобальное состояние используется для данных, разделяемых между компонентами, а локальное - для данных, специфичных для конкретного компонента.

## Связанные концепции

- [[state]] - основное понятие состояния
- [[Паттерны-состояния]] - шаблоны управления состоянием
- [[advanced-state-management-patterns]] - продвинутые паттерны
- [[advanced-state-architecture]] - архитектурные подходы