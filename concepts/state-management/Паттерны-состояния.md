---
aliases: [паттерны состояния, state patterns, state management patterns]
tags: [frontend, state-management, architecture, patterns, react, vue, angular]
---

# Паттерны состояния

Паттерны управления состоянием - это проверенные временем подходы к организации, изменениям и отслеживанию состояния приложения. Они помогают создавать масштабируемые, поддерживаемые и предсказуемые приложения.

## Основные паттерны

### 1. Паттерн "Хранилище" (Store Pattern)

Этот паттерн предполагает централизованное хранение состояния в одном или нескольких хранилищах.

#### Реализация в React с использованием Context API

```javascript
// context/AppStore.js
import React, { createContext, useContext, useReducer } from 'react';

// Определение начального состояния
const initialState = {
  user: null,
  theme: 'light',
  notifications: [],
};

// Определение редьюсера
const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'ADD_NOTIFICATION':
      return { 
        ...state, 
        notifications: [...state.notifications, action.payload] 
      };
    case 'REMOVE_NOTIFICATION':
      return { 
        ...state, 
        notifications: state.notifications.filter(n => n.id !== action.payload) 
      };
    default:
      return state;
  }
};

// Создание контекста
const AppStoreContext = createContext();

// Провайдер хранилища
export const AppStoreProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <AppStoreContext.Provider value={{ state, dispatch }}>
      {children}
    </AppStoreContext.Provider>
  );
};

// Хук для использования хранилища
export const useAppStore = () => {
  const context = useContext(AppStoreContext);
  if (!context) {
    throw new Error('useAppStore must be used within AppStoreProvider');
  }
  return context;
};
```

### 2. Паттерн "Наблюдатель" (Observer Pattern)

Паттерн Observer позволяет объектам подписываться на изменения состояния и получать уведомления при их изменении.

```javascript
// utils/Observer.js
class StateObserver {
  constructor() {
    this.observers = new Map();
  }

  subscribe(event, callback) {
    if (!this.observers.has(event)) {
      this.observers.set(event, []);
    }
    this.observers.get(event).push(callback);
    return () => this.unsubscribe(event, callback);
  }

  unsubscribe(event, callback) {
    const eventObservers = this.observers.get(event);
    if (eventObservers) {
      const index = eventObservers.indexOf(callback);
      if (index > -1) {
        eventObservers.splice(index, 1);
      }
    }
  }

  notify(event, data) {
    const eventObservers = this.observers.get(event);
    if (eventObservers) {
      eventObservers.forEach(callback => callback(data));
    }
  }
}

// Использование
const stateObserver = new StateObserver();

// Подписка на изменения
const unsubscribe = stateObserver.subscribe('userChanged', (user) => {
  console.log('User updated:', user);
});

// Уведомление об изменении
stateObserver.notify('userChanged', { id: 1, name: 'John' });

// Отписка
unsubscribe();
```

### 3. Паттерн "Фабрика состояния" (State Factory Pattern)

Этот паттерн позволяет создавать экземпляры состояния с определенными свойствами и методами.

```javascript
// utils/StateFactory.js
class StateFactory {
  static createUserState(userData = {}) {
    return {
      data: {
        id: userData.id || null,
        name: userData.name || '',
        email: userData.email || '',
        ...userData,
      },
      isLoading: false,
      error: null,
      
      // Методы для изменения состояния
      setLoading: function(loading) {
        this.isLoading = loading;
        return { ...this };
      },
      
      setError: function(error) {
        this.error = error;
        this.isLoading = false;
        return { ...this };
      },
      
      updateData: function(newData) {
        this.data = { ...this.data, ...newData };
        this.error = null;
        return { ...this };
      },
    };
  }
  
  static createListState(items = []) {
    return {
      items,
      loading: false,
      error: null,
      filters: {},
      pagination: { page: 1, limit: 10, total: 0 },
      
      addItems: function(newItems) {
        this.items = [...this.items, ...newItems];
        return { ...this };
      },
      
      removeItem: function(id) {
        this.items = this.items.filter(item => item.id !== id);
        return { ...this };
      },
    };
  }
}

// Использование
const userState = StateFactory.createUserState({ id: 1, name: 'John' });
const listState = StateFactory.createListState([{ id: 1, name: 'Item 1' }]);
```

### 4. Паттерн "Контейнер-представление" (Container-Presenter Pattern)

Этот паттерн разделяет компоненты на контейнеры (управление состоянием) и презентационные компоненты (отображение данных).

```javascript
// containers/UserContainer.js
import React, { useEffect } from 'react';
import { useAppStore } from '../context/AppStore';
import UserProfile from '../components/UserProfile';

const UserContainer = () => {
  const { state, dispatch } = useAppStore();

  useEffect(() => {
    // Загрузка данных пользователя при монтировании
    const fetchUser = async () => {
      try {
        dispatch({ type: 'SET_LOADING', payload: true });
        const user = await fetch('/api/user').then(res => res.json());
        dispatch({ type: 'SET_USER', payload: user });
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: error.message });
      } finally {
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    };

    fetchUser();
  }, [dispatch]);

  return <UserProfile user={state.user} loading={state.loading} error={state.error} />;
};

// components/UserProfile.js
import React from 'react';

const UserProfile = ({ user, loading, error }) => {
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>No user data</div>;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
};

export default UserProfile;
export { UserContainer };
```

### 5. Паттерн "Фасад состояния" (State Facade Pattern)

Фасад предоставляет упрощенный интерфейс для сложной системы управления состоянием.

```javascript
// services/StateFacade.js
import { useAppStore } from '../context/AppStore';

class UserFacade {
  constructor(store) {
    this.store = store;
  }

  async login(credentials) {
    try {
      this.store.dispatch({ type: 'SET_LOADING', payload: true });
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      });
      
      if (!response.ok) throw new Error('Login failed');
      
      const user = await response.json();
      this.store.dispatch({ type: 'SET_USER', payload: user });
      return user;
    } catch (error) {
      this.store.dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    } finally {
      this.store.dispatch({ type: 'SET_LOADING', payload: false });
    }
  }

  logout() {
    this.store.dispatch({ type: 'LOGOUT' });
  }

  getCurrentUser() {
    return this.store.state.user;
  }

  isAuthenticated() {
    return !!this.store.state.user;
  }
}

// Хук для использования фасада
export const useUserFacade = () => {
  const store = useAppStore();
  return new UserFacade(store);
};
```

## Паттерны для асинхронного состояния

### 1. Паттерн "Загрузка-Данные-Ошибка" (Loading-Data-Error)

```javascript
// hooks/useAsyncState.js
import { useState, useEffect } from 'react';

const useAsyncState = (asyncFunction, dependencies = []) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true;

    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const result = await asyncFunction();
        
        if (isMounted) {
          setData(result);
        }
      } catch (err) {
        if (isMounted) {
          setError(err.message);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      isMounted = false;
    };
  }, dependencies);

  return { data, loading, error, refetch: () => fetchData() };
};

// Использование
const UserProfile = () => {
  const { data: user, loading, error } = useAsyncState(
    () => fetch('/api/user').then(res => res.json()),
    []
  );

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
};
```

### 2. Паттерн "Оптимистичное обновление" (Optimistic Update)

```javascript
// utils/OptimisticUpdate.js
class OptimisticUpdate {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.backupStates = new Map();
  }

  async update(resource, updateFn, optimisticUpdateFn) {
    const resourceId = resource.id || resource._id;
    
    // Сохраняем резервную копию
    this.backupStates.set(resourceId, { ...resource });
    
    // Оптимистично обновляем состояние
    if (optimisticUpdateFn) {
      optimisticUpdateFn();
    }
    
    try {
      // Выполняем реальное обновление
      const updatedResource = await updateFn();
      return updatedResource;
    } catch (error) {
      // Восстанавливаем состояние при ошибке
      if (this.backupStates.has(resourceId)) {
        const backup = this.backupStates.get(resourceId);
        // Восстанавливаем резервное состояние
        this.stateManager.updateResource(resourceId, backup);
        this.backupStates.delete(resourceId);
      }
      throw error;
    } finally {
      this.backupStates.delete(resourceId);
    }
  }
}
```

## Паттерны для сложных форм

### 1. Паттерн "Форма с валидацией" (Validated Form Pattern)

```javascript
// hooks/useValidatedForm.js
import { useState, useCallback } from 'react';

const useValidatedForm = (initialValues, validationRules) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const validateField = useCallback((name, value) => {
    const rules = validationRules[name];
    if (!rules) return '';

    for (const rule of rules) {
      const error = rule(value);
      if (error) return error;
    }
    return '';
  }, [validationRules]);

  const handleChange = useCallback((name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    if (touched[name]) {
      const error = validateField(name, value);
      setErrors(prev => ({ ...prev, [name]: error }));
    }
  }, [touched, validateField]);

  const handleBlur = useCallback((name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    const error = validateField(name, values[name]);
    setErrors(prev => ({ ...prev, [name]: error }));
  }, [values, validateField]);

  const validateForm = useCallback(() => {
    const newErrors = {};
    let isValid = true;

    for (const [name, value] of Object.entries(values)) {
      const error = validateField(name, value);
      if (error) {
        newErrors[name] = error;
        isValid = false;
      }
    }

    setErrors(newErrors);
    return isValid;
  }, [values, validateField]);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    validateForm,
    reset,
    isValid: Object.keys(errors).length === 0 && Object.keys(touched).length > 0,
  };
};

// Использование
const validationRules = {
  email: [
    (value) => !value ? 'Email is required' : null,
    (value) => !/\S+@\S+\.\S+/.test(value) ? 'Email is invalid' : null,
  ],
  password: [
    (value) => !value ? 'Password is required' : null,
    (value) => value.length < 6 ? 'Password must be at least 6 characters' : null,
  ],
};

const LoginForm = () => {
  const { values, errors, handleChange, handleBlur, validateForm } = 
    useValidatedForm({ email: '', password: '' }, validationRules);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      // Отправка формы
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        value={values.email}
        onChange={(e) => handleChange('email', e.target.value)}
        onBlur={() => handleBlur('email')}
      />
      {errors.email && <span>{errors.email}</span>}
      
      <input
        name="password"
        type="password"
        value={values.password}
        onChange={(e) => handleChange('password', e.target.value)}
        onBlur={() => handleBlur('password')}
      />
      {errors.password && <span>{errors.password}</span>}
      
      <button type="submit">Login</button>
    </form>
  );
};
```

## Лучшие практики реализации паттернов

### 1. Согласованность

Используйте одинаковые паттерны во всем приложении для обеспечения согласованности и предсказуемости.

### 2. Тестируемость

Паттерны должны быть легко тестируемыми. Разделяйте логику и UI для лучшего тестирования.

### 3. Производительность

Выбирайте паттерны с учетом производительности. Избегайте ненужных перерисовок и оптимизируйте обновления состояния.

### 4. Масштабируемость

Паттерны должны масштабироваться с ростом приложения. Планируйте архитектуру с учетом будущих изменений.

## Интеграция с различными фреймворками

### React

- Используйте хуки для реализации паттернов
- Комбинируйте Context API с редьюсерами
- Используйте библиотеки типа Redux Toolkit или Zustand для сложных случаев

### Vue

- Используйте Pinia для управления состоянием
- Применяйте Composition API для сложной логики
- Используйте computed свойства для производных данных

### Angular

- Используйте NgRx для сложного управления состоянием
- Применяйте сервисы для инкапсуляции логики
- Используйте RxJS для реактивного программирования

## Связанные концепции

- [[state]] - основное понятие состояния
- [[Глобальное-состояние]] - централизованное управление состоянием
- [[advanced-state-management-patterns]] - продвинутые паттерны
- [[advanced-state-architecture]] - архитектурные подходы
- [[reactive-programming]] - реактивное программирование