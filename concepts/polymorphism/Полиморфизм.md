# Полиморфизм

Полиморфизм — это один из основных принципов объектно-ориентированного программирования, который позволяет объектам разных типов использовать один и тот же интерфейс. Слово "полиморфизм" происходит от греческого "поли" (много) и "морф" (форма), что означает "много форм". Полиморфизм позволяет одной и той же операции работать с объектами разных типов.

## Основные характеристики полиморфизма

### Единый интерфейс
Разные классы могут реализовывать один и тот же интерфейс или наследовать от одного базового класса.

### Различная реализация
Каждый класс может по-своему реализовывать методы интерфейса или переопределять методы базового класса.

### Динамическое связывание
Выбор конкретной реализации метода происходит во время выполнения программы.

## Типы полиморфизма

### Ад-хок полиморфизм (Перегрузка)
Один интерфейс может работать с разными типами данных.

### Параметрический полиморфизм (Дженерики)
Функции или классы могут работать с любыми типами данных без знания конкретного типа.

### Подтипный полиморфизм (Наследование)
Объекты подтипов могут использоваться вместо объектов базового типа.

## Примеры полиморфизма

### В JavaScript
```javascript
// Подтипный полиморфизм в JavaScript
class Shape {
  getArea() {
    throw new Error('Метод getArea должен быть реализован');
  }
  
  getType() {
    return 'Фигура';
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  // Переопределение метода родительского класса
  getArea() {
    return this.width * this.height;
  }
  
  getType() {
    return 'Прямоугольник';
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  // Переопределение метода родительского класса
  getArea() {
    return Math.PI * this.radius * this.radius;
  }
  
  getType() {
    return 'Круг';
  }
}

class Triangle extends Shape {
  constructor(base, height) {
    super();
    this.base = base;
    this.height = height;
  }
  
  // Переопределение метода родительского класса
  getArea() {
    return 0.5 * this.base * this.height;
  }
  
  getType() {
    return 'Треугольник';
  }
}

// Полиморфное использование
function printShapeInfo(shape) {
  // Один интерфейс для разных типов
  console.log(`${shape.getType()}: площадь = ${shape.getArea()}`);
}

const shapes = [
  new Rectangle(5, 3),
  new Circle(4),
  new Triangle(6, 4)
];

// Полиморфное поведение
shapes.forEach(shape => printShapeInfo(shape));
// Прямоугольник: площадь = 15
// Круг: площадь = 50.26548245743669
// Треугольник: площадь = 12
```

### В TypeScript
```typescript
// Полиморфизм в TypeScript
interface Drawable {
  draw(): void;
  getArea(): number;
}

class Rectangle implements Drawable {
  constructor(private width: number, private height: number) {}
  
  draw(): void {
    console.log(`Рисуем прямоугольник ${this.width}x${this.height}`);
  }
  
  getArea(): number {
    return this.width * this.height;
  }
}

class Circle implements Drawable {
  constructor(private radius: number) {}
  
  draw(): void {
    console.log(`Рисуем круг радиусом ${this.radius}`);
  }
  
  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class Triangle implements Drawable {
  constructor(private base: number, private height: number) {}
  
  draw(): void {
    console.log(`Рисуем треугольник с основанием ${this.base} и высотой ${this.height}`);
  }
  
  getArea(): number {
    return 0.5 * this.base * this.height;
  }
}

// Полиморфное использование через интерфейс
function renderShape(shape: Drawable): void {
  shape.draw(); // Полиморфный вызов
  console.log(`Площадь: ${shape.getArea()}`);
}

// Массив объектов разных типов с общим интерфейсом
const shapes: Drawable[] = [
  new Rectangle(10, 5),
  new Circle(3),
  new Triangle(8, 6)
];

// Полиморфное поведение
shapes.forEach(shape => renderShape(shape));
```

### Параметрический полиморфизм в TypeScript
```typescript
// Параметрический полиморфизм (дженерики)
class Container<T> {
  private value: T;
  
  constructor(value: T) {
    this.value = value;
  }
  
  getValue(): T {
    return this.value;
  }
  
  setValue(value: T): void {
    this.value = value;
  }
  
  getType(): string {
    return typeof this.value;
  }
}

// Один класс работает с разными типами
const stringContainer = new Container<string>('Привет');
const numberContainer = new Container<number>(42);
const booleanContainer = new Container<boolean>(true);

console.log(stringContainer.getValue()); // Привет
console.log(numberContainer.getValue()); // 42
console.log(booleanContainer.getValue()); // true

// Функция с параметрическим полиморфизмом
function identity<T>(arg: T): T {
  return arg;
}

// Одна функция работает с разными типами
const stringResult = identity<string>('Текст');
const numberResult = identity<number>(123);
const objectResult = identity<{name: string}>({name: 'Иван'});
```

## Преимущества полиморфизма

### Гибкость
Полиморфизм позволяет писать более гибкий и расширяемый код.

### Расширяемость
Новые типы могут быть легко добавлены без изменения существующего кода.

### Повторное использование кода
Общий код может работать с объектами разных типов.

### Упрощение интерфейсов
Полиморфизм позволяет создавать простые и понятные интерфейсы.

## Недостатки полиморфизма

### Сложность понимания
Для новичков полиморфизм может быть сложным для понимания.

### Накладные расходы
Динамическое связывание может добавить небольшие накладные расходы.

### Потенциальная неопределенность
Иногда сложно предсказать, какая реализация метода будет вызвана.

## Паттерны, использующие полиморфизм

### Стратегия (Strategy)
```javascript
// Стратегия использует полиморфизм
class PaymentStrategy {
  pay(amount) {
    throw new Error('Метод pay должен быть реализован');
  }
}

class CreditCardPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`Оплата ${amount} через кредитную карту`);
  }
}

class PayPalPayment extends PaymentStrategy {
  pay(amount) {
    console.log(`Оплата ${amount} через PayPal`);
  }
}

class PaymentProcessor {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  processPayment(amount) {
    // Полиморфный вызов - вызывается метод конкретной стратегии
    this.strategy.pay(amount);
  }
}

// Использование
const processor = new PaymentProcessor(new CreditCardPayment());
processor.processPayment(100); // Оплата 100 через кредитную карту

processor.setStrategy(new PayPalPayment());
processor.processPayment(200); // Оплата 200 через PayPal
```

### Команда (Command)
```javascript
// Команда использует полиморфизм
class Command {
  execute() {
    throw new Error('Метод execute должен быть реализован');
  }
}

class LightOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
}

class LightOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
}

class RemoteControl {
  setCommand(command) {
    this.command = command;
  }
  
  pressButton() {
    // Полиморфный вызов - вызывается метод конкретной команды
    this.command.execute();
  }
}
```

### Посетитель (Visitor)
```javascript
// Посетитель использует полиморфизм
class Visitor {
  visit(element) {
    throw new Error('Метод visit должен быть реализован');
  }
}

class XMLExportVisitor extends Visitor {
  visit(element) {
    console.log(`Экспорт ${element.name} в XML`);
  }
}

class JSONExportVisitor extends Visitor {
  visit(element) {
    console.log(`Экспорт ${element.name} в JSON`);
  }
}

class Element {
  accept(visitor) {
    // Полиморфный вызов - вызывается метод посетителя для конкретного элемента
    visitor.visit(this);
  }
}

class TextElement extends Element {
  constructor() {
    super();
    this.name = 'Текстовый элемент';
  }
}

class ImageElement extends Element {
  constructor() {
    super();
    this.name = 'Графический элемент';
  }
}
```

## Полиморфизм в функциональном программировании

Полиморфизм также применим в функциональном программировании:

```javascript
// Функциональный полиморфизм
const map = (fn, array) => {
  const result = [];
  for (let i = 0; i < array.length; i++) {
    result.push(fn(array[i])); // Полиморфный вызов функции
  }
  return result;
};

// Одна функция работает с разными функциями преобразования
const numbers = [1, 2, 3, 4, 5];

const doubled = map(x => x * 2, numbers); // Удвоение
const squared = map(x => x * x, numbers); // Возведение в квадрат
const strings = map(x => x.toString(), numbers); // Преобразование в строки

console.log(doubled); // [2, 4, 6, 8, 10]
console.log(squared); // [1, 4, 9, 16, 25]
console.log(strings); // ['1', '2', '3', '4', '5']
```

## Связь с другими концепциями

- [[Объектно-ориентированное программирование]] - Полиморфизм является одним из основных принципов ООП
- [[Наследование]] - Полиморфизм часто реализуется через наследование
- [[Интерфейсы]] - Интерфейсы обеспечивают основу для полиморфного поведения
- [[SOLID]] - Принцип подстановки Барбары Лисков (LSP) связан с полиморфизмом
- [[Паттерны проектирования]] - Многие паттерны используют полиморфизм
- [[Функциональное программирование]] - Полиморфизм применим и в функциональном стиле

## Применение в современных технологиях

### В [[ts]]
TypeScript поддерживает полиморфизм через:
- Интерфейсы и реализацию интерфейсов
- Наследование классов
- Дженерики для параметрического полиморфизма
- Union типы для ад-хок полиморфизма

### В [[js]]
JavaScript поддерживает полиморфизм через:
- Прототипное наследование
- Динамическую типизацию
- Функции высшего порядка

### В [[react]]
React использует полиморфизм:
- Компоненты как полиморфные элементы
- HOC (Higher Order Components) для полиморфного поведения
- Хуки для полиморфной логики

## Теги
#polymorphism #oop #programming-concepts #design-principles #software-design #functional-programming