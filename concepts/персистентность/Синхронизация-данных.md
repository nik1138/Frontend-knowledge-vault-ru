---
aliases: [Синхронизация данных, Data Synchronization]
tags: [frontend, persistence, synchronization, real-time, offline]
---

# Синхронизация данных

**Синхронизация данных** - это процесс обеспечения согласованности данных между различными хранилищами, устройствами или системами. В контексте веб-приложений это включает синхронизацию данных между клиентской и серверной частями, а также между различными устройствами пользователя.

## Основные понятия

### Типы синхронизации

1. **Односторонняя синхронизация** - данные передаются только в одном направлении
2. **Двусторонняя синхронизация** - данные синхронизируются в обоих направлениях
3. **Синхронизация в реальном времени** - изменения применяются немедленно
4. **Пакетная синхронизация** - изменения применяются периодически

### Проблемы синхронизации

- **Конфликты данных** - когда одна и та же запись изменяется в разных местах
- **Потерянные обновления** - когда одно обновление перезаписывает другое
- **Согласованность данных** - обеспечение целостности данных во всех источниках
- **Обработка оффлайн-изменений** - синхронизация изменений, сделанных без подключения

## Архитектура синхронизации

### Основные компоненты

1. **Клиентское хранилище** - LocalStorage, IndexedDB и т.д.
2. **Серверное хранилище** - база данных на сервере
3. **Механизм синхронизации** - логика синхронизации
4. **Очередь изменений** - для обработки оффлайн-действий
5. **Обработчик конфликтов** - разрешение конфликтов данных

## Реализация синхронизации

### Базовая синхронизация с сервером

```javascript
class DataSyncManager {
  constructor(серверныйAPI, локальноеХранилище) {
    this.серверныйAPI = серверныйAPI;
    this.локальноеХранилище = локальноеХранилище;
    this.очередьИзменений = [];
    this.настройки = {
      интервалСинхронизации: 30000, // 30 секунд
      максимальныйРазмерОчереди: 100
    };
  }
  
  async инициализировать() {
    // Загрузка данных при запуске
    await this.загрузитьДанныеССервера();
    
    // Запуск фоновой синхронизации
    this.запуститьФоновуюСинхронизацию();
  }
  
  async загрузитьДанныеССервера() {
    try {
      const данные = await this.серверныйAPI.получитьВсе();
      await this.локальноеХранилище.обновить(данные);
    } catch (ошибка) {
      console.error('Ошибка загрузки данных с сервера:', ошибка);
    }
  }
  
  async отправитьИзмененияНаСервер() {
    const изменения = await this.получитьОчередьИзменений();
    
    for (const изменение of изменения) {
      try {
        await this.серверныйAPI.применитьИзменение(изменение);
        await this.удалитьИзОчереди(изменение.id);
      } catch (ошибка) {
        console.error('Ошибка отправки изменения:', ошибка);
        // Возможно, нужно обработать конфликт
        await this.обработатьКонфликт(изменение, ошибка);
      }
    }
  }
  
  async получитьОчередьИзменений() {
    return this.локальноеХранилище.получить('очередь_изменений') || [];
  }
  
  async добавитьВОчередь(изменение) {
    const очередь = await this.получитьОчередьИзменений();
    
    // Добавляем ID и метку времени
    изменение.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    изменение.время = new Date().toISOString();
    
    очередь.push(изменение);
    
    // Ограничиваем размер очереди
    if (очередь.length > this.настройки.максимальныйРазмерОчереди) {
      очередь.shift(); // Удаляем самые старые изменения
    }
    
    await this.локальноеХранилище.установить('очередь_изменений', очередь);
  }
  
  async удалитьИзОчереди(id) {
    const очередь = await this.получитьОчередьИзменений();
    const индекс = очередь.findIndex(изменение => изменение.id === id);
    
    if (индекс !== -1) {
      очередь.splice(индекс, 1);
      await this.локальноеХранилище.установить('очередь_изменений', очередь);
    }
  }
  
  запуститьФоновуюСинхронизацию() {
    setInterval(async () => {
      if (this.естьПодключениеКСети()) {
        await this.отправитьИзмененияНаСервер();
      }
    }, this.настройки.интервалСинхронизации);
  }
  
  естьПодключениеКСети() {
    return navigator.onLine;
  }
  
  async обработатьКонфликт(изменение, ошибка) {
    // В простейшем случае - запрашиваем актуальные данные с сервера
    try {
      const актуальныеДанные = await this.серверныйAPI.получить(изменение.сущность, изменение.id);
      await this.локальноеХранилище.обновить(актуальныеДанные);
    } catch (ошибка) {
      console.error('Ошибка обработки конфликта:', ошибка);
    }
  }
}
```

### Синхронизация с оффлайн-поддержкой

```javascript
class OfflineSyncManager {
  constructor(серверныйAPI, локальноеХранилище) {
    this.серверныйAPI = серверныйAPI;
    this.локальноеХранилище = локальноеХранилище;
    this.события = new EventTarget();
  }
  
  async инициализировать() {
    // Отслеживание состояния сети
    window.addEventListener('online', () => this.обработатьОнлайн());
    window.addEventListener('offline', () => this.обработатьОффлайн());
    
    // Проверка начального состояния
    if (navigator.onLine) {
      await this.синхронизировать();
    }
  }
  
  async создать(сущность, данные) {
    const запись = {
      ...данные,
      id: this.генерироватьID(),
      времяСоздания: new Date().toISOString(),
      синхронизирована: false
    };
    
    // Сохраняем локально
    await this.локальноеХранилище.добавить(сущность, запись);
    
    // Добавляем в очередь синхронизации
    await this.добавитьВОчередь({
      тип: 'создать',
      сущность: сущность,
      данные: запись
    });
    
    // Если онлайн - сразу синхронизируем
    if (navigator.onLine) {
      await this.синхронизировать();
    }
    
    return запись;
  }
  
  async обновить(сущность, id, данные) {
    // Получаем существующую запись
    const существующая = await this.локальноеХранилище.получить(сущность, id);
    
    if (!существующая) {
      throw new Error(`Запись ${id} не найдена`);
    }
    
    // Обновляем локально
    const обновлённая = {
      ...существующая,
      ...данные,
      времяОбновления: new Date().toISOString(),
      синхронизирована: false
    };
    
    await this.локальноеХранилище.обновить(сущность, обновлённая);
    
    // Добавляем в очередь синхронизации
    await this.добавитьВОчередь({
      тип: 'обновить',
      сущность: сущность,
      id: id,
      данные: обновлённая
    });
    
    // Если онлайн - сразу синхронизируем
    if (navigator.onLine) {
      await this.синхронизировать();
    }
    
    return обновлённая;
  }
  
  async удалить(сущность, id) {
    // Удаляем локально
    await this.локальноеХранилище.удалить(сущность, id);
    
    // Добавляем в очередь синхронизации
    await this.добавитьВОчередь({
      тип: 'удалить',
      сущность: сущность,
      id: id
    });
    
    // Если онлайн - сразу синхронизируем
    if (navigator.onLine) {
      await this.синхронизировать();
    }
  }
  
  async добавитьВОчередь(операция) {
    const очередь = await this.получитьОчередь();
    операция.id = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    операция.время = new Date().toISOString();
    очередь.push(операция);
    await this.установитьОчередь(очередь);
  }
  
  async получитьОчередь() {
    return await this.локальноеХранилище.получить('очередь_синхронизации') || [];
  }
  
  async установитьОчередь(очередь) {
    await this.локальноеХранилище.установить('очередь_синхронизации', очередь);
  }
  
  async синхронизировать() {
    const очередь = await this.получитьОчередь();
    
    if (очередь.length === 0) {
      return; // Нечего синхронизировать
    }
    
    for (const операция of [...очередь]) { // Копия для безопасности
      try {
        await this.выполнитьОперацию(операция);
        await this.удалитьИзОчереди(операция.id);
      } catch (ошибка) {
        console.error('Ошибка синхронизации операции:', ошибка);
        // Оставляем операцию в очереди для повторной попытки
        break; // Прерываем, чтобы не продолжать с другими операциями
      }
    }
  }
  
  async выполнитьОперацию(операция) {
    switch (операция.тип) {
      case 'создать':
        const созданная = await this.серверныйAPI.создать(операция.сущность, операция.данные);
        // Обновляем локальную запись с серверным ID
        await this.локальноеХранилище.обновить(операция.сущность, {
          ...операция.данные,
          id: созданная.id,
          синхронизирована: true
        });
        break;
        
      case 'обновить':
        await this.серверныйAPI.обновить(операция.сущность, операция.id, операция.данные);
        await this.отметитьСинхронизированной(операция.сущность, операция.id);
        break;
        
      case 'удалить':
        await this.серверныйAPI.удалить(операция.сущность, операция.id);
        break;
        
      default:
        throw new Error(`Неизвестный тип операции: ${операция.тип}`);
    }
  }
  
  async удалитьИзОчереди(id) {
    const очередь = await this.получитьОчередь();
    const индекс = очередь.findIndex(оп => оп.id === id);
    if (индекс !== -1) {
      очередь.splice(индекс, 1);
      await this.установитьОчередь(очередь);
    }
  }
  
  async отметитьСинхронизированной(сущность, id) {
    const запись = await this.локальноеХранилище.получить(сущность, id);
    if (запись) {
      запись.синхронизирована = true;
      await this.локальноеХранилище.обновить(сущность, запись);
    }
  }
  
  async обработатьОнлайн() {
    console.log('Подключение к сети восстановлено');
    await this.события.dispatchEvent(new CustomEvent('networkOnline'));
    await this.синхронизировать();
  }
  
  async обработатьОффлайн() {
    console.log('Подключение к сети потеряно');
    await this.события.dispatchEvent(new CustomEvent('networkOffline'));
  }
  
  генерироватьID() {
    return Date.now() + Math.random().toString(36).substr(2, 9);
  }
}
```

## Синхронизация в реальном времени

### Использование WebSocket

```javascript
class RealTimeSyncManager {
  constructor(серверныйAPI, локальноеХранилище) {
    this.серверныйAPI = серверныйAPI;
    this.локальноеХранилище = локальноеХранилище;
    this.websocket = null;
    this.подписки = new Map();
  }
  
  async подключиться() {
    return new Promise((resolve, reject) => {
      this.websocket = new WebSocket('ws://localhost:8080/realtime-sync');
      
      this.websocket.onopen = () => {
        console.log('Подключено к серверу синхронизации');
        resolve();
      };
      
      this.websocket.onmessage = (событие) => {
        const данные = JSON.parse(событие.data);
        this.обработатьСерверноеСообщение(данные);
      };
      
      this.websocket.onerror = (ошибка) => {
        console.error('Ошибка WebSocket:', ошибка);
        reject(ошибка);
      };
      
      this.websocket.onclose = () => {
        console.log('Соединение с сервером синхронизации закрыто');
      };
    });
  }
  
  async подписатьсяНаИзменения(сущность, обработчик) {
    const подписка = {
      сущность: сущность,
      обработчик: обработчик
    };
    
    this.подписки.set(сущность, подписка);
    
    // Отправляем запрос на подписку
    this.отправитьСообщение({
      тип: 'подписка',
      сущность: сущность
    });
  }
  
  async отписаться(сущность) {
    this.подписки.delete(сущность);
    
    this.отправитьСообщение({
      тип: 'отписка',
      сущность: сущность
    });
  }
  
  отправитьСообщение(сообщение) {
    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify(сообщение));
    }
  }
  
  обработатьСерверноеСообщение(данные) {
    switch (данные.тип) {
      case 'изменение':
        this.обработатьИзменениеСервера(данные);
        break;
        
      case 'подтверждение':
        this.обработатьПодтверждение(данные);
        break;
        
      default:
        console.warn('Неизвестный тип сообщения:', данные.тип);
    }
  }
  
  async обработатьИзменениеСервера(данные) {
    const { сущность, операция, запись } = данные;
    
    // Обновляем локальное хранилище
    switch (операция) {
      case 'создать':
        await this.локальноеХранилище.добавить(сущность, запись);
        break;
        
      case 'обновить':
        await this.локальноеХранилище.обновить(сущность, запись);
        break;
        
      case 'удалить':
        await this.локальноеХранилище.удалить(сущность, запись.id);
        break;
    }
    
    // Вызываем обработчики подписки
    const подписка = this.подписки.get(сущность);
    if (подписка) {
      подписка.обработчик(данные);
    }
  }
  
  async обработатьПодтверждение(данные) {
    // Обработка подтверждения получения изменений
    console.log('Получено подтверждение:', данные);
  }
  
  async отправитьИзменение(сущность, операция, запись) {
    const сообщение = {
      тип: 'изменение',
      сущность: сущность,
      операция: операция,
      запись: запись,
      clientId: this.получитьClientId()
    };
    
    this.отправитьСообщение(сообщение);
  }
  
  получитьClientId() {
    // В реальном приложении это может быть UUID пользователя или устройства
    if (!localStorage.getItem('clientId')) {
      const clientId = 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('clientId', clientId);
    }
    return localStorage.getItem('clientId');
  }
}
```

## Обработка конфликтов синхронизации

### Стратегии разрешения конфликтов

```javascript
class ConflictResolver {
  static async разрешить(локальныеДанные, серверныеДанные, типКонфликта) {
    switch (типКонфликта) {
      case 'последнее_обновление_выигрывает':
        return this.последнееОбновлениеВыигрывает(локальныеДанные, серверныеДанные);
        
      case 'локальные_данные_выигрывают':
        return локальныеДанные;
        
      case 'серверные_данные_выигрывают':
        return серверныеДанные;
        
      case 'объединение':
        return this.объединить(локальныеДанные, серверныеДанные);
        
      case 'ручное_разрешение':
        return await this.запроситьРазрешениеУПользователя(локальныеДанные, серверныеДанные);
        
      default:
        throw new Error(`Неизвестная стратегия разрешения конфликта: ${типКонфликта}`);
    }
  }
  
  static последнееОбновлениеВыигрывает(локальныеДанные, серверныеДанные) {
    const локальноеВремя = new Date(локальныеДанные.времяОбновления || локальныеДанные.времяСоздания);
    const серверноеВремя = new Date(серверныеДанные.времяОбновления || серверныеДанные.времяСоздания);
    
    return локальноеВремя > серверноеВремя ? локальныеДанные : серверныеДанные;
  }
  
  static объединить(локальныеДанные, серверныеДанные) {
    // Простое объединение - сохраняем более поздние значения для каждого поля
    const результат = { ...серверныеДанные };
    
    for (const [ключ, значение] of Object.entries(локальныеДанные)) {
      if (ключ !== 'времяОбновления' && ключ !== 'времяСоздания') {
        // Здесь может быть более сложная логика объединения
        результат[ключ] = значение;
      }
    }
    
    return результат;
  }
  
  static async запроситьРазрешениеУПользователя(локальныеДанные, серверныеДанные) {
    // В реальном приложении это может быть UI для выбора
    return new Promise((resolve) => {
      // Показываем пользователю оба варианта и даем ему выбрать
      // или объединить вручную
      console.log('Конфликт данных:', { локальные: локальныеДанные, серверные: серверныеДанные });
      
      // Для примера, возвращаем серверные данные
      resolve(серверныеДанные);
    });
  }
}

// Использование в синхронизации
class AdvancedSyncManager extends OfflineSyncManager {
  async обработатьКонфликт(локальныеДанные, серверныеДанные) {
    const разрешенные = await ConflictResolver.разрешить(
      локальныеДанные,
      серверныеДанные,
      'последнее_обновление_выигрывает'
    );
    
    // Обновляем локальное хранилище разрешенными данными
    await this.локальноеХранилище.обновить(разрешенные);
    
    // Отправляем разрешенные данные обратно на сервер
    await this.серверныйAPI.обновить(разрешенные.сущность, разрешенные.id, разрешенные);
    
    return разрешенные;
  }
}
```

## Практические примеры

### Синхронизация списка задач

```javascript
class TaskSyncManager {
  constructor() {
    this.локальноеХранилище = new IndexedDBStorage('TasksDB');
    this.api = new TaskAPI();
    this.syncManager = new OfflineSyncManager(this.api, this.локальноеХранилище);
  }
  
  async инициализировать() {
    await this.локальноеХранилище.инициализировать();
    await this.syncManager.инициализировать();
  }
  
  async создатьЗадачу(данные) {
    return await this.syncManager.создать('задачи', {
      ...данные,
      статус: 'новая',
      создана: new Date().toISOString()
    });
  }
  
  async обновитьЗадачу(id, обновления) {
    return await this.syncManager.обновить('задачи', id, {
      ...обновления,
      обновлена: new Date().toISOString()
    });
  }
  
  async удалитьЗадачу(id) {
    return await this.syncManager.удалить('задачи', id);
  }
  
  async получитьВсеЗадачи() {
    return await this.локальноеХранилище.получитьВсе('задачи');
  }
}

// Пример использования
const taskSync = new TaskSyncManager();
await taskSync.инициализировать();

// Создание задачи даже без подключения к сети
const новаяЗадача = await taskSync.создатьЗадачу({
  заголовок: 'Новая задача',
  описание: 'Описание задачи',
  приоритет: 'высокий'
});
```

## Лучшие практики

### 1. Индикация состояния синхронизации

```javascript
class SyncStatusIndicator {
  constructor(элементИнтерфейса) {
    this.элемент = элементИнтерфейса;
    this.статус = 'синхронизировано';
  }
  
  обновитьСтатус(статус) {
    this.статус = статус;
    
    switch (статус) {
      case 'синхронизировано':
        this.элемент.textContent = '✓ Синхронизировано';
        this.элемент.className = 'sync-status synced';
        break;
        
      case 'синхронизируется':
        this.элемент.textContent = '↻ Синхронизация...';
        this.элемент.className = 'sync-status syncing';
        break;
        
      case 'оффлайн':
        this.элемент.textContent = '⚠ Оффлайн';
        this.элемент.className = 'sync-status offline';
        break;
        
      case 'ошибка':
        this.элемент.textContent = '✗ Ошибка синхронизации';
        this.элемент.className = 'sync-status error';
        break;
    }
  }
}
```

### 2. Обработка ошибок и повторные попытки

```javascript
class RetryableSyncManager {
  constructor(базовыйМенеджер, настройки = {}) {
    this.базовыйМенеджер = базовыйМенеджер;
    this.настройки = {
      максимальныеПопытки: 3,
      задержкаПовтора: 1000,
      ...настройки
    };
  }
  
  async синхронизироватьСПовтором() {
    let попытка = 0;
    
    while (попытка < this.настройки.максимальныеПопытки) {
      try {
        await this.базовыйМенеджер.синхронизировать();
        return true; // Успешно
      } catch (ошибка) {
        попытка++;
        
        if (попытка >= this.настройки.максимальныеПопытки) {
          throw ошибка;
        }
        
        // Ждем перед повторной попыткой
        await new Promise(resolve => 
          setTimeout(resolve, this.настройки.задержкаПовтора * попытка)
        );
      }
    }
  }
}
```

## Заключение

Синхронизация данных - это сложная, но критически важная часть современных веб-приложений, особенно тех, которые работают автономно или в условиях нестабильного подключения к интернету. Правильная реализация синхронизации обеспечивает согласованность данных, улучшает пользовательский опыт и позволяет приложениям работать эффективно в различных сетевых условиях.

Успешная синхронизация требует тщательного планирования архитектуры, правильной обработки ошибок и конфликтов, а также четкого понимания требований к согласованности данных в конкретном приложении.

## См. также

- [[Локальное-хранилище]]
- [[Сессионное-хранилище]]
- [[IndexedDB]]
- [[Кэширование-данных]]
- [[Персистентность-данных-в-веб-приложениях]]
- [[WebSocket]]
- [[Service Workers]]
- [[Автономные веб-приложения (PWA)]]