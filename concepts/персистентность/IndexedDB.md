---
aliases: [Indexed Database API, Indexed Database]
tags: [frontend, persistence, storage, javascript, database]
---

# IndexedDB

**IndexedDB** - это низкоуровневое API для хранения значительных объемов структурированных данных в браузере, включая файлы/объекты Blob. Это полноценная клиентская база данных, которая позволяет приложениям работать автономно с большими объемами данных.

## Основные характеристики

- **Персистентность**: Данные сохраняются до тех пор, пока пользователь или приложение не удалит их
- **Объем**: Значительно больше, чем у LocalStorage/SessionStorage (обычно до 50% от свободного места на диске)
- **Типы данных**: Поддержка всех структурированных данных (объекты, массивы, файлы, изображения)
- **Асинхронность**: Все операции асинхронны, не блокируют основной поток
- **Индексация**: Поддержка индексов для быстрого поиска и сортировки
- **Транзакции**: Поддержка транзакций для обеспечения целостности данных

## Архитектура IndexedDB

### Базы данных
- Каждое приложение работает с одной или несколькими базами данных
- База данных содержит коллекции объектных хранилищ (object stores)

### Объектные хранилища
- Аналог таблиц в реляционной базе данных
- Содержат записи с ключами и значениями
- Каждая запись - это объект JavaScript

### Индексы
- Позволяют выполнять поиск по полям объектов
- Ускоряют выборку данных по не-ключевым полям

### Транзакции
- Все операции происходят в рамках транзакций
- Гарантируют атомарность и согласованность данных

## Основные операции

### Открытие базы данных

```javascript
// Открытие или создание базы данных
function открытьБазуДанных(имя, версия) {
  return new Promise((resolve, reject) => {
    const запрос = indexedDB.open(имя, версия);
    
    запрос.onerror = () => {
      reject(`Ошибка открытия базы данных: ${запрос.error}`);
    };
    
    запрос.onsuccess = () => {
      resolve(запрос.result);
    };
    
    // Обновление схемы при изменении версии
    запрос.onupgradeneeded = (событие) => {
      const база = событие.target.result;
      
      // Создание объектного хранилища
      if (!база.objectStoreNames.contains('пользователи')) {
        const хранилище = база.createObjectStore('пользователи', { keyPath: 'id', autoIncrement: true });
        
        // Создание индексов
        хранилище.createIndex('имя', 'имя', { unique: false });
        хранилише.createIndex('email', 'email', { unique: true });
      }
      
      if (!база.objectStoreNames.contains('записи')) {
        const хранилище = база.createObjectStore('записи', { keyPath: 'id', autoIncrement: true });
        хранилище.createIndex('пользователь_id', 'пользователь_id', { unique: false });
        хранилище.createIndex('дата', 'дата', { unique: false });
      }
    };
  });
}
```

### Добавление данных

```javascript
// Добавление записи в объектное хранилище
async function добавитьПользователя(база, пользователь) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readwrite');
    const хранилище = транзакция.objectStore('пользователи');
    
    const запрос = хранилище.add(пользователь);
    
    запрос.onsuccess = () => {
      console.log('Пользователь успешно добавлен с ID:', запрос.result);
      resolve(запрос.result);
    };
    
    запрос.onerror = () => {
      reject(`Ошибка добавления пользователя: ${запрос.error}`);
    };
  });
}

// Пример использования
async function примерДобавления() {
  const база = await открытьБазуДанных('МояБазаДанных', 1);
  
  const новыйПользователь = {
    имя: 'Алексей',
    email: 'alex@example.com',
    возраст: 28,
    дата_регистрации: new Date().toISOString()
  };
  
  try {
    const id = await добавитьПользователя(база, новыйПользователь);
    console.log('ID нового пользователя:', id);
  } catch (ошибка) {
    console.error('Ошибка:', ошибка);
  }
}
```

### Чтение данных

```javascript
// Получение записи по ключу
async function получитьПользователя(база, id) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readonly');
    const хранилище = транзакция.objectStore('пользователи');
    
    const запрос = хранилище.get(id);
    
    запрос.onsuccess = () => {
      resolve(запрос.result);
    };
    
    запрос.onerror = () => {
      reject(`Ошибка получения пользователя: ${запрос.error}`);
    };
  });
}

// Получение всех записей
async function получитьВсехПользователей(база) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readonly');
    const хранилище = транзакция.objectStore('пользователи');
    
    const все = [];
    хранилище.openCursor().onsuccess = (событие) => {
      const курсор = событие.target.result;
      if (курсор) {
        все.push(курсор.value);
        курсор.continue();
      } else {
        resolve(все);
      }
    };
    
    хранилище.openCursor().onerror = () => {
      reject(`Ошибка получения пользователей: ${запрос.error}`);
    };
  });
}

// Поиск по индексу
async function найтиПользователейПоИмени(база, имя) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readonly');
    const хранилище = транзакция.objectStore('пользователи');
    const индекс = хранилище.index('имя');
    
    const результаты = [];
    индекс.openCursor(IDBKeyRange.only(имя)).onsuccess = (событие) => {
      const курсор = событие.target.result;
      if (курсор) {
        результаты.push(курсор.value);
        курсор.continue();
      } else {
        resolve(результаты);
      }
    };
    
    индекс.openCursor(IDBKeyRange.only(имя)).onerror = () => {
      reject(`Ошибка поиска пользователей: ${запрос.error}`);
    };
  });
}
```

### Обновление данных

```javascript
// Обновление записи
async function обновитьПользователя(база, id, обновления) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readwrite');
    const хранилище = транзакция.objectStore('пользователи');
    
    // Получаем существующую запись
    const запросПолучения = хранилище.get(id);
    
    запросПолучения.onsuccess = () => {
      const существующий = запросПолучения.result;
      if (существующий) {
        // Объединяем существующие данные с обновлениями
        const обновлённый = { ...существующий, ...обновления };
        
        const запросОбновления = хранилище.put(обновлённый);
        
        запросОбновления.onsuccess = () => {
          resolve(обновлённый);
        };
        
        запросОбновления.onerror = () => {
          reject(`Ошибка обновления пользователя: ${запросОбновления.error}`);
        };
      } else {
        reject(`Пользователь с ID ${id} не найден`);
      }
    };
    
    запросПолучения.onerror = () => {
      reject(`Ошибка получения пользователя для обновления: ${запросПолучения.error}`);
    };
  });
}
```

### Удаление данных

```javascript
// Удаление записи по ключу
async function удалитьПользователя(база, id) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction(['пользователи'], 'readwrite');
    const хранилище = транзакция.objectStore('пользователи');
    
    const запрос = хранилище.delete(id);
    
    запрос.onsuccess = () => {
      console.log('Пользователь успешно удалён');
      resolve(true);
    };
    
    запрос.onerror = () => {
      reject(`Ошибка удаления пользователя: ${запрос.error}`);
    };
  });
}

// Удаление всей базы данных
function удалитьБазуДанных(имя) {
  return new Promise((resolve, reject) => {
    const запрос = indexedDB.deleteDatabase(имя);
    
    запрос.onsuccess = () => {
      console.log('База данных успешно удалена');
      resolve(true);
    };
    
    запрос.onerror = () => {
      reject(`Ошибка удаления базы данных: ${запрос.error}`);
    };
    
    запрос.onblocked = () => {
      reject('Удаление заблокировано - база данных используется');
    };
  });
}
```

## Практические примеры использования

### Кэширование данных приложения

```javascript
class IndexedDBCache {
  constructor(имяБазы = 'КэшПриложения', версия = 1) {
    this.имяБазы = имяБазы;
    this.база = null;
    this.инициализировать(версия);
  }
  
  async инициализировать(версия) {
    this.база = await открытьБазуДанных(this.имяБазы, версия);
  }
  
  async установить(ключ, значение) {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    // Создаем хранилище кэша если его нет
    await this.создатьХранилищеЕслиНет();
    
    const запись = {
      ключ: ключ,
      значение: значение,
      времяСоздания: Date.now(),
      времяИстечения: Date.now() + (24 * 60 * 60 * 1000) // 24 часа
    };
    
    return добавитьДанныеВХранилище(this.база, 'кэш', запись);
  }
  
  async получить(ключ) {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    const запись = await получитьИзХранилища(this.база, 'кэш', ключ);
    
    if (запись && Date.now() < запись.времяИстечения) {
      return запись.значение;
    } else if (запись) {
      // Удаляем просроченную запись
      await удалитьИзХранилища(this.база, 'кэш', ключ);
    }
    
    return null;
  }
  
  async очиститьПросроченные() {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    const транзакция = this.база.transaction(['кэш'], 'readwrite');
    const хранилище = транзакция.objectStore('кэш');
    
    return new Promise((resolve, reject) => {
      const курсор = хранилище.openCursor();
      
      курсор.onsuccess = (событие) => {
        const курсор = событие.target.result;
        if (курсор) {
          if (Date.now() > курсор.value.времяИстечения) {
            курсор.delete(); // Удаляем просроченную запись
          }
          курсор.continue();
        } else {
          resolve();
        }
      };
      
      курсор.onerror = () => {
        reject(событие.target.error);
      };
    });
  }
  
  async создатьХранилищеЕслиНет() {
    if (!this.база.objectStoreNames.contains('кэш')) {
      const запрос = this.база.transaction(['кэш'], 'versionchange');
      this.база.createObjectStore('кэш', { keyPath: 'ключ' });
    }
  }
}

// Вспомогательные функции для работы с хранилищем
async function добавитьДанныеВХранилище(база, имяХранилища, данные) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction([имяХранилища], 'readwrite');
    const хранилище = транзакция.objectStore(имяХранилища);
    
    const запрос = хранилище.add(данные);
    
    запрос.onsuccess = () => resolve(запрос.result);
    запрос.onerror = () => reject(запрос.error);
  });
}

async function получитьИзХранилища(база, имяХранилища, ключ) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction([имяХранилища], 'readonly');
    const хранилище = транзакция.objectStore(имяХранилища);
    
    const запрос = хранилище.get(ключ);
    
    запрос.onsuccess = () => resolve(запрос.result);
    запрос.onerror = () => reject(запрос.error);
  });
}

async function удалитьИзХранилища(база, имяХранилища, ключ) {
  return new Promise((resolve, reject) => {
    const транзакция = база.transaction([имяХранилища], 'readwrite');
    const хранилище = транзакция.objectStore(имяХранилища);
    
    const запрос = хранилище.delete(ключ);
    
    запрос.onsuccess = () => resolve();
    запрос.onerror = () => reject(запрос.error);
  });
}
```

### Хранение файлов и изображений

```javascript
class IndexedDBFileStorage {
  constructor(имяБазы = 'ФайловоеХранилище', версия = 1) {
    this.имяБазы = имяБазы;
    this.база = null;
    this.инициализировать(версия);
  }
  
  async инициализировать(версия) {
    this.база = await открытьБазуДанных(this.имяБазы, версия);
  }
  
  async сохранитьФайл(имяФайла, файл) {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    const запись = {
      имя: имяФайла,
      данные: файл,
      тип: файл.type || 'application/octet-stream',
      размер: файл.size,
      дата: new Date().toISOString()
    };
    
    return добавитьДанныеВХранилище(this.база, 'файлы', запись);
  }
  
  async получитьФайл(имяФайла) {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    const запись = await получитьИзХранилища(this.база, 'файлы', имяФайла);
    return запись ? запись.данные : null;
  }
  
  async получитьИнформациюОФайле(имяФайла) {
    if (!this.база) throw new Error('База данных не инициализирована');
    
    const запись = await получитьИзХранилища(this.база, 'файлы', имяФайла);
    return запись ? {
      имя: запись.имя,
      тип: запись.тип,
      размер: запись.размер,
      дата: запись.дата
    } : null;
  }
}
```

## Преимущества IndexedDB

- **Большой объем хранения**: Может использовать значительную часть свободного места на диске
- **Поддержка сложных данных**: Хранение объектов, массивов, файлов и изображений
- **Асинхронность**: Не блокирует основной поток выполнения
- **Индексация**: Быстрый поиск и сортировка данных
- **Транзакции**: Гарантия целостности данных
- **Широкая поддержка**: Доступен во всех современных браузерах

## Ограничения и сложности

- **Сложность API**: Более сложное в использовании по сравнению с LocalStorage
- **Асинхронность**: Требует работы с Promise или коллбэками
- **Обработка ошибок**: Необходимость обработки различных типов ошибок
- **Ограничения браузера**: Некоторые браузеры могут ограничивать использование в приватном режиме
- **Кросс-доменность**: Данные доступны только с того же домена

## Лучшие практики

### 1. Обработка версий схемы

```javascript
// Управление версиями базы данных
async function обновитьСхему(база, текущаяВерсия, новаяВерсия) {
  if (новаяВерсия <= текущаяВерсия) return;
  
  // Создание новой версии базы данных для обновления схемы
  const запрос = indexedDB.open(база.name, новаяВерсия);
  
  return new Promise((resolve, reject) => {
    запрос.onupgradeneeded = (событие) => {
      const новаяБаза = событие.target.result;
      
      // Добавление новых объектных хранилищ или индексов
      if (новаяВерсия >= 2 && !новаяБаза.objectStoreNames.contains('настройки')) {
        const хранилище = новаяБаза.createObjectStore('настройки', { keyPath: 'ключ' });
        хранилище.createIndex('категория', 'категория', { unique: false });
      }
      
      if (новаяВерсия >= 3) {
        // Миграция данных из старого хранилища
        мигрироватьДанные(событие);
      }
    };
    
    запрос.onsuccess = () => {
      resolve(запрос.result);
    };
    
    запрос.onerror = () => {
      reject(запрос.error);
    };
  });
}

function мигрироватьДанные(событие) {
  const база = событие.target.result;
  const транзакция = событие.target.transaction;
  const староеХранилище = транзакция.objectStore('старые_данные');
  
  // Пример миграции данных
  староеХранилище.openCursor().onsuccess = (cursorEvent) => {
    const курсор = cursorEvent.target.result;
    if (курсор) {
      // Преобразование и сохранение данных в новом формате
      const новаяЗапись = преобразоватьСтаруюЗапись(курсор.value);
      // Сохранение в новом хранилище
      курсор.continue();
    }
  };
}
```

### 2. Обработка ошибок и восстановление

```javascript
class IndexedDBManager {
  constructor(имяБазы, версия) {
    this.имяБазы = имяБазы;
    this.версия = версия;
    this.база = null;
  }
  
  async подключиться() {
    try {
      this.база = await открытьБазуДанных(this.имяБазы, this.версия);
      return true;
    } catch (ошибка) {
      console.error('Ошибка подключения к IndexedDB:', ошибка);
      
      // Попытка восстановления
      if (ошибка.name === 'InvalidStateError' || ошибка.name === 'VersionError') {
        await this.восстановить();
      }
      
      return false;
    }
  }
  
  async восстановить() {
    console.log('Попытка восстановления IndexedDB...');
    
    // Закрытие текущего соединения
    if (this.база) {
      this.база.close();
    }
    
    // Повторное открытие базы данных
    this.база = await открытьБазуДанных(this.имяБазы, this.версия);
  }
  
  async выполнитьОперацию(имяХранилища, режим, операция) {
    if (!this.база) {
      await this.подключиться();
    }
    
    const транзакция = this.база.transaction([имяХранилища], режим);
    return операция(транзакция);
  }
}
```

## Сравнение с другими методами хранения

| Метод | Персистентность | Объем | Тип данных | Синхронность | Производительность |
|-------|----------------|-------|------------|--------------|-------------------|
| [[Локальное-хранилище]] | Постоянная | ~5-10 МБ | Только строки | Синхронный | Высокая |
| [[Сессионное-хранилище]] | Сессия | ~5-10 МБ | Только строки | Синхронный | Высокая |
| [[Куки]] | Настроена | ~4 КБ | Только строки | Синхронный | Высокая |
| IndexedDB | Постоянная | ~Много | Любые объекты | Асинхронный | Высокая (с индексами) |

## Заключение

IndexedDB - это мощный инструмент для хранения больших объемов структурированных данных в браузере. Он особенно полезен для автономных приложений, приложений с большим объемом пользовательских данных и сценариев, требующих сложного поиска и фильтрации данных.

Хотя IndexedDB имеет более сложный API по сравнению с LocalStorage и SessionStorage, он предоставляет значительно больше возможностей для работы с данными на клиенте. Это делает его идеальным выбором для современных веб-приложений, которым требуется надежное и масштабируемое решение для локального хранения данных.

## См. также

- [[Локальное-хранилище]]
- [[Сессионное-хранилище]]
- [[Куки]]
- [[Кэширование-данных]]
- [[Синхронизация-данных]]
- [[Персистентность-данных-в-веб-приложениях]]
- [[Web Storage API]]