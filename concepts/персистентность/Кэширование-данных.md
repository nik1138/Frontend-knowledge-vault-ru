---
aliases: [Кэширование, Data Caching]
tags: [frontend, performance, caching, persistence, optimization]
---

# Кэширование данных

**Кэширование данных** - это процесс временного хранения данных в быстродоступной памяти для ускорения последующих обращений к ним. В контексте фронтенд-разработки кэширование позволяет уменьшить количество сетевых запросов, ускорить загрузку приложения и улучшить пользовательский опыт.

## Основные понятия кэширования

### Типы кэшей в веб-приложениях

1. **HTTP-кэш браузера** - кэширование ресурсов (HTML, CSS, JS, изображения)
2. **Кэш приложения** - временное хранение данных в памяти или локальных хранилищах
3. **Service Worker кэш** - кэширование ресурсов для автономной работы
4. **Кэш в памяти** - временные данные в переменных JavaScript

### Преимущества кэширования

- **Улучшение производительности** - уменьшение времени загрузки
- **Снижение нагрузки на сервер** - меньше сетевых запросов
- **Автономная работа** - доступ к данным без подключения
- **Экономия трафика** - уменьшение потребления данных пользователем

## HTTP-кэширование

### Заголовки кэширования

```javascript
// Пример HTTP-заголовков для кэширования
const заголовки = {
  // Устаревание кэша
  'Cache-Control': 'max-age=3600, public', // Кэшировать 1 час
  'Expires': new Date(Date.now() + 3600000).toUTCString(), // 1 час
  
  // Валидация кэша
  'ETag': '33a64df551425fcc55e4d42a148795d9f25f89d4',
  'Last-Modified': 'Wed, 21 Oct 2024 07:28:00 GMT',
  
  // Условные запросы
  'If-None-Match': '33a64df551425fcc55e4d42a148795d9f25f89d4',
  'If-Modified-Since': 'Wed, 21 Oct 2024 07:28:00 GMT'
};
```

### Кэширование в браузере

```javascript
// Пример использования заголовков кэширования при запросе данных
async function получитьДанныеСКэшированием(адрес) {
  try {
    const ответ = await fetch(адрес, {
      headers: {
        'Cache-Control': 'max-age=3600' // Кэшировать на 1 час
      }
    });
    
    if (ответ.ok) {
      return await ответ.json();
    }
  } catch (ошибка) {
    console.error('Ошибка запроса:', ошибка);
  }
}
```

## Кэширование в памяти

### Простой кэш в памяти

```javascript
class MemoryCache {
  constructor(максРазмер = 100) {
    this.кэш = new Map();
    this.максРазмер = максРазмер;
  }
  
  get(ключ) {
    return this.кэш.get(ключ);
  }
  
  set(ключ, значение) {
    // Удаление старых записей при достижении максимального размера
    if (this.кэш.size >= this.максРазмер) {
      const первыйКлюч = this.кэш.keys().next().value;
      this.кэш.delete(первыйКлюч);
    }
    
    this.кэш.set(ключ, значение);
  }
  
  has(ключ) {
    return this.кэш.has(ключ);
  }
  
  delete(ключ) {
    return this.кэш.delete(ключ);
  }
  
  clear() {
    this.кэш.clear();
  }
}

// Использование
const памятныйКэш = new MemoryCache(50);
памятныйКэш.set('пользователь_123', { id: 123, имя: 'Иван' });
const пользователь = памятныйКэш.get('пользователь_123');
```

### Кэш с TTL (Time To Live)

```javascript
class TTLCache {
  constructor(максРазмер = 100, времяЖизни = 300000) { // 5 минут по умолчанию
    this.кэш = new Map();
    this.времяЖизни = времяЖизни;
    this.максРазмер = максРазмер;
  }
  
  get(ключ) {
    const запись = this.кэш.get(ключ);
    if (!запись) return undefined;
    
    // Проверка срока годности
    if (Date.now() - запись.времяСоздания > this.времяЖизни) {
      this.кэш.delete(ключ);
      return undefined;
    }
    
    return запись.значение;
  }
  
  set(ключ, значение) {
    // Очистка просроченных записей
    this.очиститьПросроченные();
    
    // Удаление старых записей при достижении максимального размера
    if (this.кэш.size >= this.максРазмер) {
      const первыйКлюч = this.кэш.keys().next().value;
      this.кэш.delete(первыйКлюч);
    }
    
    this.кэш.set(ключ, {
      значение: значение,
      времяСоздания: Date.now()
    });
  }
  
  очиститьПросроченные() {
    for (const [ключ, запись] of this.кэш) {
      if (Date.now() - запись.времяСоздания > this.времяЖизни) {
        this.кэш.delete(ключ);
      }
    }
  }
  
  clear() {
    this.кэш.clear();
  }
}

// Использование
const ttlКэш = new TTLCache(20, 60000); // 20 элементов, 1 минута жизни
ttlКэш.set('временная_данные', { данные: 'важные' });
```

## Кэширование с использованием локальных хранилищ

### Кэш на основе LocalStorage

```javascript
class LocalStorageCache {
  constructor(префикс = 'кэш_', времяЖизни = 3600000) { // 1 час по умолчанию
    this.префикс = префикс;
    this.времяЖизни = времяЖизни;
  }
  
  get(ключ) {
    try {
      const ключСПрефиксом = this.префикс + ключ;
      const строка = localStorage.getItem(ключСПрефиксом);
      
      if (!строка) return null;
      
      const запись = JSON.parse(строка);
      
      // Проверка срока годности
      if (Date.now() - запись.времяСоздания > this.времяЖизни) {
        localStorage.removeItem(ключСПрефиксом);
        return null;
      }
      
      return запись.значение;
    } catch (ошибка) {
      console.error('Ошибка чтения из кэша:', ошибка);
      return null;
    }
  }
  
  set(ключ, значение) {
    try {
      const ключСПрефиксом = this.префикс + ключ;
      const запись = {
        значение: значение,
        времяСоздания: Date.now()
      };
      
      localStorage.setItem(ключСПрефиксом, JSON.stringify(запись));
    } catch (ошибка) {
      console.error('Ошибка сохранения в кэш:', ошибка);
      // Возможно, LocalStorage переполнен
    }
  }
  
  delete(ключ) {
    try {
      const ключСПрефиксом = this.префикс + ключ;
      localStorage.removeItem(ключСПрефиксом);
    } catch (ошибка) {
      console.error('Ошибка удаления из кэша:', ошибка);
    }
  }
  
  clear() {
    try {
      // Удаление всех записей с нашим префиксом
      const ключиДляУдаления = [];
      for (let i = 0; i < localStorage.length; i++) {
        const ключ = localStorage.key(i);
        if (ключ && ключ.startsWith(this.префикс)) {
          ключиДляУдаления.push(ключ);
        }
      }
      
      ключиДляУдаления.forEach(ключ => localStorage.removeItem(ключ));
    } catch (ошибка) {
      console.error('Ошибка очистки кэша:', ошибка);
    }
  }
  
  очиститьПросроченные() {
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const ключ = localStorage.key(i);
        if (ключ && ключ.startsWith(this.префикс)) {
          const строка = localStorage.getItem(ключ);
          if (строка) {
            try {
              const запись = JSON.parse(строка);
              if (Date.now() - запись.времяСоздания > this.времяЖизни) {
                localStorage.removeItem(ключ);
              }
            } catch (ошибка) {
              // Удаление поврежденных записей
              localStorage.removeItem(ключ);
            }
          }
        }
      }
    } catch (ошибка) {
      console.error('Ошибка очистки просроченных:', ошибка);
    }
  }
}

// Использование
const локальныйКэш = new LocalStorageCache('данные_', 1800000); // 30 минут
локальныйКэш.set('популярные_товары', [{ id: 1, название: 'Товар 1' }]);
const товары = локальныйКэш.get('популярные_товары');
```

### Кэш на основе IndexedDB

```javascript
class IndexedDBCache {
  constructor(имяБазы = 'КэшПриложения', имяХранилища = 'кэш', времяЖизни = 3600000) {
    this.имяБазы = имяБазы;
    this.имяХранилища = имяХранилища;
    this.времяЖизни = времяЖизни;
    this.база = null;
    this.инициализировать();
  }
  
  async инициализировать() {
    try {
      const запрос = indexedDB.open(this.имяБазы, 1);
      
      return new Promise((resolve, reject) => {
        запрос.onerror = () => reject(запрос.error);
        
        запрос.onsuccess = () => {
          this.база = запрос.result;
          resolve();
        };
        
        запрос.onupgradeneeded = (событие) => {
          const база = событие.target.result;
          if (!база.objectStoreNames.contains(this.имяХранилища)) {
            const хранилище = база.createObjectStore(this.имяХранилища, { keyPath: 'ключ' });
            хранилище.createIndex('времяСоздания', 'времяСоздания', { unique: false });
          }
        };
      });
    } catch (ошибка) {
      console.error('Ошибка инициализации IndexedDB кэша:', ошибка);
    }
  }
  
  async get(ключ) {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction([this.имяХранилища], 'readonly');
      const хранилище = транзакция.objectStore(this.имяХранилища);
      
      const запрос = хранилище.get(ключ);
      
      запрос.onsuccess = () => {
        const запись = запрос.result;
        if (запись) {
          // Проверка срока годности
          if (Date.now() - запись.времяСоздания > this.времяЖизни) {
            // Автоматическое удаление просроченной записи
            this.delete(ключ);
            resolve(null);
          } else {
            resolve(запись.значение);
          }
        } else {
          resolve(null);
        }
      };
      
      запрос.onerror = () => {
        reject(запрос.error);
      };
    });
  }
  
  async set(ключ, значение) {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction([this.имяХранилища], 'readwrite');
      const хранилище = транзакция.objectStore(this.имяХранилища);
      
      const запись = {
        ключ: ключ,
        значение: значение,
        времяСоздания: Date.now()
      };
      
      const запрос = хранилище.put(запись);
      
      запрос.onsuccess = () => resolve();
      запрос.onerror = () => reject(запрос.error);
    });
  }
  
  async delete(ключ) {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction([this.имяХранилища], 'readwrite');
      const хранилище = транзакция.objectStore(this.имяХранилища);
      
      const запрос = хранилище.delete(ключ);
      
      запрос.onsuccess = () => resolve();
      запрос.onerror = () => reject(запрос.error);
    });
  }
  
  async clear() {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction([this.имяХранилища], 'readwrite');
      const хранилище = транзакция.objectStore(this.имяХранилища);
      
      const запрос = хранилище.clear();
      
      запрос.onsuccess = () => resolve();
      запрос.onerror = () => reject(запрос.error);
    });
  }
  
  async очиститьПросроченные() {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction([this.имяХранилища], 'readwrite');
      const хранилище = транзакция.objectStore(this.имяХранилища);
      const индекс = хранилище.index('времяСоздания');
      
      const диапазон = IDBKeyRange.upperBound(Date.now() - this.времяЖизни);
      const запрос = индекс.openKeyCursor(diапазон);
      
      запрос.onsuccess = (событие) => {
        const курсор = событие.target.result;
        if (курсор) {
          хранилище.delete(курсор.primaryKey);
          курсор.continue();
        } else {
          resolve();
        }
      };
      
      запрос.onerror = () => {
        reject(запрос.error);
      };
    });
  }
}
```

## Кэширование API-запросов

### Кэширование данных с автоматической валидацией

```javascript
class APICache {
  constructor(времяЖизни = 300000) { // 5 минут по умолчанию
    this.времяЖизни = времяЖизни;
    this.кэш = new Map();
    this.запросы = new Map(); // Для предотвращения дублирующихся запросов
  }
  
  async get(ключ, fetcher) {
    // Проверка наличия активного запроса
    if (this.запросы.has(ключ)) {
      return this.запросы.get(ключ);
    }
    
    // Проверка кэша
    const запись = this.кэш.get(ключ);
    if (запись && Date.now() - запись.времяСоздания < this.времяЖизни) {
      return запись.данные;
    }
    
    // Выполнение запроса
    const промис = fetcher().then(данные => {
      this.кэш.set(ключ, {
        данные: данные,
        времяСоздания: Date.now()
      });
      this.запросы.delete(ключ);
      return данные;
    }).catch(ошибка => {
      this.запросы.delete(ключ);
      throw ошибка;
    });
    
    this.запросы.set(ключ, промис);
    return промис;
  }
  
  invalidate(ключ) {
    this.кэш.delete(ключ);
  }
  
  clear() {
    this.кэш.clear();
    this.запросы.clear();
  }
}

// Пример использования
const apiКэш = new APICache(60000); // 1 минута

async function получитьПользователя(id) {
  return apiКэш.get(`пользователь_${id}`, () => 
    fetch(`/api/пользователи/${id}`).then(ответ => ответ.json())
  );
}
```

### Кэширование с фоновой валидацией

```javascript
class BackgroundRefreshCache {
  constructor(времяЖизни = 300000, времяДоОбновления = 60000) {
    this.времяЖизни = времяЖизни;
    this.времяДоОбновления = времяДоОбновления;
    this.кэш = new Map();
    this.запросы = new Map();
  }
  
  async get(ключ, fetcher) {
    const запись = this.кэш.get(ключ);
    
    // Если данных нет или срок жизни истек
    if (!запись || Date.now() - запись.времяСоздания > this.времяЖизни) {
      return this.обновить(ключ, fetcher);
    }
    
    // Если данные скоро устареют, запускаем фоновое обновление
    if (Date.now() - запись.времяСоздания > (this.времяЖизни - this.времяДоОбновления)) {
      this.обновитьВФоне(ключ, fetcher);
    }
    
    return запись.данные;
  }
  
  async обновить(ключ, fetcher) {
    if (this.запросы.has(ключ)) {
      return this.запросы.get(ключ);
    }
    
    const промис = fetcher().then(данные => {
      this.кэш.set(ключ, {
        данные: данные,
        времяСоздания: Date.now()
      });
      this.запросы.delete(ключ);
      return данные;
    }).catch(ошибка => {
      this.запросы.delete(ключ);
      throw ошибка;
    });
    
    this.запросы.set(ключ, промис);
    return промис;
  }
  
  async обновитьВФоне(ключ, fetcher) {
    // Не блокируем основной поток
    setTimeout(async () => {
      try {
        const данные = await fetcher();
        this.кэш.set(ключ, {
          данные: данные,
          времяСоздания: Date.now()
        });
      } catch (ошибка) {
        console.error('Ошибка фонового обновления кэша:', ошибка);
      }
    }, 0);
  }
}
```

## Лучшие практики кэширования

### 1. Стратегии кэширования

```javascript
// Стратегия "Cache First" (сначала кэш, потом сеть)
async function cacheFirst(ключ, fetcher, кэш) {
  // Сначала пробуем получить из кэша
  let данные = await кэш.get(ключ);
  
  if (!данные) {
    // Если в кэше нет, получаем из сети и сохраняем
    данные = await fetcher();
    await кэш.set(ключ, данные);
  }
  
  return данные;
}

// Стратегия "Network First" (сначала сеть, потом кэш)
async function networkFirst(ключ, fetcher, кэш) {
  try {
    // Сначала пробуем получить из сети
    const данные = await fetcher();
    await кэш.set(ключ, данные); // Сохраняем в кэш для следующего раза
    return данные;
  } catch (ошибка) {
    // Если сеть недоступна, используем кэш
    const кэшированныеДанные = await кэш.get(ключ);
    if (кэшированныеДанные) {
      return кэшированныеДанные;
    }
    throw ошибка;
  }
}

// Стратегия "Cache and Network" (одновременно кэш и сеть)
async function cacheAndNetwork(ключ, fetcher, кэш) {
  // Получаем из кэша немедленно, если возможно
  const кэшированныеДанные = await кэш.get(ключ);
  
  // Одновременно обновляем из сети
  const свежиеДанные = await fetcher();
  await кэш.set(ключ, свежиеДанные);
  
  // Возвращаем кэшированные данные, если они есть, иначе свежие
  return кэшированныеДанные || свежиеДанные;
}
```

### 2. Управление размером кэша

```javascript
class LRUIndexedDBCache {
  constructor(имяБазы = 'LRUCache', размер = 100) {
    this.имяБазы = имяБазы;
    this.размер = размер;
    this.база = null;
    this.инициализировать();
  }
  
  async инициализировать() {
    // Реализация аналогично предыдущему примеру, но с LRU-логикой
  }
  
  async set(ключ, значение) {
    if (!this.база) await this.инициализировать();
    
    return new Promise((resolve, reject) => {
      const транзакция = this.база.transaction(['кэш'], 'readwrite');
      const хранилище = транзакция.objectStore('кэш');
      
      // Проверяем размер кэша
      const запросКоличества = хранилище.count();
      
      запросКоличества.onsuccess = () => {
        if (запросКоличества.result >= this.размер) {
          // Удаляем наименее используемую запись (LRU)
          this.удалитьLRU(транзакция).then(() => {
            this.сохранитьЗапись(хранилище, ключ, значение, resolve, reject);
          }).catch(reject);
        } else {
          this.сохранитьЗапись(хранилище, ключ, значение, resolve, reject);
        }
      };
      
      запросКоличества.onerror = () => reject(запросКоличества.error);
    });
  }
  
  сохранитьЗапись(хранилище, ключ, значение, resolve, reject) {
    const запись = {
      ключ: ключ,
      значение: значение,
      времяДоступа: Date.now()
    };
    
    const запрос = хранилище.put(запись);
    запрос.onsuccess = () => resolve();
    запрос.onerror = () => reject(запрос.error);
  }
  
  async удалитьLRU(транзакция) {
    return new Promise((resolve, reject) => {
      const хранилище = транзакция.objectStore('кэш');
      // Находим запись с наименьшим временем доступа
      const запрос = хранилище.index('времяДоступа').openCursor();
      
      запрос.onsuccess = (событие) => {
        const курсор = событие.target.result;
        if (курсор) {
          курсор.delete();
          resolve();
        } else {
          reject(new Error('Нечего удалять'));
        }
      };
      
      запрос.onerror = () => reject(запрос.error);
    });
  }
}
```

## Service Worker кэширование

```javascript
// Пример регистрации Service Worker для кэширования
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((регистрация) => {
        console.log('SW зарегистрирован с scope:', регистрация.scope);
      })
      .catch((ошибка) => {
        console.log('Ошибка регистрации SW:', ошибка);
      });
  });
}
```

```javascript
// Содержимое sw.js
const КЭШ_ИМЯ = 'приложение-кэш-v1';
const РЕСУРСЫ_ДЛЯ_КЭШИРОВАНИЯ = [
  '/',
  '/css/стили.css',
  '/js/скрипт.js',
  '/img/логотип.png'
];

self.addEventListener('install', (событие) => {
  событие.waitUntil(
    caches.open(КЭШ_ИМЯ)
      .then((кэш) => {
        console.log('Кэширование ресурсов');
        return кэш.addAll(РЕСУРСЫ_ДЛЯ_КЭШИРОВАНИЯ);
      })
  );
});

self.addEventListener('fetch', (событие) => {
  событие.respondWith(
    caches.match(событие.request)
      .then((ответ) => {
        // Возвращаем кэшированный ответ или запрашиваем с сервера
        return ответ || fetch(событие.request);
      })
  );
});
```

## Заключение

Кэширование данных - это критически важный аспект производительности веб-приложений. Правильное использование различных стратегий кэширования может значительно улучшить пользовательский опыт, особенно в условиях медленного интернет-соединения или при автономной работе приложения.

Ключ к эффективному кэшированию - выбор правильной стратегии для каждого типа данных и правильная настройка сроков жизни кэшированных данных. Важно также учитывать ограничения различных методов хранения и обеспечивать надежность и безопасность кэшированных данных.

## См. также

- [[Локальное-хранилище]]
- [[Сессионное-хранилище]]
- [[IndexedDB]]
- [[Синхронизация-данных]]
- [[Производительность-фронтенд-приложений]]
- [[HTTP-кеширование]]
- [[Service Workers]]