---
aliases: ["Higher-Order Functions", "Функции высшего порядка", "HOF", "Функциональное программирование - HOF"]
tags: [programming, functional-programming, javascript, frontend, functions]
---

# Функции высшего порядка

**Функции высшего порядка** (Higher-Order Functions, HOF) - это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат. Это одна из ключевых концепций функционального программирования.

## Определение

Функция считается функцией высшего порядка, если она:
1. Принимает одну или несколько функций в качестве аргументов
2. Возвращает функцию как результат
3. Или делает и то, и другое

## Примеры функций высшего порядка

### 1. Функция, принимающая другую функцию

```javascript
// Функция высшего порядка - принимает функцию в качестве аргумента
const executeTwice = (fn, value) => {
  return fn(fn(value));
};

// Использование
const double = x => x * 2;
console.log(executeTwice(double, 5)); // 20 (5 * 2 * 2)

// Функция высшего порядка для обработки массива
const processArray = (arr, processor) => {
  return arr.map(processor);
};

const numbers = [1, 2, 3, 4, 5];
const squared = processArray(numbers, x => x * x);
console.log(squared); // [1, 4, 9, 16, 25]
```

### 2. Функция, возвращающая другую функцию

```javascript
// Функция высшего порядка - возвращает функцию
const createMultiplier = (factor) => {
  return (number) => number * factor;
};

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

### 3. Функция, делающая и то, и другое

```javascript
// Функция высшего порядка - принимает и возвращает функцию
const composeWithLogging = (fn) => {
  return (value) => {
    console.log('Входное значение:', value);
    const result = fn(value);
    console.log('Результат:', result);
    return result;
  };
};

const addOne = x => x + 1;
const loggedAddOne = composeWithLogging(addOne);

console.log(loggedAddOne(5)); 
// Входное значение: 5
// Результат: 6
// 6
```

## Встроенные функции высшего порядка в JavaScript

### 1. Методы массивов

```javascript
const numbers = [1, 2, 3, 4, 5];

// map - принимает функцию для преобразования элементов
const doubled = numbers.map(x => x * 2); // [2, 4, 6, 8, 10]

// filter - принимает функцию для фильтрации элементов
const evens = numbers.filter(x => x % 2 === 0); // [2, 4]

// reduce - принимает функцию для свертки массива
const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 15

// forEach - принимает функцию для выполнения действия с каждым элементом
numbers.forEach(x => console.log(x));

// find - принимает функцию для поиска элемента
const found = numbers.find(x => x > 3); // 4
```

### 2. Методы строк

```javascript
// replace - принимает функцию для замены
const template = 'Hello {name}, you have {count} messages';
const data = { name: 'John', count: 5 };

const result = template.replace(/\{(\w+)\}/g, (match, key) => data[key]);
console.log(result); // 'Hello John, you have 5 messages'
```

## Практические применения

### 1. Утилиты и хелперы

```javascript
// Утилита для мемоизации
const memoize = (fn) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
};

// Утилита для задержки выполнения
const debounce = (fn, delay) => {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
};

// Утилита для ограничения частоты вызовов
const throttle = (fn, limit) => {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};
```

### 2. Валидация данных

```javascript
// Создание валидаторов
const createValidator = (validationFn, errorMessage) => {
  return (value) => {
    const isValid = validationFn(value);
    return {
      isValid,
      value,
      error: isValid ? null : errorMessage
    };
  };
};

const requiredValidator = createValidator(
  value => value && value.trim().length > 0,
  'Поле обязательно для заполнения'
);

const emailValidator = createValidator(
  value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
  'Некорректный email'
);

// Комбинирование валидаторов
const validateField = (value, ...validators) => {
  for (const validator of validators) {
    const result = validator(value);
    if (!result.isValid) {
      return result;
    }
  }
  return { isValid: true, value };
};

// Использование
const result = validateField('test@example.com', requiredValidator, emailValidator);
console.log(result); // { isValid: true, value: 'test@example.com' }
```

## Применение в фронтенд-разработке

### 1. В React компонентах

```jsx
// HOC (Higher-Order Component) для добавления логики загрузки
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <div>Загрузка...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

// Использование
const UserListWithLoading = withLoading(UserList);

// Кастомный хук как функция высшего порядка для данных
const useApi = (url, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, options);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};
```

### 2. Обработка событий

```javascript
// Создание обработчиков событий
const createEventHandler = (actionCreator) => {
  return (event) => {
    event.preventDefault();
    const action = actionCreator(event);
    // выполнить действие (например, отправить в Redux store)
    dispatch(action);
  };
};

// Пример использования
const handleLogin = createEventHandler((event) => ({
  type: 'LOGIN_REQUEST',
  credentials: {
    email: event.target.email.value,
    password: event.target.password.value
  }
}));
```

### 3. Middleware в Redux

```javascript
// Пример middleware как функции высшего порядка
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Предыдущее состояние:', store.getState());
  console.log('Действие:', action);
  
  const result = next(action);
  
  console.log('Новое состояние:', store.getState());
  return result;
};

// Асинхронный middleware
const asyncMiddleware = (store) => (next) => (action) => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  
  return next(action);
};
```

## Паттерны использования

### 1. Каррирование и частичное применение

```javascript
// Функция высшего порядка для каррирования
const curry = (fn) => {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
};

// Использование
const multiply = (a, b, c) => a * b * c;
const curriedMultiply = curry(multiply);

const multiplyByTwo = curriedMultiply(2);
const multiplyByTwoAndThree = multiplyByTwo(3);

console.log(multiplyByTwoAndThree(4)); // 24
```

### 2. Композиция функций

```javascript
// Функция для композиции функций (справа налево)
const compose = (...fns) => (value) => {
  return fns.reduceRight((acc, fn) => fn(acc), value);
};

// Функция для композиции функций (слева направо)
const pipe = (...fns) => (value) => {
  return fns.reduce((acc, fn) => fn(acc), value);
};

// Пример использования
const addOne = x => x + 1;
const double = x => x * 2;
const subtractTen = x => x - 10;

const complexOperation = pipe(addOne, double, subtractTen);
console.log(complexOperation(5)); // ((5 + 1) * 2) - 10 = 2
```

### 3. Создание специализированных функций

```javascript
// Создание функций для работы с DOM
const createDomManipulator = (selector) => {
  return {
    hide: () => document.querySelector(selector).style.display = 'none',
    show: () => document.querySelector(selector).style.display = 'block',
    addClass: (className) => document.querySelector(selector).classList.add(className),
    removeClass: (className) => document.querySelector(selector).classList.remove(className)
  };
};

// Использование
const header = createDomManipulator('#header');
header.addClass('active');
header.hide();
```

## Преимущества функций высшего порядка

1. **Повторное использование кода**: позволяют создавать гибкие и переиспользуемые функции
2. **Абстракция сложности**: скрывают детали реализации и предоставляют простой интерфейс
3. **Композиция**: позволяют комбинировать простые функции для создания сложной логики
4. **Конфигурируемость**: позволяют настраивать поведение функций через передачу других функций

## Связь с другими концепциями

- [[Чистые-функции]] - функции высшего порядка часто являются чистыми функциями
- [[Неизменяемость]] - работают хорошо с неизменяемыми структурами данных
- [[Каррирование]] - тесно связано с функциями высшего порядка
- [[Композиция-функций]] - позволяет комбинировать функции высшего порядка

## Заключение

Функции высшего порядка - мощный инструмент функционального программирования, который позволяет создавать гибкий, переиспользуемый и выразительный код. В контексте фронтенд-разработки они особенно полезны для создания переиспользуемых компонентов, хуков, middleware и утилит, что делает код более структурированным и поддерживаемым.