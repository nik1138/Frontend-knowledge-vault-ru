---
aliases: ["Immutability", "Неизменяемость данных", "Функциональное программирование - неизменяемость"]
tags: [programming, functional-programming, javascript, frontend, data-structures]
---

# Неизменяемость

**Неизменяемость** (Immutability) - это концепция, при которой данные не могут быть изменены после создания. Вместо изменения существующих данных, создаются новые структуры с необходимыми изменениями.

## Понятие неизменяемости

Неизменяемый объект - это объект, состояние которого не может быть изменено после его создания. Любые "изменения" приводят к созданию нового объекта с изменённым состоянием, в то время как оригинальный объект остаётся неизменным.

## Преимущества неизменяемости

### 1. Предсказуемость и отладка

Когда данные неизменяемы, вы точно знаете, что они не будут изменены в другом месте программы:

```javascript
const originalUser = { name: 'John', age: 30 };
const updatedUser = { ...originalUser, age: 31 };

console.log(originalUser.age); // 30 - оригинальный объект не изменился
console.log(updatedUser.age);  // 31 - новый объект с изменением
```

### 2. Упрощение тестирования

Тесты становятся более надёжными, так как нет необходимости учитывать изменения состояния между тестами:

```javascript
// Функция, которая не изменяет входные данные
const calculateDiscount = (user, discountPercent) => ({
  ...user,
  discountedPrice: user.price * (1 - discountPercent / 100)
});

// Тест
const user = { name: 'Product', price: 100 };
const result = calculateDiscount(user, 10);

console.assert(user.price === 100, 'Original user is unchanged');
console.assert(result.discountedPrice === 90, 'Discount calculated correctly');
```

### 3. Улучшенная производительность (через мемоизацию)

Неизменяемые структуры данных позволяют эффективно сравнивать объекты:

```javascript
// Эффективное сравнение - достаточно проверить ссылку
const areEqual = (obj1, obj2) => obj1 === obj2;

const state1 = { count: 1 };
const state2 = { ...state1, count: 1 }; // тот же самый логический результат
const state3 = { ...state1, count: 2 }; // другой результат

console.log(areEqual(state1, state2)); // false - разные объекты
console.log(areEqual(state1, state3)); // false - разные значения
```

### 4. Безопасность при работе с асинхронными операциями

Неизменяемые данные предотвращают гонки состояний в асинхронных операциях:

```javascript
let globalState = { users: [] };

// Небезопасно - другой процесс может изменить globalState.users
const unsafeAddUser = (user) => {
  globalState.users.push(user); // мутация
};

// Безопасно - создание нового состояния
const safeAddUser = (user) => {
  globalState = { ...globalState, users: [...globalState.users, user] };
};
```

## Реализация неизменяемости в JavaScript

### 1. Использование const

`const` предотвращает переназначение переменной, но не делает объект неизменяемым:

```javascript
const user = { name: 'John', age: 30 };
user.age = 31; // Это возможно! Объект мутирует
user.name = 'Jane'; // Это тоже возможно!

// const защищает только ссылку, а не содержимое
```

### 2. Spread оператор

Создание новых объектов и массивов без мутации:

```javascript
// Копирование массива
const originalArray = [1, 2, 3];
const newArray = [...originalArray, 4]; // [1, 2, 3, 4]

// Копирование объекта
const originalObj = { a: 1, b: 2 };
const newObj = { ...originalObj, c: 3 }; // { a: 1, b: 2, c: 3 }

// Обновление вложенных свойств
const state = {
  user: { name: 'John', profile: { age: 30 } }
};

const newState = {
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      age: 31
    }
  }
};
```

### 3. Методы массивов, не мутирующие оригинальный массив

```javascript
const numbers = [1, 2, 3, 4, 5];

// Не мутирующие методы
const doubled = numbers.map(n => n * 2);           // [2, 4, 6, 8, 10]
const evens = numbers.filter(n => n % 2 === 0);    // [2, 4]
const removed = numbers.slice(0, 2);               // [1, 2]

console.log(numbers); // [1, 2, 3, 4, 5] - оригинальный массив не изменился
```

### 4. Object.freeze()

Полная защита объекта от изменений:

```javascript
const user = Object.freeze({
  name: 'John',
  age: 30,
  address: Object.freeze({
    city: 'New York',
    zip: '10001'
  })
});

// user.name = 'Jane'; // Ошибка в strict mode, игнорируется в обычном
// user.newProp = 'value'; // Не добавляется
```

> **Важно**: `Object.freeze()` работает только на первом уровне вложенности.

### 5. Библиотеки для неизменяемых структур данных

Для более сложных случаев можно использовать библиотеки, такие как Immutable.js:

```javascript
import { Map, List } from 'immutable';

const originalMap = Map({ a: 1, b: 2 });
const newMap = originalMap.set('c', 3);

console.log(originalMap.toObject()); // { a: 1, b: 2 }
console.log(newMap.toObject());      // { a: 1, b: 2, c: 3 }
```

## Практические примеры в фронтенд-разработке

### 1. Управление состоянием в React

```jsx
import React, { useState } from 'react';

function TodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    // Правильно - создание нового массива
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };

  const toggleTodo = (id) => {
    // Правильно - создание нового массива с изменённым элементом
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          <span 
            onClick={() => toggleTodo(todo.id)}
            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
          >
            {todo.text}
          </span>
        </div>
      ))}
      <button onClick={() => addTodo('New todo')}>Add Todo</button>
    </div>
  );
}
```

### 2. Работа с Redux

```javascript
// Redux редьюсер - должен быть чистой функцией с неизменяемостью
const initialState = {
  user: null,
  loading: false,
  error: null
};

function userReducer(state = initialState, action) {
  switch (action.type) {
    case 'USER_LOGIN_REQUEST':
      return {
        ...state,
        loading: true,
        error: null
      };
    
    case 'USER_LOGIN_SUCCESS':
      return {
        ...state,
        loading: false,
        user: { ...action.payload } // создание копии пользователя
      };
    
    case 'USER_LOGIN_FAILURE':
      return {
        ...state,
        loading: false,
        error: action.payload
      };
    
    default:
      return state;
  }
}
```

### 3. Обработка форм

```javascript
// Обработка изменений формы без мутаций
const handleInputChange = (fieldName, value) => {
  setFormData({
    ...formData,
    [fieldName]: value
  });
};

// Валидация формы
const validateForm = (data) => {
  const errors = {};
  
  if (!data.email || !data.email.includes('@')) {
    errors.email = 'Invalid email';
  }
  
  if (!data.password || data.password.length < 6) {
    errors.password = 'Password too short';
  }
  
  return { ...data, errors }; // возвращаем новый объект с ошибками
};
```

## Паттерны для работы с неизменяемыми данными

### 1. Функции обновления (Update Functions)

```javascript
// Универсальная функция для обновления вложенных свойств
const updateNestedProperty = (obj, path, value) => {
  if (path.length === 1) {
    return { ...obj, [path[0]]: value };
  }
  
  const [head, ...tail] = path;
  return {
    ...obj,
    [head]: updateNestedProperty(obj[head], tail, value)
  };
};

// Использование
const state = { user: { profile: { name: 'John' } } };
const newState = updateNestedProperty(state, ['user', 'profile', 'name'], 'Jane');
```

### 2. Слияние объектов без мутаций

```javascript
// Безопасное слияние объектов
const mergeObjects = (target, source) => {
  const result = { ...target };
  
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
        result[key] = mergeObjects(result[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
  }
  
  return result;
};
```

## Связь с другими концепциями

- [[Чистые-функции]] - неизменяемость дополняет концепцию чистых функций
- [[Функции-высшего-порядка]] - часто работают с неизменяемыми структурами данных
- [[Композиция-функций]] - позволяет создавать цепочки преобразований данных

## Заключение

Неизменяемость - мощный инструмент для создания более предсказуемого и надёжного кода. Хотя в JavaScript полная неизменяемость требует дополнительных усилий, даже частичное применение этих принципов значительно улучшает качество кода, особенно в контексте фронтенд-разработки, где состояние компонентов и приложения играет ключевую роль.