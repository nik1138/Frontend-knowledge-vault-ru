---
aliases: ["Pure Functions", "Чистые функции в JavaScript", "Функциональное программирование - чистые функции"]
tags: [programming, functional-programming, javascript, frontend]
---

# Чистые функции

**Чистые функции** (Pure Functions) - это фундаментальное понятие в функциональном программировании. Это функции, которые при вызове с одинаковыми аргументами всегда возвращают одинаковый результат и не производят никаких побочных эффектов.

## Определение чистой функции

Функция считается чистой, если она удовлетворяет двум условиям:

1. **Детерминированность**: при одинаковых входных данных функция всегда возвращает одинаковый результат.
2. **Отсутствие побочных эффектов**: функция не изменяет внешнее состояние, не взаимодействует с внешним миром (не изменяет глобальные переменные, не выполняет ввод/вывод, не мутирует переданные аргументы).

## Примеры чистых функций

```javascript
// Пример чистой функции
const add = (a, b) => a + b;

// Результат всегда одинаков для одинаковых аргументов
console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5

// Функция не изменяет внешнее состояние
let counter = 0;
const increment = (x) => x + 1; // counter не изменяется
```

## Примеры нечистых функций

```javascript
// Нечистая функция - зависит от внешнего состояния
let multiplier = 2;
const multiply = (x) => x * multiplier;

// Результат может отличаться при одинаковых аргументах
console.log(multiply(5)); // 10
multiplier = 3;
console.log(multiply(5)); // 15

// Нечистая функция - имеет побочный эффект
const addToGlobalArray = (item) => {
  globalArray.push(item); // мутирует внешнюю переменную
  return item;
};

// Нечистая функция - взаимодействует с внешним миром
const getCurrentTime = () => new Date(); // результат зависит от времени вызова
```

## Преимущества чистых функций

### 1. Предсказуемость и тестирование

Поскольку чистые функции всегда возвращают одинаковый результат для одинаковых входных данных, они легко тестируются:

```javascript
// Легко тестируемая чистая функция
const calculateTax = (amount, taxRate) => amount * taxRate;

// Тест
console.assert(calculateTax(100, 0.1) === 10, 'Tax calculation is correct');
```

### 2. Кэширование (Memoization)

Результаты чистых функций можно кэшировать, так как они не зависят от внешнего состояния:

```javascript
const memoize = (fn) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
};

const expensiveCalculation = memoize((n) => {
  // Представим, что это дорогостоящая операция
  console.log('Выполняем вычисления...');
  return n * n;
});

console.log(expensiveCalculation(5)); // Выполняем вычисления... 25
console.log(expensiveCalculation(5)); // 25 (из кэша)
```

### 3. Параллельное выполнение

Чистые функции можно безопасно выполнять параллельно, так как они не зависят от внешнего состояния и не изменяют его:

```javascript
// Эти функции могут выполняться параллельно
const processItem1 = (item) => item * 2;
const processItem2 = (item) => item + 10;

const data = [1, 2, 3, 4, 5];
const results = data.map(item => [
  processItem1(item),
  processItem2(item)
]);
```

### 4. Рефакторинг и оптимизация

Чистые функции можно безопасно перемещать, удалять и заменять, не опасаясь побочных эффектов.

## Практические рекомендации

### 1. Избегайте мутаций

```javascript
// Плохо - мутация массива
const addItem = (array, item) => {
  array.push(item); // мутирует оригинальный массив
  return array;
};

// Хорошо - создание нового массива
const addItem = (array, item) => [...array, item];
```

### 2. Не используйте внешние переменные

```javascript
// Плохо - зависит от внешней переменной
const taxRate = 0.1;
const calculateTotal = (price) => price + (price * taxRate);

// Хорошо - все зависимости передаются как аргументы
const calculateTotal = (price, taxRate) => price + (price * taxRate);
```

### 3. Избегайте побочных эффектов

```javascript
// Плохо - побочный эффект (вывод в консоль)
const calculateAndLog = (a, b) => {
  const result = a + b;
  console.log(result); // побочный эффект
  return result;
};

// Хорошо - разделение логики и побочных эффектов
const calculate = (a, b) => a + b;
const calculateAndLog = (a, b) => {
  const result = calculate(a, b);
  console.log(result);
  return result;
};
```

## Применение в фронтенд-разработке

### В React компонентах

Функциональные компоненты должны быть чистыми в отношении своих props:

```jsx
// Чистый компонент - зависит только от props
const UserCard = ({ user }) => (
  <div>
    <h2>{user.name}</h2>
    <p>{user.email}</p>
  </div>
);
```

### В утилитах и хелперах

```javascript
// Чистая утилита для форматирования даты
const formatDate = (date, format = 'DD/MM/YYYY') => {
  // реализация форматирования
  return formattedDate;
};

// Чистая утилита для валидации email
const validateEmail = (email) => {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
};
```

## Связь с другими концепциями

- [[Неизменяемость]] - чистые функции работают лучше с неизменяемыми данными
- [[Функции-высшего-порядка]] - часто используются вместе с чистыми функциями
- [[Композиция-функций]] - позволяет комбинировать чистые функции

## Заключение

Чистые функции - это основа функционального программирования. Использование чистых функций делает код более предсказуемым, тестируемым и поддерживаемым. Они особенно полезны в фронтенд-разработке, где важна стабильность и предсказуемость компонентов и бизнес-логики.