---
aliases: [ФП, Functional Programming]
tags: [programming, frontend, javascript, paradigm]
---

# Функциональное программирование

**Функциональное программирование** — это парадигма программирования, в которой вычисления описываются как вычисление значений функций. В отличие от императивного программирования, функциональное программирование избегает использования изменяемого состояния и изменяющих данные.

## Основные принципы

### 1. Чистые функции (Pure Functions)

**Чистая функция** — это функция, которая:
- Возвращает одинаковый результат при одинаковых аргументах
- Не имеет побочных эффектов (не изменяет внешнее состояние)

```javascript
// Чистая функция
const add = (a, b) => a + b;

// Нечистая функция (зависит от внешнего состояния)
let multiplier = 2;
const multiplyByGlobal = (a) => a * multiplier;
```

### 2. Неизменяемость (Immutability)

В функциональном программировании данные не изменяются, а создаются новые структуры данных:

```javascript
// Императивный подход (изменение данных)
const user = { name: 'Иван', age: 25 };
user.age = 26; // Изменяем существующий объект

// Функциональный подход (неизменяемость)
const updatedUser = { ...user, age: 26 }; // Создаем новый объект
```

### 3. Функции высшего порядка

Функции, которые принимают другие функции как аргументы или возвращают их:

```javascript
// Функция высшего порядка
const applyOperation = (value, operation) => operation(value);

// Примеры использования
const double = x => x * 2;
const square = x => x * x;

console.log(applyOperation(5, double)); // 10
console.log(applyOperation(5, square)); // 25
```

## Применение в фронтенд-разработке

### Работа с массивами

```javascript
// Использование методов массивов (map, filter, reduce)
const users = [
  { name: 'Иван', age: 25, active: true },
  { name: 'Мария', age: 30, active: false },
  { name: 'Петр', age: 35, active: true }
];

// Получить имена активных пользователей
const activeUserNames = users
  .filter(user => user.active)
  .map(user => user.name);

// Подсчитать общий возраст активных пользователей
const totalAge = users
  .filter(user => user.active)
  .reduce((sum, user) => sum + user.age, 0);
```

### Функции компонентов в React

```jsx
// Функциональный компонент
const UserCard = ({ user }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>Возраст: {user.age}</p>
    </div>
  );
};

// Компонент с логикой
const UserList = ({ users }) => {
  const activeUsers = users.filter(user => user.active);
  
  return (
    <div className="user-list">
      {activeUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

### Управление состоянием

```javascript
// Функциональное обновление состояния
const updateCounter = (prevState, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return prevState + 1;
    case 'DECREMENT':
      return prevState - 1;
    case 'RESET':
      return 0;
    default:
      return prevState;
  }
};

// Использование в React
const [counter, dispatch] = useReducer(updateCounter, 0);
```

## Преимущества в фронтенде

- **Предсказуемость**: чистые функции легче тестировать и отлаживать
- **Повторное использование**: функции легко переиспользуются в разных частях приложения
- **Меньше багов**: отсутствие изменяемого состояния уменьшает количество ошибок
- **Простота тестирования**: чистые функции не зависят от внешнего состояния

## Часто используемые паттерны

### Композиция функций

```javascript
// Создание новой функции путем композиции других
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

const addOne = x => x + 1;
const double = x => x * 2;
const subtractTen = x => x - 10;

const complexOperation = compose(subtractTen, double, addOne);
console.log(complexOperation(5)); // ((5 + 1) * 2) - 10 = 2
```

### Каррирование

```javascript
// Каррированная функция
const multiply = a => b => a * b;

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

## Связанные концепции

- [[Иммутабельность]] - важный аспект функционального программирования
- [[Управление состоянием]] - функциональный подход к управлению состоянием
- [[Декларативное программирование]] - связанная парадигма
- [[Абстракция]] - функции как абстракции
- [[Композиция-и-агрегация]] - композиция функций

## Лучшие практики

1. **Пишите чистые функции** whenever possible
2. **Избегайте мутаций** - используйте spread-оператор, Object.assign и т.д.
3. **Используйте встроенные методы массивов** - map, filter, reduce вместо циклов
4. **Создавайте переиспользуемые функции** - компоненты и утилиты
5. **Применяйте каррирование и композицию** для создания гибких функций

## Заключение

Функциональное программирование предоставляет мощные инструменты для создания более предсказуемых и тестируемых фронтенд-приложений. Его принципы особенно хорошо подходят для управления состоянием и обработки данных в современных веб-приложениях.