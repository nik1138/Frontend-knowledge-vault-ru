---
aliases: ["Function Composition", "Композиция функций", "Функциональное программирование - композиция"]
tags: [programming, functional-programming, javascript, frontend, functions]
---

# Композиция функций

**Композиция функций** - это техника комбинирования двух или более функций для создания новой функции, где результат одной функции передается в качестве аргумента следующей. Это одна из ключевых концепций функционального программирования.

## Определение композиции

Математически композиция функций f и g записывается как (f ∘ g)(x) = f(g(x)). В программировании это означает, что мы сначала применяем функцию g к аргументу x, а затем применяем функцию f к результату g(x).

## Простые примеры композиции

### 1. Базовая композиция

```javascript
// Определим простые функции
const addTen = x => x + 10;
const multiplyByTwo = x => x * 2;
const square = x => x * x;

// Ручная композиция
const result = square(multiplyByTwo(addTen(5))); // ((5 + 10) * 2) ^ 2 = 900

// Функция композиции для двух функций
const compose2 = (f, g) => (x) => f(g(x));

// Использование
const addTenThenMultiplyByTwo = compose2(multiplyByTwo, addTen);
console.log(addTenThenMultiplyByTwo(5)); // (5 + 10) * 2 = 30

// Композиция трех функций
const compose3 = (f, g, h) => (x) => f(g(h(x)));
const complexOperation = compose3(square, multiplyByTwo, addTen);
console.log(complexOperation(5)); // ((5 + 10) * 2) ^ 2 = 900
```

### 2. Универсальная функция композиции

```javascript
// Композиция произвольного количества функций (справа налево)
const compose = (...fns) => (value) => {
  return fns.reduceRight((acc, fn) => fn(acc), value);
};

// Пример использования
const addOne = x => x + 1;
const double = x => x * 2;
const subtractTen = x => x - 10;

const complexFunction = compose(
  subtractTen,  // 3. Затем вычесть 10
  double,       // 2. Затем умножить на 2  
  addOne        // 1. Сначала прибавить 1
);

console.log(complexFunction(5)); // ((5 + 1) * 2) - 10 = 2
```

### 3. Функция композиции слева направо (pipe)

```javascript
// Композиция слева направо - часто более интуитивна
const pipe = (...fns) => (value) => {
  return fns.reduce((acc, fn) => fn(acc), value);
};

// Тот же пример, но с pipe - более читаемый порядок
const complexFunctionPipe = pipe(
  addOne,       // 1. Сначала прибавить 1
  double,       // 2. Затем умножить на 2
  subtractTen   // 3. Затем вычесть 10
);

console.log(complexFunctionPipe(5)); // ((5 + 1) * 2) - 10 = 2
```

## Практические применения

### 1. Обработка данных

```javascript
// Композиция для обработки пользовательских данных
const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const addPrefix = prefix => str => `${prefix}${str}`;
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);

// Создание цепочки обработки
const processUsername = pipe(
  trim,
  toLowerCase,
  addPrefix('@'),
  capitalize
);

console.log(processUsername('  JohnDoe  ')); // '@Johndoe'

// Композиция для обработки массива данных
const getUsersEmails = pipe(
  users => users.filter(user => user.active),
  users => users.map(user => user.email),
  emails => emails.filter(email => email.includes('@'))
);
```

### 2. Валидация данных

```javascript
// Функции валидации
const isString = value => typeof value === 'string';
const isLongEnough = minLength => str => str.length >= minLength;
const hasSpecialChar = str => /[!@#$%^&*]/.test(str);

// Композиция проверок
const validatePassword = pipe(
  isString,
  value => value && isLongEnough(8)(value),
  value => value && hasSpecialChar(value)
);

console.log(validatePassword('mypass123')); // false (нет спецсимвола)
console.log(validatePassword('mypass123!')); // true
```

### 3. Трансформация объектов

```javascript
// Функции для работы с объектами
const pick = (keys) => obj => {
  const result = {};
  keys.forEach(key => {
    if (key in obj) result[key] = obj[key];
  });
  return result;
};

const omit = (keys) => obj => {
  const result = { ...obj };
  keys.forEach(key => delete result[key]);
  return result;
};

const renameKey = (oldKey, newKey) => obj => {
  const result = { ...obj };
  if (oldKey in result) {
    result[newKey] = result[oldKey];
    delete result[oldKey];
  }
  return result;
};

// Композиция для трансформации объекта
const transformUser = pipe(
  pick(['id', 'name', 'email', 'createdAt']),
  renameKey('createdAt', 'created_at'),
  obj => ({ ...obj, processed: true })
);

const user = {
  id: 1,
  name: 'John',
  email: 'john@example.com',
  createdAt: '2023-01-01',
  password: 'secret'
};

console.log(transformUser(user));
// {
//   id: 1,
//   name: 'John', 
//   email: 'john@example.com',
//   created_at: '2023-01-01',
//   processed: true
// }
```

## Применение в фронтенд-разработке

### 1. В React с хуками

```jsx
import { useMemo } from 'react';

// Композиция функций для обработки данных
const useProcessedData = (rawData, processors) => {
  return useMemo(() => {
    return pipe(...processors)(rawData);
  }, [rawData, ...processors]);
};

// Пример использования
const UserProfile = ({ userId }) => {
  const userData = useApi(`/users/${userId}`);
  
  const processors = [
    user => ({ ...user, fullName: `${user.firstName} ${user.lastName}` }),
    user => ({ ...user, avatar: user.avatar || '/default-avatar.png' }),
    user => ({ ...user, isOnline: user.lastSeen > Date.now() - 300000 }) // 5 минут
  ];
  
  const processedUser = useProcessedData(userData, processors);
  
  if (!processedUser) return <div>Loading...</div>;
  
  return (
    <div>
      <img src={processedUser.avatar} alt="Avatar" />
      <h2>{processedUser.fullName}</h2>
      <span>{processedUser.isOnline ? 'Online' : 'Offline'}</span>
    </div>
  );
};
```

### 2. Middleware в Redux

```javascript
// Композиция middleware
const composeMiddleware = (...middlewares) => {
  return (store) => (next) => (action) => {
    return middlewares.reduceRight(
      (acc, middleware) => middleware(store)(acc),
      next
    )(action);
  };
};

// Пример использования
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Action:', action);
  return next(action);
};

const crashReporter = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (err) {
    console.error('Caught an exception!', err);
    throw err;
  }
};

const composedMiddleware = composeMiddleware(loggerMiddleware, crashReporter);
```

### 3. Обработка событий

```javascript
// Композиция обработчиков событий
const pipeHandlers = (...handlers) => (event) => {
  handlers.forEach(handler => {
    if (typeof handler === 'function') {
      handler(event);
    }
  });
};

// Использование в компоненте
const EnhancedButton = ({ onClick, onAnalytics, onValidation }) => {
  const handleClick = pipeHandlers(
    onValidation,    // Сначала валидация
    onAnalytics,     // Потом отправка аналитики
    onClick          // Потом основной обработчик
  );
  
  return <button onClick={handleClick}>Click me</button>;
};
```

## Продвинутые паттерны

### 1. Условная композиция

```javascript
// Функция для условной композиции
const conditionalPipe = (condition, fnIfTrue, fnIfFalse) => (value) => {
  return condition(value) 
    ? fnIfTrue(value) 
    : fnIfFalse ? fnIfFalse(value) : value;
};

// Пример использования
const processNumber = pipe(
  x => x * 2,
  conditionalPipe(
    x => x > 10,           // условие
    x => x - 5,            // если больше 10
    x => x + 1             // если меньше или равно 10
  ),
  x => x * x
);

console.log(processNumber(3));  // ((3*2)+1)^2 = 49
console.log(processNumber(8));  // ((8*2)-5)^2 = 121
```

### 2. Композиция с асинхронными функциями

```javascript
// Композиция асинхронных функций
const asyncPipe = (...fns) => async (value) => {
  return await fns.reduce(async (acc, fn) => {
    return fn(await acc);
  }, Promise.resolve(value));
};

// Пример асинхронной композиции
const fetchUserData = asyncPipe(
  id => fetch(`/api/users/${id}`),
  response => response.json(),
  user => ({ ...user, fetchedAt: new Date() })
);

// Использование
fetchUserData(123).then(userData => {
  console.log(userData);
});
```

### 3. Композиция с обработкой ошибок

```javascript
// Композиция с безопасной обработкой ошибок
const safePipe = (...fns) => (value) => {
  try {
    return fns.reduce((acc, fn) => {
      try {
        return fn(acc);
      } catch (error) {
        console.warn('Function failed:', error.message);
        return acc; // Возвращаем предыдущее значение при ошибке
      }
    }, value);
  } catch (error) {
    console.error('Pipeline failed completely:', error);
    return null;
  }
};

// Пример использования
const processData = safePipe(
  x => x.toUpperCase(),
  x => x.replace(' ', '_'),
  x => JSON.parse(x) // вызовет ошибку, но pipeline продолжит работу
);

console.log(processData('hello world')); // 'HELLO_WORLD' (ошибка игнорируется)
```

## Преимущества композиции функций

1. **Модульность**: позволяет создавать сложную логику из простых, переиспользуемых функций
2. **Читаемость**: делает поток данных более понятным и последовательным
3. **Тестируемость**: маленькие функции легче тестировать отдельно
4. **Поддерживаемость**: изменения в одной функции не влияют на другие
5. **Повторное использование**: одни и те же функции можно комбинировать по-разному

## Лучшие практики

### 1. Именование композиций

```javascript
// Хорошо: понятные имена для композиций
const formatDisplayUser = pipe(
  validateUser,
  normalizeUserData,
  addComputedProperties,
  sanitizeForDisplay
);

// Плохо: неясное имя
const fn = pipe(validate, normalize, compute, sanitize);
```

### 2. Ограничение сложности

```javascript
// Хорошо: разбиение сложной композиции
const validateAndNormalize = pipe(validate, normalize);
const addComputed = pipe(addTimestamp, addStatus);
const processUser = pipe(validateAndNormalize, addComputed);

// Плохо: слишком длинная цепочка
const processUser = pipe(
  validate, normalize, addTimestamp, addStatus, sanitize, format, etc...
);
```

### 3. Использование типизации (TypeScript)

```typescript
type User = { id: number; name: string; email: string };
type ProcessedUser = User & { createdAt: Date; isActive: boolean };

const processUser: (user: User) => ProcessedUser = pipe(
  addTimestamp,
  markActiveStatus
);
```

## Связь с другими концепциями

- [[Функции-высшего-порядка]] - композиция является примером функции высшего порядка
- [[Каррирование]] - часто используется вместе с композицией
- [[Чистые-функции]] - композиция работает лучше с чистыми функциями
- [[Неизменяемость]] - поддерживает неизменяемый подход к данным

## Заключение

Композиция функций - мощный инструмент функционального программирования, который позволяет создавать сложную логику из простых, переиспользуемых компонентов. В контексте фронтенд-разработки композиция особенно полезна для обработки данных, валидации, преобразования объектов и построения цепочек вычислений. Правильное использование композиции делает код более читаемым, тестируемым и поддерживаемым.