---
aliases: ["Currying", "Каррирование функций", "Функциональное программирование - каррирование"]
tags: [programming, functional-programming, javascript, frontend, functions]
---

# Каррирование

**Каррирование** (Currying) - это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент. Названо в честь логика Хаскелла Карри.

## Понятие каррирования

Каррирование преобразует функцию вида `f(a, b, c)` в `f(a)(b)(c)`. Вместо того чтобы вызывать функцию с несколькими аргументами за раз, мы вызываем её с первым аргументом, что возвращает новую функцию, которая принимает второй аргумент, и так далее.

## Примеры каррирования

### 1. Простое каррирование

```javascript
// Обычная функция
const multiply = (a, b, c) => a * b * c;

// Каррированная функция
const curriedMultiply = (a) => (b) => (c) => a * b * c;

console.log(multiply(2, 3, 4));       // 24
console.log(curriedMultiply(2)(3)(4)); // 24

// Преимущество каррирования - частичное применение
const multiplyByTwo = curriedMultiply(2);
const multiplyByTwoAndThree = multiplyByTwo(3);

console.log(multiplyByTwoAndThree(4)); // 24
console.log(multiplyByTwoAndThree(5)); // 30
```

### 2. Каррирование с произвольным количеством аргументов

```javascript
// Универсальная функция для каррирования
const curry = (fn) => {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
};

// Использование универсальной функции каррирования
const add = (a, b, c, d) => a + b + c + d;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)(4));     // 10
console.log(curriedAdd(1, 2)(3, 4));     // 10
console.log(curriedAdd(1, 2, 3)(4));     // 10
console.log(curriedAdd(1)(2, 3, 4));     // 10
```

### 3. Каррирование для специализации функций

```javascript
// Каррирование для создания специализированных функций
const formatCurrency = (currency, amount) => `${amount.toFixed(2)} ${currency}`;
const curriedFormatCurrency = curry(formatCurrency);

// Создание специализированных функций
const formatUSD = curriedFormatCurrency('USD');
const formatEUR = curriedFormatCurrency('EUR');

console.log(formatUSD(123.456)); // '123.46 USD'
console.log(formatEUR(123.456)); // '123.46 EUR'

// Каррирование для фильтрации
const filterByProperty = curry((property, value, obj) => obj[property] === value);
const users = [
  { name: 'John', role: 'admin' },
  { name: 'Jane', role: 'user' },
  { name: 'Bob', role: 'admin' }
];

const isAdmin = filterByProperty('role', 'admin');
const adminUsers = users.filter(isAdmin);
console.log(adminUsers); // [{ name: 'John', role: 'admin' }, { name: 'Bob', role: 'admin' }]
```

## Практические применения

### 1. Валидация данных

```javascript
// Каррирование для создания валидаторов
const validate = curry((validator, message, value) => {
  if (!validator(value)) {
    throw new Error(message);
  }
  return value;
});

const isEmail = (str) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str);
const isNotEmpty = (str) => str && str.trim().length > 0;

const validateEmail = validate(isEmail, 'Invalid email address');
const validateRequired = validate(isNotEmpty, 'Field is required');

// Использование
try {
  const email = validateRequired('user@example.com');
  const validEmail = validateEmail(email);
  console.log('Email is valid:', validEmail);
} catch (error) {
  console.error(error.message);
}
```

### 2. Обработка массивов

```javascript
// Каррирование для функций обработки массивов
const map = curry((fn, arr) => arr.map(fn));
const filter = curry((predicate, arr) => arr.filter(predicate));
const reduce = curry((reducer, initialValue, arr) => arr.reduce(reducer, initialValue));

// Создание переиспользуемых трансформаций
const doubleAll = map(x => x * 2);
const getEvenNumbers = filter(x => x % 2 === 0);
const sum = reduce((acc, curr) => acc + curr, 0);

const numbers = [1, 2, 3, 4, 5, 6];
const result = sum(doubleAll(getEvenNumbers(numbers)));
console.log(result); // (2*2) + (4*2) + (6*2) = 4 + 8 + 12 = 24
```

### 3. Создание middleware

```javascript
// Каррирование для создания middleware
const createMiddleware = curry((condition, action, next) => {
  return (req, res) => {
    if (condition(req)) {
      action(req, res);
    }
    next(req, res);
  };
});

const isAuthenticated = (req) => req.user && req.user.authenticated;
const logRequest = (req, res) => console.log(`Request: ${req.method} ${req.url}`);

const authMiddleware = createMiddleware(isAuthenticated, logRequest);
```

## Применение в фронтенд-разработке

### 1. В React компонентах

```jsx
// Каррирование для создания специализированных обработчиков
const createClickHandler = curry((action, payload, event) => {
  event.preventDefault();
  action(payload);
});

const handleUserAction = createClickHandler((userId) => {
  // выполнить действие с пользователем
  console.log('User action:', userId);
});

// В компоненте
const UserList = ({ users }) => (
  <div>
    {users.map(user => (
      <div key={user.id}>
        <span>{user.name}</span>
        <button onClick={handleUserAction(user.id)}>
          Выполнить действие
        </button>
      </div>
    ))}
  </div>
);
```

### 2. Работа с API

```javascript
// Каррирование для создания API клиентов
const createApiCall = curry((baseUrl, endpoint, options = {}) => {
  return fetch(`${baseUrl}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  }).then(response => response.json());
});

const githubApiCall = createApiCall('https://api.github.com');
const getUser = githubApiCall('/users/');
const getRepos = githubApiCall('/users/repos');

// Использование
getUser('octocat').then(user => console.log(user));
getRepos('octocat').then(repos => console.log(repos));
```

### 3. Обработка форм

```javascript
// Каррирование для валидации форм
const validateField = curry((validators, fieldName, value) => {
  const errors = [];
  
  for (const validator of validators) {
    if (!validator.test(value)) {
      errors.push(validator.message);
    }
  }
  
  return {
    fieldName,
    value,
    errors,
    isValid: errors.length === 0
  };
});

const emailValidators = [
  { test: (v) => v && v.length > 0, message: 'Email is required' },
  { test: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v), message: 'Invalid email format' }
];

const validateEmailField = validateField(emailValidators, 'email');

// Использование
const result = validateEmailField('invalid-email');
console.log(result); // { fieldName: 'email', value: 'invalid-email', errors: ['Invalid email format'], isValid: false }
```

## Продвинутые паттерны

### 1. Каррирование с поддержкой массивов аргументов

```javascript
// Продвинутая версия каррирования с поддержкой вызова с несколькими аргументами
const advancedCurry = (fn) => {
  const curried = (...args) => {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return (...nextArgs) => {
      return curried.apply(this, [...args, ...nextArgs]);
    };
  };
  
  return curried;
};

// Пример с возможностью передачи массива аргументов
const sum = (a, b, c, d) => a + b + c + d;
const curriedSum = advancedCurry(sum);

console.log(curriedSum(1)(2, 3)(4)); // 10
```

### 2. Каррирование с сохранением контекста

```javascript
// Каррирование с сохранением контекста (this)
const curryWithContext = (fn) => {
  const curried = function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return (...nextArgs) => {
      return curried.apply(this, [...args, ...nextArgs]);
    };
  };
  
  return curried;
};

// Пример использования с методом объекта
const calculator = {
  base: 10,
  multiply: function(a, b) {
    return this.base * a * b;
  }
};

const curriedMultiply = curryWithContext(calculator.multiply).bind(calculator);
const multiplyByBase = curriedMultiply(2); // теперь умножает на base * 2 = 10 * 2 = 20
console.log(multiplyByBase(3)); // 60 (10 * 2 * 3)
```

### 3. Комбинирование с композицией

```javascript
// Комбинирование каррирования с композицией
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

// Каррированные функции для композиции
const add = curry((a, b) => a + b);
const multiply = curry((a, b) => a * b);
const subtract = curry((a, b) => a - b);

// Создание сложной функции через композицию каррированных функций
const complexCalculation = compose(
  subtract(100),    // 100 - result
  multiply(2),      // result * 2  
  add(10)           // result + 10
);

console.log(complexCalculation(5)); // 100 - ((5 + 10) * 2) = 100 - 30 = 70
```

## Преимущества каррирования

1. **Частичное применение**: позволяет создавать новые функции с предустановленными аргументами
2. **Повторное использование**: каррированные функции легко комбинируются
3. **Композиция**: идеально подходит для построения цепочек преобразований
4. **Читаемость**: делает код более декларативным и понятным
5. **Гибкость**: позволяет легко настраивать поведение функций

## Связь с другими концепциями

- [[Функции-высшего-порядка]] - каррирование тесно связано с функциями высшего порядка
- [[Композиция-функций]] - часто используется вместе с композицией
- [[Чистые-функции]] - каррированные функции обычно являются чистыми
- [[Функциональное-программирование]] - фундаментальная концепция функционального подхода

## Заключение

Каррирование - мощный инструмент функционального программирования, который позволяет создавать гибкие и переиспользуемые функции. В контексте фронтенд-разработки каррирование особенно полезно для создания специализированных обработчиков, валидаторов, API клиентов и других переиспользуемых компонентов логики. Оно способствует написанию более чистого, модульного и легко тестируемого кода.