---
aliases: [Форматирование дат, Локализация времени, Работа с датами]
tags: [programming, localization, dates, frontend, javascript]
---

# Локализация дат и времени

## Обзор

Локализация дат и времени — это процесс адаптации отображения дат, времени и временных интервалов в соответствии с культурными и региональными стандартами пользователя. Это включает в себя различные форматы представления дат, часовые пояса, названия месяцев и дней недели, а также различные календарные системы.

## Основные аспекты локализации дат

### Форматы дат

Разные регионы используют различные порядки дней, месяцев и лет:

- США: MM/DD/YYYY (02/14/2023)
- Европа: DD/MM/YYYY (14/02/2023)
- Китай: YYYY年MM月DD日 (2023年02月14日)

### Форматы времени

- 12-часовой формат: 2:30 PM
- 24-часовой формат: 14:30
- Различные обозначения AM/PM в разных культурах

## Встроенные возможности JavaScript

### Intl.DateTimeFormat

Современный способ форматирования дат с учётом локали:

```javascript
const date = new Date();

// Базовое форматирование
const formattedDate = new Intl.DateTimeFormat('ru-RU').format(date);
console.log(formattedDate); // Например: 14.02.2023

// Расширенные опции форматирования
const options = {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  weekday: 'long',
  hour: '2-digit',
  minute: '2-digit'
};

const detailedDate = new Intl.DateTimeFormat('ru-RU', options).format(date);
console.log(detailedDate); // Например: вторник, 14 февраля 2023 г., 14:30
```

### Форматирование для разных локалей

```javascript
const date = new Date('2023-02-14T14:30:00');

const formats = {
  'ru-RU': new Intl.DateTimeFormat('ru-RU').format(date),
  'en-US': new Intl.DateTimeFormat('en-US').format(date),
  'ja-JP': new Intl.DateTimeFormat('ja-JP').format(date),
  'ar-EG': new Intl.DateTimeFormat('ar-EG', { 
    hour: '2-digit', 
    minute: '2-digit' 
  }).format(date)
};

console.log(formats);
// {
//   'ru-RU': '14.02.2023',
//   'en-US': '2/14/2023',
//   'ja-JP': '2023/2/14',
//   'ar-EG': '02:30 م'
// }
```

## Часовые пояса

### Работа с часовыми поясами

```javascript
const date = new Date();

// Отображение в конкретном часовом поясе
const options = {
  timeZone: 'Europe/Moscow',
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit'
};

const moscowTime = new Intl.DateTimeFormat('ru-RU', options).format(date);
console.log(`Москва: ${moscowTime}`);

// То же время в другом часовом поясе
options.timeZone = 'America/New_York';
const nyTime = new Intl.DateTimeFormat('en-US', options).format(date);
console.log(`Нью-Йорк: ${nyTime}`);
```

### Определение часового пояса пользователя

```javascript
// Определение часового пояса браузера
const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
console.log(`Часовой пояс пользователя: ${userTimeZone}`);

// Использование часового пояса в форматировании
const date = new Date();
const options = {
  timeZone: userTimeZone,
  timeZoneName: 'short'
};

const formattedWithTz = new Intl.DateTimeFormat('ru-RU', options).format(date);
console.log(formattedWithTz);
```

## Относительное время

### Форматирование относительного времени

```javascript
// Относительное время (например, "2 часа назад")
const rtf = new Intl.RelativeTimeFormat('ru', { numeric: 'auto' });

const now = Date.now();
const pastDate = new Date(now - 2 * 60 * 60 * 1000); // 2 часа назад

const diffInSeconds = Math.floor((pastDate - now) / 1000);
const diffInMinutes = Math.floor(diffInSeconds / 60);
const diffInHours = Math.floor(diffInMinutes / 60);

let relativeTime;
if (Math.abs(diffInHours) < 24) {
  relativeTime = rtf.format(diffInHours, 'hour');
} else {
  const diffInDays = Math.floor(diffInHours / 24);
  relativeTime = rtf.format(diffInDays, 'day');
}

console.log(relativeTime); // "2 часа назад"
```

### Расширенный пример относительного времени

```javascript
class RelativeTimeFormatter {
  constructor(locale = 'ru-RU') {
    this.locale = locale;
    this.units = {
      second: 60,
      minute: 60,
      hour: 24,
      day: 7,
      week: 4.35,
      month: 12
    };
  }

  format(date) {
    const rtf = new Intl.RelativeTimeFormat(this.locale, { numeric: 'auto' });
    const now = Date.now();
    const diffInSeconds = Math.floor((date - now) / 1000);

    let divisor = 1;
    let unit;

    for (const [u, max] of Object.entries(this.units)) {
      if (Math.abs(diffInSeconds) < max * divisor) {
        unit = u;
        break;
      }
      divisor *= max;
    }

    if (!unit) {
      unit = 'year';
    }

    const value = Math.floor(diffInSeconds / divisor);
    return rtf.format(value, unit);
  }
}

// Использование
const formatter = new RelativeTimeFormatter('ru-RU');
const date = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000); // 3 дня назад
console.log(formatter.format(date)); // "3 дня назад"
```

## Календарные системы

### Поддержка различных календарей

```javascript
// Григорианский календарь (по умолчанию)
const gregorian = new Intl.DateTimeFormat('ru-RU', {
  calendar: 'gregory',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

// Исламский календарь
const islamic = new Intl.DateTimeFormat('ar-SA', {
  calendar: 'islamic',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

// Ивритский календарь
const hebrew = new Intl.DateTimeFormat('he-IL', {
  calendar: 'hebrew',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

const date = new Date();
console.log('Григорианский:', gregorian.format(date));
console.log('Исламский:', islamic.format(date));
console.log('Ивритский:', hebrew.format(date));
```

## Работа с библиотеками

### Date-fns

```javascript
import { format, formatRelative, formatDistance } from 'date-fns';
import { ru, enUS, de } from 'date-fns/locale';

const date = new Date();

// Форматирование с локализацией
const formatted = format(date, "d MMMM yyyy 'года'", { locale: ru });
console.log(formatted); // Например: 14 февраля 2023 года

// Относительное время
const relative = formatRelative(date, new Date(), { locale: ru });
console.log(relative); // "сегодня"

// Расстояние во времени
const distance = formatDistance(
  new Date(Date.now() - 2 * 60 * 60 * 1000), 
  new Date(), 
  { locale: ru, addSuffix: true }
);
console.log(distance); // "2 часа назад"
```

### Day.js с плагинами

```javascript
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import localizedFormat from 'dayjs/plugin/localizedFormat';
import 'dayjs/locale/ru';
import 'dayjs/locale/en';

dayjs.extend(relativeTime);
dayjs.extend(localizedFormat);

// Установка локали
dayjs.locale('ru');
const now = dayjs();

console.log(now.format('L')); // 14.02.2023
console.log(now.fromNow()); // 2 часа назад

// Смена локали
dayjs.locale('en');
console.log(now.format('L')); // 02/14/2023
```

## Практические рекомендации

### 1. Хранение дат

- Храните даты в UTC в базе данных
- Конвертируйте в локальное время только для отображения
- Используйте ISO 8601 формат для передачи данных

```javascript
// Хранение в UTC
const utcDate = new Date().toISOString(); // "2023-02-14T12:30:00.000Z"

// Отображение в локальном времени
const localDate = new Intl.DateTimeFormat('ru-RU').format(new Date(utcDate));
```

### 2. Обработка пользовательского ввода

```javascript
// Парсинг даты с учётом локали пользователя
function parseLocalizedDate(dateString, locale) {
  // Определение формата на основе локали
  const formatPatterns = {
    'en-US': /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/, // MM/DD/YYYY
    'ru-RU': /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/, // DD.MM.YYYY
    'fr-FR': /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/  // DD/MM/YYYY
  };
  
  const pattern = formatPatterns[locale] || formatPatterns['en-US'];
  const match = dateString.match(pattern);
  
  if (match) {
    const [, part1, part2, year] = match;
    // Логика парсинга зависит от локали
    if (locale === 'en-US') {
      return new Date(year, part1 - 1, part2);
    } else {
      return new Date(year, part2 - 1, part1);
    }
  }
  
  return null;
}
```

### 3. Валидация дат

```javascript
// Проверка корректности даты
function isValidDate(date) {
  return date instanceof Date && !isNaN(date);
}

// Валидация с учётом локали
function validateLocalizedDate(dateString, locale) {
  const parsed = parseLocalizedDate(dateString, locale);
  return isValidDate(parsed) && parsed.toString() !== 'Invalid Date';
}
```

## Тестирование локализации дат

### Unit-тесты

```javascript
import { describe, it, expect } from 'vitest';

describe('Date localization', () => {
  it('should format date correctly in Russian locale', () => {
    const date = new Date(2023, 1, 14); // 14 февраля 2023
    const formatted = new Intl.DateTimeFormat('ru-RU').format(date);
    
    // Проверка формата дд.мм.гггг
    expect(formatted).toMatch(/^\d{2}\.\d{2}\.\d{4}$/);
  });

  it('should format date differently for different locales', () => {
    const date = new Date(2023, 1, 14);
    
    const ruFormat = new Intl.DateTimeFormat('ru-RU').format(date);
    const usFormat = new Intl.DateTimeFormat('en-US').format(date);
    
    expect(ruFormat).not.toEqual(usFormat);
  });

  it('should handle relative time correctly', () => {
    const rtf = new Intl.RelativeTimeFormat('ru-RU', { numeric: 'auto' });
    const result = rtf.format(-1, 'day');
    
    expect(result).toContain('вчера');
  });
});
```

## Заключение

Локализация дат и времени требует внимательного подхода к различиям в культурных стандартах. Использование встроенных возможностей JavaScript (Intl API) или специализированных библиотек позволяет создавать интерфейсы, адаптированные под различные региональные особенности.

> [!tip]
> Всегда учитывайте часовые пояса при работе с датами и времени. Храните в UTC, отображайте в локальном времени пользователя.

> [!warning]
> Разные страны могут использовать разные форматы дат, даже в пределах одного языка. Например, британский и американский английский используют разные порядки дня и месяца.