---
aliases: [Всплытие событий, Перехват событий, Event Bubbling, Event Capturing]
tags: [javascript, events, frontend, programming]
---

# Всплытие-и-перехват-событий

## Введение

Всплытие и перехват событий - это два механизма, описывающих порядок, в котором обрабатываются события при взаимодействии с вложенными элементами DOM. Понимание этих концепций критически важно для правильной обработки событий в сложных веб-приложениях.

## Фазы обработки событий

Когда событие происходит на элементе, оно проходит через три фазы:

1. **Фаза захвата (Capturing Phase)** - событие движется от корня документа к целевому элементу
2. **Фаза цели (Target Phase)** - событие достигает целевого элемента
3. **Фаза всплытия (Bubbling Phase)** - событие всплывает от целевого элемента к корню документа

```
Документ
   |
   |  (Фаза захвата)
   ↓
Родительский элемент
   |
   ↓
Целевой элемент (Фаза цели)
   |
   ↑
Родительский элемент
   |
   |  (Фаза всплытия)
   ↑
Документ
```

## Всплытие событий (Event Bubbling)

По умолчанию события в JavaScript всплывают. Это означает, что когда событие происходит на вложенном элементе, оно сначала обрабатывается на этом элементе, а затем "всплывает" к родительским элементам, вызывая соответствующие обработчики на каждом уровне.

### Пример всплытия событий

```html
<div id="parent">
  <button id="child">Нажми меня</button>
</div>
```

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', function() {
    console.log('Клик на родительском элементе');
});

child.addEventListener('click', function() {
    console.log('Клик на дочернем элементе');
});
```

При клике на кнопке в консоли появится:
```
Клик на дочернем элементе
Клик на родительском элементе
```

## Перехват событий (Event Capturing)

Перехват событий - это противоположный процесс, при котором событие сначала обрабатывается на родительских элементах, а затем доходит до целевого элемента. Для включения перехвата нужно передать `true` в качестве третьего параметра метода `addEventListener`.

### Пример перехвата событий

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', function() {
    console.log('Перехват на родительском элементе');
}, true); // включаем фазу захвата

child.addEventListener('click', function() {
    console.log('Клик на дочернем элементе');
});
```

При клике на кнопке в консоли появится:
```
Перехват на родительском элементе
Клик на дочернем элементе
```

## Практическое применение

### 1. Делегирование событий

Всплытие событий позволяет использовать делегирование - установка одного обработчика на родительский элемент для управления событиями дочерних элементов:

```javascript
// Вместо добавления обработчиков каждому элементу списка
const list = document.getElementById('list');

list.addEventListener('click', function(event) {
    if (event.target.tagName === 'LI') {
        console.log('Нажат элемент списка:', event.target.textContent);
    }
});
```

### 2. Остановка всплытия события

Использование метода `stopPropagation()` для предотвращения всплытия события выше:

```javascript
const child = document.getElementById('child');

child.addEventListener('click', function(event) {
    console.log('Клик на дочернем элементе');
    event.stopPropagation(); // Останавливает всплытие
});

const parent = document.getElementById('parent');
parent.addEventListener('click', function() {
    console.log('Клик на родительском элементе');
});
```

При клике на дочернем элементе будет только:
```
Клик на дочернем элементе
```

### 3. Остановка всех обработчиков

Метод `stopImmediatePropagation()` останавливает как всплытие, так и выполнение других обработчиков на том же элементе:

```javascript
const element = document.getElementById('myElement');

element.addEventListener('click', function() {
    console.log('Первый обработчик');
    this.stopImmediatePropagation();
});

element.addEventListener('click', function() {
    console.log('Второй обработчик'); // Не выполнится
});

element.click(); // Вызов события программно
```

## Практические рекомендации

### 1. Использование делегирования для производительности

```javascript
// Неэффективно - создание множества обработчиков
const buttons = document.querySelectorAll('.button');
buttons.forEach(button => {
    button.addEventListener('click', handleClick);
});

// Эффективно - один обработчик для всех кнопок
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('button')) {
        handleClick(event);
    }
});
```

### 2. Понимание текущего элемента (currentTarget)

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', function(event) {
    console.log('currentTarget:', event.currentTarget); // Всегда родительский элемент
    console.log('target:', event.target); // Элемент, на котором произошло событие
});
```

### 3. Комбинирование фаз захвата и всплытия

```javascript
const grandParent = document.getElementById('grandParent');
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Фаза захвата
grandParent.addEventListener('click', () => console.log('Захват: дедушка'), true);
parent.addEventListener('click', () => console.log('Захват: родитель'), true);
child.addEventListener('click', () => console.log('Цель: ребенок'));

// Фаза всплытия
child.addEventListener('click', () => console.log('Всплытие: ребенок'));
parent.addEventListener('click', () => console.log('Всплытие: родитель'));
grandParent.addEventListener('click', () => console.log('Всплытие: дедушка'));
```

При клике на дочернем элементе результат будет:
```
Захват: дедушка
Захват: родитель
Цель: ребенок
Всплытие: ребенок
Всплытие: родитель
Всплытие: дедушка
```

## Современные подходы

### Использование современных возможностей

```javascript
// Использование делегирования с современным синтаксисом
document.addEventListener('click', (event) => {
    // Проверка соответствия селектору
    const button = event.target.closest('.button');
    if (button) {
        handleButtonClick(button);
    }
});
```

### Работа с пользовательскими событиями

```javascript
// Создание события с контролем всплытия
const customEvent = new CustomEvent('myCustomEvent', {
    bubbles: true,    // разрешить всплытие
    cancelable: true, // разрешить отмену
    detail: { data: 'Пример данных' }
});

// Слушатель может остановить всплытие
document.addEventListener('myCustomEvent', function(event) {
    console.log('Пользовательское событие:', event.detail);
    // event.stopPropagation(); // при необходимости
});
```

## Заключение

Понимание всплытия и перехвата событий позволяет создавать более эффективные и предсказуемые приложения. Эти механизмы особенно важны при работе с вложенными компонентами и сложной структурой DOM.

## Смежные темы

- [[Обработка-событий]]
- [[События-в-React]]
- [[События-в-Vue]]
- [[События-в-Svelte]]
- [[Компонентная-архитектура]]
- [[Фреймворки]]