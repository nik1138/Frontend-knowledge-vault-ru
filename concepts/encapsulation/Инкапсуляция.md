# Инкапсуляция

Инкапсуляция — это один из основных принципов объектно-ориентированного программирования, который объединяет данные и методы, работающие с этими данными, в одном классе, а также ограничивает доступ к внутреннему устройству объекта. Инкапсуляция позволяет скрывать детали реализации и предоставлять контролируемый интерфейс для взаимодействия с объектом.

## Основные аспекты инкапсуляции

### Объединение данных и методов
Инкапсуляция объединяет данные (состояние объекта) и методы (поведение объекта) в одном классе.

### Скрытие внутренней реализации
Внутренние детали реализации объекта скрыты от внешнего кода.

### Контролируемый доступ
Доступ к данным и методам объекта осуществляется через публичный интерфейс.

## Уровни доступа

### Публичные (public)
Публичные члены класса доступны из любого места программы.

### Приватные (private)
Приватные члены класса доступны только внутри самого класса.

### Защищенные (protected)
Защищенные члены класса доступны внутри класса и его наследников.

## Примеры инкапсуляции в различных языках

### JavaScript
```javascript
// Инкапсуляция в JavaScript
class BankAccount {
  #balance = 0; // Приватное поле (ES2022+)
  #accountNumber;
  
  constructor(accountNumber, initialBalance = 0) {
    this.#accountNumber = accountNumber;
    this.#balance = initialBalance;
  }
  
  // Публичные методы для взаимодействия
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return true;
    }
    return false;
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      return true;
    }
    return false;
  }
  
  getBalance() {
    return this.#balance;
  }
  
  getAccountInfo() {
    // Скрытие внутренней структуры
    return {
      accountNumber: this.#maskAccountNumber(),
      balance: this.#balance
    };
  }
  
  #maskAccountNumber() {
    // Приватный метод
    return this.#accountNumber.replace(/(\d{2})\d+(\d{4})/, '$1****$2');
  }
}

const account = new BankAccount('1234567890', 1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
console.log(account.getAccountInfo()); // { accountNumber: '12****7890', balance: 1500 }
// console.log(account.#balance); // Ошибка! Приватное поле
```

### TypeScript
```typescript
// Инкапсуляция в TypeScript
class BankAccount {
  private balance: number = 0;
  private accountNumber: string;
  
  constructor(accountNumber: string, initialBalance: number = 0) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
  }
  
  // Публичные методы
  public deposit(amount: number): boolean {
    if (amount > 0) {
      this.balance += amount;
      return true;
    }
    return false;
  }
  
  public withdraw(amount: number): boolean {
    if (amount > 0 && amount <= this.balance) {
      this.balance -= amount;
      return true;
    }
    return false;
  }
  
  public getBalance(): number {
    return this.balance;
  }
  
  protected getAccountNumber(): string {
    return this.accountNumber;
  }
}

class PremiumAccount extends BankAccount {
  private premiumFeatures: string[] = [];
  
  constructor(accountNumber: string, initialBalance: number = 0) {
    super(accountNumber, initialBalance);
  }
  
  public addPremiumFeature(feature: string): void {
    this.premiumFeatures.push(feature);
    // Может получить доступ к accountNumber через protected метод
    console.log(`Added feature for account ${this.getAccountNumber()}`);
  }
}
```

### Java
```java
// Инкапсуляция в Java
public class BankAccount {
  private double balance;
  private String accountNumber;
  
  public BankAccount(String accountNumber, double initialBalance) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
  }
  
  // Публичные методы
  public boolean deposit(double amount) {
    if (amount > 0) {
      balance += amount;
      return true;
    }
    return false;
  }
  
  public boolean withdraw(double amount) {
    if (amount > 0 && amount <= balance) {
      balance -= amount;
      return true;
    }
    return false;
  }
  
  public double getBalance() {
    return balance;
  }
  
  // Геттеры и сеттеры для контролируемого доступа
  public String getAccountNumber() {
    return maskAccountNumber();
  }
  
  private String maskAccountNumber() {
    // Скрытие реального номера счета
    return accountNumber.replaceAll("(?<=^.{2}).{4}(?=.{4})", "****");
  }
}
```

### Python
```python
# Инкапсуляция в Python
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Приватный атрибут
        self.__balance = initial_balance        # Приватный атрибут
    
    # Публичные методы
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self.__balance
    
    def get_account_info(self):
        return {
            'account_number': self.__mask_account_number(),
            'balance': self.__balance
        }
    
    def __mask_account_number(self):
        # Приватный метод
        return self.__account_number[:2] + '****' + self.__account_number[-4:]

# Использование
account = BankAccount('1234567890', 1000)
account.deposit(500)
print(account.get_balance())  # 1500
print(account.get_account_info())  # {'account_number': '12****7890', 'balance': 1500}
# print(account.__balance)  # Ошибка! Приватный атрибут
```

## Преимущества инкапсуляции

### Скрытие сложности
Инкапсуляция скрывает сложную реализацию за простым интерфейсом.

### Повышение безопасности
Приватные данные защищены от несанкционированного доступа.

### Упрощение сопровождения
Изменения во внутренней реализации не влияют на внешний код.

### Контроль доступа
Можно контролировать, как и когда данные могут быть изменены.

### Повышение надежности
Ограничение доступа к данным снижает вероятность ошибок.

## Недостатки инкапсуляции

### Сложность для начинающих
Понимание принципов инкапсуляции может быть сложным для новичков.

### Потенциальная избыточность
Для простых классов инкапсуляция может быть избыточной.

### Накладные расходы
Создание геттеров и сеттеров может добавить накладные расходы.

## Паттерны, использующие инкапсуляцию

### Фасад (Facade)
```javascript
// Фасад скрывает сложность подсистемы
class PaymentProcessor {
  constructor() {
    this.paymentGateway = new PaymentGateway();
    this.fraudDetector = new FraudDetector();
    this.notificationService = new NotificationService();
  }
  
  processPayment(amount, paymentData) {
    // Вся сложность скрыта внутри
    if (this.fraudDetector.check(paymentData)) {
      const result = this.paymentGateway.charge(amount, paymentData);
      if (result.success) {
        this.notificationService.sendConfirmation(result.transactionId);
      }
      return result;
    }
    return { success: false, error: 'Fraud detected' };
  }
}
```

### Адаптер (Adapter)
```javascript
// Адаптер инкапсулирует различия между интерфейсами
class PaymentAdapter {
  constructor(paymentService) {
    this.paymentService = paymentService;
  }
  
  process(amount, data) {
    // Инкапсулирует преобразование данных
    const convertedData = this.convertData(data);
    return this.paymentService.charge(convertedData);
  }
  
  private convertData(data) {
    // Скрытое преобразование
    return {
      amount: data.sum,
      card: data.cardNumber,
      expiry: data.expDate
    };
  }
}
```

## Инкапсуляция в функциональном программировании

Хотя инкапсуляция чаще ассоциируется с ООП, она также применима в функциональном программировании:

```javascript
// Инкапсуляция в функциональном стиле
function createBankAccount(initialBalance = 0) {
  let balance = initialBalance; // Скрытое состояние
  
  // Возвращаем объект с публичными методами
  return {
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return true;
      }
      return false;
    },
    
    withdraw(amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        return true;
      }
      return false;
    },
    
    getBalance() {
      return balance;
    }
  };
}

const account = createBankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // 1500
// Невозможно напрямую получить доступ к balance
```

## Связь с другими концепциями

- [[Объектно-ориентированное программирование]] - Инкапсуляция является одним из основных принципов ООП
- [[SOLID]] - Инкапсуляция поддерживает принцип единственной ответственности
- [[GRASP (General Responsibility Assignment Software Patterns)]] - Инкапсуляция является основой для многих паттернов GRASP
- [[Чистый код]] - Инкапсуляция способствует написанию чистого, понятного кода
- [[KISS (Keep It Simple, Stupid)]] - Хорошая инкапсуляция упрощает использование классов
- [[Наследование]] - Инкапсуляция и наследование работают вместе в ООП
- [[Композиция]] - Альтернатива наследованию с точки зрения инкапсуляции
- [[Интерфейсы]] - Интерфейсы помогают определить границы инкапсуляции

## Применение в современных технологиях

### В [[ts]]
TypeScript предоставляет мощные средства для инкапсуляции:
- Модификаторы доступа (public, private, protected)
- Приватные поля (ES2022+)
- Геттеры и сеттеры

### В [[js]]
JavaScript поддерживает инкапсуляцию через:
- Приватные поля (ES2022+)
- Замыкания
- Символы

### В [[react]]
React компоненты используют инкапсуляцию:
- Состояние компонента скрыто внутри
- Взаимодействие через props
- Хуки инкапсулируют сложную логику

## Теги
#encapsulation #oop #programming-concepts #data-hiding #access-control