# Интеграционные тесты

## Свойства
```yaml
tags: [testing, frontend, integration-testing, javascript, react]
aliases: [Интеграционное тестирование, Integration Testing]
```

## Обзор
Интеграционные тесты проверяют взаимодействие между различными модулями или компонентами системы. В отличие от unit-тестов, которые тестируют изолированные части кода, интеграционные тесты проверяют, как эти части работают вместе. В контексте фронтенд-разработки это может включать тестирование взаимодействия между компонентами, API-вызовов, работы с состоянием и другими интеграциями.

## Подробности

### Что тестируется
- Взаимодействие между компонентами
- Интеграция с API/бэкендом
- Работа с глобальным состоянием (Redux, Context и т.д.)
- Интеграция с библиотеками и сторонними сервисами
- Работа с DOM при взаимодействии нескольких компонентов

### Принципы
- **Реалистичность**: тесты должны отражать реальные сценарии использования
- **Полнота**: проверяют взаимодействие между модулями
- **Сложность**: сложнее в настройке и поддержке, чем unit-тесты
- **Время выполнения**: требуют больше времени на выполнение

### Популярные фреймворки и инструменты
- Jest + React Testing Library
- Cypress
- Playwright
- Puppeteer

### Примеры

#### React компоненты с контекстом
```jsx
// UserContext.jsx
import React, { createContext, useContext } from 'react';

const UserContext = createContext();

export const UserProvider = ({ children, user }) => (
  <UserContext.Provider value={user}>{children}</UserContext.Provider>
);

export const useUser = () => useContext(UserContext);

// UserProfile.jsx
export const UserProfile = () => {
  const user = useUser();
  return <div>{user.name}</div>;
};

// UserProfile.test.jsx
import { render, screen } from '@testing-library/react';
import { UserProvider } from './UserContext';
import { UserProfile } from './UserProfile';

test('displays user name from context', () => {
  const user = { name: 'John Doe', email: 'john@example.com' };
  render(
    <UserProvider value={user}>
      <UserProfile />
    </UserProvider>
  );
  expect(screen.getByText('John Doe')).toBeInTheDocument();
});
```

#### API интеграция
```javascript
// api.js
export const fetchUser = async (id) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

// UserCard.jsx
import { useState, useEffect } from 'react';
import { fetchUser } from './api';

export const UserCard = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(data => {
      setUser(data);
      setLoading(false);
    });
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
};

// UserCard.test.jsx
import { render, screen, waitFor } from '@testing-library/react';
import { UserCard } from './UserCard';
import { fetchUser } from './api';

// Мокаем API вызов
jest.mock('./api');

test('fetches and displays user data', async () => {
  fetchUser.mockResolvedValue({ name: 'Jane Doe' });

  render(<UserCard userId="123" />);

  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  await waitFor(() => {
    expect(screen.getByText('Jane Doe')).toBeInTheDocument();
  });
});
```

### Лучшие практики
- Тестируйте критические пути интеграции
- Используйте моки для внешних зависимостей при необходимости
- Избегайте чрезмерного использования интеграционных тестов
- Обеспечьте покрытие основных сценариев взаимодействия

## Связанные темы
- [[Unit-тесты]]
- [[E2E-тесты]]
- [[Mock-объекты]]
- [[Тестирование-компонентов]]

> [!tip] Совет
> Интеграционные тесты особенно полезны для проверки работы с глобальным состоянием и взаимодействия между компонентами.

> [!warning] Важно
> Не заменяйте unit-тесты интеграционными. Они дополняют друг друга и служат разным целям.

## Заключение
Интеграционные тесты обеспечивают проверку корректного взаимодействия между различными частями приложения, что критически важно для надежности фронтенд-приложений.