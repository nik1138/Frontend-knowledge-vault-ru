---
aliases: [Network Storage, Сетевое хранилище, Backend Storage, Серверное хранилище]
tags: [frontend, backend, storage, network, http, rest, api]
---

# Сетевые хранилища

## Введение

Сетевые хранилища представляют собой решения для хранения данных на серверной стороне, доступ к которым осуществляется через сеть. В контексте веб-приложений это обычно REST API, GraphQL, WebSockets или другие сетевые протоколы, позволяющие фронтенд-приложениям взаимодействовать с серверной частью и базами данных.

## Основные характеристики сетевых хранилищ

- Данные хранятся на сервере, а не на клиенте
- Требуется сетевое подключение для доступа к данным
- Обеспечивают централизованное хранение информации
- Поддерживают масштабируемость и безопасность
- Позволяют нескольким пользователям одновременно работать с одними и теми же данными

## Типы сетевых хранилищ

### REST API

REST (Representational State Transfer) - это архитектурный стиль для создания веб-сервисов. REST API использует стандартные HTTP-методы (GET, POST, PUT, DELETE) для выполнения операций с ресурсами.

#### Пример использования REST API

```javascript
// Получение данных
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error('Ошибка при получении данных пользователя:', error);
    throw error;
  }
}

// Сохранение данных
async function saveUserData(userData) {
  try {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(userData),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Ошибка при сохранении данных пользователя:', error);
    throw error;
  }
}
```

### GraphQL

GraphQL - это язык запросов для API, который позволяет клиентам запрашивать только те данные, которые им нужны, и получать их в одном запросе.

#### Пример использования GraphQL

```javascript
// Запрос данных через GraphQL
async function fetchUserWithPosts(userId) {
  const query = `
    query GetUserWithPosts($userId: ID!) {
      user(id: $userId) {
        id
        name
        email
        posts {
          id
          title
          content
        }
      }
    }
  `;
  
  const response = await fetch('/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query,
      variables: { userId },
    }),
  });
  
  const result = await response.json();
  return result.data.user;
}
```

### WebSockets

WebSockets обеспечивают двустороннюю связь в реальном времени между клиентом и сервером, что полезно для чатов, онлайн-игр и других приложений, требующих мгновенной синхронизации данных.

#### Пример использования WebSockets

```javascript
// Подключение к WebSocket серверу
const socket = new WebSocket('ws://localhost:8080');

socket.onopen = function(event) {
  console.log('Соединение установлено');
  
  // Отправка данных на сервер
  socket.send(JSON.stringify({
    type: 'join_room',
    roomId: 'chat_room_1'
  }));
};

socket.onmessage = function(event) {
  const data = JSON.parse(event.data);
  
  // Обработка полученных данных
  switch(data.type) {
    case 'new_message':
      console.log('Новое сообщение:', data.message);
      break;
    case 'user_joined':
      console.log('Пользователь присоединился:', data.username);
      break;
  }
};

socket.onclose = function(event) {
  console.log('Соединение закрыто');
};
```

## Преимущества сетевых хранилищ

- Централизованное управление данными
- Возможность масштабирования
- Обеспечение безопасности и контроля доступа
- Совместное использование данных между пользователями
- Резервное копирование и восстановление данных
- Поддержка сложных структур данных

## Недостатки сетевых хранилищ

- Зависимость от сетевого подключения
- Возможные задержки при передаче данных
- Необходимость управления аутентификацией и авторизацией
- Более сложная архитектура по сравнению с локальными хранилищами
- Потенциальные проблемы с производительностью при большом объеме данных

## Практические рекомендации

### Обработка ошибок

```javascript
// Обработка сетевых ошибок
async function robustApiCall(url, options = {}) {
  const maxRetries = 3;
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        ...options,
        timeout: 10000, // 10 секунд таймаут
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      lastError = error;
      if (i < maxRetries - 1) {
        // Ожидание перед повторной попыткой (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
      }
    }
  }
  
  throw new Error(`Не удалось выполнить запрос после ${maxRetries} попыток: ${lastError.message}`);
}
```

### Кэширование данных

```javascript
// Простой кэш для сетевых запросов
class NetworkCache {
  constructor(ttl = 300000) { // 5 минут по умолчанию
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  set(key, value) {
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }
  
  clear() {
    this.cache.clear();
  }
}

const cache = new NetworkCache();

async function getCachedUserData(userId) {
  const cacheKey = `user_${userId}`;
  const cached = cache.get(cacheKey);
  
  if (cached) {
    return cached;
  }
  
  const userData = await fetchUserData(userId);
  cache.set(cacheKey, userData);
  return userData;
}
```

### Аутентификация и безопасность

```javascript
// Пример аутентификации с использованием токенов
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.token = null;
  }
  
  setToken(token) {
    this.token = token;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      }
    };
    
    if (this.token) {
      config.headers['Authorization'] = `Bearer ${this.token}`;
    }
    
    const response = await fetch(url, config);
    
    if (response.status === 401) {
      // Токен истек, возможно, нужно обновить или перенаправить на логин
      this.handleUnauthorized();
    }
    
    return response;
  }
  
  handleUnauthorized() {
    // Обработка ситуации с недействительным токеном
    this.token = null;
    // Перенаправление на страницу логина или запрос нового токена
  }
}
```

## Связанные темы

- [[Локальные-хранилища]]
- [[Индексированные-хранилища]]
- [[Временные-хранилища]]
- [[Сравнение-хранилищ]]

## Заключение

Сетевые хранилища играют ключевую роль в современных веб-приложениях, обеспечивая централизованное хранение данных, безопасность и масштабируемость. При правильной реализации они позволяют создавать мощные, надежные и гибкие приложения, способные обслуживать большое количество пользователей и обрабатывать сложные сценарии работы с данными.