---
aliases: [IndexedDB, Индексированное хранилище, База данных в браузере]
tags: [frontend, storage, database, indexeddb, javascript, web-api]
---

# Индексированные хранилища

## Введение

IndexedDB - это низкоуровневое API для хранения значительных объемов структурированных данных в браузере, включая файлы/объекты BLOB. Это полноценная клиентская база данных, которая поддерживает индексирование для эффективного поиска данных. IndexedDB особенно полезен для приложений, требующих хранения большого объема данных на стороне клиента.

## Основные понятия IndexedDB

- **База данных (Database)** - контейнер для объектных хранилищ
- **Объектное хранилище (Object Store)** - коллекция записей, аналогичная таблице в реляционной Б
- **Индекс (Index)** - специальный объект для эффективного поиска записей по свойствам
- **Транзакция (Transaction)** - контекст выполнения операций с базой данных
- **Запрос (Request)** - асинхронная операция с базой данных

## Создание базы данных и объектного хранилища

```javascript
// Открытие или создание базы данных
function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('MyAppDB', 1); // версия 1
    
    request.onerror = () => {
      console.error('Ошибка при открытии базы данных:', request.error);
      reject(request.error);
    };
    
    request.onsuccess = () => {
      const db = request.result;
      console.log('База данных успешно открыта');
      resolve(db);
    };
    
    // Создание схемы базы данных при первом открытии или изменении версии
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Создание объектного хранилища для пользователей
      if (!db.objectStoreNames.contains('users')) {
        const objectStore = db.createObjectStore('users', { keyPath: 'id', autoIncrement: true });
        
        // Создание индексов для эффективного поиска
        objectStore.createIndex('email', 'email', { unique: true });
        objectStore.createIndex('name', 'name', { unique: false });
      }
      
      // Создание объектного хранилища для постов
      if (!db.objectStoreNames.contains('posts')) {
        const objectStore = db.createObjectStore('posts', { keyPath: 'id', autoIncrement: true });
        objectStore.createIndex('userId', 'userId', { unique: false });
        objectStore.createIndex('createdAt', 'createdAt', { unique: false });
      }
    };
  });
}
```

## Основные операции с IndexedDB

### Добавление данных

```javascript
// Добавление пользователя в хранилище
async function addUser(userData) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readwrite');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.add(userData);
    
    request.onsuccess = () => {
      console.log('Пользователь успешно добавлен с ID:', request.result);
      resolve(request.result);
    };
    
    request.onerror = () => {
      console.error('Ошибка при добавлении пользователя:', request.error);
      reject(request.error);
    };
  });
}

// Пример использования
addUser({
  name: 'Иван Петров',
  email: 'ivan@example.com',
  age: 30,
  createdAt: new Date().toISOString()
});
```

### Чтение данных

```javascript
// Получение пользователя по ID
async function getUserById(id) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.get(id);
    
    request.onsuccess = () => {
      if (request.result) {
        console.log('Пользователь найден:', request.result);
        resolve(request.result);
      } else {
        console.log('Пользователь с ID', id, 'не найден');
        resolve(null);
      }
    };
    
    request.onerror = () => {
      console.error('Ошибка при получении пользователя:', request.error);
      reject(request.error);
    };
  });
}

// Чтение всех пользователей
async function getAllUsers() {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.getAll();
    
    request.onsuccess = () => {
      console.log('Все пользователи:', request.result);
      resolve(request.result);
    };
    
    request.onerror = () => {
      console.error('Ошибка при получении всех пользователей:', request.error);
      reject(request.error);
    };
  });
}
```

### Обновление данных

```javascript
// Обновление данных пользователя
async function updateUser(id, updatedData) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readwrite');
    const objectStore = transaction.objectStore('users');
    const getRequest = objectStore.get(id);
    
    getRequest.onsuccess = () => {
      const user = getRequest.result;
      if (user) {
        // Объединяем существующие данные с обновленными
        Object.assign(user, updatedData);
        
        const putRequest = objectStore.put(user);
        putRequest.onsuccess = () => {
          console.log('Пользователь успешно обновлен');
          resolve(user);
        };
        
        putRequest.onerror = () => {
          console.error('Ошибка при обновлении пользователя:', putRequest.error);
          reject(putRequest.error);
        };
      } else {
        reject(new Error(`Пользователь с ID ${id} не найден`));
      }
    };
    
    getRequest.onerror = () => {
      console.error('Ошибка при получении пользователя для обновления:', getRequest.error);
      reject(getRequest.error);
    };
  });
}
```

### Удаление данных

```javascript
// Удаление пользователя по ID
async function deleteUser(id) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readwrite');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.delete(id);
    
    request.onsuccess = () => {
      console.log('Пользователь успешно удален');
      resolve(true);
    };
    
    request.onerror = () => {
      console.error('Ошибка при удалении пользователя:', request.error);
      reject(request.error);
    };
  });
}
```

## Использование индексов

```javascript
// Поиск пользователя по email с использованием индекса
async function getUserByEmail(email) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const index = objectStore.index('email');
    const request = index.get(email);
    
    request.onsuccess = () => {
      if (request.result) {
        console.log('Пользователь найден по email:', request.result);
        resolve(request.result);
      } else {
        console.log('Пользователь с email', email, 'не найден');
        resolve(null);
      }
    };
    
    request.onerror = () => {
      console.error('Ошибка при поиске пользователя по email:', request.error);
      reject(request.error);
    };
  });
}

// Получение всех пользователей с определенным именем
async function getUsersByName(name) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const index = objectStore.index('name');
    const range = IDBKeyRange.only(name);
    const request = index.getAll(range);
    
    request.onsuccess = () => {
      console.log(`Найдено ${request.result.length} пользователей с именем ${name}`);
      resolve(request.result);
    };
    
    request.onerror = () => {
      console.error('Ошибка при поиске пользователей по имени:', request.error);
      reject(request.error);
    };
  });
}
```

## Продвинутые возможности

### Обработка ошибок и управление транзакциями

```javascript
// Пример сложной транзакции с обработкой ошибок
async function complexTransactionExample() {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    // Начинаем транзакцию для нескольких объектных хранилищ
    const transaction = db.transaction(['users', 'posts'], 'readwrite');
    const usersStore = transaction.objectStore('users');
    const postsStore = transaction.objectStore('posts');
    
    // Обработка ошибок транзакции
    transaction.onerror = () => {
      console.error('Ошибка транзакции:', transaction.error);
      reject(transaction.error);
    };
    
    // Обработка завершения транзакции
    transaction.oncomplete = () => {
      console.log('Транзакция успешно завершена');
      resolve();
    };
    
    // Добавляем пользователя
    const addUserRequest = usersStore.add({
      name: 'Анна Смирнова',
      email: 'anna@example.com',
      createdAt: new Date().toISOString()
    });
    
    addUserRequest.onsuccess = (event) => {
      const userId = event.target.result;
      
      // После добавления пользователя добавляем связанный пост
      postsStore.add({
        title: 'Первый пост',
        content: 'Это содержимое первого поста',
        userId: userId,
        createdAt: new Date().toISOString()
      });
    };
  });
}
```

### Работа с диапазонами ключей

```javascript
// Получение пользователей с ID в определенном диапазоне
async function getUsersInRange(minId, maxId) {
  const db = await openDatabase();
  
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    
    // Создаем диапазон ключей
    const range = IDBKeyRange.bound(minId, maxId);
    const request = objectStore.getAll(range);
    
    request.onsuccess = () => {
      console.log('Пользователи в диапазоне:', request.result);
      resolve(request.result);
    };
    
    request.onerror = () => {
      console.error('Ошибка при получении пользователей в диапазоне:', request.error);
      reject(request.error);
    };
  });
}
```

## Преимущества IndexedDB

- Поддержка больших объемов данных (обычно ограничена только доступным местом на диске)
- Структурированное хранение данных
- Поддержка индексов для эффективного поиска
- Асинхронная работа без блокировки UI
- Поддержка транзакций
- Возможность хранения сложных объектов (включая BLOB)

## Недостатки IndexedDB

- Сложный API по сравнению с Local Storage
- Асинхронная природа может усложнить отладку
- Ограниченная поддержка в старых браузерах
- Потенциальные проблемы с производительностью при неправильном использовании индексов

## Практические рекомендации

### Обертка для упрощения работы с IndexedDB

```javascript
// Простая обертка для упрощения работы с IndexedDB
class IndexedDBWrapper {
  constructor(dbName, version) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        this.db = event.target.result;
        // Здесь можно создавать объектные хранилища
      };
    });
  }
  
  async add(storeName, data) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.add(data);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async get(storeName, key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getAll(storeName) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async delete(storeName, key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.delete(key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

// Использование обертки
const dbWrapper = new IndexedDBWrapper('MyAppDB', 1);
await dbWrapper.init();

// Добавление данных
await dbWrapper.add('users', { name: 'Иван', email: 'ivan@example.com' });

// Получение данных
const user = await dbWrapper.get('users', 1);
```

## Связанные темы

- [[Локальные-хранилища]]
- [[Сетевые-хранилища]]
- [[Временные-хранилища]]
- [[Сравнение-хранилищ]]

## Заключение

IndexedDB представляет собой мощное решение для клиентского хранения данных, особенно подходящее для приложений, требующих хранения больших объемов структурированных данных. Несмотря на сложность API, IndexedDB предоставляет возможности, недоступные в более простых решениях, такие как Local Storage, и является отличным выбором для автономных приложений или приложений, требующих кэширования данных на клиенте.