---
aliases: [Temporary Storage, Временное хранилище, Session Data, Временные данные]
tags: [frontend, storage, temporary, cache, javascript, web-api]
---

# Временные хранилища

## Введение

Временные хранилища - это решения для хранения данных, которые имеют ограниченное время жизни или существуют только в рамках определенного контекста выполнения. В веб-разработке временные хранилища используются для кэширования данных, хранения состояния между действиями пользователя и других сценариев, где данные не должны сохраняться надолго.

## Типы временных хранилищ

### 1. Память JavaScript (Memory Storage)

Самый простой способ временного хранения данных - использование переменных и объектов в памяти JavaScript.

#### Пример использования памяти

```javascript
// Простое временное хранилище в памяти
class MemoryStorage {
  constructor() {
    this.data = {};
    this.timers = {};
  }
  
  // Установка значения с временем жизни
  set(key, value, ttl = null) {
    this.data[key] = value;
    
    // Если указан TTL, устанавливаем таймер для удаления
    if (ttl) {
      if (this.timers[key]) {
        clearTimeout(this.timers[key]);
      }
      
      this.timers[key] = setTimeout(() => {
        this.delete(key);
      }, ttl);
    }
  }
  
  // Получение значения
  get(key) {
    return this.data[key];
  }
  
  // Удаление значения
  delete(key) {
    delete this.data[key];
    if (this.timers[key]) {
      clearTimeout(this.timers[key]);
      delete this.timers[key];
    }
  }
  
  // Очистка всех данных
  clear() {
    Object.keys(this.timers).forEach(key => clearTimeout(this.timers[key]));
    this.data = {};
    this.timers = {};
  }
}

// Использование временного хранилища
const tempStorage = new MemoryStorage();

// Сохраняем данные на 5 секунд
tempStorage.set('session-token', 'abc123xyz', 5000);

// Получаем данные
const token = tempStorage.get('session-token');
console.log('Токен:', token);

// Через 5 секунд значение будет автоматически удалено
```

### 2. Session Storage как временное хранилище

Session Storage автоматически очищается при закрытии вкладки/браузера, что делает его отличным выбором для временных данных сессии.

#### Пример использования Session Storage

```javascript
// Временное хранилище на основе Session Storage с TTL
class SessionStorageWithTTL {
  constructor() {
    this.prefix = '__temp__';
  }
  
  set(key, value, ttl = null) {
    const item = {
      value: value,
      timestamp: Date.now(),
      ttl: ttl
    };
    
    sessionStorage.setItem(this.prefix + key, JSON.stringify(item));
  }
  
  get(key) {
    const itemStr = sessionStorage.getItem(this.prefix + key);
    
    if (!itemStr) {
      return null;
    }
    
    const item = JSON.parse(itemStr);
    
    // Проверяем, не истекло ли время жизни
    if (item.ttl && (Date.now() - item.timestamp) > item.ttl) {
      sessionStorage.removeItem(this.prefix + key);
      return null;
    }
    
    return item.value;
  }
  
  delete(key) {
    sessionStorage.removeItem(this.prefix + key);
  }
  
  clear() {
    Object.keys(sessionStorage).forEach(key => {
      if (key.startsWith(this.prefix)) {
        sessionStorage.removeItem(key);
      }
    });
  }
}

// Использование
const sessionTempStorage = new SessionStorageWithTTL();

// Сохраняем временные данные
sessionTempStorage.set('form-data', { name: 'Иван', email: 'ivan@example.com' }, 300000); // 5 минут

// Получаем данные
const formData = sessionTempStorage.get('form-data');
console.log('Данные формы:', formData);
```

### 3. Кэш в памяти с ограничением по размеру

Для приложений, которые могут генерировать много временных данных, полезно использовать кэш с ограничением по размеру.

```javascript
// Кэш с ограничением по размеру и политикой LRU (Least Recently Used)
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      // Перемещаем элемент в конец (помечаем как недавно использованный)
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return undefined;
  }
  
  set(key, value) {
    if (this.cache.has(key)) {
      // Если ключ уже существует, удаляем его перед добавлением
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Удаляем первый элемент (наименее недавно использованный)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
  
  has(key) {
    return this.cache.has(key);
  }
  
  delete(key) {
    return this.cache.delete(key);
  }
  
  clear() {
    this.cache.clear();
  }
  
  size() {
    return this.cache.size;
  }
  
  keys() {
    return Array.from(this.cache.keys());
  }
}

// Использование LRU кэша
const lruCache = new LRUCache(5); // Максимум 5 элементов

lruCache.set('a', 1);
lruCache.set('b', 2);
lruCache.set('c', 3);
lruCache.set('d', 4);
lruCache.set('e', 5);

console.log('Размер кэша:', lruCache.size()); // 5

// При добавлении шестого элемента, первый (a) будет удален
lruCache.set('f', 6);
console.log('Ключи:', lruCache.keys()); // ['b', 'c', 'd', 'e', 'f']
console.log('Ключ a существует?', lruCache.has('a')); // false
```

### 4. Кэш с временными метками

Для сценариев, где важна актуальность данных, можно использовать кэш с автоматическим обновлением.

```javascript
// Кэш с автоматическим обновлением при истечении времени
class ExpiringCache {
  constructor(defaultTTL = 300000) { // 5 минут по умолчанию
    this.defaultTTL = defaultTTL;
    this.cache = new Map();
    this.timers = new Map();
  }
  
  set(key, value, ttl = null) {
    const actualTTL = ttl || this.defaultTTL;
    
    // Удаляем предыдущий таймер, если он был
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }
    
    // Сохраняем данные
    this.cache.set(key, {
      value: value,
      timestamp: Date.now(),
      ttl: actualTTL
    });
    
    // Устанавливаем таймер для автоматического удаления
    const timer = setTimeout(() => {
      this.delete(key);
    }, actualTTL);
    
    this.timers.set(key, timer);
  }
  
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) {
      return undefined;
    }
    
    // Обновляем время жизни при доступе (если используется политика "свежести")
    if (Date.now() - item.timestamp > item.ttl) {
      this.delete(key);
      return undefined;
    }
    
    return item.value;
  }
  
  has(key) {
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }
    
    if (Date.now() - item.timestamp > item.ttl) {
      this.delete(key);
      return false;
    }
    
    return true;
  }
  
  delete(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    
    return this.cache.delete(key);
  }
  
  clear() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
    this.cache.clear();
  }
  
  refresh(key, ttl = null) {
    const item = this.cache.get(key);
    if (item) {
      this.set(key, item.value, ttl);
    }
  }
}

// Использование кэша с временными метками
const expiringCache = new ExpiringCache(10000); // 10 секунд по умолчанию

expiringCache.set('api-response', { data: [1, 2, 3], status: 'success' });
console.log('Данные:', expiringCache.get('api-response')); // { data: [1,2,3], status: 'success' }

// Через 10 секунд данные будут автоматически удалены
```

## Практические применения временных хранилищ

### Кэширование API-ответов

```javascript
// Кэш для API-ответов
class ApiCache {
  constructor(ttl = 300000) { // 5 минут по умолчанию
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  async fetchWithCache(url, options = {}) {
    // Генерируем ключ на основе URL и параметров
    const cacheKey = `${url}_${JSON.stringify(options)}`;
    const cached = this.cache.get(cacheKey);
    
    // Проверяем, не истекло ли время кэширования
    if (cached && (Date.now() - cached.timestamp) < this.ttl) {
      console.log('Возвращаем данные из кэша');
      return cached.data;
    }
    
    // Выполняем запрос
    try {
      const response = await fetch(url, options);
      const data = await response.json();
      
      // Сохраняем в кэш
      this.cache.set(cacheKey, {
        data: data,
        timestamp: Date.now()
      });
      
      return data;
    } catch (error) {
      console.error('Ошибка при выполнении запроса:', error);
      throw error;
    }
  }
  
  invalidate(url) {
    // Удаляем из кэша все записи, начинающиеся с указанного URL
    for (const [key] of this.cache) {
      if (key.startsWith(url)) {
        this.cache.delete(key);
      }
    }
  }
  
  clear() {
    this.cache.clear();
  }
}

// Использование кэша API
const apiCache = new ApiCache(60000); // 1 минута

// Функция для получения данных с кэшированием
async function getUserData(userId) {
  const url = `/api/users/${userId}`;
  return await apiCache.fetchWithCache(url);
}
```

### Временное хранение состояния формы

```javascript
// Хранилище для временного сохранения состояния форм
class FormStateStorage {
  constructor() {
    this.storage = new Map();
  }
  
  // Сохраняем состояние формы
  saveFormState(formId, formData) {
    this.storage.set(formId, {
      data: formData,
      timestamp: Date.now()
    });
  }
  
  // Получаем состояние формы
  getFormState(formId) {
    const formState = this.storage.get(formId);
    
    if (!formState) {
      return null;
    }
    
    // Проверяем, не слишком ли старое состояние (например, старше 30 минут)
    if (Date.now() - formState.timestamp > 1800000) { // 30 минут
      this.storage.delete(formId);
      return null;
    }
    
    return formState.data;
  }
  
  // Удаляем состояние формы
  clearFormState(formId) {
    this.storage.delete(formId);
  }
  
  // Очищаем все устаревшие состояния форм
  clearExpiredStates() {
    const now = Date.now();
    for (const [formId, state] of this.storage) {
      if (now - state.timestamp > 1800000) { // 30 минут
        this.storage.delete(formId);
      }
    }
  }
}

// Использование
const formStorage = new FormStateStorage();

// При заполнении формы сохраняем состояние
formStorage.saveFormState('registration-form', {
  firstName: 'Иван',
  lastName: 'Петров',
  email: 'ivan@example.com'
});

// При загрузке формы восстанавливаем состояние
const savedState = formStorage.getFormState('registration-form');
if (savedState) {
  // Восстанавливаем данные формы
  console.log('Восстанавливаем состояние формы:', savedState);
}
```

## Преимущества временных хранилищ

- Эффективное использование памяти
- Улучшение производительности за счет кэширования
- Удобство для хранения промежуточных данных
- Автоматическая очистка устаревших данных
- Гибкость в настройке политик хранения

## Недостатки временных хранилищ

- Данные теряются при перезагрузке страницы/приложения
- Ограниченный объем памяти
- Не подходят для хранения важных данных
- Требуют управления временем жизни данных

## Практические рекомендации

### Выбор подходящего типа временного хранилища

```javascript
// Фабрика временных хранилищ
class TempStorageFactory {
  static create(type, options = {}) {
    switch (type) {
      case 'memory':
        return new MemoryStorage();
      case 'session-ttl':
        return new SessionStorageWithTTL();
      case 'lru':
        return new LRUCache(options.maxSize || 100);
      case 'expiring':
        return new ExpiringCache(options.defaultTTL || 300000);
      case 'api-cache':
        return new ApiCache(options.ttl || 300000);
      default:
        throw new Error(`Неизвестный тип временного хранилища: ${type}`);
    }
  }
}

// Использование фабрики
const memoryStorage = TempStorageFactory.create('memory');
const lruStorage = TempStorageFactory.create('lru', { maxSize: 50 });
const apiCache = TempStorageFactory.create('api-cache', { ttl: 60000 });
```

## Связанные темы

- [[Локальные-хранилища]]
- [[Сетевые-хранилища]]
- [[Индексированные-хранилища]]
- [[Сравнение-хранилищ]]

## Заключение

Временные хранилища играют важную роль в оптимизации производительности веб-приложений. Они позволяют эффективно управлять промежуточными данными, кэшировать результаты операций и улучшать пользовательский опыт за счет уменьшения задержек при доступе к часто используемым данным. При правильном использовании временные хранилища могут значительно улучшить производительность и отзывчивость приложения.