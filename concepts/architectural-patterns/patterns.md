---
aliases: ["Архитектурные паттерны", "Паттерны проектирования архитектуры"]
tags: ["#programming", "#architecture", "#patterns", "#design"]
---

# Архитектурные паттерны

## Определение архитектурных паттернов

Архитектурные паттерны — это общие структурные решения, определяющие организацию программных систем. Они описывают отношения между компонентами, их ответственности и способы взаимодействия. Архитектурные паттерны помогают разработчикам создавать масштабируемые, поддерживаемые и тестируемые приложения.

> [!note] Заметка
> Архитектурные паттерны отличаются от паттернов проектирования тем, что они охватывают более высокий уровень — структуру всего приложения, а не отдельные классы или объекты.

## Основные архитектурные паттерны

### Слоистая архитектура (Layered Architecture)

Слоистая архитектура делит приложение на горизонтальные слои, каждый из которых отвечает за определенный уровень абстракции:

- **Представление (Presentation Layer)** — пользовательский интерфейс
- **Бизнес-логика (Business Layer)** — бизнес-правила и логика
- **Данные (Data Layer)** — доступ к базе данных

```
+-------------------+
|   Presentation    |
+-------------------+
|    Business       |
+-------------------+
|      Data         |
+-------------------+
```

**Преимущества:**
- Простота понимания и разработки
- Хорошо подходит для традиционных приложений
- Легко тестировать отдельные слои

**Недостатки:**
- Может привести к жесткой связанности между слоями
- Сложно масштабировать отдельные компоненты

### MVC (Model-View-Controller)

MVC разделяет приложение на три основных компонента:

- **Model** — данные и бизнес-логика
- **View** — представление данных пользователю
- **Controller** — обработка пользовательского ввода

```javascript
// Пример MVC на Node.js
class UserController {
  async getUser(req, res) {
    const user = await User.findById(req.params.id); // Model
    res.render('user', { user }); // View
  }
}
```

### MVVM (Model-View-ViewModel)

MVVM используется в основном в клиентских приложениях, особенно в WPF и современных фреймворках:

- **Model** — бизнес-данные
- **View** — пользовательский интерфейс
- **ViewModel** — связующее звено между Model и View

### MVP (Model-View-Presenter)

MVP — это модификация MVC, где Presenter отвечает за всю логику представления:

- **Model** — данные
- **View** — пассивное представление
- **Presenter** — контролирует взаимодействие между View и Model

### Микросервисы (Microservices)

Микросервисная архитектура разбивает приложение на небольшие независимые сервисы, каждый из которых отвечает за определенную бизнес-функцию:

```
+-------------+    +-------------+    +-------------+
|   User      |    |  Product    |    |   Order     |
|  Service    |    |  Service    |    |  Service    |
+-------------+    +-------------+    +-------------+
```

**Преимущества:**
- Независимое развертывание
- Технологическая гибкость
- Лучшая масштабируемость

**Недостатки:**
- Сложность управления
- Проблемы с сетевыми вызовами
- Трудности в тестировании

### Монолитная архитектура

Монолитное приложение — это единый исполняемый файл, в котором все компоненты объединены в одном процессе:

```
+-----------------------------------------+
|              Монолитное приложение       |
|  +-------------+  +-------------+       |
|  |   Web UI    |  |  Business   |       |
|  +-------------+  +-------------+       |
|  +-------------+  +-------------+       |
|  |   Data      |  |  Services   |       |
|  +-------------+  +-------------+       |
+-----------------------------------------+
```

**Преимущества:**
- Простота разработки и тестирования
- Легко развертывать
- Хорошая производительность

**Недостатки:**
- Трудности масштабирования
- Технический долг
- Сложности при добавлении новых функций

### Событийно-ориентированная архитектура (Event-Driven Architecture)

EDA основана на генерации, обнаружении, потреблении и реагировании на события:

```
+-------------+      +-------------+      +-------------+
|  Publisher  |----->|  Message    |----->|  Consumer   |
+-------------+      |  Broker     |      +-------------+
                     +-------------+
```

**Компоненты:**
- **Издатели (Publishers)** — генерируют события
- **Брокеры (Brokers)** — маршрутизируют события
- **Потребители (Consumers)** — обрабатывают события

### CQRS (Command Query Responsibility Segregation)

CQRS разделяет операции чтения и записи:

- **Commands** — изменяют состояние системы
- **Queries** — возвращают данные без изменения состояния

```javascript
// Пример CQRS
class UserService {
  // Command
  async createUser(userData) {
    await this.userRepository.create(userData);
  }

  // Query
  async getUser(userId) {
    return await this.readModel.getUser(userId);
  }
}
```

### Serverless архитектура

Serverless позволяет разработчикам создавать приложения без управления серверами:

- Функции как сервис (FaaS)
- Автоматическое масштабирование
- Оплата только за использование

## Выбор правильной архитектуры

Выбор архитектуры зависит от множества факторов:

- **Размер команды** — микросервисы требуют более опытной команды
- **Масштабируемость** — необходимость масштабировать отдельные компоненты
- **Сложность бизнес-логики** — простые приложения могут использовать монолит
- **Время на разработку** — монолиты быстрее для MVP
- **Инфраструктура** — доступные ресурсы и технологии

## Практические примеры

### Пример: выбор архитектуры для интернет-магазина

Для интернет-магазина может быть использована микросервисная архитектура с отдельными сервисами для пользователей, товаров, заказов и платежей. Это позволяет независимо развивать и масштабировать каждую часть приложения.

### Пример: выбор архитектуры для корпоративного приложения

Корпоративные приложения часто используют слоистую архитектуру с MVC или MVVM, что упрощает поддержку и тестирование.

## Связь с другими концепциями

Архитектурные паттерны тесно связаны с другими концепциями программирования:

- [[design-patterns]] — паттерны проектирования работают на более низком уровне
- [[component-architecture]] — компонентная архитектура реализует архитектурные паттерны
- [[caching]] — кэширование применяется в различных архитектурах
- [[api-integration]] — взаимодействие между сервисами требует архитектурных решений

## Ключевые выводы

- Архитектурные паттерны предоставляют проверенные решения для структурирования приложений
- Выбор паттерна зависит от требований проекта, команды и инфраструктуры
- Современные приложения часто используют комбинации нескольких паттернов
- Архитектура должна эволюционировать вместе с приложением
