---
aliases: [Immutability, Неизменяемость]
tags: [programming, frontend, javascript, paradigm]
---

# Иммутабельность

**Иммутабельность** — это свойство объекта или значения не изменяться после создания. В контексте программирования это означает, что данные не могут быть изменены после их создания, и любые операции над ними создают новые объекты или значения, а не модифицируют существующие.

## Основные понятия

### Что такое иммутабельность

```javascript
// Мутабельный подход (изменение оригинала)
let user = { name: 'Иван', age: 25 };
user.age = 26; // Изменяем оригинальный объект
console.log(user); // { name: 'Иван', age: 26 }

// Иммутабельный подход (создание нового объекта)
const userOriginal = { name: 'Иван', age: 25 };
const userUpdated = { ...userOriginal, age: 26 }; // Создаем новый объект
console.log(userOriginal); // { name: 'Иван', age: 25 } - оригинальный не изменился
console.log(userUpdated);  // { name: 'Иван', age: 26 } - новый объект
```

### Встроенные иммутабельные типы в JavaScript

```javascript
// Примитивные типы - иммутабельны по природе
let name = 'Иван';
name.toUpperCase(); // Возвращает новую строку
console.log(name); // 'Иван' - оригинальная строка не изменилась

let count = 42;
count.toString(); // Возвращает новую строку
console.log(count); // 42 - оригинальное число не изменилось

// Массивы и объекты - мутабельны по умолчанию
let arr = [1, 2, 3];
arr.push(4); // Мутирует оригинальный массив
console.log(arr); // [1, 2, 3, 4]
```

## Практическое применение в фронтенд-разработке

### Работа с массивами

```javascript
// Мутабельные методы массивов (изменяют оригинальный массив)
const numbers = [1, 2, 3];
numbers.push(4); // Мутирует массив
numbers.sort();  // Мутирует массив
console.log(numbers); // [1, 2, 3, 4] - оригинальный массив изменен

// Иммутабельные методы массивов (возвращают новый массив)
const originalNumbers = [3, 1, 4, 1, 5];
const newNumbers = [...originalNumbers, 6]; // Добавление элемента
const sortedNumbers = [...originalNumbers].sort(); // Сортировка
const filteredNumbers = originalNumbers.filter(n => n > 2); // Фильтрация
const mappedNumbers = originalNumbers.map(n => n * 2); // Трансформация

console.log(originalNumbers); // [3, 1, 4, 1, 5] - оригинальный массив не изменился
console.log(newNumbers);      // [3, 1, 4, 1, 5, 6]
console.log(sortedNumbers);   // [1, 1, 3, 4, 5]
console.log(filteredNumbers); // [3, 4, 5]
console.log(mappedNumbers);   // [6, 2, 8, 2, 10]
```

### Работа с объектами

```javascript
// Иммутабельные операции с объектами
const user = {
  name: 'Иван',
  age: 25,
  address: {
    city: 'Москва',
    street: 'Тверская'
  }
};

// Обновление объекта (создание нового)
const updatedUser = {
  ...user,
  age: 26,
  email: 'ivan@example.com'
};

// Глубокое обновление (создание новых вложенных объектов)
const userWithNewAddress = {
  ...user,
  address: {
    ...user.address,
    street: 'Арбат'
  }
};

// Использование Object.assign (альтернатива spread-оператору)
const newUser = Object.assign({}, user, { age: 27 });
```

### React и иммутабельность

```jsx
// Пример с React и иммутабельностью
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Изучить React', completed: false },
    { id: 2, text: 'Написать приложение', completed: true }
  ]);
  
  // Правильный иммутабельный способ добавления todo
  const addTodo = (text) => {
    setTodos([
      ...todos,
      { id: Date.now(), text, completed: false }
    ]);
  };
  
  // Правильный иммутабельный способ переключения статуса
  const toggleTodo = (id) => {
    setTodos(
      todos.map(todo =>
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  // Правильный иммутабельный способ удаления
  const removeTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    <div>
      <button onClick={() => addTodo('Новое дело')}>
        Добавить дело
      </button>
      <ul>
        {todos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={() => toggleTodo(todo.id)}
            onRemove={() => removeTodo(todo.id)}
          />
        ))}
      </ul>
    </div>
  );
}
```

### Redux и иммутабельность

```javascript
// Redux reducer с иммутабельными операциями
const initialState = {
  user: null,
  todos: [],
  loading: false
};

function appReducer(state = initialState, action) {
  switch (action.type) {
    case 'SET_USER':
      return {
        ...state,
        user: { ...action.payload } // Создаем новый объект пользователя
      };
    
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos, // Создаем новый массив
          { ...action.payload } // Создаем новый объект todo
        ]
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed } // Создаем новый объект todo
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id)
      };
    
    default:
      return state;
  }
}
```

## Инструменты для работы с иммутабельностью

### Использование библиотеки Immer

```javascript
import produce from 'immer';

// С использованием Immer можно писать "мутирующий" код, 
// но результат будет иммутабельным
const state = {
  user: {
    name: 'Иван',
    preferences: {
      theme: 'light',
      notifications: true
    }
  },
  todos: [
    { id: 1, text: 'Дело 1', completed: false }
  ]
};

// С Immer - выглядит как мутация, но на самом деле создает новый объект
const newState = produce(state, draft => {
  draft.user.name = 'Мария'; // Выглядит как мутация
  draft.user.preferences.theme = 'dark'; // Но на самом деле создается новый объект
  draft.todos.push({ id: 2, text: 'Дело 2', completed: false }); // Также иммутабельно
});

console.log(state === newState); // false - это новый объект
console.log(state.user === newState.user); // false - пользователь тоже новый
```

### Пользовательские утилиты

```javascript
// Утилиты для иммутабельных операций
const immutable = {
  // Обновление вложенного свойства
  updateIn: (obj, path, updater) => {
    const keys = path.split('.');
    const lastKey = keys.pop();
    
    const newObj = { ...obj };
    let current = newObj;
    
    for (const key of keys) {
      current[key] = { ...current[key] };
      current = current[key];
    }
    
    current[lastKey] = updater(current[lastKey]);
    return newObj;
  },
  
  // Добавление в массив
  push: (arr, item) => [...arr, item],
  
  // Удаление из массива по индексу
  removeAt: (arr, index) => [
    ...arr.slice(0, index),
    ...arr.slice(index + 1)
  ],
  
  // Обновление элемента массива по индексу
  updateAt: (arr, index, updater) => arr.map((item, i) =>
    i === index ? updater(item) : item
  )
};

// Использование утилит
const state = {
  user: { name: 'Иван', settings: { theme: 'light' } },
  items: [1, 2, 3]
};

const newState = immutable.updateIn(
  state, 
  'user.settings.theme', 
  () => 'dark'
);

const newItems = immutable.push(state.items, 4);
```

## Преимущества иммутабельности во фронтенде

### 1. Предсказуемость

```javascript
// С иммутабельностью легче отслеживать изменения
const originalState = { count: 0, items: [] };

// Каждое изменение создает новый объект
const state1 = { ...originalState, count: 1 };
const state2 = { ...state1, items: ['item1'] };
const state3 = { ...state2, count: 2 };

// Можно легко сравнить состояния
console.log(originalState === state1); // false
console.log(state1 === state2); // false
console.log(state2 === state3); // false
```

### 2. Упрощение отладки

```javascript
// При использовании иммутабельности легче отследить, где произошло изменение
const actionsLog = [];

function reducer(state, action) {
  const newState = performAction(state, action);
  
  // Логирование изменений
  actionsLog.push({
    action,
    prevState: state,
    newState,
    timestamp: Date.now()
  });
  
  return newState;
}
```

### 3. Оптимизация производительности

```jsx
// React.memo работает эффективнее с иммутабельными данными
const TodoItem = React.memo(({ todo, onToggle, onRemove }) => {
  return (
    <div className="todo-item">
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
      />
      <span className={todo.completed ? 'completed' : ''}>
        {todo.text}
      </span>
      <button onClick={onRemove}>Удалить</button>
    </div>
  );
});

// Компонент перерендеривается только если props действительно изменились
```

### 4. Легкость тестирования

```javascript
// Иммутабельные функции легче тестировать
function addItem(items, newItem) {
  return [...items, newItem];
}

// Тест
test('addItem добавляет элемент в массив', () => {
  const originalItems = [1, 2, 3];
  const newItem = 4;
  const result = addItem(originalItems, newItem);
  
  expect(result).toEqual([1, 2, 3, 4]);
  expect(originalItems).toEqual([1, 2, 3]); // Оригинальный массив не изменился
});
```

## Практические примеры

### Работа с формами

```jsx
function UserForm({ initialUser, onSave }) {
  const [user, setUser] = useState({ ...initialUser }); // Создаем копию
  
  const handleChange = (field, value) => {
    // Создаем новое состояние, а не мутируем существующее
    setUser(prevUser => ({
      ...prevUser,
      [field]: value
    }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSave(user); // Передаем неизмененную копию данных
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={user.name}
        onChange={(e) => handleChange('name', e.target.value)}
        placeholder="Имя"
      />
      <input
        value={user.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder="Email"
      />
      <button type="submit">Сохранить</button>
    </form>
  );
}
```

### Управление сложным состоянием

```javascript
// Пример с глубокой структурой данных
const initialState = {
  users: {
    byId: {},
    allIds: []
  },
  ui: {
    currentView: 'list',
    filters: {
      searchTerm: '',
      sortBy: 'name',
      showInactive: false
    }
  }
};

function updateFilter(state, filterName, value) {
  return {
    ...state,
    ui: {
      ...state.ui,
      filters: {
        ...state.ui.filters,
        [filterName]: value
      }
    }
  };
}

function addUser(state, user) {
  return {
    ...state,
    users: {
      byId: {
        ...state.users.byId,
        [user.id]: user
      },
      allIds: [...state.users.allIds, user.id]
    }
  };
}
```

## Связанные концепции

- [[Функциональное программирование]] - иммутабельность как ключевой принцип
- [[Управление состоянием]] - иммутабельное управление состоянием
- [[Реактивное программирование]] - реактивность и иммутабельность
- [[Декларативное программирование]] - декларативные подходы к работе с данными
- [[Асинхронное программирование]] - работа с иммутабельными данными в асинхронных операциях

## Лучшие практики

1. **Используйте spread-операторы** для создания копий объектов и массивов
2. **Избегайте мутации оригинальных данных** - всегда создавайте новые структуры
3. **Используйте библиотеки для иммутабельности** при работе со сложными структурами
4. **Будьте осторожны с глубокими копиями** - используйте поверхностные копии, когда это возможно
5. **Используйте Object.freeze()** для создания действительно неизменяемых объектов (в разработке)
6. **Тестируйте иммутабельность** - убедитесь, что оригинальные данные не изменяются

## Заключение

Иммутабельность является важным принципом современной фронтенд-разработки, особенно в экосистеме React и Redux. Она помогает создавать более предсказуемые, тестируемые и поддерживаемые приложения. Понимание и применение принципов иммутабельности позволяет избежать многих ошибок, связанных с неожиданными изменениями данных, и делает код более надежным и понятным.