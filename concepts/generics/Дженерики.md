# Дженерики (Generics)

Дженерики (Generics) — это механизм параметрического полиморфизма в программировании, который позволяет создавать компоненты, работающие с различными типами данных без потери информации о типах. Дженерики позволяют писать код, который может работать с любыми типами, сохраняя при этом строгую типизацию.

## Основные характеристики дженериков

### Параметрический полиморфизм
Дженерики позволяют создавать компоненты, которые могут работать с различными типами данных.

### Сохранение типобезопасности
Несмотря на универсальность, дженерики сохраняют строгую типизацию и предотвращают ошибки времени выполнения.

### Переиспользование кода
Дженерики позволяют писать универсальный код, который может быть использован с различными типами.

## Примеры дженериков

### В TypeScript
```typescript
// Простой дженерик
function identity<T>(arg: T): T {
  return arg;
}

// Использование с разными типами
const stringResult = identity<string>('Привет');
const numberResult = identity<number>(42);
const booleanResult = identity<boolean>(true);

// Вывод типа - компилятор сам определяет тип
const autoString = identity('Привет');
const autoNumber = identity(42);

// Дженерик массив
function getFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const firstString = getFirstElement(['a', 'b', 'c']); // string | undefined
const firstNumber = getFirstElement([1, 2, 3]); // number | undefined

// Дженерик класс
class Container<T> {
  private value: T;
  
  constructor(value: T) {
    this.value = value;
  }
  
  getValue(): T {
    return this.value;
  }
  
  setValue(value: T): void {
    this.value = value;
  }
}

// Использование с разными типами
const stringContainer = new Container<string>('Текст');
const numberContainer = new Container<number>(123);
const objectContainer = new Container<{name: string}>({name: 'Иван'});

console.log(stringContainer.getValue()); // Текст
console.log(numberContainer.getValue()); // 123
console.log(objectContainer.getValue()); // {name: 'Иван'}
```

### Ограничения дженериков (Constraints)
```typescript
// Ограничение дженерика
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(`Длина: ${arg.length}`);
  return arg;
}

// Работает с типами, имеющими свойство length
logLength('Привет'); // string
logLength([1, 2, 3]); // number[]
logLength({length: 10, value: 'test'}); // {length: number, value: string}

// Не работает с типами без свойства length
// logLength(123); // Ошибка!

// Ограничение с несколькими интерфейсами
interface Nameable {
  name: string;
}

interface Ageable {
  age: number;
}

function processPerson<T extends Nameable & Ageable>(person: T): string {
  return `${person.name}, возраст: ${person.age}`;
}

const person = {name: 'Иван', age: 30, city: 'Москва'};
console.log(processPerson(person)); // Иван, возраст: 30
```

### Дженерики в интерфейсах и типах
```typescript
// Дженерик интерфейс
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

const stringNumberPair: KeyValuePair<string, number> = {
  key: 'возраст',
  value: 25
};

const numberBooleanPair: KeyValuePair<number, boolean> = {
  key: 1,
  value: true
};

// Дженерик тип
type ResponseData<T> = {
  data: T;
  status: number;
  message: string;
};

const userResponse: ResponseData<{name: string, email: string}> = {
  data: {name: 'Иван', email: 'ivan@example.com'},
  status: 200,
  message: 'Успешно'
};

const usersResponse: ResponseData<{name: string, email: string}[]> = {
  data: [
    {name: 'Иван', email: 'ivan@example.com'},
    {name: 'Мария', email: 'maria@example.com'}
  ],
  status: 200,
  message: 'Успешно'
};
```

### Дженерики в классах
```typescript
// Дженерик класс с несколькими параметрами
class Dictionary<K, V> {
  private items: Map<K, V> = new Map();
  
  set(key: K, value: V): void {
    this.items.set(key, value);
  }
  
  get(key: K): V | undefined {
    return this.items.get(key);
  }
  
  has(key: K): boolean {
    return this.items.has(key);
  }
  
  delete(key: K): boolean {
    return this.items.delete(key);
  }
  
  keys(): K[] {
    return Array.from(this.items.keys());
  }
  
  values(): V[] {
    return Array.from(this.items.values());
  }
}

// Использование
const stringNumberDict = new Dictionary<string, number>();
stringNumberDict.set('один', 1);
stringNumberDict.set('два', 2);
console.log(stringNumberDict.get('один')); // 1

const objectStringDict = new Dictionary<{id: number}, string>();
objectStringDict.set({id: 1}, 'Первый элемент');
objectStringDict.set({id: 2}, 'Второй элемент');
console.log(objectStringDict.get({id: 1})); // undefined (разные объекты)
```

## Продвинутые возможности дженериков

### Условные типы (Conditional Types)
```typescript
// Условные типы с дженериками
type NonNullable<T> = T extends null | undefined ? never : T;

type A = NonNullable<string | null>; // string
type B = NonNullable<number | undefined>; // number
type C = NonNullable<string | null | undefined>; // string

// Дженерик с условным типом
type Flatten<T> = T extends (infer U)[] ? U : T;

type D = Flatten<number[]>; // number
type E = Flatten<string>; // string
```

### Вывод типов (Type Inference)
```typescript
// Вывод типов в дженериках
function firstElement<T>(arr: T[]): T {
  return arr[0];
}

// Тип выводится автоматически
const first = firstElement([1, 2, 3]); // number

// Дженерик с несколькими параметрами и выводом
function mapArray<T, U>(arr: T[], fn: (item: T) => U): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3];
const strings = mapArray(numbers, x => x.toString()); // string[]
```

### Ключевые слова keyof и typeof
```typescript
// keyof с дженериками
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = {name: 'Иван', age: 30};
const name = getProperty(person, 'name'); // string
const age = getProperty(person, 'age'); // number

// typeof с дженериками
function createProxy<T extends object>(obj: T): T {
  return new Proxy(obj, {
    get(target, prop) {
      console.log(`Доступ к свойству: ${String(prop)}`);
      return target[prop as keyof T];
    }
  });
}

const proxyPerson = createProxy({name: 'Иван', age: 30});
console.log(proxyPerson.name); // Доступ к свойству: name, затем "Иван"
```

## Преимущества дженериков

### Типобезопасность
Дженерики сохраняют строгую типизацию при работе с универсальными компонентами.

### Переиспользование кода
Один и тот же код может работать с различными типами данных.

### Автозавершение
IDE может предоставлять автозавершение на основе выведенных типов.

### Предотвращение ошибок
Дженерики помогают предотвратить ошибки времени выполнения.

## Недостатки дженериков

### Сложность понимания
Для новичков дженерики могут быть сложными для понимания.

### Усложнение кода
Избыточное использование дженериков может усложнить код.

### Ограничения в runtime
Дженерики существуют только во время компиляции и не доступны в runtime.

## Паттерны, использующие дженерики

### Фабрика (Factory)
```typescript
// Фабрика с дженериками
interface Product {
  operation(): string;
}

class ConcreteProductA implements Product {
  operation(): string {
    return 'Результат продукта A';
  }
}

class ConcreteProductB implements Product {
  operation(): string {
    return 'Результат продукта B';
  }
}

class Factory<T extends Product> {
  create(type: new () => T): T {
    return new type();
  }
}

// Использование
const factory = new Factory<Product>();
const productA = factory.create(ConcreteProductA);
const productB = factory.create(ConcreteProductB);

console.log(productA.operation()); // Результат продукта A
console.log(productB.operation()); // Результат продукта B
```

### Репозиторий (Repository)
```typescript
// Репозиторий с дженериками
interface Entity {
  id: number;
}

class Repository<T extends Entity> {
  private entities: Map<number, T> = new Map();
  
  save(entity: T): T {
    this.entities.set(entity.id, entity);
    return entity;
  }
  
  findById(id: number): T | undefined {
    return this.entities.get(id);
  }
  
  findAll(): T[] {
    return Array.from(this.entities.values());
  }
  
  delete(id: number): boolean {
    return this.entities.delete(id);
  }
}

// Конкретные сущности
interface User extends Entity {
  name: string;
  email: string;
}

interface Product extends Entity {
  title: string;
  price: number;
}

// Конкретные репозитории
const userRepository = new Repository<User>();
const productRepository = new Repository<Product>();

const user: User = {id: 1, name: 'Иван', email: 'ivan@example.com'};
const product: Product = {id: 1, title: 'Товар', price: 100};

userRepository.save(user);
productRepository.save(product);

console.log(userRepository.findById(1)); // {id: 1, name: 'Иван', email: 'ivan@example.com'}
console.log(productRepository.findById(1)); // {id: 1, title: 'Товар', price: 100}
```

## Связь с другими концепциями

- [[ts]] - Дженерики являются важной частью системы типов TypeScript
- [[Полиморфизм]] - Дженерики реализуют параметрический полиморфизм
- [[Интерфейсы]] - Дженерики часто используются с интерфейсами
- [[SOLID]] - Дженерики помогают соблюдать принцип открытости/закрытости (OCP)
- [[DRY (Don't Repeat Yourself)]] - Дженерики способствуют избеганию дублирования кода
- [[Чистый код]] - Дженерики способствуют написанию более чистого и универсального кода

## Применение в современных технологиях

### В [[ts]]
TypeScript предоставляет мощную поддержку дженериков:
- Дженерики в функциях, классах, интерфейсах и типах
- Ограничения дженериков (extends)
- Условные типы с дженериками
- Вывод типов

### В [[js]]
JavaScript косвенно поддерживает дженерики через:
- JSDoc аннотации
- Библиотеки для проверки типов (Flow)
- Документирование API

### В [[react]]
React активно использует дженерики:
- Типизация компонентов с props
- Хуки с дженериками (useState, useRef, useContext)
- Типизация событий и элементов DOM

## Теги
#generics #typescript #programming-concepts #type-system #polymorphism #software-design