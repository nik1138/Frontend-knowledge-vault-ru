---
aliases: [Declarative Programming]
tags: [programming, frontend, paradigm, react]
---

# Декларативное программирование

**Декларативное программирование** — это парадигма программирования, при которой задача описывается в терминах того, **что** должно быть сделано, а не **как** это должно быть сделано. В отличие от императивного программирования, декларативное программирование фокусируется на описании желаемого результата, а не на пошаговых инструкциях.

## Основные принципы

### Что vs Как

**Императивный подход** (как это сделать):
```javascript
// Императивное обновление DOM
const container = document.getElementById('user-list');
container.innerHTML = ''; // Очистка

users.forEach(user => {
  const div = document.createElement('div');
  div.className = 'user-item';
  
  const nameSpan = document.createElement('span');
  nameSpan.textContent = user.name;
  
  const emailSpan = document.createElement('span');
  emailSpan.textContent = user.email;
  
  div.appendChild(nameSpan);
  div.appendChild(emailSpan);
  container.appendChild(div);
});
```

**Декларативный подход** (что должно быть):
```jsx
// Декларативное описание UI в React
function UserList({ users }) {
  return (
    <div id="user-list">
      {users.map(user => (
        <div key={user.id} className="user-item">
          <span>{user.name}</span>
          <span>{user.email}</span>
        </div>
      ))}
    </div>
  );
}
```

## Применение в фронтенд-разработке

### JSX и React

```jsx
// Декларативное описание интерфейса
function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Изучить React', completed: false },
    { id: 2, text: 'Написать приложение', completed: true }
  ]);
  
  const [newTodo, setNewTodo] = useState('');
  
  const addTodo = () => {
    if (newTodo.trim()) {
      setTodos([...todos, {
        id: Date.now(),
        text: newTodo,
        completed: false
      }]);
      setNewTodo('');
    }
  };
  
  // Декларативное описание UI на основе состояния
  return (
    <div className="todo-app">
      <h1>Список дел</h1>
      
      <div className="todo-input">
        <input
          value={newTodo}
          onChange={(e) => setNewTodo(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="Добавить задачу"
        />
        <button onClick={addTodo}>Добавить</button>
      </div>
      
      <ul className="todo-list">
        {todos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={() => toggleTodo(todo.id)}
            onDelete={() => deleteTodo(todo.id)}
          />
        ))}
      </ul>
    </div>
  );
}

function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
      />
      <span className="todo-text">{todo.text}</span>
      <button onClick={onDelete} className="delete-btn">Удалить</button>
    </li>
  );
}
```

### CSS как декларативный язык

```css
/* Декларативное описание стилей */
.user-card {
  display: flex;
  flex-direction: column;
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.user-card:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.user-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  object-fit: cover;
}
```

### SQL-подобные операции в JavaScript

```javascript
// Декларативная обработка данных
const users = [
  { id: 1, name: 'Иван', age: 25, active: true },
  { id: 2, name: 'Мария', age: 30, active: false },
  { id: 3, name: 'Петр', age: 35, active: true }
];

// Что мы хотим: получить имена активных пользователей старше 25 лет
const activeUsersOver25 = users
  .filter(user => user.active && user.age > 25)
  .map(user => user.name);

// Вместо императивного подхода с циклами и условиями
```

## Декларативные библиотеки и фреймворки

### Vue.js

```vue
<template>
  <!-- Декларативное описание интерфейса -->
  <div class="user-profile">
    <h2>{{ user.name }}</h2>
    <p>{{ user.email }}</p>
    
    <div v-if="user.isActive" class="status active">
      Активен
    </div>
    <div v-else class="status inactive">
      Неактивен
    </div>
    
    <ul v-for="post in user.posts" :key="post.id">
      <li>{{ post.title }}</li>
    </ul>
    
    <button @click="updateProfile">Обновить профиль</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      user: {
        name: 'Иван',
        email: 'ivan@example.com',
        isActive: true,
        posts: []
      }
    }
  },
  methods: {
    async updateProfile() {
      // Обновление состояния, интерфейс автоматически обновится
      this.user = await fetchUserProfile();
    }
  },
  async created() {
    this.user = await fetchUserProfile();
  }
}
</script>
```

### Angular

```typescript
// Компонент с декларативным шаблоном
@Component({
  selector: 'app-user-list',
  template: `
    <div class="user-list">
      <div 
        *ngFor="let user of users; trackBy: trackByUserId" 
        class="user-card"
        [class.active]="user.isActive"
      >
        <h3>{{ user.name }}</h3>
        <p>{{ user.email }}</p>
        <button (click)="selectUser(user)">Выбрать</button>
      </div>
    </div>
  `
})
export class UserListComponent {
  users: User[] = [];
  selectedUser: User | null = null;
  
  async ngOnInit() {
    this.users = await this.userService.getUsers();
  }
  
  selectUser(user: User) {
    this.selectedUser = user;
  }
  
  trackByUserId(index: number, user: User): number {
    return user.id;
  }
}
```

## Практические примеры

### Условный рендеринг

```jsx
// Декларативный условный рендеринг
function UserProfile({ user, loading, error }) {
  if (loading) {
    return <div className="loading">Загрузка...</div>;
  }
  
  if (error) {
    return <div className="error">Ошибка: {error.message}</div>;
  }
  
  if (!user) {
    return <div className="no-user">Пользователь не найден</div>;
  }
  
  return (
    <div className="user-profile">
      <img src={user.avatar} alt={user.name} />
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <UserStats stats={user.stats} />
    </div>
  );
}
```

### Анимации и переходы

```jsx
// Декларативные анимации с Framer Motion
import { motion, AnimatePresence } from 'framer-motion';

function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  return (
    <div className="todo-app">
      <AnimatePresence>
        {todos.map(todo => (
          <motion.div
            key={todo.id}
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, x: 100 }}
            transition={{ duration: 0.3 }}
            className="todo-item"
          >
            {todo.text}
            <button onClick={() => removeTodo(todo.id)}>Удалить</button>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
}
```

### Формы

```jsx
// Декларативное описание формы с валидацией
function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  const [errors, setErrors] = useState({});
  
  const handleChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Валидация в реальном времени
    if (errors[field]) {
      validateField(field, value);
    }
  };
  
  const validateField = (field, value) => {
    const newErrors = { ...errors };
    
    switch (field) {
      case 'email':
        if (!value || !/\S+@\S+\.\S+/.test(value)) {
          newErrors.email = 'Некорректный email';
        } else {
          delete newErrors.email;
        }
        break;
      case 'name':
        if (!value || value.length < 2) {
          newErrors.name = 'Имя должно быть не менее 2 символов';
        } else {
          delete newErrors.name;
        }
        break;
    }
    
    setErrors(newErrors);
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Валидация всех полей
    const newErrors = validateAllFields(formData);
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      // Отправка формы
      submitForm(formData);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <InputField
        label="Имя"
        value={formData.name}
        onChange={(value) => handleChange('name', value)}
        error={errors.name}
      />
      
      <InputField
        label="Email"
        type="email"
        value={formData.email}
        onChange={(value) => handleChange('email', value)}
        error={errors.email}
      />
      
      <TextArea
        label="Сообщение"
        value={formData.message}
        onChange={(value) => handleChange('message', value)}
        error={errors.message}
      />
      
      <button 
        type="submit" 
        disabled={Object.keys(errors).length > 0}
      >
        Отправить
      </button>
    </form>
  );
}
```

## Преимущества декларативного подхода

### 1. Читаемость и понятность

```jsx
// Декларативный подход - легко понять намерение
function UserDashboard({ user }) {
  return (
    <div className="dashboard">
      <Header user={user} />
      <Navigation />
      {user.isAdmin && <AdminPanel />}
      <MainContent user={user} />
      <Footer />
    </div>
  );
}

// Императивный подход - требует больше когнитивных усилий
function UserDashboardImperative({ user }) {
  const element = document.createElement('div');
  element.className = 'dashboard';
  
  const header = createHeader(user);
  element.appendChild(header);
  
  const nav = createNavigation();
  element.appendChild(nav);
  
  if (user.isAdmin) {
    const adminPanel = createAdminPanel();
    element.appendChild(adminPanel);
  }
  
  const main = createMainContent(user);
  element.appendChild(main);
  
  const footer = createFooter();
  element.appendChild(footer);
  
  return element;
}
```

### 2. Легкость тестирования

```jsx
// Легко тестировать декларативные компоненты
function UserCard({ user }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p className={user.active ? 'active' : 'inactive'}>
        {user.active ? 'Активен' : 'Неактивен'}
      </p>
    </div>
  );
}

// Тест
test('отображает статус пользователя', () => {
  const user = { name: 'Иван', active: true, avatar: 'avatar.jpg' };
  const { getByText } = render(<UserCard user={user} />);
  
  expect(getByText('Активен')).toBeInTheDocument();
});
```

### 3. Предсказуемость

```jsx
// Состояние полностью определяет UI
function Counter({ initialCount = 0 }) {
  const [count, setCount] = useState(initialCount);
  
  // UI полностью определяется значением count
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(initialCount)}>Сброс</button>
    </div>
  );
}
```

## Связанные концепции

- [[Компонентный-подход]] - декларативное описание компонентов интерфейса
- [[Реактивное программирование]] - автоматическое обновление UI при изменении данных
- [[Функциональное программирование]] - связанная парадигма
- [[Управление состоянием]] - декларативное управление состоянием приложения
- [[Абстракция]] - декларативные интерфейсы как абстракции

## Лучшие практики

1. **Описывайте UI как функцию состояния**: интерфейс должен быть предсказуемой функцией данных
2. **Используйте чистые функции**: компоненты должны возвращать одинаковый результат для одних и тех же пропсов
3. **Минимизируйте побочные эффекты**: декларативный код должен быть свободен от побочных эффектов
4. **Используйте именованные функции для сложной логики**: выносите сложную логику в отдельные функции
5. **Думайте в терминах трансформаций данных**: преобразуйте данные в UI, а не управляйте DOM напрямую

## Заключение

Декларативное программирование делает код более понятным, предсказуемым и легким в поддержке. В фронтенд-разработке это подход, при котором мы описываем, как интерфейс должен выглядеть для данного состояния, а фреймворк заботится о том, как эффективно обновить DOM. Это позволяет разработчикам сосредоточиться на бизнес-логике, а не на деталях реализации обновлений интерфейса.