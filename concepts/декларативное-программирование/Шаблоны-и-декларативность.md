---
aliases: [Декларативные шаблоны, Шаблоны программирования, HTML шаблоны]
tags: [programming, templates, frontend, declarative, html]
---

# Шаблоны и декларативность: декларативное описание интерфейса

## Обзор

Шаблоны играют ключевую роль в декларативном программировании, особенно в контексте фронтенд-разработки. Они позволяют описывать структуру пользовательского интерфейса в декларативной форме, что делает код более читаемым, понятным и поддерживаемым.

## Что такое шаблоны в контексте декларативности

Шаблоны - это декларативные описания структуры интерфейса, которые могут быть заполнены данными. Они позволяют отделить структуру от логики и данных, что является ключевым принципом декларативного подхода.

## Типы шаблонов

### 1. HTML-шаблоны

HTML сам по себе является декларативным шаблоном:

```html
<!-- Простой HTML-шаблон -->
<div class="product-card">
    <img src="{{product.image}}" alt="{{product.name}}" />
    <h3>{{product.name}}</h3>
    <p class="price">{{product.price}}</p>
    <button class="add-to-cart">Добавить в корзину</button>
</div>
```

### 2. Шаблоны в фреймворках

#### React (JSX)
```jsx
// JSX как декларативный шаблон
function ProductCard({ product }) {
    return (
        <div className="product-card">
            <img src={product.image} alt={product.name} />
            <h3>{product.name}</h3>
            <p className="price">${product.price}</p>
            <button 
                className="add-to-cart"
                onClick={() => addToCart(product)}
            >
                Добавить в корзину
            </button>
        </div>
    );
}
```

#### Vue
```vue
<!-- Vue-шаблон -->
<template>
    <div class="product-card">
        <img :src="product.image" :alt="product.name" />
        <h3>{{ product.name }}</h3>
        <p class="price">${{ product.price }}</p>
        <button @click="addToCart(product)">
            Добавить в корзину
        </button>
    </div>
</template>
```

### 3. Шаблоны с условной отрисовкой

```jsx
// Условные шаблоны в React
function UserCard({ user }) {
    return (
        <div className="user-card">
            <h3>{user.name}</h3>
            {user.avatar && (
                <img src={user.avatar} alt={user.name} />
            )}
            {user.verified && (
                <span className="verified-badge">✓</span>
            )}
            {!user.verified && user.pending && (
                <span className="pending-badge">Ожидает верификации</span>
            )}
        </div>
    );
}
```

## Продвинутые шаблонные паттерны

### 1. Шаблоны с повторяющимися элементами

```jsx
// Список элементов с шаблоном
function ProductList({ products }) {
    return (
        <div className="product-grid">
            {products.map(product => (
                <ProductCard 
                    key={product.id} 
                    product={product} 
                />
            ))}
        </div>
    );
}
```

### 2. Композиционные шаблоны

```jsx
// Шаблон как композиция других шаблонов
function DashboardLayout({ children, sidebarItems }) {
    return (
        <div className="dashboard">
            <aside className="sidebar">
                <nav>
                    {sidebarItems.map(item => (
                        <NavLink 
                            key={item.id} 
                            to={item.path}
                            active={item.active}
                        >
                            {item.icon && <Icon name={item.icon} />}
                            {item.label}
                        </NavLink>
                    ))}
                </nav>
            </aside>
            
            <main className="main-content">
                {children}
            </main>
            
            <footer className="dashboard-footer">
                <p>© 2023 Dashboard App</p>
            </footer>
        </div>
    );
}
```

### 3. Шаблоны с динамическими классами

```jsx
// Динамические стили в шаблонах
function StatusBadge({ status, text }) {
    const statusClass = `badge badge-${status}`;
    const additionalClass = status === 'error' ? 'shake-animation' : '';
    
    return (
        <span className={`${statusClass} ${additionalClass}`}>
            {text}
        </span>
    );
}

// Или с использованием библиотеки classnames
import classNames from 'classnames';

function StatusBadge({ status, text, isActive }) {
    return (
        <span className={
            classNames('badge', {
                'badge-success': status === 'success',
                'badge-error': status === 'error',
                'badge-warning': status === 'warning',
                'active': isActive
            })
        }>
            {text}
        </span>
    );
}
```

## Шаблоны с вложенными данными

### Рекурсивные шаблоны

```jsx
// Рекурсивный шаблон для дерева данных
function TreeNode({ node, level = 0 }) {
    return (
        <div className={`tree-node level-${level}`}>
            <div className="node-content">
                {node.icon && <span className="node-icon">{node.icon}</span>}
                <span className="node-label">{node.label}</span>
            </div>
            
            {node.children && node.children.length > 0 && (
                <div className="node-children">
                    {node.children.map(child => (
                        <TreeNode 
                            key={child.id} 
                            node={child} 
                            level={level + 1} 
                        />
                    ))}
                </div>
            )}
        </div>
    );
}
```

### Шаблоны с асинхронными данными

```jsx
// Шаблоны для обработки асинхронного состояния
function AsyncDataComponent({ promise }) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        promise
            .then(result => {
                setData(result);
                setLoading(false);
            })
            .catch(err => {
                setError(err);
                setLoading(false);
            });
    }, [promise]);
    
    return (
        <div className="async-container">
            {loading && <LoadingSpinner />}
            {error && <ErrorMessage error={error} />}
            {data && <DataDisplay data={data} />}
        </div>
    );
}
```

## Шаблоны с пользовательскими хуками

```jsx
// Пользовательский хук для управления шаблоном
function useToggle(initialValue = false) {
    const [value, setValue] = useState(initialValue);
    const toggle = useCallback(() => setValue(v => !v), []);
    return [value, toggle];
}

// Использование в шаблоне
function CollapsibleSection({ title, children }) {
    const [isOpen, toggleOpen] = useToggle(false);
    
    return (
        <div className="collapsible-section">
            <button 
                className="section-header"
                onClick={toggleOpen}
            >
                {title}
                <span className={`arrow ${isOpen ? 'open' : ''}`}>
                    ▼
                </span>
            </button>
            
            {isOpen && (
                <div className="section-content">
                    {children}
                </div>
            )}
        </div>
    );
}
```

## Практические рекомендации по созданию шаблонов

### 1. Именование и организация

```jsx
// Хорошо структурированные шаблоны
function UserProfileTemplate({ user }) {
    return (
        <article className="user-profile">
            <header className="profile-header">
                <Avatar src={user.avatar} alt={user.name} />
                <h1>{user.name}</h1>
                <Badge status={user.status} />
            </header>
            
            <section className="profile-details">
                <ContactInfo user={user} />
                <Bio bio={user.bio} />
            </section>
            
            <footer className="profile-actions">
                <FollowButton userId={user.id} />
                <MessageButton userId={user.id} />
            </footer>
        </article>
    );
}
```

### 2. Переиспользуемые шаблоны

```jsx
// Переиспользуемый шаблон карточки
function CardTemplate({ 
    header, 
    body, 
    footer, 
    variant = 'default',
    actions = [] 
}) {
    return (
        <div className={`card card-${variant}`}>
            {header && (
                <div className="card-header">
                    {header}
                    {actions.length > 0 && (
                        <div className="card-actions">
                            {actions.map((action, index) => (
                                <button 
                                    key={index}
                                    className="action-btn"
                                    onClick={action.handler}
                                >
                                    {action.label}
                                </button>
                            ))}
                        </div>
                    )}
                </div>
            )}
            
            <div className="card-body">
                {body}
            </div>
            
            {footer && (
                <div className="card-footer">
                    {footer}
                </div>
            )}
        </div>
    );
}

// Использование
function ProductCard({ product }) {
    return (
        <CardTemplate
            header={
                <>
                    <h3>{product.name}</h3>
                    <span className="price">${product.price}</span>
                </>
            }
            body={
                <img src={product.image} alt={product.name} />
            }
            footer={
                <button onClick={() => addToCart(product)}>
                    Добавить в корзину
                </button>
            }
            actions={[
                { label: 'Избранное', handler: () => toggleFavorite(product) }
            ]}
        />
    );
}
```

## Заключение

Шаблоны являются мощным инструментом для декларативного описания пользовательского интерфейса. Они позволяют создавать чистые, понятные и переиспользуемые компоненты, которые описывают **что** должно быть отображено, а не **как** это сделать. Это делает код более поддерживаемым и понятным для других разработчиков.

> [!tip] Практический совет
> Создавайте шаблоны как чистые описания UI, избегая логики в разметке. Логика должна быть в хуках и функциях, а шаблоны - в описании структуры.

> [!info] См. также
> - [[JSX-и-декларативность]]
> - [[Декларативные-паттерны]]
> - [[Описание-вместо-инструкций]]
> - [[Декларативный-и-императивный-стили]]