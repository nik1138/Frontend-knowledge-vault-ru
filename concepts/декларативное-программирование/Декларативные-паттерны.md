---
aliases: [Декларативные паттерны программирования, Паттерны декларативности]
tags: [programming, patterns, frontend, react, declarative]
---

# Декларативные паттерны программирования

## Обзор

Декларативные паттерны - это шаблоны проектирования, которые помогают писать код, описывающий **что** должно быть сделано, а не **как** это сделать. Эти паттерны особенно важны в современной фронтенд-разработке и при работе с такими фреймворками как [[React]].

## Основные декларативные паттерны

### 1. Паттерн "Компонент" (Component Pattern)

Компоненты описывают, как должна выглядеть часть интерфейса, а не как её создать.

```jsx
// Декларативное описание компонента
function Button({ onClick, children, variant = 'primary' }) {
    return (
        <button 
            className={`btn btn-${variant}`}
            onClick={onClick}
        >
            {children}
        </button>
    );
}

// Использование
<Button variant="success" onClick={handleSubmit}>
    Отправить
</Button>
```

### 2. Паттерн "Состояние как описание" (State as Description)

Состояние описывает текущее состояние UI, а не историю изменений.

```jsx
// Вместо управления DOM напрямую
function TodoApp() {
    const [todos, setTodos] = useState([]);
    const [filter, setFilter] = useState('all');
    
    // Интерфейс декларативно описывает, как должен выглядеть
    // в зависимости от текущего состояния
    return (
        <div>
            <FilterControls 
                currentFilter={filter} 
                onFilterChange={setFilter} 
            />
            <TodoList 
                todos={todos} 
                filter={filter} 
            />
        </div>
    );
}
```

### 3. Паттерн "Фильтрация и преобразование" (Filter & Transform)

Использование методов массивов для декларативной обработки данных.

```javascript
// Декларативная обработка данных
const processUsers = (users) => {
    return users
        .filter(user => user.isActive)
        .filter(user => user.role !== 'banned')
        .map(user => ({
            ...user,
            displayName: `${user.firstName} ${user.lastName}`
        }))
        .sort((a, b) => a.displayName.localeCompare(b.displayName));
};
```

### 4. Паттерн "Условная отрисовка" (Conditional Rendering)

Декларативное описание того, что должно быть отображено в зависимости от условий.

```jsx
function UserProfile({ user, isLoading, error }) {
    return (
        <div className="user-profile">
            {isLoading && <LoadingSpinner />}
            {error && <ErrorMessage message={error} />}
            {!isLoading && !error && user && (
                <div>
                    <h1>{user.name}</h1>
                    <p>{user.email}</p>
                </div>
            )}
            {!user && !isLoading && !error && (
                <p>Пользователь не найден</p>
            )}
        </div>
    );
}
```

### 5. Паттерн "Композиция компонентов" (Component Composition)

Создание сложных интерфейсов путем композиции простых компонентов.

```jsx
// Простые компоненты
function Header() { return <header>...</header>; }
function Sidebar() { return <aside>...</aside>; }
function MainContent() { return <main>...</main>; }
function Footer() { return <footer>...</footer>; }

// Композиция в сложном компоненте
function Layout({ children }) {
    return (
        <div className="app-layout">
            <Header />
            <div className="main-container">
                <Sidebar />
                <MainContent>{children}</MainContent>
            </div>
            <Footer />
        </div>
    );
}
```

## Продвинутые декларативные паттерны

### 6. Паттерн "Конфигурация вместо кода" (Configuration over Code)

Использование конфигурационных объектов для описания поведения.

```javascript
// Конфигурация формы
const formConfig = {
    fields: [
        { name: 'email', type: 'email', required: true },
        { name: 'password', type: 'password', required: true, minLength: 8 },
        { name: 'name', type: 'text', required: false }
    ],
    validationRules: {
        email: (value) => /\S+@\S+\.\S+/.test(value),
        password: (value) => value.length >= 8
    }
};

// Компонент использует конфигурацию для построения формы
function DynamicForm({ config }) {
    return (
        <form>
            {config.fields.map(field => (
                <InputField 
                    key={field.name}
                    config={field}
                />
            ))}
        </form>
    );
}
```

### 7. Паттерн "Описание маршрутов" (Route Definition)

Декларативное определение маршрутов приложения.

```jsx
// Определение маршрутов как конфигурации
const routes = [
    { path: '/', component: Home },
    { path: '/about', component: About },
    { path: '/users/:id', component: UserDetail },
    { 
        path: '/admin',
        component: AdminPanel,
        authRequired: true,
        roles: ['admin']
    }
];

// Использование в роутере
function AppRouter() {
    return (
        <BrowserRouter>
            <Routes>
                {routes.map(route => (
                    <Route 
                        key={route.path}
                        path={route.path}
                        element={
                            route.authRequired ? 
                                <AuthWrapper roles={route.roles}>
                                    <route.component />
                                </AuthWrapper> :
                                <route.component />
                        }
                    />
                ))}
            </Routes>
        </BrowserRouter>
    );
}
```

### 8. Паттерн "Описание стилей" (Styling as Description)

CSS-in-JS и styled-components как декларативные паттерны стилизации.

```jsx
import styled from 'styled-components';

// Декларативное описание стилей
const StyledButton = styled.button`
    background-color: ${props => props.variant === 'primary' ? '#007bff' : '#6c757d'};
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: ${props => props.disabled ? 'not-allowed' : 'pointer'};
    
    &:hover {
        opacity: ${props => props.disabled ? 1 : 0.8};
    }
`;

// Использование
function MyComponent() {
    return <StyledButton variant="primary">Нажми меня</StyledButton>;
}
```

## Практические рекомендации по применению

### 1. Идентификация императивного кода

Ищите:
- Циклы, которые модифицируют DOM напрямую
- Многоуровневые условные конструкции
- Повторяющийся код для похожих задач

### 2. Рефакторинг к декларативному стилю

```javascript
// До: императивный подход
function updateUI(users) {
    const container = document.getElementById('user-list');
    container.innerHTML = '';
    
    for (let i = 0; i < users.length; i++) {
        const user = users[i];
        const div = document.createElement('div');
        div.className = 'user-item';
        div.innerHTML = `
            <h3>${user.name}</h3>
            <p>${user.email}</p>
        `;
        container.appendChild(div);
    }
}

// После: декларативный подход
function UserList({ users }) {
    return (
        <div className="user-list">
            {users.map(user => (
                <UserItem key={user.id} user={user} />
            ))}
        </div>
    );
}
```

### 3. Создание декларативных утилит

```javascript
// Утилита для декларативной валидации
const validators = {
    required: value => value && value.trim().length > 0,
    email: value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    minLength: min => value => value && value.length >= min,
    custom: fn => fn
};

function validateField(value, rules) {
    return rules.map(rule => {
        const [validator, params] = Array.isArray(rule) ? rule : [rule, null];
        const validatorFn = typeof validator === 'function' ? validator : 
                           params ? validators[validator](params) : 
                           validators[validator];
        
        return validatorFn(value);
    }).every(result => result === true);
}
```

## Заключение

Декларативные паттерны позволяют создавать более читаемый, поддерживаемый и предсказуемый код. Они особенно эффективны в фронтенд-разработке, где важна согласованность и предсказуемость пользовательского интерфейса.

> [!tip] Практический совет
> При проектировании компонентов думайте о них как о "описаниях" UI, а не как о "инструкциях" по его созданию.

> [!info] См. также
> - [[Описание-вместо-инструкций]]
> - [[JSX-и-декларативность]]
> - [[Шаблоны-и-декларативность]]