# Системное программирование

Системное программирование — это область программирования, связанная с созданием программного обеспечения, которое работает на низком уровне и взаимодействует непосредственно с аппаратными компонентами компьютера. Системное программное обеспечение включает операционные системы, драйверы устройств, утилиты и другие программы, которые управляют и поддерживают работу компьютерной системы.

## Основные характеристики

### Низкоуровневый доступ
Системное программирование требует прямого взаимодействия с аппаратными ресурсами, такими как память, процессор и устройства ввода-вывода.

```c
// Пример системного программирования на C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();  // Создание нового процесса
    
    if (pid == 0) {
        // Дочерний процесс
        printf("Child process with PID: %d\n", getpid());
        exit(0);
    } else if (pid > 0) {
        // Родительский процесс
        printf("Parent process with PID: %d\n", getpid());
        wait(NULL);  // Ожидание завершения дочернего процесса
    } else {
        // Ошибка
        perror("fork failed");
        exit(1);
    }
    
    return 0;
}
```

### Эффективность и производительность
Системные программы должны быть максимально эффективными и использовать минимальное количество ресурсов.

```assembly
; Пример на ассемблере x86
section .data
    msg db 'Hello, World!', 0xA
    len equ $ - msg

section .text
    global _start

_start:
    ; Запись сообщения в stdout
    mov eax, 4          ; системный вызов sys_write
    mov ebx, 1          ; файловый дескриптор stdout
    mov ecx, msg        ; указатель на сообщение
    mov edx, len        ; длина сообщения
    int 0x80            ; вызов ядра
    
    ; Завершение программы
    mov eax, 1          ; системный вызов sys_exit
    xor ebx, ebx        ; код возврата 0
    int 0x80            ; вызов ядра
```

### Работа с памятью
Системное программирование требует точного управления памятью без автоматического сборщика мусора.

```c
// Управление памятью в системном программировании
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    void *address;
    size_t size;
    int allocated;
} MemoryBlock;

#define POOL_SIZE 1024
static char memory_pool[POOL_SIZE];
static MemoryBlock blocks[100];
static int block_count = 0;

void *custom_malloc(size_t size) {
    // Простой аллокатор памяти
    static size_t pool_offset = 0;
    
    if (pool_offset + size > POOL_SIZE) {
        return NULL;  // Недостаточно памяти
    }
    
    void *ptr = &memory_pool[pool_offset];
    pool_offset += size;
    
    // Сохраняем информацию о блоке
    blocks[block_count].address = ptr;
    blocks[block_count].size = size;
    blocks[block_count].allocated = 1;
    block_count++;
    
    return ptr;
}
```

## Основные области применения

### Операционные системы
Операционные системы — это основной пример системного программирования.

```c
// Упрощенный пример планировщика задач
typedef struct {
    int pid;
    int priority;
    int state;  // 0 - готов, 1 - выполняется, 2 - заблокирован
} Process;

Process process_table[100];
int current_process = 0;

void schedule() {
    // Простой алгоритм планирования по приоритетам
    int highest_priority = -1;
    int next_process = current_process;
    
    for (int i = 0; i < 100; i++) {
        if (process_table[i].state == 0 && 
            process_table[i].priority > highest_priority) {
            highest_priority = process_table[i].priority;
            next_process = i;
        }
    }
    
    if (next_process != current_process) {
        // Переключение контекста
        process_table[current_process].state = 0;  // Готов
        process_table[next_process].state = 1;     // Выполняется
        current_process = next_process;
    }
}
```

### Драйверы устройств
Драйверы обеспечивают взаимодействие между операционной системой и аппаратными устройствами.

```c
// Упрощенный пример драйвера устройства
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

#define DEVICE_NAME "mydevice"
#define BUFFER_SIZE 1024

static int major_number;
static char device_buffer[BUFFER_SIZE];
static int buffer_pointer = 0;

// Функции драйвера
static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char *, size_t, loff_t *);

static struct file_operations fops = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release,
};

static int device_open(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Device opened\n");
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Device closed\n");
    return 0;
}

static ssize_t device_read(struct file *file, char *buffer, size_t length, loff_t *offset) {
    int bytes_read = 0;
    
    if (buffer_pointer == 0) {
        return 0;  // EOF
    }
    
    while (length && (buffer_pointer > 0)) {
        put_user(device_buffer[bytes_read], buffer++);
        length--;
        bytes_read++;
        buffer_pointer--;
    }
    
    return bytes_read;
}

static ssize_t device_write(struct file *file, const char *buffer, size_t length, loff_t *offset) {
    int i;
    
    for (i = 0; i < length && i < BUFFER_SIZE; i++) {
        get_user(device_buffer[i], buffer + i);
    }
    
    buffer_pointer = i;
    
    return i;
}
```

### Утилиты и инструменты
Системные утилиты обеспечивают обслуживание и управление системой.

```c
// Пример системной утилиты
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/resource.h>

void print_system_info() {
    struct rusage usage;
    
    if (getrusage(RUSAGE_SELF, &usage) == 0) {
        printf("Использование процессора: %ld.%06ld секунд\n", 
               usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
        printf("Использование памяти: %ld килобайт\n", 
               usage.ru_maxrss);
    }
}

int main(int argc, char *argv[]) {
    printf("Системная утилита мониторинга\n");
    printf("============================\n");
    
    print_system_info();
    
    return 0;
}
```

## Преимущества системного программирования

1. **Полный контроль** — Прямой доступ к аппаратным ресурсам
2. **Высокая производительность** — Минимальные накладные расходы
3. **Эффективное использование ресурсов** — Точное управление памятью и процессором
4. **Стабильность** — Возможность создания надежных систем
5. **Гибкость** — Возможность оптимизации под конкретные задачи

## Связанные концепции

- [[Императивное программирование]] - Системное программирование часто использует императивный подход
- [[Структурное программирование]] - Системные программы следуют принципам структурного программирования
- [[DRY (Don't Repeat Yourself)]] - В системном программировании важно избегать дублирования для повышения надежности
- [[KISS (Keep It Simple, Stupid)]] - Системные программы должны быть простыми и надежными
- [[Чистый код]] - Чистый код особенно важен в системном программировании из-за критичности ошибок

## В других технологиях

### В [[c]]
Язык C является основным языком для системного программирования:

```c
// Пример системного кода на C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void signal_handler(int sig) {
    printf("Получен сигнал %d\n", sig);
    exit(0);
}

int main() {
    // Установка обработчика сигнала
    signal(SIGINT, signal_handler);
    
    printf("Программа запущена. Нажмите Ctrl+C для завершения.\n");
    
    // Бесконечный цикл
    while(1) {
        sleep(1);
        printf(".");
        fflush(stdout);
    }
    
    return 0;
}
```

### В [[python]]
Python может использоваться для системного администрирования:

```python
# Системные скрипты на Python
import os
import psutil
import subprocess

def get_system_info():
    """Получение информации о системе"""
    cpu_percent = psutil.cpu_percent(interval=1)
    memory = psutil.virtual_memory()
    disk = psutil.disk_usage('/')
    
    return {
        'cpu_percent': cpu_percent,
        'memory_percent': memory.percent,
        'disk_percent': (disk.used / disk.total) * 100
    }

def restart_service(service_name):
    """Перезапуск системного сервиса"""
    try:
        subprocess.run(['systemctl', 'restart', service_name], check=True)
        return True
    except subprocess.CalledProcessError:
        return False

# Использование
if __name__ == "__main__":
    info = get_system_info()
    print(f"CPU: {info['cpu_percent']}%")
    print(f"Memory: {info['memory_percent']}%")
    print(f"Disk: {info['disk_percent']:.2f}%")
```

## Теги
#systems-programming #low-level #operating-systems #drivers #utilities