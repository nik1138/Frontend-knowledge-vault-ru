---
aliases: [Интеграционное-тестирование-компонентов, Integration-Testing]
tags: [testing, integration-testing, frontend, components]
---

# Интеграционное тестирование компонентов

Интеграционное тестирование компонентов - это подход к тестированию, при котором несколько компонентов или модулей тестируются вместе как группа, чтобы убедиться в правильности их взаимодействия. В отличие от unit-тестов, которые проверяют отдельные компоненты в изоляции, интеграционные тесты фокусируются на взаимодействиях между компонентами и на то, как они работают вместе.

## Обзор

Интеграционное тестирование компонентов проверяет, как компоненты взаимодействуют друг с другом, как данные передаются между ними и как они работают в составе более крупных частей приложения. Это критически важно для выявления проблем, которые могут возникнуть при объединении отдельных компонентов, даже если каждый из них работает корректно по отдельности.

В контексте фронтенд-разработки интеграционные тесты:
- Проверяют передачу данных между родительским и дочерними компонентами
- Тестируют взаимодействие с внешними сервисами или API
- Проверяют интеграцию с системой управления состоянием (Redux, Context и т.д.)
- Тестируют взаимодействие с библиотеками маршрутизации

## Основы интеграционного тестирования

### Цели интеграционного тестирования

1. **Проверка взаимодействия между компонентами** - убедиться, что компоненты корректно обмениваются данными
2. **Тестирование передачи props** - проверить, что данные корректно передаются от родительского компонента к дочернему
3. **Валидация событий** - убедиться, что события, возникающие в дочерних компонентах, корректно обрабатываются родительскими
4. **Проверка интеграции с внешними сервисами** - тестировать взаимодействие с API, базами данных и другими внешними ресурсами
5. **Тестирование управления состоянием** - проверить, как компоненты взаимодействуют с централизованным хранилищем состояния

### Отличие от unit-тестирования

| Характеристика | Unit-тестирование | Интеграционное тестирование |
|----------------|-------------------|------------------------------|
| Фокус | Отдельные компоненты | Взаимодействие между компонентами |
| Сложность | Проще в написании и поддержке | Более сложные в настройке и отладке |
| Скорость | Быстрые | Медленнее из-за большего объема кода |
| Частота запуска | Часто | Реже, чем unit-тесты |
| Обнаружение ошибок | Локальные ошибки в логике | Ошибки интеграции и взаимодействия |

## Подходы к интеграционному тестированию

### Тестирование композиции компонентов

Этот подход фокусируется на тестировании взаимодействия между несколькими компонентами, которые работают вместе для достижения общей цели.

```javascript
// UserProfile.jsx
import React from 'react';
import UserHeader from './UserHeader';
import UserPosts from './UserPosts';
import UserStats from './UserStats';

const UserProfile = ({ userId }) => {
  return (
    <div className="user-profile">
      <UserHeader userId={userId} />
      <UserStats userId={userId} />
      <UserPosts userId={userId} />
    </div>
  );
};

export default UserProfile;
```

```javascript
// UserProfile.integration.test.jsx
import { render, screen, waitFor } from '@testing-library/react';
import UserProfile from './UserProfile';
import { fetchUser, fetchUserPosts, fetchUserStats } from '../services/userService';

// Мокирование сервисов
jest.mock('../services/userService');

describe('UserProfile Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('отображает информацию о пользователе, его статистику и посты', async () => {
    const mockUser = { id: 1, name: 'Иван Иванов', email: 'ivan@example.com' };
    const mockPosts = [{ id: 1, title: 'Первый пост' }, { id: 2, title: 'Второй пост' }];
    const mockStats = { postsCount: 2, followers: 100 };

    fetchUser.mockResolvedValue(mockUser);
    fetchUserPosts.mockResolvedValue(mockPosts);
    fetchUserStats.mockResolvedValue(mockStats);

    render(<UserProfile userId={1} />);

    // Проверяем, что заголовок пользователя отображается
    expect(screen.getByText('Загрузка...')).toBeInTheDocument();

    // Ждем загрузки данных
    await waitFor(() => {
      expect(screen.getByText('Иван Иванов')).toBeInTheDocument();
    });

    // Проверяем, что статистика отображается
    expect(screen.getByText(/100 подписчиков/)).toBeInTheDocument();

    // Проверяем, что посты отображаются
    expect(screen.getByText('Первый пост')).toBeInTheDocument();
    expect(screen.getByText('Второй пост')).toBeInTheDocument();

    // Проверяем, что сервисы были вызваны с правильными аргументами
    expect(fetchUser).toHaveBeenCalledWith(1);
    expect(fetchUserPosts).toHaveBeenCalledWith(1);
    expect(fetchUserStats).toHaveBeenCalledWith(1);
  });
});
```

### Тестирование с использованием контекста

При тестировании компонентов, использующих React Context, важно проверить, как они взаимодействуют с провайдерами контекста.

```javascript
// ThemeContext.jsx
import React, { createContext, useContext } from 'react';

const ThemeContext = createContext();

export const ThemeProvider = ({ children, theme }) => (
  <ThemeContext.Provider value={theme}>
    {children}
  </ThemeContext.Provider>
);

export const useTheme = () => useContext(ThemeContext);
```

```javascript
// ButtonWithContext.jsx
import React from 'react';
import { useTheme } from './ThemeContext';

const ButtonWithContext = ({ children, onClick }) => {
  const { primaryColor } = useTheme();
  
  return (
    <button 
      style={{ backgroundColor: primaryColor }}
      onClick={onClick}
    >
      {children}
    </button>
  );
};

export default ButtonWithContext;
```

```javascript
// ButtonWithContext.integration.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import ButtonWithContext from './ButtonWithContext';
import { ThemeProvider } from './ThemeContext';

describe('ButtonWithContext Integration', () => {
  test('использует тему из контекста', () => {
    const mockTheme = { primaryColor: '#007bff' };
    const mockOnClick = jest.fn();

    render(
      <ThemeProvider theme={mockTheme}>
        <ButtonWithContext onClick={mockOnClick}>
          Нажми меня
        </ButtonWithContext>
      </ThemeProvider>
    );

    const button = screen.getByRole('button');
    
    // Проверяем, что кнопка использует цвет из темы
    expect(button).toHaveStyle({ backgroundColor: '#007bff' });
    
    // Проверяем, что обработчик вызывается при клике
    fireEvent.click(button);
    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });
});
```

### Тестирование с Redux

При использовании Redux важно тестировать, как компоненты взаимодействуют с хранилищем.

```javascript
// TodoListContainer.jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import TodoItem from './TodoItem';

const TodoListContainer = () => {
  const todos = useSelector(state => state.todos.items);
  const dispatch = useDispatch();

  const handleToggle = (id) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };

  return (
    <div className="todo-list">
      {todos.map(todo => (
        <TodoItem 
          key={todo.id} 
          todo={todo} 
          onToggle={handleToggle} 
        />
      ))}
    </div>
  );
};

export default TodoListContainer;
```

```javascript
// TodoListContainer.integration.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import TodoListContainer from './TodoListContainer';

// Простой редьюсер для тестирования
const todosReducer = (state = { items: [] }, action) => {
  switch (action.type) {
    case 'SET_TODOS':
      return { items: action.payload };
    case 'TOGGLE_TODO':
      return {
        items: state.items.map(todo =>
          todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo
        )
      };
    default:
      return state;
  }
};

describe('TodoListContainer Integration', () => {
  let store;

  const renderWithRedux = (initialState = { items: [] }) => {
    store = configureStore({
      reducer: {
        todos: todosReducer
      },
      preloadedState: { todos: initialState }
    });

    return render(
      <Provider store={store}>
        <TodoListContainer />
      </Provider>
    );
  };

  test('отображает список дел и позволяет переключать статус', () => {
    const initialTodos = [
      { id: 1, text: 'Задача 1', completed: false },
      { id: 2, text: 'Задача 2', completed: true }
    ];

    renderWithRedux({ items: initialTodos });

    // Проверяем, что задачи отображаются
    expect(screen.getByText('Задача 1')).toBeInTheDocument();
    expect(screen.getByText('Задача 2')).toBeInTheDocument();

    // Проверяем начальное состояние чекбоксов
    const checkboxes = screen.getAllByRole('checkbox');
    expect(checkboxes[0]).not.toBeChecked(); // Первая задача не выполнена
    expect(checkboxes[1]).toBeChecked();     // Вторая задача выполнена

    // Переключаем первую задачу
    fireEvent.click(checkboxes[0]);

    // Проверяем, что состояние изменилось
    expect(checkboxes[0]).toBeChecked();
  });
});
```

## Практические примеры

### Тестирование формы с валидацией

```javascript
// LoginForm.jsx
import React, { useState } from 'react';
import { validateEmail, validatePassword } from '../utils/validation';

const LoginForm = ({ onSubmit }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();
    
    const emailError = validateEmail(email);
    const passwordError = validatePassword(password);
    
    const newErrors = {
      email: emailError,
      password: passwordError
    };
    
    setErrors(newErrors);
    
    if (!emailError && !passwordError) {
      onSubmit({ email, password });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      {errors.email && <div className="error">{errors.email}</div>}
      
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Пароль"
      />
      {errors.password && <div className="error">{errors.password}</div>}
      
      <button type="submit">Войти</button>
    </form>
  );
};

export default LoginForm;
```

```javascript
// LoginForm.integration.test.jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import LoginForm from './LoginForm';

// Мокируем утилиты валидации
jest.mock('../utils/validation', () => ({
  validateEmail: jest.fn(),
  validatePassword: jest.fn()
}));

import { validateEmail, validatePassword } from '../utils/validation';

describe('LoginForm Integration', () => {
  const mockSubmit = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    validateEmail.mockReturnValue(null);
    validatePassword.mockReturnValue(null);
  });

  test('отображает ошибки валидации при неверных данных', () => {
    validateEmail.mockReturnValue('Неверный формат email');
    validatePassword.mockReturnValue('Пароль должен содержать минимум 8 символов');

    render(<LoginForm onSubmit={mockSubmit} />);

    // Заполняем поля неверными данными
    fireEvent.change(screen.getByPlaceholderText('Email'), { target: { value: 'invalid-email' } });
    fireEvent.change(screen.getByPlaceholderText('Пароль'), { target: { value: '123' } });
    
    fireEvent.click(screen.getByRole('button'));

    // Проверяем, что ошибки отображаются
    expect(screen.getByText('Неверный формат email')).toBeInTheDocument();
    expect(screen.getByText('Пароль должен содержать минимум 8 символов')).toBeInTheDocument();

    // Проверяем, что форма не была отправлена
    expect(mockSubmit).not.toHaveBeenCalled();
  });

  test('отправляет форму при корректных данных', async () => {
    const testData = { email: 'user@example.com', password: 'password123' };
    
    render(<LoginForm onSubmit={mockSubmit} />);

    // Заполняем поля корректными данными
    fireEvent.change(screen.getByPlaceholderText('Email'), { target: { value: testData.email } });
    fireEvent.change(screen.getByPlaceholderText('Пароль'), { target: { value: testData.password } });
    
    fireEvent.click(screen.getByRole('button'));

    // Проверяем, что форма была отправлена с правильными данными
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith(testData);
    });
  });
});
```

## Паттерны интеграционного тестирования

### Test Data Builder

Для сложных сценариев тестирования полезно использовать паттерн Test Data Builder, который позволяет создавать тестовые данные с различными комбинациями значений.

```javascript
// TestDataBuilder.js
class UserBuilder {
  constructor() {
    this.user = {
      id: 1,
      name: 'Тестовый пользователь',
      email: 'test@example.com',
      role: 'user',
      isActive: true
    };
  }

  withId(id) {
    this.user.id = id;
    return this;
  }

  withName(name) {
    this.user.name = name;
    return this;
  }

  withRole(role) {
    this.user.role = role;
    return this;
  }

  withStatus(active) {
    this.user.isActive = active;
    return this;
  }

  build() {
    return { ...this.user };
  }
}

// Использование в тесте
test('администратор может управлять пользователями', () => {
  const adminUser = new UserBuilder()
    .withRole('admin')
    .withName('Администратор')
    .build();
    
  const regularUser = new UserBuilder()
    .withRole('user')
    .withName('Обычный пользователь')
    .build();

  // Тестирование с этими пользователями
  render(<UserManagement currentUser={adminUser} targetUser={regularUser} />);
  // ... дополнительные проверки
});
```

### Page Object для интеграционных тестов

Для сложных компонентов или сценариев можно использовать Page Object паттерн, который инкапсулирует взаимодействие с элементами интерфейса.

```javascript
// pages/ShoppingCartPage.js
class ShoppingCartPage {
  constructor() {
    this.items = screen.getAllByTestId('cart-item');
    this.totalPrice = screen.getByTestId('total-price');
    this.checkoutButton = screen.getByRole('button', { name: /оформить заказ/i });
  }

  getItemsCount() {
    return this.items.length;
  }

  getItemByName(name) {
    return this.items.find(item => 
      item.textContent.includes(name)
    );
  }

  clickCheckout() {
    fireEvent.click(this.checkoutButton);
  }

  getTotalPrice() {
    return parseFloat(this.totalPrice.textContent.replace(/[^\d.]/g, ''));
  }
}

// Использование в тесте
test('корзина корректно рассчитывает общую стоимость', () => {
  render(<ShoppingCart items={testItems} />);
  
  const cartPage = new ShoppingCartPage();
  
  expect(cartPage.getTotalPrice()).toBe(150.00);
  expect(cartPage.getItemsCount()).toBe(3);
  
  cartPage.clickCheckout();
  // ... дополнительные проверки
});
```

## Заключение

Интеграционное тестирование компонентов - важная часть стратегии тестирования фронтенд-приложений. Оно помогает выявить проблемы, которые могут возникнуть при объединении отдельных компонентов, и обеспечивает уверенность в том, что различные части приложения работают вместе корректно.

Эффективные интеграционные тесты:
- Покрывают критические пути взаимодействия между компонентами
- Тестируют реальные сценарии использования
- Проверяют интеграцию с внешними сервисами и системами управления состоянием
- Балансируют между полнотой покрытия и производительностью тестов

## См. также

- [[Unit-тестирование-компонентов]]
- [[E2E-тестирование]]
- [[Тестирование-взаимодействия]]
- [[Тестирование-React-компонентов]]
- [[Тестирование-Vue-компонентов]]
- [[TDD-в-фронтенд-разработке]]