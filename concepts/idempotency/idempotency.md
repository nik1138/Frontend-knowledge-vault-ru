---
aliases: ["Идемпотентность", "Idempotency"]
tags: ["#programming", "#architecture", "#rest-api", "#distributed-systems", "#mathematics"]
---

# Идемпотентность

## Определение идемпотентности

**Идемпотентность** — это свойство операции, при котором её повторное применение к результату не изменяет результат. В контексте программирования и систем это означает, что выполнение одной и той же операции несколько раз даёт тот же результат, что и однократное выполнение.

> [!note] Значение в контексте программирования
> В программировании функция или операция является идемпотентной, если её многократное выполнение не изменяет состояние системы после первого выполнения.

## Математические основы

В математике операция `f` является идемпотентной, если:

```
f(f(x)) = f(x)
```

Это означает, что применение операции дважды дает тот же результат, что и однократное применение. Примеры идемпотентных операций:
- Математическая функция: `abs(abs(x)) = abs(x)`
- Множество: `set.add(element)` - добавление одного и того же элемента в множество
- Базы данных: `INSERT IGNORE` или `UPSERT` операции

## Идемпотентность в REST API

### GET запросы

Запросы `GET` являются идемпотентными по определению, так как они не изменяют состояние сервера:

```http
GET /users/123
```

Повторный запрос вернёт тот же результат (при отсутствии изменений в данных).

### PUT запросы

Запросы `PUT` должны быть идемпотентными, так как они заменяют ресурс целиком:

```http
PUT /users/123
{
  "name": "Иван",
  "email": "ivan@example.com"
}
```

Несколько последовательных запросов с одинаковыми данными приведут к одному и тому же результату.

### DELETE запросы

Запросы `DELETE` должны быть идемпотентными:

```http
DELETE /users/123
```

После первого успешного удаления повторные запросы должны возвращать `200 OK` или `404 Not Found`, но не изменять состояние системы.

### POST запросы

Запросы `POST` **не** являются идемпотентными, так как каждый вызов может создать новый ресурс:

```http
POST /users
{
  "name": "Иван",
  "email": "ivan@example.com"
}
```

## Идемпотентность в распределённых системах

В распределённых системах идемпотентность особенно важна из-за возможных сетевых ошибок и дублирования запросов. При проектировании таких систем важно:

1. Использовать идемпотентные токены для идентификации операций
2. Обеспечивать идемпотентность на уровне бизнес-логики
3. Использовать атомарные операции для изменения состояния

## Стратегии реализации

### Идемпотентные ключи

Использование уникальных ключей для идентификации операций:

```javascript
// Пример реализации с идемпотентным ключом
function processPayment(amount, idempotencyKey) {
  // Проверяем, была ли уже выполнена операция с этим ключом
  const existingOperation = getOperationByIdempotencyKey(idempotencyKey);
  if (existingOperation) {
    return existingOperation.result;
  }
  
  // Выполняем операцию и сохраняем результат
  const result = performPayment(amount);
  saveOperation(idempotencyKey, result);
  return result;
}
```

### Условные обновления

Использование условных обновлений для обеспечения идемпотентности:

```sql
-- Пример условного обновления в базе данных
UPDATE accounts 
SET balance = balance - 100 
WHERE id = 123 AND balance >= 100;
```

### Сравнение и установка (Compare-and-Swap)

Использование атомарных операций для безопасного обновления:

```javascript
// Пример с версионированием
function updateResource(resourceId, newData, expectedVersion) {
  const currentResource = getResource(resourceId);
  if (currentResource.version !== expectedVersion) {
    throw new Error("Resource was modified by another process");
  }
  
  return saveResource(resourceId, newData, expectedVersion + 1);
}
```

## Преимущества идемпотентности

- **Надёжность**: возможность безопасного повторения операций
- **Упрощение обработки ошибок**: можно безопасно повторять неудачные операции
- **Лучшая масштабируемость**: упрощает обработку параллельных запросов
- **Устойчивость к сетевым проблемам**: дублирование запросов не приводит к нежелательным последствиям

## Распространённые ошибки

- Неправильное понимание идемпотентности `POST` запросов
- Отсутствие идемпотентности в операциях, которые должны быть идемпотентными
- Неправильная обработка ошибок, приводящая к частичному выполнению операций
- Отсутствие проверки на дублирование операций

## Реальные примеры

### Платёжные системы

Платёжные системы часто используют идемпотентные ключи для предотвращения дублирования платежей:

```
POST /payments HTTP/1.1
Idempotency-Key: abc-123-def-456
Content-Type: application/json

{
  "amount": 1000,
  "currency": "RUB",
  "description": "Payment for order #12345"
}
```

### Системы уведомлений

Системы отправки уведомлений используют идемпотентность для предотвращения дублирования сообщений пользователям.

## Тестирование идемпотентных операций

Для тестирования идемпотентности нужно:

1. Выполнить операцию один раз
2. Выполнить ту же операцию несколько раз
3. Проверить, что состояние системы не изменилось после первого выполнения
4. Проверить, что возвращаемые значения согласованы

```javascript
// Пример теста идемпотентности
test('delete operation is idempotent', async () => {
  const resourceId = await createResource();
  
  // Первое удаление
  const firstResult = await deleteResource(resourceId);
  expect(firstResult.status).toBe(200);
  
  // Повторное удаление
  const secondResult = await deleteResource(resourceId);
  // Должно вернуть 404 или 200 в зависимости от реализации
  expect(secondResult.status).toBeOneOf([200, 404]);
});
```

## Связь с другими концепциями

- [[concepts/consistency/consistency]] - идемпотентность помогает обеспечить согласованность данных
- [[concepts/reliability/reliability]] - важный аспект надёжных систем
- [[architecture/api-design/api-design]] - ключевой принцип проектирования API
- [[concepts/transaction/transaction]] - пересекается с атомарностью транзакций

## Заключение

Идемпотентность — важное свойство, которое делает системы более надёжными и предсказуемыми. Понимание и правильная реализация идемпотентных операций особенно важны в распределённых системах, где сетевые ошибки и дублирование запросов являются нормой, а не исключением.

> [!tip] Практический совет
> При проектировании API всегда стремитесь к идемпотентности для операций, которые могут быть выполнены несколько раз без нежелательных последствий.
