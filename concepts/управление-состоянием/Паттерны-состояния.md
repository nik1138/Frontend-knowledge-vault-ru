---
aliases: [Паттерны управления состоянием, Архитектурные паттерны состояния]
tags: [programming, state-management, patterns, architecture, react, frontend]
---

# Паттерны-состояния

## Обзор

Паттерны управления состоянием - это архитектурные решения, которые помогают эффективно управлять данными в приложениях. Они обеспечивают структурированный подход к хранению, обновлению и доступу к состоянию, что улучшает читаемость, тестируемость и поддерживаемость кода.

## Основные паттерны управления состоянием

### 1. Flux-паттерн

Flux - это архитектурный паттерн, разработанный Facebook для управления состоянием в React-приложениях. Он использует односторонний поток данных.

#### Основные компоненты Flux:

- **Actions** - объекты, которые содержат информацию о том, что произошло
- **Dispatcher** - центральный узел, который направляет действия в хранилища
- **Stores** - объекты, которые содержат состояние и логику приложения
- **Views** - представления, которые подписываются на изменения состояния

```javascript
// Пример Flux-паттерна
class CounterStore {
  constructor() {
    this.count = 0;
    this.callbacks = [];
  }

  subscribe(callback) {
    this.callbacks.push(callback);
  }

  notify() {
    this.callbacks.forEach(callback => callback());
  }

  reduce(action) {
    switch (action.type) {
      case 'INCREMENT':
        this.count++;
        break;
      case 'DECREMENT':
        this.count--;
        break;
    }
    this.notify();
  }
}

const counterStore = new CounterStore();

// Диспетчер
function dispatch(action) {
  counterStore.reduce(action);
}

// Использование
dispatch({ type: 'INCREMENT' });
```

### 2. Redux-паттерн

Redux - это предсказуемое хранилище состояния для JavaScript-приложений. Он основан на Flux, но упрощен и использует строгие ограничения.

#### Основные принципы Redux:

- Единый источник истины
- Состояние доступно только для чтения
- Изменения происходят только через чистые функции (редьюсеры)

```javascript
// Redux-паттерн
const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Хранилище
const store = {
  state: initialState,
  listeners: [],
  
  getState() {
    return this.state;
  },
  
  dispatch(action) {
    this.state = counterReducer(this.state, action);
    this.listeners.forEach(listener => listener());
  },
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
};
```

### 3. State Machine

State Machine (машина состояний) - это модель поведения системы, которая определяет конечное количество состояний и переходы между ними.

```javascript
// Пример машины состояний для аутентификации
class AuthStateMachine {
  constructor() {
    this.state = 'unauthenticated';
    this.transitions = {
      'unauthenticated': ['authenticating'],
      'authenticating': ['authenticated', 'unauthenticated', 'error'],
      'authenticated': ['unauthenticated'],
      'error': ['unauthenticated', 'authenticating']
    };
  }

  canTransition(to) {
    return this.transitions[this.state].includes(to);
  }

  transition(to) {
    if (this.canTransition(to)) {
      this.state = to;
      return true;
    }
    return false;
  }
}

const authMachine = new AuthStateMachine();
authMachine.transition('authenticating'); // true
authMachine.transition('authenticated');   // true
```

### 4. Observer Pattern

Observer (Наблюдатель) - это поведенческий паттерн, который позволяет объектам наблюдать за изменениями в других объектах.

```javascript
// Паттерн Observer для управления состоянием
class StateObserver {
  constructor() {
    this.state = {};
    this.observers = [];
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify();
  }

  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  }

  notify() {
    this.observers.forEach(observer => observer(this.state));
  }
}

const stateManager = new StateObserver();
stateManager.subscribe((state) => console.log('Состояние изменилось:', state));
stateManager.setState({ user: 'John' });
```

### 5. Context Pattern

Context (Контекст) - паттерн, который позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на каждом уровне.

```jsx
// React Context Pattern
import React, { createContext, useContext, useReducer } from 'react';

const StateContext = createContext();

export const useAppState = () => useContext(StateContext);

export const StateProvider = ({ reducer, initialState, children }) => {
  return (
    &lt;StateContext.Provider value={useReducer(reducer, initialState)}&gt;
      {children}
    &lt;/StateContext.Provider&gt;
  );
};

// Использование
function App() {
  return (
    &lt;StateProvider reducer={appReducer} initialState={initialState}&gt;
      &lt;Header /&gt;
      &lt;Main /&gt;
      &lt;Footer /&gt;
    &lt;/StateProvider&gt;
  );
}

function Header() {
  const [state] = useAppState();
  return &lt;header&gt;Пользователь: {state.user.name}&lt;/header&gt;;
}
```

## Паттерны для конкретных задач

### 1. Local State Hoisting

Поднятие локального состояния - это паттерн, при котором состояние поднимается до ближайшего общего предка компонентов, которым нужно к нему доступ.

```jsx
// Вместо дублирования состояния
function Parent() {
  const [value, setValue] = useState('');
  
  return (
    &lt;&gt;
      &lt;Input value={value} onChange={setValue} /&gt;
      &lt;Display value={value} /&gt;
    &lt;/&gt;
  );
}
```

### 2. Container/Presenter Pattern

Контейнерный/презентационный паттерн разделяет компоненты, отвечающие за логику, от компонентов, отвечающих за отображение.

```jsx
// Контейнерный компонент
function UserProfileContainer() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then(setUser).finally(() => setLoading(false));
  }, []);

  return &lt;UserProfilePresenter user={user} loading={loading} /&gt;;
}

// Презентационный компонент
function UserProfilePresenter({ user, loading }) {
  if (loading) return &lt;div&gt;Загрузка...&lt;/div&gt;
  return &lt;div&gt;Привет, {user.name}!&lt;/div&gt;;
}
```

### 3. State Colocation

Размещение состояния близко к месту использования - паттерн, при котором состояние размещается как можно ближе к компонентам, которые его используют.

```jsx
// Плохо: состояние слишком высоко
function App() {
  const [searchTerm, setSearchTerm] = useState('');
  return &lt;SearchResults searchTerm={searchTerm} /&gt;;
}

// Лучше: состояние ближе к компоненту, который его использует
function SearchResults() {
  const [searchTerm, setSearchTerm] = useState('');
  // Логика поиска и отображения результатов
  return &lt;div&gt;...&lt;/div&gt;;
}
```

## Современные паттерны и библиотеки

### 1. Atomic Pattern (Jotai, Recoil)

Atomic Pattern разбивает состояние на атомы - минимальные единицы состояния, которые могут быть независимо обновлены.

```javascript
// Jotai
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);
const userAtom = atom(null);

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  return (
    &lt;div&gt;
      &lt;span&gt;{count}&lt;/span&gt;
      &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
```

### 2. SWR Pattern (Stale-While-Revalidate)

SWR - это паттерн кеширования и синхронизации данных, который обеспечивает мгновенные обновления и повторные попытки запросов.

```javascript
// SWR
import useSWR from 'swr';

function Profile() {
  const { data, error } = useSWR('/api/user', fetcher);

  if (error) return &lt;div&gt;Ошибка загрузки&lt;/div&gt;
  if (!data) return &lt;div&gt;Загрузка...&lt;/div&gt;

  return &lt;div&gt;Привет, {data.name}!&lt;/div&gt;;
}
```

### 3. Zustand Pattern

Zustand предоставляет простое и масштабируемое решение для управления состоянием без лишней сложности.

```javascript
import { create } from 'zustand';

const useStore = create((set, get) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  
  // Асинхронные действия
  fetchUser: async (userId) => {
    const user = await fetch(`/api/users/${userId}`).then(res => res.json());
    set({ user });
  }
}));
```

## Выбор паттерна

### Для простых приложений:
- Локальное состояние с `useState` и `useReducer`
- Context API для общих данных

### Для средних приложений:
- Redux Toolkit или Zustand
- SWR для управления данными с сервера

### Для сложных приложений:
- Комбинация нескольких паттернов
- Атомарные состояния (Jotai, Recoil)
- Микросервисная архитектура состояния

## Лучшие практики

### 1. Структурирование состояния

Организуйте состояние логически и предсказуемо:

```javascript
// Хорошая структура состояния
{
  entities: {
    users: { /* ... */ },
    posts: { /* ... */ },
    comments: { /* ... */ }
  },
  ui: {
    theme: 'dark',
    language: 'en',
    notifications: []
  },
  app: {
    currentUser: null,
    isAuthenticated: false
  }
}
```

### 2. Иммутабельность

Всегда создавайте новые объекты при обновлении состояния:

```javascript
// Правильно
const newState = {
  ...state,
  users: [...state.users, newUser]
};

// Неправильно
state.users.push(newUser);
```

### 3. Нормализация данных

Храните данные в нормализованном виде, особенно при работе с сущностями:

```javascript
// Нормализованное состояние
{
  entities: {
    users: {
      1: { id: 1, name: 'John', posts: [1, 2] },
      2: { id: 2, name: 'Jane', posts: [3] }
    },
    posts: {
      1: { id: 1, title: 'Post 1', author: 1 },
      2: { id: 2, title: 'Post 2', author: 1 },
      3: { id: 3, title: 'Post 3', author: 2 }
    }
  },
  ui: {
    currentUserId: 1,
    visiblePostIds: [1, 2, 3]
  }
}
```

## Связь с другими концепциями

Паттерны состояния тесно связаны с другими аспектами управления состоянием:

- [[Локальное-состояние]] - паттерны для управления состоянием на уровне компонентов
- [[Глобальное-состояние]] - паттерны для централизованного управления состоянием
- [[Состояние-и-производительность]] - влияние паттернов управления состоянием на производительность

## Заключение

Паттерны управления состоянием - это важный инструмент в арсенале разработчика. Выбор правильного паттерна зависит от сложности приложения, команды разработчиков и конкретных требований. Важно понимать, что нет универсального решения, и часто приходится комбинировать несколько паттернов для достижения наилучших результатов.