---
aliases: [Глобальное состояние в приложениях, Управление глобальным состоянием]
tags: [programming, state-management, react, frontend, architecture]
---

# Глобальное-состояние

## Обзор

Глобальное состояние (global state) - это тип состояния, которое доступно и может быть изменено из любой части приложения. В отличие от локального состояния, которое ограничено отдельным компонентом, глобальное состояние обеспечивает централизованный доступ к данным, которые нужны в разных частях приложения.

## Основные понятия

Глобальное состояние представляет собой централизованное хранилище данных, которое может быть доступно из любого компонента приложения. Оно особенно полезно для данных, которые:

- Используются в нескольких компонентах
- Должны сохраняться между переходами между страницами
- Требуют сложной логики обновления
- Представляют собой данные аутентификации, настройки пользователя или другую общую информацию

## Архитектура глобального состояния

### Центральное хранилище

Глобальное состояние обычно реализуется через центральное хранилище, которое предоставляет:

- Единый источник истины (single source of truth)
- Предсказуемое изменение состояния
- Возможность отслеживания изменений
- Инструменты для отладки и тестирования

### Поток данных

В архитектуре с глобальным состоянием данные обычно движутся по следующему паттерну:

1. Компоненты подписываются на изменения состояния
2. Действия (actions) инициируют изменения
3. Редьюсеры (reducers) обновляют состояние
4. Компоненты получают обновленные данные

## Реализации глобального состояния

### Redux

Redux - одна из самых популярных библиотек для управления глобальным состоянием:

```javascript
// actions.js
export const INCREMENT = 'INCREMENT';
export const DECREMENT = 'DECREMENT';
export const SET_USER = 'SET_USER';

export function increment() {
  return { type: INCREMENT };
}

export function decrement() {
  return { type: DECREMENT };
}

export function setUser(user) {
  return { type: SET_USER, payload: user };
}

// reducer.js
const initialState = {
  count: 0,
  user: null
};

export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return { ...state, count: state.count + 1 };
    case DECREMENT:
      return { ...state, count: state.count - 1 };
    case SET_USER:
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

// App.js
import { createStore } from 'redux';
import { Provider, useSelector, useDispatch } from 'react-redux';

const store = createStore(counterReducer);

function App() {
  return (
    &lt;Provider store={store}&gt;
      &lt;Counter /&gt;
      &lt;UserProfile /&gt;
    &lt;/Provider&gt;
  );
}

function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();

  return (
    &lt;div&gt;
      &lt;p&gt;Счетчик: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch(increment())}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}
```

### Zustand

Zustand - более легковесная альтернатива Redux:

```javascript
import { create } from 'zustand';

const useStore = create((set, get) => ({
  count: 0,
  user: null,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  setUser: (user) => set({ user }),
  reset: () => set({ count: 0, user: null })
}));

// Использование в компоненте
function Counter() {
  const { count, increment, decrement } = useStore();

  return (
    &lt;div&gt;
      &lt;p&gt;Счетчик: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Увеличить&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Уменьшить&lt;/button&gt;
    &lt;/div&gt;
  );
}
```

### Context API

React Context API позволяет создавать глобальное состояние без внешних библиотек:

```jsx
import React, { createContext, useContext, useReducer } from 'react';

// Создание контекста
const AppContext = createContext();

// Редьюсер для управления состоянием
const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    default:
      return state;
  }
};

// Провайдер контекста
export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    theme: 'light',
    language: 'ru'
  });

  return (
    &lt;AppContext.Provider value={{ state, dispatch }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Хук для использования контекста
export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
}

// Использование в компоненте
function UserProfile() {
  const { state, dispatch } = useAppContext();

  const handleLogin = (userData) => {
    dispatch({ type: 'SET_USER', payload: userData });
  };

  return (
    &lt;div&gt;
      {state.user ? (
        &lt;p&gt;Привет, {state.user.name}!&lt;/p&gt;
      ) : (
        &lt;button onClick={() =&gt; handleLogin({ name: 'Иван' })}&gt;
          Войти
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}
```

## Преимущества глобального состояния

### Централизованный контроль

- Все данные находятся в одном месте
- Легко отслеживать изменения
- Упрощается отладка и тестирование

### Совместное использование данных

- Компоненты могут легко получать доступ к общим данным
- Устраняет необходимость передачи пропсов через многоуровневые деревья
- Повышает переиспользуемость компонентов

### Управление сложной логикой

- Можно реализовать сложную бизнес-логику в одном месте
- Легко реализовать асинхронные операции
- Упрощается обработка ошибок

## Недостатки глобального состояния

### Сложность

- Добавляет абстракцию и сложность в приложение
- Требует изучения новых концепций и инструментов
- Может быть избыточным для простых приложений

### Производительность

- Неправильное использование может привести к лишним перерисовкам
- Требует оптимизации для больших приложений
- Может замедлить производительность при неправильной архитектуре

### Поддержка

- Требует строгой архитектуры и документации
- Сложнее тестировать по сравнению с локальным состоянием
- Может создать жесткую зависимость между компонентами

## Лучшие практики

### 1. Минимизация глобального состояния

Не помещайте всё состояние в глобальное хранилище. Используйте глобальное состояние только для данных, которые действительно нужны в нескольких компонентах:

```javascript
// Плохо: всё состояние в глобальном хранилище
{
  global: {
    count: 0,
    isOpen: false,
    theme: 'light',
    modalTitle: 'Заголовок',
    // ... все остальные состояния
  }
}

// Хорошо: только общие данные в глобальном хранилище
{
  global: {
    user: {...},
    settings: {...},
    notifications: [...]
  }
}
```

### 2. Структурирование состояния

Организуйте состояние логически:

```javascript
const initialState = {
  auth: {
    user: null,
    isAuthenticated: false,
    token: null
  },
  ui: {
    theme: 'light',
    language: 'ru',
    notifications: []
  },
  data: {
    posts: [],
    comments: {},
    users: {}
  }
};
```

### 3. Использование селекторов

Для сложных вычислений используйте селекторы:

```javascript
// Селектор для получения активных пользователей
const selectActiveUsers = (state) => 
  state.users.filter(user => user.isActive);

// Селектор для получения количества активных пользователей
const selectActiveUserCount = createSelector(
  [selectActiveUsers],
  (activeUsers) => activeUsers.length
);
```

### 4. Асинхронные операции

Правильно обрабатывайте асинхронные операции:

```javascript
// Redux Toolkit с createAsyncThunk
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

export const fetchUserById = createAsyncThunk(
  'users/fetchByIdStatus',
  async (userId, { rejectWithValue }) => {
    try {
      const response = await userAPI.fetchById(userId);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: { entities: [], loading: 'idle' },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserById.pending, (state) => {
        state.loading = 'pending';
      })
      .addCase(fetchUserById.fulfilled, (state, { payload }) => {
        state.entities.push(payload);
        state.loading = 'idle';
      })
      .addCase(fetchUserById.rejected, (state) => {
        state.loading = 'idle';
      });
  }
});
```

## Связь с другими концепциями

Глобальное состояние связано с другими аспектами управления состоянием:

- [[Локальное-состояние]] - альтернатива глобальному состоянию для данных, специфичных для компонента
- [[Паттерны-состояния]] - шаблоны проектирования для эффективного управления состоянием
- [[Состояние-и-производительность]] - влияние управления состоянием на производительность приложения

## Заключение

Глобальное состояние - мощный инструмент для управления данными в сложных приложениях. При правильном использовании оно позволяет создавать предсказуемые, тестируемые и масштабируемые приложения. Однако важно помнить, что с большой силой приходит большая ответственность - глобальное состояние не всегда является решением для всех задач управления состоянием.