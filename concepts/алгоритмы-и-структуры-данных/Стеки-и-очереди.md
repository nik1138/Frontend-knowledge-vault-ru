---
aliases: ["Stack", "Queue", "LIFO", "FIFO", "Deque"]
tags: ["#алгоритмы", "#структуры-данных", "#стек", "#очередь", "#javascript"]
---

# Стеки и очереди

## Общее описание

Стеки и очереди - это абстрактные структуры данных, которые определяют порядок добавления и извлечения элементов. Они широко используются в фронтенд-разработке для управления состоянием, обработки событий и реализации различных алгоритмов.

## Стек (Stack)

Стек - это структура данных, которая следует принципу LIFO (Last In, First Out) - последним пришел, первым ушел. Представляет собой "стопку" элементов, где добавление и удаление элементов происходит с одного конца, называемого "вершиной" стека.

### Характеристики стека:

- **Добавление элемента (push)**: O(1)
- **Удаление элемента (pop)**: O(1)
- **Просмотр верхнего элемента (peek)**: O(1)
- **Проверка на пустоту**: O(1)

```javascript
// Реализация стека на основе массива
class Stack {
    constructor() {
        this.items = [];
    }

    // Добавление элемента в стек - O(1)
    push(element) {
        this.items.push(element);
    }

    // Удаление элемента из стека - O(1)
    pop() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.pop();
    }

    // Просмотр верхнего элемента - O(1)
    peek() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[this.items.length - 1];
    }

    // Проверка на пустоту - O(1)
    isEmpty() {
        return this.items.length === 0;
    }

    // Размер стека - O(1)
    size() {
        return this.items.length;
    }

    // Очистка стека - O(1)
    clear() {
        this.items = [];
    }
}

// Пример использования
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.peek()); // 3
console.log(stack.pop());  // 3
console.log(stack.size()); // 2
```

### Применение стека в фронтенд-разработке

```javascript
// Управление историей навигации
class NavigationHistory {
    constructor() {
        this.historyStack = new Stack();
        this.forwardStack = new Stack();
    }

    // Переход на новую страницу
    navigateTo(page) {
        this.historyStack.push(page);
        this.forwardStack.clear(); // Очистка стека вперед после нового перехода
    }

    // Назад
    goBack() {
        if (!this.historyStack.isEmpty()) {
            const currentPage = this.historyStack.pop();
            this.forwardStack.push(currentPage);
            return this.historyStack.peek(); // Возвращаем предыдущую страницу
        }
        return null;
    }

    // Вперед
    goForward() {
        if (!this.forwardStack.isEmpty()) {
            const page = this.forwardStack.pop();
            this.historyStack.push(page);
            return page;
        }
        return null;
    }
}

// Отмена/повтор действий (undo/redo)
class UndoRedoManager {
    constructor() {
        this.undoStack = new Stack();
        this.redoStack = new Stack();
    }

    // Выполнение действия
    execute(action) {
        action.execute();
        this.undoStack.push(action);
        this.redoStack.clear(); // Очистка redo после нового действия
    }

    // Отмена последнего действия
    undo() {
        if (!this.undoStack.isEmpty()) {
            const action = this.undoStack.pop();
            action.undo();
            this.redoStack.push(action);
        }
    }

    // Повтор действия
    redo() {
        if (!this.redoStack.isEmpty()) {
            const action = this.redoStack.pop();
            action.execute();
            this.undoStack.push(action);
        }
    }
}
```

## Очередь (Queue)

Очередь - это структура данных, которая следует принципу FIFO (First In, First Out) - первым пришел, первым ушел. Элементы добавляются в конец очереди и извлекаются из начала.

### Характеристики очереди:

- **Добавление элемента (enqueue)**: O(1)
- **Удаление элемента (dequeue)**: O(1)
- **Просмотр первого элемента (front)**: O(1)
- **Проверка на пустоту**: O(1)

```javascript
// Реализация очереди на основе массива
class Queue {
    constructor() {
        this.items = [];
    }

    // Добавление элемента в очередь - O(1)
    enqueue(element) {
        this.items.push(element);
    }

    // Удаление элемента из очереди - O(n) для простой реализации
    dequeue() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.shift(); // shift() требует O(n) времени
    }

    // Более эффективная реализация очереди
    // с использованием указателя на начало
    dequeueEfficient() {
        if (this.isEmpty()) {
            return null;
        }
        const element = this.items[this.frontIndex];
        this.items[this.frontIndex] = undefined; // Освобождаем память
        this.frontIndex++;
        
        // Очищаем массив, если он становится слишком большим
        if (this.frontIndex * 2 >= this.items.length) {
            this.items = this.items.slice(this.frontIndex);
            this.frontIndex = 0;
        }
        
        return element;
    }

    // Просмотр первого элемента - O(1)
    front() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0];
    }

    // Проверка на пустоту - O(1)
    isEmpty() {
        return this.items.length === 0;
    }

    // Размер очереди - O(1)
    size() {
        return this.items.length;
    }

    // Очистка очереди - O(1)
    clear() {
        this.items = [];
    }
}

// Более эффективная реализация очереди
class EfficientQueue {
    constructor() {
        this.items = {};
        this.head = 0;
        this.tail = 0;
    }

    // Добавление элемента - O(1)
    enqueue(element) {
        this.items[this.tail] = element;
        this.tail++;
    }

    // Удаление элемента - O(1)
    dequeue() {
        if (this.head === this.tail) {
            return null;
        }
        
        const item = this.items[this.head];
        delete this.items[this.head];
        this.head++;
        return item;
    }

    // Размер очереди - O(1)
    size() {
        return this.tail - this.head;
    }

    // Проверка на пустоту - O(1)
    isEmpty() {
        return this.head === this.tail;
    }
}
```

### Двусторонняя очередь (Deque - Double-ended Queue)

Двусторонняя очередь позволяет добавлять и удалять элементы с обоих концов.

```javascript
class Deque {
    constructor() {
        this.items = {};
        this.head = 0;
        this.tail = 0;
    }

    // Добавление в начало - O(1)
    addFront(element) {
        this.head--;
        this.items[this.head] = element;
    }

    // Добавление в конец - O(1)
    addBack(element) {
        this.items[this.tail] = element;
        this.tail++;
    }

    // Удаление из начала - O(1)
    removeFront() {
        if (this.head === this.tail) {
            return null;
        }
        
        const item = this.items[this.head];
        delete this.items[this.head];
        this.head++;
        return item;
    }

    // Удаление из конца - O(1)
    removeBack() {
        if (this.head === this.tail) {
            return null;
        }
        
        this.tail--;
        const item = this.items[this.tail];
        delete this.items[this.tail];
        return item;
    }

    // Размер - O(1)
    size() {
        return this.tail - this.head;
    }

    isEmpty() {
        return this.head === this.tail;
    }
}
```

## Применение в фронтенд-разработке

### Обработка асинхронных задач

```javascript
// Очередь задач для обработки
class TaskQueue {
    constructor() {
        this.queue = new Queue();
        this.isProcessing = false;
    }

    // Добавление задачи в очередь
    addTask(task) {
        this.queue.enqueue(task);
        if (!this.isProcessing) {
            this.processTasks();
        }
    }

    // Обработка задач из очереди
    async processTasks() {
        this.isProcessing = true;
        
        while (!this.queue.isEmpty()) {
            const task = this.queue.dequeue();
            try {
                await task();
            } catch (error) {
                console.error('Ошибка при выполнении задачи:', error);
            }
        }
        
        this.isProcessing = false;
    }
}

// Использование
const taskQueue = new TaskQueue();

// Добавляем задачи
taskQueue.addTask(async () => {
    console.log('Задача 1 выполнена');
    await new Promise(resolve => setTimeout(resolve, 1000));
});

taskQueue.addTask(async () => {
    console.log('Задача 2 выполнена');
    await new Promise(resolve => setTimeout(resolve, 500));
});
```

### Управление анимациями и переходами

```javascript
// Очередь анимаций
class AnimationQueue {
    constructor() {
        this.queue = new Queue();
        this.isPlaying = false;
    }

    // Добавление анимации в очередь
    addAnimation(animation) {
        this.queue.enqueue(animation);
        if (!this.isPlaying) {
            this.play();
        }
    }

    // Воспроизведение анимаций по очереди
    async play() {
        this.isPlaying = true;
        
        while (!this.queue.isEmpty()) {
            const animation = this.queue.dequeue();
            await this.executeAnimation(animation);
        }
        
        this.isPlaying = false;
    }

    async executeAnimation(animation) {
        return new Promise((resolve) => {
            const element = document.querySelector(animation.selector);
            element.style.transition = `all ${animation.duration}ms`;
            
            // Применяем стили
            Object.assign(element.style, animation.styles);
            
            // Ждем завершения анимации
            setTimeout(resolve, animation.duration);
        });
    }
}
```

### Обработка событий

```javascript
// Стек для отслеживания состояния UI
class UIStateManager {
    constructor() {
        this.stateStack = new Stack();
    }

    // Сохранение текущего состояния
    saveState(state) {
        this.stateStack.push({ ...state });
    }

    // Восстановление предыдущего состояния
    restoreState() {
        const previousState = this.stateStack.pop();
        if (previousState) {
            return previousState;
        }
        return null;
    }

    // Проверка, есть ли предыдущее состояние
    canRestore() {
        return !this.stateStack.isEmpty();
    }
}

// Использование в компоненте
const uiManager = new UIStateManager();

// При изменении состояния
function changeFilter(newFilter) {
    uiManager.saveState({ filter: currentFilter, scrollTop: window.scrollY });
    currentFilter = newFilter;
    updateUI();
}

// При необходимости отката
function goBack() {
    if (uiManager.canRestore()) {
        const prevState = uiManager.restoreState();
        currentFilter = prevState.filter;
        window.scrollTo(0, prevState.scrollTop);
        updateUI();
    }
}
```

## Практические рекомендации для фронтенд-разработчиков

1. **Используйте стек для управления состоянием с возможностью отката** (undo/redo, навигация)
2. **Применяйте очередь для обработки асинхронных задач** (загрузка данных, обработка событий)
3. **Используйте эффективные реализации** - избегайте O(n) операций при частом добавлении/удалении
4. **Рассмотрите встроенные структуры** - `Array.push/pop` для стека, `Array.push/shift` для очереди (но с оглядкой на производительность)
5. **Следите за памятью** - особенно при работе с большими очередями

```javascript
// Плохо: использование shift() в цикле
function processQueueBad(queue) {
    while (queue.length > 0) {
        const item = queue.shift(); // O(n) для каждого элемента
        process(item);
    }
}

// Хорошо: использование индекса
function processQueueGood(queue) {
    for (let i = 0; i < queue.length; i++) {
        process(queue[i]);
    }
    queue.length = 0; // Очистка
}
```

## Заключение

Стеки и очереди являются важными структурами данных в фронтенд-разработке. Они позволяют управлять последовательностью операций, реализовывать функции отмены/повтора, обрабатывать асинхронные задачи и управлять состоянием приложения. Понимание различий между этими структурами и их эффективной реализации помогает создавать более производительные и надежные приложения.

См. также: [[Сложность-алгоритмов]], [[Списки-и-массивы]], [[Деревья-и-графы]], [[Хэш-таблицы]], [[Асинхронное программирование]]