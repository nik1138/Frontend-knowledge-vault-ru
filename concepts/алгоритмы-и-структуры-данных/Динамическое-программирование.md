---
aliases: [Динамическое программирование, DP, Оптимизация с DP]
tags: [programming, algorithms, dynamic-programming, frontend]
---

# Динамическое-программирование

## Обзор

Динамическое программирование (DP) — это метод решения сложных задач путем разбиения их на более простые подзадачи и сохранения результатов этих подзадач для избежания повторных вычислений. Это особенно эффективно для задач, обладающих свойствами перекрывающихся подзадач и оптимальной подструктуры.

## Важность в фронтенд-разработке

Динамическое программирование может быть полезно в фронтенде для:
- Оптимизации сложных вычислений в интерфейсах
- Реализации алгоритмов для анализа данных
- Решения задач оптимизации пользовательского интерфейса
- Обработки сложных пользовательских взаимодействий
- Кэширования результатов сложных вычислений

## Основные концепции

### 1. Перекрывающиеся подзадачи

Задача имеет перекрывающиеся подзадачи, если она может быть разбита на подзадачи, которые решаются несколько раз. DP сохраняет результаты этих подзадач, чтобы избежать повторных вычислений.

### 2. Оптимальная подструктура

Задача имеет оптимальную подструктуру, если оптимальное решение задачи может быть сконструировано из оптимальных решений её подзадач.

## Подходы к динамическому программированию

### 1. Сверху вниз (Memoization)

Рекурсивный подход с кэшированием результатов.

```javascript
// Вычисление чисел Фибоначчи с мемоизацией
function fibonacciMemo(n, memo = {}) {
    if (n in memo) {
        return memo[n];
    }
    
    if (n <= 1) {
        return n;
    }
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}

// Пример использования
console.log(fibonacciMemo(10)); // 55
```

### 2. Снизу вверх (Tabulation)

Итеративный подход с заполнением таблицы результатов.

```javascript
// Вычисление чисел Фибоначчи с табуляцией
function fibonacciTab(n) {
    if (n <= 1) {
        return n;
    }
    
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// Пример использования
console.log(fibonacciTab(10)); // 55
```

## Классические задачи динамического программирования

### 1. Задача о рюкзаке (Knapsack Problem)

```javascript
function knapsack(weights, values, capacity) {
    const n = weights.length;
    // Создаем таблицу dp размером (n+1) x (capacity+1)
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            // Если вес текущего предмета больше вместимости, пропускаем его
            if (weights[i - 1] > w) {
                dp[i][w] = dp[i - 1][w];
            } else {
                // Максимум между значением без текущего предмета и значением с ним
                dp[i][w] = Math.max(
                    dp[i - 1][w], 
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                );
            }
        }
    }
    
    return dp[n][capacity];
}

// Пример использования
const weights = [2, 1, 3, 2];
const values = [12, 10, 20, 15];
const capacity = 5;
console.log(knapsack(weights, values, capacity)); // 37
```

### 2. Наибольшая общая подпоследовательность (LCS)

```javascript
function longestCommonSubsequence(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Создаем таблицу для динамического программирования
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// Восстановление самой подпоследовательности
function lcsWithReconstruction(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Восстанавливаем подпоследовательность
    let lcs = '';
    let i = m, j = n;
    
    while (i > 0 && j > 0) {
        if (str1[i - 1] === str2[j - 1]) {
            lcs = str1[i - 1] + lcs;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return lcs;
}

// Пример использования
console.log(longestCommonSubsequence("ABCDGH", "AEDFHR")); // 3
console.log(lcsWithReconstruction("ABCDGH", "AEDFHR")); // "ADH"
```

### 3. Наибольшая возрастающая подпоследовательность (LIS)

```javascript
function longestIncreasingSubsequence(arr) {
    if (arr.length === 0) return 0;
    
    const dp = new Array(arr.length).fill(1);
    
    for (let i = 1; i < arr.length; i++) {
        for (let j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max(...dp);
}

// Более эффективная реализация с бинарным поиском
function longestIncreasingSubsequenceOptimized(arr) {
    if (arr.length === 0) return 0;
    
    const tails = [];
    
    for (const num of arr) {
        let left = 0;
        let right = tails.length;
        
        // Бинарный поиск
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        tails[left] = num;
    }
    
    return tails.length;
}

// Пример использования
const arr = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(longestIncreasingSubsequence(arr)); // 4
console.log(longestIncreasingSubsequenceOptimized(arr)); // 4
```

### 4. Задача о редакционном расстоянии (Расстояние Левенштейна)

```javascript
function editDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Создаем таблицу dp размером (m+1) x (n+1)
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Инициализация первой строки и столбца
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    
    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]; // символы совпадают
            } else {
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,      // удаление
                    dp[i][j - 1] + 1,      // вставка
                    dp[i - 1][j - 1] + 1   // замена
                );
            }
        }
    }
    
    return dp[m][n];
}

// Пример использования
console.log(editDistance("kitten", "sitting")); // 3
console.log(editDistance("intention", "execution")); // 5
```

### 5. Задача о максимальной сумме подмассива (Kadane's Algorithm)

```javascript
function maxSubarraySum(arr) {
    if (arr.length === 0) return 0;
    
    let maxSoFar = arr[0];
    let maxEndingHere = arr[0];
    
    for (let i = 1; i < arr.length; i++) {
        // Максимальная сумма, заканчивающаяся в текущей позиции
        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        // Обновляем максимальную сумму
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}

// Восстановление самого подмассива
function maxSubarrayWithIndices(arr) {
    if (arr.length === 0) return { sum: 0, start: -1, end: -1 };
    
    let maxSoFar = arr[0];
    let maxEndingHere = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    
    for (let i = 1; i < arr.length; i++) {
        if (maxEndingHere < 0) {
            maxEndingHere = arr[i];
            tempStart = i;
        } else {
            maxEndingHere += arr[i];
        }
        
        if (maxEndingHere > maxSoFar) {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
        }
    }
    
    return { sum: maxSoFar, start, end };
}

// Пример использования
const arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(maxSubarraySum(arr)); // 6 (подмассив [4, -1, 2, 1])
console.log(maxSubarrayWithIndices(arr)); // { sum: 6, start: 3, end: 6 }
```

### 6. Задача о размене монет

```javascript
function coinChange(coins, amount) {
    // dp[i] будет хранить минимальное количество монет для суммы i
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0; // Для суммы 0 нужно 0 монет
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
}

// Восстановление самих монет
function coinChangeWithCoins(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    const parent = new Array(amount + 1).fill(-1);
    dp[0] = 0;
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i && dp[i - coin] + 1 < dp[i]) {
                dp[i] = dp[i - coin] + 1;
                parent[i] = coin;
            }
        }
    }
    
    if (dp[amount] === Infinity) {
        return { count: -1, coins: [] };
    }
    
    // Восстановление монет
    const resultCoins = [];
    let current = amount;
    while (current > 0) {
        const coin = parent[current];
        resultCoins.push(coin);
        current -= coin;
    }
    
    return { count: dp[amount], coins: resultCoins };
}

// Пример использования
const coins = [1, 3, 4];
const amount = 6;
console.log(coinChange(coins, amount)); // 2 (монеты 3 и 3)
console.log(coinChangeWithCoins(coins, amount)); // { count: 2, coins: [3, 3] }
```

## Практические примеры в фронтенде

### 1. Оптимизация отображения элементов

```javascript
// Вычисление оптимального количества элементов для отображения
// с учетом производительности и пользовательского опыта
class DisplayOptimizer {
    constructor() {
        this.cache = new Map();
    }
    
    // DP для определения оптимального количества элементов для отображения
    optimalDisplayCount(items, maxRenderTime, itemRenderTime) {
        const key = `${items.length}-${maxRenderTime}-${itemRenderTime}`;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        let optimalCount = 0;
        let currentRenderTime = 0;
        
        for (let i = 0; i < items.length; i++) {
            if (currentRenderTime + itemRenderTime <= maxRenderTime) {
                currentRenderTime += itemRenderTime;
                optimalCount++;
            } else {
                break;
            }
        }
        
        this.cache.set(key, optimalCount);
        return optimalCount;
    }
}

// Пример использования
const optimizer = new DisplayOptimizer();
const items = Array(100).fill({}).map((_, i) => ({ id: i, data: `Item ${i}` }));
console.log(optimizer.optimalDisplayCount(items, 16, 0.5)); // Оптимальное количество для 16 мс
```

### 2. Кэширование результатов сложных вычислений

```javascript
class MemoizedCalculator {
    constructor() {
        this.cache = new Map();
    }
    
    // Вычисление факториала с мемоизацией
    factorial(n) {
        if (n <= 1) return 1;
        
        const key = `factorial-${n}`;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        const result = n * this.factorial(n - 1);
        this.cache.set(key, result);
        return result;
    }
    
    // Вычисление биномиального коэффициента с мемоизацией
    binomialCoefficient(n, k) {
        if (k === 0 || k === n) return 1;
        
        const key = `binomial-${n}-${k}`;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        const result = this.binomialCoefficient(n - 1, k - 1) + 
                      this.binomialCoefficient(n - 1, k);
        this.cache.set(key, result);
        return result;
    }
    
    // Очистка кэша
    clearCache() {
        this.cache.clear();
    }
}

// Пример использования
const calculator = new MemoizedCalculator();
console.log(calculator.factorial(10)); // 3628800
console.log(calculator.binomialCoefficient(10, 3)); // 120
```

### 3. Оптимизация обработки пользовательского ввода

```javascript
class InputOptimizer {
    constructor() {
        this.typingCache = new Map();
    }
    
    // Алгоритм для определения наиболее вероятного слова при опечатках
    suggestCorrections(input, dictionary) {
        const key = `correction-${input}`;
        if (this.typingCache.has(key)) {
            return this.typingCache.get(key);
        }
        
        const suggestions = [];
        
        for (const word of dictionary) {
            const distance = this.levenshteinDistance(input, word);
            if (distance <= 2) { // допускаем до 2 ошибок
                suggestions.push({ word, distance });
            }
        }
        
        // Сортируем по расстоянию
        suggestions.sort((a, b) => a.distance - b.distance);
        
        this.typingCache.set(key, suggestions.slice(0, 5)); // возвращаем топ-5
        return this.typingCache.get(key);
    }
    
    levenshteinDistance(str1, str2) {
        const m = str1.length;
        const n = str2.length;
        
        const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
        
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (str1[i - 1] === str2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i - 1][j - 1] + 1
                    );
                }
            }
        }
        
        return dp[m][n];
    }
}

// Пример использования
const optimizer = new InputOptimizer();
const dictionary = ["javascript", "python", "java", "react", "angular"];
console.log(optimizer.suggestCorrections("javascrpt", dictionary));
```

### 4. Оптимизация анимаций

```javascript
class AnimationOptimizer {
    constructor() {
        this.frameCache = new Map();
    }
    
    // Вычисление оптимальной кривой анимации с использованием DP
    optimalAnimationPath(start, end, duration, constraints = {}) {
        const key = `${start}-${end}-${duration}`;
        if (this.frameCache.has(key)) {
            return this.frameCache.get(key);
        }
        
        const frames = [];
        const steps = Math.min(duration / 16, 100); // ~60 FPS, максимум 100 шагов
        
        // Простая линейная интерполяция с оптимизацией
        for (let i = 0; i <= steps; i++) {
            const progress = i / steps;
            const value = start + (end - start) * progress;
            frames.push({
                time: (i / steps) * duration,
                value: this.applyConstraints(value, constraints)
            });
        }
        
        this.frameCache.set(key, frames);
        return frames;
    }
    
    applyConstraints(value, constraints) {
        if (constraints.min !== undefined) {
            value = Math.max(value, constraints.min);
        }
        if (constraints.max !== undefined) {
            value = Math.min(value, constraints.max);
        }
        return value;
    }
    
    // Очистка устаревших кэшей
    cleanupOldCaches() {
        // Удаляем кэши старше 5 минут
        const now = Date.now();
        for (const [key, value] of this.frameCache.entries()) {
            if (value.timestamp && now - value.timestamp > 5 * 60 * 1000) {
                this.frameCache.delete(key);
            }
        }
    }
}

// Пример использования
const animOptimizer = new AnimationOptimizer();
const animationPath = animOptimizer.optimalAnimationPath(0, 100, 1000, { min: 0, max: 100 });
console.log(animationPath.slice(0, 5)); // первые 5 кадров
```

## Сравнение подходов

| Подход | Преимущества | Недостатки | Когда использовать |
|--------|--------------|------------|-------------------|
| Memoization | Простота реализации, сохраняет только нужные значения | Может использовать много памяти из-за рекурсии | Когда структура задачи естественным образом рекурсивна |
| Tabulation | Эффективное использование памяти, итеративный подход | Может вычислять ненужные подзадачи | Когда все подзадачи действительно нужны |

## Заключение

Динамическое программирование — мощный инструмент для решения оптимизационных задач. Хотя в повседневной фронтенд-разработке оно используется не так часто, как в алгоритмических задачах, понимание DP помогает в решении сложных задач оптимизации, кэширования и анализа данных. DP особенно полезен при создании сложных интерактивных интерфейсов, где эффективность вычислений критична для пользовательского опыта.

См. также: [[Алгоритмы-поиска]], [[Жадные-алгоритмы]], [[Сложность-по-памяти]]