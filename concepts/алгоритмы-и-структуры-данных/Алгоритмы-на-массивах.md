---
aliases: [Алгоритмы на массивах, Работа с массивами, Массивные алгоритмы]
tags: [programming, algorithms, arrays, frontend]
---

# Алгоритмы-на-массивах

## Обзор

Алгоритмы на массивах — это методы обработки и анализа данных, организованных в виде массивов. Массивы являются одной из самых фундаментальных структур данных, и понимание алгоритмов для работы с ними критически важно для фронтенд-разработчиков.

## Важность в фронтенд-разработке

Алгоритмы на массивах особенно важны в фронтенде для:
- Обработки пользовательских данных
- Работы с коллекциями элементов (списки, галереи, таблицы)
- Оптимизации производительности
- Реализации фильтрации, сортировки и поиска
- Управления состоянием приложения

## Основные алгоритмы на массивах

### 1. Поиск элементов

#### Линейный поиск

```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Возвращаем индекс найденного элемента
        }
    }
    return -1; // Элемент не найден
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(linearSearch(numbers, 22)); // 4
```

#### Бинарный поиск (для отсортированных массивов)

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Пример использования
const sortedNumbers = [11, 12, 22, 25, 34, 64, 90];
console.log(binarySearch(sortedNumbers, 25)); // 3
```

### 2. Сортировка массивов

#### Быстрая сортировка (Quick Sort)

```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort([...numbers])); // [11, 12, 22, 25, 34, 64, 90]
```

#### Сортировка слиянием (Merge Sort)

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    return result
        .concat(left.slice(leftIndex))
        .concat(right.slice(rightIndex));
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(mergeSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]
```

### 3. Работа с подмассивами

#### Максимальная сумма подмассива (алгоритм Кадане)

```javascript
function maxSubarraySum(arr) {
    if (arr.length === 0) return 0;
    
    let maxSoFar = arr[0];
    let maxEndingHere = arr[0];
    
    for (let i = 1; i < arr.length; i++) {
        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}

// Восстановление самого подмассива
function maxSubarrayWithIndices(arr) {
    if (arr.length === 0) return { sum: 0, start: -1, end: -1 };
    
    let maxSoFar = arr[0];
    let maxEndingHere = arr[0];
    let start = 0;
    let end = 0;
    let tempStart = 0;
    
    for (let i = 1; i < arr.length; i++) {
        if (maxEndingHere < 0) {
            maxEndingHere = arr[i];
            tempStart = i;
        } else {
            maxEndingHere += arr[i];
        }
        
        if (maxEndingHere > maxSoFar) {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
        }
    }
    
    return { sum: maxSoFar, start, end };
}

// Пример использования
const arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(maxSubarraySum(arr)); // 6
console.log(maxSubarrayWithIndices(arr)); // { sum: 6, start: 3, end: 6 }
```

#### Найти подмассив с заданной суммой

```javascript
function subarrayWithSum(arr, targetSum) {
    let currentSum = arr[0];
    let start = 0;
    
    for (let end = 1; end <= arr.length; end++) {
        // Уменьшаем сумму, пока она больше или равна целевой
        while (currentSum > targetSum && start < end - 1) {
            currentSum -= arr[start];
            start++;
        }
        
        // Если текущая сумма равна целевой, возвращаем индексы
        if (currentSum === targetSum) {
            return { start, end: end - 1 };
        }
        
        // Добавляем следующий элемент к текущей сумме
        if (end < arr.length) {
            currentSum += arr[end];
        }
    }
    
    return null; // Подмассив не найден
}

// Пример использования
const arr = [1, 4, 2, 7, 3, 5];
console.log(subarrayWithSum(arr, 9)); // { start: 1, end: 3 } (элементы [4, 2, 7])
```

### 4. Работа с двумя указателями

#### Проверка на палиндром (в массиве)

```javascript
function isPalindrome(arr) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left < right) {
        if (arr[left] !== arr[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Пример использования
console.log(isPalindrome([1, 2, 3, 2, 1])); // true
console.log(isPalindrome([1, 2, 3, 4, 5])); // false
```

#### Найти пару с заданной суммой

```javascript
function findPairWithSum(arr, targetSum) {
    // Сначала сортируем массив
    const sortedArr = [...arr].sort((a, b) => a - b);
    let left = 0;
    let right = sortedArr.length - 1;
    
    while (left < right) {
        const currentSum = sortedArr[left] + sortedArr[right];
        
        if (currentSum === targetSum) {
            return [sortedArr[left], sortedArr[right]];
        } else if (currentSum < targetSum) {
            left++;
        } else {
            right--;
        }
    }
    
    return null; // Пара не найдена
}

// Пример использования
const numbers = [1, 4, 45, 6, 10, -8];
console.log(findPairWithSum(numbers, 16)); // [6, 10]
```

### 5. Поиск вращенного отсортированного массива

```javascript
function searchInRotatedArray(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        }
        
        // Проверяем, какая половина отсортирована
        if (arr[left] <= arr[mid]) {
            // Левая половина отсортирована
            if (arr[left] <= target && target < arr[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // Правая половина отсортирована
            if (arr[mid] < target && target <= arr[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1; // Элемент не найден
}

// Пример использования
const rotatedArray = [4, 5, 6, 7, 0, 1, 2];
console.log(searchInRotatedArray(rotatedArray, 0)); // 4
console.log(searchInRotatedArray(rotatedArray, 3)); // -1
```

### 6. Работа с дубликатами

#### Удаление дубликатов из отсортированного массива

```javascript
function removeDuplicates(arr) {
    if (arr.length === 0) return 0;
    
    let writeIndex = 1;
    
    for (let readIndex = 1; readIndex < arr.length; readIndex++) {
        if (arr[readIndex] !== arr[readIndex - 1]) {
            arr[writeIndex] = arr[readIndex];
            writeIndex++;
        }
    }
    
    return writeIndex; // Возвращаем новую длину
}

// Пример использования
let arr = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4];
const newLength = removeDuplicates(arr);
console.log(arr.slice(0, newLength)); // [0, 1, 2, 3, 4]
```

#### Найти все дубликаты в массиве

```javascript
function findAllDuplicates(arr) {
    const countMap = new Map();
    const duplicates = [];
    
    // Подсчитываем количество вхождений каждого элемента
    for (const num of arr) {
        countMap.set(num, (countMap.get(num) || 0) + 1);
    }
    
    // Находим элементы, которые встречаются более одного раза
    for (const [num, count] of countMap) {
        if (count > 1) {
            duplicates.push(num);
        }
    }
    
    return duplicates;
}

// Пример использования
const arr = [4, 3, 2, 7, 8, 2, 3, 1];
console.log(findAllDuplicates(arr)); // [2, 3]
```

## Практические примеры в фронтенде

### 1. Управление списком пользователей

```javascript
class UserListManager {
    constructor(users = []) {
        this.users = users;
    }
    
    // Сортировка пользователей по нескольким критериям
    sortByMultipleCriteria(sortCriteria) {
        return [...this.users].sort((a, b) => {
            for (const { field, direction } of sortCriteria) {
                const aValue = a[field];
                const bValue = b[field];
                
                let comparison = 0;
                if (typeof aValue === 'string') {
                    comparison = aValue.localeCompare(bValue);
                } else {
                    comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
                }
                
                if (comparison !== 0) {
                    return direction === 'asc' ? comparison : -comparison;
                }
            }
            return 0;
        });
    }
    
    // Поиск пользователей по нескольким полям
    searchUsers(searchTerm, fields = ['name', 'email']) {
        if (!searchTerm) return this.users;
        
        const lowerSearchTerm = searchTerm.toLowerCase();
        
        return this.users.filter(user => {
            return fields.some(field => {
                const value = user[field];
                return value && value.toLowerCase().includes(lowerSearchTerm);
            });
        });
    }
    
    // Пагинация списка пользователей
    paginate(page, pageSize) {
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        return {
            data: this.users.slice(startIndex, endIndex),
            currentPage: page,
            totalPages: Math.ceil(this.users.length / pageSize),
            totalItems: this.users.length
        };
    }
}

// Пример использования
const userManager = new UserListManager([
    { id: 1, name: "Иван", email: "ivan@example.com", age: 25 },
    { id: 2, name: "Мария", email: "maria@example.com", age: 30 },
    { id: 3, name: "Алексей", email: "alex@example.com", age: 25 }
]);

console.log(userManager.searchUsers("иван"));
console.log(userManager.sortByMultipleCriteria([
    { field: 'age', direction: 'asc' },
    { field: 'name', direction: 'asc' }
]));
```

### 2. Работа с данными для диаграмм

```javascript
class ChartDataManager {
    constructor(data = []) {
        this.data = data;
    }
    
    // Фильтрация данных по диапазону
    filterByRange(field, min, max) {
        return this.data.filter(item => {
            const value = item[field];
            return value !== undefined && value >= min && value <= max;
        });
    }
    
    // Группировка данных
    groupBy(field) {
        const groups = {};
        
        for (const item of this.data) {
            const key = item[field];
            if (!groups[key]) {
                groups[key] = [];
            }
            groups[key].push(item);
        }
        
        return groups;
    }
    
    // Агрегация данных
    aggregate(field, operation = 'sum') {
        if (this.data.length === 0) return 0;
        
        switch (operation) {
            case 'sum':
                return this.data.reduce((acc, item) => acc + (item[field] || 0), 0);
            case 'avg':
                return this.data.reduce((acc, item) => acc + (item[field] || 0), 0) / this.data.length;
            case 'max':
                return Math.max(...this.data.map(item => item[field] || 0));
            case 'min':
                return Math.min(...this.data.map(item => item[field] || 0));
            default:
                return 0;
        }
    }
    
    // Найти аномалии в данных
    findAnomalies(field, threshold) {
        const values = this.data.map(item => item[field]).filter(v => v !== undefined);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const stdDev = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - avg, 2), 0) / values.length);
        
        return this.data.filter(item => {
            const value = item[field];
            return Math.abs(value - avg) > threshold * stdDev;
        });
    }
}

// Пример использования
const chartData = [
    { month: 'Янв', revenue: 1000, expenses: 800 },
    { month: 'Фев', revenue: 1200, expenses: 900 },
    { month: 'Мар', revenue: 900, expenses: 1100 },
    { month: 'Апр', revenue: 1500, expenses: 1000 }
];

const manager = new ChartDataManager(chartData);
console.log(manager.aggregate('revenue', 'sum')); // Общая выручка
console.log(manager.groupBy('month')); // Группировка по месяцам
console.log(manager.findAnomalies('revenue', 1)); // Найти аномалии
```

### 3. Оптимизация рендеринга списков

```javascript
class ListRenderer {
    constructor(items = [], container) {
        this.items = items;
        this.container = container;
        this.renderedItems = new Set();
        this.virtualizationThreshold = 100; // Порог для виртуализации
    }
    
    // Рендеринг только видимых элементов (виртуализация)
    renderVisible(startIndex, endIndex) {
        // Очищаем контейнер
        this.container.innerHTML = '';
        
        // Рендерим только элементы в диапазоне
        for (let i = startIndex; i < Math.min(endIndex, this.items.length); i++) {
            const item = this.items[i];
            const element = this.createItemElement(item, i);
            this.container.appendChild(element);
            this.renderedItems.add(i);
        }
    }
    
    createItemElement(item, index) {
        const element = document.createElement('div');
        element.className = 'list-item';
        element.style.position = 'absolute';
        element.style.top = `${index * 50}px`; // Предполагаем высоту 50px
        element.textContent = typeof item === 'object' ? JSON.stringify(item) : item;
        return element;
    }
    
    // Двунаправленная пагинация
    getVisibleRange(scrollTop, containerHeight, itemHeight) {
        const startIndex = Math.floor(scrollTop / itemHeight);
        const visibleCount = Math.ceil(containerHeight / itemHeight);
        const endIndex = Math.min(startIndex + visibleCount + 5, this.items.length); // +5 для буфера
        
        return { startIndex, endIndex };
    }
    
    // Поиск с подсветкой
    highlightSearch(searchTerm) {
        const lowerSearchTerm = searchTerm.toLowerCase();
        
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];
            const itemText = typeof item === 'object' ? JSON.stringify(item) : String(item);
            
            if (itemText.toLowerCase().includes(lowerSearchTerm)) {
                // Подсвечиваем элемент (в реальном приложении)
                console.log(`Найдено совпадение в элементе ${i}: ${itemText}`);
            }
        }
    }
}

// Пример использования
const items = Array.from({ length: 1000 }, (_, i) => `Item ${i + 1}`);
const container = document.createElement('div'); // В реальном приложении это будет реальный DOM элемент
const renderer = new ListRenderer(items, container);

// Симуляция прокрутки
const visibleRange = renderer.getVisibleRange(500, 400, 50); // scrollTop=500, height=400, itemHeight=50
renderer.renderVisible(visibleRange.startIndex, visibleRange.endIndex);
```

### 4. Работа с товарами в корзине

```javascript
class ShoppingCart {
    constructor() {
        this.items = [];
    }
    
    addItem(product, quantity = 1) {
        const existingItem = this.items.find(item => item.id === product.id);
        
        if (existingItem) {
            existingItem.quantity += quantity;
        } else {
            this.items.push({ ...product, quantity });
        }
    }
    
    removeItem(productId) {
        this.items = this.items.filter(item => item.id !== productId);
    }
    
    updateQuantity(productId, newQuantity) {
        if (newQuantity <= 0) {
            this.removeItem(productId);
            return;
        }
        
        const item = this.items.find(item => item.id === productId);
        if (item) {
            item.quantity = newQuantity;
        }
    }
    
    // Сортировка товаров по различным критериям
    sortBy(field, direction = 'asc') {
        this.items.sort((a, b) => {
            const aVal = a[field];
            const bVal = b[field];
            
            let comparison = 0;
            if (typeof aVal === 'string') {
                comparison = aVal.localeCompare(bVal);
            } else {
                comparison = aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
            }
            
            return direction === 'asc' ? comparison : -comparison;
        });
    }
    
    // Фильтрация товаров
    filterBy(filterFn) {
        return this.items.filter(filterFn);
    }
    
    // Получение статистики
    getStats() {
        return {
            totalItems: this.items.reduce((sum, item) => sum + item.quantity, 0),
            totalValue: this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0),
            uniqueItems: this.items.length
        };
    }
    
    // Поиск товаров
    search(searchTerm) {
        const lowerSearchTerm = searchTerm.toLowerCase();
        return this.items.filter(item => 
            item.name.toLowerCase().includes(lowerSearchTerm) ||
            item.description.toLowerCase().includes(lowerSearchTerm)
        );
    }
}

// Пример использования
const cart = new ShoppingCart();
cart.addItem({ id: 1, name: "Ноутбук", price: 1000, category: "электроника" }, 1);
cart.addItem({ id: 2, name: "Мышь", price: 50, category: "электроника" }, 2);
cart.addItem({ id: 3, name: "Книга", price: 20, category: "книги" }, 3);

console.log(cart.getStats());
console.log(cart.search("ноутбук"));
cart.sortBy('price', 'desc');
console.log(cart.items);
```

## Заключение

Алгоритмы на массивах являются фундаментом для большинства операций с данными в фронтенд-приложениях. Понимание этих алгоритмов позволяет эффективно обрабатывать, фильтровать, сортировать и искать данные, что критически важно для создания отзывчивых и производительных пользовательских интерфейсов.

В повседневной фронтенд-разработке часто используются встроенные методы JavaScript для работы с массивами (map, filter, reduce, sort и т.д.), но знание базовых алгоритмов помогает принимать обоснованные решения о производительности и выбирать правильные подходы для сложных сценариев.

См. также: [[Алгоритмы-сортировки]], [[Алгоритмы-поиска]], [[Хеширование]]