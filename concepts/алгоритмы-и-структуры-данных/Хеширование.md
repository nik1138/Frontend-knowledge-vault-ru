---
aliases: [Хеширование, Хеш-функции, Хеш-таблицы]
tags: [programming, algorithms, hashing, frontend]
---

# Хеширование

## Обзор

Хеширование — это процесс преобразования входных данных произвольного размера в фиксированный размер выходных данных (хеш) с помощью хеш-функции. Хеширование широко используется для быстрого поиска, проверки целостности данных, аутентификации и других задач.

## Важность в фронтенд-разработке

Хеширование играет важную роль в фронтенде для:
- Реализации структур данных с быстрым доступом (Map, Set)
- Оптимизации производительности при поиске и сравнении данных
- Кэширования результатов вычислений
- Проверки изменений в данных (например, для memoization)
- Безопасности (хеширование паролей, проверка целостности файлов)

## Основные понятия

### 1. Хеш-функция

Хеш-функция — это функция, которая принимает входные данные и возвращает фиксированный размер хеша. Хорошая хеш-функция должна:
- Быть детерминированной (одинаковый ввод всегда дает одинаковый вывод)
- Быть быстрой для вычисления
- Равномерно распределять хеши по доступному диапазону
- Минимизировать коллизии

### 2. Коллизии

Коллизия происходит, когда две разные входные строки дают одинаковый хеш. Существует несколько стратегий разрешения коллизий:
- Метод цепочек (chaining)
- Открытая адресация (open addressing)

## Реализация хеш-таблицы

### 1. Простая хеш-таблица с методом цепочек

```javascript
class HashTable {
    constructor(size = 50) {
        this.size = size;
        this.buckets = new Array(size);
        
        // Инициализируем каждый слот как пустой массив
        for (let i = 0; i < this.size; i++) {
            this.buckets[i] = [];
        }
    }
    
    // Простая хеш-функция
    hash(key) {
        let hash = 0;
        for (let i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % this.size;
    }
    
    // Добавление пары ключ-значение
    set(key, value) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        // Проверяем, существует ли уже такой ключ
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value; // Обновляем значение
                return;
            }
        }
        
        // Добавляем новую пару ключ-значение
        bucket.push([key, value]);
    }
    
    // Получение значения по ключу
    get(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket[i][1];
            }
        }
        
        return undefined;
    }
    
    // Удаление по ключу
    remove(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket.splice(i, 1)[0][1]; // Возвращаем удаленное значение
            }
        }
        
        return undefined;
    }
    
    // Получение всех ключей
    keys() {
        const allKeys = [];
        for (const bucket of this.buckets) {
            for (const [key, value] of bucket) {
                allKeys.push(key);
            }
        }
        return allKeys;
    }
}

// Пример использования
const hashTable = new HashTable();
hashTable.set('name', 'John');
hashTable.set('age', 30);
hashTable.set('city', 'New York');

console.log(hashTable.get('name')); // 'John'
console.log(hashTable.get('age'));  // 30
console.log(hashTable.keys());      // ['name', 'age', 'city']
```

### 2. Улучшенная хеш-функция

```javascript
class ImprovedHashTable {
    constructor(size = 50) {
        this.size = size;
        this.buckets = new Array(size);
        
        for (let i = 0; i < this.size; i++) {
            this.buckets[i] = [];
        }
    }
    
    // Улучшенная хеш-функция (алгоритм djb2)
    hash(key) {
        let hash = 5381;
        for (let i = 0; i < key.length; i++) {
            hash = ((hash << 5) + hash) + key.charCodeAt(i); // hash * 33 + char
        }
        return Math.abs(hash) % this.size;
    }
    
    set(key, value) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value;
                return;
            }
        }
        
        bucket.push([key, value]);
    }
    
    get(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket[i][1];
            }
        }
        
        return undefined;
    }
    
    remove(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket.splice(i, 1)[0][1];
            }
        }
        
        return undefined;
    }
}

// Пример использования
const improvedTable = new ImprovedHashTable();
improvedTable.set('email', 'john@example.com');
improvedTable.set('phone', '+1234567890');
console.log(improvedTable.get('email')); // 'john@example.com'
```

## Алгоритмы хеширования

### 1. Простой полиномиальный хеш

```javascript
function polynomialHash(str, prime = 31, mod = 1e9 + 9) {
    let hash = 0;
    let pPow = 1;
    
    for (let i = 0; i < str.length; i++) {
        hash = (hash + (str[i].charCodeAt(0) - 'a'.charCodeAt(0) + 1) * pPow) % mod;
        pPow = (pPow * prime) % mod;
    }
    
    return hash;
}

// Пример использования
console.log(polynomialHash("hello")); // 99162322
console.log(polynomialHash("world")); // 57625266
```

### 2. MD5-подобный хеш (упрощенная версия)

```javascript
function simpleHash(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Преобразуем в 32-битное целое
    }
    
    return Math.abs(hash);
}

// Пример использования
console.log(simpleHash("hello")); // 99162322
console.log(simpleHash("world")); // 113318802
```

## Практические примеры в фронтенде

### 1. Кэширование результатов вычислений

```javascript
class MemoizedFunction {
    constructor() {
        this.cache = new Map();
    }
    
    // Кэширование результата функции на основе аргументов
    memoize(fn, keyFn = JSON.stringify) {
        return (...args) => {
            const key = keyFn(args);
            
            if (this.cache.has(key)) {
                console.log('Cache hit');
                return this.cache.get(key);
            }
            
            console.log('Cache miss');
            const result = fn.apply(this, args);
            this.cache.set(key, result);
            return result;
        };
    }
    
    clearCache() {
        this.cache.clear();
    }
}

// Пример использования
const memoizer = new MemoizedFunction();

// Дорогостоящая функция
const expensiveFunction = (n) => {
    console.log('Выполнение дорогостоящей операции...');
    return n * n * n;
};

const memoizedExpensiveFunction = memoizer.memoize(expensiveFunction);

console.log(memoizedExpensiveFunction(5)); // Выполнение дорогостоящей операции... 125
console.log(memoizedExpensiveFunction(5)); // Cache hit 125
console.log(memoizedExpensiveFunction(3)); // Cache miss, Выполнение дорогостоящей операции... 27
```

### 2. Уникальные идентификаторы

```javascript
class IdGenerator {
    constructor() {
        this.usedIds = new Set();
    }
    
    // Генерация уникального ID на основе строки
    generateId(baseString) {
        let id = this.simpleHash(baseString);
        let attempt = 0;
        
        // Убедимся, что ID уникален
        while (this.usedIds.has(id)) {
            id = this.simpleHash(baseString + attempt);
            attempt++;
        }
        
        this.usedIds.add(id);
        return id.toString();
    }
    
    // Простой хеш для генерации ID
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }
    
    // Генерация UUID-подобного ID
    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}

// Пример использования
const idGen = new IdGenerator();
console.log(idGen.generateId('user-profile')); // Уникальный ID
console.log(idGen.generateId('user-profile')); // Другой уникальный ID
console.log(idGen.generateUUID()); // Случайный UUID
```

### 3. Проверка целостности данных

```javascript
class DataIntegrityChecker {
    // Простой хеш для проверки целостности
    static hash(data) {
        const str = JSON.stringify(data);
        let hash = 0;
        
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        
        return Math.abs(hash);
    }
    
    // Проверка, изменились ли данные
    static hasChanged(originalData, newData) {
        return this.hash(originalData) !== this.hash(newData);
    }
    
    // Создание "подписи" данных
    static createSignature(data) {
        return {
            data,
            hash: this.hash(data),
            timestamp: Date.now()
        };
    }
    
    // Проверка подписи
    static verifySignature(signature) {
        const currentHash = this.hash(signature.data);
        return currentHash === signature.hash;
    }
}

// Пример использования
const originalData = { user: 'john', role: 'admin', permissions: ['read', 'write'] };
const signature = DataIntegrityChecker.createSignature(originalData);

console.log('Подпись создана:', signature);
console.log('Подпись действительна:', DataIntegrityChecker.verifySignature(signature));

// Изменяем данные
const modifiedData = { ...originalData, permissions: ['read'] };
console.log('Данные изменились:', DataIntegrityChecker.hasChanged(originalData, modifiedData));
```

### 4. Оптимизация рендеринга (React-подобный подход)

```javascript
class ComponentRenderer {
    constructor() {
        this.renderedComponents = new Map();
    }
    
    // Вычисление хеша состояния компонента
    computeStateHash(props, state) {
        const stateStr = JSON.stringify({ props, state });
        let hash = 0;
        
        for (let i = 0; i < stateStr.length; i++) {
            const char = stateStr.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        
        return Math.abs(hash);
    }
    
    // Рендер компонента с проверкой необходимости обновления
    renderComponent(componentId, props, state, renderFunction) {
        const stateHash = this.computeStateHash(props, state);
        
        // Проверяем, изменилось ли состояние
        if (this.renderedComponents.has(componentId)) {
            const { hash, element } = this.renderedComponents.get(componentId);
            
            if (hash === stateHash) {
                console.log(`Компонент ${componentId} не изменился, используем кэш`);
                return element;
            }
        }
        
        // Рендерим компонент
        const element = renderFunction(props, state);
        
        // Сохраняем в кэш
        this.renderedComponents.set(componentId, {
            hash: stateHash,
            element: element,
            timestamp: Date.now()
        });
        
        console.log(`Компонент ${componentId} перерисован`);
        return element;
    }
    
    // Очистка устаревших кэшей
    cleanupStaleCache(maxAge = 300000) { // 5 минут
        const now = Date.now();
        for (const [id, { timestamp }] of this.renderedComponents.entries()) {
            if (now - timestamp > maxAge) {
                this.renderedComponents.delete(id);
            }
        }
    }
}

// Пример использования
const renderer = new ComponentRenderer();

const userProfileComponent = (props, state) => {
    return `<div>
        <h2>${props.name}</h2>
        <p>Role: ${props.role}</p>
        <p>Status: ${state.active ? 'Active' : 'Inactive'}</p>
    </div>`;
};

// Первый рендер
const element1 = renderer.renderComponent(
    'user-profile-1', 
    { name: 'John', role: 'admin' }, 
    { active: true }, 
    userProfileComponent
);

// Второй рендер с теми же данными (должен использовать кэш)
const element2 = renderer.renderComponent(
    'user-profile-1', 
    { name: 'John', role: 'admin' }, 
    { active: true }, 
    userProfileComponent
);

// Рендер с измененными данными
const element3 = renderer.renderComponent(
    'user-profile-1', 
    { name: 'John', role: 'admin' }, 
    { active: false }, // изменено
    userProfileComponent
);
```

### 5. Управление зависимостями

```javascript
class DependencyManager {
    constructor() {
        this.dependencies = new Map();
        this.dependencyHashes = new Map();
    }
    
    // Добавление зависимости
    addDependency(name, version, files) {
        this.dependencies.set(name, { version, files });
        this.dependencyHashes.set(name, this.computeFilesHash(files));
    }
    
    // Вычисление хеша файлов зависимости
    computeFilesHash(files) {
        const filesStr = JSON.stringify(files.sort());
        let hash = 0;
        
        for (let i = 0; i < filesStr.length; i++) {
            const char = filesStr.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        
        return Math.abs(hash);
    }
    
    // Проверка, изменилась ли зависимость
    hasDependencyChanged(name, newFiles) {
        if (!this.dependencies.has(name)) {
            return true; // новая зависимость
        }
        
        const oldHash = this.dependencyHashes.get(name);
        const newHash = this.computeFilesHash(newFiles);
        
        return oldHash !== newHash;
    }
    
    // Получение информации о зависимости
    getDependency(name) {
        return this.dependencies.get(name);
    }
    
    // Получение всех зависимостей
    getAllDependencies() {
        return Array.from(this.dependencies.entries()).map(([name, info]) => ({
            name,
            ...info
        }));
    }
}

// Пример использования
const depManager = new DependencyManager();
depManager.addDependency('react', '18.2.0', ['react.js', 'jsx-runtime.js']);
depManager.addDependency('lodash', '4.17.21', ['lodash.js', 'fp.js']);

console.log('Зависимости:', depManager.getAllDependencies());

// Проверяем, изменились ли зависимости
const files = ['react.js', 'jsx-runtime.js', 'scheduler.js']; // добавлен scheduler.js
console.log('React изменился:', depManager.hasDependencyChanged('react', files)); // true
```

## Сравнение структур данных

| Структура | Доступ | Поиск | Вставка | Удаление | Память |
|-----------|--------|-------|---------|----------|--------|
| Хеш-таблица | O(1) | O(1) | O(1) | O(1) | O(n) |
| Массив | O(1) | O(n) | O(1) | O(n) | O(n) |
| Отсортированный массив | O(1) | O(log n) | O(n) | O(n) | O(n) |
| Двоичное дерево поиска | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |

> [!note] Важно
> В теории хеш-таблицы обеспечивают O(1) время доступа, но на практике производительность зависит от качества хеш-функции и стратегии разрешения коллизий.

## Заключение

Хеширование — мощный инструмент для оптимизации производительности в фронтенд-приложениях. Понимание принципов работы хеш-функций и хеш-таблиц позволяет эффективно решать задачи кэширования, проверки целостности данных, управления состоянием и оптимизации рендеринга.

В современных фреймворках (React, Vue, Angular) хеширование используется для оптимизации процесса сравнения (diffing) и определения необходимости перерисовки компонентов. Также хеширование применяется в системах сборки для определения изменений в файлах и оптимизации процесса сборки.

См. также: [[Алгоритмы-поиска]], [[Алгоритмы-на-строках]], [[Сложность-по-памяти]]