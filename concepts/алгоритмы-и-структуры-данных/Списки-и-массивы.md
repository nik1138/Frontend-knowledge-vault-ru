---
aliases: ["Массивы", "Списки", "Linked Lists", "Dynamic Arrays"]
tags: ["#алгоритмы", "#структуры-данных", "#массивы", "#списки", "#javascript"]
---

# Списки и массивы

## Общее описание

Массивы и списки - это базовые структуры данных, которые позволяют хранить коллекции элементов. В контексте фронтенд-разработки понимание этих структур и их особенностей критически важно для эффективной работы с данными в приложениях.

## Массивы (Arrays)

Массивы - это упорядоченные коллекции элементов, доступ к которым осуществляется по индексу. В JavaScript массивы реализованы как динамические массивы (dynamic arrays), что позволяет изменять их размер во время выполнения.

### Характеристики массивов:

- **Доступ к элементам**: O(1) - прямой доступ по индексу
- **Вставка/удаление в конец**: O(1) амортизированно
- **Вставка/удаление в начало или середину**: O(n)
- **Поиск элемента**: O(n) для неотсортированного массива, O(log n) для бинарного поиска в отсортированном

```javascript
// Основные операции с массивами
const arr = [1, 2, 3, 4, 5];

// Доступ по индексу - O(1)
const firstElement = arr[0];

// Добавление в конец - O(1) амортизированно
arr.push(6);

// Удаление из конца - O(1)
arr.pop();

// Добавление в начало - O(n)
arr.unshift(0);

// Удаление из начала - O(n)
arr.shift();

// Поиск элемента - O(n)
const index = arr.indexOf(3);
```

### Встроенные методы массивов в JavaScript

```javascript
const numbers = [1, 2, 3, 4, 5];

// map - преобразование каждого элемента: O(n)
const doubled = numbers.map(num => num * 2);

// filter - фильтрация элементов: O(n)
const evens = numbers.filter(num => num % 2 === 0);

// find - поиск первого элемента: O(n)
const found = numbers.find(num => num > 3);

// reduce - агрегация элементов: O(n)
const sum = numbers.reduce((acc, num) => acc + num, 0);

// slice - создание подмассива: O(k), где k - длина подмассива
const subArray = numbers.slice(1, 3);

// splice - вставка/удаление элементов: O(n)
numbers.splice(2, 1, 'new'); // удалить 1 элемент с индекса 2 и вставить 'new'
```

## Связные списки (Linked Lists)

Связные списки состоят из узлов, где каждый узел содержит данные и ссылку на следующий узел. В JavaScript связные списки обычно реализуются вручную.

### Характеристики связных списков:

- **Доступ к элементам**: O(n) - нужно пройти от начала к нужному элементу
- **Вставка/удаление в начало**: O(1)
- **Вставка/удаление в середину/конец**: O(n) - нужно найти позицию
- **Поиск элемента**: O(n)

```javascript
// Реализация односвязного списка
class ListNode {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }

    // Вставка в начало - O(1)
    prepend(val) {
        const newNode = new ListNode(val);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }

    // Вставка в конец - O(n)
    append(val) {
        const newNode = new ListNode(val);
        
        if (!this.head) {
            this.head = newNode;
            this.size++;
            return;
        }
        
        let current = this.head;
        while (current.next) {
            current = current.next;
        }
        current.next = newNode;
        this.size++;
    }

    // Поиск элемента - O(n)
    find(val) {
        let current = this.head;
        while (current) {
            if (current.val === val) {
                return current;
            }
            current = current.next;
        }
        return null;
    }

    // Удаление элемента - O(n)
    remove(val) {
        if (!this.head) return false;

        if (this.head.val === val) {
            this.head = this.head.next;
            this.size--;
            return true;
        }

        let current = this.head;
        while (current.next) {
            if (current.next.val === val) {
                current.next = current.next.next;
                this.size--;
                return true;
            }
            current = current.next;
        }
        return false;
    }
}
```

## Применение в фронтенд-разработке

### Работа с данными пользовательского интерфейса

```javascript
// Хранение состояния списка элементов
class TodoList {
    constructor() {
        this.todos = []; // Массив для хранения задач
    }

    // Добавление задачи - O(1) амортизированно
    addTodo(text) {
        this.todos.push({
            id: Date.now(),
            text,
            completed: false
        });
    }

    // Удаление задачи по ID - O(n)
    removeTodo(id) {
        const index = this.todos.findIndex(todo => todo.id === id);
        if (index !== -1) {
            this.todos.splice(index, 1);
        }
    }

    // Поиск задачи по ID - O(n)
    findTodo(id) {
        return this.todos.find(todo => todo.id === id);
    }

    // Обновление задачи - O(n)
    updateTodo(id, updates) {
        const todo = this.findTodo(id);
        if (todo) {
            Object.assign(todo, updates);
        }
    }
}
```

### Работа с DOM-элементами

```javascript
// Массив DOM-элементов для эффективной обработки
class ListManager {
    constructor(selector) {
        this.elements = Array.from(document.querySelectorAll(selector));
    }

    // Фильтрация видимых элементов - O(n)
    filterVisible() {
        return this.elements.filter(el => !el.hidden);
    }

    // Применение стиля ко всем элементам - O(n)
    applyStyle(property, value) {
        this.elements.forEach(el => {
            el.style[property] = value;
        });
    }

    // Поиск элемента по атрибуту - O(n)
    findByAttribute(attr, value) {
        return this.elements.find(el => el.getAttribute(attr) === value);
    }
}
```

### Оптимизация рендеринга списков

```javascript
// Использование массивов для виртуализации списков
class VirtualList {
    constructor(data, itemHeight, containerHeight) {
        this.data = data; // Исходный массив данных
        this.itemHeight = itemHeight;
        this.containerHeight = containerHeight;
        this.visibleItems = Math.ceil(containerHeight / itemHeight);
    }

    // Получение видимых элементов на основе прокрутки
    getVisibleRange(scrollTop) {
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const endIndex = Math.min(
            startIndex + this.visibleItems + 5, // 5 дополнительных для плавности
            this.data.length
        );
        
        return {
            startIndex,
            endIndex,
            items: this.data.slice(startIndex, endIndex)
        };
    }
}
```

## Сравнение массивов и связных списков

| Характеристика | Массив | Связный список |
|----------------|--------|----------------|
| Доступ по индексу | O(1) | O(n) |
| Вставка в начало | O(n) | O(1) |
| Вставка в конец | O(1) амортизированно | O(n) |
| Удаление по индексу | O(n) | O(n) |
| Память | Компактная | Больше оверхеда |
| Кэш-эффективность | Высокая | Низкая |

## Практические рекомендации для фронтенд-разработчиков

1. **Используйте массивы для большинства случаев** - они более кэш-эффективны и имеют встроенные методы
2. **Избегайте частого использования `unshift` и `shift`** - они требуют перенумерации всех элементов
3. **Рассмотрите использование `Set` или `Map` для частых операций поиска** - O(1) вместо O(n)
4. **Оптимизируйте операции с большими массивами** с помощью дебаунса или виртуализации
5. **Используйте методы массивов для декларативного программирования** - `map`, `filter`, `reduce`

```javascript
// Плохо: мутация массива в цикле
function addIdsBad(items) {
    for (let i = 0; i < items.length; i++) {
        items[i].id = i;
    }
    return items;
}

// Хорошо: функциональный подход
function addIdsGood(items) {
    return items.map((item, index) => ({
        ...item,
        id: index
    }));
}
```

## Заключение

Массивы являются одной из самых важных структур данных в фронтенд-разработке. Понимание их особенностей помогает создавать более эффективные приложения. В большинстве случаев массивы JavaScript (которые на самом деле динамические массивы) являются оптимальным выбором, особенно учитывая встроенные методы и хорошую интеграцию с браузерными API.

См. также: [[Сложность-алгоритмов]], [[Стеки-и-очереди]], [[Деревья-и-графы]], [[Хэш-таблицы]], [[Производительность фронтенд-приложений]]