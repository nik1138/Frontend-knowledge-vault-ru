---
aliases: [Жадные алгоритмы, Greedy Algorithms, Оптимизация с Greedy]
tags: [programming, algorithms, greedy, frontend]
---

# Жадные-алгоритмы

## Обзор

Жадные алгоритмы — это алгоритмы, которые на каждом шаге принимают локально оптимальное решение в надежде получить глобально оптимальное решение. Они строят решение пошагово, выбирая на каждом шаге то, что выглядит лучшим в данный момент, без учета будущих последствий.

## Важность в фронтенд-разработке

Жадные алгоритмы полезны в фронтенде для:
- Оптимизации загрузки ресурсов
- Управления приоритетами задач
- Оптимизации отображения элементов интерфейса
- Реализации систем кэширования
- Оптимизации пользовательского опыта

## Основные принципы

### 1. Жадный выбор

На каждом шаге делается выбор, который выглядит лучшим в данный момент, без учета последствий для будущих шагов.

### 2. Оптимальная подструктура

Проблема обладает свойством оптимальной подструктуры, если оптимальное решение задачи содержит оптимальные решения подзадач.

## Классические задачи жадных алгоритмов

### 1. Задача о выборе активностей

```javascript
function activitySelection(activities) {
    // Сортируем активности по времени окончания
    activities.sort((a, b) => a.end - b.end);
    
    const selected = [];
    let lastEnd = -1;
    
    for (const activity of activities) {
        // Если начало активности после окончания последней выбранной
        if (activity.start >= lastEnd) {
            selected.push(activity);
            lastEnd = activity.end;
        }
    }
    
    return selected;
}

// Пример использования
const activities = [
    { start: 1, end: 4, name: 'A' },
    { start: 3, end: 5, name: 'B' },
    { start: 0, end: 6, name: 'C' },
    { start: 5, end: 7, name: 'D' },
    { start: 8, end: 9, name: 'E' },
    { start: 5, end: 9, name: 'F' }
];

console.log(activitySelection(activities));
// [{ start: 1, end: 4, name: 'A' }, { start: 5, end: 7, name: 'D' }, { start: 8, end: 9, name: 'E' }]
```

### 2. Задача о размене монет (для специальных систем монет)

```javascript
function coinChangeGreedy(coins, amount) {
    // Сортируем монеты в порядке убывания
    coins.sort((a, b) => b - a);
    
    const result = [];
    let remaining = amount;
    
    for (const coin of coins) {
        while (remaining >= coin) {
            result.push(coin);
            remaining -= coin;
        }
        
        if (remaining === 0) {
            break;
        }
    }
    
    return remaining === 0 ? result : null; // null если невозможно разменять
}

// Пример использования
const coins = [25, 10, 5, 1]; // американская система монет
console.log(coinChangeGreedy(coins, 67)); // [25, 25, 10, 5, 1, 1]
```

> [!warning] Важно
> Жадный алгоритм для задачи о размене монет работает оптимально только для определенных систем монет (например, американская). Для произвольных систем монет лучше использовать динамическое программирование.

### 3. Задача о покрытии множества

```javascript
function setCover(universe, sets) {
    const covered = new Set();
    const selectedSets = [];
    
    while (covered.size < universe.size) {
        let bestSet = null;
        let maxNewCoverage = 0;
        
        for (const set of sets) {
            // Подсчитываем количество новых элементов, которые покрывает множество
            let newCoverage = 0;
            for (const element of set) {
                if (!covered.has(element)) {
                    newCoverage++;
                }
            }
            
            if (newCoverage > maxNewCoverage) {
                maxNewCoverage = newCoverage;
                bestSet = set;
            }
        }
        
        if (bestSet) {
            selectedSets.push(bestSet);
            for (const element of bestSet) {
                covered.add(element);
            }
        } else {
            // Невозможно покрыть все элементы
            break;
        }
    }
    
    return selectedSets;
}

// Пример использования
const universe = new Set([1, 2, 3, 4, 5]);
const sets = [
    new Set([1, 2, 3]),
    new Set([2, 4]),
    new Set([3, 4]),
    new Set([4, 5])
];

console.log(setCover(universe, sets)); // [[1, 2, 3], [4, 5]] или другое оптимальное решение
```

### 4. Кодирование Хаффмана (упрощенная версия)

```javascript
class Node {
    constructor(char, freq) {
        this.char = char;
        this.freq = freq;
        this.left = null;
        this.right = null;
    }
}

function huffmanCoding(chars, freqs) {
    // Создаем узлы для каждого символа
    const nodes = [];
    for (let i = 0; i < chars.length; i++) {
        nodes.push(new Node(chars[i], freqs[i]));
    }
    
    // Сортируем по частоте
    nodes.sort((a, b) => a.freq - b.freq);
    
    // Пока не останется один узел
    while (nodes.length > 1) {
        // Берем два узла с наименьшей частотой
        const left = nodes.shift();
        const right = nodes.shift();
        
        // Создаем новый узел с частотой, равной сумме частот
        const merged = new Node(null, left.freq + right.freq);
        merged.left = left;
        merged.right = right;
        
        // Вставляем новый узел обратно в очередь
        let inserted = false;
        for (let i = 0; i < nodes.length; i++) {
            if (nodes[i].freq > merged.freq) {
                nodes.splice(i, 0, merged);
                inserted = true;
                break;
            }
        }
        if (!inserted) {
            nodes.push(merged);
        }
    }
    
    return nodes[0]; // корень дерева
}

// Функция для генерации кодов
function generateCodes(root) {
    if (!root) return {};
    
    const codes = {};
    
    function traverse(node, code) {
        if (node.char !== null) {
            codes[node.char] = code || '0'; // если только один символ
        } else {
            if (node.left) traverse(node.left, code + '0');
            if (node.right) traverse(node.right, code + '1');
        }
    }
    
    traverse(root, '');
    return codes;
}

// Пример использования
const chars = ['a', 'b', 'c', 'd', 'e'];
const freqs = [45, 13, 12, 16, 9];
const root = huffmanCoding(chars, freqs);
const codes = generateCodes(root);
console.log(codes); // { a: '0', b: '101', c: '100', d: '111', e: '110' }
```

### 5. Задача о максимальной прибыли при расписании работ

```javascript
function jobScheduling(jobs) {
    // Сортируем работы по убыванию прибыли
    jobs.sort((a, b) => b.profit - a.profit);
    
    // Находим максимальное время выполнения
    let maxDeadline = 0;
    for (const job of jobs) {
        maxDeadline = Math.max(maxDeadline, job.deadline);
    }
    
    // Создаем массив для хранения запланированных работ
    const result = new Array(maxDeadline + 1).fill(null);
    let totalProfit = 0;
    
    for (const job of jobs) {
        // Находим последний доступный слот перед дедлайном
        for (let j = job.deadline; j > 0; j--) {
            if (result[j] === null) {
                result[j] = job;
                totalProfit += job.profit;
                break;
            }
        }
    }
    
    // Возвращаем только заполненные слоты
    return result.filter(job => job !== null);
}

// Пример использования
const jobs = [
    { id: 'J1', deadline: 2, profit: 100 },
    { id: 'J2', deadline: 1, profit: 19 },
    { id: 'J3', deadline: 2, profit: 27 },
    { id: 'J4', deadline: 1, profit: 25 },
    { id: 'J5', deadline: 3, profit: 15 }
];

console.log(jobScheduling(jobs));
// [{ id: 'J3', deadline: 2, profit: 27 }, { id: 'J1', deadline: 2, profit: 100 }, { id: 'J5', deadline: 3, profit: 15 }]
```

## Практические примеры в фронтенде

### 1. Оптимизация загрузки ресурсов

```javascript
class ResourceManager {
    constructor() {
        this.resources = [];
    }
    
    addResource(priority, size, url) {
        this.resources.push({ priority, size, url, loaded: false });
    }
    
    // Жадный алгоритм для определения порядка загрузки ресурсов
    prioritizeLoading(availableBandwidth) {
        // Сортируем ресурсы по соотношению приоритет/размер (жадный выбор)
        const sortedResources = [...this.resources]
            .filter(r => !r.loaded)
            .sort((a, b) => (b.priority / b.size) - (a.priority / a.size));
        
        const toLoad = [];
        let usedBandwidth = 0;
        
        for (const resource of sortedResources) {
            if (usedBandwidth + resource.size <= availableBandwidth) {
                toLoad.push(resource);
                usedBandwidth += resource.size;
            }
        }
        
        return toLoad;
    }
    
    // Загрузка ресурсов по приоритету
    async loadResources(availableBandwidth) {
        const resourcesToLoad = this.prioritizeLoading(availableBandwidth);
        
        const promises = resourcesToLoad.map(async (resource) => {
            try {
                // Симуляция загрузки ресурса
                await new Promise(resolve => setTimeout(resolve, resource.size * 10));
                resource.loaded = true;
                console.log(`Загружен ресурс: ${resource.url}`);
            } catch (error) {
                console.error(`Ошибка загрузки ресурса: ${resource.url}`, error);
            }
        });
        
        return Promise.all(promises);
    }
}

// Пример использования
const resourceManager = new ResourceManager();
resourceManager.addResource(10, 5, 'critical.css');
resourceManager.addResource(5, 2, 'feature.js');
resourceManager.addResource(8, 8, 'background.jpg');
resourceManager.addResource(3, 1, 'icon.png');

console.log(resourceManager.prioritizeLoading(10));
```

### 2. Оптимизация отображения элементов (ленивая загрузка)

```javascript
class LazyLoader {
    constructor(container, items) {
        this.container = container;
        this.items = items;
        this.loadedItems = 0;
        this.maxItemsPerBatch = 5;
    }
    
    // Жадный алгоритм для определения количества элементов для загрузки
    calculateOptimalBatch(renderTimeBudget = 16) { // 16мс на кадр
        let batchSize = 0;
        let estimatedRenderTime = 0;
        
        // Жадно добавляем элементы, пока не превысим бюджет времени
        while (batchSize < this.maxItemsPerBatch && 
               this.loadedItems + batchSize < this.items.length) {
            
            // Оценка времени рендеринга одного элемента (в реальном приложении это будет более сложным)
            const estimatedTimePerItem = 3; // 3мс на элемент
            estimatedRenderTime += estimatedTimePerItem;
            
            if (estimatedRenderTime > renderTimeBudget) {
                break;
            }
            
            batchSize++;
        }
        
        return batchSize;
    }
    
    loadBatch() {
        const batchSize = this.calculateOptimalBatch();
        const itemsToLoad = this.items.slice(
            this.loadedItems, 
            this.loadedItems + batchSize
        );
        
        itemsToLoad.forEach(item => {
            // Добавляем элемент в DOM
            const element = document.createElement('div');
            element.textContent = item.text;
            this.container.appendChild(element);
        });
        
        this.loadedItems += batchSize;
        return itemsToLoad.length;
    }
    
    hasMoreItems() {
        return this.loadedItems < this.items.length;
    }
}

// Пример использования
const container = document.createElement('div'); // в реальном приложении это будет реальный DOM элемент
const items = Array.from({ length: 20 }, (_, i) => ({ text: `Item ${i + 1}` }));
const lazyLoader = new LazyLoader(container, items);

// Загружаем элементы порциями
while (lazyLoader.hasMoreItems()) {
    const loadedCount = lazyLoader.loadBatch();
    console.log(`Загружено ${loadedCount} элементов`);
}
```

### 3. Оптимизация кэширования

```javascript
class CacheManager {
    constructor(maxSize) {
        this.maxSize = maxSize;
        this.cache = new Map();
        this.accessCount = new Map(); // для LRU
    }
    
    // Жадный алгоритм: при переполнении удаляем наименее ценные элементы
    put(key, value, priority = 1) {
        if (this.cache.has(key)) {
            this.cache.set(key, value);
            this.accessCount.set(key, this.accessCount.get(key) + 1);
            return;
        }
        
        if (this.cache.size >= this.maxSize) {
            this.evict();
        }
        
        this.cache.set(key, value);
        this.accessCount.set(key, 1);
    }
    
    get(key) {
        if (this.cache.has(key)) {
            this.accessCount.set(key, this.accessCount.get(key) + 1);
            return this.cache.get(key);
        }
        return undefined;
    }
    
    // Жадно удаляем наименее ценный элемент (LRU)
    evict() {
        let lruKey = null;
        let minAccessCount = Infinity;
        
        for (const [key, count] of this.accessCount) {
            if (count < minAccessCount) {
                minAccessCount = count;
                lruKey = key;
            }
        }
        
        if (lruKey) {
            this.cache.delete(lruKey);
            this.accessCount.delete(lruKey);
        }
    }
    
    // Жадный алгоритм для предварительной загрузки
    preload(keys) {
        const availableSlots = this.maxSize - this.cache.size;
        if (availableSlots <= 0) return [];
        
        // Жадно выбираем ключи с наивысшим приоритетом для предзагрузки
        const sortedKeys = keys
            .filter(key => !this.cache.has(key))
            .slice(0, availableSlots);
        
        return sortedKeys;
    }
}

// Пример использования
const cache = new CacheManager(3);
cache.put('home', '<div>Home Page</div>', 10);
cache.put('about', '<div>About Page</div>', 5);
cache.put('contact', '<div>Contact Page</div>', 8);

console.log(cache.get('home')); // <div>Home Page</div>
cache.put('products', '<div>Products Page</div>', 7); // удаляет 'about' как наименее ценный
```

### 4. Оптимизация пользовательского интерфейса

```javascript
class UIOptimizer {
    constructor() {
        this.components = new Map();
    }
    
    registerComponent(id, renderCost, priority, isVisible) {
        this.components.set(id, {
            id,
            renderCost, // условная стоимость рендеринга
            priority,   // приоритет отображения
            isVisible,
            lastRendered: 0
        });
    }
    
    // Жадный алгоритм для определения компонентов для рендеринга в рамках бюджета времени
    optimizeRendering(timeBudget = 16) { // 16мс на кадр
        const components = Array.from(this.components.values())
            .filter(comp => !comp.isVisible); // только невидимые компоненты
        
        // Сортируем по соотношению приоритет/стоимость рендеринга (жадный выбор)
        components.sort((a, b) => 
            (b.priority / b.renderCost) - (a.priority / a.renderCost)
        );
        
        const toRender = [];
        let totalTime = 0;
        
        for (const component of components) {
            if (totalTime + component.renderCost <= timeBudget) {
                toRender.push(component);
                totalTime += component.renderCost;
            } else {
                break; // превышен бюджет времени
            }
        }
        
        // Отмечаем компоненты как видимые
        toRender.forEach(comp => {
            comp.isVisible = true;
            comp.lastRendered = Date.now();
        });
        
        return toRender;
    }
    
    // Жадный алгоритм для определения компонентов для отложенной загрузки
    prioritizeLazyLoading() {
        const components = Array.from(this.components.values())
            .filter(comp => !comp.isVisible);
        
        // Сортируем по приоритету (жадный выбор)
        return components.sort((a, b) => b.priority - a.priority);
    }
}

// Пример использования
const uiOptimizer = new UIOptimizer();
uiOptimizer.registerComponent('header', 2, 10, true);
uiOptimizer.registerComponent('sidebar', 3, 8, true);
uiOptimizer.registerComponent('content', 5, 9, false);
uiOptimizer.registerComponent('footer', 1, 5, false);
uiOptimizer.registerComponent('modal', 4, 15, false);

const toRender = uiOptimizer.optimizeRendering(10);
console.log('Компоненты для рендеринга:', toRender.map(c => c.id));
```

## Преимущества и недостатки жадных алгоритмов

### Преимущества:
- Простота реализации
- Обычно более высокая эффективность по сравнению с другими подходами
- Меньшее потребление памяти
- Хорошая производительность в реальном времени

### Недостатки:
- Не всегда приводят к глобально оптимальному решению
- Требуют доказательства корректности для каждой конкретной задачи
- Иногда сложно определить, какой выбор является "жадным"

## Когда использовать жадные алгоритмы

Жадные алгоритмы подходят, когда:
1. Задача обладает свойством жадного выбора
2. Задача имеет оптимальную подструктуру
3. Нужно быстро получить приближенное решение
4. Необходима высокая производительность в реальном времени

## Заключение

Жадные алгоритмы — мощный инструмент для решения оптимизационных задач, особенно когда требуется быстро получить хорошее, хотя и не обязательно оптимальное, решение. В фронтенд-разработке они особенно полезны для задач оптимизации производительности, управления ресурсами и улучшения пользовательского опыта.

См. также: [[Динамическое-программирование]], [[Алгоритмы-поиска]], [[Алгоритмы-сортировки]]