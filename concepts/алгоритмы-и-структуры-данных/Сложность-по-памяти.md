---
aliases: [Сложность по памяти, Memory Complexity, Пространственная сложность]
tags: [programming, algorithms, complexity, memory, frontend]
---

# Сложность-по-памяти

## Обзор

Сложность по памяти (или пространственная сложность) — это мера объема памяти, которую алгоритм использует в зависимости от размера входных данных. Она показывает, как растет потребление памяти при увеличении размера входных данных.

## Важность в фронтенд-разработке

Понимание сложности по памяти особенно важно в фронтенд-разработке для:
- Оптимизации производительности веб-приложений
- Управления памятью в браузере
- Создания эффективных пользовательских интерфейсов
- Работы с большими наборами данных
- Предотвращения утечек памяти
- Оптимизации загрузки и кэширования ресурсов

## Обозначения сложности

Как и временная сложность, сложность по памяти выражается с помощью O-нотации:

- **O(1)** - константная сложность: объем памяти не зависит от размера входных данных
- **O(log n)** - логарифмическая сложность: память растет логарифмически
- **O(n)** - линейная сложность: память растет пропорционально размеру входных данных
- **O(n log n)** - линеарифмическая сложность
- **O(n²)** - квадратичная сложность: память растет пропорционально квадрату размера данных

## Основные концепции

### 1. Дополнительная память vs Общая память

- **Дополнительная память**: память, дополнительно используемая алгоритмом (не считая память для входных данных)
- **Общая память**: общее количество памяти, используемое алгоритмом

```javascript
// Пример: сортировка с O(1) дополнительной памятью
function bubbleSort(arr) {
    // Используем исходный массив, дополнительная память O(1)
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

// Пример: сортировка с O(n) дополнительной памятью
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));  // Создаем новые массивы
    const right = mergeSort(arr.slice(mid));    // Создаем новые массивы
    
    // Дополнительная память для результата
    const result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    return result
        .concat(left.slice(leftIndex))
        .concat(right.slice(rightIndex));
}
```

## Анализ сложности по памяти для различных алгоритмов

### 1. Алгоритмы сортировки

```javascript
// Сортировка пузырьком - O(1) дополнительной памяти
function bubbleSort(arr) {
    // Только несколько переменных для индексов и временного хранения
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

// Быстрая сортировка - O(log n) дополнительной памяти (из-за рекурсии)
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);    // Рекурсивный вызов
        quickSort(arr, pi + 1, high);   // Рекурсивный вызов
    }
    return arr;
}

// Сортировка слиянием - O(n) дополнительной памяти
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));   // O(n/2) дополнительной памяти
    const right = mergeSort(arr.slice(mid));     // O(n/2) дополнительной памяти
    
    // Дополнительная память для результата
    return merge(left, right);
}
```

### 2. Алгоритмы поиска

```javascript
// Бинарный поиск - O(1) дополнительной памяти (итеративный)
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Бинарный поиск - O(log n) дополнительной памяти (рекурсивный)
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
    if (left > right) {
        return -1;
    }
    
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);  // Рекурсивный вызов
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);   // Рекурсивный вызов
    }
}
```

### 3. Работа с деревьями

```javascript
// Обход дерева в глубину - O(h) дополнительной памяти, где h - высота дерева
function dfs(root, visitFn) {
    if (!root) return;
    
    visitFn(root.value);
    
    for (const child of root.children) {
        dfs(child, visitFn);  // Рекурсивный вызов, стек растет с глубиной
    }
}

// Обход дерева в ширину - O(w) дополнительной памяти, где w - максимальная ширина дерева
function bfs(root, visitFn) {
    if (!root) return;
    
    const queue = [root];  // Очередь может содержать до w узлов
    
    while (queue.length > 0) {
        const node = queue.shift();
        visitFn(node.value);
        
        for (const child of node.children) {
            queue.push(child);
        }
    }
}
```

## Практические примеры в фронтенде

### 1. Управление памятью в приложениях

```javascript
class MemoryEfficientDataProcessor {
    constructor(maxCacheSize = 1000) {
        this.cache = new Map();
        this.maxCacheSize = maxCacheSize;
    }
    
    // Обработка данных с ограничением по памяти
    processLargeDataset(data, processorFn) {
        const results = [];
        
        for (let i = 0; i < data.length; i++) {
            // Обрабатываем данные порциями, чтобы не перегружать память
            const chunk = data[i];
            const result = processorFn(chunk);
            
            results.push(result);
            
            // Ограничиваем размер результата, если нужно
            if (results.length > this.maxCacheSize) {
                // Очищаем кэш или используем другие стратегии
                this.cleanup();
                break;
            }
        }
        
        return results;
    }
    
    // Очистка устаревших данных
    cleanup() {
        if (this.cache.size > this.maxCacheSize) {
            // Удаляем половину старейших записей
            const keys = Array.from(this.cache.keys());
            const toDelete = Math.floor(keys.length / 2);
            
            for (let i = 0; i < toDelete; i++) {
                this.cache.delete(keys[i]);
            }
        }
    }
    
    // Ленивая загрузка данных
    lazyLoadData(key, loaderFn) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        const data = loaderFn();
        this.cache.set(key, data);
        
        // Очистка при переполнении
        if (this.cache.size > this.maxCacheSize) {
            this.cleanup();
        }
        
        return data;
    }
}

// Пример использования
const processor = new MemoryEfficientDataProcessor(500);
const largeDataset = Array.from({ length: 10000 }, (_, i) => ({ id: i, value: Math.random() }));

const results = processor.processLargeDataset(
    largeDataset,
    (item) => ({ ...item, processed: true, doubled: item.value * 2 })
);
```

### 2. Оптимизация рендеринга списков

```javascript
class VirtualList {
    constructor(items, container, itemHeight = 50) {
        this.items = items;
        this.container = container;
        this.itemHeight = itemHeight;
        this.visibleStart = 0;
        this.visibleEnd = 0;
        this.renderedItems = new Map(); // Кэш отрендеренных элементов
    }
    
    // Рассчитываем количество видимых элементов
    calculateVisibleRange() {
        const containerHeight = this.container.clientHeight;
        const scrollTop = this.container.scrollTop;
        
        this.visibleStart = Math.floor(scrollTop / this.itemHeight);
        this.visibleEnd = Math.min(
            this.visibleStart + Math.ceil(containerHeight / this.itemHeight) + 5, // +5 для буфера
            this.items.length
        );
    }
    
    // Рендерим только видимые элементы
    render() {
        this.calculateVisibleRange();
        
        // Удаляем невидимые элементы из DOM
        for (const [index, element] of this.renderedItems) {
            if (index < this.visibleStart || index >= this.visibleEnd) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                    this.renderedItems.delete(index);
                }
            }
        }
        
        // Добавляем видимые элементы
        for (let i = this.visibleStart; i < this.visibleEnd; i++) {
            if (!this.renderedItems.has(i)) {
                const element = this.createItemElement(this.items[i], i);
                element.style.position = 'absolute';
                element.style.top = `${i * this.itemHeight}px`;
                this.container.appendChild(element);
                this.renderedItems.set(i, element);
            }
        }
        
        // Устанавливаем высоту контейнера для правильной прокрутки
        this.container.style.height = `${this.items.length * this.itemHeight}px`;
    }
    
    createItemElement(item, index) {
        const element = document.createElement('div');
        element.className = 'virtual-list-item';
        element.textContent = `Item ${index}: ${typeof item === 'object' ? JSON.stringify(item) : item}`;
        return element;
    }
    
    // Очистка памяти
    destroy() {
        this.renderedItems.clear();
        this.container.innerHTML = '';
    }
}

// Пример использования
// const container = document.getElementById('list-container');
// const largeList = Array.from({ length: 100000 }, (_, i) => `Item ${i}`);
// const virtualList = new VirtualList(largeList, container);
```

### 3. Управление кэшем изображений

```javascript
class ImageCacheManager {
    constructor(maxCacheSize = 50 * 1024 * 1024) { // 50 MB
        this.cache = new Map();
        this.size = 0;
        this.maxSize = maxCacheSize;
    }
    
    // Загрузка и кэширование изображения
    async loadImage(src) {
        // Проверяем, есть ли изображение в кэше
        if (this.cache.has(src)) {
            return this.cache.get(src);
        }
        
        // Загружаем изображение
        const img = new Image();
        const promise = new Promise((resolve, reject) => {
            img.onload = () => {
                // Оцениваем приблизительный размер в байтах
                const sizeEstimate = this.estimateImageSize(img);
                
                // Проверяем, уместится ли в кэш
                if (this.size + sizeEstimate > this.maxSize) {
                    this.cleanup(sizeEstimate);
                }
                
                this.cache.set(src, img);
                this.size += sizeEstimate;
                resolve(img);
            };
            
            img.onerror = reject;
        });
        
        img.src = src;
        return promise;
    }
    
    // Оценка размера изображения
    estimateImageSize(img) {
        // Приблизительная оценка: ширина * высота * 4 байта (RGBA)
        return img.width * img.height * 4;
    }
    
    // Очистка кэша по LRU (Least Recently Used)
    cleanup(neededSize = 0) {
        const entries = Array.from(this.cache.entries());
        // Сортируем по времени последнего использования (в реальном приложении нужно отслеживать это)
        
        let freedSize = 0;
        const toKeep = [];
        
        // Удаляем старые элементы, пока не освободим достаточно места
        for (let i = 0; i < entries.length && freedSize < neededSize; i++) {
            const [src, img] = entries[i];
            const size = this.estimateImageSize(img);
            freedSize += size;
            this.cache.delete(src);
            this.size -= size;
        }
    }
    
    // Очистка всех данных
    clear() {
        this.cache.clear();
        this.size = 0;
    }
    
    // Получение статистики
    getStats() {
        return {
            cachedItems: this.cache.size,
            currentSize: this.size,
            maxSize: this.maxSize,
            usagePercent: (this.size / this.maxSize) * 100
        };
    }
}

// Пример использования
const imageCache = new ImageCacheManager();
// await imageCache.loadImage('https://example.com/image.jpg');
```

### 4. Работа с большими JSON-данными

```javascript
class JSONStreamProcessor {
    // Обработка JSON-данных частями для экономии памяти
    static async processLargeJSON(jsonUrl, chunkProcessor, chunkSize = 1000) {
        const response = await fetch(jsonUrl);
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        let buffer = '';
        let arrayStarted = false;
        let objectCount = 0;
        let currentObject = '';
        let braceCount = 0;
        
        while (true) {
            const { done, value } = await reader.read();
            
            if (done) break;
            
            buffer += decoder.decode(value, { stream: true });
            
            // Обработка потока JSON
            for (let i = 0; i < buffer.length; i++) {
                const char = buffer[i];
                
                if (char === '[' && !arrayStarted) {
                    arrayStarted = true;
                } else if (char === '{' && arrayStarted) {
                    if (braceCount === 0) {
                        currentObject = '';
                    }
                    braceCount++;
                } else if (char === '}' && arrayStarted) {
                    currentObject += char;
                    braceCount--;
                    
                    if (braceCount === 0) {
                        // Завершен один объект
                        try {
                            const parsed = JSON.parse(currentObject);
                            await chunkProcessor(parsed);
                            objectCount++;
                            
                            // Очищаем память периодически
                            if (objectCount % chunkSize === 0) {
                                // Даем браузеру время на сборку мусора
                                await new Promise(resolve => setTimeout(resolve, 0));
                            }
                        } catch (e) {
                            console.error('Error parsing JSON object:', e);
                        }
                    }
                } else if (braceCount > 0) {
                    currentObject += char;
                }
            }
            
            // Сохраняем необработанные данные
            if (braceCount > 0) {
                buffer = currentObject;
            } else {
                buffer = '';
            }
        }
    }
    
    // Альтернативный метод: обработка файла частями
    static processJSONFileInChunks(file, chunkProcessor, chunkSize = 1024 * 1024) { // 1MB chunks
        return new Promise((resolve, reject) => {
            const fileSize = file.size;
            let offset = 0;
            
            const processChunk = () => {
                if (offset >= fileSize) {
                    resolve();
                    return;
                }
                
                const chunk = file.slice(offset, offset + chunkSize);
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        // Обрабатываем кусок
                        await chunkProcessor(e.target.result);
                        offset += chunkSize;
                        
                        // Рекурсивный вызов для следующего куска
                        setTimeout(processChunk, 0); // Даем браузеру "дышать"
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(reader.error);
                reader.readAsText(chunk);
            };
            
            processChunk();
        });
    }
}

// Пример использования
// const dataProcessor = (chunk) => {
//     console.log('Обработан объект:', chunk);
//     // Обработка отдельного объекта
// };
// 
// await JSONStreamProcessor.processLargeJSON('large-data.json', dataProcessor);
```

## Паттерны оптимизации памяти

### 1. Пул объектов

```javascript
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 10) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        
        // Создаем начальные объекты
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }
    
    acquire() {
        if (this.pool.length > 0) {
            return this.pool.pop();
        }
        // Если пул пуст, создаем новый объект
        return this.createFn();
    }
    
    release(obj) {
        this.resetFn(obj);
        this.pool.push(obj);
    }
    
    getStats() {
        return {
            total: this.pool.length,
            available: this.pool.length
        };
    }
}

// Пример использования для DOM-элементов
const divPool = new ObjectPool(
    () => document.createElement('div'), // createFn
    (div) => { div.className = ''; div.textContent = ''; } // resetFn
);

// Получаем элемент из пула
const element = divPool.acquire();
element.className = 'my-class';
element.textContent = 'Hello World';

// Возвращаем элемент в пул
divPool.release(element);
```

### 2. Lazy Loading

```javascript
class LazyLoader {
    constructor(loaderFn) {
        this.loaderFn = loaderFn;
        this.loaded = false;
        this.data = null;
    }
    
    async get() {
        if (!this.loaded) {
            this.data = await this.loaderFn();
            this.loaded = true;
        }
        return this.data;
    }
    
    isLoaded() {
        return this.loaded;
    }
    
    clear() {
        this.loaded = false;
        this.data = null;
    }
}

// Пример использования
const userProfileLoader = new LazyLoader(async () => {
    const response = await fetch('/api/user/profile');
    return response.json();
});

// Данные загружаются только при первом обращении
// const profile = await userProfileLoader.get();
```

## Инструменты анализа памяти

### 1. Мониторинг использования памяти

```javascript
class MemoryMonitor {
    static getMemoryInfo() {
        if (performance.memory) {
            return {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit,
                usagePercent: (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100
            };
        }
        return null;
    }
    
    static logMemoryUsage(label = 'Memory Usage') {
        const info = this.getMemoryInfo();
        if (info) {
            console.log(`${label}: ${Math.round(info.used / 1024 / 1024)}MB / ${Math.round(info.limit / 1024 / 1024)}MB (${info.usagePercent.toFixed(2)}%)`);
        }
    }
    
    static async detectMemoryLeak(thresholdMB = 50) {
        const initial = this.getMemoryInfo();
        if (!initial) return false;
        
        // Ждем немного, затем проверяем снова
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        const current = this.getMemoryInfo();
        if (current && (current.used - initial.used) > (thresholdMB * 1024 * 1024)) {
            console.warn(`Potential memory leak detected: ${Math.round((current.used - initial.used) / 1024 / 1024)}MB increase`);
            return true;
        }
        
        return false;
    }
}

// Использование
MemoryMonitor.logMemoryUsage('Before operation');
// ... выполнение операции ...
MemoryMonitor.logMemoryUsage('After operation');
```

## Заключение

Понимание сложности по памяти критически важно для создания эффективных фронтенд-приложений. В условиях ограниченных ресурсов браузера и разнообразия устройств, на которых запускаются веб-приложения, оптимизация использования памяти может значительно улучшить производительность и пользовательский опыт.

При разработке приложений всегда стоит учитывать:
- Сколько памяти будет использоваться при различных сценариях использования
- Как приложение будет вести себя с большими наборами данных
- Какие стратегии очистки памяти реализованы
- Как избежать утечек памяти

Эффективное управление памятью особенно важно при работе с большими списками, изображениями, видео, а также в приложениях реального времени.

См. также: [[Алгоритмы-сортировки]], [[Динамическое-программирование]], [[Хеширование]]