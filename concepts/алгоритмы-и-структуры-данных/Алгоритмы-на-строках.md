---
aliases: [Строковые алгоритмы, Алгоритмы на строках, Обработка строк]
tags: [programming, algorithms, strings, frontend]
---

# Алгоритмы-на-строках

## Обзор

Алгоритмы на строках — это методы обработки и анализа текстовых данных. В контексте фронтенд-разработки они особенно важны для задач валидации ввода, поиска по тексту, обработки пользовательских данных, реализации функций автодополнения и других текстовых операций.

## Важность в фронтенд-разработке

Алгоритмы на строках критически важны для:
- Валидации пользовательского ввода (email, телефон, форматы)
- Реализации поисковых функций
- Обработки текста пользователем
- Автодополнения и подсветки синтаксиса
- Оптимизации отображения текста

## Основные алгоритмы на строках

### 1. Поиск подстроки

#### Наивный алгоритм поиска подстроки

```javascript
function naiveStringSearch(text, pattern) {
    const textLen = text.length;
    const patternLen = pattern.length;
    const results = [];
    
    for (let i = 0; i <= textLen - patternLen; i++) {
        let j;
        for (j = 0; j < patternLen; j++) {
            if (text[i + j] !== pattern[j]) {
                break;
            }
        }
        if (j === patternLen) {
            results.push(i); // Сохраняем индекс начала найденной подстроки
        }
    }
    return results;
}

// Пример использования
const text = "Привет, это тестовая строка для поиска. Это тест.";
const pattern = "тест";
console.log(naiveStringSearch(text, pattern)); // [12, 42]
```

#### Алгоритм Кнута-Морриса-Пратта (KMP)

```javascript
function kmpSearch(text, pattern) {
    const lps = buildLPSArray(pattern);
    const textLen = text.length;
    const patternLen = pattern.length;
    const results = [];
    
    let i = 0; // Индекс для text
    let j = 0; // Индекс для pattern
    
    while (i < textLen) {
        if (pattern[j] === text[i]) {
            i++;
            j++;
        }
        
        if (j === patternLen) {
            results.push(i - j); // Найдено совпадение
            j = lps[j - 1];
        } else if (i < textLen && pattern[j] !== text[i]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return results;
}

function buildLPSArray(pattern) {
    const len = pattern.length;
    const lps = new Array(len);
    let length = 0;
    let i = 1;
    
    lps[0] = 0;
    
    while (i < len) {
        if (pattern[i] === pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length !== 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

// Пример использования
const text = "ABABDABACDABABCABCABCABCABC";
const pattern = "ABABCABCAB";
console.log(kmpSearch(text, pattern)); // [10]
```

### 2. Алгоритм Бойера-Мура

Более эффективный алгоритм для поиска подстроки, особенно при длинных образцах.

```javascript
function boyerMooreSearch(text, pattern) {
    const textLen = text.length;
    const patternLen = pattern.length;
    const results = [];
    
    // Создаем таблицу смещений
    const badChar = buildBadCharTable(pattern);
    
    let shift = 0; // Сдвиг образца относительно текста
    
    while (shift <= textLen - patternLen) {
        let j = patternLen - 1;
        
        // Пока символы совпадают, смещаемся к началу образца
        while (j >= 0 && pattern[j] === text[shift + j]) {
            j--;
        }
        
        // Если образец полностью совпал, сохраняем позицию
        if (j < 0) {
            results.push(shift);
            // Сдвигаем на величину, определенную таблицей плохого символа
            shift += (shift + patternLen < textLen) ? 
                     patternLen - badChar[text[shift + patternLen].charCodeAt(0)] : 1;
        } else {
            // Сдвигаем на основе таблицы плохого символа
            shift += Math.max(1, j - badChar[text[shift + j].charCodeAt(0)]);
        }
    }
    
    return results;
}

function buildBadCharTable(pattern) {
    const NO_OF_CHARS = 256;
    const badChar = new Array(NO_OF_CHARS).fill(-1);
    
    for (let i = 0; i < pattern.length; i++) {
        badChar[pattern[i].charCodeAt(0)] = i;
    }
    
    return badChar;
}

// Пример использования
const text = "ABAAABCD";
const pattern = "ABC";
console.log(boyerMooreSearch(text, pattern)); // [4]
```

### 3. Алгоритм Рабина-Карпа

Алгоритм поиска подстроки, использующий хеширование для быстрого сравнения.

```javascript
function rabinKarpSearch(text, pattern, prime = 101) {
    const textLen = text.length;
    const patternLen = pattern.length;
    const results = [];
    
    if (patternLen > textLen) return results;
    
    const d = 256; // количество символов в алфавите
    let h = 1;
    let pHash = 0; // хеш образца
    let tHash = 0; // хеш текста
    
    // Вычисляем h = pow(d, patternLen-1) % prime
    for (let i = 0; i < patternLen - 1; i++) {
        h = (h * d) % prime;
    }
    
    // Вычисляем хеши образца и первого окна текста
    for (let i = 0; i < patternLen; i++) {
        pHash = (d * pHash + pattern[i].charCodeAt(0)) % prime;
        tHash = (d * tHash + text[i].charCodeAt(0)) % prime;
    }
    
    // Скользящее окно по тексту
    for (let i = 0; i <= textLen - patternLen; i++) {
        // Если хеши совпадают, проверяем символы один за другим
        if (pHash === tHash) {
            let match = true;
            for (let j = 0; j < patternLen; j++) {
                if (text[i + j] !== pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                results.push(i);
            }
        }
        
        // Вычисляем хеш для следующего окна текста
        if (i < textLen - patternLen) {
            tHash = (d * (tHash - text[i].charCodeAt(0) * h) + text[i + patternLen].charCodeAt(0)) % prime;
            
            // Обрабатываем отрицательные значения
            if (tHash < 0) {
                tHash = (tHash + prime);
            }
        }
    }
    
    return results;
}

// Пример использования
const text = "GEEKS FOR GEEKS";
const pattern = "GEEK";
console.log(rabinKarpSearch(text, pattern)); // [0, 10]
```

## Операции с строками

### 1. Проверка анаграммы

```javascript
function areAnagrams(str1, str2) {
    // Удаляем пробелы и приводим к нижнему регистру
    str1 = str1.replace(/\s+/g, '').toLowerCase();
    str2 = str2.replace(/\s+/g, '').toLowerCase();
    
    if (str1.length !== str2.length) {
        return false;
    }
    
    // Сортируем символы и сравниваем
    return str1.split('').sort().join('') === str2.split('').sort().join('');
}

// Пример использования
console.log(areAnagrams("listen", "silent")); // true
console.log(areAnagrams("hello", "world")); // false
console.log(areAnagrams("The Eyes", "They See")); // true
```

### 2. Проверка палиндрома

```javascript
function isPalindrome(str) {
    // Удаляем все символы, кроме букв и цифр, и приводим к нижнему регистру
    const cleanStr = str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    
    let left = 0;
    let right = cleanStr.length - 1;
    
    while (left < right) {
        if (cleanStr[left] !== cleanStr[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Пример использования
console.log(isPalindrome("A man, a plan, a canal: Panama")); // true
console.log(isPalindrome("race a car")); // false
console.log(isPalindrome("Was it a car or a cat I saw?")); // true
```

### 3. Наибольшая общая подпоследовательность (LCS)

```javascript
function longestCommonSubsequence(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Создаем таблицу для динамического программирования
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Восстанавливаем саму подпоследовательность
    let lcs = '';
    let i = m, j = n;
    
    while (i > 0 && j > 0) {
        if (str1[i - 1] === str2[j - 1]) {
            lcs = str1[i - 1] + lcs;
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return lcs;
}

// Пример использования
console.log(longestCommonSubsequence("ABCDGH", "AEDFHR")); // "ADH"
console.log(longestCommonSubsequence("AGGTAB", "GXTXAYB")); // "GTAB"
```

### 4. Расстояние Левенштейна (редакционное расстояние)

```javascript
function levenshteinDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // Создаем таблицу для динамического программирования
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Инициализация первой строки и столбца
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    
    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]; // символы совпадают
            } else {
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,      // удаление
                    dp[i][j - 1] + 1,      // вставка
                    dp[i - 1][j - 1] + 1   // замена
                );
            }
        }
    }
    
    return dp[m][n];
}

// Пример использования
console.log(levenshteinDistance("kitten", "sitting")); // 3
console.log(levenshteinDistance("hello", "world")); // 4
console.log(levenshteinDistance("algorithm", "logarithm")); // 3
```

## Практические примеры в фронтенде

### 1. Валидация email

```javascript
function validateEmail(email) {
    // Проверяем основной формат email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailRegex.test(email)) {
        return false;
    }
    
    // Дополнительные проверки
    const parts = email.split('@');
    if (parts[0].length > 64 || parts[1].length > 253) {
        return false; // Проверка длины частей
    }
    
    return true;
}

// Пример использования
console.log(validateEmail("user@example.com")); // true
console.log(validateEmail("invalid.email")); // false
```

### 2. Поиск с подсветкой совпадений

```javascript
function highlightMatches(text, searchTerm) {
    if (!searchTerm) return text;
    
    const regex = new RegExp(`(${searchTerm})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
}

// Пример использования
const text = "JavaScript - это мощный язык программирования";
const highlighted = highlightMatches(text, "JavaScript");
console.log(highlighted); 
// "<mark>JavaScript</mark> - это мощный язык программирования"
```

### 3. Автодополнение с подсветкой

```javascript
class AutoCompleteWithHighlight {
    constructor(data) {
        this.data = data;
    }
    
    searchAndHighlight(prefix) {
        const lowerPrefix = prefix.toLowerCase();
        return this.data
            .filter(item => item.toLowerCase().includes(lowerPrefix))
            .slice(0, 5)
            .map(item => {
                // Подсвечиваем совпадающую часть
                const regex = new RegExp(`(${prefix})`, 'gi');
                const highlighted = item.replace(regex, '<mark>$1</mark>');
                return { original: item, highlighted };
            });
    }
}

// Пример использования
const autoComplete = new AutoCompleteWithHighlight([
    "JavaScript", "Java", "Python", "C++", "Ruby", 
    "Rust", "Go", "TypeScript", "Swift", "Kotlin"
]);

console.log(autoComplete.searchAndHighlight("Java"));
// [{ original: "JavaScript", highlighted: "<mark>Java</mark>Script" }, 
//  { original: "Java", highlighted: "<mark>Java</mark>" }]
```

### 4. Поиск с нечетким совпадением

```javascript
function fuzzySearch(text, pattern) {
    let textIndex = 0;
    let patternIndex = 0;
    
    while (textIndex < text.length && patternIndex < pattern.length) {
        if (text[textIndex].toLowerCase() === pattern[patternIndex].toLowerCase()) {
            patternIndex++;
        }
        textIndex++;
    }
    
    return patternIndex === pattern.length;
}

// Более сложная реализация с оценкой качества совпадения
function fuzzySearchWithScore(text, pattern) {
    const textLower = text.toLowerCase();
    const patternLower = pattern.toLowerCase();
    
    let textIndex = 0;
    let patternIndex = 0;
    let matches = 0;
    let consecutiveMatches = 0;
    let maxConsecutiveMatches = 0;
    
    while (textIndex < textLower.length && patternIndex < patternLower.length) {
        if (textLower[textIndex] === patternLower[patternIndex]) {
            matches++;
            consecutiveMatches++;
            patternIndex++;
            
            if (consecutiveMatches > maxConsecutiveMatches) {
                maxConsecutiveMatches = consecutiveMatches;
            }
        } else {
            consecutiveMatches = 0;
        }
        textIndex++;
    }
    
    // Возвращаем оценку соответствия
    if (patternIndex === patternLower.length) {
        const matchRatio = matches / pattern.length;
        const consecutiveBonus = maxConsecutiveMatches > 0 ? maxConsecutiveMatches * 0.1 : 0;
        return Math.min(1, matchRatio + consecutiveBonus);
    }
    
    return 0;
}

// Пример использования
const candidates = ["JavaScript", "TypeScript", "Java", "Python", "C++"];
const searchTerm = "js";

const results = candidates
    .map(item => ({
        text: item,
        score: fuzzySearchWithScore(item, searchTerm)
    }))
    .filter(item => item.score > 0)
    .sort((a, b) => b.score - a.score);

console.log(results);
```

### 5. Токенизация строк

```javascript
class StringTokenizer {
    static tokenize(text, options = {}) {
        const {
            separators = /\s+/g,
            includeSeparators = false,
            preserveCase = false
        } = options;
        
        if (!preserveCase) {
            text = text.toLowerCase();
        }
        
        const tokens = [];
        let lastIndex = 0;
        
        let match;
        while ((match = separators.exec(text)) !== null) {
            const token = text.slice(lastIndex, match.index);
            if (token) {
                tokens.push(token);
            }
            
            if (includeSeparators) {
                tokens.push(match[0]);
            }
            
            lastIndex = match.index + match[0].length;
        }
        
        // Добавляем последний токен
        const lastToken = text.slice(lastIndex);
        if (lastToken) {
            tokens.push(lastToken);
        }
        
        return tokens.filter(token => token.trim() !== '');
    }
    
    // Токенизация для поиска
    static tokenizeForSearch(text) {
        // Разбиваем по пробелам и знакам препинания
        return text
            .toLowerCase()
            .split(/[^\wа-яё]/gi)
            .filter(token => token.length > 0);
    }
}

// Пример использования
const text = "JavaScript - это мощный язык программирования!";
console.log(StringTokenizer.tokenize(text)); // ['javascript', 'это', 'мощный', 'язык', 'программирования']
console.log(StringTokenizer.tokenizeForSearch(text)); // ['javascript', 'это', 'мощный', 'язык', 'программирования']
```

## Сравнение алгоритмов

| Алгоритм | Сложность времени | Сложность памяти | Применение |
|----------|-------------------|------------------|------------|
| Наивный поиск | O(n*m) | O(1) | Простые случаи, короткие строки |
| KMP | O(n+m) | O(m) | Поиск с повторяющимися шаблонами |
| Бойер-Мур | O(n*m) в худшем, O(n/m) в среднем | O(m) | Длинные шаблоны, хорошие алфавиты |
| Рабин-Карп | O(n*m) в худшем, O(n+m) в среднем | O(1) | Поиск нескольких шаблонов |

## Заключение

Алгоритмы на строках играют важную роль в фронтенд-разработке, особенно при работе с пользовательским вводом, поиском по тексту и валидацией данных. Понимание этих алгоритмов позволяет создавать более эффективные и удобные интерфейсы. В реальных приложениях часто используются комбинации различных подходов для достижения оптимальной производительности и пользовательского опыта.

См. также: [[Алгоритмы-поиска]], [[Хеширование]], [[Алгоритмы-на-массивах]]