---
aliases: ["Trees", "Graphs", "Binary Tree", "Binary Search Tree", "DOM Tree"]
tags: ["#алгоритмы", "#структуры-данных", "#деревья", "#графы", "#javascript", "#dom"]
---

# Деревья и графы

## Общее описание

Деревья и графы - это нелинейные структуры данных, которые позволяют моделировать иерархические и сетевые отношения между элементами. Эти структуры особенно важны для фронтенд-разработчиков, поскольку DOM (Document Object Model) представляет собой дерево, а многие алгоритмы обхода и поиска используют графовые структуры.

## Деревья

Дерево - это иерархическая структура данных, состоящая из узлов, где один узел является корнем, а остальные узлы разделены на непересекающиеся поддеревья. Каждый узел может иметь ноль или более дочерних узлов.

### Основные термины:

- **Корень (Root)**: верхний узел дерева
- **Лист (Leaf)**: узел без дочерних элементов
- **Родитель (Parent)**: узел, имеющий дочерние узлы
- **Дочерний узел (Child)**: узел, находящийся под другим узлом
- **Глубина (Depth)**: расстояние от корня до узла
- **Высота (Height)**: максимальное расстояние от узла до листа

### Бинарное дерево

В бинарном дереве каждый узел имеет не более двух дочерних узлов (левый и правый).

```javascript
// Реализация узла бинарного дерева
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// Пример бинарного дерева
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
```

### Бинарное дерево поиска (BST)

BST - это бинарное дерево, в котором для каждого узла выполняются следующие условия:
- Значение левого поддерева меньше значения узла
- Значение правого поддерева больше значения узла
- Оба поддерева также являются BST

```javascript
class BinarySearchTree {
    constructor() {
        this.root = null;
    }

    // Вставка элемента - O(log n) для сбалансированного дерева
    insert(val) {
        this.root = this.insertNode(this.root, val);
    }

    insertNode(node, val) {
        if (node === null) {
            return new TreeNode(val);
        }

        if (val < node.val) {
            node.left = this.insertNode(node.left, val);
        } else if (val > node.val) {
            node.right = this.insertNode(node.right, val);
        }

        return node;
    }

    // Поиск элемента - O(log n) для сбалансированного дерева
    search(val) {
        return this.searchNode(this.root, val);
    }

    searchNode(node, val) {
        if (node === null || node.val === val) {
            return node;
        }

        if (val < node.val) {
            return this.searchNode(node.left, val);
        } else {
            return this.searchNode(node.right, val);
        }
    }

    // Удаление элемента
    remove(val) {
        this.root = this.removeNode(this.root, val);
    }

    removeNode(node, val) {
        if (node === null) {
            return null;
        }

        if (val < node.val) {
            node.left = this.removeNode(node.left, val);
            return node;
        } else if (val > node.val) {
            node.right = this.removeNode(node.right, val);
            return node;
        } else {
            // Узел найден
            if (node.left === null && node.right === null) {
                // Лист
                return null;
            } else if (node.left === null) {
                // Только правое поддерево
                return node.right;
            } else if (node.right === null) {
                // Только левое поддерево
                return node.left;
            } else {
                // Два дочерних узла
                const minRight = this.findMin(node.right);
                node.val = minRight.val;
                node.right = this.removeNode(node.right, minRight.val);
                return node;
            }
        }
    }

    findMin(node) {
        while (node.left !== null) {
            node = node.left;
        }
        return node;
    }
}
```

### Обход дерева

Существует несколько способов обхода дерева:

```javascript
class TreeTraversal {
    // Прямой обход (Pre-order): корень -> левый -> правый
    preOrder(root, result = []) {
        if (root !== null) {
            result.push(root.val);
            this.preOrder(root.left, result);
            this.preOrder(root.right, result);
        }
        return result;
    }

    // Центральный обход (In-order): левый -> корень -> правый
    inOrder(root, result = []) {
        if (root !== null) {
            this.inOrder(root.left, result);
            result.push(root.val);
            this.inOrder(root.right, result);
        }
        return result;
    }

    // Обратный обход (Post-order): левый -> правый -> корень
    postOrder(root, result = []) {
        if (root !== null) {
            this.postOrder(root.left, result);
            this.postOrder(root.right, result);
            result.push(root.val);
        }
        return result;
    }

    // Обход в ширину (BFS)
    bfs(root) {
        if (root === null) return [];
        
        const result = [];
        const queue = [root];
        
        while (queue.length > 0) {
            const node = queue.shift();
            result.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        return result;
    }
}
```

## Графы

Граф - это структура данных, состоящая из узлов (вершин) и соединений между ними (ребер). В отличие от деревьев, графы могут содержать циклы и не имеют иерархической структуры.

### Представление графов

```javascript
// Список смежности
class Graph {
    constructor() {
        this.adjacencyList = new Map();
    }

    // Добавление вершины
    addVertex(vertex) {
        if (!this.adjacencyList.has(vertex)) {
            this.adjacencyList.set(vertex, []);
        }
    }

    // Добавление ребра (для неориентированного графа)
    addEdge(vertex1, vertex2) {
        if (!this.adjacencyList.has(vertex1)) {
            this.addVertex(vertex1);
        }
        if (!this.adjacencyList.has(vertex2)) {
            this.addVertex(vertex2);
        }
        
        this.adjacencyList.get(vertex1).push(vertex2);
        this.adjacencyList.get(vertex2).push(vertex1);
    }

    // Добавление ребра (для ориентированного графа)
    addDirectedEdge(from, to) {
        if (!this.adjacencyList.has(from)) {
            this.addVertex(from);
        }
        if (!this.adjacencyList.has(to)) {
            this.addVertex(to);
        }
        
        this.adjacencyList.get(from).push(to);
    }

    // Удаление ребра
    removeEdge(vertex1, vertex2) {
        if (this.adjacencyList.has(vertex1)) {
            this.adjacencyList.set(
                vertex1, 
                this.adjacencyList.get(vertex1).filter(v => v !== vertex2)
            );
        }
        if (this.adjacencyList.has(vertex2)) {
            this.adjacencyList.set(
                vertex2, 
                this.adjacencyList.get(vertex2).filter(v => v !== vertex1)
            );
        }
    }

    // Удаление вершины
    removeVertex(vertex) {
        if (!this.adjacencyList.has(vertex)) {
            return;
        }
        
        // Удаляем все ребра, связанные с этой вершиной
        while (this.adjacencyList.get(vertex).length) {
            const adjacentVertex = this.adjacencyList.get(vertex).pop();
            this.removeEdge(vertex, adjacentVertex);
        }
        
        // Удаляем саму вершину
        this.adjacencyList.delete(vertex);
    }
}
```

### Обход графа

```javascript
class GraphTraversal {
    // Поиск в глубину (DFS)
    dfs(startVertex) {
        const visited = new Set();
        const result = [];
        
        const dfsHelper = (vertex) => {
            visited.add(vertex);
            result.push(vertex);
            
            const neighbors = this.adjacencyList.get(vertex) || [];
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    dfsHelper(neighbor);
                }
            }
        };
        
        dfsHelper(startVertex);
        return result;
    }

    // Поиск в ширину (BFS)
    bfs(startVertex) {
        const visited = new Set();
        const queue = [startVertex];
        const result = [];
        
        visited.add(startVertex);
        
        while (queue.length > 0) {
            const vertex = queue.shift();
            result.push(vertex);
            
            const neighbors = this.adjacencyList.get(vertex) || [];
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        
        return result;
    }
}
```

## Применение в фронтенд-разработке

### DOM как дерево

DOM - это древовидная структура, где HTML-элементы представлены в виде узлов дерева:

```javascript
// Пример работы с DOM-деревом
class DOMTreeAnalyzer {
    // Поиск всех потомков элемента
    findAllDescendants(element) {
        const descendants = [];
        
        const traverse = (node) => {
            for (let child of node.children) {
                descendants.push(child);
                traverse(child); // Рекурсивный обход
            }
        };
        
        traverse(element);
        return descendants;
    }

    // Поиск пути от элемента к корню
    getPathToRoot(element) {
        const path = [];
        let current = element;
        
        while (current && current !== document) {
            path.unshift(current); // Добавляем в начало массива
            current = current.parentElement;
        }
        
        return path;
    }

    // Поиск ближайшего родительского элемента по селектору
    findClosestAncestor(element, selector) {
        let current = element.parentElement;
        
        while (current) {
            if (current.matches(selector)) {
                return current;
            }
            current = current.parentElement;
        }
        
        return null;
    }
}
```

### Оптимизация рендеринга с использованием деревьев

```javascript
// Пример виртуального дерева для оптимизации рендеринга
class VirtualDOMTree {
    constructor(tag, props = {}, children = []) {
        this.tag = tag;
        this.props = props;
        this.children = children;
    }

    // Создание реального DOM-элемента из виртуального
    createElement() {
        const element = document.createElement(this.tag);
        
        // Установка атрибутов
        Object.keys(this.props).forEach(key => {
            if (key.startsWith('on')) {
                // Обработчики событий
                const event = key.substring(2).toLowerCase();
                element.addEventListener(event, this.props[key]);
            } else {
                element.setAttribute(key, this.props[key]);
            }
        });
        
        // Добавление дочерних элементов
        this.children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            } else {
                element.appendChild(child.createElement());
            }
        });
        
        return element;
    }

    // Сравнение двух виртуальных деревьев
    static diff(oldTree, newTree) {
        const patches = [];
        
        // Сравнение узлов
        if (oldTree.tag !== newTree.tag) {
            patches.push({ type: 'REPLACE', node: newTree });
        } else if (oldTree.props !== newTree.props) {
            patches.push({ type: 'PROPS', props: newTree.props });
        }
        
        // Рекурсивное сравнение детей
        const maxLen = Math.max(
            oldTree.children.length, 
            newTree.children.length
        );
        
        for (let i = 0; i < maxLen; i++) {
            const oldChild = oldTree.children[i];
            const newChild = newTree.children[i];
            
            if (!oldChild && newChild) {
                patches.push({ type: 'INSERT', index: i, node: newChild });
            } else if (oldChild && !newChild) {
                patches.push({ type: 'REMOVE', index: i });
            } else if (oldChild && newChild) {
                const childPatches = VirtualDOMTree.diff(oldChild, newChild);
                if (childPatches.length > 0) {
                    patches.push({ type: 'CHILDREN', index: i, patches: childPatches });
                }
            }
        }
        
        return patches;
    }
}
```

### Управление зависимостями компонентов

```javascript
// Граф зависимостей компонентов
class ComponentDependencyGraph {
    constructor() {
        this.dependencies = new Map(); // компонент -> [зависимости]
        this.dependents = new Map();   // компонент -> [зависимые компоненты]
    }

    addComponent(componentName) {
        if (!this.dependencies.has(componentName)) {
            this.dependencies.set(componentName, new Set());
            this.dependents.set(componentName, new Set());
        }
    }

    addDependency(component, dependency) {
        this.addComponent(component);
        this.addComponent(dependency);
        
        this.dependencies.get(component).add(dependency);
        this.dependents.get(dependency).add(component);
    }

    // Получение топологической сортировки компонентов
    getTopologicalOrder() {
        const visited = new Set();
        const order = [];
        
        const dfs = (component) => {
            if (visited.has(component)) return;
            visited.add(component);
            
            const deps = this.dependencies.get(component) || [];
            for (const dep of deps) {
                dfs(dep);
            }
            
            order.push(component);
        };
        
        for (const component of this.dependencies.keys()) {
            dfs(component);
        }
        
        return order;
    }

    // Проверка на циклические зависимости
    hasCycles() {
        const visited = new Set();
        const recStack = new Set();
        
        const dfs = (component) => {
            if (!visited.has(component)) {
                visited.add(component);
                recStack.add(component);
                
                const deps = this.dependencies.get(component) || [];
                for (const dep of deps) {
                    if (!visited.has(dep) && dfs(dep)) {
                        return true;
                    } else if (recStack.has(dep)) {
                        return true;
                    }
                }
            }
            recStack.delete(component);
            return false;
        };
        
        for (const component of this.dependencies.keys()) {
            if (dfs(component)) {
                return true;
            }
        }
        
        return false;
    }
}
```

### Поиск кратчайшего пути в навигации

```javascript
// Граф для маршрутизации в приложении
class NavigationGraph {
    constructor() {
        this.graph = new Map();
    }

    addRoute(from, to, weight = 1) {
        if (!this.graph.has(from)) {
            this.graph.set(from, []);
        }
        this.graph.get(from).push({ to, weight });
    }

    // Алгоритм Дейкстры для поиска кратчайшего пути
    findShortestPath(start, end) {
        const distances = new Map();
        const previous = new Map();
        const unvisited = new Set();
        
        // Инициализация
        for (const node of this.graph.keys()) {
            distances.set(node, Infinity);
            unvisited.add(node);
        }
        distances.set(start, 0);
        
        while (unvisited.size > 0) {
            // Находим узел с минимальным расстоянием
            let current = null;
            let minDistance = Infinity;
            
            for (const node of unvisited) {
                const dist = distances.get(node);
                if (dist < minDistance) {
                    minDistance = dist;
                    current = node;
                }
            }
            
            // Если минимальное расстояние Infinity, пути нет
            if (current === null || current === end) {
                break;
            }
            
            unvisited.delete(current);
            
            // Обновляем расстояния до соседей
            const neighbors = this.graph.get(current) || [];
            for (const neighbor of neighbors) {
                const distance = distances.get(current) + neighbor.weight;
                if (distance < distances.get(neighbor.to)) {
                    distances.set(neighbor.to, distance);
                    previous.set(neighbor.to, current);
                }
            }
        }
        
        // Восстанавливаем путь
        const path = [];
        let current = end;
        
        while (current !== undefined) {
            path.unshift(current);
            current = previous.get(current);
        }
        
        return path.length > 0 && path[0] === start ? path : [];
    }
}
```

## Практические рекомендации для фронтенд-разработчиков

1. **Используйте древовидные структуры для представления иерархических данных** (например, меню, комментарии)
2. **Оптимизируйте обход DOM-дерева** - избегайте частого обхода, кэшируйте результаты
3. **Рассмотрите использование виртуальных деревьев** для оптимизации рендеринга (как в React)
4. **Используйте графы для моделирования зависимостей** между компонентами или модулями
5. **Применяйте алгоритмы обхода** для задач валидации, поиска и оптимизации

```javascript
// Плохо: частый обход DOM
function findElementsByClassBad(rootElement, className) {
    const elements = [];
    
    // Повторный обход для каждого поиска
    const traverse = (node) => {
        if (node.classList.contains(className)) {
            elements.push(node);
        }
        for (let child of node.children) {
            traverse(child);
        }
    };
    
    traverse(rootElement);
    return elements;
}

// Хорошо: однократный обход с кэшированием
class OptimizedDOMSearch {
    constructor(rootElement) {
        this.rootElement = rootElement;
        this.cache = new Map();
    }
    
    findElementsByClass(className) {
        if (this.cache.has(className)) {
            return this.cache.get(className);
        }
        
        const elements = [];
        const traverse = (node) => {
            if (node.classList.contains(className)) {
                elements.push(node);
            }
            for (let child of node.children) {
                traverse(child);
            }
        };
        
        traverse(this.rootElement);
        this.cache.set(className, elements);
        return elements;
    }
}
```

## Заключение

Деревья и графы являются мощными структурами данных, которые широко используются в фронтенд-разработке. DOM сам по себе является деревом, а графы полезны для моделирования сложных отношений между компонентами, зависимостями и маршрутами. Понимание этих структур и алгоритмов работы с ними позволяет создавать более эффективные и масштабируемые приложения.

См. также: [[Сложность-алгоритмов]], [[Списки-и-массивы]], [[Стеки-и-очереди]], [[Хэш-таблицы]], [[DOM-манипуляции]]