---
aliases: [Поиск, Алгоритмы поиска, Поисковые алгоритмы]
tags: [programming, algorithms, search, frontend]
---

# Алгоритмы-поиска

## Обзор

Алгоритмы поиска — это методы нахождения конкретного элемента или элементов в коллекции данных. В контексте фронтенд-разработки поиск используется повсеместно: поиск по спискам, фильтрация данных, автодополнение, поиск по таблицам и т.д.

## Важность в фронтенд-разработке

Поисковые алгоритмы критически важны для:
- Повышения пользовательского опыта через быстрый доступ к информации
- Эффективной фильтрации и поиска в больших наборах данных
- Реализации функций автодополнения и поиска
- Оптимизации производительности интерфейсов

## Основные алгоритмы поиска

### 1. Линейный поиск (Linear Search)

Самый простой алгоритм поиска, который проверяет каждый элемент в списке по очереди до тех пор, пока не найдет искомое значение.

```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Возвращаем индекс найденного элемента
        }
    }
    return -1; // Возвращаем -1, если элемент не найден
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(linearSearch(numbers, 22)); // 4
console.log(linearSearch(numbers, 100)); // -1
```

**Сложность:**
- Время: O(n) в худшем случае
- Память: O(1)

> [!tip] Применение в фронтенде
> Линейный поиск идеально подходит для небольших массивов или неотсортированных данных, например, при поиске элемента в небольшом списке пользователей или фильтрации по небольшому набору опций.

### 2. Бинарный поиск (Binary Search)

Эффективный алгоритм поиска в отсортированном массиве, который работает по принципу "разделяй и властвуй", каждый раз уменьшая область поиска вдвое.

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1; // Элемент не найден
}

// Пример использования
const sortedNumbers = [11, 12, 22, 25, 34, 64, 90];
console.log(binarySearch(sortedNumbers, 25)); // 3
console.log(binarySearch(sortedNumbers, 100)); // -1
```

**Сложность:**
- Время: O(log n)
- Память: O(1)

> [!warning] Важно
> Бинарный поиск работает только с отсортированными массивами. Если данные не отсортированы, сначала нужно их отсортировать, что добавит O(n log n) времени.

### 3. Интерполяционный поиск (Interpolation Search)

Улучшенная версия бинарного поиска для равномерно распределенных данных. Вместо того чтобы всегда проверять средний элемент, он вычисляет вероятное положение искомого элемента.

```javascript
function interpolationSearch(arr, target) {
    let low = 0;
    let high = arr.length - 1;
    
    while (low <= high && target >= arr[low] && target <= arr[high]) {
        if (low === high) {
            return arr[low] === target ? low : -1;
        }
        
        // Вычисляем позицию
        const pos = low + Math.floor(
            ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])
        );
        
        if (arr[pos] === target) {
            return pos;
        } else if (arr[pos] < target) {
            low = pos + 1;
        } else {
            high = pos - 1;
        }
    }
    
    return -1;
}

// Пример использования
const sortedNumbers = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47];
console.log(interpolationSearch(sortedNumbers, 18)); // 4
console.log(interpolationSearch(sortedNumbers, 100)); // -1
```

**Сложность:**
- Время: O(log log n) для равномерно распределенных данных, O(n) в худшем случае
- Память: O(1)

### 4. Экспоненциальный поиск (Exponential Search)

Полезен для неограниченных или очень больших массивов. Сначала находит диапазон, в котором может находиться искомый элемент, а затем применяет бинарный поиск.

```javascript
function exponentialSearch(arr, target) {
    if (arr[0] === target) {
        return 0;
    }
    
    let i = 1;
    while (i < arr.length && arr[i] <= target) {
        i *= 2;
    }
    
    // Применяем бинарный поиск в найденном диапазоне
    return binarySearchRange(arr, target, Math.floor(i/2), Math.min(i, arr.length - 1));
}

function binarySearchRange(arr, target, left, right) {
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Пример использования
const sortedNumbers = [2, 3, 4, 10, 40];
console.log(exponentialSearch(sortedNumbers, 10)); // 3
console.log(exponentialSearch(sortedNumbers, 100)); // -1
```

**Сложность:**
- Время: O(log n)
- Память: O(1)

## Поиск в строках

### 1. Поиск подстроки (Naive Approach)

Простейший алгоритм для поиска подстроки в строке.

```javascript
function naiveStringSearch(text, pattern) {
    const textLen = text.length;
    const patternLen = pattern.length;
    
    for (let i = 0; i <= textLen - patternLen; i++) {
        let j;
        for (j = 0; j < patternLen; j++) {
            if (text[i + j] !== pattern[j]) {
                break;
            }
        }
        if (j === patternLen) {
            return i; // Возвращаем индекс начала найденной подстроки
        }
    }
    return -1;
}

// Пример использования
const text = "Привет, это тестовая строка для поиска";
const pattern = "тестовая";
console.log(naiveStringSearch(text, pattern)); // 12
```

### 2. Алгоритм Кнута-Морриса-Пратта (KMP)

Более эффективный алгоритм поиска подстроки, который избегает повторного сравнения символов.

```javascript
function kmpSearch(text, pattern) {
    const lps = buildLPSArray(pattern);
    const textLen = text.length;
    const patternLen = pattern.length;
    
    let i = 0; // Индекс для text
    let j = 0; // Индекс для pattern
    
    while (i < textLen) {
        if (pattern[j] === text[i]) {
            i++;
            j++;
        }
        
        if (j === patternLen) {
            return i - j; // Найдено совпадение
        } else if (i < textLen && pattern[j] !== text[i]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return -1; // Совпадений не найдено
}

function buildLPSArray(pattern) {
    const len = pattern.length;
    const lps = new Array(len);
    let length = 0;
    let i = 1;
    
    lps[0] = 0;
    
    while (i < len) {
        if (pattern[i] === pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length !== 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

// Пример использования
const text = "ABABDABACDABABCABCABCABCABC";
const pattern = "ABABCABCAB";
console.log(kmpSearch(text, pattern)); // 10
```

## Практические примеры в фронтенде

### Поиск в массиве объектов

```javascript
// Поиск пользователя по имени
const users = [
    { id: 1, name: "Иван", email: "ivan@example.com" },
    { id: 2, name: "Мария", email: "maria@example.com" },
    { id: 3, name: "Алексей", email: "alexey@example.com" }
];

// Поиск по имени
const foundUser = users.find(user => user.name === "Мария");
console.log(foundUser); // { id: 2, name: "Мария", email: "maria@example.com" }

// Поиск по нескольким критериям
const foundUser2 = users.find(user => 
    user.name.toLowerCase().includes("ал") && 
    user.email.endsWith("@example.com")
);
console.log(foundUser2);
```

### Поиск с использованием фильтрации

```javascript
// Фильтрация списка товаров по названию
const products = [
    { name: "iPhone", category: "телефоны", price: 800 },
    { name: "Samsung Galaxy", category: "телефоны", price: 700 },
    { name: "iPad", category: "планшеты", price: 600 }
];

// Поиск товаров по названию
function searchProducts(products, searchTerm) {
    return products.filter(product => 
        product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
}

console.log(searchProducts(products, "iPhone"));
```

### Реализация автодополнения

```javascript
class AutoComplete {
    constructor(data) {
        this.data = data;
    }
    
    search(prefix) {
        const lowerPrefix = prefix.toLowerCase();
        return this.data.filter(item => 
            item.toLowerCase().includes(lowerPrefix)
        ).slice(0, 5); // Возвращаем первые 5 результатов
    }
}

// Пример использования
const autoComplete = new AutoComplete([
    "JavaScript", "Java", "Python", "C++", "Ruby", 
    "Rust", "Go", "TypeScript", "Swift", "Kotlin"
]);

console.log(autoComplete.search("java")); // ["JavaScript", "Java"]
```

## Встроенные методы поиска JavaScript

JavaScript предоставляет множество встроенных методов для поиска:

```javascript
const arr = [1, 2, 3, 4, 5];

// find() - возвращает первый элемент, удовлетворяющий условию
const found = arr.find(x => x > 3); // 4

// findIndex() - возвращает индекс первого элемента, удовлетворяющего условию
const index = arr.findIndex(x => x === 3); // 2

// indexOf() - возвращает индекс первого вхождения элемента
const idx = arr.indexOf(3); // 2

// includes() - проверяет наличие элемента
const hasThree = arr.includes(3); // true

// lastIndexOf() - возвращает индекс последнего вхождения элемента
const lastIdx = arr.lastIndexOf(3); // 2

// Методы для строк
const str = "Hello, World!";
const hasHello = str.includes("Hello"); // true
const startsWithHello = str.startsWith("Hello"); // true
const endsWithWorld = str.endsWith("World!"); // true
```

## Сравнение алгоритмов

| Алгоритм | Сложность времени | Сложность памяти | Требует сортировки |
|----------|-------------------|------------------|---------------------|
| Линейный поиск | O(n) | O(1) | Нет |
| Бинарный поиск | O(log n) | O(1) | Да |
| Интерполяционный поиск | O(log log n) | O(1) | Да |
| Экспоненциальный поиск | O(log n) | O(1) | Да |
| KMP | O(n + m) | O(m) | Нет |

## Заключение

Алгоритмы поиска являются фундаментальной частью фронтенд-разработки. Понимание их работы помогает эффективно реализовывать функции поиска, фильтрации и автодополнения. Выбор правильного алгоритма зависит от типа данных, размера коллекции и частоты выполнения поиска.

Для большинства случаев в фронтенде рекомендуется использовать встроенные методы JavaScript, такие как `find()`, `filter()`, `includes()`, так как они оптимизированы в браузерах. Однако знание основных алгоритмов поиска полезно для оптимизации производительности в специфических сценариях.

См. также: [[Алгоритмы-сортировки]], [[Алгоритмы-на-строках]], [[Хеширование]]