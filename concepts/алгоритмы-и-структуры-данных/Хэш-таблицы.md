---
aliases: ["Hash Table", "Hash Map", "Dictionary", "Object", "Map", "Set"]
tags: ["#алгоритмы", "#структуры-данных", "#хэш-таблицы", "#javascript", "#производительность"]
---

# Хэш-таблицы

## Общее описание

Хэш-таблица (также известная как хэш-карта, словарь или мэп) - это структура данных, которая реализует абстрактный тип "ассоциативный массив", позволяя эффективно хранить и извлекать пары "ключ-значение". В фронтенд-разработке хэш-таблицы чрезвычайно важны для оптимизации производительности приложений.

## Основные характеристики

- **Вставка элемента**: O(1) в среднем случае, O(n) в худшем случае
- **Поиск элемента**: O(1) в среднем случае, O(n) в худшем случае
- **Удаление элемента**: O(1) в среднем случае, O(n) в худшем случае
- **Пространственная сложность**: O(n)

## Как работают хэш-таблицы

Хэш-таблица использует хэш-функцию для преобразования ключа в индекс массива, где будет храниться соответствующее значение. Идеальная хэш-функция распределяет ключи равномерно по массиву, минимизируя коллизии (когда разные ключи получают одинаковый индекс).

```javascript
// Простая реализация хэш-таблицы
class SimpleHashTable {
    constructor(size = 50) {
        this.size = size;
        this.buckets = new Array(size);
        
        // Инициализация массива пустыми массивами для разрешения коллизий
        for (let i = 0; i < this.size; i++) {
            this.buckets[i] = [];
        }
    }
    
    // Простая хэш-функция
    hash(key) {
        let hash = 0;
        for (let i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % this.size;
    }
    
    // Вставка пары ключ-значение
    set(key, value) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        // Проверка, существует ли уже такой ключ
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value; // Обновление значения
                return;
            }
        }
        
        // Добавление новой пары
        bucket.push([key, value]);
    }
    
    // Получение значения по ключу
    get(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket[i][1];
            }
        }
        
        return undefined; // Ключ не найден
    }
    
    // Удаление пары ключ-значение
    remove(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket.splice(i, 1);
                return true;
            }
        }
        
        return false; // Ключ не найден
    }
}

// Пример использования
const hashTable = new SimpleHashTable();
hashTable.set('name', 'John');
hashTable.set('age', 30);
hashTable.set('city', 'New York');

console.log(hashTable.get('name')); // 'John'
console.log(hashTable.get('age'));  // 30
```

## Встроенные структуры в JavaScript

### Объекты (Objects)

Объекты JavaScript могут использоваться как хэш-таблицы, но имеют некоторые ограничения:

```javascript
// Использование объекта как хэш-таблицы
const userMap = {
    'user1': { id: 1, name: 'Alice', email: 'alice@example.com' },
    'user2': { id: 2, name: 'Bob', email: 'bob@example.com' },
    'user3': { id: 3, name: 'Charlie', email: 'charlie@example.com' }
};

// Доступ к данным
console.log(userMap['user1'].name); // 'Alice'

// Добавление данных
userMap['user4'] = { id: 4, name: 'Diana', email: 'diana@example.com' };

// Удаление данных
delete userMap['user3'];
```

### Map

`Map` - это более совершенная структура данных, специально предназначенная для хранения пар ключ-значение:

```javascript
// Использование Map
const userMap = new Map();

// Установка значений
userMap.set('user1', { id: 1, name: 'Alice', email: 'alice@example.com' });
userMap.set('user2', { id: 2, name: 'Bob', email: 'bob@example.com' });
userMap.set('user3', { id: 3, name: 'Charlie', email: 'charlie@example.com' });

// Получение значений
console.log(userMap.get('user1').name); // 'Alice'

// Проверка наличия ключа
console.log(userMap.has('user2')); // true

// Удаление
userMap.delete('user3');

// Итерация
for (const [key, value] of userMap) {
    console.log(`${key}: ${value.name}`);
}

// Использование различных типов ключей
const idMap = new Map();
idMap.set(1, 'first');
idMap.set(true, 'boolean key');
idMap.set({ id: 123 }, 'object key');

console.log(idMap.get(1)); // 'first'
```

### Set

`Set` - это коллекция уникальных значений:

```javascript
// Использование Set
const uniqueItems = new Set();

// Добавление элементов
uniqueItems.add('apple');
uniqueItems.add('banana');
uniqueItems.add('apple'); // Не будет добавлен, так как уже существует

console.log(uniqueItems.size); // 2

// Проверка наличия
console.log(uniqueItems.has('apple')); // true

// Удаление
uniqueItems.delete('banana');

// Итерация
for (const item of uniqueItems) {
    console.log(item);
}

// Преобразование в массив
const itemsArray = Array.from(uniqueItems);
// или
const itemsArray2 = [...uniqueItems];
```

## Применение в фронтенд-разработке

### Кэширование данных

```javascript
// Кэширование результатов API-запросов
class APICache {
    constructor() {
        this.cache = new Map();
        this.timeout = 5 * 60 * 1000; // 5 минут
    }
    
    async get(key) {
        const cached = this.cache.get(key);
        
        if (cached) {
            // Проверка времени жизни кэша
            if (Date.now() - cached.timestamp < this.timeout) {
                return cached.data;
            } else {
                // Удаление устаревшего кэша
                this.cache.delete(key);
            }
        }
        
        return null;
    }
    
    set(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }
    
    async fetchWithCache(url) {
        const cached = await this.get(url);
        if (cached) {
            return cached;
        }
        
        const response = await fetch(url);
        const data = await response.json();
        this.set(url, data);
        
        return data;
    }
}
```

### Управление состоянием приложения

```javascript
// Хранилище состояния с использованием Map
class StateStore {
    constructor() {
        this.state = new Map();
        this.listeners = new Map(); // подписчики на изменения
    }
    
    // Установка значения
    set(key, value) {
        const oldValue = this.state.get(key);
        this.state.set(key, value);
        
        // Уведомление подписчиков
        const listeners = this.listeners.get(key) || [];
        listeners.forEach(callback => callback(value, oldValue));
    }
    
    // Получение значения
    get(key) {
        return this.state.get(key);
    }
    
    // Подписка на изменения
    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, []);
        }
        this.listeners.get(key).push(callback);
        
        // Возврат функции отписки
        return () => {
            const listeners = this.listeners.get(key);
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        };
    }
}

// Пример использования
const store = new StateStore();

// Подписка на изменения
const unsubscribe = store.subscribe('user', (newUser, oldUser) => {
    console.log('Пользователь изменился:', newUser);
});

// Установка значения
store.set('user', { id: 1, name: 'John' });
```

### Оптимизация поиска

```javascript
// Быстрый поиск пользователей по ID
class UserRegistry {
    constructor() {
        this.usersById = new Map(); // ключ: id, значение: user
        this.usersByEmail = new Map(); // ключ: email, значение: user
    }
    
    addUser(user) {
        this.usersById.set(user.id, user);
        this.usersByEmail.set(user.email, user);
    }
    
    getUserById(id) {
        return this.usersById.get(id);
    }
    
    getUserByEmail(email) {
        return this.usersByEmail.get(email);
    }
    
    removeUser(id) {
        const user = this.usersById.get(id);
        if (user) {
            this.usersById.delete(id);
            this.usersByEmail.delete(user.email);
        }
    }
}
```

### Фильтрация и агрегация данных

```javascript
// Группировка элементов по категориям
function groupBy(items, keyFunction) {
    const groups = new Map();
    
    for (const item of items) {
        const key = keyFunction(item);
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(item);
    }
    
    return groups;
}

// Пример использования
const products = [
    { name: 'Laptop', category: 'Electronics', price: 1000 },
    { name: 'Book', category: 'Education', price: 20 },
    { name: 'Phone', category: 'Electronics', price: 800 },
    { name: 'Notebook', category: 'Education', price: 10 }
];

const groupedProducts = groupBy(products, item => item.category);
console.log(groupedProducts.get('Electronics')); // [{ name: 'Laptop', ... }, { name: 'Phone', ... }]
```

### Уникальные элементы и дедупликация

```javascript
// Удаление дубликатов из массива
function removeDuplicates(array) {
    return [...new Set(array)];
}

// Удаление дубликатов объектов по ключу
function removeDuplicateObjects(array, key) {
    const seen = new Set();
    return array.filter(item => {
        const value = item[key];
        if (seen.has(value)) {
            return false;
        }
        seen.add(value);
        return true;
    });
}

// Пример
const numbers = [1, 2, 2, 3, 4, 4, 5];
console.log(removeDuplicates(numbers)); // [1, 2, 3, 4, 5]

const users = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
    { id: 1, name: 'John' } // дубликат
];
console.log(removeDuplicateObjects(users, 'id'));
// [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]
```

## Сравнение структур данных

| Характеристика | Object | Map | Set |
|----------------|--------|-----|-----|
| Ключи | Только строки/symbols | Любые типы | Не применимо |
| Размер | Нужно вычислять | size property | size property |
| Итерация | В порядке вставки (ES2015+) | В порядке вставки | В порядке вставки |
| Производительность | Медленнее при частых операциях | Быстрее при частых операциях | Быстрее при проверке уникальности |
| Память | Меньше оверхеда | Больше оверхеда | Меньше оверхеда |

## Практические рекомендации для фронтенд-разработчиков

1. **Используйте Map вместо Object** для хранения пар ключ-значение, особенно когда ключи не являются строками
2. **Используйте Set для проверки уникальности** элементов
3. **Кэшируйте результаты вычислений** с помощью Map для избежания повторных дорогостоящих операций
4. **Используйте WeakMap/WeakSet** для избежания утечек памяти при работе с DOM-элементами
5. **Рассмотрите использование хэш-таблиц для индексации** данных для быстрого поиска

```javascript
// Плохо: поиск в массиве - O(n)
function findUserBad(users, id) {
    return users.find(user => user.id === id); // O(n)
}

// Хорошо: использование Map для поиска - O(1)
function findUserGood(users) {
    const userMap = new Map();
    users.forEach(user => userMap.set(user.id, user));
    
    return (id) => userMap.get(id); // O(1)
}

// Использование WeakMap для хранения приватных данных
const privateData = new WeakMap();

class Component {
    constructor(element) {
        this.element = element;
        privateData.set(element, {
            state: {},
            listeners: []
        });
    }
    
    getState() {
        return privateData.get(this.element).state;
    }
    
    setState(newState) {
        const data = privateData.get(this.element);
        Object.assign(data.state, newState);
    }
}
```

## Заключение

Хэш-таблицы являются одной из самых важных структур данных в фронтенд-разработке. Они обеспечивают эффективный доступ к данным и позволяют создавать производительные приложения. Понимание различий между объектами, Map и Set, а также знание, когда и как использовать каждую структуру, помогает создавать более эффективный и читаемый код.

См. также: [[Сложность-алгоритмов]], [[Списки-и-массивы]], [[Стеки-и-очереди]], [[Деревья-и-графы]], [[Производительность фронтенд-приложений]]