---
aliases: ["Паттерны и практики чистой архитектуры", "Лучшие практики"]
tags: 
  - "#архитектура"
  - "#паттерны"
  - "#практики"
  - "#разработка"
---

# Паттерны и практики чистой архитектуры

## Введение

Помимо основных принципов чистой архитектуры, существуют дополнительные паттерны и практики, которые помогают эффективно реализовать этот подход. В этой статье рассмотрим наиболее важные из них.

## Паттерны проектирования в чистой архитектуре

### Repository Pattern

Repository паттерн используется во внешних слоях для абстрагирования доступа к данным:

```python
from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    def save(self, user):
        pass
    
    @abstractmethod
    def find_by_id(self, user_id):
        pass
    
    @abstractmethod
    def find_by_email(self, email):
        pass

# Реализация для конкретной базы данных
class SqlUserRepository(UserRepository):
    def __init__(self, connection):
        self.connection = connection
    
    def save(self, user):
        # Реализация сохранения в SQL базу
        pass
    
    def find_by_id(self, user_id):
        # Реализация поиска по ID
        pass
    
    def find_by_email(self, email):
        # Реализация поиска по email
        pass
```

### Specification Pattern

Specification паттерн позволяет определять сложные условия поиска и фильтрации:

```python
from abc import ABC, abstractmethod

class Specification(ABC):
    @abstractmethod
    def is_satisfied_by(self, obj):
        pass
    
    def and_spec(self, other):
        return AndSpecification(self, other)
    
    def or_spec(self, other):
        return OrSpecification(self, other)

class ActiveUserSpecification(Specification):
    def is_satisfied_by(self, user):
        return user.is_active and user.last_login > datetime.now() - timedelta(days=30)

class PremiumUserSpecification(Specification):
    def is_satisfied_by(self, user):
        return user.subscription_type == "premium"

class UserSearchUseCase:
    def __init__(self, user_repository):
        self.user_repository = user_repository
    
    def execute(self, specification):
        # Получаем всех пользователей и фильтруем по спецификации
        all_users = self.user_repository.find_all()
        return [user for user in all_users if specification.is_satisfied_by(user)]
```

### Observer Pattern

Observer паттерн полезен для уведомлений о бизнес-событиях:

```python
from abc import ABC, abstractmethod

class Observer(ABC):
    @abstractmethod
    def update(self, event):
        pass

class EmailNotificationObserver(Observer):
    def update(self, event):
        if event.type == "user_registered":
            # Отправка email уведомления
            send_registration_email(event.data['user'])

class LoggingObserver(Observer):
    def update(self, event):
        log_event(event)

class EventBus:
    def __init__(self):
        self.observers = []
    
    def subscribe(self, observer):
        self.observers.append(observer)
    
    def notify(self, event):
        for observer in self.observers:
            observer.update(event)

class UserRegistrationUseCase:
    def __init__(self, user_repository, event_bus):
        self.user_repository = user_repository
        self.event_bus = event_bus
    
    def execute(self, user_data):
        user = User(**user_data)
        saved_user = self.user_repository.save(user)
        
        # Уведомляем подписчиков о регистрации пользователя
        event = Event("user_registered", {"user": saved_user})
        self.event_bus.notify(event)
        
        return saved_user
```

## Практики реализации

### 1. Использование DTO (Data Transfer Objects)

Для передачи данных между слоями рекомендуется использовать специальные объекты:

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class TaskDTO:
    id: Optional[int]
    title: str
    description: str
    status: str
    created_at: str

@dataclass
class CreateTaskRequest:
    title: str
    description: str

@dataclass
class CreateTaskResponse:
    success: bool
    task_id: Optional[int]
    error_message: Optional[str]

class TaskController:
    def __init__(self, create_task_use_case):
        self.create_task_use_case = create_task_use_case
    
    def create_task(self, request_data):
        # Преобразование данных запроса в DTO
        request = CreateTaskRequest(
            title=request_data.get('title'),
            description=request_data.get('description', '')
        )
        
        # Вызов сценария использования
        response = self.create_task_use_case.execute(request)
        
        # Преобразование результата в формат ответа
        return {
            'success': response.success,
            'taskId': response.task_id,
            'errorMessage': response.error_message
        }
```

### 2. Обработка ошибок

Важно правильно обрабатывать ошибки на всех уровнях:

```python
class BusinessError(Exception):
    """Базовый класс для бизнес-ошибок"""
    def __init__(self, message, error_code=None):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class UserNotFoundError(BusinessError):
    """Ошибка: пользователь не найден"""
    def __init__(self, user_id):
        super().__init__(f"User with ID {user_id} not found", "USER_NOT_FOUND")

class InvalidEmailError(BusinessError):
    """Ошибка: неверный формат email"""
    def __init__(self):
        super().__init__("Invalid email format", "INVALID_EMAIL")

class GetUserUseCase:
    def __init__(self, user_repository):
        self.user_repository = user_repository
    
    def execute(self, user_id):
        user = self.user_repository.find_by_id(user_id)
        if not user:
            raise UserNotFoundError(user_id)
        return user

class UserController:
    def get_user(self, user_id):
        try:
            user = self.get_user_use_case.execute(user_id)
            return {
                'success': True,
                'user': self._to_dto(user)
            }
        except UserNotFoundError as e:
            return {
                'success': False,
                'error': {
                    'code': e.error_code,
                    'message': e.message
                }
            }
        except Exception as e:
            # Обработка неожиданных ошибок
            return {
                'success': False,
                'error': {
                    'code': 'INTERNAL_ERROR',
                    'message': 'An unexpected error occurred'
                }
            }
```

### 3. Валидация данных

Валидация должна происходить на соответствующих уровнях:

```python
from abc import ABC, abstractmethod

class Validator(ABC):
    @abstractmethod
    def validate(self, data):
        pass

class TaskTitleValidator(Validator):
    def validate(self, title):
        if not title or len(title.strip()) == 0:
            raise ValueError("Task title cannot be empty")
        if len(title) > 100:
            raise ValueError("Task title cannot exceed 100 characters")

class TaskDescriptionValidator(Validator):
    def validate(self, description):
        if description and len(description) > 1000:
            raise ValueError("Task description cannot exceed 1000 characters")

class CreateTaskUseCase:
    def __init__(self, task_repository, validators=None):
        self.task_repository = task_repository
        self.validators = validators or [
            TaskTitleValidator(),
            TaskDescriptionValidator()
        ]
    
    def execute(self, title, description):
        # Валидация данных
        for validator in self.validators:
            try:
                if hasattr(validator, 'validate_title'):
                    validator.validate_title(title)
                elif hasattr(validator, 'validate'):
                    if validator.__class__.__name__ == 'TaskTitleValidator':
                        validator.validate(title)
                    elif validator.__class__.__name__ == 'TaskDescriptionValidator':
                        validator.validate(description)
            except ValueError as e:
                raise BusinessError(str(e))
        
        # Создание задачи
        task = Task(None, title, description)
        return self.task_repository.save(task)
```

## Организация кода

### Структура проекта

Рекомендуемая структура проекта для чистой архитектуры:

```
project/
├── src/
│   ├── entities/           # Слой сущностей
│   │   ├── user.py
│   │   ├── task.py
│   │   └── ...
│   ├── use_cases/          # Слой сценариев использования
│   │   ├── user/
│   │   │   ├── register_user.py
│   │   │   └── ...
│   │   ├── task/
│   │   │   ├── create_task.py
│   │   │   └── ...
│   │   └── interfaces/     # Интерфейсы для внешних слоев
│   │       ├── user_repository.py
│   │       └── ...
│   ├── interface_adapters/ # Слой интерфейсных адаптеров
│   │   ├── controllers/
│   │   ├── presenters/
│   │   └── converters/
│   └── frameworks_drivers/ # Слой фреймворков и драйверов
│       ├── database/
│       ├── web/
│       └── external_services/
├── tests/
│   ├── unit/
│   │   ├── entities/
│   │   └── use_cases/
│   ├── integration/
│   └── e2e/
└── requirements.txt
```

### Именование файлов и классов

Для поддержания согласованности в проекте рекомендуется использовать следующие соглашения:

- Классы сценариев использования заканчиваются на `UseCase`
- Интерфейсы начинаются с `I` или заканчиваются на `Interface`
- Классы контроллеров заканчиваются на `Controller`
- Классы репозиториев заканчиваются на `Repository`
- DTO классы заканчиваются на `DTO`

## Инфраструктурные соображения

### Dependency Injection

Для правильной инъекции зависимостей рекомендуется использовать контейнер внедрения зависимостей:

```python
class DIContainer:
    def __init__(self):
        self._services = {}
        self._singletons = {}
    
    def register(self, interface, implementation, singleton=False):
        self._services[interface] = {
            'implementation': implementation,
            'singleton': singleton
        }
    
    def resolve(self, interface):
        if interface in self._singletons:
            return self._singletons[interface]
        
        service_info = self._services[interface]
        implementation = service_info['implementation']
        
        if service_info['singleton']:
            instance = implementation()
            self._singletons[interface] = instance
            return instance
        else:
            return implementation()

# Регистрация сервисов
container = DIContainer()
container.register(UserRepository, SqlUserRepository, singleton=True)
container.register(CreateUserUseCase, CreateUserUseCase)

# Использование
user_repo = container.resolve(UserRepository)
create_user_uc = container.resolve(CreateUserUseCase)
```

### Configuration Management

Управление конфигурацией также должно следовать принципам чистой архитектуры:

```python
from abc import ABC, abstractmethod

class ConfigProvider(ABC):
    @abstractmethod
    def get(self, key, default=None):
        pass

class EnvConfigProvider(ConfigProvider):
    def __init__(self):
        import os
        self.env = os.environ
    
    def get(self, key, default=None):
        return self.env.get(key, default)

class UseCaseWithConfig:
    def __init__(self, repository, config_provider):
        self.repository = repository
        self.config_provider = config_provider
    
    def execute(self):
        timeout = self.config_provider.get('DB_TIMEOUT', 30)
        # Использование конфигурации в бизнес-логике
        result = self.repository.fetch_data_with_timeout(timeout)
        return result
```

## Миграция существующих проектов

При миграции существующих проектов на чистую архитектуру рекомендуется:

1. **Начать с выделения бизнес-логики** в отдельные классы
2. **Создать интерфейсы** для внешних зависимостей
3. **Поэтапно внедрять** архитектурные слои
4. **Писать тесты** для новой архитектуры по мере внедрения
5. **Не пытаться переархитектурировать всё сразу**

## Заключение

Паттерны и практики, описанные в этой статье, помогут эффективно реализовать чистую архитектуру в ваших проектах. Важно помнить, что архитектура должна служить целям приложения, а не наоборот. Используйте эти паттерны осознанно, в зависимости от конкретных требований вашего проекта.

## Связанные концепции

- [[Чистая-архитектура]]
- [[Слои-чистой-архитектуры]]
- [[Примеры-чистой-архитектуры]]
- [[SOLID-принципы]]
- [[Разделение-ответственности]]

## Теги

#архитектура #паттерны #практики #разработка #чистая-архитектура