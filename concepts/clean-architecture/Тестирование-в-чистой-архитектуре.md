---
aliases: ["Тестирование в чистой архитектуре", "Юнит-тестирование"]
tags: 
  - "#архитектура"
  - "#тестирование"
  - "#разработка"
  - "#юнит-тесты"
---

# Тестирование в чистой архитектуре

## Введение

Одним из ключевых преимуществ чистой архитектуры является высокая тестируемость. Благодаря четкому разделению ответственностей и использованию абстракций, внутренние слои архитектуры могут быть протестированы без зависимости от внешних факторов, таких как база данных, веб-фреймворки или UI.

## Принципы тестирования в чистой архитектуре

### 1. Тестирование бизнес-логики изолированно

В чистой архитектуре бизнес-логика (сценарии использования и сущности) изолирована от внешних зависимостей. Это позволяет:

- Писать unit-тесты для бизнес-логики без необходимости запуска базы данных
- Тестировать бизнес-правила независимо от UI
- Быстро выполнять тесты, так как не требуется внешняя инфраструктура

### 2. Использование моков и стабов

Для тестирования внутренних слоев используются моки внешних зависимостей:

```python
from unittest.mock import Mock, MagicMock

# Создание мока для репозитория
mock_repository = Mock(spec=TaskRepository)
mock_repository.save.return_value = Task(1, "Test Task", "Description")

# Использование мока в сценарии использования
use_case = CreateTaskUseCase(mock_repository)
result = use_case.execute("Test Task", "Description")

# Проверка результата
assert result.title == "Test Task"
```

### 3. Тестирование на каждом уровне

- **Юнит-тесты** для сущностей и сценариев использования
- **Интеграционные тесты** для проверки взаимодействия между слоями
- **Сквозные тесты** для проверки работы всей системы

## Тестирование слоя сущностей

Слой сущностей содержит бизнес-правила и может быть протестирован без внешних зависимостей:

```python
import unittest

class TestUser(unittest.TestCase):
    def test_change_email_with_valid_format(self):
        # Подготовка
        user = User(1, "John Doe", "john@example.com")
        
        # Выполнение
        user.change_email("newemail@example.com")
        
        # Проверка
        self.assertEqual(user.email, "newemail@example.com")
    
    def test_change_email_with_invalid_format_raises_error(self):
        # Подготовка
        user = User(1, "John Doe", "john@example.com")
        
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            user.change_email("invalid-email")
        
        # Убедиться, что email не изменился
        self.assertEqual(user.email, "john@example.com")

class TestTask(unittest.TestCase):
    def test_update_status_from_done_to_incomplete_raises_error(self):
        # Подготовка
        task = Task(1, "Test Task", "Description", TaskStatus.DONE)
        
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            task.update_status(TaskStatus.IN_PROGRESS)
```

## Тестирование слоя сценариев использования

Слой сценариев использования тестируется с использованием моков внешних зависимостей:

```python
class TestRegisterUserUseCase(unittest.TestCase):
    def setUp(self):
        self.mock_repository = Mock(spec=UserRepository)
        self.mock_email_service = Mock(spec=EmailService)
        self.use_case = RegisterUserUseCase(
            self.mock_repository, 
            self.mock_email_service
        )
    
    def test_register_new_user_success(self):
        # Подготовка
        self.mock_repository.exists_by_email.return_value = False
        self.mock_repository.save.return_value = User(1, "John Doe", "john@example.com")
        
        # Выполнение
        user = self.use_case.execute("John Doe", "john@example.com")
        
        # Проверка
        self.assertEqual(user.name, "John Doe")
        self.assertEqual(user.email, "john@example.com")
        self.mock_repository.exists_by_email.assert_called_once_with("john@example.com")
        self.mock_repository.save.assert_called_once()
        self.mock_email_service.send_welcome_email.assert_called_once_with("john@example.com")
    
    def test_register_existing_email_raises_error(self):
        # Подготовка
        self.mock_repository.exists_by_email.return_value = True
        
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            self.use_case.execute("John Doe", "existing@example.com")
    
    def test_register_user_with_invalid_email_format_raises_error(self):
        # Подготовка
        self.mock_repository.exists_by_email.return_value = False
        user_entity = User(1, "John Doe", "invalid-email")
        
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            # Предполагаем, что сущность проверяет формат email при создании
            self.use_case.execute("John Doe", "invalid-email")
```

## Тестирование слоя интерфейсных адаптеров

Контроллеры и другие компоненты интерфейсного слоя тестируются с моками сценариев использования:

```python
from flask import Flask
import json

class TestUserController(unittest.TestCase):
    def setUp(self):
        self.mock_use_case = Mock(spec=RegisterUserUseCase)
        self.controller = UserController(self.mock_use_case)
        
        # Настройка Flask приложения для тестирования
        self.app = Flask(__name__)
        self.client = self.app.test_client()
        
        # Мокаем метод контроллера
        self.controller.register_user = self.mock_register_user
    
    def mock_register_user(self, request_data):
        # Эмуляция работы метода register_user
        name = request_data.get('name')
        email = request_data.get('email')
        
        try:
            user = self.mock_use_case.execute(name, email)
            return {
                'status': 'success',
                'user_id': user.user_id,
                'message': 'User registered successfully'
            }
        except ValueError as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def test_register_user_controller_success(self):
        # Подготовка
        mock_user = User(1, "John Doe", "john@example.com")
        self.mock_use_case.execute.return_value = mock_user
        
        # Выполнение
        request_data = {'name': 'John Doe', 'email': 'john@example.com'}
        result = self.controller.register_user(request_data)
        
        # Проверка
        self.assertEqual(result['status'], 'success')
        self.assertEqual(result['user_id'], 1)
        self.mock_use_case.execute.assert_called_once_with('John Doe', 'john@example.com')

class TestTaskController(unittest.TestCase):
    def setUp(self):
        self.mock_create_task = Mock(spec=CreateTaskUseCase)
        self.mock_update_status = Mock(spec=UpdateTaskStatusUseCase)
        self.mock_get_task = Mock(spec=GetTaskUseCase)
        
        self.controller = TaskController(
            self.mock_create_task,
            self.mock_update_status,
            self.mock_get_task
        )
    
    def test_create_task_controller_success(self):
        # Подготовка
        mock_task = Task(1, "Test Task", "Description")
        self.mock_create_task.execute.return_value = mock_task
        
        # Эмуляция данных запроса
        request_data = {'title': 'Test Task', 'description': 'Description'}
        
        # Выполнение
        with app.test_request_context('/tasks', method='POST', json=request_data):
            response = self.controller.create_task()
        
        # Проверка
        self.assertIn('201', str(response[1]))  # Проверка статуса 201
        self.assertIn('Test Task', str(response[0]))
```

## Интеграционное тестирование

Интеграционные тесты проверяют взаимодействие между слоями:

```python
class TestTaskIntegration(unittest.TestCase):
    def setUp(self):
        # Используем реальные реализации для интеграционного теста
        self.db_path = ':memory:'  # Используем in-memory базу для тестов
        self.repository = SqliteTaskRepository(self.db_path)
        self.create_task_use_case = CreateTaskUseCase(self.repository)
        self.get_task_use_case = GetTaskUseCase(self.repository)
    
    def test_create_and_retrieve_task(self):
        # Выполнение
        created_task = self.create_task_use_case.execute("Integration Test", "Description")
        retrieved_task = self.get_task_use_case.execute(created_task.task_id)
        
        # Проверка
        self.assertEqual(created_task.task_id, retrieved_task.task_id)
        self.assertEqual(created_task.title, retrieved_task.title)
        self.assertEqual(created_task.description, retrieved_task.description)
    
    def tearDown(self):
        # Очистка после теста
        import os
        if self.db_path != ':memory:':
            os.remove(self.db_path)
```

## Тестирование зависимостей и инверсии

Тестирование корректности инверсии зависимостей:

```python
class TestDependencyInversion(unittest.TestCase):
    def test_use_case_does_not_depend_on_framework(self):
        # Подготовка
        mock_repository = Mock(spec=TaskRepository)
        mock_email_service = Mock(spec=EmailService)
        
        # Создание сценария использования - не должно вызывать ошибок
        # даже если фреймворки не установлены
        use_case = RegisterUserUseCase(mock_repository, mock_email_service)
        
        # Проверка, что сценарий использования может быть создан
        self.assertIsInstance(use_case, RegisterUserUseCase)
        
        # Проверка, что сценарий использования не зависит от конкретных фреймворков
        # и может работать с любыми реализациями интерфейсов
        self.assertEqual(use_case.user_repository, mock_repository)
        self.assertEqual(use_case.email_service, mock_email_service)
```

## Практические советы по тестированию

### 1. Используйте фикстуры для подготовки данных

```python
class TaskTestFixture:
    @staticmethod
    def create_sample_task():
        return Task(1, "Sample Task", "Sample Description")
    
    @staticmethod
    def create_sample_user():
        return User(1, "Sample User", "sample@example.com")
    
    @staticmethod
    def create_mock_repository():
        mock_repo = Mock(spec=TaskRepository)
        mock_repo.find_by_id.return_value = TaskTestFixture.create_sample_task()
        return mock_repo
```

### 2. Покрывайте граничные условия

```python
def test_task_with_empty_title_raises_error(self):
    # Тестируем бизнес-правило: заголовок не может быть пустым
    task = TaskTestFixture.create_sample_task()
    with self.assertRaises(ValueError):
        task.update_title("")
```

### 3. Тестируйте ошибочные сценарии

```python
def test_update_nonexistent_task_raises_error(self):
    # Подготовка
    mock_repo = Mock(spec=TaskRepository)
    mock_repo.find_by_id.return_value = None
    
    use_case = UpdateTaskStatusUseCase(mock_repo)
    
    # Выполнение и проверка
    with self.assertRaises(ValueError):
        use_case.execute(999, TaskStatus.IN_PROGRESS)
```

## Автоматизация тестирования

Для эффективного тестирования в чистой архитектуре рекомендуется:

- Использовать CI/CD пайплайны для автоматического запуска тестов
- Покрывать бизнес-логику unit-тестами с высоким приоритетом
- Регулярно измерять покрытие кода тестами
- Использовать property-based тестирование для сложных сценариев

## Заключение

Тестирование в чистой архитектуре становится более эффективным благодаря:

- Изоляции бизнес-логики от внешних зависимостей
- Возможности использования моков и стабов
- Четкому разделению ответственностей
- Легкости в написании и поддержке тестов

Эти преимущества делают приложения более надежными и предсказуемыми в поведении.

## Связанные концепции

- [[Чистая-архитектура]]
- [[Слои-чистой-архитектуры]]
- [[Примеры-чистой-архитектуры]]
- [[SOLID-принципы]]
- [[Разделение-ответственности]]

## Теги

#архитектура #тестирование #разработка #юнит-тесты #чистая-архитектура