---
aliases: ["Примеры чистой архитектуры", "Практические примеры"]
tags: 
  - "#архитектура"
  - "#примеры"
  - "#практика"
  - "#разработка"
---

# Примеры чистой архитектуры

## Пример 1: Система управления задачами

Рассмотрим пример реализации системы управления задачами (Task Management System) с использованием чистой архитектуры.

### Слой сущностей

```python
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum

class TaskStatus(Enum):
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"

class Task:
    def __init__(self, task_id, title, description, status=TaskStatus.TODO, created_at=None):
        self.task_id = task_id
        self.title = title
        self.description = description
        self.status = status
        self.created_at = created_at or datetime.now()
    
    def update_status(self, new_status):
        """Бизнес-правило: задача не может вернуться к статусу TODO после выполнения"""
        if self.status == TaskStatus.DONE and new_status != TaskStatus.DONE:
            raise ValueError("Cannot change status of completed task back to incomplete")
        self.status = new_status
    
    def update_title(self, new_title):
        """Бизнес-правило: заголовок не может быть пустым"""
        if not new_title.strip():
            raise ValueError("Task title cannot be empty")
        self.title = new_title
```

### Слой сценариев использования

```python
from abc import ABC, abstractmethod

class TaskRepository(ABC):
    @abstractmethod
    def save(self, task):
        pass
    
    @abstractmethod
    def find_by_id(self, task_id):
        pass
    
    @abstractmethod
    def find_all(self):
        pass
    
    @abstractmethod
    def delete(self, task_id):
        pass

class CreateTaskUseCase:
    def __init__(self, task_repository):
        self.task_repository = task_repository
    
    def execute(self, title, description):
        # Бизнес-логика создания задачи
        if not title.strip():
            raise ValueError("Title is required")
        
        task = Task(None, title, description)
        saved_task = self.task_repository.save(task)
        return saved_task

class UpdateTaskStatusUseCase:
    def __init__(self, task_repository):
        self.task_repository = task_repository
    
    def execute(self, task_id, new_status):
        task = self.task_repository.find_by_id(task_id)
        if not task:
            raise ValueError(f"Task with ID {task_id} not found")
        
        task.update_status(new_status)
        updated_task = self.task_repository.save(task)
        return updated_task

class GetTaskUseCase:
    def __init__(self, task_repository):
        self.task_repository = task_repository
    
    def execute(self, task_id):
        task = self.task_repository.find_by_id(task_id)
        if not task:
            raise ValueError(f"Task with ID {task_id} not found")
        return task
```

### Слой интерфейсных адаптеров

```python
import json
from flask import request, jsonify

class TaskController:
    def __init__(self, create_task_use_case, update_task_status_use_case, get_task_use_case):
        self.create_task_use_case = create_task_use_case
        self.update_task_status_use_case = update_task_status_use_case
        self.get_task_use_case = get_task_use_case
    
    def create_task(self):
        data = request.get_json()
        title = data.get('title')
        description = data.get('description', '')
        
        try:
            task = self.create_task_use_case.execute(title, description)
            return jsonify({
                'id': task.task_id,
                'title': task.title,
                'description': task.description,
                'status': task.status.value,
                'created_at': task.created_at.isoformat()
            }), 201
        except ValueError as e:
            return jsonify({'error': str(e)}), 400
    
    def update_task_status(self, task_id):
        data = request.get_json()
        status_value = data.get('status')
        
        try:
            new_status = TaskStatus(status_value)
            task = self.update_task_status_use_case.execute(task_id, new_status)
            return jsonify({
                'id': task.task_id,
                'title': task.title,
                'status': task.status.value
            })
        except ValueError as e:
            return jsonify({'error': str(e)}), 400
    
    def get_task(self, task_id):
        try:
            task = self.get_task_use_case.execute(task_id)
            return jsonify({
                'id': task.task_id,
                'title': task.title,
                'description': task.description,
                'status': task.status.value,
                'created_at': task.created_at.isoformat()
            })
        except ValueError as e:
            return jsonify({'error': str(e)}), 404
```

### Слой фреймворков и драйверов

```python
import sqlite3
from contextlib import contextmanager

class SqliteTaskRepository:
    def __init__(self, db_path):
        self.db_path = db_path
        self.init_db()
    
    def init_db(self):
        with self.get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS tasks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    description TEXT,
                    status TEXT NOT NULL,
                    created_at TEXT NOT NULL
                )
            ''')
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def save(self, task):
        with self.get_connection() as conn:
            if task.task_id is None:
                # Создание новой задачи
                cursor = conn.execute(
                    'INSERT INTO tasks (title, description, status, created_at) VALUES (?, ?, ?, ?)',
                    (task.title, task.description, task.status.value, task.created_at.isoformat())
                )
                task.task_id = cursor.lastrowid
            else:
                # Обновление существующей задачи
                conn.execute(
                    'UPDATE tasks SET title=?, description=?, status=? WHERE id=?',
                    (task.title, task.description, task.status.value, task.task_id)
                )
            return task
    
    def find_by_id(self, task_id):
        with self.get_connection() as conn:
            cursor = conn.execute(
                'SELECT id, title, description, status, created_at FROM tasks WHERE id=?',
                (task_id,)
            )
            row = cursor.fetchone()
            if row:
                task_id, title, description, status, created_at = row
                return Task(
                    task_id=task_id,
                    title=title,
                    description=description,
                    status=TaskStatus(status),
                    created_at=datetime.fromisoformat(created_at)
                )
            return None
    
    def find_all(self):
        with self.get_connection() as conn:
            cursor = conn.execute(
                'SELECT id, title, description, status, created_at FROM tasks'
            )
            tasks = []
            for row in cursor.fetchall():
                task_id, title, description, status, created_at = row
                tasks.append(Task(
                    task_id=task_id,
                    title=title,
                    description=description,
                    status=TaskStatus(status),
                    created_at=datetime.fromisoformat(created_at)
                ))
            return tasks
    
    def delete(self, task_id):
        with self.get_connection() as conn:
            cursor = conn.execute('DELETE FROM tasks WHERE id=?', (task_id,))
            return cursor.rowcount > 0

# Конфигурация приложения
from flask import Flask

def create_app():
    app = Flask(__name__)
    
    # Создание репозитория
    task_repository = SqliteTaskRepository('tasks.db')
    
    # Создание сценариев использования
    create_task_uc = CreateTaskUseCase(task_repository)
    update_task_status_uc = UpdateTaskStatusUseCase(task_repository)
    get_task_uc = GetTaskUseCase(task_repository)
    
    # Создание контроллера
    task_controller = TaskController(
        create_task_uc,
        update_task_status_uc,
        get_task_uc
    )
    
    # Настройка маршрутов
    @app.route('/tasks', methods=['POST'])
    def create_task():
        return task_controller.create_task()
    
    @app.route('/tasks/<int:task_id>/status', methods=['PUT'])
    def update_task_status(task_id):
        return task_controller.update_task_status(task_id)
    
    @app.route('/tasks/<int:task_id>', methods=['GET'])
    def get_task(task_id):
        return task_controller.get_task(task_id)
    
    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)
```

## Пример 2: Система электронной коммерции

Рассмотрим упрощенную систему электронной коммерции с использованием чистой архитектуры.

### Слой сущностей

```python
from decimal import Decimal

class Product:
    def __init__(self, product_id, name, price, stock_quantity):
        self.product_id = product_id
        self.name = name
        self.price = price
        self.stock_quantity = stock_quantity
    
    def update_stock(self, quantity_change):
        """Обновление остатка товара"""
        new_quantity = self.stock_quantity + quantity_change
        if new_quantity < 0:
            raise ValueError("Insufficient stock")
        self.stock_quantity = new_quantity

class Cart:
    def __init__(self, cart_id, user_id):
        self.cart_id = cart_id
        self.user_id = user_id
        self.items = []
    
    def add_item(self, product, quantity):
        """Добавление товара в корзину"""
        # Проверка наличия достаточного количества товара
        if product.stock_quantity < quantity:
            raise ValueError(f"Insufficient stock for {product.name}")
        
        # Проверка, есть ли уже такой товар в корзине
        for item in self.items:
            if item['product'].product_id == product.product_id:
                item['quantity'] += quantity
                return
        
        # Добавление нового товара
        self.items.append({
            'product': product,
            'quantity': quantity
        })
    
    def calculate_total(self):
        """Расчет общей стоимости корзины"""
        total = Decimal('0')
        for item in self.items:
            total += item['product'].price * item['quantity']
        return total
```

### Слой сценариев использования

```python
class AddToCartUseCase:
    def __init__(self, cart_repository, product_repository):
        self.cart_repository = cart_repository
        self.product_repository = product_repository
    
    def execute(self, user_id, product_id, quantity):
        # Получение корзины пользователя
        cart = self.cart_repository.get_or_create_cart(user_id)
        
        # Получение продукта
        product = self.product_repository.find_by_id(product_id)
        if not product:
            raise ValueError(f"Product with ID {product_id} not found")
        
        # Добавление товара в корзину
        cart.add_item(product, quantity)
        
        # Обновление остатков
        product.update_stock(-quantity)
        self.product_repository.update(product)
        
        # Сохранение корзины
        self.cart_repository.save(cart)
        
        return cart

class CheckoutUseCase:
    def __init__(self, cart_repository, order_repository, payment_service):
        self.cart_repository = cart_repository
        self.order_repository = order_repository
        self.payment_service = payment_service
    
    def execute(self, user_id, payment_info):
        # Получение корзины пользователя
        cart = self.cart_repository.find_by_user_id(user_id)
        if not cart or not cart.items:
            raise ValueError("Cart is empty")
        
        # Расчет общей суммы
        total_amount = cart.calculate_total()
        
        # Проведение оплаты
        payment_result = self.payment_service.process_payment(
            user_id, total_amount, payment_info
        )
        
        if not payment_result.success:
            raise ValueError("Payment failed")
        
        # Создание заказа
        order = Order(
            user_id=user_id,
            items=cart.items,
            total_amount=total_amount,
            payment_id=payment_result.payment_id
        )
        
        # Сохранение заказа
        saved_order = self.order_repository.save(order)
        
        # Очистка корзины
        self.cart_repository.clear_cart(user_id)
        
        return saved_order
```

## Пример 3: Тестирование в чистой архитектуре

Пример тестов для слоя сценариев использования:

```python
import unittest
from unittest.mock import Mock

class TestCreateTaskUseCase(unittest.TestCase):
    def setUp(self):
        self.mock_repository = Mock(spec=TaskRepository)
        self.use_case = CreateTaskUseCase(self.mock_repository)
    
    def test_create_task_success(self):
        # Подготовка
        self.mock_repository.save.return_value = Task(1, "Test Task", "Description")
        
        # Выполнение
        result = self.use_case.execute("Test Task", "Description")
        
        # Проверка
        self.assertEqual(result.title, "Test Task")
        self.assertEqual(result.description, "Description")
        self.mock_repository.save.assert_called_once()
    
    def test_create_task_empty_title_fails(self):
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            self.use_case.execute("", "Description")

class TestUpdateTaskStatusUseCase(unittest.TestCase):
    def setUp(self):
        self.mock_repository = Mock(spec=TaskRepository)
        self.use_case = UpdateTaskStatusUseCase(self.mock_repository)
    
    def test_update_task_status_success(self):
        # Подготовка
        existing_task = Task(1, "Test Task", "Description")
        self.mock_repository.find_by_id.return_value = existing_task
        self.mock_repository.save.return_value = existing_task
        
        # Выполнение
        result = self.use_case.execute(1, TaskStatus.IN_PROGRESS)
        
        # Проверка
        self.assertEqual(result.status, TaskStatus.IN_PROGRESS)
        self.mock_repository.find_by_id.assert_called_once_with(1)
        self.mock_repository.save.assert_called_once()
    
    def test_update_nonexistent_task_fails(self):
        # Подготовка
        self.mock_repository.find_by_id.return_value = None
        
        # Выполнение и проверка
        with self.assertRaises(ValueError):
            self.use_case.execute(999, TaskStatus.IN_PROGRESS)
```

## Преимущества примеров

Эти примеры демонстрируют:

1. **Четкое разделение ответственностей** между слоями
2. **Тестируемость** бизнес-логики без внешних зависимостей
3. **Независимость** бизнес-правил от фреймворков и баз данных
4. **Легкость замены** внешних зависимостей (например, смена базы данных)

## Связанные концепции

- [[Чистая-архитектура]]
- [[Слои-чистой-архитектуры]]
- [[Тестирование-в-чистой-архитектуре]]
- [[Преимущества-и-вызовы]]

## Теги

#архитектура #примеры #практика #разработка #чистая-архитектура