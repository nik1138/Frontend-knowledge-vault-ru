---
aliases: [Encapsulation, Инкапсуляция]
tags: [programming, frontend, oop, architecture]
---

# Инкапсуляция

**Инкапсуляция** — это принцип объектно-ориентированного программирования, который заключается в объединении данных и методов, работающих с этими данными, в одном классе, а также в ограничении доступа к внутренним компонентам объекта. Инкапсуляция защищает данные от непреднамеренного изменения и скрывает внутреннюю реализацию от внешнего мира.

## Основные понятия

### Что такое инкапсуляция

Инкапсуляция — это механизм, который объединяет код и данные, которыми он управляет, и защищает их от внешнего вмешательства и неправильного использования. Она обеспечивает:

1. **Сокрытие данных** - внутренние данные объекта защищены от прямого доступа
2. **Контроль доступа** - определение, кто и как может взаимодействовать с объектом
3. **Изолированность** - внутренние изменения не влияют на внешний код

```javascript
// Пример без инкапсуляции (плохо)
class BankAccount {
  constructor() {
    this.balance = 0; // Открытый доступ к балансу
    this.transactions = []; // Открытый доступ к транзакциям
  }
}

const account = new BankAccount();
account.balance = -1000; // Нарушение бизнес-логики!
account.transactions.push({ amount: -5000 }); // Нарушение целостности данных

// Пример с инкапсуляцией (хорошо)
class SecureBankAccount {
  #balance = 0; // Приватное поле (ES2022+)
  #transactions = [];
  
  constructor(initialBalance = 0) {
    if (initialBalance < 0) {
      throw new Error('Начальный баланс не может быть отрицательным');
    }
    this.#balance = initialBalance;
  }
  
  // Публичные методы для безопасного доступа
  getBalance() {
    return this.#balance;
  }
  
  deposit(amount) {
    if (amount <= 0) {
      throw new Error('Сумма депозита должна быть положительной');
    }
    this.#balance += amount;
    this.#addTransaction('deposit', amount);
  }
  
  withdraw(amount) {
    if (amount <= 0) {
      throw new Error('Сумма снятия должна быть положительной');
    }
    if (amount > this.#balance) {
      throw new Error('Недостаточно средств');
    }
    this.#balance -= amount;
    this.#addTransaction('withdraw', -amount);
  }
  
  getTransactionHistory() {
    return [...this.#transactions]; // Возвращаем копию, а не оригинальный массив
  }
  
  // Приватные методы (доступны только внутри класса)
  #addTransaction(type, amount) {
    this.#transactions.push({
      id: Date.now(),
      type,
      amount,
      timestamp: new Date(),
      balanceAfter: this.#balance
    });
  }
}

// Использование
const secureAccount = new SecureBankAccount(1000);
secureAccount.deposit(500);
console.log(secureAccount.getBalance()); // 1500
// secureAccount.#balance = -1000; // Ошибка! Приватное поле
```

## Уровни доступа

### Приватные (private) члены

```javascript
class User {
  // Приватные поля (ES2022+)
  #id;
  #password;
  #email;
  
  constructor(email, password) {
    this.#id = this.#generateId();
    this.#email = this.#validateEmail(email);
    this.#password = this.#hashPassword(password);
  }
  
  // Приватные методы
  #generateId() {
    return Date.now() + Math.random();
  }
  
  #validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Некорректный email');
    }
    return email;
  }
  
  #hashPassword(password) {
    // Упрощенная "хеш-функция" для примера
    return btoa(password); // На практике используйте bcrypt или аналоги
  }
  
  // Публичные методы
  getEmail() {
    return this.#email;
  }
  
  changeEmail(newEmail) {
    this.#email = this.#validateEmail(newEmail);
  }
  
  verifyPassword(password) {
    return this.#hashPassword(password) === this.#password;
  }
  
  // Методы доступа к приватным данным без их раскрытия
  getPublicInfo() {
    return {
      id: this.#id,
      email: this.#email
    };
  }
}
```

### Защищенные (protected) члены

```javascript
// Имитация защищенных членов через соглашения
class BaseService {
  constructor(apiUrl) {
    this._apiUrl = apiUrl; // Защищенное поле (соглашение: начинается с _)
    this._defaultHeaders = { 'Content-Type': 'application/json' };
  }
  
  // Защищенный метод (соглашение: начинается с _)
  _makeRequest(endpoint, options = {}) {
    const url = `${this._apiUrl}${endpoint}`;
    return fetch(url, {
      headers: { ...this._defaultHeaders, ...options.headers },
      ...options
    });
  }
  
  // Публичный метод
  async get(endpoint) {
    const response = await this._makeRequest(endpoint, { method: 'GET' });
    return response.json();
  }
}

class UserService extends BaseService {
  constructor(apiUrl) {
    super(apiUrl);
    this._cache = new Map(); // Защищенное поле для дочернего класса
  }
  
  async getUser(id) {
    // Используем защищенный метод родительского класса
    if (this._cache.has(id)) {
      return this._cache.get(id);
    }
    
    const user = await this._makeRequest(`/users/${id}`, { method: 'GET' });
    this._cache.set(id, user);
    return user;
  }
}
```

## Практические примеры инкапсуляции во фронтенде

### Инкапсуляция состояния компонента

```jsx
// Классовый компонент с инкапсуляцией состояния
class UserProfile extends React.Component {
  #userData = null;
  #loading = false;
  #error = null;
  
  constructor(props) {
    super(props);
    this.state = {
      // Публичное состояние, доступное для рендеринга
      displayName: '',
      displayEmail: '',
      isEditing: false
    };
  }
  
  async componentDidMount() {
    await this.#loadUserData();
  }
  
  // Приватные методы для работы с данными
  #loadUserData = async () => {
    this.#loading = true;
    this.forceUpdate(); // Обновляем компонент при изменении приватного состояния
    
    try {
      this.#userData = await fetch(`/api/users/${this.props.userId}`).then(r => r.json());
      this.setState({
        displayName: this.#userData.name,
        displayEmail: this.#userData.email
      });
    } catch (error) {
      this.#error = error.message;
    } finally {
      this.#loading = false;
      this.forceUpdate();
    }
  };
  
  #updateUserData = async (updatedData) => {
    try {
      const response = await fetch(`/api/users/${this.props.userId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedData)
      });
      
      if (response.ok) {
        this.#userData = { ...this.#userData, ...updatedData };
        this.setState({
          displayName: this.#userData.name,
          displayEmail: this.#userData.email,
          isEditing: false
        });
      }
    } catch (error) {
      console.error('Ошибка обновления данных:', error);
    }
  };
  
  handleEditToggle = () => {
    this.setState(prevState => ({ isEditing: !prevState.isEditing }));
  };
  
  handleSave = (updatedData) => {
    this.#updateUserData(updatedData);
  };
  
  render() {
    if (this.#loading) return <div>Загрузка...</div>;
    if (this.#error) return <div>Ошибка: {this.#error}</div>;
    
    const { displayName, displayEmail, isEditing } = this.state;
    
    return (
      <div className="user-profile">
        {isEditing ? (
          <UserEditForm
            name={displayName}
            email={displayEmail}
            onSave={this.handleSave}
            onCancel={this.handleEditToggle}
          />
        ) : (
          <UserDisplay
            name={displayName}
            email={displayEmail}
            onEdit={this.handleEditToggle}
          />
        )}
      </div>
    );
  }
}
```

### Инкапсуляция через замыкания

```javascript
// Инкапсуляция через замыкания (функциональный подход)
function createUserManager() {
  // Приватные данные
  let users = [];
  let currentUser = null;
  
  // Приватные методы
  const validateUser = (user) => {
    return user && user.name && user.email && user.email.includes('@');
  };
  
  const generateId = () => Date.now() + Math.random();
  
  // Публичный интерфейс
  return {
    addUser(userData) {
      if (!validateUser(userData)) {
        throw new Error('Некорректные данные пользователя');
      }
      
      const user = {
        id: generateId(),
        ...userData,
        createdAt: new Date()
      };
      
      users.push(user);
      return user;
    },
    
    getUser(id) {
      return users.find(user => user.id === id);
    },
    
    updateUser(id, updateData) {
      const index = users.findIndex(user => user.id === id);
      if (index !== -1) {
        users[index] = { ...users[index], ...updateData };
        return users[index];
      }
      return null;
    },
    
    deleteUser(id) {
      users = users.filter(user => user.id !== id);
    },
    
    getAllUsers() {
      return [...users]; // Возвращаем копию массива
    },
    
    setCurrentUser(id) {
      currentUser = this.getUser(id);
    },
    
    getCurrentUser() {
      return currentUser ? { ...currentUser } : null; // Возвращаем копию
    }
  };
}

// Использование
const userManager = createUserManager();
const newUser = userManager.addUser({ name: 'Иван', email: 'ivan@example.com' });
console.log(userManager.getAllUsers()); // [{ id: ..., name: 'Иван', ... }]
// users; // Ошибка! Переменная не доступна извне
```

### Инкапсуляция в хуках React

```jsx
// Пользовательский хук с инкапсуляцией
function useUserState(initialUserId = null) {
  // Приватное состояние (инкапсулировано в замыкании хука)
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [userData, setUserData] = useState(null);
  const [userId, setUserId] = useState(initialUserId);
  
  // Приватная функция
  const fetchUserData = async (id) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch(`/api/users/${id}`);
      if (!response.ok) throw new Error('Не удалось загрузить пользователя');
      const data = await response.json();
      setUserData(data);
    } catch (err) {
      setError(err.message);
      setUserData(null);
    } finally {
      setLoading(false);
    }
  };
  
  // Публичный интерфейс
  const loadUser = useCallback((id) => {
    setUserId(id);
    fetchUserData(id);
  }, []);
  
  const updateUser = useCallback(async (updateData) => {
    if (!userData) return;
    
    try {
      const response = await fetch(`/api/users/${userData.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData)
      });
      
      if (response.ok) {
        const updatedData = await response.json();
        setUserData(updatedData);
      }
    } catch (err) {
      setError(err.message);
    }
  }, [userData]);
  
  const logout = useCallback(() => {
    setUserId(null);
    setUserData(null);
  }, []);
  
  return {
    user: userData,
    loading,
    error,
    userId,
    loadUser,
    updateUser,
    logout
  };
}

// Использование
function UserProfile({ userId }) {
  const { user, loading, error, loadUser, updateUser } = useUserState(userId);
  
  useEffect(() => {
    if (userId) {
      loadUser(userId);
    }
  }, [userId, loadUser]);
  
  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  if (!user) return <div>Пользователь не найден</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => updateUser({ name: 'Новое имя' })}>
        Обновить
      </button>
    </div>
  );
}
```

## Инкапсуляция в архитектуре приложения

### Модуль с инкапсуляцией

```javascript
// Модуль аутентификации с инкапсуляцией
const AuthModule = (() => {
  // Приватные данные
  let currentUser = null;
  let token = null;
  const storageKey = 'auth_token';
  
  // Приватные методы
  const saveToken = (t) => {
    token = t;
    localStorage.setItem(storageKey, t);
  };
  
  const loadToken = () => {
    return localStorage.getItem(storageKey);
  };
  
  const validateToken = (t) => {
    // Простая проверка токена (в реальности будет сложнее)
    return t && t.length > 10;
  };
  
  // Публичный интерфейс
  return {
    async login(credentials) {
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        });
        
        if (!response.ok) throw new Error('Неверные учетные данные');
        
        const { token: newToken, user } = await response.json();
        
        if (validateToken(newToken)) {
          saveToken(newToken);
          currentUser = user;
          return { success: true, user };
        } else {
          throw new Error('Некорректный токен');
        }
      } catch (error) {
        return { success: false, error: error.message };
      }
    },
    
    logout() {
      token = null;
      currentUser = null;
      localStorage.removeItem(storageKey);
    },
    
    isAuthenticated() {
      if (!token) {
        token = loadToken();
      }
      return validateToken(token);
    },
    
    getCurrentUser() {
      return currentUser ? { ...currentUser } : null; // Возвращаем копию
    },
    
    getAuthToken() {
      if (!token) {
        token = loadToken();
      }
      return token;
    }
  };
})();

// Использование
AuthModule.login({ email: 'user@example.com', password: 'password' })
  .then(result => {
    if (result.success) {
      console.log('Успешный вход:', result.user);
    } else {
      console.log('Ошибка входа:', result.error);
    }
  });
```

## Преимущества инкапсуляции

### 1. Безопасность данных

```javascript
// Без инкапсуляции - данные уязвимы
class ShoppingCart {
  constructor() {
    this.items = [];
    this.total = 0; // Может быть изменен напрямую
  }
}

const cart = new ShoppingCart();
cart.total = -1000; // Нарушение бизнес-логики!

// С инкапсуляцией - данные защищены
class SecureCart {
  #items = [];
  #total = 0;
  
  get total() {
    return this.#total;
  }
  
  addItem(item) {
    if (item.price > 0) {
      this.#items.push(item);
      this.#recalculateTotal();
    }
  }
  
  #recalculateTotal() {
    this.#total = this.#items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

### 2. Контроль над изменениями

```javascript
class DataValidator {
  #rules = new Map();
  #validationLog = [];
  
  addRule(fieldName, validator) {
    this.#rules.set(fieldName, validator);
  }
  
  validate(data) {
    const errors = {};
    
    for (const [field, validator] of this.#rules) {
      const error = validator(data[field]);
      if (error) {
        errors[field] = error;
        this.#logValidationError(field, error);
      }
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors,
      validationLog: [...this.#validationLog] // Возвращаем копию лога
    };
  }
  
  #logValidationError(field, error) {
    this.#validationLog.push({
      field,
      error,
      timestamp: new Date()
    });
  }
  
  getValidationLog() {
    return [...this.#validationLog]; // Защита оригинального лога
  }
}
```

### 3. Легкость сопровождения

```javascript
// Инкапсуляция позволяет изменять внутреннюю реализацию без изменения интерфейса
class Cache {
  constructor(maxSize = 100) {
    this.#maxSize = maxSize;
    this.#data = new Map(); // Можно изменить на другую структуру данных
    this.#accessOrder = []; // Для LRU алгоритма
  }
  
  get(key) {
    if (this.#data.has(key)) {
      this.#updateAccessOrder(key);
      return this.#data.get(key);
    }
    return undefined;
  }
  
  set(key, value) {
    if (this.#data.size >= this.#maxSize) {
      this.#evictOldest(); // LRU eviction
    }
    
    this.#data.set(key, value);
    this.#accessOrder.push(key);
  }
  
  #updateAccessOrder(key) {
    const index = this.#accessOrder.indexOf(key);
    if (index !== -1) {
      this.#accessOrder.splice(index, 1);
      this.#accessOrder.push(key);
    }
  }
  
  #evictOldest() {
    const oldestKey = this.#accessOrder.shift();
    if (oldestKey !== undefined) {
      this.#data.delete(oldestKey);
    }
  }
}
```

## Связанные концепции

- [[Объектно-ориентированное программирование]] - основа для понимания инкапсуляции
- [[Абстракция]] - тесно связана с инкапсуляцией
- [[Модульность]] - модули как форма инкапсуляции функциональности
- [[Компонентный-подход]] - компоненты как инкапсулированные единицы UI
- [[Инкапсуляция]] - ключевой принцип обеспечения целостности данных

## Лучшие практики

1. **Скрывайте внутренние данные** - используйте приватные поля и методы
2. **Предоставляйте четкий публичный интерфейс** - только необходимые методы доступны извне
3. **Валидируйте входные данные** - проверяйте данные в публичных методах
4. **Возвращайте копии, а не оригиналы** - защищайте внутренние структуры данных
5. **Используйте замыкания для инкапсуляции** - в функциональном программировании
6. **Документируйте публичный интерфейс** - четко описывайте, что делает каждый метод

## Заключение

Инкапсуляция является фундаментальным принципом, обеспечивающим безопасность, надежность и поддерживаемость кода. В фронтенд-разработке она особенно важна для защиты состояния приложения, управления данными и создания надежных компонентов. Правильное применение инкапсуляции делает приложения более стабильными и легкими в сопровождении.