---
aliases: [Приватные поля, Приватные методы, #private-fields, #private-methods]
tags: [programming, javascript, oop, encapsulation, es2022]
---

# Приватные поля и методы

Приватные поля и методы - это механизм в JavaScript, появившийся в ES2022, который позволяет скрывать внутренние детали реализации классов от внешнего доступа. Это ключевой элемент инкапсуляции, одного из основных принципов объектно-ориентированного программирования.

## Обзор приватных полей и методов

Приватные поля и методы в JavaScript обозначаются префиксом `#` и доступны только внутри класса, в котором они определены. Они не могут быть доступны или изменены извне, что обеспечивает более строгую инкапсуляцию по сравнению с традиционными подходами.

## Синтаксис и основы

### Приватные поля

```javascript
class BankAccount {
  // Приватные поля
  #balance = 0;
  #accountNumber;
  #transactionHistory = [];

  constructor(accountNumber, initialBalance = 0) {
    this.#accountNumber = accountNumber;
    if (initialBalance > 0) {
      this.#balance = initialBalance;
    }
  }

  // Публичные методы для взаимодействия
  getBalance() {
    return this.#balance;
  }

  deposit(amount) {
    if (this.#validateAmount(amount)) {
      this.#balance += amount;
      this.#addTransaction('deposit', amount);
      return true;
    }
    return false;
  }

  withdraw(amount) {
    if (this.#validateAmount(amount) && amount <= this.#balance) {
      this.#balance -= amount;
      this.#addTransaction('withdraw', amount);
      return true;
    }
    return false;
  }

  // Приватные методы
  #validateAmount(amount) {
    return typeof amount === 'number' && amount > 0;
  }

  #addTransaction(type, amount) {
    this.#transactionHistory.push({
      type,
      amount,
      timestamp: new Date(),
      balanceAfter: this.#balance
    });
  }

  // Публичный метод для получения истории (возвращаем копию для безопасности)
  getTransactionHistory() {
    return [...this.#transactionHistory];
  }
}

// Использование
const account = new BankAccount('ACC001', 1000);
console.log(account.getBalance()); // 1000
account.deposit(500);
console.log(account.getBalance()); // 1500

// Следующие строки вызовут ошибки:
// console.log(account.#balance); // SyntaxError
// account.#validateAmount(100); // SyntaxError
```

## Приватные методы

```javascript
class DataProcessor {
  #data = [];
  #processingRules = new Map();
  #isInitialized = false;

  constructor() {
    this.#initializeProcessingRules();
  }

  #initializeProcessingRules() {
    this.#processingRules.set('uppercase', (str) => str.toUpperCase());
    this.#processingRules.set('reverse', (str) => str.split('').reverse().join(''));
    this.#processingRules.set('trim', (str) => str.trim());
    this.#isInitialized = true;
  }

  addData(item) {
    if (this.#isInitialized && this.#validateItem(item)) {
      this.#data.push(item);
    }
  }

  processItem(item, rules) {
    if (!this.#isInitialized) {
      throw new Error('Processor not initialized');
    }

    let processedItem = item;
    
    for (const rule of rules) {
      const processor = this.#processingRules.get(rule);
      if (processor) {
        processedItem = processor(processedItem);
      }
    }
    
    return processedItem;
  }

  #validateItem(item) {
    return typeof item === 'string' && item.length > 0;
  }

  // Приватный геттер
  get #dataSize() {
    return this.#data.length;
  }

  getDataSize() {
    return this.#dataSize; // доступ к приватному геттеру
  }
}

const processor = new DataProcessor();
processor.addData('hello world');
console.log(processor.processItem('  test  ', ['trim', 'uppercase'])); // 'TEST'
```

## Приватные геттеры и сеттеры

```javascript
class Temperature {
  #celsius = 0;

  constructor(celsius = 0) {
    this.celsius = celsius; // использует сеттер
  }

  // Приватный геттер
  get #kelvin() {
    return this.#celsius + 273.15;
  }

  // Приватный геттер
  get #fahrenheit() {
    return (this.#celsius * 9/5) + 32;
  }

  // Публичный геттер
  get celsius() {
    return this.#celsius;
  }

  // Публичный сеттер с валидацией
  set celsius(value) {
    if (typeof value !== 'number') {
      throw new Error('Temperature must be a number');
    }
    // Абсолютный ноль
    if (value < -273.15) {
      throw new Error('Temperature cannot be below absolute zero');
    }
    this.#celsius = value;
  }

  // Публичные геттеры для других единиц
  get kelvin() {
    return this.#kelvin;
  }

  get fahrenheit() {
    return this.#fahrenheit;
  }

  // Метод для преобразования из других единиц
  setFromFahrenheit(fahrenheit) {
    this.celsius = (fahrenheit - 32) * 5/9;
  }

  setFromKelvin(kelvin) {
    this.celsius = kelvin - 273.15;
  }
}

const temp = new Temperature(25);
console.log(temp.celsius);    // 25
console.log(temp.kelvin);     // 298.15
console.log(temp.fahrenheit); // 77

temp.setFromFahrenheit(86);
console.log(temp.celsius); // 30
```

## Приватные статические поля и методы

```javascript
class ApiClient {
  // Приватное статическое поле
  static #apiKey;
  static #baseUrl = 'https://api.example.com';
  static #requestCount = 0;

  constructor(apiKey) {
    ApiClient.#apiKey = apiKey;
  }

  // Приватный статический метод
  static #makeRequest(endpoint, options = {}) {
    ApiClient.#requestCount++;
    
    return fetch(`${ApiClient.#baseUrl}/${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${ApiClient.#apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
  }

  // Приватный статический метод для логирования
  static #logRequest(endpoint, method = 'GET') {
    console.log(`Запрос ${method} к ${endpoint}, всего запросов: ${ApiClient.#requestCount}`);
  }

  async getUser(userId) {
    ApiClient.#logRequest(`users/${userId}`, 'GET');
    const response = await ApiClient.#makeRequest(`users/${userId}`);
    return response.json();
  }

  async createUser(userData) {
    ApiClient.#logRequest('users', 'POST');
    const response = await ApiClient.#makeRequest('users', {
      method: 'POST',
      body: JSON.stringify(userData)
    });
    return response.json();
  }

  // Публичный метод для получения статистики
  static getRequestCount() {
    return ApiClient.#requestCount;
  }
}

// Использование
const client = new ApiClient('your-api-key');
// client.#makeRequest(); // Ошибка - приватный метод
```

## Сравнение с традиционными подходами

### До ES2022 (с замыканиями)

```javascript
// Традиционный подход с замыканиями
function createCounter(initialValue = 0) {
  let value = initialValue; // приватная переменная
  
  return {
    increment() {
      value++;
      return value;
    },
    decrement() {
      value--;
      return value;
    },
    getValue() {
      return value;
    }
  };
}
```

### После ES2022 (с приватными полями)

```javascript
// Современный подход с приватными полями
class Counter {
  #value;

  constructor(initialValue = 0) {
    this.#value = initialValue;
  }

  increment() {
    this.#value++;
    return this.#value;
  }

  decrement() {
    this.#value--;
    return this.#value;
  }

  getValue() {
    return this.#value;
  }
}
```

## Практические применения

### Инкапсуляция конфигурации

```javascript
class DatabaseConnection {
  #host;
  #port;
  #username;
  #password;
  #isConnected = false;
  #connectionOptions;

  constructor(config) {
    this.#validateConfig(config);
    this.#host = config.host;
    this.#port = config.port;
    this.#username = config.username;
    this.#password = config.password;
    this.#connectionOptions = { ...config.options };
  }

  #validateConfig(config) {
    const required = ['host', 'port', 'username', 'password'];
    for (const field of required) {
      if (!(field in config)) {
        throw new Error(`Missing required config field: ${field}`);
      }
    }
  }

  async connect() {
    // Инкапсулированная логика подключения
    console.log(`Connecting to ${this.#host}:${this.#port}`);
    this.#isConnected = true;
  }

  async disconnect() {
    console.log('Disconnecting...');
    this.#isConnected = false;
  }

  isConnected() {
    return this.#isConnected;
  }

  // Публичный метод без раскрытия внутренних деталей
  getConnectionInfo() {
    return {
      host: this.#host,
      port: this.#port,
      isConnected: this.#isConnected
    };
  }
}
```

### Защита внутреннего состояния

```javascript
class StateManager {
  #state = {};
  #middlewares = [];
  #listeners = [];
  #history = [];
  #historyIndex = -1;

  constructor(initialState = {}) {
    this.#state = { ...initialState };
    this.#saveToHistory();
  }

  #saveToHistory() {
    this.#history = this.#history.slice(0, this.#historyIndex + 1);
    this.#history.push(JSON.stringify(this.#state));
    this.#historyIndex = this.#history.length - 1;
  }

  #applyMiddlewares(action) {
    let modifiedAction = action;
    for (const middleware of this.#middlewares) {
      modifiedAction = middleware(modifiedAction);
    }
    return modifiedAction;
  }

  #notifyListeners() {
    for (const listener of this.#listeners) {
      listener(this.#state);
    }
  }

  setState(updates) {
    const action = { type: 'SET_STATE', updates };
    const processedAction = this.#applyMiddlewares(action);
    
    this.#state = { ...this.#state, ...processedAction.updates };
    this.#saveToHistory();
    this.#notifyListeners();
  }

  subscribe(listener) {
    this.#listeners.push(listener);
    // Возвращаем функцию для отписки
    return () => {
      const index = this.#listeners.indexOf(listener);
      if (index > -1) {
        this.#listeners.splice(index, 1);
      }
    };
  }

  addMiddleware(middleware) {
    this.#middlewares.push(middleware);
  }

  undo() {
    if (this.#historyIndex > 0) {
      this.#historyIndex--;
      this.#state = JSON.parse(this.#history[this.#historyIndex]);
      this.#notifyListeners();
    }
  }

  redo() {
    if (this.#historyIndex < this.#history.length - 1) {
      this.#historyIndex++;
      this.#state = JSON.parse(this.#history[this.#historyIndex]);
      this.#notifyListeners();
    }
  }

  getState() {
    return { ...this.#state }; // возвращаем копию для защиты
  }
}
```

## Ограничения и особенности

1. **Синтаксическая проверка**: Попытка доступа к приватному полю/методу извне вызывает `SyntaxError` на этапе парсинга
2. **Наследование**: Приватные поля и методы не наследуются подклассами
3. **Сериализация**: Приватные поля не включаются в `JSON.stringify()`
4. **Отладка**: Приватные поля могут быть менее доступны для инструментов отладки

## Практические рекомендации

1. **Используйте приватные поля для внутреннего состояния**, которое не должно изменяться извне
2. **Создавайте публичные методы для взаимодействия** с приватным состоянием
3. **Используйте приватные методы для вспомогательной логики**, которая не должна быть частью публичного API
4. **Документируйте публичный интерфейс** класса, объясняя, как безопасно взаимодействовать с объектом
5. **Рассмотрите использование TypeScript** для дополнительной защиты типов

## Заключение

Приватные поля и методы в JavaScript обеспечивают настоящую инкапсуляцию на уровне языка, позволяя создавать более безопасные и предсказуемые классы. Они предотвращают случайное изменение внутреннего состояния и обеспечивают четкое разделение между внутренней реализацией и публичным интерфейсом.

## См. также
- [[Инкапсуляция-в-JavaScript]]
- [[Инкапсуляция-в-React]]
- [[Инкапсуляция-в-Vue]]
- [[Инкапсуляция-в-Svelte]]
- [[Объектно-ориентированное программирование в JavaScript]]
