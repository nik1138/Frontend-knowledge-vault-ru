---
aliases: [Пользовательские директивы, Custom Directives, Директивы разработчика]
tags: [frontend, directives, vue, svelte, angular, javascript]
---

# Пользовательские директивы

## Обзор

Пользовательские директивы позволяют разработчикам расширять функциональность шаблонов, добавляя собственное поведение к DOM-элементам. Это мощный инструмент, который позволяет инкапсулировать сложную логику работы с DOM в переиспользуемую форму.

## Пользовательские директивы в Vue

### Создание пользовательской директивы

В Vue пользовательские директивы можно создавать как глобально, так и локально в компоненте.

#### Глобальные директивы

```javascript
// Регистрация глобальной директивы
Vue.directive('focus', {
  // Вызывается перед вставкой узла в DOM
  created(el, binding, vnode, prevVnode) {
    console.log('created hook');
  },
  
  // Вызывается сразу после вставки узла в DOM
  mounted(el, binding, vnode) {
    el.focus();
  },
  
  // Вызывается перед обновлением содержащего узла
  beforeUpdate(el, binding, vnode, prevVnode) {
    console.log('beforeUpdate hook');
  },
  
  // Вызывается после обновления содержащего узла
  updated(el, binding, vnode, prevVnode) {
    if (binding.value !== binding.oldValue) {
      // Логика при изменении значения
      console.log('Directive value changed');
    }
  },
  
  // Вызывается перед разрушением узла
  beforeUnmount(el, binding, vnode) {
    console.log('beforeUnmount hook');
  },
  
  // Вызывается после разрушения узла
  unmounted(el, binding, vnode) {
    console.log('unmounted hook');
  }
});

// Использование в шаблоне
<template>
  <input v-focus />
</template>
```

#### Локальные директивы

```javascript
export default {
  name: 'MyComponent',
  directives: {
    focus: {
      mounted(el) {
        el.focus();
      }
    },
    
    // Сокращенная запись для хука mounted
    color: {
      mounted(el, binding) {
        el.style.color = binding.value;
      },
      updated(el, binding) {
        el.style.color = binding.value;
      }
    }
  },
  template: `
    <div>
      <input v-focus />
      <p v-color="'red'">Текст красного цвета</p>
    </div>
  `
}
```

### Параметры хука директивы

Каждый хук директивы получает следующие параметры:

- `el` - элемент, к которому привязана директива
- `binding` - объект, содержащий свойства:
  - `value` - значение, переданное директиве
  - `oldValue` - предыдущее значение (только в `updated` и `componentUpdated`)
  - `arg` - аргумент, переданный директиве
  - `modifiers` - объект, содержащий модификаторы
  - `instance` - экземпляр компонента
  - `dir` - определение директивы
- `vnode` - виртуальный узел, управляемый директивой
- `prevVnode` - предыдущий виртуальный узел (доступен в `updated` и `componentUpdated`)

```javascript
Vue.directive('demo', {
  mounted(el, binding, vnode) {
    console.log('Элемент:', el);
    console.log('Значение:', binding.value);
    console.log('Аргумент:', binding.arg);
    console.log('Модификаторы:', binding.modifiers);
  }
});

// Использование:
// <div v-demo:foo.bar.baz="message"></div>
// binding.arg === 'foo'
// binding.modifiers === { bar: true, baz: true }
```

### Примеры полезных пользовательских директив

#### Директива для автоскрытия (click-outside)

```javascript
export const clickOutside = {
  beforeMount(el, binding) {
    el.clickOutsideEvent = function(event) {
      // Проверяем, находится ли клик вне элемента и его потомков
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.addEventListener('click', el.clickOutsideEvent);
  },
  unmounted(el) {
    document.removeEventListener('click', el.clickOutsideEvent);
  }
};

// Использование
export default {
  directives: {
    clickOutside
  },
  data() {
    return {
      isDropdownOpen: false
    };
  },
  methods: {
    closeDropdown() {
      this.isDropdownOpen = false;
    }
  }
}
```

```vue
<template>
  <div 
    v-click-outside="closeDropdown"
    class="dropdown"
    v-show="isDropdownOpen"
  >
    <button @click="toggleDropdown">Меню</button>
    <ul v-show="isDropdownOpen">
      <li>Пункт 1</li>
      <li>Пункт 2</li>
    </ul>
  </div>
</template>
```

#### Директива для lazy loading изображений

```javascript
export const lazyLoad = {
  mounted(el, binding) {
    const img = new Image();
    
    // Показываем плейсхолдер
    el.src = binding.value.placeholder || 'placeholder.jpg';
    
    // Загружаем настоящее изображение
    img.onload = () => {
      el.src = binding.value.src;
      el.classList.add('loaded');
    };
    
    img.src = binding.value.src;
  },
  updated(el, binding) {
    if (binding.value.src !== binding.oldValue.src) {
      el.src = binding.value.placeholder || 'placeholder.jpg';
      const img = new Image();
      img.onload = () => {
        el.src = binding.value.src;
      };
      img.src = binding.value.src;
    }
  }
};
```

#### Директива для ограничения ввода (input mask)

```javascript
export const inputMask = {
  mounted(el, binding) {
    if (el.tagName !== 'INPUT') {
      console.warn('v-input-mask должен использоваться только с input элементами');
      return;
    }
    
    const mask = binding.value;
    
    el.addEventListener('input', function(e) {
      let value = e.target.value;
      
      // Применяем маску в зависимости от типа
      if (mask.type === 'phone') {
        value = value.replace(/\D/g, '').substring(0, 10);
        value = value.replace(/(\d{3})(\d)/, '($1) $2');
        value = value.replace(/(\d{3})(\d{3})/, '$1-$2');
        value = value.replace(/(\d{4})/, '$1');
      } else if (mask.type === 'date') {
        value = value.replace(/\D/g, '').substring(0, 8);
        value = value.replace(/(\d{2})(\d)/, '$1/$2');
        value = value.replace(/(\d{2})(\d{4})/, '$1/$2');
      }
      
      e.target.value = value;
    });
  }
};
```

## Пользовательские директивы в Angular

В Angular пользовательские директивы создаются как классы с декоратором `@Directive`.

```typescript
import { Directive, ElementRef, Input, OnInit, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective implements OnInit {
  @Input() appHighlight: string = 'yellow';
  @Input() defaultColor: string = 'white';

  constructor(private el: ElementRef) {}

  ngOnInit() {
    this.highlight(this.appHighlight || this.defaultColor);
  }

  @HostListener('mouseenter') onMouseEnter() {
    this.highlight(this.appHighlight || this.defaultColor);
  }

  @HostListener('mouseleave') onMouseLeave() {
    this.highlight(this.defaultColor);
  }

  private highlight(color: string) {
    this.el.nativeElement.style.backgroundColor = color;
  }
}
```

Использование в шаблоне:

```html
<p appHighlight="yellow">Обычное выделение</p>
<p [appHighlight]="'orange'" [defaultColor]="'lightblue'">Выделение с настройками</p>
```

## Пользовательские директивы в Svelte

В Svelte пользовательские директивы реализуются как функции, возвращающие объект с определенными хуками:

```javascript
// focus.js
export function focus(node, value) {
  if (value) {
    node.focus();
  }
  
  return {
    update(newValue) {
      if (newValue) {
        node.focus();
      }
    }
  };
}

// Использование в компоненте
<script>
  import { focus } from './focus.js';
  let shouldFocus = true;
</script>

<input use:focus={shouldFocus} />
```

Более сложный пример с обработкой событий:

```javascript
// tooltip.js
export function tooltip(node, text) {
  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip';
  tooltip.textContent = text;
  tooltip.style.cssText = `
    position: absolute;
    background: #333;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1000;
    display: none;
  `;
  
  document.body.appendChild(tooltip);
  
  const showTooltip = (e) => {
    tooltip.style.display = 'block';
    tooltip.style.left = e.pageX + 10 + 'px';
    tooltip.style.top = e.pageY - 30 + 'px';
  };
  
  const hideTooltip = () => {
    tooltip.style.display = 'none';
  };
  
  node.addEventListener('mouseenter', showTooltip);
  node.addEventListener('mouseleave', hideTooltip);
  
  return {
    update(newText) {
      tooltip.textContent = newText;
    },
    destroy() {
      node.removeEventListener('mouseenter', showTooltip);
      node.removeEventListener('mouseleave', hideTooltip);
      document.body.removeChild(tooltip);
    }
  };
}
```

## Лучшие практики для пользовательских директив

### 1. Ограниченная ответственность

Каждая директива должна решать одну конкретную задачу:

```javascript
// Плохо - директива делает слишком много
Vue.directive('complex-behavior', {
  // Логика для фокуса, стилей, обработки событий и т.д.
});

// Хорошо - каждая директива решает свою задачу
Vue.directive('focus', { /* только фокус */ });
Vue.directive('highlight', { /* только подсветка */ });
```

### 2. Чистка ресурсов

Обязательно очищайте ресурсы в хуках `unmounted`, `beforeUnmount` или `destroy`:

```javascript
Vue.directive('resize', {
  mounted(el, binding) {
    const handler = () => {
      binding.value(); // вызов переданной функции
    };
    
    window.addEventListener('resize', handler);
    
    // Сохраняем обработчик для последующей очистки
    el._resizeHandler = handler;
  },
  unmounted(el) {
    window.removeEventListener('resize', el._resizeHandler);
    delete el._resizeHandler;
  }
});
```

### 3. Проверка условий

Проверяйте, что элемент и параметры существуют:

```javascript
Vue.directive('visible', {
  mounted(el, binding) {
    if (!binding.value) {
      el.style.display = 'none';
    }
  },
  updated(el, binding) {
    // Проверяем, что значение изменилось
    if (binding.value !== binding.oldValue) {
      el.style.display = binding.value ? 'block' : 'none';
    }
  }
});
```

### 4. Использование модификаторов

Используйте модификаторы для настройки поведения директивы:

```javascript
Vue.directive('keydown', {
  mounted(el, binding) {
    const keys = binding.arg ? binding.arg.split('.') : [];
    const modifiers = binding.modifiers;
    
    const handler = (e) => {
      if (keys.length && !keys.includes(e.key.toLowerCase())) {
        return;
      }
      
      if (modifiers.ctrl && !e.ctrlKey) return;
      if (modifiers.shift && !e.shiftKey) return;
      if (modifiers.alt && !e.altKey) return;
      
      binding.value(e);
    };
    
    el.addEventListener('keydown', handler);
    el._keydownHandler = handler;
  },
  unmounted(el) {
    el.removeEventListener('keydown', el._keydownHandler);
  }
});

// Использование: v-keydown.a.ctrl.shift="handler"
```

## Распространенные ошибки

### 1. Неправильная очистка обработчиков событий

```javascript
// Плохо - утечка памяти
Vue.directive('event', {
  mounted(el, binding) {
    el.addEventListener('click', binding.value);
  }
  // Нет очистки!
});

// Хорошо - правильная очистка
Vue.directive('event', {
  mounted(el, binding) {
    el.addEventListener('click', binding.value);
    el._clickHandler = binding.value;
  },
  unmounted(el) {
    el.removeEventListener('click', el._clickHandler);
  }
});
```

### 2. Неправильная работа с DOM

```javascript
// Плохо - прямое изменение DOM может конфликтовать с виртуальным DOM
Vue.directive('style', {
  mounted(el, binding) {
    el.setAttribute('style', binding.value);
  }
});

// Хорошо - использование Vue API для изменения стилей
Vue.directive('style', {
  mounted(el, binding) {
    Object.keys(binding.value).forEach(prop => {
      el.style[prop] = binding.value[prop];
    });
  }
});
```

## Примеры комплексных директив

### Директива для drag-and-drop

```javascript
Vue.directive('drag', {
  mounted(el, binding) {
    let startX, startY, initialX, initialY;
    
    const handleDragStart = (e) => {
      e.preventDefault();
      
      initialX = el.offsetLeft;
      initialY = el.offsetTop;
      startX = e.clientX;
      startY = e.clientY;
      
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', handleDragEnd);
    };
    
    const handleDrag = (e) => {
      e.preventDefault();
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      el.style.left = initialX + deltaX + 'px';
      el.style.top = initialY + deltaY + 'px';
    };
    
    const handleDragEnd = () => {
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', handleDragEnd);
    };
    
    el.addEventListener('mousedown', handleDragStart);
    
    // Сохраняем обработчики для очистки
    el._dragHandlers = { handleDragStart, handleDrag, handleDragEnd };
  },
  unmounted(el) {
    if (el._dragHandlers) {
      const { handleDragStart, handleDrag, handleDragEnd } = el._dragHandlers;
      
      el.removeEventListener('mousedown', handleDragStart);
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', handleDragEnd);
      
      delete el._dragHandlers;
    }
  }
});
```

### Директива для debounced событий

```javascript
Vue.directive('debounce', {
  mounted(el, binding) {
    const [event, callback, delay = 300] = binding.value;
    
    let timeoutId;
    
    const debouncedCallback = (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => callback.apply(this, args), delay);
    };
    
    el.addEventListener(event, debouncedCallback);
    el._debounceHandler = debouncedCallback;
  },
  unmounted(el) {
    if (el._debounceHandler) {
      // Удаление обработчика
      // Для полной очистки нужно хранить и событие
      delete el._debounceHandler;
    }
  }
});

// Использование: v-debounce="['input', handleInput, 500]"
```

> [!tip] 
> При создании пользовательских директив всегда учитывайте жизненный цикл компонента и правильно очищайте ресурсы, чтобы избежать утечек памяти.

> [!warning] 
> Избегайте сложной логики в директивах - если поведение становится слишком сложным, возможно, лучше создать компонент.

## См. также

- [[Директивы-в-Vue]]
- [[Директивы-в-Svelte]]
- [[Директивы-в-Angular]]
- [[Встроенные-директивы]]