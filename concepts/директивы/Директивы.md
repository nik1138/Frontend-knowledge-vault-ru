---
aliases: ["Директивы в фронтенде", "Frontend Directives", "Directive Patterns"]
tags: 
  - frontend
  - architecture
  - angular
  - vue
  - react
  - javascript
---

# Директивы в Фронтенд-Разработке

## Обзор

**Директивы** - это мощный паттерн программирования в фронтенд-фреймворках, который позволяет расширять функциональность HTML-элементов или компонентов. Директивы определяют поведение, манипуляции с DOM, или другие эффекты, которые должны происходить при рендеринге компонента. Они позволяют разработчикам инкапсулировать сложную логику в переиспользуемых блоках, которые можно применять к различным элементам пользовательского интерфейса.

## Основные концепции

### Что такое директивы

Директивы - это инструкции, встроенные в разметку, которые сообщают фреймворку о необходимости выполнить определенные действия с DOM-элементом. Они могут быть:

- **Атрибутами** в HTML-разметке
- **Манипуляция DOM** без изменения логики компонента
- **Переиспользуемыми функциями** поведения

### Преимущества использования директив

- **Разделение ответственности** - логика представления отделена от бизнес-логики
- **Переиспользуемость** - однажды созданную директиву можно использовать в разных частях приложения
- **Чистота компонентов** - уменьшает сложность компонентов за счет выноса вспомогательной логики

## Директивы в различных фреймворках

### Angular

Angular имеет встроенную систему директив с тремя основными типами:

#### 1. Компонентные директивы

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  template: `<h1>Это компонентная директива</h1>`
})
export class ExampleComponent { }
```

#### 2. Атрибутные директивы

```typescript
import { Directive, ElementRef, OnInit } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective implements OnInit {
  constructor(private el: ElementRef) {}

  ngOnInit() {
    this.el.nativeElement.style.backgroundColor = 'yellow';
  }
}
```

Использование в шаблоне:
```html
<p appHighlight>Этот текст будет выделен желтым цветом</p>
```

#### 3. Структурные директивы

```typescript
// *ngIf - структурная директива
<div *ngIf="isVisible">Содержимое отображается при условии</div>

// *ngFor - структурная директива
<div *ngFor="let item of items">{{ item }}</div>
```

### Vue.js

В Vue.js директивы обозначаются префиксом `v-`:

#### Встроенные директивы

```vue
<template>
  <!-- Условный рендеринг -->
  <div v-if="show">Отображается при условии</div>
  
  <!-- Циклы -->
  <div v-for="item in items" :key="item.id">{{ item.name }}</div>
  
  <!-- Двусторонняя привязка -->
  <input v-model="message" />
  
  <!-- Обработка событий -->
  <button v-on:click="handleClick">Нажми меня</button>
</template>
```

#### Пользовательские директивы

```javascript
// Глобальная директива
Vue.directive('focus', {
  mounted(el) {
    el.focus();
  }
});

// Локальная директива в компоненте
export default {
  directives: {
    focus: {
      mounted(el) {
        el.focus();
      }
    }
  }
}
```

Использование:
```vue
<input v-focus />
```

### React

React не имеет встроенной концепции директив, но концепцию можно реализовать через:

#### 1. HOC (Higher-Order Components)

```javascript
function withLogging(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Компонент рендерится');
    return <WrappedComponent {...props} />;
  }
}

const EnhancedButton = withLogging(Button);
```

#### 2. Пользовательские хуки

```javascript
function useFocus() {
  const ref = useRef();
  
  useEffect(() => {
    ref.current?.focus();
  }, []);
  
  return ref;
}

// Использование
function MyInput() {
  const inputRef = useFocus();
  return <input ref={inputRef} />;
}
```

#### 3. Render Props

```javascript
class FocusManager extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  
  componentDidMount() {
    this.inputRef.current.focus();
  }
  
  render() {
    return this.props.children(this.inputRef);
  }
}

// Использование
<FocusManager>
  {inputRef => <input ref={inputRef} />}
</FocusManager>
```

## Практические примеры использования

### 1. Директива для доступности (Angular)

```typescript
@Directive({
  selector: '[appA11yTitle]'
})
export class A11yTitleDirective {
  @Input() appA11yTitle: string;

  constructor(private el: ElementRef, private renderer: Renderer2) {}

  ngOnInit() {
    // Добавляем заголовок для улучшения доступности
    this.renderer.setAttribute(this.el.nativeElement, 'title', this.appA11yTitle);
    this.renderer.setAttribute(this.el.nativeElement, 'aria-label', this.appA11yTitle);
  }
}
```

### 2. Директива для индикатора загрузки (Vue)

```javascript
export default {
  name: 'Loading',
  directives: {
    loading: {
      mounted(el, binding) {
        if (binding.value) {
          el.classList.add('loading');
        }
      },
      updated(el, binding) {
        if (binding.value !== binding.oldValue) {
          el.classList.toggle('loading', binding.value);
        }
      }
    }
  }
}
```

### 3. Директива для отслеживания прокрутки (Angular)

```typescript
@Directive({
  selector: '[appScrollSpy]'
})
export class ScrollSpyDirective {
  @Output() sectionChange = new EventEmitter<string>();

  constructor(private el: ElementRef) {}

  @HostListener('window:scroll', [])
  onWindowScroll() {
    // Логика отслеживания текущей видимой секции
    const sections = this.el.nativeElement.querySelectorAll('section');
    sections.forEach(section => {
      const rect = section.getBoundingClientRect();
      if (rect.top <= 100 && rect.bottom >= 100) {
        this.sectionChange.emit(section.id);
      }
    });
  }
}
```

## Лучшие практики

### 1. Именование директив

- Используйте осмысленные префиксы для избежания конфликта с нативными атрибутами
- В Angular используйте префиксы, например `app` для приложения
- В Vue используйте префиксы для организации, например `v-focus`, `v-permission`

### 2. Управление ресурсами

- Всегда очищайте подписки и слушатели событий в директивах
- Используйте соответствующие хуки жизненного цикла для очистки

### 3. Тестируемость

- Пишите тесты для директив отдельно от компонентов
- Проверяйте как поведение, так и влияние на DOM

## Сравнение с другими паттернами

| Паттерн | Преимущества | Недостатки | Когда использовать |
|---------|--------------|------------|-------------------|
| Директивы | Чистый DOM, переиспользуемость | Сложность в отладке | Когда нужно изменить поведение элемента |
| Компоненты | Инкапсуляция, переиспользуемость | Больше кода для простых задач | Когда нужен сложный UI |
| Хуки | Логика в функциональных компонентах | Ограниченный доступ к DOM | Когда нужна логика без UI |

## Заключение

Директивы - это мощный инструмент в арсенале фронтенд-разработчика, особенно в Angular и Vue. Они позволяют создавать переиспользуемые куски функциональности, которые изменяют поведение DOM-элементов. Понимание и правильное использование директив помогает создавать более чистую архитектуру приложения и улучшает читаемость кода.

## См. также

- [[Angular]] - подробнее о фреймворке Angular
- [[Vue.js]] - подробнее о фреймворке Vue.js
- [[React]] - подробнее о фреймворке React
- [[Архитектура фронтенд-приложений]] - общие принципы архитектуры
- [[Паттерны проектирования в JavaScript]] - паттерны для фронтенд-разработки
- [[Компонентный подход]] - подход к построению интерфейсов
- [[Доступность веб-контента]] - важные аспекты доступности
- [[Тестирование фронтенд-приложений]] - практики тестирования
- [[Функциональные компоненты vs Классовые компоненты]] - сравнение подходов
- [[Состояние приложения]] - управление состоянием в приложениях