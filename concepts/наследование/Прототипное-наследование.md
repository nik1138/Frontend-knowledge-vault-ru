---
aliases: [Прототипное наследование, Прототипы, Prototype Inheritance]
tags: [javascript, oop, прототипы, наследование, фронтенд]
---

# Прототипное-наследование

## Обзор

Прототипное наследование - это механизм в JavaScript, при котором объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. В отличие от классического наследования, прототипное наследование позволяет объектам наследовать свойства непосредственно от других объектов, что делает его более гибким и динамичным.

## Основные понятия

### Прототип (Prototype)

Каждый объект в JavaScript имеет внутреннее свойство `[[Prototype]]`, которое указывает на другой объект - прототип. Этот прототип также может иметь свой прототип и так далее, формируя цепочку прототипов.

```javascript
// Создание объекта
const animal = {
  eats: true,
  walk() {
    console.log("Ходит по земле");
  }
};

// Создание другого объекта, наследующего от animal
const rabbit = {
  jumps: true
};

// Установка прототипа rabbit в animal
Object.setPrototypeOf(rabbit, animal);

console.log(rabbit.eats); // true - наследуется от animal
rabbit.walk(); // "Ходит по земле" - метод также наследуется
```

### Цепочка прототипов

Когда вы пытаетесь получить доступ к свойству объекта, JavaScript сначала проверяет, есть ли это свойство в самом объекте. Если нет, он ищет его в прототипе объекта, затем в прототипе прототипа и так далее, пока не достигнет конца цепочки (где прототип равен `null`).

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} издает звук`);
};

function Dog(name, breed) {
  Animal.call(this, name); // Вызов родительского конструктора
  this.breed = breed;
}

// Установка прототипа Dog в Animal
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(`${this.name} лает`);
};

const myDog = new Dog("Рекс", "Лабрадор");
myDog.speak(); // "Рекс издает звук" - наследуется от Animal
myDog.bark(); // "Рекс лает" - собственный метод Dog
```

### Методы работы с прототипами

- `Object.create(proto)` - создает новый объект с указанным прототипом
- `Object.getPrototypeOf(obj)` - возвращает прототип объекта
- `Object.setPrototypeOf(obj, proto)` - устанавливает прототип объекта
- `obj.hasOwnProperty(prop)` - проверяет, является ли свойство собственным

## Практические рекомендации

### 1. Используйте `Object.create()` для установки прототипов

```javascript
// Хорошо: используя Object.create()
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} издает звук`);
};

function Dog(name) {
  Animal.call(this, name);
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Плохо: прямое присваивание может привести к нежелательным последствиям
// Dog.prototype = Animal.prototype; // Не делайте так!
```

### 2. Проверяйте наличие свойств в цепочке прототипов

```javascript
const obj = { a: 1 };
const proto = { b: 2 };
Object.setPrototypeOf(obj, proto);

// Проверка собственного свойства
console.log(obj.hasOwnProperty('a')); // true
console.log(obj.hasOwnProperty('b')); // false - b находится в прототипе

// Проверка наличия свойства в цепочке
console.log('b' in obj); // true
```

### 3. Избегайте изменения встроенных прототипов

```javascript
// Плохо: изменение встроенных прототипов может привести к проблемам
// String.prototype.customMethod = function() { ... };

// Лучше создавать свои вспомогательные функции
const stringUtils = {
  customMethod: function(str) {
    // реализация
  }
};
```

## Преимущества прототипного наследования

- **Гибкость**: прототипы могут быть изменены в runtime
- **Экономия памяти**: методы и свойства хранятся в прототипе, а не в каждом экземпляре
- **Динамичность**: можно легко добавлять новые методы к существующим прототипам

## Недостатки прототипного наследования

- **Сложность понимания**: цепочка прототипов может быть сложной для понимания новичками
- **Производительность**: поиск свойств в длинной цепочке прототипов может быть медленнее
- **Потенциальные ошибки**: неправильное использование прототипов может привести к нежелательным эффектам

## Сравнение с классическим наследованием

| Аспект | Прототипное наследование | Классическое наследование |
|--------|--------------------------|---------------------------|
| Гибкость | Высокая | Ограниченная |
| Время определения | Runtime | Compile time |
| Структура | Динамическая | Статическая |
| Сложность | Средняя | Низкая для простых случаев |

## Связь с другими концепциями

Прототипное наследование тесно связано с такими концепциями как:

- [[Объекты]] - основа для прототипного наследования
- [[Функции-конструкторы]] - способ создания объектов с прототипами
- [[Классовое-наследование]] - более абстрактный подход, построенный поверх прототипов
- [[Композиция-вместо-наследования]] - альтернативный подход к повторному использованию кода
- [[Полиморфизм]] - возможность объектов разных типов использовать одинаковые интерфейсы

## Заключение

Прототипное наследование - мощная особенность JavaScript, которая дает разработчикам гибкость в создании объектно-ориентированных структур. Понимание работы прототипов необходимо для эффективной разработки на JavaScript и правильного использования фреймворков, построенных на этой технологии.

> [!tip] Совет
> Используйте `Object.create(null)` для создания "чистых" объектов без прототипа, когда вам не нужна цепочка прототипов.

> [!warning] Важно
> Будьте осторожны при работе с цепочками прототипов, особенно при изменении встроенных прототипов, что может повлиять на всю программу.