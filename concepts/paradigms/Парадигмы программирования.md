# Парадигмы программирования

Парадигма программирования — это стиль или способ программирования, определяющий фундаментальные принципы, концепции и подходы к решению задач. Разные парадигмы предлагают различные способы структурирования и организации кода.

## Основные парадигмы программирования

### Императивное программирование

Императивное программирование описывает вычисления как последовательность инструкций, изменяющих состояние программы. Основной акцент делается на том, *как* достичь результата. Подробнее см. [[Императивное программирование]].

#### Характеристики
- Последовательное выполнение команд
- Изменяемое состояние
- Использование переменных и присваиваний
- Циклы и условные операторы

#### Пример на JavaScript
```javascript
// Императивный подход
function sumArray(numbers) {
  let sum = 0; // Изменяемая переменная
  for (let i = 0; i < numbers.length; i++) { // Цикл
    sum = sum + numbers[i]; // Изменение состояния
  }
  return sum;
}

const numbers = [1, 2, 3, 4, 5];
const result = sumArray(numbers);
console.log(result); // 15
```

#### Преимущества
- Простота понимания для начинающих
- Прямое соответствие машинным инструкциям
- Эффективность выполнения

#### Недостатки
- Сложность управления состоянием в больших программах
- Склонность к ошибкам из-за изменяемого состояния
- Трудности с параллелизацией

### Декларативное программирование

Декларативное программирование описывает *что* должно быть вычислено, а не *как*. Программа специфицирует желаемый результат, а не последовательность шагов для его достижения. Подробнее см. [[Декларативное программирование]].

#### Характеристики
- Описание желаемого результата
- Минимизация изменяемого состояния
- Высокоуровневые абстракции
- Фокус на логике, а не на потоке управления

#### Пример на SQL
```sql
-- Декларативный подход
SELECT name, age 
FROM users 
WHERE age > 18 
ORDER BY age DESC;
```

#### Преимущества
- Более высокий уровень абстракции
- Легкость понимания логики
- Лучшая поддержка параллелизма
- Меньше склонность к ошибкам

#### Недостатки
- Меньший контроль над выполнением
- Потенциально менее эффективное выполнение
- Сложность для некоторых задач

### Объектно-ориентированное программирование (ООП)

Объектно-ориентированное программирование организует код вокруг объектов, которые содержат данные и методы для работы с этими данными. Подробнее см. [[Объектно-ориентированное программирование]].

#### Основные принципы

##### Инкапсуляция
Скрытие внутренней реализации и предоставление контролируемого доступа к данным. Подробнее см. [[Инкапсуляция]].

```javascript
// Пример инкапсуляции в JavaScript
class BankAccount {
  #balance = 0; // Приватное поле
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
    }
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance()); // 100
```

##### Наследование
Создание новых классов на основе существующих, перенимая их свойства и методы. Подробнее см. [[Наследование]].

```javascript
// Пример наследования
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} издает звук`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} лает`);
  }
  
  fetch() {
    console.log(`${this.name} принес палку`);
  }
}

const dog = new Dog('Бобик');
dog.speak(); // Бобик лает
dog.fetch(); // Бобик принес палку
```

##### Полиморфизм
Возможность объектов разных типов использовать один и тот же интерфейс. Подробнее см. [[Полиморфизм]].

```javascript
// Пример полиморфизма
class Shape {
  getArea() {
    throw new Error('Метод getArea должен быть реализован');
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius * this.radius;
  }
}

// Полиморфное использование
function printArea(shape) {
  console.log(`Площадь: ${shape.getArea()}`);
}

const shapes = [
  new Rectangle(5, 3),
  new Circle(4)
];

shapes.forEach(shape => printArea(shape));
```

##### Абстракция
Сокрытие сложной реализации за простым интерфейсом. Подробнее см. [[Абстракция]].

##### Композиция
Создание сложных объектов путем объединения более простых объектов. Подробнее см. [[Композиция]].
##### Интерфейсы
Контракты, определяющие набор методов и свойств, которые должен реализовать класс. Подробнее см. [[Интерфейсы]].

```javascript
// Пример абстракции
class DatabaseConnection {
  constructor(config) {
    this.config = config;
    this.connection = null;
  }
  
  connect() {
    // Сложная реализация подключения к базе данных
    // Обработка ошибок, настройка параметров и т.д.
    this.connection = this._createConnection();
    console.log('Подключение к базе данных установлено');
  }
  
  query(sql) {
    // Сложная реализация выполнения запроса
    if (!this.connection) {
      throw new Error('Нет подключения к базе данных');
    }
    return this._executeQuery(sql);
  }
  
  _createConnection() {
    // Внутренняя реализация, скрытая от пользователя
    return { connected: true };
  }
  
  _executeQuery(sql) {
    // Внутренняя реализация выполнения запроса
    return { result: 'query result' };
  }
}
```

#### Преимущества ООП
- Модульность и повторное использование кода
- Легкость сопровождения
- Расширяемость
- Интуитивная модель для реальных сущностей

#### Недостатки ООП
- Сложность для простых задач
- Потенциальная избыточность
- Проблемы с множественным наследованием

### Функциональное программирование

Функциональное программирование рассматривает вычисления как вычисление математических функций и избегает изменяемого состояния. Подробнее см. [[Функциональное программирование]].

#### Основные принципы

##### Чистые функции
Функции, которые не имеют побочных эффектов и всегда возвращают одинаковый результат для одинаковых входных данных.

```javascript
// Чистая функция
function add(a, b) {
  return a + b;
}

// Нечистая функция
let total = 0;
function addToTotal(value) {
  total += value; // Побочный эффект - изменение внешнего состояния
  return total;
}
```

##### Неизменяемость
Данные не изменяются после создания, вместо этого создаются новые версии.

```javascript
// Иммутабельный подход
const originalArray = [1, 2, 3, 4, 5];

// Вместо изменения массива создаем новый
const doubledArray = originalArray.map(x => x * 2);
const evenArray = originalArray.filter(x => x % 2 === 0);

console.log(originalArray); // [1, 2, 3, 4, 5] - не изменился
console.log(doubledArray);  // [2, 4, 6, 8, 10]
console.log(evenArray);     // [2, 4]
```

##### Функции высшего порядка
Функции, которые принимают другие функции в качестве аргументов или возвращают функции.

```javascript
// Функция высшего порядка
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// Другой пример
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2); // map - функция высшего порядка
const sum = numbers.reduce((acc, x) => acc + x, 0); // reduce - функция высшего порядка
```

##### Композиция функций
Создание сложных функций из более простых.

```javascript
// Композиция функций
const add = (x) => (y) => x + y;
const multiply = (x) => (y) => x * y;
const compose = (f, g) => (x) => f(g(x));

const add5 = add(5);
const multiplyBy2 = multiply(2);
const add5AndMultiplyBy2 = compose(multiplyBy2, add5);

console.log(add5AndMultiplyBy2(10)); // 30 (10 + 5 = 15, 15 * 2 = 30)
```

#### Преимущества функционального программирования
- Легкость тестирования
- Лучшая поддержка параллелизма
- Предсказуемость
- Легкость отладки

#### Недостатки функционального программирования
- Кривая обучения
- Потенциальная неэффективность
- Сложность для некоторых задач

### Структурное программирование

Структурное программирование основывается на принципе разбиения программы на логически завершенные блоки и использование структурированного потока управления. Подробнее см. [[Структурное программирование]].

#### Характеристики
- Использование последовательных блоков
- Условные операторы (if-else)
- Циклы (for, while)
- Избегание goto

#### Пример
```javascript
// Структурный подход
function findMax(numbers) {
  if (numbers.length === 0) {
    return null;
  }
  
  let max = numbers[0];
  
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] > max) {
      max = numbers[i];
    }
  }
  
  return max;
}

const numbers = [3, 7, 2, 9, 1, 5];
const max = findMax(numbers);
console.log(max); // 9
```

## Смешанные парадигмы

Современные языки программирования часто поддерживают несколько парадигм:

### JavaScript
```javascript
// Императивный подход
const numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

// Функциональный подход
const sum2 = numbers.reduce((acc, x) => acc + x, 0);

// Объектно-ориентированный подход
class Calculator {
  add(a, b) {
    return a + b;
  }
}
```

### TypeScript
```typescript
// Функциональный подход с типами
type User = {
  id: number;
  name: string;
  email: string;
};

const users: User[] = [
  { id: 1, name: 'John', email: 'john@example.com' },
  { id: 2, name: 'Jane', email: 'jane@example.com' }
];

// Чистая функция с типизацией
const findUserById = (users: User[], id: number): User | undefined => {
  return users.find(user => user.id === id);
};

// Использование
const user = findUserById(users, 1);
```

## Выбор парадигмы

### Факторы выбора
- Тип задачи
- Размер и сложность проекта
- Команда разработчиков
- Требования к производительности
- Временные ограничения

### Рекомендации
- Для простых скриптов подходит императивное программирование
- Для сложных систем полезно ООП
- Для обработки данных эффективно функциональное программирование
- Для веб-разработки часто используется смешанный подход

## Связь с другими концепциями

- [[SOLID]] - Принципы SOLID применимы в ООП
- [[DRY (Don't Repeat Yourself)]] - Все парадигмы способствуют избеганию дублирования
- [[KISS (Keep It Simple, Stupid)]] - Разные парадигмы по-разному подходят к простоте
- [[Чистый код]] - Каждая парадигма имеет свои стандарты чистого кода

## Применение в современных технологиях

### В [[ts]]
TypeScript поддерживает все основные парадигмы:
- Интерфейсы и классы для ООП
- Функции высшего порядка для функционального программирования
- Типы и дженерики для структурного программирования

### В [[js]]
JavaScript является мультипарадигменным языком:
- Прототипное наследование для ООП
- Функции первого класса для функционального программирования
- Структурные конструкции для структурного программирования

## Теги
#programming-paradigms #oop #functional-programming #imperative #declarative #programming-concepts