---
aliases: ["Backend Routing", "Server-side Routing"]
tags: [routing, backend, server, web-development]
---

# Серверный роутинг

Серверный роутинг (Server-side routing) - это подход к навигации в веб-приложениях, при котором каждый переход между страницами обрабатывается на стороне сервера. При этом происходит полная перезагрузка страницы с получением нового HTML-документа от сервера.

## Основные понятия

Серверный роутинг - это традиционный подход к веб-разработке, при котором сервер отвечает за обработку URL и возврат соответствующего HTML-контента. Каждый маршрут соответствует определенному обработчику на сервере.

### Преимущества серверного роутинга

- **SEO оптимизация** - контент сразу доступен для поисковых систем
- **Первоначальная загрузка** - страница сразу отображает полезный контент
- **Простота реализации** - не требует сложных клиентских фреймворков
- **Безопасность** - логика приложения остается на сервере
- **Поддержка JavaScript** - работает даже при отключенном JavaScript

### Недостатки серверного роутинга

- **Задержки при навигации** - каждый переход требует нового HTTP-запроса
- **Повторяющиеся ресурсы** - HTML, CSS и JavaScript загружаются при каждом переходе
- **Меньше интерактивности** - сложнее создавать плавные анимации
- **Состояние приложения** - сложнее управлять состоянием между переходами

## Архитектурные паттерны

### Model-View-Controller (MVC)

Серверный роутинг часто используется в архитектуре MVC:

```
Запрос → Роутер → Контроллер → Модель → Представление (View) → Ответ
```

### Примеры серверных фреймворков

- Express.js (Node.js)
- Django (Python)
- Ruby on Rails (Ruby)
- Laravel (PHP)
- Spring Boot (Java)

## Реализация серверного роутинга

### На примере Express.js

```javascript
const express = require('express');
const app = express();

// Основные маршруты
app.get('/', (req, res) => {
    res.render('index', { title: 'Главная страница' });
});

app.get('/about', (req, res) => {
    res.render('about', { title: 'О нас' });
});

app.get('/users/:id', (req, res) => {
    const userId = req.params.id;
    // Получение данных пользователя из базы данных
    getUserById(userId, (user) => {
        if (user) {
            res.render('user', { title: `Пользователь ${user.name}`, user });
        } else {
            res.status(404).render('404', { title: 'Пользователь не найден' });
        }
    });
});

// Обработка 404 ошибок
app.use((req, res) => {
    res.status(404).render('404', { title: 'Страница не найдена' });
});

app.listen(3000, () => {
    console.log('Сервер запущен на порту 3000');
});
```

### На примере Django

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('about/', views.about, name='about'),
    path('users/<int:user_id>/', views.user_detail, name='user_detail'),
    path('404/', views.not_found, name='not_found'),
]

# views.py
from django.shortcuts import render, get_object_or_404
from .models import User

def index(request):
    return render(request, 'index.html', {'title': 'Главная страница'})

def about(request):
    return render(request, 'about.html', {'title': 'О нас'})

def user_detail(request, user_id):
    user = get_object_or_404(User, pk=user_id)
    return render(request, 'user_detail.html', {'user': user, 'title': f'Пользователь {user.name}'})
```

## Сравнение с клиентским роутингом

| Характеристика | [[Клиентский-роутинг]] | Серверный роутинг |
|----------------|------------------------|-------------------|
| Загрузка страницы | Однократная | Каждый переход |
| SEO | Требует дополнительной обработки | Лучше по умолчанию |
| Производительность | Быстрая навигация | Медленнее из-за перезагрузки |
| Сложность разработки | Выше | Ниже |
| Безопасность | Требует дополнительных мер | Выше по умолчанию |

## Современные подходы

### Server-Side Rendering (SSR)

Современные фреймворки позволяют комбинировать преимущества обоих подходов:

- Next.js (React)
- Nuxt.js (Vue)
- SvelteKit (Svelte)

### Static Site Generation (SSG)

Для контентных сайтов часто используется генерация статических страниц:

- Gatsby (React)
- Jekyll (Ruby)
- Hugo (Go)

### Incremental Static Regeneration (ISR)

Современный подход, позволяющий обновлять статические страницы по мере необходимости:

```javascript
// Пример в Next.js
export async function getStaticProps() {
    const data = await fetchData();
    return {
        props: {
            data,
        },
        revalidate: 3600, // Обновлять каждые час
    };
}
```

## Практические рекомендации

### 1. Оптимизация производительности

- Используйте кэширование маршрутов
- Минимизируйте время обработки запросов
- Используйте CDN для статических ресурсов

### 2. Обработка ошибок

```javascript
// Express.js - централизованная обработка ошибок
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).render('error', { 
        title: 'Внутренняя ошибка сервера',
        message: process.env.NODE_ENV === 'development' ? err.message : 'Произошла ошибка'
    });
});
```

### 3. Безопасность

- Проверяйте и валидируйте параметры маршрутов
- Используйте middleware для аутентификации и авторизации
- Защищайте от XSS и CSRF атак

```javascript
// Валидация параметров маршрута
app.get('/users/:id', (req, res, next) => {
    const userId = parseInt(req.params.id);
    if (isNaN(userId) || userId <= 0) {
        return res.status(400).render('error', { title: 'Неверный ID пользователя' });
    }
    next();
}, (req, res) => {
    // Обработка валидного ID
});
```

### 4. SEO оптимизация

- Используйте семантические теги HTML
- Добавляйте мета-теги для каждой страницы
- Реализуйте канонические URL

## Роутинг с аутентификацией

```javascript
// Middleware для проверки аутентификации
const requireAuth = (req, res, next) => {
    if (!req.session.userId) {
        return res.redirect('/login');
    }
    next();
};

// Защищенные маршруты
app.get('/dashboard', requireAuth, (req, res) => {
    res.render('dashboard', { title: 'Панель управления' });
});

app.get('/profile', requireAuth, (req, res) => {
    res.render('profile', { title: 'Профиль пользователя' });
});
```

## Заключение

Серверный роутинг остается важным подходом в веб-разработке, особенно для контентных сайтов и приложений, где SEO имеет первостепенное значение. Современные фреймворки позволяют комбинировать преимущества серверного и клиентского роутинга, создавая гибкие и эффективные веб-приложения.

Для получения информации о клиентском роутинге смотрите:
- [[Клиентский-роутинг]]
- [[Роутинг-в-React]]
- [[Роутинг-в-Vue]]
- [[Роутинг-в-Svelte]]

## Ключевые теги

#routing #backend #server #web-development #server-side-routing #mvc #expressjs #django