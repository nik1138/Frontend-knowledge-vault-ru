---
aliases: [Абстрактные паттерны, Паттерны абстракции]
tags: [patterns, abstraction, frontend, react, javascript, design-patterns]
---

# Абстрактные паттерны

## Определение

Абстрактные паттерны — это шаблоны проектирования, которые помогают абстрагировать сложность и создавать гибкие, поддерживаемые и масштабируемые приложения. Эти паттерны особенно важны во фронтенд-разработке, где необходимо управлять состоянием, взаимодействиями и пользовательским интерфейсом.

## Классификация абстрактных паттернов

### 1. Порождающие паттерны

#### Абстрактная фабрика

Позволяет создавать семейства связанных объектов без указания их конкретных классов.

```javascript
// Абстрактная фабрика для UI-компонентов
class UIFactory {
    createButton() {
        throw new Error('Метод должен быть реализован');
    }
    
    createInput() {
        throw new Error('Метод должен быть реализован');
    }
}

class MaterialFactory extends UIFactory {
    createButton() {
        return new MaterialButton();
    }
    
    createInput() {
        return new MaterialInput();
    }
}

class BootstrapFactory extends UIFactory {
    createButton() {
        return new BootstrapButton();
    }
    
    createInput() {
        return new BootstrapInput();
    }
}

// Использование
function createUI(factoryType) {
    let factory;
    
    switch(factoryType) {
        case 'material':
            factory = new MaterialFactory();
            break;
        case 'bootstrap':
            factory = new BootstrapFactory();
            break;
        default:
            throw new Error('Неизвестный тип фабрики');
    }
    
    return {
        button: factory.createButton(),
        input: factory.createInput()
    };
}
```

#### Фабричный метод

Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта.

```javascript
// Фабричный метод для создания компонентов
class ComponentFactory {
    createComponent(type, props) {
        const component = this.createComponentInstance(type);
        component.setProps(props);
        return component;
    }
    
    createComponentInstance(type) {
        throw new Error('Метод должен быть реализован');
    }
}

class ReactComponentFactory extends ComponentFactory {
    createComponentInstance(type) {
        switch(type) {
            case 'button':
                return new ReactButton();
            case 'input':
                return new ReactInput();
            default:
                throw new Error('Неизвестный тип компонента');
        }
    }
}
```

### 2. Структурные паттерны

#### Адаптер

Позволяет объектам с несовместимыми интерфейсами работать вместе.

```javascript
// Адаптер для работы с разными API
class UserAPIAdapter {
    constructor(legacyAPI) {
        this.legacyAPI = legacyAPI;
    }
    
    async getUsers() {
        const data = await this.legacyAPI.fetchUsers();
        // Адаптируем данные к новому формату
        return data.map(user => ({
            id: user.userId,
            name: user.userName,
            email: user.userEmail
        }));
    }
    
    async createUser(userData) {
        // Адаптируем данные к формату старого API
        const legacyData = {
            userId: userData.id,
            userName: userData.name,
            userEmail: userData.email
        };
        
        return await this.legacyAPI.addUser(legacyData);
    }
}

// Использование
const legacyAPI = new LegacyUserAPI();
const adapter = new UserAPIAdapter(legacyAPI);
const users = await adapter.getUsers();
```

#### Компоновщик

Позволяет сгруппировать объекты в древовидную структуру и работать с ней как с одним объектом.

```javascript
// Компоновщик для UI-компонентов
class UIComponent {
    constructor(name) {
        this.name = name;
        this.children = [];
    }
    
    add(component) {
        this.children.push(component);
    }
    
    remove(component) {
        this.children = this.children.filter(child => child !== component);
    }
    
    render() {
        let result = `<div class="component" data-name="${this.name}">`;
        
        this.children.forEach(child => {
            result += child.render();
        });
        
        result += '</div>';
        return result;
    }
}

class Button extends UIComponent {
    render() {
        return `<button class="btn">${this.name}</button>`;
    }
}

class Panel extends UIComponent {
    render() {
        return `<div class="panel">${super.render()}</div>`;
    }
}

// Использование
const panel = new Panel('Основная панель');
const button1 = new Button('Кнопка 1');
const button2 = new Button('Кнопка 2');

panel.add(button1);
panel.add(button2);

console.log(panel.render());
```

#### Декоратор

Позволяет динамически добавлять новую функциональность объектам.

```javascript
// Декоратор для компонентов
class Component {
    render() {
        return '<div>Компонент</div>';
    }
}

class ComponentDecorator {
    constructor(component) {
        this.component = component;
    }
    
    render() {
        return this.component.render();
    }
}

class StyledDecorator extends ComponentDecorator {
    render() {
        return `<div class="styled">${super.render()}</div>`;
    }
}

class AnimatedDecorator extends ComponentDecorator {
    render() {
        return `<div class="animated">${super.render()}</div>`;
    }
}

// Использование
const component = new Component();
const styledComponent = new StyledDecorator(component);
const animatedStyledComponent = new AnimatedDecorator(styledComponent);

console.log(animatedStyledComponent.render());
```

### 3. Поведенческие паттерны

#### Наблюдатель (Observer)

Определяет зависимость "один ко многим" между объектами, чтобы при изменении состояния одного объекта все зависящие от него объекты уведомлялись автоматически.

```javascript
// Паттерн Наблюдатель для управления состоянием
class StateManager {
    constructor() {
        this.state = {};
        this.observers = [];
    }
    
    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.notifyObservers();
    }
    
    subscribe(observer) {
        this.observers.push(observer);
        return () => {
            this.observers = this.observers.filter(obs => obs !== observer);
        };
    }
    
    notifyObservers() {
        this.observers.forEach(observer => observer(this.state));
    }
}

// Использование в React-подобной системе
const stateManager = new StateManager();

function connect(mapStateToProps) {
    return function(WrappedComponent) {
        return class ConnectedComponent extends React.Component {
            constructor(props) {
                super(props);
                this.state = mapStateToProps(stateManager.state);
            }
            
            componentDidMount() {
                this.unsubscribe = stateManager.subscribe((newState) => {
                    this.setState(mapStateToProps(newState));
                });
            }
            
            componentWillUnmount() {
                if (this.unsubscribe) {
                    this.unsubscribe();
                }
            }
            
            render() {
                return <WrappedComponent {...this.props} {...this.state} />;
            }
        };
    };
}
```

#### Стратегия

Позволяет определять семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми.

```javascript
// Паттерн Стратегия для валидации форм
class ValidationStrategy {
    validate(value) {
        throw new Error('Метод должен быть реализован');
    }
}

class RequiredStrategy extends ValidationStrategy {
    validate(value) {
        return value !== undefined && value !== null && value !== '';
    }
}

class EmailStrategy extends ValidationStrategy {
    validate(value) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(value);
    }
}

class MinLengthStrategy extends ValidationStrategy {
    constructor(minLength) {
        super();
        this.minLength = minLength;
    }
    
    validate(value) {
        return value && value.length >= this.minLength;
    }
}

// Контекст валидации
class Validator {
    constructor(strategy) {
        this.strategy = strategy;
    }
    
    setStrategy(strategy) {
        this.strategy = strategy;
    }
    
    validate(value) {
        return this.strategy.validate(value);
    }
}

// Использование
const requiredValidator = new Validator(new RequiredStrategy());
const emailValidator = new Validator(new EmailStrategy());
const minLengthValidator = new Validator(new MinLengthStrategy(6));

console.log(requiredValidator.validate('')); // false
console.log(emailValidator.validate('test@example.com')); // true
console.log(minLengthValidator.validate('12345')); // false
```

#### Команда

Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с помощью очередей, запросов и операций.

```javascript
// Паттерн Команда для обработки действий в UI
class Command {
    execute() {
        throw new Error('Метод должен быть реализован');
    }
    
    undo() {
        throw new Error('Метод должен быть реализован');
    }
}

class AddItemCommand extends Command {
    constructor(items, item) {
        super();
        this.items = items;
        this.item = item;
    }
    
    execute() {
        this.items.push(this.item);
    }
    
    undo() {
        const index = this.items.findIndex(i => i.id === this.item.id);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
    }
}

class DeleteItemCommand extends Command {
    constructor(items, item) {
        super();
        this.items = items;
        this.item = item;
        this.index = -1;
    }
    
    execute() {
        this.index = this.items.findIndex(i => i.id === this.item.id);
        if (this.index !== -1) {
            this.items.splice(this.index, 1);
        }
    }
    
    undo() {
        if (this.index !== -1) {
            this.items.splice(this.index, 0, this.item);
        }
    }
}

// Использование
const items = [];
const addItemCommand = new AddItemCommand(items, { id: 1, name: 'Элемент 1' });
const deleteItemCommand = new DeleteItemCommand(items, { id: 1, name: 'Элемент 1' });

addItemCommand.execute(); // Добавляем элемент
console.log(items); // [{ id: 1, name: 'Элемент 1' }]

deleteItemCommand.execute(); // Удаляем элемент
console.log(items); // []
```

## Паттерны в современном фронтенде

### 1. Flux/Redux Pattern

Архитектурный паттерн для управления состоянием приложения.

```javascript
// Простая реализация Flux-подобной архитектуры
class Store {
    constructor(reducer, initialState) {
        this.reducer = reducer;
        this.state = initialState;
        this.listeners = [];
    }
    
    getState() {
        return this.state;
    }
    
    dispatch(action) {
        this.state = this.reducer(this.state, action);
        this.listeners.forEach(listener => listener());
    }
    
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter(l => l !== listener);
        };
    }
}

// Редьюсер
function userReducer(state = { users: [], currentUser: null }, action) {
    switch(action.type) {
        case 'ADD_USER':
            return {
                ...state,
                users: [...state.users, action.payload]
            };
        case 'SET_CURRENT_USER':
            return {
                ...state,
                currentUser: action.payload
            };
        default:
            return state;
    }
}

// Использование
const store = new Store(userReducer, { users: [], currentUser: null });

store.dispatch({
    type: 'ADD_USER',
    payload: { id: 1, name: 'Иван' }
});

console.log(store.getState());
```

### 2. Container/Presentational Pattern

Разделение компонентов на контейнерные (управляющие данными) и презентационные (отвечающие за отображение).

```jsx
// Презентационный компонент
const UserList = ({ users, onUserClick }) => (
    <ul>
        {users.map(user => (
            <li key={user.id} onClick={() => onUserClick(user)}>
                {user.name} - {user.email}
            </li>
        ))}
    </ul>
);

// Контейнерный компонент
class UserContainer extends React.Component {
    constructor() {
        super();
        this.state = { users: [] };
    }
    
    async componentDidMount() {
        const users = await fetchUsers();
        this.setState({ users });
    }
    
    render() {
        return (
            <UserList 
                users={this.state.users} 
                onUserClick={this.handleUserClick} 
            />
        );
    }
}
```

### 3. Higher-Order Component (HOC)

Паттерн для повторного использования логики компонентов.

```javascript
// HOC для проверки аутентификации
function withAuth(WrappedComponent) {
    return function AuthenticatedComponent(props) {
        const [isAuthenticated, setIsAuthenticated] = useState(false);
        
        useEffect(() => {
            checkAuth().then(setIsAuthenticated);
        }, []);
        
        if (!isAuthenticated) {
            return <Redirect to="/login" />;
        }
        
        return <WrappedComponent {...props} />;
    };
}

// Использование
const ProtectedProfile = withAuth(Profile);
```

## Применение абстрактных паттернов в React

### 1. Пользовательские хуки

Хуки позволяют абстрагировать логику состояния и побочных эффектов.

```javascript
// Пользовательский хук для работы с API
function useAPI(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const response = await fetch(url);
                const result = await response.json();
                setData(result);
            } catch (err) {
                setError(err);
            } finally {
                setLoading(false);
            }
        };
        
        fetchData();
    }, [url]);
    
    return { data, loading, error };
}

// Использование
function UserProfile({ userId }) {
    const { data: user, loading, error } = useAPI(`/api/users/${userId}`);
    
    if (loading) return <div>Загрузка...</div>;
    if (error) return <div>Ошибка: {error.message}</div>;
    
    return <div>{user.name}</div>;
}
```

### 2. Render Props

Паттерн для передачи логики отображения через пропсы.

```javascript
// Компонент с Render Props
function DataProvider({ url, children }) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const response = await fetch(url);
                const result = await response.json();
                setData(result);
            } catch (err) {
                setError(err);
            } finally {
                setLoading(false);
            }
        };
        
        fetchData();
    }, [url]);
    
    return children({ data, loading, error });
}

// Использование
function UserList() {
    return (
        <DataProvider url="/api/users">
            {({ data, loading, error }) => {
                if (loading) return <div>Загрузка...</div>;
                if (error) return <div>Ошибка: {error.message}</div>;
                
                return (
                    <ul>
                        {data.map(user => (
                            <li key={user.id}>{user.name}</li>
                        ))}
                    </ul>
                );
            }}
        </DataProvider>
    );
}
```

## Связь с другими концепциями

- [[Абстракция-в-фронтенде]]: Общие принципы абстракции во фронтенде
- [[Абстрактные-компоненты]]: Компоненты, реализующие абстрактные паттерны
- [[Дизайн-паттерны]]: Общие паттерны проектирования
- [[Архитектурные-паттерны]]: Архитектурные решения, основанные на паттернах
- [[Компонентная-архитектура]]: Организация компонентов по архитектурным принципам

## Заключение

Абстрактные паттерны являются мощным инструментом для создания гибких, поддерживаемых и масштабируемых приложений. Они помогают абстрагировать сложность, улучшить повторное использование кода и обеспечить согласованность архитектуры. Понимание и правильное применение этих паттернов является ключевым навыком для любого фронтенд-разработчика.

## Теги

#patterns #abstraction #frontend #react #javascript #design-patterns #architecture #oop