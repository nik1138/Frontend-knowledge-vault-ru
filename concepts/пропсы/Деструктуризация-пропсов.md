---
aliases: ["Деструктуризация свойств", "Props destructuring", "Разбор пропсов"]
tags: [frontend, props, destructuring, javascript, react, vue, es6]
---

# Деструктуризация пропсов

**Деструктуризация пропсов** — это процесс извлечения свойств из объекта пропсов с помощью синтаксиса деструктуризации JavaScript. Это позволяет более удобно и читаемо работать с передаваемыми в компонент данными, улучшая как читаемость кода, так и его поддерживаемость.

## Основы деструктуризации пропсов

Деструктуризация позволяет извлекать конкретные свойства из объекта пропсов прямо в объявлении параметров функции:

```jsx
// Без деструктуризации
function UserProfile(props) {
  return (
    <div>
      <h1>{props.name}</h1>
      <p>{props.email}</p>
      <p>Возраст: {props.age}</p>
    </div>
  );
}

// С деструктуризацией
function UserProfile({ name, email, age }) {
  return (
    <div>
      <h1>{name}</h1>
      <p>{email}</p>
      <p>Возраст: {age}</p>
    </div>
  );
}
```

## Деструктуризация с значениями по умолчанию

Одной из мощных возможностей деструктуризации является установка значений по умолчанию:

```jsx
function Button({ 
  text = 'Кнопка', 
  type = 'primary', 
  disabled = false, 
  onClick = () => {},
  size = 'medium'
}) {
  return (
    <button 
      className={`btn btn-${type} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {text}
    </button>
  );
}
```

## Деструктуризация с переименованием

Иногда нужно переименовать переменную при деструктуризации:

```jsx
function UserCard({ 
  name: userName,           // переименование name в userName
  email: userEmail,         // переименование email в userEmail
  age: userAge = 18,        // с значением по умолчанию
  ...otherProps             // оставшиеся пропсы
}) {
  return (
    <div {...otherProps}>
      <h2>{userName}</h2>
      <p>Email: {userEmail}</p>
      <p>Возраст: {userAge}</p>
    </div>
  );
}
```

## Деструктуризация вложенных объектов

Можно деструктурировать вложенные объекты:

```jsx
function UserCard({ 
  user: { 
    name, 
    profile: { 
      email, 
      avatar = '/default-avatar.png' 
    } 
  },
  displayAge = true
}) {
  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h2>{name}</h2>
      <p>{email}</p>
      {displayAge && <p>Возраст: {user.profile.age || 'Не указан'}</p>}
    </div>
  );
}

// Использование компонента
<UserCard 
  user={{
    name: 'Иван',
    profile: {
      email: 'ivan@example.com',
      avatar: '/ivan-avatar.png'
    }
  }}
/>
```

## Деструктуризация массивов в пропсах

Если пропс содержит массив, можно использовать деструктуризацию массива:

```jsx
function TodoList({ todos: [firstTodo, ...remainingTodos] }) {
  return (
    <div>
      <h3>Первое задание: {firstTodo}</h3>
      <ul>
        {remainingTodos.map((todo, index) => (
          <li key={index}>{todo}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Деструктуризация с сохранением оригинального объекта

Иногда нужно как деструктурировать пропсы, так и сохранить доступ к оригинальному объекту:

```jsx
function EnhancedComponent(props) {
  const { name, age, ...restProps } = props;
  
  // Теперь можно использовать как отдельные значения, так и остальные пропсы
  return (
    <div className="enhanced-component" {...restProps}>
      <h1>{name}</h1>
      <p>Возраст: {age}</p>
      <p>Дополнительные пропсы: {JSON.stringify(restProps)}</p>
    </div>
  );
}
```

## Деструктуризация в React с TypeScript

В TypeScript деструктуризация пропсов сочетается с интерфейсами:

```tsx
interface UserCardProps {
  user: {
    name: string;
    email: string;
    age?: number;
  };
  showAge?: boolean;
  onEdit?: () => void;
}

function UserCard({ 
  user: { name, email, age }, 
  showAge = true, 
  onEdit = () => {} 
}: UserCardProps) {
  return (
    <div className="user-card">
      <h2>{name}</h2>
      <p>{email}</p>
      {showAge && age && <p>Возраст: {age}</p>}
      <button onClick={onEdit}>Редактировать</button>
    </div>
  );
}
```

## Деструктуризация в других фреймворках

### Vue.js

В Vue 3 Composition API деструктуризация пропсов работает немного иначе:

```vue
<script setup>
// Определение пропсов
const props = defineProps({
  title: {
    type: String,
    default: 'Заголовок'
  },
  items: {
    type: Array,
    default: () => []
  },
  config: {
    type: Object,
    default: () => ({ theme: 'light' })
  }
});

// Деструктуризация с помощью toRefs для реактивности
import { toRefs } from 'vue';
const { title, items, config } = toRefs(props);

// Или использование напрямую
function processItems() {
  console.log(props.items.length);
}
</script>
```

### Vue 2 с деструктуризацией

```javascript
export default {
  name: 'MyComponent',
  props: ['title', 'items', 'config'],
  render() {
    // Деструктуризация this.$props
    const { title, items, config } = this.$props;
    
    return (
      <div>
        <h1>{title}</h1>
        <ul>
          {items.map((item, index) => <li key={index}>{item}</li>)}
        </ul>
      </div>
    );
  }
}
```

### Svelte

В Svelte деструктуризация работает напрямую при объявлении пропсов:

```svelte
<script>
  // Деструктуризация происходит при импорте
  import { createEventDispatcher } from 'svelte';
  
  // Определение пропсов
  export let title = 'Заголовок по умолчанию';
  export let user = { name: 'Аноним', email: 'no-email@example.com' };
  export let items = [];
  
  // Можно деструктурировать объекты внутри скрипта
  const { name, email } = user;
  
  const dispatch = createEventDispatcher();
</script>

<div>
  <h1>{title}</h1>
  <p>Имя: {name}, Email: {email}</p>
  <ul>
    {#each items as item}
      <li>{item}</li>
    {/each}
  </ul>
</div>
```

## Проблемы и решения

### Проблема: Потеря реактивности в Vue

При деструктуризации пропсов в Vue может быть потеряна реактивность:

```javascript
// НЕПРАВИЛЬНО - потеряется реактивность
export default {
  props: ['title'],
  computed: {
    upperTitle() {
      const { title } = this; // Реактивность будет потеряна
      return title.toUpperCase();
    }
  }
}

// ПРАВИЛЬНО - сохранение реактивности
export default {
  props: ['title'],
  computed: {
    upperTitle() {
      return this.title.toUpperCase(); // Реактивность сохранена
    }
  }
}
```

### Проблема: Неправильная обработка изменений пропсов

```jsx
function BadComponent({ items }) {
  // НЕПРАВИЛЬНО - useMemo не будет пересчитан при изменении items
  const processedItems = useMemo(() => {
    return items.map(item => ({ ...item, processed: true }));
  }, []); // Пустой массив зависимостей
  
  return <div>{processedItems.length}</div>;
}

function GoodComponent({ items }) {
  // ПРАВИЛЬНО - useMemo будет пересчитан при изменении items
  const processedItems = useMemo(() => {
    return items.map(item => ({ ...item, processed: true }));
  }, [items]);
  
  return <div>{processedItems.length}</div>;
}
```

## Лучшие практики

1. **Используйте деструктуризацию для улучшения читаемости**: Особенно когда компонент принимает много пропсов
2. **Будьте осторожны с вложенными объектами**: При деструктуризации вложенных объектов теряется реактивность в некоторых фреймворках
3. **Комбинируйте с значениями по умолчанию**: Это делает компоненты более гибкими
4. **Используйте rest-оператор для передачи оставшихся пропсов**: Особенно полезно при создании оборачивающих компонентов
5. **Избегайте глубокой деструктуризации**: Слишком сложная деструктуризация может ухудшить читаемость

## Примеры использования

### Оборачивающий компонент

```jsx
function CustomButton({ 
  variant = 'primary', 
  size = 'medium', 
  children, 
  ...restProps // Все остальные пропсы передаются в нативную кнопку
}) {
  return (
    <button 
      className={`custom-btn custom-btn-${variant} custom-btn-${size}`}
      {...restProps}
    >
      {children}
    </button>
  );
}

// Использование
<CustomButton 
  type="submit" 
  disabled={false}
  onClick={handleSubmit}
>
  Отправить
</CustomButton>
```

### Условная деструктуризация

```jsx
function Avatar({ 
  src, 
  alt, 
  initials, 
  showInitials = false,
  ...props 
}) {
  const displaySrc = src || (showInitials ? null : '/default-avatar.png');
  
  return (
    <img 
      src={displaySrc}
      alt={alt || 'Аватар'}
      className="avatar"
      {...props}
    />
  );
}
```

## Связанные темы

- [[Передача-пропсов]]
- [[Валидация-пропсов]]
- [[Пропсы-по-умолчанию]]
- [[Пропсы-в-React]]
- [[Компонентная архитектура]]
- [[JavaScript ES6]]

## Заключение

Деструктуризация пропсов — мощный инструмент, который улучшает читаемость и удобство работы с компонентами. При правильном использовании она делает код более понятным и поддерживаемым, особенно в сложных компонентах с множеством входных параметров.