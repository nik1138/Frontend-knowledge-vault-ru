---
aliases: [Защита от инъекций, SQL-инъекции, Инъекции, Защита от SQL-инъекций]
tags: [security, injection, sql-injection, frontend-security, backend-security]
---

# Защита от инъекций

## Введение

Инъекции - это тип уязвимости, при которой злоумышленник внедряет в приложение нежелательный код для изменения поведения системы. Наиболее известным типом инъекции является SQL-инъекция, но существуют и другие виды: NoSQL-инъекции, командные инъекции, инъекции LDAP и другие. Защита от инъекций требует тщательной валидации и обработки пользовательского ввода на всех уровнях приложения.

## Типы инъекций

### 1. SQL-инъекции

SQL-инъекция происходит, когда пользовательский ввод неправильно обрабатывается и становится частью SQL-запроса.

#### Пример уязвимого кода:
```javascript
// НЕБЕЗОПАСНО - уязвимо к SQL-инъекции
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query, (error, results) => {
  // обработка результата
});
```

Если `userId` содержит `1 OR 1=1`, то запрос станет:
```sql
SELECT * FROM users WHERE id = 1 OR 1=1
```
Это вернет всех пользователей из базы данных.

#### Пример SQL-инъекции для аутентификации:
```javascript
// НЕБЕЗОПАСНО
const login = (username, password) => {
  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;
  return db.query(query);
};
```

При вводе в поле username: `admin'--` и в поле password: `anything`, запрос станет:
```sql
SELECT * FROM users WHERE username = 'admin'--' AND password = 'anything'
```
Комментарий `--` игнорирует остальную часть запроса, и пользователь получает доступ как администратор.

### 2. NoSQL-инъекции

NoSQL-инъекции происходят при работе с NoSQL базами данных (MongoDB, CouchDB и др.).

#### Пример уязвимости в MongoDB:
```javascript
// НЕБЕЗОПАСНО
app.get('/user', (req, res) => {
  const query = { username: req.query.username };
  User.findOne(query, (err, user) => {
    res.json(user);
  });
});
```

Если `req.query.username` содержит `{ "$ne": null }`, это может обойти аутентификацию.

### 3. Командные инъекции

Командные инъекции происходят при неправильной обработке пользовательского ввода в системных командах.

#### Пример командной инъекции:
```javascript
// НЕБЕЗОПАСНО
const { exec } = require('child_process');
app.get('/ping', (req, res) => {
  exec(`ping ${req.query.host}`, (error, stdout) => {
    res.send(stdout);
  });
});
```

При вводе `host` как `google.com; rm -rf /`, будет выполнена вредоносная команда.

### 4. Инъекции LDAP

LDAP-инъекции происходят при неправильной обработке фильтров поиска в LDAP-запросах.

## Методы защиты от инъекций

### 1. Параметризованные запросы (Prepared Statements)

Это наиболее эффективный способ защиты от SQL-инъекций.

#### Пример с использованием MySQL:
```javascript
// БЕЗОПАСНО - использование параметризованных запросов
const mysql = require('mysql2');

const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb'
});

// Правильное использование параметров
const query = 'SELECT * FROM users WHERE id = ?';
connection.execute(query, [userId], (error, results) => {
  // обработка результата
});

// Или с async/await
try {
  const [results] = await connection.execute(query, [userId]);
  console.log(results);
} catch (error) {
  console.error('Ошибка запроса:', error);
}
```

#### Пример с PostgreSQL:
```javascript
const { Client } = require('pg');

const client = new Client({
  user: 'user',
  host: 'localhost',
  database: 'mydb',
  password: 'password',
  port: 5432,
});

// Параметризованный запрос
const query = 'SELECT * FROM users WHERE id = $1';
const values = [userId];

client.query(query, values, (err, res) => {
  console.log(res.rows);
});
```

#### Пример с использованием ORM (Sequelize):
```javascript
// БЕЗОПАСНО - ORM автоматически использует параметризованные запросы
const { Op } = require('sequelize');

// Поиск пользователя по ID
const user = await User.findOne({
  where: {
    id: userId
  }
});

// Поиск с условиями
const users = await User.findAll({
  where: {
    age: {
      [Op.gt]: minAge
    }
  }
});
```

### 2. Валидация и экранирование ввода

#### Валидация данных:
```javascript
// Валидация ID (только числа)
function validateUserId(id) {
  const userId = parseInt(id, 10);
  if (isNaN(userId) || userId <= 0) {
    throw new Error('Неверный ID пользователя');
  }
  return userId;
}

// Использование валидации
try {
  const validId = validateUserId(req.query.id);
  // безопасное использование validId
} catch (error) {
  res.status(400).send('Неверный ID пользователя');
}
```

#### Экранирование специальных символов:
```javascript
// Функция экранирования для SQL
function escapeSqlString(str) {
  return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (char) {
    switch (char) {
      case "\0":
        return "\\0";
      case "\x08":
        return "\\b";
      case "\x09":
        return "\\t";
      case "\x1a":
        return "\\z";
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "\"":
      case "'":
      case "\\":
      case "%":
        return "\\" + char; // экранирование символа
      default:
        return char;
    }
  });
}
```

### 3. Использование allowlist-валидации

Вместо блокировки опасных символов, разрешайте только безопасные:

```javascript
// Валидация с использованием регулярных выражений
function validateUsername(username) {
  // Только буквы, цифры и подчеркивания, длина от 3 до 30 символов
  const usernameRegex = /^[a-zA-Z0-9_]{3,30}$/;
  return usernameRegex.test(username);
}

function validateEmail(email) {
  // Простая валидация email
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// Использование
if (!validateUsername(req.body.username)) {
  return res.status(400).send('Неверный формат имени пользователя');
}
```

### 4. Защита от NoSQL-инъекций

#### Пример безопасной работы с MongoDB:
```javascript
const { ObjectId } = require('mongodb');

// НЕБЕЗОПАСНО
// User.findOne({ username: req.query.username });

// БЕЗОПАСНО - валидация ObjectId
if (!ObjectId.isValid(req.query.id)) {
  return res.status(400).send('Неверный ID');
}

const user = await User.findOne({ _id: new ObjectId(req.query.id) });

// БЕЗОПАСНО - валидация других полей
const username = req.query.username;
if (typeof username !== 'string' || !/^[a-zA-Z0-9_]{3,30}$/.test(username)) {
  return res.status(400).send('Неверное имя пользователя');
}

const user = await User.findOne({ username: username });
```

#### Использование библиотек валидации:
```javascript
const Joi = require('joi');

const userSchema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(0).max(130)
});

const { error, value } = userSchema.validate(req.body);

if (error) {
  return res.status(400).json({ error: error.details[0].message });
}

// value содержит валидированные и очищенные данные
```

### 5. Защита от командных инъекций

#### Избегайте прямой передачи пользовательского ввода в команды:
```javascript
const { spawn } = require('child_process');

// НЕБЕЗОПАСНО
// exec(`ping ${req.query.host}`, callback);

// БЕЗОПАСНО - использование spawn с массивом аргументов
const host = req.query.host;

// Валидация хоста
if (!isValidHostname(host)) {
  return res.status(400).send('Неверный хост');
}

const child = spawn('ping', ['-c', '4', host]);

let output = '';
child.stdout.on('data', (data) => {
  output += data.toString();
});

child.on('close', (code) => {
  res.send(output);
});

function isValidHostname(hostname) {
  // Простая валидация hostname
  const hostnameRegex = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]))*$/;
  return hostnameRegex.test(hostname) && hostname.length <= 255;
}
```

#### Использование безопасных альтернатив:
```javascript
// Вместо системных команд используйте встроенные модули Node.js
const dns = require('dns');

// Вместо ping используем DNS-запрос
app.get('/check-host', (req, res) => {
  const host = req.query.host;
  
  if (!isValidHostname(host)) {
    return res.status(400).send('Неверный хост');
  }
  
  dns.lookup(host, (err, address) => {
    if (err) {
      res.status(400).send('Хост недоступен');
    } else {
      res.send(`Хост доступен: ${address}`);
    }
  });
});
```

## Практические рекомендации для фронтенд-разработчиков

### 1. Валидация на стороне клиента

Хотя клиентская валидация не заменяет серверную, она улучшает UX и может обнаружить простые попытки инъекций:

```javascript
// Валидация формы на клиенте
function validateForm(formData) {
  const errors = [];
  
  // Валидация email
  if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
    errors.push('Неверный формат email');
  }
  
  // Валидация длины полей
  if (formData.username && (formData.username.length < 3 || formData.username.length > 30)) {
    errors.push('Имя пользователя должно быть от 3 до 30 символов');
  }
  
  // Проверка на потенциальные инъекции
  const injectionPatterns = [/\b(OR|AND)\b/i, /('|--|\/\*|\*\/)/, /(;|\bEXEC\b)/i];
  for (const field in formData) {
    if (typeof formData[field] === 'string') {
      for (const pattern of injectionPatterns) {
        if (pattern.test(formData[field])) {
          errors.push(`Поле ${field} содержит подозрительные символы`);
          break;
        }
      }
    }
  }
  
  return errors;
}

// Использование валидации
document.getElementById('submitBtn').addEventListener('click', (e) => {
  const formData = new FormData(document.getElementById('userForm'));
  const plainFormData = Object.fromEntries(formData.entries());
  
  const errors = validateForm(plainFormData);
  if (errors.length > 0) {
    alert('Ошибки валидации: ' + errors.join(', '));
    e.preventDefault();
    return false;
  }
});
```

### 2. Очистка пользовательского ввода перед отправкой

```javascript
// Очистка данных перед отправкой на сервер
function sanitizeInput(input) {
  if (typeof input !== 'string') return input;
  
  // Удаление потенциально опасных символов
  return input
    .replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, '') // Удаление специальных символов
    .trim(); // Удаление пробелов
}

// Использование при отправке формы
async function submitForm(formData) {
  // Очистка всех строковых значений
  const sanitizedData = {};
  for (const key in formData) {
    sanitizedData[key] = typeof formData[key] === 'string' 
      ? sanitizeInput(formData[key]) 
      : formData[key];
  }
  
  const response = await fetch('/api/user', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(sanitizedData)
  });
  
  return response.json();
}
```

### 3. Использование Content Security Policy (CSP)

CSP помогает предотвратить выполнение внедренных скриптов:

```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';">
```

### 4. Защита при работе с API

```javascript
// Безопасная обработка данных из API
function processApiData(data) {
  // Валидация структуры данных
  if (!data || typeof data !== 'object') {
    throw new Error('Неверная структура данных');
  }
  
  // Валидация конкретных полей
  const requiredFields = ['id', 'name', 'email'];
  for (const field of requiredFields) {
    if (!(field in data)) {
      throw new Error(`Отсутствует поле: ${field}`);
    }
  }
  
  // Очистка потенциально опасных полей
  data.name = escapeHtml(data.name);
  data.email = escapeHtml(data.email);
  
  return data;
}

function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    ''': '&#039;'
  };
  
  return text.replace(/[&<>"']/g, m => map[m]);
}
```

## Современные инструменты и библиотеки

### 1. Библиотеки валидации

#### Joi:
```javascript
const Joi = require('joi');

const schema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  password: Joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')),
  email: Joi.string().email({
    minDomainSegments: 2,
    tlds: { allow: ['com', 'net', 'org'] }
  })
});

const { error, value } = schema.validate(req.body);
```

#### Yup:
```javascript
const yup = require('yup');

const userSchema = yup.object({
  username: yup.string().matches(/^[a-zA-Z0-9_]+$/, 'Только буквы, цифры и подчеркивания').min(3).max(30).required(),
  email: yup.string().email().required(),
  age: yup.number().integer().min(0).max(130)
});

try {
  await userSchema.validate(req.body);
} catch (error) {
  res.status(400).json({ error: error.message });
}
```

### 2. ORM с защитой от инъекций

#### Sequelize:
```javascript
// Sequelize автоматически защищает от инъекций
const user = await User.findOne({
  where: {
    id: req.params.id,  // автоматически экранируется
    email: req.body.email  // автоматически экранируется
  }
});
```

#### Mongoose (для MongoDB):
```javascript
// Mongoose также защищает от инъекций при правильном использовании
const user = await User.findOne({
  _id: req.params.id,  // валидируется как ObjectId
  email: req.body.email  // валидируется как строка
});
```

## Тестирование на уязвимости инъекций

### 1. Ручное тестирование

Примеры тестовых данных для поиска уязвимостей:
- `' OR '1'='1`
- `'; DROP TABLE users; --`
- `1;WAITFOR DELAY '00:00:10'--`
- `{"$ne": null}` (для NoSQL)

### 2. Автоматизированные инструменты

- OWASP ZAP
- SQLMap
- Burp Suite
- Snyk
- npm audit (для Node.js зависимостей)

### 3. Проверка кода

Используйте статические анализаторы кода:
- ESLint с плагинами безопасности
- SonarQube
- CodeQL

## Примеры безопасного кода

### Полностью защищенный обработчик запроса:
```javascript
const { body, validationResult } = require('express-validator');
const { User } = require('../models');

// Валидация с использованием express-validator
const validateUserInput = [
  body('username')
    .isLength({ min: 3, max: 30 })
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('Имя пользователя должно содержать только буквы, цифры и подчеркивания'),
  body('email')
    .isEmail()
    .normalizeEmail(),
  body('age')
    .isInt({ min: 0, max: 130 })
    .withMessage('Возраст должен быть числом от 0 до 130')
];

// Обработчик с валидацией
app.post('/user', validateUserInput, async (req, res) => {
  // Проверка ошибок валидации
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  try {
    // Использование безопасного ORM запроса
    const user = await User.create({
      username: req.body.username,
      email: req.body.email,
      age: req.body.age
    });
    
    res.status(201).json(user);
  } catch (error) {
    console.error('Ошибка создания пользователя:', error);
    res.status(500).json({ error: 'Внутренняя ошибка сервера' });
  }
});
```

### Защита от инъекций в сложных запросах:
```javascript
// Безопасная реализация поиска с фильтрами
async function searchUsers(filters) {
  const whereClause = {};
  
  // Безопасное добавление фильтров
  if (filters.username) {
    // Проверка формата и длины
    if (typeof filters.username === 'string' && 
        /^[a-zA-Z0-9_]{3,30}$/.test(filters.username)) {
      whereClause.username = filters.username;
    }
  }
  
  if (filters.minAge !== undefined) {
    const age = parseInt(filters.minAge, 10);
    if (!isNaN(age) && age >= 0 && age <= 130) {
      whereClause.age = { [Op.gte]: age };
    }
  }
  
  if (filters.email) {
    // Валидация email
    if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(filters.email)) {
      whereClause.email = filters.email;
    }
  }
  
  // Выполнение безопасного запроса
  return await User.findAll({ where: whereClause });
}
```

## Заключение

Защита от инъекций требует комплексного подхода, включающего правильную обработку пользовательского ввода, использование безопасных методов работы с базами данных и регулярное тестирование кода на уязвимости. Ключевые принципы защиты:

1. Всегда использовать параметризованные запросы
2. Валидировать и экранировать пользовательский ввод
3. Применять принцип минимальных привилегий
4. Регулярно обновлять зависимости и проверять код на уязвимости

Помните, что безопасность - это не разовое мероприятие, а непрерывный процесс, требующий внимания на всех этапах разработки.

## См. также
- [[Основы-веб-безопасности]]
- [[XSS-защита]]
- [[CSRF-защита]]
- [[Безопасность-аутентификации]]
- [[HTTP-заголовки-безопасности]]