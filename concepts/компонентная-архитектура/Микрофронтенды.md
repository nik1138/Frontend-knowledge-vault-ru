---
aliases: [Microfrontends, Микрофронтенд архитектура]
tags: [frontend, architecture, microservices, scalability]
---

# Микрофронтенды

Микрофронтенды — это архитектурный подход к разработке пользовательского интерфейса, вдохновленный микросервисной архитектурой. Он позволяет разбивать монолитное фронтенд-приложение на более мелкие, независимо развертываемые фрагменты.

## Основные принципы микрофронтендов

### 1. Независимая разработка
Каждая команда может разрабатывать, тестировать, развертывать и обслуживать свой фрагмент интерфейса независимо от других команд.

### 2. Технологическая независимость
Разные части приложения могут использовать разные фреймворки и библиотеки (React, Vue, Angular и т.д.).

### 3. Автономное развертывание
Каждый микрофронтенд может быть развернут независимо без влияния на другие части приложения.

## Архитектурные паттерны микрофронтендов

### 1. Паттерн "Shell and Widget"
Центральный каркас приложения (shell) загружает виджеты (widgets) из разных источников.

```html
<!DOCTYPE html>
<html>
<head>
  <title>Микрофронтенд Shell</title>
</head>
<body>
  <div id="header"></div>
  <div id="navigation"></div>
  <div id="content"></div>
  <div id="footer"></div>

  <script>
    // Загрузка компонентов из разных источников
    import('./header-widget.js').then(widget => widget.mount('#header'));
    import('./nav-widget.js').then(widget => widget.mount('#navigation'));
    import('./content-widget.js').then(widget => widget.mount('#content'));
    import('./footer-widget.js').then(widget => widget.mount('#footer'));
  </script>
</body>
</html>
```

### 2. Паттерн "Build-Time Integration"
Компоненты собираются в единое приложение на этапе сборки.

### 3. Паттерн "Run-Time Integration"
Компоненты интегрируются во время выполнения приложения.

## Реализация с помощью Webpack Module Federation

Webpack 5 предоставляет возможность делиться модулями между приложениями в рантайме:

```javascript
// webpack.config.js (host приложение)
module.exports = {
  entry: './src/index',
  mode: 'development',
  output: {
    publicPath: 'http://localhost:3000/',
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: { loader: 'babel-loader' },
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'host_app',
      remotes: {
        user_dashboard: 'user_dashboard@http://localhost:3001/remoteEntry.js',
        product_catalog: 'product_catalog@http://localhost:3002/remoteEntry.js',
      },
    }),
  ],
};
```

```javascript
// webpack.config.js (удаленное приложение - user_dashboard)
module.exports = {
  entry: './src/index',
  mode: 'development',
  output: {
    publicPath: 'http://localhost:3001/',
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: { loader: 'babel-loader' },
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'user_dashboard',
      filename: 'remoteEntry.js',
      exposes: {
        './UserDashboard': './src/UserDashboard',
      },
      shared: ['react', 'react-dom'],
    }),
  ],
};
```

### Использование удаленного компонента

```jsx
// App.jsx (host приложение)
import React, { lazy, Suspense } from 'react';

// Ленивая загрузка удаленного компонента
const UserDashboard = lazy(() => import('user_dashboard/UserDashboard'));

const App = () => (
  <div>
    <header>Общий заголовок</header>
    <main>
      <Suspense fallback={<div>Загрузка...</div>}>
        <UserDashboard />
      </Suspense>
    </main>
    <footer>Общий футер</footer>
  </div>
);
```

## Паттерны коммуникации между микрофронтендами

### 1. Custom Events (Пользовательские события)

```javascript
// Отправка события из одного микрофронтенда
window.dispatchEvent(new CustomEvent('user-updated', {
  detail: { userId: 123, name: 'John Doe' }
}));

// Получение события в другом микрофронтенде
window.addEventListener('user-updated', (event) => {
  console.log('Пользователь обновлен:', event.detail);
});
```

### 2. Shared State (Общее состояние)

```javascript
// Использование общего хранилища
window.globalState = {
  user: null,
  cart: [],
  theme: 'light'
};

// Обновление состояния
window.globalState.user = { id: 1, name: 'John' };

// Подписка на изменения
Object.defineProperty(window.globalState, 'user', {
  set: function(value) {
    this._user = value;
    // Уведомление других микрофронтендов
    window.dispatchEvent(new CustomEvent('global-state-changed', {
      detail: { key: 'user', value }
    }));
  },
  get: function() {
    return this._user;
  }
});
```

### 3. Message Bus

```javascript
// Простая реализация Message Bus
class EventBus {
  constructor() {
    this.channels = {};
  }

  subscribe(channel, callback) {
    if (!this.channels[channel]) {
      this.channels[channel] = [];
    }
    this.channels[channel].push(callback);
  }

  publish(channel, data) {
    if (this.channels[channel]) {
      this.channels[channel].forEach(callback => callback(data));
    }
  }
}

// Глобальный экземпляр
window.eventBus = new EventBus();

// Использование в микрофронтендах
window.eventBus.subscribe('cart-updated', (data) => {
  console.log('Корзина обновлена:', data);
});

window.eventBus.publish('user-logged-in', { userId: 123 });
```

## Практические рекомендации по внедрению

### 1. Определение границ
Разделяйте приложение по бизнес-функциям, а не по технологиям:
- Профиль пользователя
- Каталог товаров
- Корзина покупок
- Платежи

### 2. Согласование интерфейсов
Установите единые соглашения о взаимодействии между микрофронтендами:
- Форматы данных
- События
- API вызовы

### 3. Обработка ошибок
Обеспечьте изоляцию ошибок:
```javascript
const withErrorBoundary = (Component) => {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
      return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
      console.error('Ошибка в микрофронтенде:', error, errorInfo);
    }

    render() {
      if (this.state.hasError) {
        return <div>Ошибка в компоненте</div>;
      }
      return <Component {...this.props} />;
    }
  };
};
```

### 4. Управление зависимостями
Используйте стратегии разрешения зависимостей:
- Shared dependencies (общие зависимости)
- Unique dependencies (уникальные зависимости для каждого микрофронтенда)

## Преимущества микрофронтендов

- **Масштабируемость**: Возможность масштабирования команд
- **Технологическая гибкость**: Использование разных технологий
- **Независимое развертывание**: Команды могут развертывать независимо
- **Изолированность ошибок**: Ошибка в одном микрофронтенде не влияет на другие
- **Быстрое время сборки**: Меньше кода в каждом микрофронтенде

## Недостатки микрофронтендов

- **Сложность архитектуры**: Увеличенная сложность взаимодействия
- **Повторение кода**: Возможное дублирование библиотек
- **Проблемы с производительностью**: Загрузка нескольких фреймворков
- **Тестирование**: Сложнее тестировать интеграцию
- **SEO**: Потенциальные проблемы с индексацией

## Когда использовать микрофронтенды

Микрофронтенды подходят для:
- Крупных приложений с несколькими командами
- Приложений, где команды отвечают за разные функциональные области
- Проектов с долгосрочной перспективой развития
- Ситуаций, когда требуется использовать разные технологии

## Связанные концепции

- [[Архитектурные-паттерны-компонентов]]
- [[Компонентные-библиотеки]]
- [[Архитектура-UI-компонентов]]
- [[Дизайн-системы-и-архитектура]]

## Теги

#frontend #architecture #microservices #scalability #module-federation #web-components