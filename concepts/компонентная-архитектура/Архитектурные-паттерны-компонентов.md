---
aliases: [Паттерны компонентов, Компонентные паттерны]
tags: [frontend, architecture, components, patterns]
---

# Архитектурные паттерны компонентов

Архитектурные паттерны компонентов — это проверенные временем подходы к структурированию и организации UI-компонентов в современных фронтенд-приложениях. Они помогают создавать масштабируемые, поддерживаемые и переиспользуемые интерфейсы.

## Обзор архитектурных паттернов

### 1. Паттерн "Контейнеры и презентационные компоненты" (Container and Presentational Components)

Этот паттерн разделяет компоненты на две категории:

- **Презентационные компоненты** (Presentational) — отвечают за внешний вид и рендеринг данных
- **Контейнерные компоненты** (Container) — управляют логикой и состоянием

```jsx
// Презентационный компонент
const UserCard = ({ user, onEdit }) => (
  <div className="user-card">
    <h3>{user.name}</h3>
    <p>{user.email}</p>
    <button onClick={onEdit}>Редактировать</button>
  </div>
);

// Контейнерный компонент
class UserContainer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { users: [] };
  }

  componentDidMount() {
    this.fetchUsers();
  }

  fetchUsers = async () => {
    const users = await api.getUsers();
    this.setState({ users });
  };

  handleEdit = (userId) => {
    // Логика редактирования
  };

  render() {
    return (
      <div>
        {this.state.users.map(user => (
          <UserCard 
            key={user.id} 
            user={user} 
            onEdit={() => this.handleEdit(user.id)} 
          />
        ))}
      </div>
    );
  }
}
```

### 2. Паттерн "Состояние машины" (State Machine Pattern)

Используется для управления сложными состояниями компонентов с помощью предсказуемых переходов:

```javascript
import { createMachine, interpret } from 'xstate';

const modalMachine = createMachine({
  id: 'modal',
  initial: 'closed',
  states: {
    closed: {
      on: { OPEN: 'open' }
    },
    open: {
      on: { CLOSE: 'closed' }
    }
  }
});

const useMachine = (machine) => {
  const [current, send] = React.useReducer(
    (state, event) => machine.transition(state, event),
    machine.initialState
  );

  return [current, send];
};

const Modal = () => {
  const [state, send] = useMachine(modalMachine);

  return (
    <div className={`modal ${state.value}`}>
      <button onClick={() => send('OPEN')}>Открыть</button>
      {state.value === 'open' && (
        <div className="modal-content">
          <h2>Содержимое модального окна</h2>
          <button onClick={() => send('CLOSE')}>Закрыть</button>
        </div>
      )}
    </div>
  );
};
```

### 3. Паттерн "Render Props"

Позволяет делиться кодом между компонентами с помощью функции-свойства:

```jsx
const MouseTracker = ({ children }) => {
  const [position, setPosition] = React.useState({ x: 0, y: 0 });

  React.useEffect(() => {
    const handleMouseMove = (event) => {
      setPosition({
        x: event.clientX,
        y: event.clientY
      });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  return children(position);
};

const App = () => (
  <MouseTracker>
    {({ x, y }) => (
      <div>Позиция мыши: {x}, {y}</div>
    )}
  </MouseTracker>
);
```

### 4. Паттерн "Компоненты высшего порядка" (Higher-Order Components)

Функции, которые принимают компонент и возвращают новый компонент с дополнительной функциональностью:

```javascript
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <div>Загрузка...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

const withErrorHandling = (WrappedComponent) => {
  return (props) => {
    if (props.error) {
      return <div>Ошибка: {props.error.message}</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

// Использование
const EnhancedUserList = withLoading(withErrorHandling(UserList));
```

### 5. Паттерн "Compound Components" (Составные компоненты)

Позволяет создавать связанные компоненты, которые взаимодействуют друг с другом:

```jsx
const Select = ({ children, value, onChange }) => {
  return (
    <div className="select">
      {React.Children.map(children, child =>
        React.cloneElement(child, { value, onChange })
      )}
    </div>
  );
};

const SelectTrigger = ({ children, onClick }) => (
  <button className="select-trigger" onClick={onClick}>
    {children}
  </button>
);

const SelectContent = ({ children, value }) => (
  <div className="select-content">
    {React.Children.map(children, child =>
      React.cloneElement(child, { value })
    )}
  </div>
);

const SelectOption = ({ children, value, optionValue, onChange }) => (
  <div 
    className={`select-option ${value === optionValue ? 'selected' : ''}`}
    onClick={() => onChange(optionValue)}
  >
    {children}
  </div>
);

// Использование
const App = () => {
  const [selectedValue, setSelectedValue] = React.useState('');
  
  return (
    <Select value={selectedValue} onChange={setSelectedValue}>
      <SelectTrigger>Выберите опцию</SelectTrigger>
      <SelectContent value={selectedValue}>
        <SelectOption optionValue="option1">Опция 1</SelectOption>
        <SelectOption optionValue="option2">Опция 2</SelectOption>
        <SelectOption optionValue="option3">Опция 3</SelectOption>
      </SelectContent>
    </Select>
  );
};
```

## Принципы проектирования компонентов

### 1. Единственная обязанность (Single Responsibility)
Каждый компонент должен иметь одну четко определенную цель.

### 2. Переиспользуемость
Компоненты должны быть спроектированы так, чтобы их можно было использовать в разных контекстах.

### 3. Предсказуемость
Компоненты должны предсказуемо реагировать на изменения входных данных.

### 4. Изолированность
Компоненты должны быть максимально изолированы от внешнего контекста.

## Практические рекомендации

- Используйте имена компонентов, отражающие их функцию
- Следите за глубиной вложенности компонентов
- Документируйте интерфейсы компонентов (props)
- Используйте типизацию (TypeScript/PropTypes) для повышения надежности
- Пишите юнит-тесты для компонентов

## Связанные концепции

- [[Микрофронтенды]]
- [[Компонентные-библиотеки]]
- [[Архитектура-UI-компонентов]]
- [[Дизайн-системы-и-архитектура]]

## Теги

#frontend #architecture #components #patterns #react #vue #angular