---
aliases: ["Функциональное программирование", "ФП", "Pure Functions", "Immutability"]
tags: 
  - programming
  - functional-programming
  - concepts
  - javascript
  - typescript
  - fp
---

# Функциональное программирование: Основные концепции

Функциональное программирование (ФП) — это парадигма программирования, в которой вычисления рассматриваются как вычисления математических функций без изменения состояния и без побочных эффектов. Эта парадигма подчеркивает использование чистых функций, неизменяемых данных и декларативного стиля программирования.

## Чистые функции (Pure Functions)

**Чистая функция** — это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не вызывает побочных эффектов. Она не зависит от внешнего состояния и не изменяет его.

### Характеристики:
- Всегда возвращает одинаковый результат при одинаковых аргументах
- Не зависит от внешнего состояния (глобальные переменные, файловая система и т.д.)
- Не производит побочных эффектов (изменение глобальных переменных, запись в файл, вывод на экран и т.д.)

```javascript
// Чистая функция
const add = (a, b) => a + b;

// Нечистая функция - зависит от внешнего состояния
let x = 10;
const addWithX = (y) => x + y;

// Нечистая функция - производит побочный эффект
const addToLog = (a, b) => {
  const result = a + b;
  console.log(result); // побочный эффект
  return result;
};
```

См. также: [[immutability]] и [[side-effects]]

## Неизменяемость (Immutability)

**Неизменяемость** означает, что данные не могут быть изменены после создания. Вместо изменения существующих данных создаются новые структуры с необходимыми изменениями.

```javascript
// Мутабельный подход
const arr = [1, 2, 3];
arr.push(4); // изменяет исходный массив

// Иммутабельный подход
const arr2 = [1, 2, 3];
const newArr = [...arr2, 4]; // создает новый массив
```

См. также: [[data-structures]] и [[state-management]]

## Функции высшего порядка (Higher-Order Functions)

**Функция высшего порядка** — это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как результат.

```javascript
// Функция, принимающая другую функцию
const applyOperation = (x, operation) => operation(x);

// Функция, возвращающая другую функцию
const createMultiplier = (factor) => (num) => num * factor;

const double = createMultiplier(2);
console.log(double(5)); // 10
```

См. также: [[callbacks]] и [[closures]]

## Map, Filter, Reduce

Это три основных метода функционального программирования для работы с коллекциями данных:

### Map
Преобразует каждый элемент коллекции в соответствии с заданной функцией:

```javascript
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(n => n * 2); // [2, 4, 6, 8]
```

### Filter
Фильтрует элементы коллекции на основе предиката:

```javascript
const numbers = [1, 2, 3, 4, 5, 6];
const evens = numbers.filter(n => n % 2 === 0); // [2, 4, 6]
```

### Reduce
Сводит все элементы коллекции к одному значению:

```javascript
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 10
```

См. также: [[arrays]] и [[iterators]]

## Каррирование (Currying)

**Каррирование** — это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.

```javascript
// Функция с несколькими аргументами
const add = (a, b, c) => a + b + c;

// Каррированная версия
const curryAdd = a => b => c => a + b + c;

const add5 = curryAdd(5); // функция, которая добавляет 5
const add5And3 = add5(3); // функция, которая добавляет 8
console.log(add5And3(2)); // 10
```

См. также: [[partial-application]]

## Функциональная композиция (Functional Composition)

**Функциональная композиция** — это техника объединения двух или более функций для создания новой функции, где результат одной функции становится аргументом следующей.

```javascript
const compose = (f, g) => (x) => f(g(x));

const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;

const addOneThenMultiplyByTwo = compose(multiplyByTwo, addOne);
console.log(addOneThenMultiplyByTwo(5)); // 12
```

См. также: [[design-patterns]]

## Функторы и монады (Functors and Monads)

### Функторы
**Функтор** — это контейнер, который позволяет применить функцию к содержимому без извлечения его из контейнера.

```javascript
// Простой функтор Maybe
const Maybe = value => ({
  map: fn => value === null || value === undefined ? Maybe(null) : Maybe(fn(value)),
  value: value
});

const result = Maybe(5)
  .map(x => x * 2)
  .map(x => x + 1)
  .value; // 11
```

### Монады
**Монада** — это функтор с дополнительной функцией `flatMap` (или `chain`), позволяющей работать с вложенными контейнерами.

```javascript
// Простая монада Maybe
const MaybeMonad = value => ({
  map: fn => value === null || value === undefined ? MaybeMonad(null) : MaybeMonad(fn(value)),
  flatMap: fn => value === null || value === undefined ? MaybeMonad(null) : fn(value),
  value: value
});
```

См. также: [[advanced-functional-patterns]]

## Референциальная прозрачность (Referential Transparency)

**Референциальная прозрачность** означает, что выражение может быть заменено его значением без изменения поведения программы. Это возможно только в отсутствие побочных эффектов.

```javascript
// Выражение с референциальной прозрачностью
const result = add(2, 3); // можно заменить на 5 без изменения поведения

// Выражение без референциальной прозрачности
const result = Math.random(); // каждый вызов дает разное значение
```

## Избегание побочных эффектов (Avoiding Side Effects)

Побочный эффект возникает, когда функция взаимодействует с внешним миром: изменяет переменные, записывает в файл, выводит на экран и т.д. В функциональном программировании стараются минимизировать побочные эффекты.

```javascript
// Побочный эффект - изменение глобальной переменной
let counter = 0;
const increment = () => counter++; // нечистая функция

// Без побочных эффектов - возвращаем новое значение
const incrementPure = (value) => value + 1;
```

См. также: [[side-effects]]

## Функциональное vs Императивное программирование

| Аспект | Функциональное программирование | Императивное программирование |
|--------|----------------------------------|-------------------------------|
| Парадигма | Декларативная | Императивная |
| Акцент | Что нужно сделать | Как нужно сделать |
| Состояние | Неизменяемое | Изменяемое |
| Циклы | Рекурсия, функции высшего порядка | for, while |
| Функции | Чистые, без побочных эффектов | Могут иметь побочные эффекты |

## Практические примеры на разных языках

### JavaScript
```javascript
// Рассчитать сумму квадратов четных чисел
const numbers = [1, 2, 3, 4, 5, 6];
const sumOfSquaredEvens = numbers
  .filter(n => n % 2 === 0)
  .map(n => n * n)
  .reduce((acc, curr) => acc + curr, 0); // 52
```

### Haskell
```haskell
-- Рассчитать сумму квадратов четных чисел
sumOfSquaredEvens :: [Int] -> Int
sumOfSquaredEvens xs = sum $ map (^2) $ filter even xs
```

### Python
```python
from functools import reduce

# Рассчитать сумму квадратов четных чисел
numbers = [1, 2, 3, 4, 5, 6]
sum_of_squared_evens = reduce(
    lambda acc, curr: acc + curr,
    map(lambda x: x * x, filter(lambda x: x % 2 == 0, numbers)),
    0
)  # 52
```

## Заключение

Функциональное программирование предоставляет мощные концепции для создания более предсказуемых, тестируемых и надежных программ. Хотя полный переход на функциональный стиль может быть сложным, внедрение отдельных принципов в императивные языки может значительно улучшить качество кода.

См. также: [[programming-paradigms]], [[functional-design-patterns]], и [[functional-vs-oop]]
