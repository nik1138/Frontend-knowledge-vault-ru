# Структуры данных

## Определение структур данных

**Структура данных** — это способ организации и хранения данных в компьютере, который позволяет эффективно обращаться к ним и модифицировать. Правильный выбор структуры данных критически важен для производительности программного обеспечения, так как влияет на скорость выполнения операций, использование памяти и сложность реализации.

> [!note] Заметка
> Структуры данных лежат в основе всех алгоритмов и программных решений. Они определяют, как данные хранятся, организуются и манипулируются в программе.

## Основные типы структур данных

### Линейные структуры

#### Массивы (Arrays)
Массив — это коллекция элементов, доступ к которым осуществляется по индексу. Элементы хранятся в непрерывной области памяти.

```javascript
// Пример массива в JavaScript
let numbers = [10, 20, 30, 40, 50];
console.log(numbers[2]); // 30
```

#### Связные списки (Linked Lists)
Связный список состоит из узлов, где каждый узел содержит данные и ссылку на следующий узел.

```javascript
// Пример односвязного списка
class ListNode {
    constructor(val, next) {
        this.val = (val === undefined ? 0 : val);
        this.next = (next === undefined ? null : next);
    }
}

let node3 = new ListNode(30);
let node2 = new ListNode(20, node3);
let node1 = new ListNode(10, node2);
```

### Нелинейные структуры

#### Деревья (Trees)
Дерево — иерархическая структура, состоящая из узлов, где один узел является корнем, а остальные узлы разделены на непересекающиеся поддеревья.

```javascript
// Пример бинарного дерева
class TreeNode {
    constructor(val, left, right) {
        this.val = (val === undefined ? 0 : val);
        this.left = (left === undefined ? null : left);
        this.right = (right === undefined ? null : right);
    }
}

let root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
```

#### Графы (Graphs)
Граф — набор узлов (вершин) и рёбер, соединяющих пары узлов. Может быть направленным или ненаправленным.

```javascript
// Представление графа с помощью списка смежности
class Graph {
    constructor(vertices) {
        this.vertices = vertices;
        this.adjacencyList = new Map();
    }

    addVertex(vertex) {
        this.adjacencyList.set(vertex, []);
    }

    addEdge(vertex1, vertex2) {
        this.adjacencyList.get(vertex1).push(vertex2);
        this.adjacencyList.get(vertex2).push(vertex1); // Для ненаправленного графа
    }
}
```

#### Хэш-таблицы (Hash Tables)
Хэш-таблица — структура данных, реализующая ассоциативный массив, сопоставляющий ключи со значениями с помощью хэш-функции.

```javascript
// Пример использования Map в JavaScript (реализация хэш-таблицы)
let hashTable = new Map();
hashTable.set("ключ1", "значение1");
hashTable.set("ключ2", "значение2");
console.log(hashTable.get("ключ1")); // "значение1"
```

## Основные операции над структурами данных

Каждая структура данных поддерживает определённый набор операций:

- **Поиск (Search)** — нахождение элемента с заданным ключом
- **Вставка (Insert)** — добавление нового элемента
- **Удаление (Delete)** — удаление элемента
- **Обход (Traverse)** — последовательный доступ ко всем элементам
- **Сортировка (Sort)** — упорядочивание элементов

Пример реализации операций для связного списка:

```javascript
class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }

    insertAtBeginning(data) {
        const newNode = new ListNode(data, this.head);
        this.head = newNode;
        this.size++;
    }

    search(data) {
        let current = this.head;
        let index = 0;
        while (current !== null) {
            if (current.val === data) {
                return index;
            }
            current = current.next;
            index++;
        }
        return -1; // Элемент не найден
    }

    delete(data) {
        let current = this.head;
        let prev = null;

        while (current !== null) {
            if (current.val === data) {
                if (prev === null) {
                    this.head = current.next; // Удаление первого элемента
                } else {
                    prev.next = current.next;
                }
                this.size--;
                return true;
            }
            prev = current;
            current = current.next;
        }
        return false; // Элемент не найден
    }
}
```

## Выбор подходящей структуры данных

Выбор структуры данных зависит от:

1. **Типа задачи** — что нужно делать с данными
2. **Частоты операций** — какие операции будут выполняться чаще всего
3. **Ограничений по памяти** — сколько памяти доступно
4. **Требований к производительности** — какие операции должны быть быстрыми

Например:
- Для частого доступа по индексу — массив
- Для частых вставок/удалений — связный список
- Для поиска с логарифмической сложностью — сбалансированное дерево
- Для быстрого поиска по ключу — хэш-таблица

## Рассмотрение памяти

Разные структуры данных имеют разные требования к памяти:

| Структура | Память | Особенности |
|-----------|--------|-------------|
| Массив | Непрерывная | Предсказуемое размещение, кэш-дружелюбный |
| Связный список | Разбросанная | Указатели требуют дополнительной памяти |
| Хэш-таблица | Переменная | Зависит от коэффициента загрузки |
| Дерево | Разбросанная | Дополнительная память для указателей на потомков |

## Характеристики производительности

| Структура | Доступ | Поиск | Вставка | Удаление | Комментарии |
|-----------|--------|-------|---------|----------|-------------|
| Массив | O(1) | O(n) | O(n) | O(n) | Если индекс известен |
| Связный список | O(n) | O(n) | O(1) | O(1) | Если позиция известна |
| Бинарное дерево | O(log n) | O(log n) | O(log n) | O(log n) | Сбалансированное |
| Хэш-таблица | N/A | O(1) | O(1) | O(1) | В среднем случае |

## Практические примеры

### 1. Использование стека для проверки сбалансированных скобок

```javascript
function isBalanced(expression) {
    const stack = [];
    const pairs = { ')': '(', '}': '{', ']': '[' };
    
    for (let char of expression) {
        if (['(', '{', '['].includes(char)) {
            stack.push(char);
        } else if ([')', '}', ']'].includes(char)) {
            if (stack.pop() !== pairs[char]) {
                return false;
            }
        }
    }
    
    return stack.length === 0;
}
```

### 2. Использование очереди для обработки задач

```javascript
class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(element) {
        this.items.push(element);
    }
    
    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
}

const taskQueue = new Queue();
taskQueue.enqueue("Задача 1");
taskQueue.enqueue("Задача 2");
console.log(taskQueue.dequeue()); // "Задача 1"
```

## Связь с другими концепциями

Структуры данных тесно связаны с другими фундаментальными концепциями программирования:

- [[algorithms]] — эффективные алгоритмы часто зависят от правильного выбора структуры данных
- [[time-complexity]] — анализ сложности операций над структурами данных
- [[memory-management]] — способы распределения и освобождения памяти
- [[design-patterns]] — шаблоны проектирования часто используют определённые структуры данных

## Заключение

Понимание структур данных критически важно для разработки эффективного программного обеспечения. Правильный выбор структуры данных может значительно улучшить производительность приложения и упростить реализацию алгоритмов. Важно учитывать не только теоретические характеристики структур данных, но и практические аспекты их использования в конкретной задаче.

> [!tip] Совет
> Всегда анализируйте требования к операциям, которые будут выполняться над данными, перед выбором структуры данных.

---

**Теги:** #programming #data-structures #computer-science #algorithms #complexity #arrays #linked-lists #trees #graphs #hash-tables