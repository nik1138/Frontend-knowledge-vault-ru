---
aliases: [Обработка ошибок, Ошибки в асинхронном коде, Async Error Handling]
tags: [javascript, async-programming, error-handling, frontend]
---

# Обработка ошибок в асинхронном коде

## Описание

Обработка ошибок в асинхронном коде требует особого подхода, так как стандартные конструкции try/catch не работают с асинхронными операциями, которые завершаются после возврата из функции. Правильная обработка ошибок критически важна для стабильности приложений.

## Проблемы с традиционной обработкой ошибок

### Проблема с колбэками

```javascript
// НЕПРАВИЛЬНО - ошибка не будет перехвачена
try {
    setTimeout(() => {
        throw new Error('Асинхронная ошибка');
    }, 1000);
} catch (error) {
    console.log('Ошибка перехвачена:', error.message); // Не выполнится
}

// ПРАВИЛЬНО - обработка ошибки в колбэке
function asyncOperation(callback) {
    setTimeout(() => {
        try {
            const result = riskyOperation();
            callback(null, result);
        } catch (error) {
            callback(error, null);
        }
    }, 1000);
}
```

## Обработка ошибок в промисах

### Использование .catch()

```javascript
// Обработка ошибок в цепочке промисов
fetch('/api/data')
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ошибка! Статус: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Данные получены:', data);
        return processData(data);
    })
    .then(processedData => {
        console.log('Данные обработаны:', processedData);
    })
    .catch(error => {
        console.error('Произошла ошибка:', error.message);
    });
```

### Обработка ошибок в Promise.all()

```javascript
// При использовании Promise.all() ошибка одного промиса приводит к отклонению всего Promise.all
Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments')
])
.then(([users, posts, comments]) => {
    console.log('Все данные получены:', { users, posts, comments });
})
.catch(error => {
    console.error('Ошибка в одном из запросов:', error);
    // Важно: мы не знаем, какой именно промис вызвал ошибку
});

// Альтернатива: обработка ошибок индивидуально
Promise.all([
    fetch('/api/users').catch(err => ({ error: err, type: 'users' })),
    fetch('/api/posts').catch(err => ({ error: err, type: 'posts' })),
    fetch('/api/comments').catch(err => ({ error: err, type: 'comments' }))
])
.then(results => {
    results.forEach((result, index) => {
        if (result.error) {
            console.error(`Ошибка в запросе ${index}:`, result.error);
        } else {
            console.log(`Запрос ${index} успешен:`, result);
        }
    });
});
```

## Обработка ошибок с async/await

### Базовая обработка ошибок

```javascript
// Использование try/catch в async функциях
async function fetchData() {
    try {
        const response = await fetch('/api/data');
        
        if (!response.ok) {
            throw new Error(`HTTP ошибка! Статус: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Ошибка при получении данных:', error.message);
        throw error; // Перебрасываем ошибку для обработки в вызывающем коде
    }
}

// Вызов функции с обработкой ошибок
fetchData()
    .then(data => console.log('Данные:', data))
    .catch(error => console.error('Ошибка в вызове:', error.message));
```

### Обработка ошибок в цепочке async/await

```javascript
async function complexOperation() {
    try {
        const userData = await fetch('/api/user').then(r => r.json());
        const postsData = await fetch('/api/posts').then(r => r.json());
        const processedData = await processAllData(userData, postsData);
        
        return processedData;
    } catch (error) {
        // Логирование ошибки с контекстом
        console.error('Ошибка в сложной операции:', {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
        
        // Можем трансформировать ошибку для более понятного сообщения
        throw new Error('Не удалось выполнить сложную операцию: ' + error.message);
    }
}
```

### Универсальный обработчик ошибок

```javascript
// Универсальный обработчик для async функций
function withErrorHandling(asyncFunction) {
    return async function(...args) {
        try {
            return await asyncFunction.apply(this, args);
        } catch (error) {
            console.error('Необработанная ошибка в асинхронной функции:', error);
            // Здесь можно добавить логирование в систему мониторинга
            throw error;
        }
    };
}

// Использование
const safeFetchData = withErrorHandling(async () => {
    const response = await fetch('/api/data');
    return response.json();
});
```

## Глобальная обработка необработанных ошибок

### Unhandled Promise Rejections

```javascript
// Обработка необработанных отклонений промисов
window.addEventListener('unhandledrejection', event => {
    console.error('Необработанное отклонение промиса:', event.reason);
    
    // Предотвращение вывода ошибки в консоль по умолчанию (опционально)
    // event.preventDefault();
});

// Пример ошибки, которая будет перехвачена
Promise.reject(new Error('Это необработанная ошибка'));
```

### Обработка ошибок на уровне приложения

```javascript
// Обертка для безопасного выполнения асинхронных операций
class AsyncErrorHandler {
    static async execute(asyncOperation, options = {}) {
        const { 
            retries = 0, 
            delay = 1000, 
            onError = null, 
            onSuccess = null 
        } = options;
        
        let lastError;
        
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                const result = await asyncOperation();
                
                if (onSuccess) {
                    onSuccess(result, attempt);
                }
                
                return result;
            } catch (error) {
                lastError = error;
                
                if (onError) {
                    onError(error, attempt);
                }
                
                // Если это не последняя попытка, ждем перед повтором
                if (attempt < retries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        // Все попытки не удались
        throw new Error(`Операция не удалась после ${retries + 1} попыток. Последняя ошибка: ${lastError.message}`);
    }
}

// Использование
AsyncErrorHandler.execute(
    () => fetch('/api/data').then(r => r.json()),
    {
        retries: 3,
        delay: 2000,
        onError: (error, attempt) => console.error(`Попытка ${attempt + 1} не удалась:`, error.message),
        onSuccess: (result) => console.log('Успех:', result)
    }
)
.then(result => console.log('Окончательный результат:', result))
.catch(error => console.error('Окончательная ошибка:', error.message));
```

## Практические советы

1. **Всегда обрабатывайте ошибки** - даже если кажется, что ошибка не может произойти
2. **Используйте try/catch с async/await** - это наиболее читаемый способ обработки ошибок
3. **Логируйте ошибки с контекстом** - включайте информацию о том, где и при каких условиях произошла ошибка
4. **Не игнорируйте Promise.reject()** - всегда обрабатывайте отклоненные промисы
5. **Используйте глобальные обработчики** - для перехвата необработанных ошибок
6. **Реализуйте retry-логику** - для не критичных операций, которые могут временно не удаваться
7. **Создавайте пользовательские ошибки** - для более точного определения причин проблем

## Распространенные ошибки

```javascript
// ОШИБКА: Забытый await
async function wrongExample() {
    try {
        // fetch возвращает Promise, но мы не используем await
        const response = fetch('/api/data'); // Это Promise, а не Response!
        const data = await response.json(); // Ошибка: response.json is not a function
    } catch (error) {
        console.error(error);
    }
}

// ПРАВИЛЬНО: Использование await
async function correctExample() {
    try {
        const response = await fetch('/api/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Ошибка:', error.message);
        throw error;
    }
}

// ОШИБКА: Неправильная обработка ошибок в Promise.all
async function badParallelHandling() {
    try {
        const [users, posts, comments] = await Promise.all([
            fetch('/api/users').then(r => r.json()),
            fetch('/api/posts').then(r => r.json()),
            fetch('/api/comments').then(r => r.json())
        ]);
    } catch (error) {
        // Мы не знаем, какой именно запрос вызвал ошибку
        console.error('Ошибка при получении данных:', error);
    }
}

// ПРАВИЛЬНО: Индивидуальная обработка ошибок
async function goodParallelHandling() {
    const [usersPromise, postsPromise, commentsPromise] = [
        fetch('/api/users').then(r => r.json()),
        fetch('/api/posts').then(r => r.json()),
        fetch('/api/comments').then(r => r.json())
    ];
    
    try {
        const users = await usersPromise;
        const posts = await postsPromise;
        const comments = await commentsPromise;
        
        return { users, posts, comments };
    } catch (error) {
        console.error('Ошибка при получении данных:', error);
        throw error;
    }
}
```

## Связанные темы

- [[Async-Await]] - особенности обработки ошибок с async/await
- [[Promises]] - обработка ошибок в промисах
- [[Callbacks]] - традиционный подход к обработке ошибок
- [[Event-Loop]] - как обработка ошибок взаимодействует с циклом событий