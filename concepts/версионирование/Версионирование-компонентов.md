---
aliases: ["Component Versioning", "Версионирование компонентов", "UI Component Versioning"]
tags: ["#component-architecture", "#versioning", "#frontend-development", "#ui-components"]
---

# Версионирование компонентов

## Определение

**Версионирование компонентов** — это процесс управления изменениями в компонентах пользовательского интерфейса, включая их API, поведение и визуальное представление. Это позволяет поддерживать совместимость между различными версиями компонентов в приложении и в библиотеках компонентов.

## Основные аспекты версионирования компонентов

### 1. API компонента

- **Пропсы (Props)**: изменения в интерфейсе компонента
- **События (Events)**: изменения в механизмах взаимодействия
- **Методы (Methods)**: публичные методы компонента
- **Слоты (Slots)**: для фреймворков, поддерживающих слоты

### 2. Поведение компонента

- Логика обработки данных
- Реакция на пользовательские действия
- Асинхронные операции
- Состояния загрузки и ошибок

### 3. Визуальное представление

- Стили и темы
- Анимации
- Адаптивность
- Доступность

## Подходы к версионированию компонентов

### 1. Семантическое версионирование для компонентов

Применение принципов SemVer к компонентам:

- **MAJOR**: изменения, ломающие совместимость API
- **MINOR**: добавление новых функций без нарушения совместимости
- **PATCH**: исправление багов

#### Пример изменения версии

```jsx
// v1.0.0 - первоначальная версия
<Button onClick={handleClick}>Click me</Button>

// v1.1.0 - добавление нового пропа (обратно совместимо)
<Button onClick={handleClick} variant="primary">Click me</Button>

// v2.0.0 - изменение обязательных пропов (не совместимо)
<Button onClick={handleClick} text="Click me" /> // text теперь обязателен
```

### 2. Версионирование в библиотеках компонентов

#### Создание библиотеки компонентов

```bash
# Структура библиотеки компонентов
my-ui-library/
├── package.json
├── src/
│   ├── Button/
│   │   ├── Button.jsx
│   │   ├── Button.stories.js
│   │   └── index.js
│   ├── Input/
│   │   ├── Input.jsx
│   │   ├── Input.stories.js
│   │   └── index.js
│   └── index.js
└── dist/
```

#### package.json для библиотеки компонентов

```json
{
  "name": "@company/ui-components",
  "version": "2.3.1",
  "description": "UI components library",
  "main": "dist/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "publishConfig": {
    "access": "public"
  }
}
```

### 3. Версионирование через имена компонентов

```jsx
// Использование суффиксов для различных версий
import ButtonV1 from './ButtonV1';
import ButtonV2 from './ButtonV2';

// Или через подмодули
import { Button } from '@company/ui-components/v1';
import { Button } from '@company/ui-components/v2';
```

## Практические примеры версионирования

### React компоненты

#### Пример компонента с версионированием

```jsx
// Button.jsx
import React from 'react';
import PropTypes from 'prop-types';

const Button = ({ 
  children, 
  variant = 'default', 
  size = 'medium', 
  disabled = false, 
  onClick,
  ...props 
}) => {
  const baseClass = 'btn';
  const className = [
    baseClass,
    `${baseClass}--${variant}`,
    `${baseClass}--${size}`,
    disabled ? `${baseClass}--disabled` : ''
  ].filter(Boolean).join(' ');

  return (
    <button 
      className={className}
      disabled={disabled}
      onClick={onClick}
      {...props}
    >
      {children}
    </button>
  );
};

Button.propTypes = {
  children: PropTypes.node.isRequired,
  variant: PropTypes.oneOf(['default', 'primary', 'secondary', 'danger']),
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  disabled: PropTypes.bool,
  onClick: PropTypes.func
};

Button.defaultProps = {
  variant: 'default',
  size: 'medium',
  disabled: false,
  onClick: () => {}
};

export default Button;
```

#### Изменение API компонента

```jsx
// v1.0.0
<Button text="Click me" onClick={handler} />

// v2.0.0 - изменение с children API
<Button onClick={handler}>Click me</Button>

// v2.1.0 - добавление нового пропа
<Button onClick={handler} loading={isLoading}>Click me</Button>
```

### Vue компоненты

#### Пример версионирования в Vue

```vue
<!-- Button.vue -->
<template>
  <button 
    :class="buttonClass"
    :disabled="disabled"
    @click="handleClick"
  >
    <slot></slot>
  </button>
</template>

<script>
export default {
  name: 'Button',
  props: {
    variant: {
      type: String,
      default: 'default',
      validator: (value) => ['default', 'primary', 'secondary'].includes(value)
    },
    size: {
      type: String,
      default: 'medium',
      validator: (value) => ['small', 'medium', 'large'].includes(value)
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    buttonClass() {
      return [
        'btn',
        `btn--${this.variant}`,
        `btn--${this.size}`,
        this.disabled ? 'btn--disabled' : ''
      ];
    }
  },
  methods: {
    handleClick(event) {
      if (!this.disabled) {
        this.$emit('click', event);
      }
    }
  }
};
</script>
```

## Инструменты для управления компонентами

### Storybook

#### Создание историй для разных версий

```jsx
// Button.stories.js
import React from 'react';
import Button from './Button';

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['default', 'primary', 'secondary', 'danger'],
    },
    size: {
      control: { type: 'select' },
      options: ['small', 'medium', 'large'],
    },
  },
};

export const Default = {
  args: {
    children: 'Button',
    variant: 'default',
  },
};

export const Primary = {
  args: {
    children: 'Primary Button',
    variant: 'primary',
  },
};

export const Disabled = {
  args: {
    children: 'Disabled Button',
    disabled: true,
  },
};
```

### Bit.dev

```bash
# Установка Bit
npm install -g @teambit/bvm
bvm install

# Инициализация workspace
bit init

# Добавление компонента
bit add src/components/Button

# Установка зависимостей
bit install

# Тестирование компонента
bit test Button

# Экспорт компонента
bit export scope-name
```

## Практические рекомендации

### 1. Использование TypeScript для типизации компонентов

```tsx
// Button.types.ts
export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'default' | 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
  loading?: boolean;
}

// Button.tsx
import React from 'react';
import { ButtonProps } from './Button.types';

const Button: React.FC<ButtonProps> = ({ 
  children, 
  variant = 'default', 
  size = 'medium', 
  disabled = false, 
  onClick,
  loading = false
}) => {
  // Реализация компонента
  return (
    <button 
      className={`btn btn--${variant} btn--${size} ${disabled ? 'btn--disabled' : ''}`}
      disabled={disabled || loading}
      onClick={onClick}
    >
      {loading ? 'Loading...' : children}
    </button>
  );
};

export default Button;
```

### 2. Создание системы миграции компонентов

```jsx
// Миграционный компонент
import React from 'react';
import NewButton from './NewButton';
import OldButton from './OldButton';

const MigratingButton = (props) => {
  // Определение версии по пропам или контексту
  const isNewVersion = props.useNewVersion || false;
  
  if (isNewVersion) {
    return <NewButton {...props} />;
  }
  
  return <OldButton {...props} />;
};

// Постепенное обновление в приложении
const App = () => {
  return (
    <div>
      {/* Старый компонент */}
      <MigratingButton>Old Button</MigratingButton>
      
      {/* Новый компонент */}
      <MigratingButton useNewVersion>Updated Button</MigratingButton>
    </div>
  );
};
```

### 3. Тестирование разных версий компонентов

```jsx
// Button.test.jsx
import React from 'react';
import { render, fireEvent, screen } from '@testing-library/react';
import Button from './Button';

describe('Button Component', () => {
  test('renders with default props', () => {
    render(<Button>Click me</Button>);
    const button = screen.getByText('Click me');
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('btn--default');
    expect(button).toHaveClass('btn--medium');
  });

  test('handles click events', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('applies correct classes based on props', () => {
    render(
      <Button variant="primary" size="large" disabled>
        Click me
      </Button>
    );
    
    const button = screen.getByText('Click me');
    expect(button).toHaveClass('btn--primary');
    expect(button).toHaveClass('btn--large');
    expect(button).toHaveClass('btn--disabled');
  });
});
```

## Стратегии версионирования в монорепозиториях

### Lerna

```json
// lerna.json
{
  "packages": [
    "packages/*"
  ],
  "version": "independent",
  "npmClient": "yarn",
  "useWorkspaces": true
}
```

```bash
# Обновление версий компонентов
lerna version --conventional-commits

# Публикация обновленных пакетов
lerna publish
```

### Yarn Workspaces

```json
// package.json (корень)
{
  "private": true,
  "workspaces": [
    "packages/*"
  ]
}
```

```json
// packages/button/package.json
{
  "name": "@mycompany/button",
  "version": "2.1.3",
  "main": "dist/index.js",
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0"
  }
}
```

## Распространенные ошибки

### 1. Изменение API без увеличения мажорной версии

```jsx
// ПЛОХО: изменение обязательных пропов в патч-версии
// v1.0.1 - добавление обязательного пропа
<Button text="Click" /> // раньше работало
<Button text="Click" theme="light" /> // теперь требуется theme
```

### 2. Неправильное определение ломающих изменений

```jsx
// ПЛОХО: удаление пропа без увеличения мажорной версии
// v1.0.1 - удаление устаревшего пропа
const Button = ({ children, oldProp, ...props }) => {
  // oldProp больше не используется
  return <button {...props}>{children}</button>;
};
```

### 3. Отсутствие документации изменений

- Нет changelog
- Нет миграционных гайдов
- Нет информации о deprecated API

## Миграционные стратегии

### 1. Прокладки совместимости (Compatibility Shims)

```jsx
// Компонент-обертка для обеспечения совместимости
const LegacyButton = (props) => {
  const newProps = {
    ...props,
    // Преобразование старого API в новый
    children: props.text || props.children,
    variant: props.type || props.variant || 'default'
  };

  return <Button {...newProps} />;
};
```

### 2. Постепенная миграция через флаги

```jsx
// Использование флага для переключения между версиями
const Button = ({ useNewVersion, ...props }) => {
  if (useNewVersion) {
    return <NewButton {...props} />;
  }
  return <OldButton {...props} />;
};
```

### 3. Использование HOC для миграции

```jsx
const withMigrationWarning = (Component) => {
  return (props) => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('This component version is deprecated, please migrate to the new version');
    }
    return <Component {...props} />;
  };
};

const LegacyButton = withMigrationWarning(OldButton);
```

## Совместимость и доступность

### Обеспечение доступности при версионировании

```jsx
// Сохранение ARIA атрибутов при обновлении компонента
const Button = ({ 
  children, 
  variant = 'default', 
  disabled = false, 
  ariaLabel,
  onClick 
}) => {
  return (
    <button 
      className={`btn btn--${variant} ${disabled ? 'btn--disabled' : ''}`}
      disabled={disabled}
      onClick={onClick}
      aria-label={ariaLabel}
      role="button"
    >
      {children}
    </button>
  );
};
```

## Связанные концепции

- [[Семантическое-версионирование]]
- [[Управление-версиями-зависимостей]]
- [[Миграция-между-версиями]]
- [[Версионирование-API]]
- [[Совместимость]]
- [[Обратная-совместимость]]
- [[Компонентная-архитектура]]
- [[Дизайн-системы]]

## Заключение

Версионирование компонентов — важная практика для поддержания стабильности и управляемости UI-библиотек. Правильное версионирование позволяет безопасно вносить изменения, не нарушая работу существующих приложений. Ключевые принципы включают соблюдение SemVer, четкую документацию изменений и постепенную миграцию между версиями.