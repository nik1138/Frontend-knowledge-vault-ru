---
aliases: [Прототипы и производительность, Производительность прототипов, Оптимизация прототипов]
tags: [javascript, прототипы, производительность, оптимизация, oop]
---

# Прототипы и производительность

Прототипы в JavaScript оказывают значительное влияние на производительность приложений. Понимание того, как работает цепочка прототипов и как оптимизировать использование прототипов, критически важно для создания высокопроизводительных JavaScript-приложений.

## Как прототипы влияют на производительность

### Цепочка прототипов и поиск свойств

При обращении к свойству объекта JavaScript сначала проверяет, существует ли это свойство в самом объекте, а затем последовательно проверяет прототипы в цепочке до тех пор, пока не найдет свойство или не достигнет конца цепочки.

```javascript
// Простой объект - быстрый доступ к свойству
const simpleObj = { name: "Простой объект" };
console.log(simpleObj.name); // Быстрый доступ - свойство в самом объекте

// Глубокая цепочка прототипов - медленный доступ
const level1 = { prop1: "уровень 1" };
const level2 = Object.create(level1);
level2.prop2 = "уровень 2";
const level3 = Object.create(level2);
level3.prop3 = "уровень 3";
const level4 = Object.create(level3);
level4.prop4 = "уровень 4";
const deepObj = Object.create(level4);
deepObj.ownProp = "собственное";

// Доступ к собственному свойству - быстро
console.time("Собственное свойство");
for (let i = 0; i < 1000000; i++) {
  const val = deepObj.ownProp;
}
console.timeEnd("Собственное свойство");

// Доступ к унаследованному свойству - медленнее
console.time("Унаследованное свойство");
for (let i = 0; i < 1000000; i++) {
  const val = deepObj.prop1;
}
console.timeEnd("Унаследованное свойство");
```

### Влияние на производительность циклов и итераций

```javascript
const base = { method: function() { return this.value; } };
const obj = Object.create(base);
obj.value = 42;

// Медленный перебор - включает унаследованные свойства
console.time("for...in с наследуемыми свойствами");
for (let i = 0; i < 100000; i++) {
  for (let key in obj) {
    // Обработка
  }
}
console.timeEnd("for...in с наследуемыми свойствами");

// Более быстрый перебор - только собственные свойства
console.time("Object.keys с собственными свойствами");
for (let i = 0; i < 100000; i++) {
  Object.keys(obj).forEach(key => {
    // Обработка
  });
}
console.timeEnd("Object.keys с собственными свойствами");
```

## Оптимизация прототипов

### Использование Object.create(null)

Для объектов, используемых как словари или хранилища данных, рекомендуется использовать `Object.create(null)`, чтобы избежать цепочки прототипов:

```javascript
// Неоптимизированный словарь
const regularDict = {};
regularDict.key1 = "value1";
regularDict.key2 = "value2";

// Оптимизированный словарь
const nullProtoDict = Object.create(null);
nullProtoDict.key1 = "value1";
nullProtoDict.key2 = "value2";

// Проверка производительности
console.time("Обычный объект как словарь");
for (let i = 0; i < 1000000; i++) {
  const val = regularDict.key1;
}
console.timeEnd("Обычный объект как словарь");

console.time("Объект с null-прототипом как словарь");
for (let i = 0; i < 1000000; i++) {
  const val = nullProtoDict.key1;
}
console.timeEnd("Объект с null-прототипом как словарь");
```

### Правильное расположение методов

Размещение методов в прототипе, а не в конструкторе, экономит память и улучшает производительность:

```javascript
// Неэффективный подход - методы создаются для каждого экземпляра
function InefficientClass(name) {
  this.name = name;
  // Каждый экземпляр получает свою копию метода
  this.getName = function() {
    return this.name;
  };
}

// Эффективный подход - методы в прототипе
function EfficientClass(name) {
  this.name = name;
}
EfficientClass.prototype.getName = function() {
  return this.name;
};

const inefficient = new Array(1000).fill().map((_, i) => new InefficientClass(`obj${i}`));
const efficient = new Array(1000).fill().map((_, i) => new EfficientClass(`obj${i}`));

console.log("Память: эффективный подход использует значительно меньше памяти");
```

## Оптимизация цепочки прототипов

### Избегайте слишком длинных цепочек

```javascript
// Неэффективная глубокая иерархия
const A = { a: 1 };
const B = Object.create(A);
B.b = 2;
const C = Object.create(B);
C.c = 3;
const D = Object.create(C);
D.d = 4;
const E = Object.create(D);
E.e = 5;
const deepObject = Object.create(E);

// Более эффективная плоская структура для часто используемых свойств
const flatObject = {
  a: 1, b: 2, c: 3, d: 4, e: 5,
  // Методы для работы с этими свойствами
  getValues: function() {
    return [this.a, this.b, this.c, this.d, this.e];
  }
};
```

### Использование методов для кеширования доступа

```javascript
// Класс с кешированием часто используемых свойств прототипа
class CachedAccess {
  constructor() {
    // Кешируем ссылки на часто используемые методы прототипа
    this._getName = this.getName.bind(this);
    this._getValue = this.getValue.bind(this);
  }

  getName() {
    return this.name || "Без имени";
  }

  getValue() {
    return this.value || 0;
  }

  // Используем кешированные методы
  processData() {
    // Используем кешированные методы для лучшей производительности
    const name = this._getName();
    const value = this._getValue();
    return { name, value };
  }
}
```

## Производительность при создании объектов

### Сравнение способов создания объектов

```javascript
// Литерал объекта - самый быстрый способ
console.time("Литерал объекта");
for (let i = 0; i < 1000000; i++) {
  const obj = { a: 1, b: 2, c: 3 };
}
console.timeEnd("Литерал объекта");

// Object.create() - немного медленнее
console.time("Object.create()");
for (let i = 0; i < 1000000; i++) {
  const obj = Object.create(null);
  obj.a = 1;
  obj.b = 2;
  obj.c = 3;
}
console.timeEnd("Object.create()");

// Функция-конструктор - медленнее из-за вызова функции
function Constructor(a, b, c) {
  this.a = a;
  this.b = b;
  this.c = c;
}
console.time("Функция-конструктор");
for (let i = 0; i < 1000000; i++) {
  const obj = new Constructor(1, 2, 3);
}
console.timeEnd("Функция-конструктор");

// Класс - аналогично функции-конструктору
class ClassExample {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}
console.time("Класс");
for (let i = 0; i < 1000000; i++) {
  const obj = new ClassExample(1, 2, 3);
}
console.timeEnd("Класс");
```

## Оптимизация работы с прототипами

### Добавление методов в прототип массово

```javascript
// Неэффективное постепенное добавление методов
function MyClass() {}
MyClass.prototype.method1 = function() { return 1; };
MyClass.prototype.method2 = function() { return 2; };
MyClass.prototype.method3 = function() { return 3; };

// Более эффективное массовое добавление
function MyClassOptimized() {}
Object.assign(MyClassOptimized.prototype, {
  method1: function() { return 1; },
  method2: function() { return 2; },
  method3: function() { return 3; },
  method4: function() { return 4; },
  method5: function() { return 5; }
});
```

### Использование Object.setPrototypeOf() с осторожностью

```javascript
const obj = { a: 1 };
const proto = { b: 2 };

// Object.setPrototypeOf() может быть медленным и ломает оптимизации движка
console.time("Object.setPrototypeOf");
for (let i = 0; i < 100000; i++) {
  const newObj = { a: 1 };
  Object.setPrototypeOf(newObj, proto);
}
console.timeEnd("Object.setPrototypeOf");

// Object.create() более эффективен для установки прототипа
console.time("Object.create");
for (let i = 0; i < 100000; i++) {
  const newObj = Object.create(proto);
  newObj.a = 1;
}
console.timeEnd("Object.create");
```

## Практические рекомендации по производительности

### 1. Минимизируйте глубину цепочки прототипов

```javascript
// Плохо: глубокая иерархия
const Animal = { breathe: true };
const Mammal = Object.create(Animal);
Mammal.warmBlooded = true;
const Dog = Object.create(Mammal);
Dog.bark = true;
const Puppy = Object.create(Dog);
Puppy.playful = true;

// Лучше: более плоская структура или композиция
const dogTraits = {
  breathe: true,
  warmBlooded: true,
  bark: true,
  playful: true
};
```

### 2. Используйте прототипы для общих методов

```javascript
// Правильно: методы в прототипе
function User(name, email) {
  this.name = name;
  this.email = email;
  // Только данные в экземпляре
}

User.prototype.getInfo = function() {
  return `${this.name} (${this.email})`;
};

User.prototype.validate = function() {
  return this.email.includes('@');
};
```

### 3. Избегайте изменения прототипов после создания экземпляров

```javascript
function MyClass() {}
const instance = new MyClass();

// Избегайте этого после создания экземпляров
MyClass.prototype.newMethod = function() {
  // Это может ломать оптимизации движка JavaScript
};

// Лучше определить все методы до создания экземпляров
function MyClassOptimized() {}
MyClassOptimized.prototype.existingMethod = function() {};
MyClassOptimized.prototype.anotherMethod = function() {};
const instanceOpt = new MyClassOptimized();
```

### 4. Используйте кеширование для часто вызываемых методов

```javascript
class PerformanceClass {
  constructor() {
    // Кешируем часто используемые вычисления
    this._cachedValue = null;
    this._cacheValid = false;
  }

  computeExpensiveValue() {
    if (!this._cacheValid) {
      // Выполняем дорогостоящие вычисления
      this._cachedValue = this.expensiveOperation();
      this._cacheValid = true;
    }
    return this._cachedValue;
  }

  expensiveOperation() {
    // Симуляция дорогостоящей операции
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += Math.random();
    }
    return result;
  }

  invalidateCache() {
    this._cacheValid = false;
  }
}
```

## Профилирование и измерение производительности

### Использование встроенных инструментов

```javascript
// Пример измерения производительности прототипных операций
function performanceTest() {
  console.time("Тест производительности прототипов");

  // Создаем прототип
  const proto = {
    method: function() { return this.value; },
    value: 42
  };

  // Создаем много объектов с этим прототипом
  const objects = [];
  for (let i = 0; i < 100000; i++) {
    objects.push(Object.create(proto));
  }

  // Вызываем метод у всех объектов
  for (const obj of objects) {
    obj.method();
  }

  console.timeEnd("Тест производительности прототипов");
}

performanceTest();
```

## Заключение

Прототипы в JavaScript - мощный инструмент, но их неправильное использование может негативно сказаться на производительности. Ключевые моменты для оптимизации:

1. Держите цепочки прототипов максимально короткими
2. Размещайте общие методы в прототипах, а не в экземплярах
3. Избегайте частого изменения прототипов во время выполнения
4. Используйте `Object.create(null)` для объектов-словарей
5. Кешируйте результаты дорогостоящих операций
6. Измеряйте производительность критических участков кода

Правильное понимание и использование прототипов позволяет создавать как гибкие, так и высокопроизводительные JavaScript-приложения.

## См. также

- [[Прототипное-наследование]]
- [[Прототипы-в-JavaScript]]
- [[Прототипы-и-классы]]
- [[Прототипы-в-современном-JavaScript]]
- [[Производительность-JavaScript]]
- [[Оптимизация-памяти]]