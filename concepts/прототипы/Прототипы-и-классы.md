---
aliases: [Прототипы и классы, Классы и прототипы, Классы vs Прототипы]
tags: [javascript, прототипы, классы, oop, es6]
---

# Прототипы и классы

С появлением ES6 в JavaScript были добавлены классы, которые часто рассматриваются как более привычный способ создания объектов и реализации наследования для разработчиков, пришедших из других объектно-ориентированных языков. Однако, важно понимать, что классы в JavaScript являются синтаксическим сахаром над прототипным наследованием.

## Классы как синтаксический сахар

Несмотря на внешнее сходство с классами в других языках программирования, JavaScript-классы по сути являются обычными функциями-конструкторами с использованием прототипного наследования под капотом.

```javascript
// Класс ES6
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }

  static createSquare(size) {
    return new Rectangle(size, size);
  }
}

// Эквивалентный код с использованием функции-конструктора и прототипов
function RectangleOld(width, height) {
  this.width = width;
  this.height = height;
}

RectangleOld.prototype.getArea = function() {
  return this.width * this.height;
};

RectangleOld.createSquare = function(size) {
  return new RectangleOld(size, size);
};

// Оба подхода создают объекты с одинаковым поведением
const rect1 = new Rectangle(10, 5);
const rect2 = new RectangleOld(10, 5);

console.log(rect1.getArea()); // 50
console.log(rect2.getArea()); // 50
console.log(rect1.constructor === Rectangle); // true
console.log(rect2.constructor === RectangleOld); // true
```

## Наследование: классы vs прототипы

### С использованием классов

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} издает звук`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // вызываем родительский конструктор
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} лает`);
  }

  speak() {
    super.speak(); // вызываем родительский метод
    this.bark();
  }
}

const dog = new Dog("Бобик", "Дворняга");
dog.speak(); // "Бобик издает звук", затем "Бобик лает"
console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
```

### С использованием прототипов

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} издает звук`);
};

function Dog(name, breed) {
  Animal.call(this, name); // вызываем родительский конструктор
  this.breed = breed;
}

// Устанавливаем прототип Dog как экземпляр Animal
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(`${this.name} лает`);
};

Dog.prototype.speak = function() {
  Animal.prototype.speak.call(this); // вызываем родительский метод
  this.bark();
};

const dog2 = new Dog("Шарик", "Лабрадор");
dog2.speak(); // "Шарик издает звук", затем "Шарик лает"
console.log(dog2 instanceof Dog); // true
console.log(dog2 instanceof Animal); // true
```

## Методы и свойства классов

Классы позволяют определять различные типы методов:

```javascript
class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }

  // Обычный метод экземпляра
  add(number) {
    this.value += number;
    return this; // для цепочки вызовов
  }

  // Геттер
  get result() {
    return this.value;
  }

  // Статический метод
  static multiply(a, b) {
    return a * b;
  }

  // Сеттер
  set reset(newValue) {
    this.value = newValue || 0;
  }
}

const calc = new Calculator(5);
console.log(calc.add(3).add(2).result); // 10
console.log(Calculator.multiply(4, 5)); // 20
calc.reset = 100;
console.log(calc.result); // 100
```

## Прототипы и области применения

### Когда использовать классы

- При создании иерархий объектов с четко определенными отношениями наследования
- Когда команда разработчиков более знакома с классическим ООП
- Для создания библиотек и фреймворков с понятным API
- При необходимости использования статических методов и полей

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.state = {};
    this.props = {};
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.render();
  }

  render() {
    // Логика рендеринга
  }

  static createInstance(config) {
    return new Component(config.element);
  }
}
```

### Когда использовать прототипы напрямую

- Для простых объектов без сложной иерархии
- При необходимости динамического изменения поведения объектов
- Для создания функциональных библиотек
- При работе с производительностью критических участков кода

```javascript
// Пример создания объекта с прототипом для переиспользуемого поведения
const Flyable = {
  fly() {
    console.log(`${this.name} летит`);
  }
};

const Duck = Object.create(Flyable);
Duck.name = "Утка";
Duck.swim = function() {
  console.log(`${this.name} плывет`);
};

const duck = Object.create(Duck);
duck.name = "Дональд";
duck.fly(); // "Дональд летит"
duck.swim(); // "Дональд плывет"
```

## Приватные поля и методы

ES2022 добавил поддержку приватных полей и методов в классы:

```javascript
class BankAccount {
  #balance = 0; // приватное поле
  #transactionHistory = [];

  constructor(initialBalance = 0) {
    this.#balance = initialBalance;
  }

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      this.#recordTransaction(`Депозит: +${amount}`);
    }
  }

  getBalance() {
    return this.#balance;
  }

  #recordTransaction(description) {
    this.#transactionHistory.push({
      description,
      timestamp: new Date()
    });
  }

  // Приватный метод
  #validateAmount(amount) {
    return typeof amount === 'number' && amount > 0;
  }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance()); // 150
// console.log(account.#balance); // Ошибка - приватное поле
```

## Сравнение производительности

Оба подхода имеют схожую производительность, так как классы используют ту же систему прототипов под капотом:

```javascript
// Класс
class PersonClass {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Привет, я ${this.name}`;
  }
}

// Прототип
function PersonProto(name) {
  this.name = name;
}
PersonProto.prototype.greet = function() {
  return `Привет, я ${this.name}`;
};

// Создание экземпляров
const person1 = new PersonClass("Алекс");
const person2 = new PersonProto("Мария");

console.log(person1.greet()); // "Привет, я Алекс"
console.log(person2.greet()); // "Привет, я Мария"
```

## Практические рекомендации

1. **Используйте классы**, когда:
   - Создаете четкую иерархию объектов
   - Нужна поддержка наследования с вызовами `super()`
   - Команда предпочитает классический ООП подход
   - Работаете с фреймворками, использующими классы

2. **Используйте прототипы напрямую**, когда:
   - Создаете простые объекты без сложной иерархии
   - Нужна максимальная гибкость в изменении поведения
   - Пишете библиотеку для широкого использования
   - Работаете с функциональным программированием

3. **Совмещайте подходы**, когда:
   - Используете классы, но нужен доступ к прототипу для добавления методов
   - Создаете экземпляры классов и модифицируете их прототип для всех экземпляров

```javascript
// Пример комбинированного подхода
class User {
  constructor(name) {
    this.name = name;
  }
}

// Добавляем метод ко всем экземплярам через прототип
User.prototype.introduce = function() {
  console.log(`Привет, меня зовут ${this.name}`);
};

const user = new User("Вася");
user.introduce(); // "Привет, меня зовут Вася"
```

## Заключение

Классы и прототипы в JavaScript тесно связаны между собой. Классы - это синтаксический сахар над прототипным наследованием, предоставляющий более удобный и читаемый способ создания объектов и организации наследования. Понимание обеих концепций позволяет разработчику выбирать наиболее подходящий инструмент для конкретной задачи.

## См. также

- [[Прототипное-наследование]]
- [[Прототипы-в-JavaScript]]
- [[Прототипы-и-производительность]]
- [[Прототипы-в-современном-JavaScript]]
- [[Объектно-ориентированное-программирование]]
- [[Классы-в-JavaScript]] [[Классы-в-JavaScript]] (предполагаемый файл)