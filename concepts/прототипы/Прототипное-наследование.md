---
aliases: [Прототипное наследование, Прототипное наследование в JavaScript]
tags: [javascript, прототипы, наследование, oop]
---

# Прототипное наследование

Прототипное наследование - это механизм в JavaScript, который позволяет объектам наследовать свойства и методы от других объектов, называемых прототипами. В отличие от классического наследования, используемого в других объектно-ориентированных языках программирования, прототипное наследование предоставляет более гибкий и динамичный подход к созданию и расширению объектов.

## Основы прототипного наследования

В JavaScript каждый объект имеет внутреннее свойство `[[Prototype]]`, которое ссылается на другой объект - прототип. Этот прототип, в свою очередь, также может иметь свой прототип, создавая цепочку прототипов. Когда вы пытаетесь получить доступ к свойству объекта, JavaScript сначала проверяет, существует ли это свойство в самом объекте, а затем по цепочке прототипов до тех пор, пока не найдет свойство или не достигнет конца цепочки.

```javascript
// Создаем объект с прототипом
const animal = {
  eats: true,
  walk() {
    console.log("Животное идет");
  }
};

// Создаем объект, наследующий от animal
const rabbit = {
  jumps: true
};

// Устанавливаем прототип rabbit как animal
Object.setPrototypeOf(rabbit, animal);

console.log(rabbit.eats); // true - свойство из прототипа
rabbit.walk(); // "Животное идет" - метод из прототипа
```

## Цепочка прототипов

Цепочка прототипов - это последовательность объектов, через которую осуществляется поиск свойств. Когда свойство не находится в текущем объекте, интерпретатор JavaScript переходит к прототипу объекта, затем к прототипу прототипа и так далее.

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Животное идет");
  }
};

const rabbit = {
  jumps: true,
  walk() {
    console.log("Кролик прыгает");
  }
};

const longEars = {
  earLength: 10
};

Object.setPrototypeOf(rabbit, animal);
Object.setPrototypeOf(longEars, rabbit);

// longEars наследует от rabbit, который наследует от animal
console.log(longEars.eats); // true (наследуется от animal)
console.log(longEars.jumps); // true (наследуется от rabbit)
longEars.walk(); // "Кролик прыгает" (метод из rabbit, ближайший в цепочке)
```

## Использование функций-конструкторов

Функции-конструкторы - это традиционный способ создания объектов с прототипным наследованием в JavaScript.

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eats = true;
Animal.prototype.walk = function() {
  console.log(`${this.name} идет`);
};

function Rabbit(name) {
  Animal.call(this, name); // Вызываем родительский конструктор
  this.jumps = true;
}

// Устанавливаем прототип Rabbit как экземпляр Animal
Rabbit.prototype = Object.create(Animal.prototype);
Rabbit.prototype.constructor = Rabbit;

Rabbit.prototype.jump = function() {
  console.log(`${this.name} прыгает`);
};

const myRabbit = new Rabbit("Белый кролик");
console.log(myRabbit.name); // "Белый кролик"
console.log(myRabbit.eats); // true (наследуется от Animal)
myRabbit.walk(); // "Белый кролик идет"
myRabbit.jump(); // "Белый кролик прыгает"
```

## Современные подходы к прототипному наследованию

С появлением ES6 были введены классы, которые являются синтаксическим сахаром над прототипным наследованием, но сохраняют ту же основу.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  get eats() {
    return true;
  }

  walk() {
    console.log(`${this.name} идет`);
  }
}

class Rabbit extends Animal {
  constructor(name) {
    super(name);
    this.jumps = true;
  }

  jump() {
    console.log(`${this.name} прыгает`);
  }

  // Переопределяем метод родителя
  walk() {
    super.walk();
    this.jump();
  }
}

const myRabbit = new Rabbit("Серый кролик");
console.log(myRabbit.eats); // true
myRabbit.walk(); // "Серый кролик идет", затем "Серый кролик прыгает"
```

## Преимущества прототипного наследования

1. **Гибкость**: Возможность динамического изменения прототипов во время выполнения
2. **Экономия памяти**: Методы и свойства хранятся в одном месте, а не в каждом экземпляре
3. **Простота наследования**: Легко создавать иерархии объектов
4. **Динамическое обновление**: Все экземпляры автоматически получают новые методы, добавленные к прототипу

## Практические рекомендации

- Используйте `Object.create()` для установки прототипов, а не `Object.setPrototypeOf()`, так как последний может негативно повлиять на производительность
- Избегайте изменения прототипов встроенных объектов, чтобы не нарушать ожидаемое поведение
- Помните, что свойства и методы прототипа разделяются между всеми экземплярами
- Используйте `hasOwnProperty()` для проверки, принадлежит ли свойство самому объекту, а не его прототипу

```javascript
// Проверка принадлежности свойства объекту
const obj = { ownProp: 'value' };
Object.setPrototypeOf(obj, { protoProp: 'protoValue' });

console.log(obj.hasOwnProperty('ownProp')); // true
console.log(obj.hasOwnProperty('protoProp')); // false
console.log('protoProp' in obj); // true (свойство доступно через цепочку прототипов)
```

## Заключение

Прототипное наследование - это мощный механизм JavaScript, который позволяет создавать гибкие и переиспользуемые структуры данных. Понимание прототипов и цепочки прототипов критически важно для эффективной разработки на JavaScript.

## См. также

- [[Прототипы-в-JavaScript]]
- [[Прототипы-и-классы]]
- [[Прототипы-и-производительность]]
- [[Прототипы-в-современном-JavaScript]]
- [[Объектно-ориентированное-программирование]]
- [[Наследование]]