# Алгоритмы поиска

Алгоритмы поиска - это методы нахождения определенного элемента в коллекции данных. Они являются фундаментальной частью компьютерных наук и программирования.

## Содержание
- [[#Линейный поиск]]
- [[#Бинарный поиск]]
- [[#Интерполяционный поиск]]
- [[#Экспоненциальный поиск]]
- [[#Тернарный поиск]]
- [[#Прыжковый поиск]]
- [[#Сравнение алгоритмов]]
- [[#Заключение]]

## Линейный поиск

**Линейный поиск** (или последовательный поиск) - это простейший алгоритм поиска, который проверяет каждый элемент в списке по очереди до нахождения целевого значения.

### Реализация
```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // возвращаем индекс найденного элемента
        }
    }
    return -1; // элемент не найден
}
```

### Сложность
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

### Когда использовать
- Когда данные не отсортированы
- Для небольших наборов данных
- Когда структура данных не поддерживает другие типы поиска

### Преимущества
- Прост в реализации
- Не требует отсортированных данных
- Работает с любыми структурами данных

### Недостатки
- Медленный для больших наборов данных
- Неэффективен по сравнению с другими алгоритмами

## Бинарный поиск

**Бинарный поиск** - это эффективный алгоритм поиска в отсортированном массиве, который делит область поиска пополам на каждой итерации.

### Реализация
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

### Сложность
- **Временная сложность**: O(log n)
- **Пространственная сложность**: O(1)

### Когда использовать
- Когда данные отсортированы
- Для больших наборов данных
- Когда требуется частый поиск

### Преимущества
- Высокая эффективность
- Хорошая производительность

### Недостатки
- Требует отсортированных данных
- Сложнее в реализации

## Интерполяционный поиск

**Интерполяционный поиск** - это улучшенная версия бинарного поиска, которая работает лучше для равномерно распределенных данных.

### Реализация
```javascript
function interpolationSearch(arr, target) {
    let low = 0;
    let high = arr.length - 1;
    
    while (low <= high && target >= arr[low] && target <= arr[high]) {
        if (low === high) {
            return arr[low] === target ? low : -1;
        }
        
        let pos = low + Math.floor(((target - arr[low]) * (high - low)) / (arr[high] - arr[low]));
        
        if (arr[pos] === target) {
            return pos;
        } else if (arr[pos] < target) {
            low = pos + 1;
        } else {
            high = pos - 1;
        }
    }
    
    return -1;
}
```

### Сложность
- **Временная сложность**: O(log log n) для равномерно распределенных данных, O(n) в худшем случае
- **Пространственная сложность**: O(1)

### Когда использовать
- Когда данные равномерно распределены
- Для больших отсортированных массивов
- Когда доступ к элементам быстрый

### Преимущества
- Быстрее бинарного поиска для равномерно распределенных данных
- Хорошая производительность в оптимальных условиях

### Недостатки
- Плохо работает с неравномерно распределенными данными
- Сложнее в реализации

## Экспоненциальный поиск

**Экспоненциальный поиск** - это алгоритм, который сначала находит диапазон, в котором может находиться целевой элемент, а затем использует бинарный поиск в этом диапазоне.

### Реализация
```javascript
function exponentialSearch(arr, target) {
    if (arr[0] === target) return 0;
    
    let i = 1;
    while (i < arr.length && arr[i] <= target) {
        i *= 2;
    }
    
    return binarySearch(arr, target, Math.floor(i/2), Math.min(i, arr.length - 1));
}

function binarySearch(arr, target, left, right) {
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

### Сложность
- **Временная сложность**: O(log n)
- **Пространственная сложность**: O(1)

### Когда использовать
- Для неограниченных или очень больших массивов
- Когда элемент может быть близко к началу массива
- Когда неизвестна длина массива

### Преимущества
- Эффективен для поиска в начале массива
- Подходит для неограниченных массивов

### Недостатки
- Сложнее в реализации
- Требует отсортированных данных

## Тернарный поиск

**Тернарный поиск** - это алгоритм, который делит массив на три части и определяет, в какой части находится целевой элемент.

### Реализация
```javascript
function ternarySearch(arr, target, left, right) {
    if (right >= left) {
        let mid1 = left + Math.floor((right - left) / 3);
        let mid2 = right - Math.floor((right - left) / 3);
        
        if (arr[mid1] === target) return mid1;
        if (arr[mid2] === target) return mid2;
        
        if (target < arr[mid1]) {
            return ternarySearch(arr, target, left, mid1 - 1);
        } else if (target > arr[mid2]) {
            return ternarySearch(arr, target, mid2 + 1, right);
        } else {
            return ternarySearch(arr, target, mid1 + 1, mid2 - 1);
        }
    }
    
    return -1;
}
```

### Сложность
- **Временная сложность**: O(log₃ n)
- **Пространственная сложность**: O(log n) из-за рекурсии

### Когда использовать
- Для поиска в отсортированных массивах
- Когда нужно использовать три деления вместо двух

### Преимущества
- Может быть полезен для оптимизации в некоторых случаях
- Альтернатива бинарному поиску

### Недостатки
- Более сложная реализация
- Не всегда быстрее бинарного поиска
- Требует больше сравнений

## Прыжковый поиск

**Прыжковый поиск** (или блочный поиск) - это алгоритм поиска, который прыгает через определенные блоки массива, чтобы уменьшить количество сравнений.

### Реализация
```javascript
function jumpSearch(arr, target) {
    const n = arr.length;
    let step = Math.floor(Math.sqrt(n));
    let prev = 0;
    
    while (arr[Math.min(step, n) - 1] < target) {
        prev = step;
        step += Math.floor(Math.sqrt(n));
        if (prev >= n) return -1;
    }
    
    while (arr[prev] < target) {
        prev++;
        if (prev === Math.min(step, n)) return -1;
    }
    
    if (arr[prev] === target) return prev;
    return -1;
}
```

### Сложность
- **Временная сложность**: O(√n)
- **Пространственная сложность**: O(1)

### Когда использовать
- Когда прыжки дешевле, чем бинарный поиск
- Для массивов, где доступ к элементам дорогой
- Как альтернатива бинарному поиску

### Преимущества
- Меньше прыжков по сравнению с линейным поиском
- Хорошо работает с физическими данными

### Недостатки
- Требует отсортированных данных
- Не так эффективен, как бинарный поиск

## Сравнение алгоритмов

| Алгоритм | Временная сложность | Пространственная сложность | Требует сортировки |
|----------|-------------------|--------------------------|------------------|
| Линейный | O(n) | O(1) | Нет |
| Бинарный | O(log n) | O(1) | Да |
| Интерполяционный | O(log log n) - O(n) | O(1) | Да |
| Экспоненциальный | O(log n) | O(1) | Да |
| Тернарный | O(log₃ n) | O(log n) | Да |
| Прыжковый | O(√n) | O(1) | Да |

## Заключение

Выбор алгоритма поиска зависит от:
- Размера данных
- Состояния сортировки
- Распределения данных
- Требований к производительности
- Частоты поиска

Для большинства случаев бинарный поиск является оптимальным выбором, когда данные отсортированы. Линейный поиск подходит для небольших или неотсортированных наборов данных.

См. также: [[sorting]], [[data-structures]], [[algorithm-analysis]]

> [!tip] 
> Практика реализации этих алгоритмов поможет лучше понять их особенности и выбрать правильный алгоритм для конкретной задачи.

> [!warning] 
> Помните, что эффективность алгоритмов может зависеть от специфики данных и условий использования.

#search #algorithms #programming #complexity #data-structures