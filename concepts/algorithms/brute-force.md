# Парадигма перебора (Brute Force)

## Что такое перебор (Brute Force)

**Перебор** (Brute Force) - это простейший алгоритмический подход, при котором рассматриваются все возможные решения задачи до нахождения правильного или оптимального. Этот метод не использует эвристики или оптимизации, а просто проверяет каждую возможность до тех пор, пока не будет найдено решение.

> [!info] Определение
> Перебор - это метод решения задач, при котором рассматриваются все возможные кандидаты на решение и проверяется каждый из них на соответствие условиям задачи.

## Как работает перебор

Процесс перебора включает следующие этапы:

1. **Генерация** - создание всех возможных кандидатов на решение
2. **Проверка** - тестирование каждого кандидата на соответствие условиям задачи
3. **Выбор** - сохранение или возврат подходящих решений

## Когда использовать перебор

Перебор особенно полезен в следующих случаях:

- **Маленькие размеры данных** - когда количество возможных решений невелико
- **Простые задачи** - когда нет очевидных способов оптимизации
- **Тестирование** - для проверки корректности более сложных алгоритмов
- **Поиск подтверждений** - когда нужно доказать, что решения не существует
- **Образовательные цели** - для понимания проблемы перед разработкой оптимизированных решений

## Примеры алгоритмов перебора

### 1. Поиск подстроки

```python
def brute_force_search(text, pattern):
    """
    Поиск подстроки методом перебора
    """
    n = len(text)
    m = len(pattern)
    
    for i in range(n - m + 1):
        j = 0
        while j < m and text[i + j] == pattern[j]:
            j += 1
        if j == m:
            return i  # Найдено совпадение в позиции i
    
    return -1  # Совпадение не найдено
```

### 2. Задача коммивояжера (упрощенная)

```python
from itertools import permutations

def tsp_brute_force(distances):
    """
    Решение задачи коммивояжера методом перебора
    """
    n = len(distances)
    cities = list(range(1, n))  # Исключаем начальный город
    min_cost = float('inf')
    best_route = None
    
    for perm in permutations(cities):
        route = [0] + list(perm) + [0]  # Начало и конец в городе 0
        cost = 0
        for i in range(len(route) - 1):
            cost += distances[route[i]][route[i+1]]
        
        if cost < min_cost:
            min_cost = cost
            best_route = route
    
    return best_route, min_cost
```

### 3. Решение уравнения методом перебора

```python
def find_integer_solution(a, b, c, max_range=1000):
    """
    Найти целочисленное решение уравнения ax + by = c
    """
    for x in range(-max_range, max_range + 1):
        for y in range(-max_range, max_range + 1):
            if a * x + b * y == c:
                return (x, y)
    return None  # Решение не найдено
```

## Анализ сложности

Сложность переборных алгоритмов обычно высока:

- **Временная сложность**: часто экспоненциальная или факториальная
  - Поиск подстроки: O(n×m)
  - Задача коммивояжера: O(n!)
  - Поиск в пространстве решений: O(k^n), где k - количество возможных значений для каждого элемента
- **Пространственная сложность**: обычно O(1) или O(n), если нужно хранить промежуточные результаты

## Преимущества и недостатки

### Преимущества

- **Простота реализации** - не требует сложных алгоритмических идей
- **Гарантированный результат** - если решение существует, оно будет найдено
- **Универсальность** - применим ко многим типам задач
- **Понятность** - легко понять и объяснить

### Недостатки

- **Высокая вычислительная сложность** - может быть непрактичным для больших данных
- **Низкая эффективность** - проверка всех возможностей без оптимизации
- **Зависимость от размера входных данных** - время выполнения резко возрастает

## Сравнение с другими парадигмами

| Парадигма | Сложность | Эффективность | Когда использовать |
|-----------|-----------|---------------|-------------------|
| Перебор | Высокая | Низкая | Маленькие задачи, тестирование |
| [[divide-and-conquer|Разделяй и властвуй]] | Зависит от задачи | Высокая | Задачи, которые можно разбить |
| [[dynamic-programming|Динамическое программирование]] | Зависит от задачи | Высокая | Задачи с перекрывающимися подзадачами |
| [[greedy|Жадные алгоритмы]] | Обычно низкая | Высокая | Задачи с оптимальной подструктурой |
| [[backtracking|Поиск с возвратом]] | Лучше, чем полный перебор | Средняя | Задачи с ограничениями |

## Практические примеры использования

### 1. Криптография
Перебор часто используется для взлома простых шифров, когда пытаются все возможные ключи.

### 2. Игровые алгоритмы
В простых играх, таких как "угадай число", может использоваться перебор возможных ходов.

### 3. Проверка гипотез
В научных вычислениях перебор может использоваться для проверки всех возможных комбинаций параметров.

## Связь с другими алгоритмами

Перебор часто служит основой для более сложных алгоритмов:

- [[backtracking|Поиск с возвратом]] - улучшенная версия перебора с отсечением недопустимых решений
- [[branch-and-bound|Метод ветвей и границ]] - перебор с оценкой перспективности ветвей
- [[combinatorial-search|Комбинаторный поиск]] - систематический перебор комбинаторных объектов

## Заключение

Перебор - это фундаментальная парадигма алгоритмов, которая, несмотря на низкую эффективность, остается важной для понимания алгоритмического мышления. Она служит основой для многих других подходов и полезна в случаях, когда:

- Размер задачи ограничен
- Требуется гарантированное решение
- Нужно протестировать более сложные алгоритмы
- Нет очевидных способов оптимизации

Хотя перебор редко используется в производственных системах из-за своей вычислительной сложности, он остается важным инструментом в арсенале разработчика и исследователя алгоритмов.

## См. также

- [[divide-and-conquer]]
- [[dynamic-programming]]
- [[greedy]]
- [[backtracking]]
- [[combinatorial-search]]
- [[algorithm-complexity]]

#алгоритмы #перебор #brute-force #алгоритмическая-сложность #парадигмы-алгоритмов