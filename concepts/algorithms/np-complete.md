---
aliases: ["NP-полнота", "NP-полные задачи", "Теория сложности"]
tags: 
  - "#algorithms"
  - "#complexity-theory"
  - "#theoretical-cs"
---

# NP-полные задачи

## Определение NP-полноты

**NP-полные задачи** — это класс вычислительных задач, которые обладают двумя ключевыми свойствами:
1. Они принадлежат классу [NP](np.md) — задачи, решения которых можно проверить за полиномиальное время.
2. Любая задача из класса NP может быть сведена к ней за полиномиальное время.

Формально, задача $L$ называется NP-полной, если:
- $L \in NP$
- $\forall L' \in NP: L' \leq_p L$ (все задачи из NP сводятся к $L$ за полиномиальное время)

## Проблема P vs NP

Центральный вопрос теории вычислительной сложности: **P = NP?**

- **P** — класс задач, решаемых за полиномиальное время на детерминированной машине Тьюринга.
- **NP** — класс задач, решения которых можно проверить за полиномиальное время.

Если P = NP, то все NP-полные задачи имеют полиномиальные решения. Это одна из семи задач тысячелетия, за решение которой институт Клэя предлагает премию в 1 миллион долларов.

## Примеры NP-полных задач

### SAT (Проблема выполнимости булевых формул)

**Определение:** Дано булевое выражение в конъюнктивной нормальной форме (КНФ). Существует ли набор значений переменных, при котором выражение принимает значение "истина"?

**Формулировка:** Пусть $\phi = C_1 \land C_2 \land \ldots \land C_m$, где $C_i$ — дизъюнкция литералов. Найти $\{x_1, x_2, \ldots, x_n\}$ такое, что $\phi$ истинно.

**Пример:**
```text
(x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2) ∧ (x2 ∨ ¬x3)
```
Решение: $x_1 = \text{ложь}, x_2 = \text{истина}, x_3 = \text{истина}$

### TSP (Задача коммивояжера)

**Определение:** Дан взвешенный граф. Найти кратчайший гамильтонов цикл — маршрут, проходящий через каждую вершину ровно один раз.

**Формулировка:** Минимизировать $\sum_{i=1}^{n} w(v_i, v_{i+1})$, где $v_{n+1} = v_1$, при условии, что все вершины пройдены ровно один раз.

**Сложность:** $O(n!)$ для перебора всех маршрутов.

### Vertex Cover (Покрытие вершин)

**Определение:** Найти минимальное подмножество вершин графа, такое что каждое ребро инцидентно хотя бы одной вершине из этого подмножества.

**Формулировка:** Дан граф $G(V, E)$ и число $k$. Существует ли $V' \subseteq V$, $|V'| \leq k$, такое что $\forall (u,v) \in E: u \in V' \lor v \in V'$?

### Independent Set (Независимое множество)

**Определение:** Найти максимальное подмножество вершин графа, между которыми нет рёбер.

**Формулировка:** Дан граф $G(V, E)$ и число $k$. Существует ли $V' \subseteq V$, $|V'| \geq k$, такое что $\forall u,v \in V': (u,v) \notin E$?

### Clique (Клика)

**Определение:** Найти максимальное полносвязное подмножество вершин графа.

**Формулировка:** Дан граф $G(V, E)$ и число $k$. Существует ли $V' \subseteq V$, $|V'| \geq k$, такое что $\forall u,v \in V': (u,v) \in E$?

## Техники сведения

**Полиномиальное сведение** $L_1 \leq_p L_2$ — это преобразование входа задачи $L_1$ в эквивалентный вход задачи $L_2$ за полиномиальное время.

### Методы сведения:
- **Конструктивное сведение:** Построение эквивалентной задачи $L_2$ из $L_1$
- **Редукция с ограничениями:** Использование специфических ограничений
- **Модификация входа:** Изменение структуры входных данных

**Пример сведения:** Vertex Cover ≤p Independent Set
- В графе $G(V,E)$: $V'$ — покрытие вершин $\Leftrightarrow$ $V \setminus V'$ — независимое множество
- Следовательно, задачи эквивалентны и обе NP-полные

## Полиномиальная проверка решений

Для задачи из NP существует **полиномиальный верификатор** — алгоритм, который проверяет, является ли предложенное решение правильным за полиномиальное время.

**Пример для SAT:**
```python
def verify_sat(formula, assignment):
    """
    Проверяет, удовлетворяет ли assignment формулу в КНФ
    """
    for clause in formula:
        clause_satisfied = False
        for literal in clause:
            var, is_positive = literal
            if (is_positive and assignment[var]) or (not is_positive and not assignment[var]):
                clause_satisfied = True
                break
        if not clause_satisfied:
            return False
    return True
```

## Практические последствия

NP-полные задачи возникают во множестве приложений:
- **Оптимизация:** Планирование, маршрутизация, распределение ресурсов
- **Криптография:** Безопасность систем часто основана на сложности NP-полных задач
- **Биоинформатика:** Сравнение последовательностей, предсказание структур белков
- **Логика:** Автоматическое доказательство теорем, верификация программ

## Приближенные алгоритмы

Поскольку точные решения NP-полных задач требуют экспоненциального времени, часто используют **приближенные алгоритмы** с гарантией качества решения.

**Пример: 2-аппроксимация для Vertex Cover**
```python
def approx_vertex_cover(graph):
    """
    Жадный алгоритм: O(E) время, 2-аппроксимация
    """
    cover = set()
    edges = set(graph.edges())
    
    while edges:
        u, v = edges.pop()
        cover.add(u)
        cover.add(v)
        # Удаляем все рёбра, инцидентные u и v
        edges = {e for e in edges if u not in e and v not in e}
    
    return cover
```

## Эвристические подходы

Когда приближенные алгоритмы недостаточны, применяют **эвристики** без гарантий качества:
- **Локальный поиск:** 2-opt для TSP
- **Генетические алгоритмы**
- **Имитация отжига**
- **Муравьиные алгоритмы**

## Связь с другими концепциями

- [[np]] — класс задач с полиномиальной проверкой
- [[complexity-classes]] — иерархия вычислительной сложности
- [[approximation-algorithms]] — методы получения приближенных решений
- [[graph-theory]] — основа для многих NP-полных задач

## Заключение

NP-полные задачи представляют собой важный класс вычислительных проблем, которые, как предполагается, не имеют эффективных решений. Понимание этих задач критично для разработчиков алгоритмов, поскольку помогает:
- Осознавать пределы вычислительной эффективности
- Выбирать подходящие методы решения (точные, приближенные, эвристические)
- Понимать границы применимости различных алгоритмов

См. также: [[p-vs-np]], [[reduction]], [[approximation-theory]]