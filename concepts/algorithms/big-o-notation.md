---
aliases: ["Асимптотический анализ", "Сложность алгоритмов"]
tags: 
  - algorithms
  - complexity
  - analysis
  - computer-science
---

# Нотация O-большое (Big O)

## Определение

Нотация O-большое (Big O) — это математическая нотация, используемая в информатике для описания производительности или сложности алгоритма. Она характеризует время выполнения алгоритма или объем памяти, который он использует в зависимости от размера входных данных.

## Типы асимптотических нотаций

### O-большое (Big O) - верхняя граница
- Обозначает **верхнюю границу** сложности алгоритма
- Показывает **наихудший случай** выполнения алгоритма
- Формально: f(n) = O(g(n)), если существует c > 0 и n₀ ≥ 0, такие что f(n) ≤ c * g(n) для всех n ≥ n₀

### Ω-большое (Omega) - нижняя граница
- Обозначает **нижнюю границу** сложности алгоритма
- Показывает **наилучший случай** выполнения алгоритма
- Формально: f(n) = Ω(g(n)), если существует c > 0 и n₀ ≥ 0, такие что f(n) ≥ c * g(n) для всех n ≥ n₀

### Θ-большое (Theta) - точная граница
- Обозначает **точную границу** сложности алгоритма
- Используется, когда верхняя и нижняя границы совпадают
- Формально: f(n) = Θ(g(n)), если f(n) = O(g(n)) и f(n) = Ω(g(n))

## Классы сложности

### O(1) - постоянная сложность
```javascript
function getFirstElement(arr) {
    return arr[0]; // Всегда выполняется за одно действие
}
```
- Время выполнения не зависит от размера входных данных
- Примеры: доступ к элементу массива по индексу, операции с хеш-таблицами (в среднем случае)

### O(log n) - логарифмическая сложность
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```
- Характерна для алгоритмов, которые на каждом шаге делят задачу пополам
- Примеры: бинарный поиск, деревья поиска

### O(n) - линейная сложность
```javascript
function findMax(arr) {
    let max = arr[0];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
    }
    return max;
}
```
- Время выполнения пропорционально количеству элементов
- Примеры: линейный поиск, обход массива

### O(n log n) - линейитмическая сложность
```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) result.push(left[i++]);
        else result.push(right[j++]);
    }
    
    return result.concat(left.slice(i), right.slice(j));
}
```
- Характерна для эффективных алгоритмов сортировки
- Примеры: сортировка слиянием, быстрая сортировка (в среднем случае)

### O(n²) - квадратичная сложность
```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
```
- Характерна для алгоритмов с вложенными циклами
- Примеры: пузырьковая сортировка, сортировка выбором

### O(2ⁿ) - экспоненциальная сложность
```javascript
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```
- Рост вдвое при каждом увеличении входных данных
- Примеры: рекурсивное вычисление чисел Фибоначчи, задача о рюкзаке

### O(n!) - факториальная сложность
```javascript
function permutations(arr) {
    if (arr.length <= 1) return [arr];
    
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        const rest = arr.slice(0, i).concat(arr.slice(i + 1));
        const restPermutations = permutations(rest);
        for (let j = 0; j < restPermutations.length; j++) {
            result.push([arr[i]].concat(restPermutations[j]));
        }
    }
    return result;
}
```
- Наихудший класс сложности, быстро становится непрактичным
- Примеры: генерация всех перестановок, задача коммивояжера

## Анализ алгоритмов с помощью нотации O-большое

При анализе алгоритмов важно:
1. Определить основные операции
2. Подсчитать количество операций в зависимости от размера входных данных
3. Оставить только доминирующий член
4. Игнорировать константные множители

**Пример анализа:**
```javascript
function example(arr) {
    let sum = 0;                    // O(1)
    for (let i = 0; i < arr.length; i++) {  // n итераций
        sum += arr[i];              // O(1) на итерацию
    }
    return sum;                     // O(1)
}
// Общая сложность: O(1) + O(n) + O(1) = O(n)
```

## Анализ по худшему, среднему и лучшему случаю

- **Худший случай (Worst Case)**: максимальное время выполнения для любого входа определенного размера
- **Средний случай (Average Case)**: среднее время выполнения по всем возможным входам
- **Лучший случай (Best Case)**: минимальное время выполнения для любого входа определенного размера

> [!tip] Заметка
> Обычно анализируют худший случай, так как он дает гарантию производительности алгоритма.

## Визуальные представления

Для лучшего понимания различий в сложности алгоритмов полезно представлять их визуально:
- График логарифмической функции растет медленнее всех
- Линейная функция растет пропорционально
- Лог-линейная (n log n) находится между линейной и квадратичной
- Квадратичная растет быстрее линейной
- Экспоненциальная и факториальная функции растут чрезвычайно быстро

## Практические примеры расчета сложности

### Пример 1: Вложенные циклы
```javascript
function nestedLoops(n) {
    for (let i = 0; i < n; i++) {        // n итераций
        for (let j = 0; j < n; j++) {    // n итераций для каждого i
            console.log(i, j);           // O(1)
        }
    }
}
// Сложность: O(n²)
```

### Пример 2: Рекурсивный алгоритм
```javascript
function power(base, exp) {
    if (exp === 0) return 1;             // O(1)
    return base * power(base, exp - 1);  // exp рекурсивных вызовов
}
// Сложность: O(exp)
```

## Связанные концепции

- [[data-structures]] - структуры данных и их сложности
- [[sorting-algorithms]] - алгоритмы сортировки и их сложности
- [[searching-algorithms]] - алгоритмы поиска и их сложности
- [[recursion]] - рекурсивные алгоритмы и их анализ
- [[dynamic-programming]] - динамическое программирование и оптимизация сложности

## Заключение

Понимание нотации O-большое критически важно для разработки эффективных алгоритмов. Она позволяет:
- Сравнивать эффективность различных алгоритмов
- Принимать обоснованные решения при выборе структур данных
- Прогнозировать производительность при увеличении объема данных
- Оптимизировать код с учетом ограничений по времени и памяти

> [!warning] Важно
> Нотация O-большое описывает асимптотическое поведение при стремлении размера входных данных к бесконечности и не учитывает константные факторы, которые могут быть важны для малых объемов данных.