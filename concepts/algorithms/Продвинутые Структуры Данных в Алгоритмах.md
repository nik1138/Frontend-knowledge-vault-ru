---
aliases: [Структуры данных, Алгоритмы, АВЛ-деревья, Красно-черные деревья, Графы, Хеш-таблицы]
tags: [algorithms, data-structures, computer-science, advanced-topics]
---

# Продвинутые Структуры Данных в Алгоритмах

## Введение

Продвинутые структуры данных играют ключевую роль в разработке эффективных алгоритмов. Понимание их свойств и особенностей позволяет создавать более оптимизированные решения для сложных вычислительных задач. В этой статье мы рассмотрим основные продвинутые структуры данных, их реализацию и применение в алгоритмах.

## Деревья

### Бинарные деревья поиска (BST)

Бинарное дерево поиска — это упорядоченное двоичное дерево, где для каждого узла выполняется условие: все значения в левом поддереве меньше значения в узле, а все значения в правом поддереве — больше.

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

BST обеспечивает эффективные операции поиска, вставки и удаления в среднем за O(log n) времени, при условии, что дерево сбалансировано.

### Сбалансированные деревья

Сбалансированные деревья, такие как [[АВЛ-деревья]] и [[Красно-черные деревья]], гарантируют, что высота дерева остается O(log n), обеспечивая стабильную производительность.

#### АВЛ-деревья

АВЛ-деревья — это самобалансирующиеся бинарные деревья поиска, где разница высот левого и правого поддеревьев для любого узла не превышает 1. Это требует выполнения вращений при вставке или удалении узлов для поддержания баланса.

```cpp
class AVLNode {
public:
    int val;
    int height;
    AVLNode* left;
    AVLNode* right;
    
    AVLNode(int x) : val(x), height(1), left(nullptr), right(nullptr) {}
};
```

#### Красно-черные деревья

Красно-черные деревья — это самобалансирующиеся бинарные деревья поиска, удовлетворяющие следующим свойствам:
- Каждый узел окрашен в красный или черный цвет
- Корень всегда черный
- Все листья (NULL узлы) черные
- Красные узлы не могут быть родителями друг друга
- Все пути от узла до его потомков содержат одинаковое количество черных узлов

Эти свойства обеспечивают, что самая длинная ветвь не превышает самую короткую более чем в 2 раза, что дает O(log n) для основных операций.

### B-деревья

B-деревья — это сбалансированные деревья поиска, где каждый узел может содержать несколько ключей и иметь несколько потомков. Используются в базах данных и файловых системах, где важна эффективность при работе с диском.

```cpp
class BTreeNode {
public:
    std::vector<int> keys;
    std::vector<BTreeNode*> children;
    bool isLeaf;
    int degree; // минимальная степень
};
```

## Графы

Графы представляют собой структуры данных, состоящие из вершин (узлов) и ребер (соединений между узлами). Они широко используются для моделирования отношений между объектами.

### Представление графов

#### Список смежности

Список смежности — это массив списков, где каждый элемент массива соответствует вершине, а список содержит все вершины, смежные с данной.

```cpp
#include <vector>
#include <list>

class Graph {
    int vertices;
    std::vector<std::list<int>> adjList;
public:
    Graph(int v) : vertices(v), adjList(v) {}
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // для неориентированного графа
    }
};
```

#### Матрица смежности

Матрица смежности — это двумерный массив, где элемент matrix[i][j] равен 1, если существует ребро между вершинами i и j, и 0 в противном случае.

```cpp
class Graph {
    int vertices;
    std::vector<std::vector<int>> adjMatrix;
public:
    Graph(int v) : vertices(v), adjMatrix(v, std::vector<int>(v, 0)) {}
    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // для неориентированного графа
    }
};
```

### Алгоритмы на графах

#### Поиск в глубину (DFS)

DFS — это алгоритм обхода или поиска в графе, который начинает с корневой вершины и исследует как можно дальше каждую ветвь перед тем, как отступить.

```cpp
void DFS(int vertex, std::vector<bool>& visited, const std::vector<std::list<int>>& adjList) {
    visited[vertex] = true;
    std::cout << vertex << " ";
    
    for (int neighbor : adjList[vertex]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited, adjList);
        }
    }
}
```

#### Поиск в ширину (BFS)

BFS — это алгоритм обхода графа, который начинает с корневой вершины и посещает все соседние вершины на текущем уровне перед переходом к вершинам следующего уровня.

```cpp
#include <queue>

void BFS(int start, const std::vector<std::list<int>>& adjList) {
    std::vector<bool> visited(adjList.size(), false);
    std::queue<int> queue;
    
    visited[start] = true;
    queue.push(start);
    
    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();
        std::cout << current << " ";
        
        for (int neighbor : adjList[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.push(neighbor);
            }
        }
    }
}
```

## Хеш-таблицы

Хеш-таблицы — это структуры данных, которые реализуют ассоциативный массив, сопоставляющий ключи со значениями. Они обеспечивают среднее время O(1) для поиска, вставки и удаления.

### Принцип работы

Хеш-таблица использует хеш-функцию для вычисления индекса в массиве, где будет храниться значение. При коллизиях (когда несколько ключей дают одинаковый хеш) используются методы разрешения коллизий, такие как цепочки или открытая адресация.

```cpp
#include <vector>
#include <list>
#include <utility>

template<typename K, typename V>
class HashTable {
private:
    std::vector<std::list<std::pair<K, V>>> table;
    size_t size;
    
    size_t hash(const K& key) const {
        return std::hash<K>{}(key) % table.size();
    }
    
public:
    HashTable(size_t initialSize = 16) : size(initialSize), table(initialSize) {}
    
    void put(const K& key, const V& value) {
        size_t index = hash(key);
        for (auto& pair : table[index]) {
            if (pair.first == key) {
                pair.second = value;
                return;
            }
        }
        table[index].push_back(std::make_pair(key, value));
    }
    
    V get(const K& key) const {
        size_t index = hash(key);
        for (const auto& pair : table[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        throw std::runtime_error("Key not found");
    }
};
```

### Решение коллизий

#### Метод цепочек

При методе цепочек каждый элемент хеш-таблицы содержит указатель на связный список пар ключ-значение, которые хешируются в этот индекс.

#### Открытая адресация

При открытой адресации все элементы хранятся непосредственно в массиве. При коллизии алгоритм ищет следующую свободную ячейку, используя методы линейного, квадратичного пробирования или двойного хеширования.

## Кучи (Heaps)

Куча — это специализированная древовидная структура данных, которая удовлетворяет свойству кучи: если A является родительским узлом для B, то ключ(A) и ключ(B) связаны упорядочением, и это отношение верно для всех узлов.

### Двоичная куча

Двоичная куча — это полное бинарное дерево, которое удовлетворяет свойству кучи. Может быть минимальной (ключ родителя меньше или равен ключам потомков) или максимальной (ключ родителя больше или равен ключам потомков).

```cpp
#include <vector>
#include <algorithm>

class MinHeap {
private:
    std::vector<int> heap;
    
    void heapifyUp(int index) {
        if (index == 0) return;
        int parent = (index - 1) / 2;
        if (heap[parent] > heap[index]) {
            std::swap(heap[parent], heap[index]);
            heapifyUp(parent);
        }
    }
    
    void heapifyDown(int index) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        int smallest = index;
        
        if (left < heap.size() && heap[left] < heap[smallest])
            smallest = left;
        if (right < heap.size() && heap[right] < heap[smallest])
            smallest = right;
            
        if (smallest != index) {
            std::swap(heap[index], heap[smallest]);
            heapifyDown(smallest);
        }
    }
    
public:
    void push(int value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }
    
    int pop() {
        if (heap.empty()) throw std::runtime_error("Heap is empty");
        int root = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) heapifyDown(0);
        return root;
    }
    
    int top() const {
        if (heap.empty()) throw std::runtime_error("Heap is empty");
        return heap[0];
    }
};
```

## Trie (Префиксное дерево)

Trie — это древовидная структура данных, используемая для эффективного хранения и поиска строк. Каждый узел представляет собой символ, а путь от корня до узла представляет строку.

```cpp
class TrieNode {
public:
    std::vector<TrieNode*> children;
    bool isEndOfWord;
    
    TrieNode() : children(26, nullptr), isEndOfWord(false) {} // для латинских букв
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() : root(new TrieNode()) {}
    
    void insert(const std::string& word) {
        TrieNode* current = root;
        for (char c : word) {
            int index = c - 'a';
            if (!current->children[index]) {
                current->children[index] = new TrieNode();
            }
            current = current->children[index];
        }
        current->isEndOfWord = true;
    }
    
    bool search(const std::string& word) {
        TrieNode* current = root;
        for (char c : word) {
            int index = c - 'a';
            if (!current->children[index]) {
                return false;
            }
            current = current->children[index];
        }
        return current->isEndOfWord;
    }
};
```

## Применение в алгоритмах

### Алгоритмы поиска кратчайшего пути

- **Алгоритм Дейкстры**: использует минимальную кучу для поиска кратчайших путей от одной вершины ко всем другим в взвешенном графе с неотрицательными весами.
- **Алгоритм A***: использует эвристику и приоритетную очередь для поиска оптимального пути между двумя вершинами.

### Структуры данных с отложенной модификацией

- **Деревья отрезков (Segment Trees)**: позволяют эффективно отвечать на запросы суммы, минимума, максимума на отрезке с возможностью обновления элементов.
- **Деревья Фенвика (Binary Indexed Trees)**: эффективно вычисляют префиксные суммы и поддерживают обновления.

## Заключение

Продвинутые структуры данных являются фундаментом эффективных алгоритмов. Выбор подходящей структуры данных для конкретной задачи может значительно повлиять на производительность алгоритма. Понимание свойств каждой структуры позволяет разработчику принимать обоснованные решения при проектировании алгоритмов.

## Связанные темы

- [[Алгоритмы сортировки]]
- [[Алгоритмы поиска]]
- [[Асимптотическая сложность]]
- [[Динамическое программирование]]
- [[Графовые алгоритмы]]

> [!tip] 
> При выборе структуры данных учитывайте частоту выполнения операций, требования к памяти и специфику задачи.

> [!warning] 
> Неправильный выбор структуры данных может привести к значительному ухудшению производительности алгоритма.
