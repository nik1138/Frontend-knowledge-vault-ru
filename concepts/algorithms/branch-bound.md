---
aliases: ["Метод ветвей и границ", "Алгоритм ветвления и оценки"]
tags: 
  - #algorithm
  - #optimization
  - #paradigm
  - #combinatorial-optimization
---

# Метод ветвей и границ (Branch and Bound)

Метод ветвей и границ — это общий алгоритмический подход для решения задач комбинаторной оптимизации. Он используется для нахождения оптимального решения в задачах, где пространство решений велико и перебор всех возможных решений недопустим.

## Что такое метод ветвей и границ

Метод ветвей и границ — это стратегия решения задач оптимизации, которая разбивает пространство решений на подмножества (ветвление) и использует оценки (границы), чтобы исключить подмножества, не содержащие оптимального решения.

## Как работает метод

1. **Инициализация**: Начинаем с корневой задачи, представляющей все возможные решения.
2. **Ветвление**: Разбиваем задачу на подзадачи (ветви), каждая из которых представляет подмножество решений.
3. **Оценка (Bounding)**: Для каждой подзадачи вычисляем верхнюю и/или нижнюю границу целевой функции.
4. **Отсечение (Pruning)**: Исключаем подзадачи, которые не могут привести к лучшему решению, чем уже найденное.
5. **Повторение**: Повторяем процесс до тех пор, пока не будет исследовано все пространство решений или не будет найдено оптимальное решение.

## Когда использовать метод ветвей и границ

- Задачи комбинаторной оптимизации (например, задача коммивояжера, задача о рюкзаке)
- Задачи с дискретными переменными
- Задачи, где невозможно использовать жадные алгоритмы или динамическое программирование
- Когда требуется точное оптимальное решение, а не приближенное

## Примеры задач

- [[concepts/algorithms/knapsack#Метод ветвей и границ|Задача о рюкзаке]]
- [[concepts/algorithms/tsp#Метод ветвей и границ|Задача коммивояжера]]
- Целочисленное линейное программирование

## Основные техники оценки

### Верхняя и нижняя границы
- **Верхняя граница**: Максимальное возможное значение целевой функции для подзадачи
- **Нижняя граница**: Минимальное возможное значение целевой функции для подзадачи

### Техники оценки
1. **Линейная релаксация** — для задач с целочисленными переменными
2. **Жадные приближения** — для получения начальных оценок
3. **Эвристические методы** — для быстрой оценки качества подмножества решений

## Реализация алгоритма

```python
import heapq

class Node:
    def __init__(self, level, value, weight, bound):
        self.level = level
        self.value = value
        self.weight = weight
        self.bound = bound
    
    def __lt__(self, other):
        return self.bound > other.bound  # Максимальная куча

def calculate_bound(node, n, capacity, items):
    if node.weight >= capacity:
        return 0
    
    bound = node.value
    total_weight = node.weight
    
    for i in range(node.level, n):
        if total_weight + items[i][1] <= capacity:
            total_weight += items[i][1]
            bound += items[i][0]
        else:
            remaining_capacity = capacity - total_weight
            bound += (remaining_capacity * items[i][0]) / items[i][1]
            break
    
    return bound

def knapsack_branch_bound(capacity, items):
    n = len(items)
    items.sort(key=lambda x: x[0]/x[1], reverse=True)  # Сортировка по удельной стоимости
    
    queue = []
    root = Node(-1, 0, 0, 0)
    root.bound = calculate_bound(root, n, capacity, items)
    
    max_value = 0
    heapq.heappush(queue, root)
    
    while queue:
        node = heapq.heappop(queue)
        
        if node.bound <= max_value:
            continue
            
        if node.level == n - 1:
            continue
            
        # Включить следующий элемент
        next_level = node.level + 1
        included = Node(
            next_level,
            node.value + items[next_level][0],
            node.weight + items[next_level][1],
            0
        )
        
        if included.weight <= capacity and included.value > max_value:
            max_value = included.value
            
        included.bound = calculate_bound(included, n, capacity, items)
        
        if included.bound > max_value:
            heapq.heappush(queue, included)
        
        # Исключить следующий элемент
        excluded = Node(
            next_level,
            node.value,
            node.weight,
            0
        )
        excluded.bound = calculate_bound(excluded, n, capacity, items)
        
        if excluded.bound > max_value:
            heapq.heappush(queue, excluded)
    
    return max_value
```

## Сравнение с другими парадигмами

| Парадигма | Преимущества | Недостатки | Когда использовать |
|----------|-------------|------------|-------------------|
| [[concepts/algorithms/brute-force|Полный перебор]] | Гарантия оптимальности | Высокая сложность | Очень маленькие задачи |
| [[concepts/algorithms/dynamic-programming|Динамическое программирование]] | Эффективность для задач с перекрывающимися подзадачами | Не подходит для всех задач | Оптимальная подструктура и перекрывающиеся подзадачи |
| [[concepts/algorithms/greedy|Жадные алгоритмы]] | Быстрота | Не гарантирует оптимальность | Задачи с жадным выбором |
| **Метод ветвей и границ** | Гарантия оптимальности, отсечение | Сложная реализация | Комбинаторные задачи оптимизации |

## Связи с другими алгоритмами

- [[concepts/algorithms/backtracking|Поиск с возвратом]] — метод ветвей и границ можно рассматривать как улучшенный вариант поиска с возвратом с использованием оценок
- [[concepts/algorithms/divide-conquer|Разделяй и властвуй]] — обе парадигмы разбивают задачу на подзадачи, но метод ветвей и границ использует отсечение
- [[concepts/algorithms/approximation|Аппроксимационные алгоритмы]] — альтернатива, когда точное решение слишком дорого

## Заключение

Метод ветвей и границ — мощный инструмент для решения задач комбинаторной оптимизации. Он эффективно сокращает пространство поиска за счет использования оценок и отсечений, что делает его предпочтительным выбором для многих NP-трудных задач.
