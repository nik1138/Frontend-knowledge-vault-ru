---
aliases: ["Алгоритмические парадигмы", "Методы программирования"]
tags: 
  - algorithms
  - programming
  - computer-science
  - complexity
---

# Алгоритмические парадигмы

Алгоритмические парадигмы — это общие методы проектирования алгоритмов, которые описывают основную логику решения класса задач. Понимание этих подходов позволяет выбрать наиболее эффективный способ решения конкретной задачи.

## Разделяй и властвуй (Divide and Conquer)

### Определение
Метод "разделяй и властвуй" разбивает задачу на более мелкие подзадачи того же типа, рекурсивно решает каждую подзадачу, а затем объединяет решения.

### Когда использовать
- Задача может быть разбита на независимые подзадачи
- Решение задачи можно получить из решений подзадач
- Примеры: сортировка слиянием, быстрая сортировка, бинарный поиск

### Пример: Сортировка слиянием
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

## Динамическое программирование (Dynamic Programming)

### Определение
Динамическое программирование решает задачу, разбивая её на перекрывающиеся подзадачи и сохраняя решения подзадач, чтобы избежать повторных вычислений.

### Когда использовать
- Задача имеет оптимальную подструктуру
- Подзадачи перекрываются
- Примеры: задача о рюкзаке, нахождение чисел Фибоначчи, задача о наименьшем общем подпоследовательности

### Пример: Числа Фибоначчи
```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]
```

## Жадные алгоритмы (Greedy Algorithms)

### Определение
Жадные алгоритмы делают локально оптимальный выбор на каждом шаге с надеждой получить глобально оптимальное решение.

### Когда использовать
- Локально оптимальные решения приводят к глобально оптимальному решению
- Задача обладает свойством жадного выбора
- Примеры: задача о выборе активностей, кодирование Хаффмана, минимальное остовное дерево

### Пример: Задача о выборе активностей
```python
def activity_selection(activities):
    # Сортируем по времени окончания
    activities.sort(key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end_time = activities[0][1]
    
    for i in range(1, len(activities)):
        start_time, end_time = activities[i]
        if start_time >= last_end_time:
            selected.append(activities[i])
            last_end_time = end_time
    
    return selected
```

## Метод возврата (Backtracking)

### Определение
Метод возврата строит решение пошагово, и если текущий путь не приводит к решению, откатывается и пробует другой путь.

### Когда использовать
- Нужно найти все возможные решения
- Решение можно представить как последовательность шагов
- Примеры: задача о восьми ферзях, судоку, задача коммивояжера

### Пример: Задача о восьми ферзях
```python
def solve_n_queens(n):
    def is_safe(board, row, col):
        for i in range(row):
            if board[i] == col or \
               board[i] - i == col - row or \
               board[i] + i == col + row:
                return False
        return True
    
    def backtrack(board, row):
        if row == n:
            return [board[:]]
        
        solutions = []
        for col in range(n):
            if is_safe(board, row, col):
                board[row] = col
                solutions.extend(backtrack(board, row + 1))
                board[row] = -1
        return solutions
    
    board = [-1] * n
    return backtrack(board, 0)
```

## Перебор (Brute Force)

### Определение
Метод полного перебора проверяет все возможные решения задачи до нахождения правильного.

### Когда использовать
- Размер входных данных мал
- Нет очевидного эффективного алгоритма
- Необходимо найти точное решение
- Примеры: задача коммивояжера для малого числа городов, проверка всех перестановок

### Пример: Поиск максимальной подпоследовательности
```python
def max_subarray_brute_force(arr):
    max_sum = float('-inf')
    n = len(arr)
    
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += arr[j]
            max_sum = max(max_sum, current_sum)
    
    return max_sum
```

## Рандомизированные алгоритмы (Randomized Algorithms)

### Определение
Алгоритмы, использующие случайность как часть своей логики для принятия решений.

### Когда использовать
- Когда детерминированный алгоритм слишком медленный
- Для приближенных решений
- Примеры: рандомизированная быстрая сортировка, алгоритм Монте-Карло

### Пример: Рандомизированная быстрая сортировка
```python
import random

def randomized_quicksort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = random.choice(arr)
    less = [x for x in arr if x < pivot]
    equal = [x for x in arr if x == pivot]
    greater = [x for x in arr if x > pivot]
    
    return randomized_quicksort(less) + equal + randomized_quicksort(greater)
```

## Сравнительный анализ

| Парадигма | Время | Пространство | Когда использовать |
|-----------|-------|--------------|-------------------|
| Разделяй и властвуй | O(n log n) | O(log n) | Независимые подзадачи |
| Динамическое программирование | O(n) или O(n²) | O(n) | Перекрывающиеся подзадачи |
| Жадные алгоритмы | O(n log n) или O(n) | O(1) | Свойство жадного выбора |
| Метод возврата | O(k^n) | O(n) | Поиск всех решений |
| Перебор | O(n!) или O(2^n) | O(1) | Малые данные |
| Рандомизированные | Зависит от реализации | Зависит от реализации | Приближенные решения |

## Связь с другими файлами

- [[concepts/algorithms/sorting]] - Сортировки реализуются с помощью различных парадигм
- [[concepts/algorithms/searching]] - Поиск использует парадигмы для оптимизации
- [[concepts/data-structures]] - Структуры данных часто оптимизированы под определенные парадигмы
- [[concepts/complexity-analysis]] - Анализ сложности важен для выбора подходящей парадигмы

## Заключение

Выбор правильной алгоритмической парадигмы критически важен для эффективного решения задач. Каждая парадигма имеет свои сильные и слабые стороны, и понимание этих различий позволяет разработчику выбирать наилучший подход для конкретной задачи.