# Теория вычислительной сложности

## Введение

Теория вычислительной сложности — это раздел теории вычислений, изучающий ресурсы, необходимые для решения вычислительных задач. Основные ресурсы — это **время** (количество шагов алгоритма) и **память** (объем памяти, необходимый для выполнения).

## Временная сложность

**Временная сложность** — это количество элементарных операций, которые алгоритм должен выполнить в зависимости от размера входных данных.

### Примеры временной сложности

```python
# O(1) - постоянное время
def get_first_element(arr):
    return arr[0] if arr else None

# O(n) - линейное время
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# O(n²) - квадратичное время
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# O(log n) - логарифмическое время
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

## Пространственная сложность

**Пространственная сложность** — это объем памяти, необходимый алгоритму в зависимости от размера входных данных.

```python
# O(1) - постоянная память
def constant_space_sum(arr):
    total = 0
    for num in arr:
        total += num
    return total

# O(n) - линейная память
def duplicate_array(arr):
    return [x for x in arr]  # Создает новую копию массива
```

## Нотации сложности

### Нотация O (Big O)

**O(f(n))** — верхняя граница сложности. Обозначает, что алгоритм не будет работать медленнее, чем f(n) при больших n.

- O(1) — постоянное время
- O(log n) — логарифмическое время
- O(n) — линейное время
- O(n log n) — линейитмическое время
- O(n²) — квадратичное время
- O(2ⁿ) — экспоненциальное время
- O(n!) — факториальное время

### Нотация Ω (Омега)

**Ω(f(n))** — нижняя граница сложности. Алгоритм будет работать не быстрее, чем f(n).

### Нотация Θ (Тета)

**Θ(f(n))** — точная граница сложности. Алгоритм работает в пределах f(n) как сверху, так и снизу.

## Классы сложности

### Класс P

**P** (Polynomial time) — класс задач, которые могут быть решены детерминированной машиной Тьюринга за полиномиальное время. 

Примеры:
- Сортировка массива (O(n log n))
- Поиск в отсортированном массиве (O(log n))
- Проверка числа на простоту (O(log n))

### Класс NP

**NP** (Nondeterministic Polynomial time) — класс задач, решения которых могут быть проверены за полиномиальное время.

Примеры:
- Задача коммивояжера
- Задача о выполнимости булевых формул (SAT)
- Задача о вершинном покрытии

### NP-полные задачи

**NP-полные** задачи — это задачи из класса NP, к которым можно свести любую другую задачу из NP за полиномиальное время.

Примеры:
- 3-SAT
- Задача о клике
- Задача о независимом множестве
- Задача коммивояжера

### NP-трудные задачи

**NP-трудные** задачи — это задачи, к которым можно свести любую задачу из NP за полиномиальное время, но они не обязательно принадлежат NP.

## Полиномиальное vs экспоненциальное время

> [!note] Важно
> Алгоритмы с полиномиальной сложностью (P) считаются эффективными, в то время как алгоритмы с экспоненциальной сложностью (O(2ⁿ), O(n!)) становятся непрактичными при увеличении размера входных данных.

## Приближенные алгоритмы

Для NP-трудных задач часто используются **приближенные алгоритмы**, которые дают решения, близкие к оптимальным, за полиномиальное время.

Пример: приближенный алгоритм для задачи коммивояжера с коэффициентом 2 для метрического случая.

## Компромиссы между временем и памятью

Часто можно ускорить алгоритм, используя больше памяти (например, с помощью [[caching]]), или наоборот — уменьшить использование памяти ценой увеличения времени выполнения.

> [!tip] Совет
> Выбор между временем и памятью зависит от конкретной задачи и доступных ресурсов.

## Связи с другими концепциями

- [[algorithm-design]] — методы проектирования алгоритмов
- [[data-structures]] — структуры данных, влияющие на сложность
- [[optimization]] — методы оптимизации алгоритмов
- [[recursion]] — рекурсивные алгоритмы и их сложность

## Заключение

Понимание вычислительной сложности критически важно для разработки эффективных алгоритмов. Знание классов сложности помогает определить, какие задачи можно решить эффективно, а какие требуют приближенных решений.

#tags: #programming #algorithms #complexity #theoretical-computer-science #mathematics #optimization