---
aliases: ["Динамическое программирование", "DP"]
tags: 
  - #algorithms
  - #programming
  - #optimization
  - #computer-science
---

# Динамическое программирование (Dynamic Programming)

**Динамическое программирование (DP)** — это метод решения сложных задач путем разбиения их на более простые подзадачи, решения которых сохраняются и используются для решения исходной задачи. Это особенно эффективно для задач с **перекрывающимися подзадачами** и **оптимальной подструктурой**.

## Основные понятия

Динамическое программирование особенно полезно в следующих случаях:
- Задача может быть разбита на подзадачи
- Решения подзадач повторно используются (перекрывающиеся подзадачи)
- Оптимальное решение задачи может быть построено из оптимальных решений подзадач (оптимальная подструктура)

## Memoization vs Tabulation

### Memoization (сверху вниз)

Memoization — это техника, при которой результаты вычислений сохраняются в кэше (обычно в виде хэш-таблицы), чтобы избежать повторных вычислений. Подход "сверху вниз", где мы начинаем с решения основной задачи и рекурсивно вызываем подзадачи.

```javascript
function fibonacciMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo);
    return memo[n];
}
```

**Преимущества:**
- Легко реализовать на основе рекурсивного решения
- Вычисляются только нужные подзадачи

**Недостатки:**
- Использует дополнительную память для стека вызовов
- Может быть медленнее из-за накладных расходов на вызовы функций

### Tabulation (снизу вверх)

Tabulation — это подход "снизу вверх", где мы начинаем с решения самых простых подзадач и постепенно строим решение к более сложным задачам, используя таблицу (обычно массив).

```javascript
function fibonacciTab(n) {
    if (n <= 1) return n;
    
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

**Преимущества:**
- Обычно более эффективен по времени и памяти
- Нет накладных расходов на рекурсию

**Недостатки:**
- Требует более тщательного планирования порядка вычислений
- Может вычислять ненужные подзадачи

## Классические задачи DP

### 1. Числа Фибоначчи

**Задача:** Найти n-е число Фибоначчи.

**Memoization:**
- Время: O(n)
- Память: O(n)

**Tabulation:**
- Время: O(n)
- Память: O(n)

### 2. Наибольшая общая подпоследовательность (LCS)

**Задача:** Найти длину наибольшей общей подпоследовательности двух строк.

```javascript
function lcs(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i-1] === str2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
```

- Время: O(m * n)
- Память: O(m * n)

### 3. Задача о рюкзаке (0/1)

**Задача:** Найти максимальную стоимость, которую можно унести в рюкзаке с ограниченной вместимостью.

```javascript
function knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(
                    dp[i-1][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                );
            } else {
                dp[i][w] = dp[i-1][w];
            }
        }
    }
    return dp[n][capacity];
}
```

- Время: O(n * capacity)
- Память: O(n * capacity)

### 4. Задача о сдаче (Coin Change)

**Задача:** Найти минимальное количество монет для получения заданной суммы.

```javascript
function coinChange(coins, amount) {
    const dp = Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    
    for (let i = 1; i <= amount; i++) {
        for (const coin of coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
}
```

- Время: O(amount * coins.length)
- Память: O(amount)

### 5. Расстояние редактирования (Edit Distance)

**Задача:** Найти минимальное количество операций для преобразования одной строки в другую.

```javascript
function editDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i-1] === str2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i-1][j],     // удаление
                    dp[i][j-1],     // вставка
                    dp[i-1][j-1]    // замена
                );
            }
        }
    }
    return dp[m][n];
}
```

- Время: O(m * n)
- Память: O(m * n)

### 6. Умножение матричных цепочек

**Задача:** Найти оптимальный порядок умножения матриц для минимизации операций.

```javascript
function matrixChainOrder(dimensions) {
    const n = dimensions.length - 1;
    const dp = Array(n).fill().map(() => Array(n).fill(0));
    
    for (let len = 2; len <= n; len++) {
        for (let i = 0; i <= n - len; i++) {
            const j = i + len - 1;
            dp[i][j] = Infinity;
            
            for (let k = i; k < j; k++) {
                const cost = dp[i][k] + dp[k+1][j] + 
                            dimensions[i] * dimensions[k+1] * dimensions[j+1];
                dp[i][j] = Math.min(dp[i][j], cost);
            }
        }
    }
    return dp[0][n-1];
}
```

- Время: O(n³)
- Память: O(n²)

## Когда использовать DP

Используйте DP, когда:
- Задача имеет **перекрывающиеся подзадачи**
- Задача обладает **оптимальной подструктурой**
- Прямой рекурсивный подход дает экспоненциальную сложность

## Преимущества и недостатки

**Преимущества:**
- Снижение временной сложности с экспоненциальной до полиномиальной
- Эффективное решение сложных задач
- Повторное использование результатов подзадач

**Недостатки:**
- Требует дополнительной памяти для хранения результатов
- Может быть сложно определить структуру подзадач
- Не всегда интуитивно понятен подход

## Паттерны распознавания задач DP

- Оптимизация (минимизация/максимизация)
- Подсчет количества способов что-то сделать
- Задачи на последовательности/строки
- Задачи на деревья/графы с оптимизацией
- Игровые задачи с оптимальной стратегией

## Связь с другими концепциями

- [[recursion]] - DP часто строится на рекурсивных решениях
- [[memoization]] - ключевая техника в DP
- [[greedy-algorithms]] - альтернативный подход к оптимизационным задачам
- [[graph-theory]] - DP используется в алгоритмах на графах
- [[algorithm-complexity]] - важен для анализа эффективности DP решений