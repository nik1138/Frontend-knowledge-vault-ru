---
aliases: ["Рекурсия", "Рекурсивные алгоритмы"]
tags: 
  - #algorithms
  - #recursion
  - #data-structures
  - #complexity
---

# Рекурсивные алгоритмы

## Введение

Рекурсия — это метод программирования, при котором функция вызывает саму себя для решения задачи. Рекурсивные алгоритмы разбивают сложную задачу на более простые подзадачи того же типа, пока не достигнут базового случая, который можно решить напрямую.

## Структура рекурсивного алгоритма

Каждый рекурсивный алгоритм состоит из двух ключевых компонентов:

1. **Базовый случай (base case)** — условие, при котором рекурсия останавливается
2. **Рекурсивный случай (recursive case)** — вызов функции с изменёнными параметрами, приближающими к базовому случаю

```javascript
function factorial(n) {
    // Базовый случай
    if (n <= 1) {
        return 1;
    }
    // Рекурсивный случай
    return n * factorial(n - 1);
}
```

## Рекурсивные vs Итеративные решения

### Рекурсивные решения

**Преимущества:**
- Часто более интуитивны и проще для понимания
- Хорошо подходят для задач с рекурсивной структурой (например, деревья)

**Недостатки:**
- Потенциально высокое потребление памяти из-за стека вызовов
- Могут быть медленнее из-за накладных расходов на вызовы функций

### Итеративные решения

**Преимущества:**
- Обычно более эффективны по памяти
- Не подвержены переполнению стека

**Недостатки:**
- Могут быть сложнее для понимания в некоторых случаях

**Пример: вычисление факториала**

```javascript
// Рекурсивное решение
function factorialRecursive(n) {
    if (n <= 1) return 1;
    return n * factorialRecursive(n - 1);
}

// Итеративное решение
function factorialIterative(n) {
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

## Виды рекурсии

### Хвостовая рекурсия (Tail Recursion)

Хвостовая рекурсия — это когда рекурсивный вызов является последним действием в функции. Такие функции могут быть оптимизированы компилятором для использования постоянного объема памяти.

```javascript
function tailFactorial(n, accumulator = 1) {
    if (n <= 1) return accumulator;
    return tailFactorial(n - 1, n * accumulator); // Хвостовой вызов
}
```

**Временная сложность:** O(n)  
**Пространственная сложность:** O(1) при оптимизации хвостовой рекурсии, иначе O(n)

### Древовидная рекурсия (Tree Recursion)

Древовидная рекурсия возникает, когда функция вызывает себя более одного раза.

```javascript
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2); // Два рекурсивных вызова
}
```

**Временная сложность:** O(2^n)  
**Пространственная сложность:** O(n)

### Взаимная рекурсия (Mutual Recursion)

Две или более функций вызывают друг друга.

```javascript
function isEven(n) {
    if (n === 0) return true;
    return isOdd(n - 1);
}

function isOdd(n) {
    if (n === 0) return false;
    return isEven(n - 1);
}
```

## Рекурсивные структуры данных

Многие структуры данных определены рекурсивно:

- **Деревья:** узел содержит значение и список дочерних узлов (которые тоже деревья)
- **Списки:** элемент содержит значение и указатель на следующий элемент (который тоже список)
- **Графы:** могут содержать циклы, требующие отслеживания посещённых узлов

```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.children = [];
    }
}
```

## Общие паттерны рекурсии

### 1. Прямой обход (Pre-order)
Посещение узла перед его потомками

### 2. Центрированный обход (In-order)
Для бинарных деревьев: левый потомок, узел, правый потомок

### 3. Обратный обход (Post-order)
Посещение узла после его потомков

## Рекурсивные алгоритмы обхода

### Обход дерева

```javascript
function traverseTree(node, visit) {
    if (!node) return;
    
    visit(node.value); // Прямой обход
    
    for (const child of node.children) {
        traverseTree(child, visit);
    }
}
```

### Обход графа

```javascript
function dfs(graph, start, visited = new Set()) {
    if (visited.has(start)) return;
    
    visited.add(start);
    console.log(start);
    
    for (const neighbor of graph[start] || []) {
        dfs(graph, neighbor, visited);
    }
}
```

## Возврат с откатом (Backtracking)

Возврат с откатом — это рекурсивный алгоритм для поиска решений путём построения кандидатов и отмены выбора при обнаружении невозможности завершения.

```javascript
function solveNQueens(n) {
    const result = [];
    const board = Array(n).fill().map(() => Array(n).fill('.'));
    
    function isValid(row, col) {
        // Проверка вертикали
        for (let i = 0; i < row; i++) {
            if (board[i][col] === 'Q') return false;
        }
        
        // Проверка диагоналей
        for (let i = 0; i < row; i++) {
            for (let j = 0; j < n; j++) {
                if (board[i][j] === 'Q' && 
                    Math.abs(row - i) === Math.abs(col - j)) {
                    return false;
                }
            }
        }
        return true;
    }
    
    function backtrack(row) {
        if (row === n) {
            result.push(board.map(r => r.join('')));
            return;
        }
        
        for (let col = 0; col < n; col++) {
            if (isValid(row, col)) {
                board[row][col] = 'Q';
                backtrack(row + 1);
                board[row][col] = '.'; // откат
            }
        }
    }
    
    backtrack(0);
    return result;
}
```

## Разделяй и властвуй (Divide and Conquer)

Метод "разделяй и властвуй" использует рекурсию для разделения задачи на независимые подзадачи.

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i++]);
        } else {
            result.push(right[j++]);
        }
    }
    
    return result.concat(left.slice(i), right.slice(j));
}
```

## Мемоизированная рекурсия

Мемоизация сохраняет результаты вычислений для предотвращения повторных вычислений.

```javascript
function fibonacciMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}
```

## Временная и пространственная сложность

| Алгоритм | Временная сложность | Пространственная сложность |
|----------|---------------------|-----------------------------|
| Факториал | O(n) | O(n) |
| Фибоначчи (без мемоизации) | O(2^n) | O(n) |
| Фибоначчи (с мемоизацией) | O(n) | O(n) |
| Быстрая сортировка | O(n log n) средний, O(n²) худший | O(log n) средний, O(n) худший |
| Обход дерева | O(n) | O(h), где h — высота дерева |

## Когда использовать рекурсию

**Использовать рекурсию рекомендуется, когда:**
- Задача имеет рекурсивную структуру (например, деревья, графы)
- Решение проще выразить рекурсивно
- Размер задачи ограничен, чтобы избежать переполнения стека

**Избегать рекурсии, когда:**
- Задача может быть эффективно решена итеративно
- Риск переполнения стека высок
- Производительность критична

## Рассмотрение стека вызовов

Каждый рекурсивный вызов добавляет новый фрейм в стек вызовов. Глубокая рекурсия может привести к переполнению стека (`StackOverflowError`).

## Связи с другими концепциями

- [[data-structures]] — рекурсивные структуры данных
- [[algorithm-analysis]] — анализ сложности
- [[dynamic-programming]] — мемоизация и динамическое программирование
- [[tree-traversal]] — обход деревьев
- [[graph-algorithms]] — алгоритмы на графах

## Заключение

Рекурсия — мощный инструмент программирования, особенно полезный для работы с рекурсивными структурами данных и задачами, которые можно разбить на подзадачи аналогичной структуры. Понимание различных видов рекурсии, её преимуществ и ограничений позволяет эффективно использовать этот подход при разработке алгоритмов.