---
aliases: ["Композиция в компонентах", "Композиция UI-компонентов"]
tags: ["#frontend", "#components", "#composition", "#architecture", "#react", "#vue", "#svelte"]
---

# Композиция компонентов

## Определение

**Композиция компонентов** — это фундаментальный принцип архитектуры современных фронтенд-фреймворков, при котором сложные пользовательские интерфейсы строятся путем объединения более простых, переиспользуемых компонентов. В отличие от наследования, композиция позволяет создавать гибкие и масштабируемые архитектуры, где каждый компонент имеет четко определенную ответственность.

Композиция реализует принцип "композиция лучше наследования" (composition over inheritance), который предполагает создание сложных объектов и функций путем объединения более простых, а не через иерархии наследования.

## Принципы композиции

### 1. Компонент как строительный блок
Каждый компонент должен быть:
- **Независимым** — работать автономно
- **Переиспользуемым** — использоваться в разных контекстах
- **Предсказуемым** — иметь стабильный интерфейс
- **Тестируемым** — легко тестироваться изолированно

### 2. Принцип единственной ответственности
Каждый компонент должен отвечать за одну конкретную задачу или функциональность. Это упрощает понимание, тестирование и поддержку кода.

### 3. Иерархическая структура
Компоненты организуются в иерархию, где родительские компоненты управляют дочерними, передавая им данные и обработчики событий.

## Практические примеры

### Пример 1: Простая композиция кнопки

```jsx
// Button.jsx
import React from 'react';

const Button = ({ children, onClick, variant = 'primary', disabled = false }) => {
  const buttonClass = `btn btn-${variant} ${disabled ? 'disabled' : ''}`;
  
  return (
    <button className={buttonClass} onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
};

export default Button;
```

```jsx
// ButtonGroup.jsx
import React from 'react';
import Button from './Button';

const ButtonGroup = ({ actions }) => {
  return (
    <div className="btn-group">
      {actions.map((action, index) => (
        <Button
          key={index}
          onClick={action.handler}
          variant={action.variant}
          disabled={action.disabled}
        >
          {action.label}
        </Button>
      ))}
    </div>
  );
};

export default ButtonGroup;
```

### Пример 2: Композиция формы

```jsx
// FormField.jsx
import React from 'react';

const FormField = ({ label, children, error }) => {
  return (
    <div className="form-field">
      <label>{label}</label>
      {children}
      {error && <span className="error">{error}</span>}
    </div>
  );
};

export default FormField;
```

```jsx
// LoginForm.jsx
import React, { useState } from 'react';
import FormField from './FormField';
import Button from './Button';

const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();
    // Валидация
    const newErrors = {};
    if (!email) newErrors.email = 'Email обязателен';
    if (!password) newErrors.password = 'Пароль обязателен';
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }
    
    // Отправка формы
    console.log('Форма отправлена:', { email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <FormField label="Email" error={errors.email}>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </FormField>
      
      <FormField label="Пароль" error={errors.password}>
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
      </FormField>
      
      <Button type="submit" variant="primary">Войти</Button>
    </form>
  );
};

export default LoginForm;
```

## Преимущества композиции

1. **Повторное использование**: Компоненты могут использоваться в разных частях приложения
2. **Модульность**: Каждый компонент изолирован и может разрабатываться независимо
3. **Тестируемость**: Легко тестировать отдельные компоненты изолированно
4. **Гибкость**: Возможность легко изменять и комбинировать компоненты
5. **Поддерживаемость**: Проще вносить изменения и исправлять ошибки

## Паттерны композиции

### 1. Container/Presenter (Smart/Dumb Components)
- **Контейнерные компоненты** управляют логикой и состоянием
- **Презентационные компоненты** отвечают только за отображение

### 2. Higher-Order Components (HOC)
Функции, которые принимают компонент и возвращают новый компонент с дополнительной функциональностью:

```jsx
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <div>Загрузка...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};
```

### 3. Render Props
Паттерн, при котором компонент принимает функцию, которая определяет, что отображать:

```jsx
class DataProvider extends React.Component {
  state = { data: null };
  
  componentDidMount() {
    // Загрузка данных
  }
  
  render() {
    return this.props.render(this.state.data);
  }
}

// Использование
<DataProvider render={(data) => <MyComponent data={data} />} />
```

### 4. Compound Components
Компоненты, которые работают вместе как единое целое:

```jsx
const Tabs = ({ children, activeTab, onTabChange }) => (
  <div className="tabs">
    {React.Children.map(children, child => 
      React.cloneElement(child, { activeTab, onTabChange })
    )}
  </div>
);

const Tab = ({ id, label, activeTab, onTabChange, children }) => (
  <div style={{ display: activeTab === id ? 'block' : 'none' }}>
    <button onClick={() => onTabChange(id)}>{label}</button>
    {children}
  </div>
);
```

## Контрольные вопросы

1. В чем разница между композицией и наследованием в контексте компонентов?
2. Какие преимущества дает композиция перед наследованием?
3. Какие паттерны композиции вы знаете и когда их использовать?
4. Как обеспечить переиспользуемость компонентов?
5. Как тестировать компоненты, построенные по принципу композиции?

## См. также

- [[Агрегация компонентов]]
- [[Принципы объектно-ориентированного программирования]]
- [[Компонентный подход]]
- [[Принципы программирования]]
- [[Разделение ответственности]]

## Внешние ресурсы

- [React Documentation - Composition vs Inheritance](https://reactjs.org/docs/composition-vs-inheritance.html)
- [Vue.js Guide - Component Composition](https://vuejs.org/guide/components/composition.html)
- [Svelte Tutorial - Component Composition](https://svelte.dev/tutorial/composition)