---
aliases: [Composition, Aggregation, Композиция и Агрегация]
tags: [programming, frontend, oop, architecture]
---

# Композиция и агрегация

**Композиция и агрегация** — это два фундаментальных способа создания сложных объектов из более простых. Оба подхода относятся к отношениям "часть-целое", но имеют важные различия в смыслах и жизненных циклах компонентов.

## Основные понятия

### Композиция

**Композиция** — это отношение "владеет" или "часть-целое", при котором часть не может существовать отдельно от целого. Если целое уничтожается, то и части уничтожаются автоматически.

```javascript
// Пример композиции
class Engine {
  constructor(horsepower) {
    this.horsepower = horsepower;
    this.running = false;
  }
  
  start() {
    this.running = true;
    console.log(`Двигатель ${this.horsepower} л.с. запущен`);
  }
  
  stop() {
    this.running = false;
    console.log('Двигатель остановлен');
  }
}

class Car {
  constructor(brand, model, engine) {
    this.brand = brand;
    this.model = model;
    // Композиция: двигатель создается внутри автомобиля
    this.engine = engine || new Engine(200);
  }
  
  start() {
    console.log(`Запуск автомобиля ${this.brand} ${this.model}`);
    this.engine.start();
  }
  
  stop() {
    this.engine.stop();
    console.log(`Автомобиль ${this.brand} ${this.model} остановлен`);
  }
  
  // При уничтожении автомобиля двигатель также уничтожается
  destroy() {
    this.engine = null; // Двигатель больше не нужен
  }
}

// Использование
const myCar = new Car('Toyota', 'Camry');
myCar.start(); // Запуск автомобиля и двигателя
```

### Агрегация

**Агрегация** — это отношение "использует" или "имеет", при котором часть может существовать независимо от целого. Часть может быть использована несколькими целыми.

```javascript
// Пример агрегации
class Driver {
  constructor(name) {
    this.name = name;
  }
  
  drive(car) {
    console.log(`${this.name} управляет автомобилем ${car.brand} ${car.model}`);
  }
}

class GPS {
  constructor(provider = 'Google Maps') {
    this.provider = provider;
  }
  
  navigate(destination) {
    console.log(`Навигация к ${destination} через ${this.provider}`);
  }
}

class AdvancedCar {
  constructor(brand, model, engine, driver, gps) {
    this.brand = brand;
    this.model = model;
    this.engine = engine; // Композиция - двигатель принадлежит автомобилю
    
    // Агрегация - водитель и GPS существуют независимо
    this.driver = driver; // Водитель может управлять несколькими автомобилями
    this.gps = gps;       // GPS может использоваться в нескольких автомобилях
  }
  
  startJourney(destination) {
    this.driver.drive(this);
    this.gps.navigate(destination);
    this.engine.start();
  }
}

// Использование
const engine = new Engine(250);
const driver = new Driver('Иван');
const gps = new GPS();

const car1 = new AdvancedCar('Toyota', 'Camry', engine, driver, gps);
const car2 = new AdvancedCar('Honda', 'Civic', new Engine(180), driver, gps);

// Один водитель и один GPS используются в разных автомобилях
car1.startJourney('Москва');
car2.startJourney('Санкт-Петербург');
```

## Применение в фронтенд-разработке

### Композиция компонентов

```jsx
// Пример композиции в React
function Button({ children, onClick, variant = 'primary' }) {
  return (
    <button 
      className={`btn btn--${variant}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

function Icon({ name, size = 'medium' }) {
  return <span className={`icon icon--${name} icon--${size}`} />;
}

// Композиция: иконка как часть кнопки
function IconButton({ icon, onClick }) {
  return (
    <Button onClick={onClick} variant="icon">
      <Icon name={icon} />
    </Button>
  );
}

// Более сложная композиция
function SearchInput({ onSearch, placeholder = 'Поиск...' }) {
  const [value, setValue] = useState('');
  
  const handleSearch = () => {
    if (value.trim()) {
      onSearch(value);
    }
  };
  
  return (
    <div className="search-input">
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder={placeholder}
        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
      />
      <IconButton icon="search" onClick={handleSearch} />
    </div>
  );
}
```

### Агрегация в архитектуре приложения

```javascript
// Пример агрегации в архитектуре приложения
class UserService {
  constructor(apiClient) {
    this.apiClient = apiClient; // Агрегация - UserService использует ApiClient
  }
  
  async fetchUser(id) {
    return await this.apiClient.get(`/users/${id}`);
  }
  
  async updateUser(id, data) {
    return await this.apiClient.put(`/users/${id}`, data);
  }
}

class NotificationService {
  constructor() {
    this.notifications = [];
  }
  
  show(message, type = 'info') {
    const notification = {
      id: Date.now(),
      message,
      type,
      timestamp: new Date()
    };
    
    this.notifications.push(notification);
    return notification;
  }
}

class Logger {
  log(message, level = 'info') {
    console.log(`[${level.toUpperCase()}] ${new Date().toISOString()}: ${message}`);
  }
}

class AppController {
  constructor(userService, notificationService, logger) {
    // Агрегация - AppController использует другие сервисы
    this.userService = userService;
    this.notificationService = notificationService;
    this.logger = logger;
  }
  
  async loadUserProfile(userId) {
    try {
      this.logger.log(`Загрузка профиля пользователя ${userId}`);
      
      const user = await this.userService.fetchUser(userId);
      this.notificationService.show('Профиль загружен успешно');
      
      this.logger.log(`Профиль пользователя ${user.name} загружен`);
      return user;
    } catch (error) {
      this.notificationService.show('Ошибка загрузки профиля', 'error');
      this.logger.log(`Ошибка загрузки профиля: ${error.message}`, 'error');
      throw error;
    }
  }
}

// Использование
const apiClient = new ApiClient('https://api.example.com');
const userService = new UserService(apiClient);
const notificationService = new NotificationService();
const logger = new Logger();

const appController = new AppController(userService, notificationService, logger);
```

## Практические паттерны

### Композиция с функциональными компонентами

```jsx
// Паттерн композиции: компонент как функция от других компонентов
function createCard(Component) {
  return function Card(props) {
    return (
      <div className="card">
        <div className="card-header">
          {props.header && props.header}
        </div>
        <div className="card-body">
          <Component {...props} />
        </div>
        <div className="card-footer">
          {props.footer && props.footer}
        </div>
      </div>
    );
  };
}

// Использование
const UserCard = createCard(({ user }) => (
  <div>
    <h3>{user.name}</h3>
    <p>{user.email}</p>
  </div>
));

// Пример агрегации: компонент использует внешние сервисы
function UserProfile({ userId, userService, logger }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchUser = async () => {
      try {
        logger.log(`Загрузка пользователя ${userId}`);
        const userData = await userService.fetchUser(userId);
        setUser(userData);
      } catch (error) {
        logger.log(`Ошибка загрузки пользователя: ${error.message}`, 'error');
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId, userService, logger]);
  
  if (loading) return <div>Загрузка...</div>;
  if (!user) return <div>Пользователь не найден</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

### Композиция через контекст

```jsx
// Пример композиции через React Context
const ThemeContext = createContext();
const LanguageContext = createContext();

// Компонент, который агрегирует контексты
function App({ children }) {
  const [theme, setTheme] = useState('light');
  const [language, setLanguage] = useState('ru');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <LanguageContext.Provider value={{ language, setLanguage }}>
        {children}
      </LanguageContext.Provider>
    </ThemeContext.Provider>
  );
}

// Компонент использует внешние контексты (агрегация)
function ThemedButton({ children, onClick }) {
  const { theme } = useContext(ThemeContext);
  const { language } = useContext(LanguageContext);
  
  return (
    <button
      className={`btn btn--${theme}`}
      onClick={onClick}
      data-lang={language}
    >
      {children}
    </button>
  );
}
```

### Миксины и композиция

```javascript
// Пример композиции через миксины
const ObservableMixin = {
  initObservable() {
    this.observers = [];
  },
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  },
  
  notify(data) {
    this.observers.forEach(observer => observer(data));
  }
};

const LoggerMixin = {
  initLogger() {
    this.logLevel = 'info';
  },
  
  log(message, level = 'info') {
    if (this.shouldLog(level)) {
      console.log(`[${level.toUpperCase()}] ${new Date().toISOString()}: ${message}`);
    }
  },
  
  shouldLog(level) {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    return levels[level] >= levels[this.logLevel];
  }
};

// Композиция через функцию
function createComponent(BaseClass, ...mixins) {
  return class extends BaseClass {
    constructor(...args) {
      super(...args);
      
      // Применение миксинов
      mixins.forEach(mixin => {
        if (mixin.initObservable) mixin.initObservable.call(this);
        if (mixin.initLogger) mixin.initLogger.call(this);
      });
    }
    
    // Добавление методов миксинов
    ...mixins.reduce((methods, mixin) => ({
      ...methods,
      ...Object.getOwnPropertyNames(mixin)
        .filter(name => name !== 'initObservable' && name !== 'initLogger')
        .reduce((acc, name) => {
          acc[name] = mixin[name];
          return acc;
        }, {})
    }), {})
  };
}

// Использование
class User {
  constructor(name) {
    this.name = name;
  }
}

const ObservableUser = createComponent(User, ObservableMixin, LoggerMixin);

const user = new ObservableUser('Иван');
user.log('Пользователь создан');
```

## Преимущества и недостатки

### Преимущества композиции

```javascript
// Преимущества композиции: гибкость и повторное использование
class DataSource {
  async fetch() {
    // Логика получения данных
    return { data: 'sample' };
  }
}

class CacheDecorator {
  constructor(dataSource) {
    this.dataSource = dataSource; // Композиция
    this.cache = new Map();
  }
  
  async fetch(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const data = await this.dataSource.fetch(key);
    this.cache.set(key, data);
    return data;
  }
}

class LoggingDecorator {
  constructor(dataSource) {
    this.dataSource = dataSource; // Композиция
  }
  
  async fetch(key) {
    console.log(`Запрос данных для ${key}`);
    const data = await this.dataSource.fetch(key);
    console.log(`Получены данные для ${key}`);
    return data;
  }
}

// Гибкое комбинирование функциональности
const dataSource = new DataSource();
const cachedDataSource = new CacheDecorator(dataSource);
const loggedCachedDataSource = new LoggingDecorator(cachedDataSource);

// Можно легко изменять композицию
const loggedDataSource = new LoggingDecorator(dataSource);
```

### Преимущества агрегации

```javascript
// Преимущества агрегации: независимость и повторное использование
class ValidationService {
  validateEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
  
  validatePassword(password) {
    return password.length >= 8;
  }
}

class NotificationService {
  showSuccess(message) {
    console.log(`✓ ${message}`);
  }
  
  showError(message) {
    console.error(`✗ ${message}`);
  }
}

class AuthService {
  constructor(validationService, notificationService) {
    // Агрегация - сервисы могут использоваться в других местах
    this.validationService = validationService;
    this.notificationService = notificationService;
  }
  
  async login(credentials) {
    if (!this.validationService.validateEmail(credentials.email)) {
      this.notificationService.showError('Некорректный email');
      return false;
    }
    
    // Логика аутентификации
    try {
      // ... аутентификация
      this.notificationService.showSuccess('Успешный вход');
      return true;
    } catch (error) {
      this.notificationService.showError('Ошибка входа');
      return false;
    }
  }
}

// Эти сервисы могут использоваться в других частях приложения
const validationService = new ValidationService();
const notificationService = new NotificationService();
const authService = new AuthService(validationService, notificationService);

// Сервисы могут использоваться в других контекстах
const userService = new UserService(validationService); // Та же валидация
```

## Сравнение композиции и наследования

```jsx
// Плохо: чрезмерное наследование
class Component {
  render() {}
}

class Button extends Component {
  render() { /* рендер кнопки */ }
}

class IconButton extends Button {
  render() { /* рендер иконки + кнопки */ }
}

class LoadingIconButton extends IconButton {
  render() { /* рендер иконки + кнопки + индикатора загрузки */ }
}

// Лучше: композиция
function Button({ children, onClick, ...props }) {
  return <button onClick={onClick} {...props}>{children}</button>;
}

function Icon({ name }) {
  return <i className={`icon-${name}`} />;
}

function LoadingIndicator() {
  return <span className="loading">...</span>;
}

// Композиция позволяет гибко комбинировать компоненты
function IconButton({ icon, onClick }) {
  return (
    <Button onClick={onClick}>
      <Icon name={icon} />
    </Button>
  );
}

function LoadingIconButton({ icon, loading, onClick }) {
  return (
    <Button onClick={onClick}>
      {loading ? <LoadingIndicator /> : <Icon name={icon} />}
    </Button>
  );
}
```

## Связанные концепции

- [[Объектно-ориентированное программирование]] - основа для понимания отношений между объектами
- [[Компонентный-подход]] - композиция как основа компонентной архитектуры
- [[Модульность]] - модули как агрегаты функциональности
- [[Абстракция]] - абстракции как основа для композиции
- [[Функциональное программирование]] - композиция функций

## Лучшие практики

1. **Предпочитайте композицию наследованию** - создает более гибкие и поддерживаемые системы
2. **Используйте агрегацию для слабой связанности** - позволяет повторно использовать компоненты
3. **Ясно определите границы владения** - понимайте, кто отвечает за жизненный цикл объектов
4. **Документируйте отношения** - используйте комментарии для описания композиции и агрегации
5. **Используйте внедрение зависимостей** - для управления агрегациями
6. **Избегайте циклических зависимостей** - они нарушают принципы композиции

## Заключение

Композиция и агрегация являются ключевыми принципами объектно-ориентированного и компонентного программирования. Правильное использование этих паттернов позволяет создавать более гибкие, тестируемые и поддерживаемые приложения. В фронтенд-разработке эти концепции особенно важны для построения масштабируемых архитектур и компонентных систем.