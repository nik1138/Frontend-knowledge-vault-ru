---
aliases: ["Агрегация в компонентах", "Агрегация UI-компонентов"]
tags: ["#frontend", "#components", "#aggregation", "#architecture", "#react", "#vue", "#svelte"]
---

# Агрегация компонентов

## Определение

**Агрегация компонентов** — это паттерн архитектуры, при котором компоненты объединяются в более сложные структуры, при этом сохраняя относительную независимость друг от друга. В отличие от композиции, где компоненты создаются внутри родителя, при агрегации компоненты существуют независимо и объединяются внешним контейнером.

Агрегация позволяет создавать сложные интерфейсы, при этом каждый компонент сохраняет свою автономию и может использоваться независимо.

## Принципы агрегации

### 1. Независимость компонентов
Каждый агрегируемый компонент:
- Имеет собственное состояние и жизненный цикл
- Может существовать без родителя
- Не зависит от других компонентов в агрегации

### 2. Слабая связанность
Компоненты связаны минимально, через четко определенные интерфейсы общения.

### 3. Внешнее управление
Контейнер управляет взаимодействием между компонентами, но не контролирует их внутреннюю реализацию.

## Практические примеры

### Пример 1: Агрегация независимых компонентов

```jsx
// UserProfile.jsx
import React, { useState } from 'react';
import UserAvatar from './UserAvatar';
import UserInfo from './UserInfo';
import UserStats from './UserStats';

const UserProfile = ({ userId }) => {
  // Состояние, общее для всех компонентов
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Загрузка данных пользователя
  React.useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <div>Загрузка профиля...</div>;

  return (
    <div className="user-profile">
      <UserAvatar user={user} />
      <UserInfo user={user} />
      <UserStats userId={userId} />
    </div>
  );
};

// UserAvatar.jsx
const UserAvatar = ({ user }) => {
  return (
    <div className="user-avatar">
      <img src={user.avatar} alt={`${user.name}'s avatar`} />
    </div>
  );
};

// UserInfo.jsx
const UserInfo = ({ user }) => {
  return (
    <div className="user-info">
      <h2>{user.name}</h2>
      <p>{user.bio}</p>
    </div>
  );
};

// UserStats.jsx
const UserStats = ({ userId }) => {
  const [stats, setStats] = useState(null);

  React.useEffect(() => {
    fetchUserStats(userId).then(setStats);
  }, [userId]);

  if (!stats) return null;

  return (
    <div className="user-stats">
      <span>Постов: {stats.posts}</span>
      <span>Подписчиков: {stats.followers}</span>
    </div>
  );
};
```

### Пример 2: Агрегация с общим контекстом

```jsx
// Dashboard.jsx
import React, { useState, createContext } from 'react';
import { ChartWidget } from './ChartWidget';
import { DataGrid } from './DataGrid';
import { FilterPanel } from './FilterPanel';

// Контекст для общего состояния
export const DashboardContext = createContext();

const Dashboard = () => {
  const [filters, setFilters] = useState({ dateRange: 'week', metric: 'revenue' });
  const [data, setData] = useState([]);

  // Обновление данных при изменении фильтров
  React.useEffect(() => {
    fetchData(filters).then(setData);
  }, [filters]);

  const contextValue = {
    filters,
    setFilters,
    data,
    refreshData: () => fetchData(filters).then(setData)
  };

  return (
    <DashboardContext.Provider value={contextValue}>
      <div className="dashboard">
        <header>
          <h1>Аналитическая панель</h1>
        </header>
        <main>
          <FilterPanel />
          <ChartWidget />
          <DataGrid />
        </main>
      </div>
    </DashboardContext.Provider>
  );
};
```

### Пример 3: Агрегация с событийной системой

```jsx
// EventSystem.js
class EventBus {
  constructor() {
    this.events = {};
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  unsubscribe(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

export const eventBus = new EventBus();

// NotificationPanel.jsx
import { useEffect, useState } from 'react';
import { eventBus } from './EventSystem';

const NotificationPanel = () => {
  const [notifications, setNotifications] = useState([]);

  useEffect(() => {
    const handleNotification = (notification) => {
      setNotifications(prev => [...prev, { ...notification, id: Date.now() }]);
    };

    eventBus.subscribe('notification', handleNotification);

    return () => {
      eventBus.unsubscribe('notification', handleNotification);
    };
  }, []);

  return (
    <div className="notification-panel">
      {notifications.map(notification => (
        <div key={notification.id} className={`notification ${notification.type}`}>
          {notification.message}
        </div>
      ))}
    </div>
  );
};

// ActionButton.jsx
import { eventBus } from './EventSystem';

const ActionButton = ({ action, message }) => {
  const handleClick = () => {
    // Выполнение действия
    performAction(action);
    
    // Уведомление других компонентов
    eventBus.emit('notification', {
      type: 'success',
      message: `Действие "${message}" выполнено`
    });
  };

  return <button onClick={handleClick}>{message}</button>;
};
```

## Преимущества агрегации

1. **Независимость компонентов**: Каждый компонент может существовать и функционировать независимо
2. **Повторное использование**: Компоненты могут использоваться в разных агрегациях
3. **Гибкость**: Возможность легко изменять состав агрегации
4. **Тестируемость**: Каждый компонент можно тестировать изолированно
5. **Масштабируемость**: Легко добавлять новые компоненты в агрегацию

## Недостатки агрегации

1. **Сложность коммуникации**: Взаимодействие между компонентами может быть сложнее
2. **Управление состоянием**: Требуется дополнительная логика для синхронизации состояния
3. **Производительность**: Могут возникнуть проблемы с производительностью при сложных взаимодействиях

## Паттерны агрегации

### 1. Контейнер-компонент
Компонент, который управляет взаимодействием между другими компонентами:

```jsx
const ContainerComponent = () => {
  const [sharedState, setSharedState] = useState({});
  
  return (
    <div>
      <ComponentA state={sharedState} setState={setSharedState} />
      <ComponentB state={sharedState} setState={setSharedState} />
    </div>
  );
};
```

### 2. Публикация-подписка
Компоненты взаимодействуют через систему событий:

```jsx
// Publisher Component
const Publisher = () => {
  const publishData = (data) => {
    eventBus.emit('dataUpdate', data);
  };
  
  return <button onClick={() => publishData({ value: 'new data' })}>Publish</button>;
};

// Subscriber Component
const Subscriber = () => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    const handler = (receivedData) => setData(receivedData);
    eventBus.subscribe('dataUpdate', handler);
    
    return () => eventBus.unsubscribe('dataUpdate', handler);
  }, []);
  
  return <div>{data ? JSON.stringify(data) : 'No data'}</div>;
};
```

### 3. Общий контекст
Использование контекста для обмена данными между компонентами:

```jsx
// Context
const DataContext = createContext();

// Provider Component
const DataProvider = ({ children }) => {
  const [data, setData] = useState([]);
  
  return (
    <DataContext.Provider value={{ data, setData }}>
      {children}
    </DataContext.Provider>
  );
};

// Consumer Component
const DataConsumer = () => {
  const { data, setData } = useContext(DataContext);
  
  return <div>{/* Использование данных */}</div>;
};
```

## Сравнение с композицией

| Характеристика | Композиция | Агрегация |
|---|---|---|
| Зависимость компонентов | Высокая (внутренние компоненты зависят от родителя) | Низкая (компоненты автономны) |
| Жизненный цикл | Внутренние компоненты управляются родителем | Каждый компонент управляет своим жизненным циклом |
| Переиспользование | В пределах композиции | Вне зависимости от контекста |
| Сложность взаимодействия | Простая (props) | Более сложная (события, контекст) |

## Контрольные вопросы

1. В чем разница между композицией и агрегацией компонентов?
2. Когда лучше использовать агрегацию вместо композиции?
3. Какие паттерны взаимодействия между агрегированными компонентами вы знаете?
4. Как обеспечить слабую связанность между компонентами в агрегации?
5. Какие проблемы могут возникнуть при агрегации компонентов?

## См. также

- [[Композиция компонентов]]
- [[Принципы объектно-ориентированного программирования]]
- [[Компонентный подход]]
- [[Разделение ответственности]]
- [[Слабая связанность]]

## Внешние ресурсы

- [React Documentation - Lifting State Up](https://reactjs.org/docs/lifting-state-up.html)
- [Vue.js Guide - Communication Between Components](https://vuejs.org/guide/components/communication.html)
- [Svelte Tutorial - Component Communication](https://svelte.dev/tutorial/component-composition)