---
aliases: [Паттерн Фасад, Фасад, Структурные паттерны, Упрощение API]
tags: [frontend, design-patterns, facade, architecture, api, abstraction]
---

# Паттерн Фасад в фронтенд-разработке

## Обзор

Паттерн Фасад (Facade) - это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотек или фреймворков. В контексте фронтенд-разработки фасад используется для упрощения взаимодействия с комплексными API, системами управления состоянием, сетевыми запросами и другими сложными подсистемами.

## Основные принципы паттерна Фасад

### 1. Скрытие сложности

```javascript
// Сложная система без фасада
class PaymentProcessor {
    constructor() {
        this.validator = new PaymentValidator();
        this.gateway = new PaymentGateway();
        this.logger = new PaymentLogger();
        this.notifier = new PaymentNotifier();
    }
    
    async processPayment(cardDetails, amount) {
        // Много шагов, которые нужно знать пользователю
        const isValid = this.validator.validateCard(cardDetails);
        if (!isValid) {
            throw new Error('Неверные данные карты');
        }
        
        const transactionId = await this.gateway.createTransaction(cardDetails, amount);
        this.logger.logTransaction(transactionId, amount);
        
        const result = await this.gateway.processPayment(transactionId);
        this.notifier.sendNotification(result);
        
        return result;
    }
}

// Система с фасадом
class PaymentFacade {
    constructor() {
        this.paymentSystem = new ComplexPaymentSystem();
    }
    
    async makePayment(cardDetails, amount) {
        try {
            // Единая точка входа для всей сложности
            return await this.paymentSystem.processSecurePayment(cardDetails, amount);
        } catch (error) {
            // Единая обработка ошибок
            console.error('Ошибка оплаты:', error.message);
            throw error;
        }
    }
}

// Использование становится проще
const paymentFacade = new PaymentFacade();
paymentFacade.makePayment(cardDetails, 1000);
```

### 2. Простой интерфейс для сложной системы

```javascript
// Комплексная система работы с изображениями
class ImageProcessingSystem {
    constructor() {
        this.loader = new ImageLoader();
        this.resizer = new ImageResizer();
        this.compressor = new ImageCompressor();
        this.optimizer = new ImageOptimizer();
        this.cache = new ImageCache();
        this.validator = new ImageValidator();
    }
    
    async processImage(file, options) {
        // Сложная цепочка операций
        const imageData = await this.loader.load(file);
        const validated = this.validator.validate(imageData);
        const resized = this.resizer.resize(imageData, options.dimensions);
        const optimized = this.optimizer.optimize(resized);
        const compressed = this.compressor.compress(optimized, options.quality);
        const cached = this.cache.store(compressed);
        
        return cached;
    }
}

// Фасад для упрощения
class ImageFacade {
    constructor() {
        this.system = new ImageProcessingSystem();
    }
    
    // Простой метод для типичного использования
    async uploadAndProcess(imageFile, quality = 0.8) {
        const options = {
            dimensions: { width: 800, height: 600 },
            quality: quality
        };
        
        return await this.system.processImage(imageFile, options);
    }
    
    // Альтернативный метод для продвинутого использования
    async processWithCustomOptions(imageFile, customOptions) {
        return await this.system.processImage(imageFile, customOptions);
    }
}
```

## Практические примеры использования

### 1. Фасад для работы с API

```javascript
// Фасад для API клиента
class APIClientFacade {
    constructor(baseURL, defaultHeaders = {}) {
        this.baseURL = baseURL;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            ...defaultHeaders
        };
        this.interceptors = {
            request: [],
            response: []
        };
    }
    
    // Унифицированный метод для всех HTTP-запросов
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        const config = this.buildRequestConfig(options);
        
        // Применение request-интерсепторов
        let processedConfig = { ...config };
        for (const interceptor of this.interceptors.request) {
            processedConfig = await interceptor(processedConfig);
        }
        
        try {
            const response = await fetch(url, processedConfig);
            
            // Применение response-интерсепторов
            let processedResponse = response;
            for (const interceptor of this.interceptors.response) {
                processedResponse = await interceptor(processedResponse);
            }
            
            return await this.handleResponse(processedResponse);
        } catch (error) {
            throw this.handleError(error);
        }
    }
    
    // Методы для различных HTTP-методов
    get(endpoint, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const url = queryString ? `${endpoint}?${queryString}` : endpoint;
        return this.request(url, { method: 'GET' });
    }
    
    post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    delete(endpoint) {
        return this.request(endpoint, { method: 'DELETE' });
    }
    
    // Методы для работы с конкретными сущностями
    users = {
        getAll: () => this.get('/users'),
        getById: (id) => this.get(`/users/${id}`),
        create: (userData) => this.post('/users', userData),
        update: (id, userData) => this.put(`/users/${id}`, userData),
        delete: (id) => this.delete(`/users/${id}`)
    };
    
    posts = {
        getAll: () => this.get('/posts'),
        getByUserId: (userId) => this.get(`/posts?userId=${userId}`),
        create: (postData) => this.post('/posts', postData)
    };
    
    // Внутренние вспомогательные методы
    buildRequestConfig(options) {
        return {
            method: options.method || 'GET',
            headers: {
                ...this.defaultHeaders,
                ...options.headers
            },
            body: options.body
        };
    }
    
    async handleResponse(response) {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return await response.json();
        }
        
        return await response.text();
    }
    
    handleError(error) {
        console.error('API Error:', error);
        return error;
    }
    
    // Методы для работы с интерсепторами
    addRequestInterceptor(interceptor) {
        this.interceptors.request.push(interceptor);
    }
    
    addResponseInterceptor(interceptor) {
        this.interceptors.response.push(interceptor);
    }
}

// Использование
const api = new APIClientFacade('https://api.example.com', {
    'Authorization': 'Bearer token123'
});

// Простое использование
const users = await api.users.getAll();
const newUser = await api.users.create({ name: 'Иван', email: 'ivan@example.com' });

// Или через универсальный метод
const userData = await api.request('/users/123', { method: 'GET' });
```

### 2. Фасад для управления состоянием

```javascript
// Комплексная система управления состоянием
class StateManagementSystem {
    constructor() {
        this.store = new Store();
        this.middleware = new MiddlewareManager();
        this.devTools = new DevTools();
        this.persistor = new StatePersistor();
        this.subscriber = new StateSubscriber();
    }
    
    // Многошаговый процесс обновления состояния
    dispatch(action) {
        const processedAction = this.middleware.process(action);
        const newState = this.store.update(processedAction);
        this.devTools.log(action, newState);
        this.persistor.save(newState);
        this.subscriber.notify(newState);
        return newState;
    }
    
    subscribe(listener) {
        return this.subscriber.add(listener);
    }
    
    getState() {
        return this.store.get();
    }
}

// Фасад для упрощения работы с состоянием
class StateFacade {
    constructor(initialState = {}) {
        this.system = new StateManagementSystem();
        this.system.store.set(initialState);
        this.setupDefaultMiddleware();
    }
    
    // Простой метод для обновления состояния
    update(updates) {
        if (typeof updates === 'function') {
            // Если передана функция, вызываем её с текущим состоянием
            const newState = updates(this.getState());
            this.dispatch({ type: 'UPDATE_STATE', payload: newState });
        } else {
            // Если передан объект, объединяем с текущим состоянием
            this.dispatch({ 
                type: 'PARTIAL_UPDATE', 
                payload: updates 
            });
        }
    }
    
    // Упрощённый метод для получения состояния
    get(path) {
        const state = this.getState();
        if (!path) return state;
        
        return path.split('.').reduce((obj, key) => obj?.[key], state);
    }
    
    // Упрощённый метод для подписки
    onChange(callback, path = null) {
        return this.subscribe((newState) => {
            if (path) {
                const currentValue = this.get(path);
                const newValue = path.split('.').reduce((obj, key) => obj?.[key], newState);
                
                if (currentValue !== newValue) {
                    callback(newValue, currentValue);
                }
            } else {
                callback(newState);
            }
        });
    }
    
    // Методы для типичных операций
    async loadFromAPI(apiCall) {
        try {
            const data = await apiCall();
            this.update({ data, loading: false, error: null });
            return data;
        } catch (error) {
            this.update({ loading: false, error: error.message });
            throw error;
        }
    }
    
    // Внутренние методы (для внутреннего использования фасада)
    dispatch(action) {
        return this.system.dispatch(action);
    }
    
    getState() {
        return this.system.getState();
    }
    
    subscribe(listener) {
        return this.system.subscribe(listener);
    }
    
    setupDefaultMiddleware() {
        // Установка стандартных middleware
        this.system.middleware.add(this.loggerMiddleware);
        this.system.middleware.add(this.asyncMiddleware);
    }
    
    loggerMiddleware = (action) => {
        console.log('Action:', action.type, action.payload);
        return action;
    };
    
    asyncMiddleware = async (action) => {
        if (typeof action.payload === 'function') {
            action.payload = await action.payload();
        }
        return action;
    };
}

// Использование
const state = new StateFacade({ user: null, loading: false });

// Простое обновление
state.update({ loading: true });

// Обновление с функцией
state.update(prevState => ({
    ...prevState,
    user: { name: 'Иван', id: 1 }
}));

// Подписка на изменения
const unsubscribe = state.onChange((newUser) => {
    console.log('Пользователь обновлён:', newUser);
}, 'user');

// Загрузка данных из API
state.loadFromAPI(() => fetch('/api/user').then(r => r.json()));
```

### 3. Фасад для работы с localStorage

```javascript
// Фасад для работы с локальным хранилищем
class StorageFacade {
    constructor(namespace = 'app') {
        this.namespace = namespace;
        this.encryption = new StorageEncryption();
        this.validator = new StorageValidator();
        this.migrator = new StorageMigrator();
    }
    
    // Основные методы для работы с данными
    set(key, value, options = {}) {
        const namespacedKey = this.getNamespacedKey(key);
        const processedValue = this.processValue(value, options);
        
        try {
            const serializedValue = JSON.stringify(processedValue);
            localStorage.setItem(namespacedKey, serializedValue);
            
            // Установка времени жизни, если указано
            if (options.ttl) {
                const expiry = Date.now() + (options.ttl * 1000);
                localStorage.setItem(`${namespacedKey}_expiry`, expiry.toString());
            }
        } catch (error) {
            console.error('Ошибка сохранения в localStorage:', error);
            throw error;
        }
    }
    
    get(key, defaultValue = null) {
        const namespacedKey = this.getNamespacedKey(key);
        
        // Проверка срока действия
        if (this.isExpired(namespacedKey)) {
            this.remove(key);
            return defaultValue;
        }
        
        try {
            const serializedValue = localStorage.getItem(namespacedKey);
            if (serializedValue === null) {
                return defaultValue;
            }
            
            const value = JSON.parse(serializedValue);
            return this.restoreValue(value);
        } catch (error) {
            console.error('Ошибка чтения из localStorage:', error);
            return defaultValue;
        }
    }
    
    remove(key) {
        const namespacedKey = this.getNamespacedKey(key);
        localStorage.removeItem(namespacedKey);
        localStorage.removeItem(`${namespacedKey}_expiry`);
    }
    
    clear() {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith(this.namespace)) {
                localStorage.removeItem(key);
            }
        });
    }
    
    // Методы для работы с объектами и массивами
    setObject(key, obj) {
        this.set(key, obj, { type: 'object' });
    }
    
    getObject(key, defaultValue = {}) {
        return this.get(key, defaultValue);
    }
    
    setArray(key, arr) {
        this.set(key, arr, { type: 'array' });
    }
    
    getArray(key, defaultValue = []) {
        return this.get(key, defaultValue);
    }
    
    // Методы для работы с зашифрованными данными
    setSecure(key, value) {
        this.set(key, value, { secure: true });
    }
    
    getSecure(key, defaultValue = null) {
        return this.get(key, defaultValue);
    }
    
    // Методы для работы с версионированными данными
    setVersioned(key, value, version) {
        this.set(key, {
            data: value,
            version: version,
            timestamp: Date.now()
        }, { versioned: true });
    }
    
    getVersioned(key, minVersion = 0) {
        const stored = this.get(key);
        if (!stored || !stored.version) {
            return null;
        }
        
        if (stored.version < minVersion) {
            this.remove(key);
            return null;
        }
        
        return stored.data;
    }
    
    // Внутренние вспомогательные методы
    getNamespacedKey(key) {
        return `${this.namespace}:${key}`;
    }
    
    processValue(value, options) {
        let processedValue = value;
        
        // Валидация
        if (options.validate) {
            processedValue = this.validator.validate(processedValue, options.validate);
        }
        
        // Шифрование
        if (options.secure) {
            processedValue = this.encryption.encrypt(processedValue);
        }
        
        return processedValue;
    }
    
    restoreValue(value) {
        // Если значение зашифровано
        if (value && value.encrypted) {
            return this.encryption.decrypt(value);
        }
        
        return value;
    }
    
    isExpired(key) {
        const expiryKey = `${key}_expiry`;
        const expiry = localStorage.getItem(expiryKey);
        
        if (!expiry) return false;
        
        return Date.now() > parseInt(expiry);
    }
}

// Использование
const storage = new StorageFacade('myapp');

// Простое сохранение и чтение
storage.set('user', { name: 'Иван', id: 123 });
const user = storage.get('user');

// Сохранение с TTL (время жизни 1 час)
storage.set('session', { token: 'abc123' }, { ttl: 3600 });

// Сохранение зашифрованных данных
storage.setSecure('sensitive', { creditCard: '1234-5678-9012-3456' });

// Работа с объектами
storage.setObject('settings', { theme: 'dark', lang: 'ru' });
const settings = storage.getObject('settings');
```

## Продвинутые паттерны с фасадом

### 1. Фасад с плагинами

```javascript
// Базовый фасад с поддержкой плагинов
class PluginFacade {
    constructor() {
        this.plugins = new Map();
        this.middleware = [];
        this.hooks = new Map();
    }
    
    // Регистрация плагина
    registerPlugin(name, plugin) {
        if (this.plugins.has(name)) {
            console.warn(`Плагин ${name} уже зарегистрирован`);
        }
        
        this.plugins.set(name, plugin);
        
        // Если у плагина есть метод инициализации
        if (plugin.init) {
            plugin.init(this);
        }
        
        // Регистрация middleware
        if (plugin.middleware) {
            this.middleware.push(...plugin.middleware);
        }
        
        // Регистрация хуков
        if (plugin.hooks) {
            Object.entries(plugin.hooks).forEach(([hookName, handler]) => {
                if (!this.hooks.has(hookName)) {
                    this.hooks.set(hookName, []);
                }
                this.hooks.get(hookName).push(handler);
            });
        }
        
        return this;
    }
    
    // Вызов хука
    async callHook(hookName, data) {
        const hooks = this.hooks.get(hookName) || [];
        let result = data;
        
        for (const hook of hooks) {
            result = await hook(result);
        }
        
        return result;
    }
    
    // Применение middleware
    async applyMiddleware(data, context) {
        let result = data;
        
        for (const middleware of this.middleware) {
            result = await middleware(result, context);
        }
        
        return result;
    }
    
    // Получение плагина
    getPlugin(name) {
        return this.plugins.get(name);
    }
    
    // Вызов метода плагина
    async callPluginMethod(pluginName, methodName, ...args) {
        const plugin = this.getPlugin(pluginName);
        if (!plugin) {
            throw new Error(`Плагин ${pluginName} не найден`);
        }
        
        if (typeof plugin[methodName] !== 'function') {
            throw new Error(`Метод ${methodName} не найден в плагине ${pluginName}`);
        }
        
        return await plugin[methodName](...args);
    }
}

// Пример плагина для валидации
const validationPlugin = {
    name: 'validation',
    
    init(facade) {
        facade.validate = this.validate.bind(this);
    },
    
    validate(data, rules) {
        const errors = [];
        
        for (const [field, fieldRules] of Object.entries(rules)) {
            const value = data[field];
            
            for (const rule of fieldRules) {
                if (!rule.test(value)) {
                    errors.push({
                        field,
                        message: rule.message
                    });
                }
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }
};

// Пример плагина для логирования
const loggingPlugin = {
    name: 'logging',
    
    hooks: {
        'before-request': async (data) => {
            console.log('Запрос:', data);
            return data;
        },
        'after-response': async (response) => {
            console.log('Ответ:', response);
            return response;
        }
    }
};

// Использование
const facade = new PluginFacade();
facade.registerPlugin('validation', validationPlugin);
facade.registerPlugin('logging', loggingPlugin);

// Использование валидации
const result = facade.validate(
    { email: 'invalid-email' },
    { email: [{ test: (v) => /\S+@\S+\.\S+/.test(v), message: 'Неверный email' }] }
);
```

### 2. Асинхронный фасад

```javascript
// Фасад для асинхронных операций
class AsyncFacade {
    constructor() {
        this.queue = [];
        this.isProcessing = false;
        this.concurrency = 3; // Максимум 3 одновременные операции
        this.retryAttempts = 3;
        this.retryDelay = 1000;
    }
    
    // Добавление задачи в очередь
    async enqueue(task, priority = 0) {
        return new Promise((resolve, reject) => {
            this.queue.push({
                task,
                priority,
                resolve,
                reject,
                attempts: 0
            });
            
            this.processQueue();
        });
    }
    
    // Обработка очереди
    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) {
            return;
        }
        
        this.isProcessing = true;
        
        // Сортировка по приоритету
        this.queue.sort((a, b) => b.priority - a.priority);
        
        const tasksToProcess = this.queue.splice(0, this.concurrency);
        
        const promises = tasksToProcess.map(job => this.executeJob(job));
        await Promise.allSettled(promises);
        
        this.isProcessing = false;
        
        // Продолжаем обработку оставшихся задач
        if (this.queue.length > 0) {
            setTimeout(() => this.processQueue(), 0);
        }
    }
    
    // Выполнение отдельной задачи
    async executeJob(job) {
        try {
            const result = await this.withRetry(job.task, job.attempts);
            job.resolve(result);
        } catch (error) {
            if (job.attempts < this.retryAttempts) {
                // Повторная попытка
                job.attempts++;
                this.queue.unshift(job); // Возвращаем в начало очереди
            } else {
                job.reject(error);
            }
        }
    }
    
    // Выполнение задачи с повторными попытками
    async withRetry(task, attempts) {
        let lastError;
        
        for (let i = 0; i <= this.retryAttempts; i++) {
            try {
                return await task();
            } catch (error) {
                lastError = error;
                
                if (i < this.retryAttempts) {
                    await this.delay(this.retryDelay * Math.pow(2, i)); // Экспоненциальная задержка
                }
            }
        }
        
        throw lastError;
    }
    
    // Методы для конкретных асинхронных операций
    async fetchData(url, options = {}) {
        return this.enqueue(async () => {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return await response.json();
        }, 1); // Приоритет 1
    }
    
    async saveData(url, data) {
        return this.enqueue(async () => {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await response.json();
        }, 2); // Приоритет 2
    }
    
    // Пакетная обработка
    async batchProcess(items, processor, options = {}) {
        const { concurrency = 5, onProgress } = options;
        this.concurrency = concurrency;
        
        const results = [];
        let completed = 0;
        
        for (const item of items) {
            try {
                const result = await this.enqueue(() => processor(item));
                results.push(result);
                completed++;
                
                if (onProgress) {
                    onProgress(completed, items.length);
                }
            } catch (error) {
                results.push({ error: error.message, item });
                completed++;
                
                if (onProgress) {
                    onProgress(completed, items.length);
                }
            }
        }
        
        return results;
    }
    
    // Внутренние вспомогательные методы
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Использование
const asyncFacade = new AsyncFacade();

// Загрузка данных
const userData = await asyncFacade.fetchData('/api/user/123');

// Пакетная обработка
const items = Array.from({ length: 100 }, (_, i) => ({ id: i, name: `Item ${i}` }));
const results = await asyncFacade.batchProcess(
    items,
    async (item) => {
        // Имитация обработки
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));
        return { ...item, processed: true };
    },
    {
        onProgress: (completed, total) => {
            console.log(`Обработано: ${completed}/${total}`);
        }
    }
);
```

## Лучшие практики использования фасада

### 1. Правильная абстракция

```javascript
// ПЛОХО: Фасад делает слишком много и нарушает принцип единственной ответственности
class BadFacade {
    constructor() {
        this.http = new HTTPClient();
        this.cache = new Cache();
        this.db = new Database();
        this.auth = new AuthService();
        this.validation = new Validator();
        this.logging = new Logger();
        this.notifications = new NotificationService();
        // ... и т.д.
    }
    
    doEverything(userData, action) {
        // Слишком много логики в одном методе
        this.auth.checkAuth();
        this.validation.validate(userData);
        this.logging.logAction(action);
        const cached = this.cache.get(userData.id);
        if (!cached) {
            const result = this.db.query(action);
            this.cache.set(userData.id, result);
            this.notifications.send('data_updated');
            return result;
        }
        return cached;
    }
}

// ХОРОШО: Фасад с четким назначением
class UserServiceFacade {
    constructor() {
        this.auth = new AuthService();
        this.validator = new UserValidator();
        this.repository = new UserRepository();
        this.notifier = new UserNotifier();
    }
    
    async createUser(userData) {
        // Только операции, связанные с пользователями
        this.validator.validate(userData);
        const user = await this.repository.create(userData);
        this.notifier.notifyUserCreated(user);
        return user;
    }
    
    async updateUser(userId, updates) {
        const user = await this.repository.findById(userId);
        this.validator.validate(updates, 'update');
        await this.repository.update(userId, updates);
        this.notifier.notifyUserUpdated(user, updates);
        return user;
    }
}
```

### 2. Обработка ошибок

```javascript
// Фасад с надежной обработкой ошибок
class RobustFacade {
    constructor() {
        this.subsystem = new ComplexSubsystem();
        this.fallback = new FallbackSystem();
        this.circuitBreaker = new CircuitBreaker();
    }
    
    async performOperation(data) {
        try {
            // Проверка состояния системы
            if (this.circuitBreaker.isOpen()) {
                console.warn('Circuit breaker is open, using fallback');
                return await this.fallback.handle(data);
            }
            
            // Основная операция
            return await this.subsystem.process(data);
        } catch (error) {
            // Логирование ошибки
            this.logError(error, data);
            
            // Попытка использовать резервную систему
            try {
                const fallbackResult = await this.fallback.handle(data, error);
                this.circuitBreaker.recordFailure();
                return fallbackResult;
            } catch (fallbackError) {
                this.circuitBreaker.recordFailure();
                throw new Error(`Main system failed: ${error.message}. Fallback also failed: ${fallbackError.message}`);
            }
        }
    }
    
    logError(error, data) {
        console.error('Facade error:', {
            error: error.message,
            data: data,
            timestamp: new Date().toISOString()
        });
    }
}
```

> [!tip] Используйте фасады для упрощения сложных подсистем
> Фасад особенно полезен, когда вы работаете с внешними библиотеками или сложными системами, которые имеют многоуровневый API. Фасад позволяет создать более простой и понятный интерфейс для конкретных задач вашего приложения.

## Сравнение с другими паттернами

### Фасад vs Прокси
- **Фасад** упрощает сложный интерфейс
- **Прокси** контролирует доступ к объекту

### Фасад vs Адаптер
- **Фасад** создает более простой интерфейс для существующей системы
- **Адаптер** изменяет интерфейс для совместимости

## Связанные концепции

- [[Структурные-паттерны]] - другие структурные паттерны проектирования
- [[Архитектурные-стили]] - как фасад вписывается в архитектуру приложения
- [[Инверсия-зависимостей]] - принцип, который поддерживает фасад
- [[Композиция]] - создание фасадов через композицию
- [[API-дизайн]] - проектирование удобных интерфейсов
- [[Модульность]] - организация кода через фасады