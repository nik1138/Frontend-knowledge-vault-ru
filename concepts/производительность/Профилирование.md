---
aliases: [Профилирование, Performance Profiling, Аудит производительности]
tags: [frontend, performance, profiling, optimization, debugging]
---

# Профилирование

## Введение

Профилирование - это процесс измерения производительности приложения с целью выявления узких мест и оптимизации. В контексте веб-разработки профилирование помогает понять, какие части кода потребляют больше всего ресурсов и времени.

## Инструменты профилирования

### Chrome DevTools

Chrome DevTools предоставляет мощные инструменты для профилирования производительности:

#### Performance (Профилировщик)

```javascript
// Пример использования Performance API для измерения производительности
function measureFunctionPerformance() {
    performance.mark('function-start');
    
    // Код, производительность которого нужно измерить
    expensiveOperation();
    
    performance.mark('function-end');
    performance.measure('function-duration', 'function-start', 'function-end');
    
    // Получение результатов
    const measures = performance.getEntriesByName('function-duration');
    console.log('Время выполнения:', measures[0].duration, 'мс');
}

function expensiveOperation() {
    // Симуляция дорогостоящей операции
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
        result += Math.random();
    }
    return result;
}
```

#### Memory (Профилировщик памяти)

Для анализа утечек памяти и потребления памяти приложением:
- Heap Snapshot - снимок кучи для анализа объектов
- Allocation Timeline - отслеживание выделения памяти во времени
- Allocation Profiler - профилирование выделения памяти

#### Network (Сетевой профилировщик)

Для анализа сетевых запросов:
- Время загрузки ресурсов
- Размеры файлов
- HTTP-заголовки
- Время ожидания и передачи данных

### Lighthouse

Lighthouse - это инструмент автоматического аудита веб-страниц:

```javascript
// Пример настройки Lighthouse для CI/CD
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouse(url) {
    const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
    const options = {logLevel: 'info', output: 'html', onlyCategories: ['performance']};
    const runnerResult = await lighthouse(url, options);

    // `.report` - это HTML отчет
    console.log('Report is done for', runnerResult.lhr.finalUrl);
    console.log('Performance score was', runnerResult.lhr.categories.performance.score * 100);

    await chrome.kill();
}
```

## Типы профилирования

### CPU-профилирование

Анализ использования процессора:

```javascript
// Измерение загрузки CPU с помощью PerformanceObserver
const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log('Длительность задачи:', entry.duration, 'мс');
        console.log('Начало задачи:', entry.startTime, 'мс');
    }
});

observer.observe({entryTypes: ['measure', 'navigation', 'resource']});
```

### Memory-профилирование

Анализ использования памяти:

```javascript
// Отслеживание утечек памяти
function detectMemoryLeaks() {
    const initialMemory = performance.memory;
    console.log('Память до:', initialMemory);

    // Выполнение операций
    performOperations();

    // Через некоторое время
    setTimeout(() => {
        const finalMemory = performance.memory;
        console.log('Память после:', finalMemory);
        
        const diff = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize;
        console.log('Использовано дополнительно:', diff, 'байт');
    }, 5000);
}
```

### Network-профилирование

Анализ сетевых запросов:

```javascript
// Отслеживание сетевых запросов
function trackNetworkRequests() {
    const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
            console.log('Запрос:', entry.name);
            console.log('Длительность:', entry.duration, 'мс');
            console.log('Размер:', entry.transferSize, 'байт');
        }
    });

    observer.observe({entryTypes: ['resource']});
}
```

## Профилирование React-приложений

### React DevTools Profiler

```jsx
// Использование Profiler API для измерения рендеринга компонентов
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration, baseDuration, startTime, commitTime) {
    console.log({
        id,
        phase, // "mount" (if it was a new tree) or "update" (if it was an update)
        actualDuration, // время рендеринга
        baseDuration, // оценочное время рендеринга
        startTime,
        commitTime
    });
}

function App() {
    return (
        <Profiler id="App" onRender={onRenderCallback}>
            <ComponentToProfile />
        </Profiler>
    );
}
```

### Кастомные хуки для профилирования

```jsx
import { useEffect, useRef } from 'react';

// Кастомный хук для измерения времени рендеринга
function useRenderCounter(componentName) {
    const renderCount = useRef(0);
    
    useEffect(() => {
        renderCount.current += 1;
        console.log(`${componentName} rendered ${renderCount.current} times`);
    });
    
    return renderCount.current;
}

// Кастомный хук для измерения производительности
function usePerformanceMeasure(componentName) {
    useEffect(() => {
        performance.mark(`${componentName}-start`);
        
        return () => {
            performance.mark(`${componentName}-end`);
            performance.measure(
                `${componentName}-render`,
                `${componentName}-start`,
                `${componentName}-end`
            );
        };
    });
}
```

## Аналитика производительности

### Web Vitals

```javascript
// Измерение Core Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
    // Отправка метрик в аналитическую систему
    console.log(metric.name, metric.value);
    
    // Пример отправки на сервер
    // navigator.sendBeacon('/analytics', JSON.stringify(metric));
}

// Регистрация измерений
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### Пользовательские метрики

```javascript
// Создание пользовательских метрик
class PerformanceMetrics {
    constructor() {
        this.metrics = {};
    }
    
    startTimer(name) {
        performance.mark(`${name}-start`);
    }
    
    endTimer(name) {
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        
        const measure = performance.getEntriesByName(name)[0];
        this.metrics[name] = measure.duration;
        
        return measure.duration;
    }
    
    getMetric(name) {
        return this.metrics[name];
    }
    
    getAllMetrics() {
        return this.metrics;
    }
}

// Использование
const perfMetrics = new PerformanceMetrics();
perfMetrics.startTimer('user-interaction');
// Пользовательское взаимодействие
perfMetrics.endTimer('user-interaction');
console.log('Время взаимодействия:', perfMetrics.getMetric('user-interaction'), 'мс');
```

## Практические примеры профилирования

### Профилирование анимаций

```javascript
// Профилирование анимаций
function profileAnimation() {
    let frameCount = 0;
    let startTime = performance.now();
    
    function animate() {
        frameCount++;
        const currentTime = performance.now();
        
        // Вычисление FPS
        if (currentTime - startTime >= 1000) {
            const fps = frameCount / ((currentTime - startTime) / 1000);
            console.log('FPS:', fps);
            
            frameCount = 0;
            startTime = currentTime;
        }
        
        requestAnimationFrame(animate);
    }
    
    requestAnimationFrame(animate);
}
```

### Профилирование загрузки страницы

```javascript
// Анализ времени загрузки страницы
function analyzePageLoadTime() {
    window.addEventListener('load', () => {
        const timing = performance.timing;
        
        console.log('Время загрузки DOM:', timing.domContentLoadedEventEnd - timing.navigationStart, 'мс');
        console.log('Полное время загрузки:', timing.loadEventEnd - timing.navigationStart, 'мс');
        console.log('Время подключения к серверу:', timing.connectEnd - timing.connectStart, 'мс');
        console.log('Время первого байта:', timing.responseStart - timing.requestStart, 'мс');
    });
}
```

## Автоматизированное профилирование

### Создание скрипта профилирования

```javascript
// Автоматизированный скрипт профилирования
class AutomatedProfiler {
    constructor(options = {}) {
        this.options = {
            sampleInterval: options.sampleInterval || 1000, // 1 секунда
            maxSamples: options.maxSamples || 100,
            ...options
        };
        
        this.samples = [];
        this.isProfiling = false;
    }
    
    start() {
        if (this.isProfiling) return;
        
        this.isProfiling = true;
        this.collectSamples();
    }
    
    stop() {
        this.isProfiling = false;
    }
    
    collectSamples() {
        if (!this.isProfiling || this.samples.length >= this.options.maxSamples) {
            this.stop();
            return;
        }
        
        const sample = {
            timestamp: Date.now(),
            memory: performance.memory ? {
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit
            } : null,
            cpu: this.estimateCPUUsage()
        };
        
        this.samples.push(sample);
        
        setTimeout(() => this.collectSamples(), this.options.sampleInterval);
    }
    
    estimateCPUUsage() {
        // Простая эвристика для оценки загрузки CPU
        const start = performance.now();
        let count = 0;
        
        // Выполнение простой операции в цикле
        for (let i = 0; i < 100000; i++) {
            count += Math.random();
        }
        
        const duration = performance.now() - start;
        return duration;
    }
    
    getReport() {
        if (this.samples.length === 0) {
            return 'Нет данных для анализа';
        }
        
        const durations = this.samples.map(s => s.cpu).filter(Boolean);
        const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
        
        return {
            totalSamples: this.samples.length,
            averageCPUEstimate: avgDuration,
            memoryUsage: this.samples[this.samples.length - 1]?.memory
        };
    }
}

// Использование
const profiler = new AutomatedProfiler({ sampleInterval: 2000 });
profiler.start();

// Через некоторое время
setTimeout(() => {
    profiler.stop();
    console.log(profiler.getReport());
}, 10000);
```

## Лучшие практики профилирования

1. **Профилируйте в реальных условиях** - используйте реальные данные и сценарии использования
2. **Тестируйте на разных устройствах** - производительность может сильно отличаться
3. **Измеряйте до и после оптимизаций** - чтобы убедиться в эффективности изменений
4. **Используйте несколько инструментов** - каждый инструмент показывает разные аспекты
5. **Документируйте результаты** - для отслеживания прогресса и принятия решений

## Интерпретация результатов

При анализе результатов профилирования обращайте внимание на:
- Узкие места в производительности
- Часто выполняемые операции
- Утечки памяти
- Проблемы с сетью
- Долгие задачи в главном потоке

## См. также

- [[Оптимизация-рендеринга]]
- [[lazy-loading]]
- [[Кэширование]]
- [[Web Vitals]]
- [[Chrome DevTools]]