---
aliases: [Кэширование, Cache, Кэш]
tags: [frontend, performance, caching, optimization]
---

# Кэширование

## Введение

Кэширование - это важнейшая техника оптимизации производительности веб-приложений, заключающаяся в хранении временных копий данных для ускорения последующего доступа к ним. Правильное кэширование может значительно улучшить время загрузки страниц и сократить сетевой трафик.

## Типы кэширования

### HTTP-кэширование

HTTP-кэширование - это основной механизм, контролируемый через заголовки HTTP. Он работает на уровне браузера и промежуточных серверов.

#### Заголовки кэширования

```http
Cache-Control: max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
Expires: Wed, 21 Oct 2023 08:28:00 GMT
```

#### Примеры директив Cache-Control

```javascript
// Пример настройки заголовков кэширования на сервере
app.get('/api/data', (req, res) => {
    // Кэширование на 1 час
    res.set('Cache-Control', 'public, max-age=3600');
    res.json({ data: 'important data' });
});

app.get('/static/image.jpg', (req, res) => {
    // Долгосрочное кэширование для статических ресурсов
    res.set('Cache-Control', 'public, max-age=31536000'); // 1 год
    res.sendFile('image.jpg');
});
```

### Клиентское кэширование

#### LocalStorage и SessionStorage

```javascript
// Кэширование данных в LocalStorage
class LocalStorageCache {
    constructor(prefix = 'app_cache_', ttl = 3600000) { // 1 час по умолчанию
        this.prefix = prefix;
        this.ttl = ttl;
    }

    set(key, value) {
        const item = {
            value: value,
            timestamp: Date.now(),
            ttl: this.ttl
        };
        localStorage.setItem(this.prefix + key, JSON.stringify(item));
    }

    get(key) {
        const itemStr = localStorage.getItem(this.prefix + key);
        if (!itemStr) return null;

        const item = JSON.parse(itemStr);
        if (Date.now() - item.timestamp > item.ttl) {
            localStorage.removeItem(this.prefix + key);
            return null;
        }

        return item.value;
    }

    remove(key) {
        localStorage.removeItem(this.prefix + key);
    }
}

// Использование кэша
const cache = new LocalStorageCache();
cache.set('user_data', { name: 'John', id: 123 });
const userData = cache.get('user_data');
```

#### IndexedDB

```javascript
// Кэширование с использованием IndexedDB
class IndexedDBCache {
    constructor(dbName = 'AppCache', version = 1) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('cache')) {
                    const store = db.createObjectStore('cache', { keyPath: 'key' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }

    async set(key, value) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['cache'], 'readwrite');
        const store = transaction.objectStore('cache');
        
        const data = {
            key: key,
            value: value,
            timestamp: Date.now()
        };
        
        return store.put(data);
    }

    async get(key) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['cache'], 'readonly');
        const store = transaction.objectStore('cache');
        const request = store.get(key);
        
        return new Promise((resolve, reject) => {
            request.onsuccess = () => {
                const result = request.result;
                if (result) {
                    resolve(result.value);
                } else {
                    resolve(null);
                }
            };
            request.onerror = () => reject(request.error);
        });
    }
}
```

### Service Worker кэширование

```javascript
// Service Worker для кэширования ресурсов
const CACHE_NAME = 'app-cache-v1';
const urlsToCache = [
    '/',
    '/styles/main.css',
    '/scripts/main.js',
    '/images/logo.png'
];

self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => cache.addAll(urlsToCache))
    );
});

self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request)
            .then((response) => {
                // Возврат кэшированного ответа или сетевого запроса
                if (response) {
                    return response;
                }
                return fetch(event.request);
            })
    );
});
```

## Стратегии кэширования

### Cache-First (Кэш в приоритете)

```javascript
// Стратегия "сначала кэш"
async function cacheFirst(request) {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
        return cachedResponse;
    }
    
    const networkResponse = await fetch(request);
    if (networkResponse && networkResponse.status === 200) {
        const cache = await caches.open(CACHE_NAME);
        cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
}
```

### Network-First (Сеть в приоритете)

```javascript
// Стратегия "сначала сеть"
async function networkFirst(request) {
    try {
        const networkResponse = await fetch(request);
        if (networkResponse && networkResponse.status === 200) {
            const cache = await caches.open(CACHE_NAME);
            cache.put(request, networkResponse.clone());
        }
        return networkResponse;
    } catch (error) {
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }
        throw error;
    }
}
```

### Stale-While-Revalidate (Старый с обновлением)

```javascript
// Стратегия "старый с обновлением"
async function staleWhileRevalidate(request) {
    const cachedResponse = await caches.match(request);
    
    // Обновление кэша в фоне
    const networkResponsePromise = fetch(request)
        .then(async (networkResponse) => {
            if (networkResponse && networkResponse.status === 200) {
                const cache = await caches.open(CACHE_NAME);
                cache.put(request, networkResponse.clone());
            }
            return networkResponse;
        });

    // Возврат кэшированного ответа, если доступен
    return cachedResponse || networkResponsePromise;
}
```

## Кэширование в React

### Использование useMemo для кэширования вычислений

```jsx
import React, { useMemo } from 'react';

function ExpensiveComponent({ items, filter }) {
    // Кэширование результатов дорогостоящих вычислений
    const filteredItems = useMemo(() => {
        console.log('Выполнение фильтрации'); // Лог будет только при изменении зависимостей
        return items.filter(item => item.category === filter);
    }, [items, filter]);

    return (
        <div>
            {filteredItems.map(item => (
                <div key={item.id}>{item.name}</div>
            ))}
        </div>
    );
}
```

### Кастомный хук для кэширования данных

```jsx
import { useState, useEffect } from 'react';

// Кастомный хук для кэширования API-запросов
function useCachedData(key, fetchFunction, ttl = 300000) { // 5 минут по умолчанию
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const cacheKey = `cache_${key}`;
        const cached = localStorage.getItem(cacheKey);
        
        if (cached) {
            const parsed = JSON.parse(cached);
            if (Date.now() - parsed.timestamp < ttl) {
                setData(parsed.data);
                setLoading(false);
                return;
            }
        }

        const fetchData = async () => {
            try {
                const result = await fetchFunction();
                setData(result);
                
                // Сохранение в кэш
                localStorage.setItem(cacheKey, JSON.stringify({
                    data: result,
                    timestamp: Date.now()
                }));
                
                setLoading(false);
            } catch (err) {
                setError(err);
                setLoading(false);
            }
        };

        fetchData();
    }, [key, fetchFunction, ttl]);

    return { data, loading, error };
}
```

## Кэширование на стороне сервера

### Пример кэширования с Redis

```javascript
const redis = require('redis');
const client = redis.createClient();

// Кэширование результатов API
async function getCachedData(key, fetchFunction, ttl = 3600) {
    // Попытка получить данные из кэша
    const cached = await client.get(key);
    if (cached) {
        return JSON.parse(cached);
    }

    // Если данных нет в кэше, получаем их
    const data = await fetchFunction();
    
    // Сохраняем в кэш
    await client.setex(key, ttl, JSON.stringify(data));
    
    return data;
}

// Использование
app.get('/api/expensive-operation', async (req, res) => {
    const data = await getCachedData(
        'expensive_operation',
        async () => {
            // Дорогостоящая операция
            return await performExpensiveOperation();
        },
        3600 // 1 час
    );
    
    res.json(data);
});
```

## Инвалидация кэша

### Стратегии инвалидации

```javascript
// Пример системы инвалидации кэша
class CacheManager {
    constructor() {
        this.cache = new Map();
        this.dependencies = new Map(); // Отслеживание зависимостей
    }

    set(key, value, dependencies = []) {
        this.cache.set(key, {
            value,
            timestamp: Date.now(),
            dependencies
        });

        // Регистрация зависимостей
        dependencies.forEach(dep => {
            if (!this.dependencies.has(dep)) {
                this.dependencies.set(dep, new Set());
            }
            this.dependencies.get(dep).add(key);
        });
    }

    get(key) {
        const item = this.cache.get(key);
        if (!item) return null;
        
        return item.value;
    }

    // Инвалидация по зависимостям
    invalidate(dependency) {
        const keys = this.dependencies.get(dependency);
        if (keys) {
            keys.forEach(key => {
                this.cache.delete(key);
            });
        }
    }
}
```

## Лучшие практики

1. **Установите правильное время жизни (TTL)** для кэшируемых данных
2. **Используйте версионирование** для статических ресурсов
3. **Регулярно очищайте устаревшие данные** из кэша
4. **Используйте подходящую стратегию кэширования** для каждого типа данных
5. **Тестируйте производительность** до и после внедрения кэширования

## Потенциальные проблемы

- **Устаревшие данные** - кэшированные данные могут не соответствовать актуальным
- **Расход памяти** - кэш может занимать значительное место
- **Сложность управления** - усложнение логики приложения при управлении кэшем

## См. также

- [[lazy-loading]]
- [[Оптимизация-рендеринга]]
- [[Service Workers]]
- [[HTTP Headers]]