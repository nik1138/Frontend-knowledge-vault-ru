# Паттерны проектирования

Паттерны проектирования — это типичные решения часто встречающихся проблем при проектировании программ. Они представляют собой проверенные подходы к решению проблем, которые могут возникнуть при разработке программного обеспечения. Паттерны проектирования не являются готовыми копиями кода, а скорее концептуальными шаблонами, которые можно адаптировать под конкретные задачи.

## Основные характеристики паттернов проектирования

### Повторное использование решений
Паттерны представляют собой проверенные решения, которые можно применять в различных контекстах.

### Универсальность
Паттерны могут быть адаптированы под конкретные задачи и технологии.

### Общая терминология
Паттерны создают общую терминологию для разработчиков, облегчая коммуникацию.

### Документирование лучших практик
Паттерны фиксируют лучшие практики проектирования программного обеспечения.

## Классификация паттернов проектирования

### Порождающие паттерны (Creational)
Эти паттерны занимаются созданием объектов. Они предоставляют гибкий механизм для создания объектов в различных ситуациях.

### Структурные паттерны (Structural)
Эти паттерны занимаются компоновкой классов и объектов для формирования более крупных структур.

### Поведенческие паттерны (Behavioral)
Эти паттерны определяют способы взаимодействия между объектами и распределения ответственностей.

## Порождающие паттерны

### Одиночка (Singleton)
Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

```javascript
// Одиночка в JavaScript
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }
    
    Database.instance = this;
    this.connection = null;
    return this;
  }
  
  connect() {
    if (!this.connection) {
      // Логика подключения к базе данных
      this.connection = { connected: true };
      console.log('Подключение к базе данных установлено');
    }
    return this.connection;
  }
  
  query(sql) {
    if (!this.connection) {
      throw new Error('Нет подключения к базе данных');
    }
    console.log(`Выполнение запроса: ${sql}`);
    return { result: 'query result' };
  }
}

// Использование
const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2); // true - один и тот же экземпляр
```

### Фабрика (Factory)
Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемых объектов.

```javascript
// Фабрика в JavaScript
class AnimalFactory {
  static createAnimal(type, name) {
    switch(type) {
      case 'dog':
        return new Dog(name);
      case 'cat':
        return new Cat(name);
      case 'bird':
        return new Bird(name);
      default:
        throw new Error('Неизвестный тип животного');
    }
  }
}

class Dog {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} лает`;
  }
}

class Cat {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} мяукает`;
  }
}

class Bird {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} чирикает`;
  }
}

// Использование
const dog = AnimalFactory.createAnimal('dog', 'Бобик');
const cat = AnimalFactory.createAnimal('cat', 'Мурка');
const bird = AnimalFactory.createAnimal('bird', 'Чижик');

console.log(dog.speak()); // Бобик лает
console.log(cat.speak()); // Мурка мяукает
console.log(bird.speak()); // Чижик чирикает
```

### Абстрактная фабрика (Abstract Factory)
Предоставляет интерфейс для создания семейств связанных или зависимых объектов без указания их конкретных классов.

```typescript
// Абстрактная фабрика в TypeScript
interface Button {
  render(): void;
}

interface Checkbox {
  toggle(): void;
}

class WindowsButton implements Button {
  render(): void {
    console.log('Отображение кнопки в стиле Windows');
  }
}

class WindowsCheckbox implements Checkbox {
  toggle(): void {
    console.log('Переключение чекбокса в стиле Windows');
  }
}

class MacButton implements Button {
  render(): void {
    console.log('Отображение кнопки в стиле Mac');
  }
}

class MacCheckbox implements Checkbox {
  toggle(): void {
    console.log('Переключение чекбокса в стиле Mac');
  }
}

interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

class WindowsFactory implements GUIFactory {
  createButton(): Button {
    return new WindowsButton();
  }
  
  createCheckbox(): Checkbox {
    return new WindowsCheckbox();
  }
}

class MacFactory implements GUIFactory {
  createButton(): Button {
    return new MacButton();
  }
  
  createCheckbox(): Checkbox {
    return new MacCheckbox();
  }
}

// Использование
function createUI(factory: GUIFactory) {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  
  button.render();
  checkbox.toggle();
}

const windowsFactory = new WindowsFactory();
const macFactory = new MacFactory();

createUI(windowsFactory);
// Отображение кнопки в стиле Windows
// Переключение чекбокса в стиле Windows

createUI(macFactory);
// Отображение кнопки в стиле Mac
// Переключение чекбокса в стиле Mac
```

## Структурные паттерны

### Адаптер (Adapter)
Позволяет объектам с несовместимыми интерфейсами работать вместе.

```javascript
// Адаптер в JavaScript
class OldPaymentSystem {
  makePayment(amount) {
    return `Оплата ${amount} через старую систему`;
  }
}

class NewPaymentSystem {
  process(amount, currency) {
    return `Обработка платежа ${amount} ${currency} через новую систему`;
  }
}

class PaymentAdapter {
  constructor(newSystem) {
    this.newSystem = newSystem;
  }
  
  makePayment(amount) {
    // Адаптируем интерфейс новой системы к старому интерфейсу
    return this.newSystem.process(amount, 'RUB');
  }
}

// Использование
const oldSystem = new OldPaymentSystem();
const newSystem = new NewPaymentSystem();
const adapter = new PaymentAdapter(newSystem);

console.log(oldSystem.makePayment(100)); // Оплата 100 через старую систему
console.log(adapter.makePayment(100)); // Обработка платежа 100 RUB через новую систему
```

### Декоратор (Decorator)
Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные "обёртки".

```javascript
// Декоратор в JavaScript
class Notifier {
  send(message) {
    console.log(`Отправка уведомления: ${message}`);
  }
}

class SMSDecorator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  
  send(message) {
    this.notifier.send(message);
    this.sendSMS(message);
  }
  
  sendSMS(message) {
    console.log(`Отправка SMS: ${message}`);
  }
}

class EmailDecorator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  
  send(message) {
    this.notifier.send(message);
    this.sendEmail(message);
  }
  
  sendEmail(message) {
    console.log(`Отправка Email: ${message}`);
  }
}

// Использование
let notifier = new Notifier();
notifier = new SMSDecorator(notifier);
notifier = new EmailDecorator(notifier);

notifier.send('Важное сообщение');
// Отправка уведомления: Важное сообщение
// Отправка SMS: Важное сообщение
// Отправка Email: Важное сообщение
```

### Фасад (Facade)
Предоставляет простой интерфейс для сложной системы классов, библиотеки или фреймворка.

```javascript
// Фасад в JavaScript
class CPU {
  freeze() {
    console.log('CPU: Заморозка');
  }
  
  jump(position) {
    console.log(`CPU: Переход к позиции ${position}`);
  }
  
  execute() {
    console.log('CPU: Выполнение');
  }
}

class Memory {
  load(position, data) {
    console.log(`Память: Загрузка данных "${data}" в позицию ${position}`);
  }
}

class HardDrive {
  read(lba, size) {
    console.log(`Жесткий диск: Чтение ${size} байт с адреса ${lba}`);
    return 'данные';
  }
}

class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    console.log('Запуск компьютера:');
    this.cpu.freeze();
    this.memory.load(0, this.hardDrive.read(0, 1024));
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('Компьютер запущен');
  }
  
  stop() {
    console.log('Выключение компьютера');
  }
}

// Использование
const computer = new ComputerFacade();
computer.start();
computer.stop();
```

## Поведенческие паттерны

### Наблюдатель (Observer)
Определяет зависимость "один ко многим" между объектами, при которой изменение состояния одного объекта влечет за собой автоматическое оповещение всех зависимых объектов.

```javascript
// Наблюдатель в JavaScript
class Subject {
  constructor() {
    this.observers = [];
  }
  
  addObserver(observer) {
    this.observers.push(observer);
  }
  
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class NewsAgency extends Subject {
  constructor() {
    super();
    this.news = '';
  }
  
  setNews(news) {
    this.news = news;
    this.notify(this.news);
  }
}

class NewsChannel {
  constructor(name) {
    this.name = name;
  }
  
  update(news) {
    console.log(`${this.name} получает новость: ${news}`);
  }
}

// Использование
const agency = new NewsAgency();
const channel1 = new NewsChannel('Канал 1');
const channel2 = new NewsChannel('Канал 2');

agency.addObserver(channel1);
agency.addObserver(channel2);

agency.setNews('Важные новости!');
// Канал 1 получает новость: Важные новости!
// Канал 2 получает новость: Важные новости!
```

### Стратегия (Strategy)
Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

```typescript
// Стратегия в TypeScript
interface SortStrategy {
  sort(data: number[]): number[];
}

class QuickSort implements SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка быстрой сортировкой');
    return [...data].sort((a, b) => a - b);
  }
}

class MergeSort implements SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка сортировкой слиянием');
    return [...data].sort((a, b) => a - b);
  }
}

class BubbleSort implements SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка пузырьковой сортировкой');
    const result = [...data];
    for (let i = 0; i < result.length; i++) {
      for (let j = 0; j < result.length - i - 1; j++) {
        if (result[j] > result[j + 1]) {
          [result[j], result[j + 1]] = [result[j + 1], result[j]];
        }
      }
    }
    return result;
  }
}

class Sorter {
  private strategy: SortStrategy;
  
  constructor(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  sort(data: number[]): number[] {
    return this.strategy.sort(data);
  }
}

// Использование
const data = [64, 34, 25, 12, 22, 11, 90];
const sorter = new Sorter(new QuickSort());

console.log(sorter.sort(data));
// Сортировка быстрой сортировкой
// [11, 12, 22, 25, 34, 64, 90]

sorter.setStrategy(new MergeSort());
console.log(sorter.sort(data));
// Сортировка сортировкой слиянием
// [11, 12, 22, 25, 34, 64, 90]
```

### Команда (Command)
Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

```javascript
// Команда в JavaScript
class Command {
  execute() {
    throw new Error('Метод execute должен быть реализован');
  }
  
  undo() {
    throw new Error('Метод undo должен быть реализован');
  }
}

class Light {
  constructor() {
    this.isOn = false;
  }
  
  turnOn() {
    this.isOn = true;
    console.log('Свет включен');
  }
  
  turnOff() {
    this.isOn = false;
    console.log('Свет выключен');
  }
}

class TurnOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class TurnOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

class RemoteControl {
  constructor() {
    this.history = [];
  }
  
  submit(command) {
    command.execute();
    this.history.push(command);
  }
  
  undo() {
    if (this.history.length > 0) {
      const command = this.history.pop();
      command.undo();
    }
  }
}

// Использование
const light = new Light();
const remote = new RemoteControl();

const turnOnCommand = new TurnOnCommand(light);
const turnOffCommand = new TurnOffCommand(light);

remote.submit(turnOnCommand); // Свет включен
remote.submit(turnOffCommand); // Свет выключен
remote.undo(); // Свет включен
```

## Преимущества паттернов проектирования

### Повторное использование
Паттерны предоставляют проверенные решения, которые можно использовать в различных проектах.

### Улучшенная коммуникация
Паттерны создают общую терминологию для разработчиков, облегчая общение.

### Гибкость и расширяемость
Паттерны помогают создавать гибкие и легко расширяемые системы.

### Поддержка лучших практик
Паттерны фиксируют лучшие практики проектирования программного обеспечения.

## Недостатки паттернов проектирования

### Избыточность
Для простых задач паттерны могут быть избыточными.

### Сложность
Неправильное применение паттернов может усложнить код.

### Косвенность
Паттерны могут добавить уровни косвенности, затрудняющие понимание кода.

## Когда использовать паттерны

### Подходящие ситуации
- Когда сталкиваешься с типичными проблемами проектирования
- Когда нужно улучшить структуру существующего кода
- Когда требуется обеспечить гибкость и расширяемость системы
- Когда нужно улучшить коммуникацию в команде разработчиков

### Когда не использовать
- Когда паттерн добавляет ненужную сложность
- Когда решение без паттерна проще и понятнее
- Когда паттерн не соответствует конкретной задаче

## Связь с другими концепциями

- [[SOLID]] - Паттерны проектирования реализуют принципы SOLID
- [[GRASP (General Responsibility Assignment Software Patterns)]] - Паттерны GRASP и GoF паттерны дополняют друг друга
- [[DRY (Don't Repeat Yourself)]] - Паттерны помогают избежать дублирования решений
- [[KISS (Keep It Simple, Stupid)]] - Паттерны должны применяться с учетом принципа простоты
- [[YAGNI (You Aren't Gonna Need It)]] - Не используйте паттерны до необходимости
- [[Наследование]] - Многие паттерны используют наследование
- [[Композиция]] - Композиция часто предпочтительнее наследования в паттернах
- [[Интерфейсы]] - Интерфейсы являются основой многих паттернов
- [[Полиморфизм]] - Паттерны часто используют полиморфное поведение

## Применение в современных технологиях

### В [[ts]]
TypeScript предоставляет мощные возможности для реализации паттернов:
- Интерфейсы для определения контрактов
- Абстрактные классы для базовых реализаций
- Дженерики для создания универсальных решений

### В [[js]]
JavaScript поддерживает паттерны через:
- Прототипное наследование
- Функции высшего порядка
- Замыкания

### В [[react]]
React использует паттерны:
- Компонент как реализация паттерна Композиция
- HOC (Higher Order Components) как реализация паттерна Декоратор
- Хуки как реализация паттерна Стратегия

## Теги
#design-patterns #programming-concepts #software-design #oop #architecture