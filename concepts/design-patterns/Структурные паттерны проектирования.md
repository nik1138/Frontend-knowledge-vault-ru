---
aliases: ["Структурные паттерны", "Structural Patterns"]
tags: 
  - design-patterns
  - structural
  - patterns
  - oop
---

# Структурные паттерны проектирования

## Обзор

Структурные паттерны проектирования (Structural Design Patterns) - это паттерны, которые решают задачи композиции объектов или классов. Они помогают обеспечить, чтобы при изменении одной части системы не приходилось переписывать все связанное с ней. Эти паттерны фокусируются на создании связей между объектами, обеспечивая гибкость и эффективность структуры системы.

## Adapter

### Описание

Adapter позволяет объектам с несовместимыми интерфейсами работать вместе. Он выступает в роли переводчика между двумя интерфейсами, которые в противном случае не могли бы взаимодействовать.

### Проблема

Существующий класс имеет интерфейс, который несовместим с остальной системой, но его функциональность необходима.

### Решение

Создать адаптер, который преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом.

### Реализация

```javascript
// Существующий класс с несовместимым интерфейсом
class OldXMLParser {
  parseXML(data) {
    console.log('Parsing XML data...');
    // Предположим, это возвращает объект с определенной структурой
    return {
      title: data.title,
      content: data.body,
      metadata: {
        author: data.author,
        date: data.created_at
      }
    };
  }
}

// Целевой интерфейс
class JSONParserInterface {
  parse(data) {
    throw new Error('parse() method must be implemented');
  }
}

// Адаптер
class XMLToJSONAdapter extends JSONParserInterface {
  constructor(xmlParser) {
    super();
    this.xmlParser = xmlParser;
  }
  
  parse(data) {
    // Преобразование формата данных
    const xmlData = {
      title: data.title,
      body: data.content,
      author: data.metadata.author,
      created_at: data.metadata.date
    };
    
    // Использование старого XML парсера
    const result = this.xmlParser.parseXML(xmlData);
    
    // Преобразование результата в JSON формат
    return {
      title: result.title,
      content: result.content,
      author: result.metadata.author,
      date: result.metadata.date
    };
  }
}

// Клиентский код, который ожидает JSONParserInterface
class DataProcessor {
  constructor(parser) {
    this.parser = parser;
  }
  
  processData(data) {
    const parsedData = this.parser.parse(data);
    console.log('Processing data:', parsedData);
    return parsedData;
  }
}

// Использование
const oldParser = new OldXMLParser();
const adapter = new XMLToJSONAdapter(oldParser);
const processor = new DataProcessor(adapter);

const inputData = {
  title: 'Sample Title',
  content: 'Sample content',
  metadata: {
    author: 'John Doe',
    date: '2023-01-01'
  }
};

processor.processData(inputData);
```

### Объектный адаптер

```javascript
// Адаптер через делегирование
class PaymentAdapter {
  constructor(externalPaymentService) {
    this.externalService = externalPaymentService;
  }
  
  processPayment(amount, currency) {
    // Адаптация интерфейса
    return this.externalService.makePayment({
      amount: amount * 100, // Преобразование в центы
      currency: currency.toUpperCase(),
      timestamp: Date.now()
    });
  }
}

// Использование
const externalService = new ExternalPaymentService();
const paymentAdapter = new PaymentAdapter(externalService);
paymentAdapter.processPayment(100, 'usd');
```

## Bridge

### Описание

Bridge разделяет абстракцию и реализацию так, что они могут изменяться независимо. Это позволяет изменять реализацию без изменения клиентского кода, использующего абстракцию.

### Проблема

При связывании абстракции с конкретной реализацией возникает жесткая зависимость, которая затрудняет внесение изменений.

### Решение

Создать мост между абстракцией и реализацией, позволяющий им изменяться независимо друг от друга.

### Реализация

```javascript
// Реализация
class Renderer {
  renderShape(shapeData) {
    throw new Error('renderShape() method must be implemented');
  }
}

class VectorRenderer extends Renderer {
  renderShape(shapeData) {
    console.log(`Drawing vector shape: ${shapeData.type} with ${shapeData.properties}`);
  }
}

class RasterRenderer extends Renderer {
  renderShape(shapeData) {
    console.log(`Drawing raster shape: ${shapeData.type} with ${shapeData.properties}`);
  }
}

// Абстракция
class Shape {
  constructor(renderer) {
    this.renderer = renderer;
  }
  
  draw() {
    throw new Error('draw() method must be implemented');
  }
  
  resize(factor) {
    this.size *= factor;
  }
}

class Circle extends Shape {
  constructor(renderer, x, y, radius) {
    super(renderer);
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.size = radius;
  }
  
  draw() {
    const shapeData = {
      type: 'circle',
      properties: { x: this.x, y: this.y, radius: this.radius }
    };
    this.renderer.renderShape(shapeData);
  }
}

class Square extends Shape {
  constructor(renderer, x, y, side) {
    super(renderer);
    this.x = x;
    this.y = y;
    this.side = side;
    this.size = side;
  }
  
  draw() {
    const shapeData = {
      type: 'square',
      properties: { x: this.x, y: this.y, side: this.side }
    };
    this.renderer.renderShape(shapeData);
  }
}

// Использование
const vectorRenderer = new VectorRenderer();
const rasterRenderer = new RasterRenderer();

const circle1 = new Circle(vectorRenderer, 5, 5, 10);
const circle2 = new Circle(rasterRenderer, 10, 10, 15);
const square1 = new Square(vectorRenderer, 0, 0, 20);

circle1.draw(); // Drawing vector shape: circle with x: 5, y: 5, radius: 10
circle2.draw(); // Drawing raster shape: circle with x: 10, y: 10, radius: 15
square1.draw(); // Drawing vector shape: square with x: 0, y: 0, side: 20
```

## Composite

### Описание

Composite позволяет клиентскому коду обрабатывать как индивидуальные объекты, так и их составные структуры одинаково. Он создает иерархию объектов "часть-целое".

### Проблема

Необходимость обрабатывать одиночные объекты и составные структуры одинаковым образом.

### Решение

Создать общий интерфейс для одиночных объектов и их композиций.

### Реализация

```javascript
// Компонент
class FileSystemItem {
  constructor(name) {
    this.name = name;
  }
  
  getName() {
    return this.name;
  }
  
  getSize() {
    throw new Error('getSize() method must be implemented');
  }
  
  isFolder() {
    throw new Error('isFolder() method must be implemented');
  }
}

// Лист
class File extends FileSystemItem {
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  
  getSize() {
    return this.size;
  }
  
  isFolder() {
    return false;
  }
}

// Контейнер
class Folder extends FileSystemItem {
  constructor(name) {
    super(name);
    this.children = [];
  }
  
  add(item) {
    this.children.push(item);
  }
  
  remove(item) {
    const index = this.children.indexOf(item);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
  
  getSize() {
    return this.children.reduce((total, child) => total + child.getSize(), 0);
  }
  
  isFolder() {
    return true;
  }
  
  listContents(indent = 0) {
    const spaces = '  '.repeat(indent);
    console.log(`${spaces}Folder: ${this.name} (${this.getSize()} bytes)`);
    
    this.children.forEach(child => {
      if (child.isFolder()) {
        child.listContents(indent + 1);
      } else {
        console.log(`${spaces}  File: ${child.getName()} (${child.getSize()} bytes)`);
      }
    });
  }
}

// Использование
const root = new Folder('root');
const documents = new Folder('documents');
const photos = new Folder('photos');

const resume = new File('resume.pdf', 1024);
const coverLetter = new File('cover_letter.docx', 512);
const vacation = new File('vacation.jpg', 2048);

documents.add(resume);
documents.add(coverLetter);
photos.add(vacation);

root.add(documents);
root.add(photos);

root.listContents();
console.log(`Total size: ${root.getSize()} bytes`);
```

## Decorator

### Описание

Decorator позволяет динамически добавлять новую функциональность объектам, оборачивая их в полезные "обертки". Это альтернатива созданию подклассов для расширения функциональности.

### Проблема

Необходимость добавления функциональности к объектам динамически, без изменения их класса.

### Решение

Оборачивание объекта в декоратор, который добавляет дополнительную функциональность.

### Реализация

```javascript
// Базовый компонент
class Coffee {
  getCost() {
    return 2.0;
  }
  
  getDescription() {
    return 'Coffee';
  }
}

// Декоратор
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  getCost() {
    return this.coffee.getCost();
  }
  
  getDescription() {
    return this.coffee.getDescription();
  }
}

// Конкретные декораторы
class MilkDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 0.5;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', milk';
  }
}

class SugarDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 0.2;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', sugar';
  }
}

class WhipDecorator extends CoffeeDecorator {
  getCost() {
    return this.coffee.getCost() + 0.7;
  }
  
  getDescription() {
    return this.coffee.getDescription() + ', whip';
  }
}

// Использование
let coffee = new Coffee();
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);

coffee = new MilkDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);

coffee = new SugarDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);

coffee = new WhipDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`);

// Или создание с нуля
const fancyCoffee = new WhipDecorator(
  new SugarDecorator(
    new MilkDecorator(new Coffee())
  )
);
console.log(`${fancyCoffee.getDescription()}: $${fancyCoffee.getCost()}`);
```

### Функциональный декоратор

```javascript
// Функциональный декоратор для логирования
function logDecorator(target, propertyName, descriptor) {
  const method = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${propertyName} with arguments:`, args);
    const result = method.apply(this, args);
    console.log(`Result of ${propertyName}:`, result);
    return result;
  };
  
  return descriptor;
}

// Пример использования декоратора
class Calculator {
  @logDecorator
  add(a, b) {
    return a + b;
  }
  
  @logDecorator
  multiply(a, b) {
    return a * b;
  }
}
```

## Facade

### Описание

Facade предоставляет унифицированный интерфейс к подсистеме, состоящей из множества интерфейсов. Он упрощает использование сложной системы, скрывая ее сложность за простым интерфейсом.

### Проблема

Сложная подсистема с множеством интерфейсов требует сложного кода для использования.

### Решение

Создать фасад, который предоставляет простой интерфейс к сложной подсистеме.

### Реализация

```javascript
// Подсистемы
class VideoConverter {
  convert(filename, format) {
    console.log(`Converting video ${filename} to ${format}`);
    return `converted_${filename}.${format}`;
  }
}

class AudioExtractor {
  extract(filename) {
    console.log(`Extracting audio from ${filename}`);
    return `extracted_audio_from_${filename}`;
  }
}

class FileCompressor {
  compress(filename) {
    console.log(`Compressing file ${filename}`);
    return `compressed_${filename}`;
  }
}

class NotificationService {
  sendNotification(message) {
    console.log(`Notification: ${message}`);
  }
}

// Фасад
class VideoConverterFacade {
  constructor() {
    this.videoConverter = new VideoConverter();
    this.audioExtractor = new AudioExtractor();
    this.fileCompressor = new FileCompressor();
    this.notificationService = new NotificationService();
  }
  
  convertVideo(filename, targetFormat) {
    try {
      this.notificationService.sendNotification('Начало конвертации видео...');
      
      // Конвертация видео
      const convertedVideo = this.videoConverter.convert(filename, targetFormat);
      
      // Извлечение аудио
      const extractedAudio = this.audioExtractor.extract(filename);
      
      // Сжатие результатов
      const compressedVideo = this.fileCompressor.compress(convertedVideo);
      const compressedAudio = this.fileCompressor.compress(extractedAudio);
      
      this.notificationService.sendNotification('Конвертация завершена!');
      
      return {
        video: compressedVideo,
        audio: compressedAudio
      };
    } catch (error) {
      this.notificationService.sendNotification(`Ошибка: ${error.message}`);
      throw error;
    }
  }
}

// Использование
const converterFacade = new VideoConverterFacade();
const result = converterFacade.convertVideo('movie.avi', 'mp4');
console.log('Conversion result:', result);
```

## Flyweight

### Описание

Flyweight позволяет уменьшить использование памяти или вычислительную стоимость за счет разделения как можно большего количества аналогичных объектов.

### Проблема

Создание большого количества похожих объектов приводит к чрезмерному использованию памяти.

### Решение

Разделение внутреннего состояния (которое может быть общим) и внешнего состояния (которое уникально для каждого объекта).

### Реализация

```javascript
// Легковесный объект
class CharacterFlyweight {
  constructor(symbol, fontFamily, fontSize, color) {
    this.symbol = symbol;
    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.color = color;
  }
  
  render(x, y, content) {
    console.log(`Rendering character '${this.symbol}' at (${x}, ${y}) with content: ${content}`);
    // Здесь мог бы быть код для отображения символа
  }
}

// Фабрика легковесных объектов
class CharacterFlyweightFactory {
  constructor() {
    this.flyweights = new Map();
  }
  
  getFlyweight(symbol, fontFamily, fontSize, color) {
    const key = `${symbol}-${fontFamily}-${fontSize}-${color}`;
    
    if (!this.flyweights.has(key)) {
      this.flyweights.set(key, new CharacterFlyweight(symbol, fontFamily, fontSize, color));
    }
    
    return this.flyweights.get(key);
  }
  
  getFlyweightCount() {
    return this.flyweights.size;
  }
}

// Контекст - объект, который использует легковес
class Character {
  constructor(symbol, x, y, fontFamily, fontSize, color, flyweightFactory) {
    this.symbol = symbol;
    this.x = x;
    this.y = y;
    this.flyweight = flyweightFactory.getFlyweight(symbol, fontFamily, fontSize, color);
  }
  
  render() {
    this.flyweight.render(this.x, this.y, this.symbol);
  }
}

// Текстовый документ
class TextDocument {
  constructor() {
    this.characters = [];
    this.flyweightFactory = new CharacterFlyweightFactory();
  }
  
  addCharacter(symbol, x, y, fontFamily = 'Arial', fontSize = 12, color = 'black') {
    const character = new Character(
      symbol, 
      x, 
      y, 
      fontFamily, 
      fontSize, 
      color, 
      this.flyweightFactory
    );
    this.characters.push(character);
  }
  
  render() {
    this.characters.forEach(char => char.render());
  }
  
  getFlyweightCount() {
    return this.flyweightFactory.getFlyweightCount();
  }
}

// Использование
const doc = new TextDocument();

// Добавляем много символов одного типа
for (let i = 0; i < 1000; i++) {
  doc.addCharacter('A', i, 0, 'Arial', 12, 'black');
}

console.log(`Количество созданных легковесов: ${doc.getFlyweightCount()}`); // 1
doc.render();
```

## Proxy

### Описание

Proxy предоставляет замену или заполнитель для другой объект, контролируя доступ к нему. Это может быть полезно для ленивой инициализации, контроля доступа, ведения журнала и других задач.

### Проблема

Необходимость контроля доступа к объекту или добавления дополнительной логики при доступе к объекту.

### Решение

Создать прокси-объект, который управляет доступом к реальному объекту.

### Реализация

```javascript
// Субъект
class Image {
  constructor(filename) {
    this.filename = filename;
    this.loadImage();
  }
  
  loadImage() {
    console.log(`Loading image: ${this.filename}`);
    // Здесь могла бы быть загрузка изображения из файла
  }
  
  display() {
    console.log(`Displaying image: ${this.filename}`);
  }
}

// Прокси
class ImageProxy {
  constructor(filename) {
    this.filename = filename;
    this.realImage = null;
  }
  
  display() {
    if (!this.realImage) {
      this.realImage = new Image(this.filename);
    }
    this.realImage.display();
  }
}

// Использование
const image1 = new ImageProxy('photo1.jpg');
const image2 = new ImageProxy('photo2.jpg');

// Изображения не загружаются до вызова display()
image1.display(); // Теперь изображение загружается
image2.display(); // Теперь изображение загружается
```

### Защитный прокси

```javascript
// Защитный прокси для управления доступом
class SecureDocument {
  constructor(content, userRole) {
    this.content = content;
    this.userRole = userRole;
  }
  
  getContent() {
    if (this.userRole === 'admin') {
      return this.content;
    } else {
      return 'Access denied';
    }
  }
}

class DocumentProxy {
  constructor(realDocument, userRole) {
    this.realDocument = realDocument;
    this.userRole = userRole;
  }
  
  getContent() {
    if (this.userRole === 'admin' || this.userRole === 'user') {
      return this.realDocument.getContent();
    } else {
      throw new Error('Unauthorized access');
    }
  }
}

// Использование
const secureDoc = new SecureDocument('Secret content', 'admin');
const proxy = new DocumentProxy(secureDoc, 'user');

console.log(proxy.getContent()); // 'Access denied' или 'Secret content' в зависимости от роли
```

### Виртуальный прокси

```javascript
// Виртуальный прокси для тяжелых объектов
class ExpensiveObject {
  constructor() {
    console.log('Creating expensive object...');
    this.data = this.loadExpensiveData();
  }
  
  loadExpensiveData() {
    console.log('Loading expensive data...');
    // Имитация загрузки данных
    return Array.from({ length: 1000000 }, (_, i) => i);
  }
  
  processData() {
    console.log('Processing data...');
    return this.data.length;
  }
}

class VirtualProxy {
  constructor() {
    this.realObject = null;
  }
  
  processData() {
    if (!this.realObject) {
      this.realObject = new ExpensiveObject();
    }
    return this.realObject.processData();
  }
}

// Использование
const proxy = new VirtualProxy();
// Объект не создается до вызова метода
const result = proxy.processData();
console.log(`Result: ${result}`);
```

## Сравнение паттернов

| Паттерн | Назначение | Когда использовать |
|---------|------------|-------------------|
| Adapter | Преобразование интерфейса | Когда нужно использовать класс с несовместимым интерфейсом |
| Bridge | Разделение абстракции и реализации | Когда нужно изменять абстракцию и реализацию независимо |
| Composite | Дерево объектов | Когда нужно обрабатывать одиночные и составные объекты одинаково |
| Decorator | Добавление функциональности | Когда нужно динамически добавлять функциональность |
| Facade | Упрощение сложной системы | Когда нужен простой интерфейс к сложной подсистеме |
| Flyweight | Экономия памяти | Когда нужно создать много похожих объектов |
| Proxy | Контроль доступа | Когда нужно контролировать доступ к объекту |

## Практические применения

### В веб-разработке

```javascript
// Пример использования Proxy для валидации данных
function createValidatedObject(schema) {
  return new Proxy({}, {
    set(target, property, value) {
      if (schema[property]) {
        const validator = schema[property];
        if (validator.test(value)) {
          target[property] = value;
          return true;
        } else {
          throw new Error(`Invalid value for ${property}`);
        }
      }
      target[property] = value;
      return true;
    }
  });
}

const userSchema = {
  email: {
    test: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)
  },
  age: {
    test: (value) => typeof value === 'number' && value >= 0 && value <= 150
  }
};

const user = createValidatedObject(userSchema);
user.email = 'test@example.com'; // OK
user.age = 25; // OK
// user.age = -5; // Ошибка валидации
```

### В API интеграциях

```javascript
// Пример использования Adapter для разных API
class APIAdapter {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async getUser(id) {
    const data = await this.apiClient.get(`/users/${id}`);
    return this.mapToStandardFormat(data);
  }
  
  mapToStandardFormat(data) {
    // Преобразование данных к стандартному формату
    return {
      id: data.id || data.user_id,
      name: data.name || data.full_name,
      email: data.email || data.email_address,
      createdAt: data.created_at || data.created
    };
  }
}
```

## Заключение

Структурные паттерны проектирования предоставляют гибкие решения для организации взаимодействия между объектами и классами. Каждый паттерн решает конкретную проблему структурирования системы:

- **Adapter** - позволяет работать с несовместимыми интерфейсами
- **Bridge** - разделяет абстракцию и реализацию
- **Composite** - позволяет работать с деревьями объектов
- **Decorator** - добавляет функциональность динамически
- **Facade** - упрощает сложные подсистемы
- **Flyweight** - экономит память при создании множества объектов
- **Proxy** - контролирует доступ к объектам

Эти паттерны помогают создавать более гибкие, расширяемые и поддерживаемые системы, позволяя изменять структуру без значительных изменений в клиентском коде.

## Связанные концепции

- [[Порождающие паттерны проектирования]] - порождающие паттерны
- [[Поведенческие паттерны проектирования]] - поведенческие паттерны
- [[Design Principles]] - принципы проектирования
- [[Object-Oriented Programming]] - объектно-ориентированное программирование
- [[SOLID Principles]] - принципы SOLID