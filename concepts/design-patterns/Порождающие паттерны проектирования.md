---
aliases: ["Порождающие паттерны", "Creational Patterns"]
tags: 
  - design-patterns
  - creational
  - patterns
  - oop
---

# Порождающие паттерны проектирования

## Обзор

Порождающие паттерны проектирования (Creational Design Patterns) - это паттерны, которые решают задачи создания объектов. Они абстрагируют процесс инстанцирования и делают систему независимой от способа создания, композиции и представления объектов. Эти паттерны особенно полезны, когда заранее неизвестно, какие именно типы объектов будут созданы или когда нужно централизовать создание объектов.

## Singleton

### Описание

Singleton гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Это один из самых известных и часто используемых порождающих паттернов.

### Проблема

Иногда требуется обеспечить, чтобы класс имел только один экземпляр. Это может быть нужно для:
- Управления ресурсами (например, подключение к базе данных)
- Логирования
- Настройки приложения
- Кэширования

### Решение

Создать класс, который контролирует собственное инстанцирование и не позволяет создать второй экземпляр.

### Реализация

```javascript
// Классический Singleton
class DatabaseConnection {
  constructor(connectionString) {
    if (DatabaseConnection.instance) {
      return DatabaseConnection.instance;
    }
    
    this.connectionString = connectionString;
    this.isConnected = false;
    
    DatabaseConnection.instance = this;
    return this;
  }
  
  connect() {
    if (!this.isConnected) {
      console.log(`Подключение к базе данных: ${this.connectionString}`);
      this.isConnected = true;
    }
    return this;
  }
  
  disconnect() {
    if (this.isConnected) {
      console.log('Отключение от базы данных');
      this.isConnected = false;
    }
  }
}

// Использование
const db1 = new DatabaseConnection('mongodb://localhost:27017');
const db2 = new DatabaseConnection('mongodb://localhost:27018');

console.log(db1 === db2); // true - это один и тот же экземпляр
```

### Альтернативная реализация с модулем

```javascript
// Singleton с использованием модуля
const DatabaseConnection = (function() {
  let instance;
  
  function createInstance(connectionString) {
    return {
      connectionString: connectionString,
      isConnected: false,
      
      connect() {
        if (!this.isConnected) {
          console.log(`Подключение к базе данных: ${this.connectionString}`);
          this.isConnected = true;
        }
        return this;
      },
      
      disconnect() {
        if (this.isConnected) {
          console.log('Отключение от базы данных');
          this.isConnected = false;
        }
      }
    };
  }
  
  return {
    getInstance(connectionString) {
      if (!instance) {
        instance = createInstance(connectionString);
      }
      return instance;
    }
  };
})();

// Использование
const db1 = DatabaseConnection.getInstance('mongodb://localhost:27017');
const db2 = DatabaseConnection.getInstance('mongodb://localhost:27018');

console.log(db1 === db2); // true
```

### Плюсы и минусы

**Плюсы:**
- Гарантирует наличие единственного экземпляра класса
- Предоставляет глобальную точку доступа
- Ленивая инициализация

**Минусы:**
- Нарушает принцип единственной ответственности
- Может скрыть плохой дизайн
- Проблемы с тестированием
- Проблемы с многопоточностью

## Factory Method

### Описание

Factory Method определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта. Это позволяет делегировать создание объектов подклассам.

### Проблема

Приложение должно быть способно создавать объекты без указания конкретных классов, из которых должны быть созданы объекты.

### Решение

Определить интерфейс для создания объекта, но позволить подклассам решать, какой класс инстанцировать.

### Реализация

```javascript
// Абстрактный класс продукта
class Button {
  render() {
    throw new Error('Method render() must be implemented');
  }
}

// Конкретные продукты
class WindowsButton extends Button {
  render() {
    return '<button class="windows-button">Windows Button</button>';
  }
}

class MacButton extends Button {
  render() {
    return '<button class="mac-button">Mac Button</button>';
  }
}

class LinuxButton extends Button {
  render() {
    return '<button class="linux-button">Linux Button</button>';
  }
}

// Создатель (Creator)
class Dialog {
  // Фабричный метод
  createButton() {
    throw new Error('createButton() method must be implemented');
  }
  
  render() {
    const button = this.createButton();
    return `
      <div class="dialog">
        ${button.render()}
      </div>
    `;
  }
}

// Конкретные создатели
class WindowsDialog extends Dialog {
  createButton() {
    return new WindowsButton();
  }
}

class MacDialog extends Dialog {
  createButton() {
    return new MacButton();
  }
}

class LinuxDialog extends Dialog {
  createButton() {
    return new LinuxButton();
  }
}

// Использование
const windowsDialog = new WindowsDialog();
const macDialog = new MacDialog();

console.log(windowsDialog.render());
console.log(macDialog.render());
```

### Реализация с фабричной функцией

```javascript
// Фабричная функция для создания кнопок
const createButton = (type) => {
  switch (type) {
    case 'windows':
      return new WindowsButton();
    case 'mac':
      return new MacButton();
    case 'linux':
      return new LinuxButton();
    default:
      throw new Error(`Unknown button type: ${type}`);
  }
};

// Использование
const button = createButton('windows');
console.log(button.render());
```

## Abstract Factory

### Описание

Abstract Factory предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов.

### Проблема

Необходимо создавать семейства связанных объектов, при этом изолировать клиентский код от конкретных классов создаваемых объектов.

### Решение

Определить интерфейс для создания семейств объектов, а затем реализовать этот интерфейс для различных семейств объектов.

### Реализация

```javascript
// Абстрактные продукты
class Button {
  render() {
    throw new Error('render() method must be implemented');
  }
}

class Checkbox {
  render() {
    throw new Error('render() method must be implemented');
  }
}

// Конкретные продукты для Windows
class WindowsButton extends Button {
  render() {
    return '<button class="windows-button">Windows Button</button>';
  }
}

class WindowsCheckbox extends Checkbox {
  render() {
    return '<input type="checkbox" class="windows-checkbox">';
  }
}

// Конкретные продукты для Mac
class MacButton extends Button {
  render() {
    return '<button class="mac-button">Mac Button</button>';
  }
}

class MacCheckbox extends Checkbox {
  render() {
    return '<input type="checkbox" class="mac-checkbox">';
  }
}

// Абстрактная фабрика
class GUIFactory {
  createButton() {
    throw new Error('createButton() method must be implemented');
  }
  
  createCheckbox() {
    throw new Error('createCheckbox() method must be implemented');
  }
}

// Конкретные фабрики
class WindowsFactory extends GUIFactory {
  createButton() {
    return new WindowsButton();
  }
  
  createCheckbox() {
    return new WindowsCheckbox();
  }
}

class MacFactory extends GUIFactory {
  createButton() {
    return new MacButton();
  }
  
  createCheckbox() {
    return new MacCheckbox();
  }
}

// Клиентский код
class Application {
  constructor(factory) {
    this.factory = factory;
    this.button = null;
    this.checkbox = null;
  }
  
  createUI() {
    this.button = this.factory.createButton();
    this.checkbox = this.factory.createCheckbox();
  }
  
  render() {
    return `
      <div class="application">
        ${this.button.render()}
        ${this.checkbox.render()}
      </div>
    `;
  }
}

// Использование
const windowsApp = new Application(new WindowsFactory());
windowsApp.createUI();
console.log(windowsApp.render());

const macApp = new Application(new MacFactory());
macApp.createUI();
console.log(macApp.render());
```

## Builder

### Описание

Builder позволяет создавать сложные объекты пошагово. Паттерн позволяет производить различные типы и представления объекта, используя один и тот же процесс построения.

### Проблема

Создание сложных объектов с множеством параметров и опциональных компонентов может привести к громоздким конструкторам и неудобству использования.

### Решение

Разделить создание объекта на несколько шагов, каждый из которых отвечает за добавление определенной части объекта.

### Реализация

```javascript
// Продукт
class Car {
  constructor() {
    this.type = null;
    this.engine = null;
    this.wheels = null;
    this.color = null;
    this.gps = false;
    this.tripComputer = false;
  }
  
  toString() {
    return `
      Car: ${this.type}
      Engine: ${this.engine}
      Wheels: ${this.wheels}
      Color: ${this.color}
      GPS: ${this.gps ? 'Yes' : 'No'}
      Trip Computer: ${this.tripComputer ? 'Yes' : 'No'}
    `;
  }
}

// Строитель
class CarBuilder {
  constructor() {
    this.car = new Car();
  }
  
  setType(type) {
    this.car.type = type;
    return this;
  }
  
  setEngine(engine) {
    this.car.engine = engine;
    return this;
  }
  
  setWheels(wheels) {
    this.car.wheels = wheels;
    return this;
  }
  
  setColor(color) {
    this.car.color = color;
    return this;
  }
  
  setGPS(hasGPS) {
    this.car.gps = hasGPS;
    return this;
  }
  
  setTripComputer(hasTripComputer) {
    this.car.tripComputer = hasTripComputer;
    return this;
  }
  
  build() {
    const result = this.car;
    this.car = new Car(); // Сброс для следующего билда
    return result;
  }
}

// Директор (опциональный)
class CarDirector {
  constructor(builder) {
    this.builder = builder;
  }
  
  constructSportsCar() {
    return this.builder
      .setType('Sports')
      .setEngine('V8')
      .setWheels(4)
      .setColor('Red')
      .setGPS(true)
      .setTripComputer(true)
      .build();
  }
  
  constructFamilyCar() {
    return this.builder
      .setType('Family')
      .setEngine('V4')
      .setWheels(4)
      .setColor('Blue')
      .setGPS(false)
      .setTripComputer(true)
      .build();
  }
}

// Использование
const carBuilder = new CarBuilder();
const director = new CarDirector(carBuilder);

const sportsCar = director.constructSportsCar();
const familyCar = director.constructFamilyCar();

console.log(sportsCar.toString());
console.log(familyCar.toString());

// Или создание вручную
const customCar = new CarBuilder()
  .setType('Custom')
  .setEngine('V6')
  .setWheels(4)
  .setColor('Black')
  .setGPS(true)
  .build();

console.log(customCar.toString());
```

## Prototype

### Описание

Prototype позволяет копировать объекты, не создавая зависимости от их конкретных классов. Вместо создания нового экземпляра, объект-прототип клонируется.

### Проблема

Необходимость создания новых объектов, которые похожи на уже существующие, но с небольшими изменениями.

### Решение

Определить интерфейс для клонирования объектов и использовать существующий объект в качестве прототипа для создания новых объектов.

### Реализация

```javascript
// Прототип
class Shape {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  
  clone() {
    return new this.constructor(this.x, this.y);
  }
  
  draw() {
    throw new Error('draw() method must be implemented');
  }
}

// Конкретные реализации
class Rectangle extends Shape {
  constructor(x, y, width, height) {
    super(x, y);
    this.width = width;
    this.height = height;
  }
  
  clone() {
    const clone = super.clone();
    clone.width = this.width;
    clone.height = this.height;
    return clone;
  }
  
  draw() {
    return `Drawing rectangle at (${this.x}, ${this.y}) with width ${this.width} and height ${this.height}`;
  }
}

class Circle extends Shape {
  constructor(x, y, radius) {
    super(x, y);
    this.radius = radius;
  }
  
  clone() {
    const clone = super.clone();
    clone.radius = this.radius;
    return clone;
  }
  
  draw() {
    return `Drawing circle at (${this.x}, ${this.y}) with radius ${this.radius}`;
  }
}

// Регистр прототипов
class ShapeRegistry {
  constructor() {
    this.shapes = new Map();
  }
  
  addShape(key, shape) {
    this.shapes.set(key, shape);
  }
  
  getShape(key) {
    const shape = this.shapes.get(key);
    return shape ? shape.clone() : null;
  }
}

// Использование
const registry = new ShapeRegistry();

// Регистрация прототипов
const rectanglePrototype = new Rectangle(0, 0, 10, 5);
const circlePrototype = new Circle(0, 0, 5);

registry.addShape('rectangle', rectanglePrototype);
registry.addShape('circle', circlePrototype);

// Создание новых объектов из прототипов
const newRectangle = registry.getShape('rectangle');
newRectangle.x = 10;
newRectangle.y = 10;

const newCircle = registry.getShape('circle');
newCircle.x = 20;
newCircle.y = 20;

console.log(newRectangle.draw()); // Drawing rectangle at (10, 10) with width 10 and height 5
console.log(newCircle.draw());    // Drawing circle at (20, 20) with radius 5
```

## Сравнение паттернов

| Паттерн | Назначение | Когда использовать |
|---------|------------|-------------------|
| Singleton | Гарантия одного экземпляра | Когда нужен только один экземпляр класса |
| Factory Method | Делегирование создания подклассам | Когда подклассы определяют создаваемый тип |
| Abstract Factory | Создание семейств связанных объектов | Когда нужно создавать связанные объекты |
| Builder | Пошаговое создание сложных объектов | Когда объекты создаются в несколько этапов |
| Prototype | Копирование существующих объектов | Когда создание нового объекта дорого |

## Практические применения

### В веб-разработке

```javascript
// Пример использования Singleton для управления сессией
class SessionManager {
  constructor() {
    if (SessionManager.instance) {
      return SessionManager.instance;
    }
    
    this.sessionData = {};
    SessionManager.instance = this;
    return this;
  }
  
  set(key, value) {
    this.sessionData[key] = value;
  }
  
  get(key) {
    return this.sessionData[key];
  }
  
  clear() {
    this.sessionData = {};
  }
}

// Пример использования Factory Method для создания API клиентов
class ApiClientFactory {
  static createClient(type, config) {
    switch (type) {
      case 'rest':
        return new RestApiClient(config);
      case 'graphql':
        return new GraphqlApiClient(config);
      default:
        throw new Error(`Unknown client type: ${type}`);
    }
  }
}
```

## Заключение

Порождающие паттерны проектирования предоставляют гибкие решения для создания объектов. Каждый паттерн решает конкретную проблему создания объектов:

- **Singleton** - управление единственным экземпляром
- **Factory Method** - делегирование создания подклассам
- **Abstract Factory** - создание семейств связанных объектов
- **Builder** - пошаговое создание сложных объектов
- **Prototype** - копирование существующих объектов

Правильный выбор и применение этих паттернов делает код более гибким, повторно используемым и легко поддерживаемым.

## Связанные концепции

- [[Структурные паттерны проектирования]] - структурные паттерны
- [[Поведенческие паттерны проектирования]] - поведенческие паттерны
- [[Design Principles]] - принципы проектирования
- [[Object-Oriented Programming]] - объектно-ориентированное программирование
- [[Creational Patterns in JavaScript]] - порождающие паттерны в JavaScript