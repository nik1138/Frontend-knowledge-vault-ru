---
aliases: [Рекурсивные алгоритмы, Рекурсивные функции, Рекурсивное программирование]
tags: [programming, algorithms, recursion, frontend]
---

# Рекурсия

Рекурсия — это метод программирования, при котором функция вызывает саму себя для решения задачи. Это мощный инструмент, особенно полезный при работе с древовидными структурами данных, обходом DOM, обработкой вложенных компонентов и другими задачами, которые можно разбить на подобные меньшие задачи.

## Основные понятия рекурсии

Любая рекурсивная функция должна содержать:

1. **Базовый случай (base case)** — условие, при котором рекурсия прекращается
2. **Рекурсивный случай (recursive case)** — вызов функции с измененными параметрами

```javascript
// Простой пример: вычисление факториала
function factorial(n) {
    // Базовый случай
    if (n <= 1) {
        return 1;
    }
    
    // Рекурсивный случай
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```

## Примеры рекурсивных алгоритмов

### Вычисление чисел Фибоначчи

```javascript
function fibonacci(n) {
    // Базовые случаи
    if (n <= 1) {
        return n;
    }
    
    // Рекурсивный случай
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Более эффективная версия с мемоизацией
function fibonacciMemo(n, memo = {}) {
    if (n in memo) {
        return memo[n];
    }
    
    if (n <= 1) {
        return n;
    }
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}
```

### Обход дерева DOM

Рекурсия особенно полезна при работе с DOM-деревом:

```javascript
// Рекурсивный обход всех элементов DOM
function traverseDOM(element, callback) {
    // Выполняем действие над текущим элементом
    callback(element);
    
    // Рекурсивно обходим всех детей
    for (let child of element.children) {
        traverseDOM(child, callback);
    }
}

// Пример использования: поиск всех элементов с определенным классом
function findElementsByClass(element, className, results = []) {
    if (element.classList && element.classList.contains(className)) {
        results.push(element);
    }
    
    for (let child of element.children) {
        findElementsByClass(child, className, results);
    }
    
    return results;
}
```

### Обработка вложенных структур данных

```javascript
// Рекурсивный поиск в объекте
function findInObject(obj, key, value) {
    if (obj[key] === value) {
        return obj;
    }
    
    for (let prop in obj) {
        if (obj[prop] !== null && typeof obj[prop] === 'object') {
            const found = findInObject(obj[prop], key, value);
            if (found) return found;
        }
    }
    
    return null;
}

// Рекурсивное суммирование значений в дереве
function sumTree(node) {
    if (!node) return 0;
    
    let sum = node.value || 0;
    
    if (node.children) {
        for (let child of node.children) {
            sum += sumTree(child);
        }
    }
    
    return sum;
}
```

## Рекурсия в фронтенд-разработке

### Обработка вложенных компонентов React

```javascript
// Рекурсивный компонент для отображения дерева
function TreeNode({ node }) {
    if (!node) return null;
    
    return (
        <div className="tree-node">
            <div>{node.name}</div>
            {node.children && node.children.map((child, index) => (
                <TreeNode key={index} node={child} />
            ))}
        </div>
    );
}

// Использование
const treeData = {
    name: 'Root',
    children: [
        { name: 'Child 1', children: [{ name: 'Grandchild 1' }] },
        { name: 'Child 2', children: [{ name: 'Grandchild 2' }] }
    ]
};

function TreeView() {
    return <TreeNode node={treeData} />;
}
```

### Рекурсивная валидация форм

```javascript
// Рекурсивная валидация вложенных форм
function validateForm(formData, validationRules) {
    const errors = {};
    
    for (let field in validationRules) {
        const rule = validationRules[field];
        const value = formData[field];
        
        if (typeof rule === 'object' && !Array.isArray(rule) && rule !== null) {
            // Вложенная структура - рекурсивный вызов
            errors[field] = validateForm(value, rule);
        } else if (typeof rule === 'function') {
            // Простая валидация
            const error = rule(value);
            if (error) {
                errors[field] = error;
            }
        }
    }
    
    return errors;
}
```

### Рекурсивная фильтрация данных

```javascript
// Рекурсивная фильтрация дерева данных
function filterTree(tree, predicate) {
    if (!tree) return null;
    
    // Проверяем текущий узел
    const matches = predicate(tree);
    
    // Рекурсивно фильтруем детей
    const filteredChildren = tree.children 
        ? tree.children.map(child => filterTree(child, predicate)).filter(Boolean)
        : [];
    
    // Если узел соответствует или имеет подходящих детей - возвращаем его
    if (matches || filteredChildren.length > 0) {
        return {
            ...tree,
            children: filteredChildren
        };
    }
    
    return null;
}
```

## Оптимизация рекурсии

### Хвостовая рекурсия (Tail Recursion)

Некоторые языки поддерживают оптимизацию хвостовой рекурсии, но JavaScript в браузерах обычно не оптимизирует рекурсивные вызовы:

```javascript
// Хвостовая рекурсия для вычисления факториала
function factorialTail(n, accumulator = 1) {
    if (n <= 1) {
        return accumulator;
    }
    
    return factorialTail(n - 1, n * accumulator);
}

// Вспомогательная функция для безопасного выполнения рекурсии
function safeRecursion(fn, ...args) {
    try {
        return fn(...args);
    } catch (e) {
        if (e instanceof RangeError && e.message.includes('Maximum call stack')) {
            throw new Error('Превышена глубина рекурсии. Рассмотрите итеративное решение.');
        }
        throw e;
    }
}
```

### Преобразование рекурсии в итерацию

Для избежания переполнения стека:

```javascript
// Итеративная версия обхода дерева
function iterativeTreeTraversal(root) {
    if (!root) return [];
    
    const stack = [root];
    const result = [];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.value);
        
        // Добавляем детей в стек (в обратном порядке для сохранения порядка)
        if (node.children) {
            for (let i = node.children.length - 1; i >= 0; i--) {
                stack.push(node.children[i]);
            }
        }
    }
    
    return result;
}
```

## Практические советы по использованию рекурсии

> [!tip] Совет
> Всегда определяйте базовый случай до написания рекурсивного вызова, чтобы избежать бесконечной рекурсии.

### Когда использовать рекурсию

Рекурсия особенно полезна в следующих случаях:

- Обход древовидных структур (DOM, JSON, файловые системы)
- Разбор вложенных структур данных
- Алгоритмы "разделяй и властвуй"
- Математические вычисления (факториал, числа Фибоначчи)
- Обработка вложенных компонентов в UI

### Когда избегать рекурсии

- При работе с очень глубокими структурами (риск переполнения стека)
- Когда задачу можно решить проще итеративно
- В производственном коде с жесткими требованиями к производительности

## Примеры сложных рекурсивных задач

### Глубокое копирование объекта

```javascript
function deepCopy(obj, visited = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // Обработка циклических ссылок
    if (visited.has(obj)) {
        return visited.get(obj);
    }
    
    let cloned;
    
    if (Array.isArray(obj)) {
        cloned = [];
        visited.set(obj, cloned);
        for (let i = 0; i < obj.length; i++) {
            cloned[i] = deepCopy(obj[i], visited);
        }
    } else {
        cloned = {};
        visited.set(obj, cloned);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                cloned[key] = deepCopy(obj[key], visited);
            }
        }
    }
    
    return cloned;
}
```

### Рекурсивное вычисление вложенных значений

```javascript
// Вычисление вложенного выражения
function evaluateExpression(expr) {
    if (typeof expr === 'number') {
        return expr;
    }
    
    if (typeof expr === 'string') {
        return parseFloat(expr) || expr;
    }
    
    if (Array.isArray(expr)) {
        const [operator, ...operands] = expr;
        
        switch (operator) {
            case '+':
                return operands.reduce((sum, operand) => sum + evaluateExpression(operand), 0);
            case '*':
                return operands.reduce((product, operand) => product * evaluateExpression(operand), 1);
            case '-':
                if (operands.length === 1) {
                    return -evaluateExpression(operands[0]);
                }
                return evaluateExpression(operands[0]) - evaluateExpression(operands[1]);
            default:
                throw new Error(`Неизвестный оператор: ${operator}`);
        }
    }
    
    throw new Error('Неподдерживаемый тип выражения');
}

// Пример: ['+', 1, ['*', 2, 3], 4] = 1 + (2 * 3) + 4 = 11
console.log(evaluateExpression(['+', 1, ['*', 2, 3], 4])); // 11
```

## Связанные концепции

- [[Алгоритмы-поиска]] - рекурсия используется в алгоритмах поиска (DFS)
- [[Алгоритмы-сортировки]] - некоторые алгоритмы сортировки используют рекурсию (QuickSort, MergeSort)
- [[Графовые-алгоритмы]] - обход графов часто реализуется рекурсивно
- [[Структуры-данных]] - рекурсия особенно полезна для работы с древовидными структурами

## Заключение

Рекурсия — мощный инструмент в арсенале фронтенд-разработчика. Она особенно полезна при работе с древовидными структурами данных, такими как DOM, JSON-объекты и компоненты интерфейса. Понимание принципов рекурсии помогает писать более чистый и выразительный код для обработки вложенных структур.