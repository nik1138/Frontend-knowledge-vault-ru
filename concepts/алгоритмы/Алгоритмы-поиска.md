---
aliases: [Поиск, Поисковые алгоритмы, Алгоритмы поиска]
tags: [programming, algorithms, search, frontend]
---

# Алгоритмы поиска

Алгоритмы поиска являются фундаментальной частью программирования и особенно важны для фронтенд-разработчиков, так как часто используются в интерактивных интерфейсах, фильтрации данных и навигации.

## Основные типы поиска

### Линейный поиск (Sequential Search)

Самый простой алгоритм поиска, который проверяет каждый элемент в списке по порядку до нахождения искомого значения.

```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Возвращаем индекс найденного элемента
        }
    }
    return -1; // Возвращаем -1, если элемент не найден
}

// Пример использования
const numbers = [10, 20, 30, 40, 50];
console.log(linearSearch(numbers, 30)); // 2
```

**Временная сложность:** O(n)

### Бинарный поиск (Binary Search)

Эффективный алгоритм поиска в отсортированном массиве. Работает за O(log n) время.

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// Пример использования
const sortedNumbers = [10, 20, 30, 40, 50, 60, 70];
console.log(binarySearch(sortedNumbers, 40)); // 3
```

**Важное ограничение:** Массив должен быть отсортирован.

## Практическое применение в фронтенде

### Поиск в пользовательском интерфейсе

Часто используется для реализации поиска по спискам элементов:

```javascript
// Функция для фильтрации списка пользователей
function searchUsers(users, searchTerm) {
    return users.filter(user => 
        user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.email.toLowerCase().includes(searchTerm.toLowerCase())
    );
}

// Пример использования в React-компоненте
function UserSearch({ users }) {
    const [searchTerm, setSearchTerm] = useState('');
    const [filteredUsers, setFilteredUsers] = useState(users);
    
    useEffect(() => {
        if (searchTerm) {
            setFilteredUsers(searchUsers(users, searchTerm));
        } else {
            setFilteredUsers(users);
        }
    }, [searchTerm]);
    
    return (
        <div>
            <input 
                type="text" 
                placeholder="Поиск пользователей..." 
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
            />
            <ul>
                {filteredUsers.map(user => (
                    <li key={user.id}>{user.name} - {user.email}</li>
                ))}
            </ul>
        </div>
    );
}
```

### Поиск в структурах данных

```javascript
// Поиск в дереве DOM
function findElementByAttribute(rootElement, attributeName, attributeValue) {
    if (rootElement.getAttribute(attributeName) === attributeValue) {
        return rootElement;
    }
    
    for (let child of rootElement.children) {
        const found = findElementByAttribute(child, attributeName, attributeValue);
        if (found) return found;
    }
    
    return null;
}
```

## Алгоритмы поиска в строках

### Алгоритм Кнута-Морриса-Пратта (KMP)

Полезен для поиска подстроки в строке без возврата к предыдущим символам.

```javascript
function buildLPS(pattern) {
    const lps = new Array(pattern.length).fill(0);
    let len = 0;
    let i = 1;
    
    while (i < pattern.length) {
        if (pattern[i] === pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len !== 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

function kmpSearch(text, pattern) {
    const lps = buildLPS(pattern);
    let i = 0; // индекс для text
    let j = 0; // индекс для pattern
    
    while (i < text.length) {
        if (pattern[j] === text[i]) {
            i++;
            j++;
        }
        
        if (j === pattern.length) {
            return i - j; // Найдено совпадение
        } else if (i < text.length && pattern[j] !== text[i]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return -1; // Совпадение не найдено
}
```

## Практические советы для фронтенд-разработчиков

> [!tip] Совет
> Для простых случаев поиска по массиву используйте встроенные методы JavaScript:
> - `array.find()` - для поиска первого элемента, соответствующего условию
> - `array.findIndex()` - для получения индекса первого элемента
> - `array.includes()` - для проверки наличия элемента

### Оптимизация поиска

При работе с большими наборами данных:

1. **Используйте индексы** - создавайте хэш-таблицы для быстрого доступа
2. **Ограничивайте объем данных** - фильтруйте до поиска
3. **Используйте виртуализацию** - при отображении результатов

```javascript
// Создание индекса для быстрого поиска
class SearchIndex {
    constructor(data) {
        this.index = new Map();
        data.forEach((item, index) => {
            // Индексация по ключевым полям
            const key = item.id || index;
            this.index.set(key, item);
        });
    }
    
    findById(id) {
        return this.index.get(id);
    }
    
    searchByField(field, value) {
        const results = [];
        for (const [key, item] of this.index) {
            if (item[field] === value) {
                results.push(item);
            }
        }
        return results;
    }
}
```

## Связанные концепции

- [[Алгоритмы-сортировки]] - часто используется в сочетании с бинарным поиском
- [[Рекурсия]] - основа для некоторых алгоритмов поиска
- [[Графовые-алгоритмы]] - поиск в графах (DFS, BFS)
- [[Структуры-данных]] - эффективные структуры для поиска

## Заключение

Алгоритмы поиска играют важную роль в разработке интерактивных веб-приложений. Понимание различных подходов к поиску позволяет создавать более эффективные и отзывчивые пользовательские интерфейсы.