---
aliases: [Сортировка, Алгоритмы сортировки, Сортировки]
tags: [programming, algorithms, sorting, frontend]
---

# Алгоритмы сортировки

Алгоритмы сортировки являются основой эффективного программирования и особенно важны для фронтенд-разработчиков, так как часто используются для упорядочивания данных в интерфейсах, таблицах, списках и других элементах пользовательского интерфейса.

## Встроенные методы сортировки JavaScript

JavaScript предоставляет встроенный метод `Array.prototype.sort()`, который по умолчанию сортирует элементы как строки:

```javascript
// Сортировка чисел (внимание: по умолчанию сортирует как строки!)
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];
console.log(numbers.sort()); // ["1", "1", "2", "3", "4", "5", "6", "9"]

// Правильная сортировка чисел
const sortedNumbers = [3, 1, 4, 1, 5, 9, 2, 6];
console.log(sortedNumbers.sort((a, b) => a - b)); // [1, 1, 2, 3, 4, 5, 6, 9]

// Сортировка объектов
const users = [
    { name: 'Иван', age: 30 },
    { name: 'Мария', age: 25 },
    { name: 'Алексей', age: 35 }
];

// Сортировка по возрасту
users.sort((a, b) => a.age - b.age);
console.log(users);

// Сортировка по строке (по алфавиту)
users.sort((a, b) => a.name.localeCompare(b.name));
console.log(users);
```

## Основные алгоритмы сортировки

### Сортировка пузырьком (Bubble Sort)

Простой, но неэффективный алгоритм, полезный для обучения:

```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Меняем местами элементы
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

// Пример использования
console.log(bubbleSort([64, 34, 25, 12, 22, 11, 90]));
// [11, 12, 22, 25, 34, 64, 90]
```

**Временная сложность:** O(n²)

### Сортировка вставками (Insertion Sort)

Эффективна для небольших массивов или почти отсортированных данных:

```javascript
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let current = arr[i];
        let j = i - 1;
        
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = current;
    }
    return arr;
}

// Пример использования
console.log(insertionSort([64, 34, 25, 12, 22, 11, 90]));
// [11, 12, 22, 25, 34, 64, 90]
```

**Временная сложность:** O(n²), но O(n) для почти отсортированных данных

### Сортировка выбором (Selection Sort)

Находит минимальный элемент и помещает его в начало:

```javascript
function selectionSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        let minIndex = i;
        
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }
    
    return arr;
}

// Пример использования
console.log(selectionSort([64, 34, 25, 12, 22, 11, 90]));
// [11, 12, 22, 25, 34, 64, 90]
```

### Быстрая сортировка (Quick Sort)

Один из самых эффективных алгоритмов сортировки:

```javascript
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = [];
    const right = [];
    const equal = [];
    
    for (let element of arr) {
        if (element < pivot) {
            left.push(element);
        } else if (element > pivot) {
            right.push(element);
        } else {
            equal.push(element);
        }
    }
    
    return [...quickSort(left), ...equal, ...quickSort(right)];
}

// Пример использования
console.log(quickSort([64, 34, 25, 12, 22, 11, 90]));
// [11, 12, 22, 25, 34, 64, 90]
```

**Временная сложность:** O(n log n) в среднем случае, O(n²) в худшем случае

### Сортировка слиянием (Merge Sort)

Стабильный алгоритм с гарантированной сложностью O(n log n):

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    return result
        .concat(left.slice(leftIndex))
        .concat(right.slice(rightIndex));
}

// Пример использования
console.log(mergeSort([64, 34, 25, 12, 22, 11, 90]));
// [11, 12, 22, 25, 34, 64, 90]
```

## Практическое применение в фронтенде

### Сортировка данных в таблицах

```javascript
// Компонент сортировки таблицы в React
function SortableTable({ data, columns }) {
    const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
    
    const sortedData = useMemo(() => {
        if (!sortConfig.key) return data;
        
        return [...data].sort((a, b) => {
            if (a[sortConfig.key] < b[sortConfig.key]) {
                return sortConfig.direction === 'asc' ? -1 : 1;
            }
            if (a[sortConfig.key] > b[sortConfig.key]) {
                return sortConfig.direction === 'asc' ? 1 : -1;
            }
            return 0;
        });
    }, [data, sortConfig]);
    
    const handleSort = (key) => {
        let direction = 'asc';
        if (sortConfig.key === key && sortConfig.direction === 'asc') {
            direction = 'desc';
        }
        setSortConfig({ key, direction });
    };
    
    return (
        <table>
            <thead>
                <tr>
                    {columns.map(column => (
                        <th 
                            key={column.key} 
                            onClick={() => handleSort(column.key)}
                        >
                            {column.label}
                            {sortConfig.key === column.key && (
                                sortConfig.direction === 'asc' ? ' ↑' : ' ↓'
                            )}
                        </th>
                    ))}
                </tr>
            </thead>
            <tbody>
                {sortedData.map((row, index) => (
                    <tr key={index}>
                        {columns.map(column => (
                            <td key={column.key}>{row[column.key]}</td>
                        ))}
                    </tr>
                ))}
            </tbody>
        </table>
    );
}
```

### Сортировка в списке задач

```javascript
// Управление сортировкой списка задач
class TaskManager {
    constructor() {
        this.tasks = [];
    }
    
    addTask(task) {
        this.tasks.push(task);
    }
    
    sortTasks(sortBy = 'priority', order = 'asc') {
        return this.tasks.sort((a, b) => {
            let comparison = 0;
            
            switch(sortBy) {
                case 'priority':
                    comparison = a.priority - b.priority;
                    break;
                case 'dueDate':
                    comparison = new Date(a.dueDate) - new Date(b.dueDate);
                    break;
                case 'title':
                    comparison = a.title.localeCompare(b.title);
                    break;
            }
            
            return order === 'asc' ? comparison : -comparison;
        });
    }
    
    getSortedTasks(sortBy, order) {
        return [...this.sortTasks(sortBy, order)];
    }
}
```

## Оптимизация сортировки в браузере

### Виртуальная сортировка

При работе с большими наборами данных:

```javascript
// Виртуальный скроллинг с сортировкой
function VirtualSortedList({ items, sortConfig, onSortChange }) {
    const [displayedItems, setDisplayedItems] = useState([]);
    
    useEffect(() => {
        // Сортируем только отображаемые элементы
        const sorted = [...items]
            .sort((a, b) => {
                // Логика сортировки
                if (a[sortConfig.key] < b[sortConfig.key]) {
                    return sortConfig.direction === 'asc' ? -1 : 1;
                }
                return sortConfig.direction === 'asc' ? 1 : -1;
            })
            .slice(0, 100); // Ограничиваем количество элементов
        
        setDisplayedItems(sorted);
    }, [items, sortConfig]);
    
    return (
        <div>
            {displayedItems.map(item => (
                <div key={item.id}>{item.content}</div>
            ))}
        </div>
    );
}
```

## Практические советы для фронтенд-разработчиков

> [!tip] Совет
> Используйте встроенную сортировку JavaScript для большинства случаев, так как она оптимизирована движком. Писать свои алгоритмы сортировки стоит только в особых случаях.

### Когда использовать каждый алгоритм

| Алгоритм | Лучшее применение | Временная сложность |
|----------|------------------|-------------------|
| Встроенная сортировка | Общее использование | O(n log n) |
| Быстрая сортировка | Средние и большие массивы | O(n log n) |
| Сортировка вставками | Маленькие массивы или почти отсортированные | O(n) для отсортированных |
| Сортировка слиянием | Когда нужна стабильность | O(n log n) |
| Сортировка пузырьком | Образовательные цели | O(n²) |

### Память и производительность

```javascript
// Оптимизация сортировки с учетом производительности
function efficientSort(array, compareFunction) {
    // Для маленьких массивов используем вставки
    if (array.length < 10) {
        return insertionSort([...array], compareFunction);
    }
    
    // Для стабильной сортировки используем встроенную
    if (compareFunction && compareFunction.isStable) {
        return [...array].sort(compareFunction);
    }
    
    // Для остальных случаев - быстрая сортировка
    return quickSort([...array], compareFunction);
}
```

## Связанные концепции

- [[Алгоритмы-поиска]] - часто используется в сочетании с сортировкой
- [[Структуры-данных]] - эффективные структуры для сортировки
- [[Рекурсия]] - основа для некоторых алгоритмов сортировки
- [[Алгоритмы-сортировки-в-React]] - специфика работы с сортировкой в React

## Заключение

Алгоритмы сортировки играют важную роль в создании интерактивных интерфейсов. Понимание различных подходов позволяет выбирать наиболее подходящий метод в зависимости от размера данных, частоты сортировки и требований к производительности.