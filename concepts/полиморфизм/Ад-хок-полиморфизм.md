---
aliases: ["Ад-хок полиморфизм", "Ad-hoc полиморфизм"]
tags: ["#polymorphism", "#programming", "#typescript", "#javascript", "#functional-programming"]
---

# Ад-хок-полиморфизм

## Введение

Ад-хок полиморфизм (от лат. ad hoc — «для этого») — это форма полиморфизма, при которой одна и та же сущность (например, функция или оператор) может работать с аргументами разных типов, при этом для каждого типа может быть реализована своя специфическая реализация. В отличие от параметрического полиморфизма, где одна реализация работает со всеми типами, ад-хок полиморфизм предоставляет разные реализации для разных типов.

Термин "ад-хок полиморфизм" был введен Кристофером Стравинским в контексте теории типов, и он охватывает такие концепции, как перегрузка функций, перегрузка операторов и type classes (в функциональных языках).

## Характеристики ад-хок полиморфизма

### Основные особенности

1. **Разные реализации для разных типов** - каждому типу может соответствовать своя реализация функции
2. **Статическое разрешение** - тип выбирается на этапе компиляции, а не во время выполнения
3. **Ограничение по типам** - может работать только с теми типами, для которых определена реализация
4. **Повышение выразительности** - позволяет использовать одинаковые имена для операций над разными типами

### Отличие от других типов полиморфизма

- **Параметрический полиморфизм**: одна реализация для всех типов
- **Подтиповый полиморфизм**: использование объектов подтипов там, где ожидаются объекты супертипов
- **Ад-хок полиморфизм**: разные реализации для разных типов

## Ад-хок полиморфизм в различных языках

### 1. C++ - перегрузка функций

```cpp
#include <iostream>
#include <string>

// Перегрузка функции для разных типов
void print(int value) {
    std::cout << "Integer: " << value << std::endl;
}

void print(double value) {
    std::cout << "Double: " << value << std::endl;
}

void print(const std::string& value) {
    std::cout << "String: " << value << std::endl;
}

int main() {
    print(42);           // Вызовет print(int)
    print(3.14);         // Вызовет print(double)
    print("Hello");      // Вызовет print(const std::string&)
    
    return 0;
}
```

### 2. Java - перегрузка методов

```java
public class Calculator {
    // Перегрузка метода для разных типов
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

// Использование
Calculator calc = new Calculator();
System.out.println(calc.add(1, 2));           // 3
System.out.println(calc.add(1.5, 2.5));       // 4.0
System.out.println(calc.add("Hello", "World")); // HelloWorld
System.out.println(calc.add(1, 2, 3));        // 6
```

### 3. Haskell - Type Classes

```haskell
-- Определение type class
class Printable a where
    printValue :: a -> String

-- Экземпляры type class для разных типов
instance Printable Int where
    printValue x = "Integer: " ++ show x

instance Printable String where
    printValue x = "String: " ++ x

instance Printable Bool where
    printValue x = "Boolean: " ++ show x

-- Использование
main = do
    putStrLn $ printValue (42 :: Int)      -- "Integer: 42"
    putStrLn $ printValue "Hello"          -- "String: Hello"
    putStrLn $ printValue True             -- "Boolean: True"
```

## Ад-хок полиморфизм в JavaScript и TypeScript

### 1. Перегрузка функций в TypeScript

TypeScript поддерживает перегрузку функций, что позволяет реализовать ад-хок полиморфизм:

```typescript
// Объявление перегрузок
function format(value: string): string;
function format(value: number): string;
function format(value: boolean): string;
function format(value: Date): string;

// Реализация
function format(value: string | number | boolean | Date): string {
    if (typeof value === 'string') {
        return `String: ${value}`;
    } else if (typeof value === 'number') {
        return `Number: ${value}`;
    } else if (typeof value === 'boolean') {
        return `Boolean: ${value}`;
    } else if (value instanceof Date) {
        return `Date: ${value.toISOString()}`;
    } else {
        return `Unknown: ${value}`;
    }
}

// Использование
console.log(format("Hello"));     // "String: Hello"
console.log(format(42));          // "Number: 42"
console.log(format(true));        // "Boolean: true"
console.log(format(new Date()));  // "Date: 2023-12-01T10:00:00.000Z"
```

### 2. Использование Union Types и Type Guards

```typescript
type Shape = 'circle' | 'rectangle' | 'triangle';

interface Circle {
    kind: 'circle';
    radius: number;
}

interface Rectangle {
    kind: 'rectangle';
    width: number;
    height: number;
}

interface Triangle {
    kind: 'triangle';
    base: number;
    height: number;
}

function calculateArea(shape: Circle | Rectangle | Triangle): number {
    switch (shape.kind) {
        case 'circle':
            return Math.PI * shape.radius ** 2;
        case 'rectangle':
            return shape.width * shape.height;
        case 'triangle':
            return 0.5 * shape.base * shape.height;
        default:
            // Это обеспечит exhaustiveness check
            const _exhaustiveCheck: never = shape;
            return _exhaustiveCheck;
    }
}

// Использование
const circle: Circle = { kind: 'circle', radius: 5 };
const rectangle: Rectangle = { kind: 'rectangle', width: 4, height: 6 };
const triangle: Triangle = { kind: 'triangle', base: 3, height: 4 };

console.log(calculateArea(circle));     // 78.53981633974483
console.log(calculateArea(rectangle));  // 24
console.log(calculateArea(triangle));   // 6
```

### 3. Generic Functions с Constraints

```typescript
// Определение интерфейсов для различных типов
interface NumberLike {
    valueOf(): number;
}

interface StringLike {
    toString(): string;
}

// Функция с перегрузками для разных типов
function processValue<T extends NumberLike>(value: T): number;
function processValue<T extends StringLike>(value: T): string;
function processValue<T>(value: T): T;
function processValue<T>(value: T): any {
    if (typeof value === 'object' && value !== null && 'valueOf' in value) {
        return (value as NumberLike).valueOf();
    } else if (typeof value === 'object' && value !== null && 'toString' in value) {
        return (value as StringLike).toString();
    } else {
        return value;
    }
}

// Использование
console.log(processValue(42));           // 42
console.log(processValue("hello"));      // "hello"
console.log(processValue(new Date()));   // "Mon Dec 01 2023 13:00:00 GMT+0300"
```

### 4. Использование Discriminated Unions

```typescript
// Определение типов для ад-хок полиморфизма
interface Success {
    type: 'success';
    data: any;
    message: string;
}

interface Error {
    type: 'error';
    error: string;
    code: number;
}

interface Loading {
    type: 'loading';
    progress?: number;
}

type Result = Success | Error | Loading;

function handleResult(result: Result): string {
    switch (result.type) {
        case 'success':
            return `Success: ${result.message} with data: ${JSON.stringify(result.data)}`;
        case 'error':
            return `Error ${result.code}: ${result.error}`;
        case 'loading':
            return result.progress ? 
                `Loading: ${result.progress}%` : 
                'Loading...';
        default:
            // Exhaustiveness check
            const _exhaustiveCheck: never = result;
            return _exhaustiveCheck;
    }
}

// Использование
const success: Success = { 
    type: 'success', 
    data: { id: 1, name: 'John' }, 
    message: 'User loaded' 
};

const error: Error = { 
    type: 'error', 
    error: 'User not found', 
    code: 404 
};

const loading: Loading = { 
    type: 'loading', 
    progress: 75 
};

console.log(handleResult(success)); // "Success: User loaded with data: {...}"
console.log(handleResult(error));   // "Error 404: User not found"
console.log(handleResult(loading)); // "Loading: 75%"
```

## Практические примеры ад-хок полиморфизма

### 1. Универсальный сериализатор

```typescript
// Определение типов для сериализации
interface Serializable {
    serialize(): string;
}

// Классы с разными реализациями сериализации
class User implements Serializable {
    constructor(public name: string, public email: string) {}
    
    serialize(): string {
        return JSON.stringify({ type: 'user', name: this.name, email: this.email });
    }
}

class Product implements Serializable {
    constructor(public name: string, public price: number) {}
    
    serialize(): string {
        return JSON.stringify({ type: 'product', name: this.name, price: this.price });
    }
}

class Order implements Serializable {
    constructor(public id: number, public items: string[]) {}
    
    serialize(): string {
        return JSON.stringify({ type: 'order', id: this.id, items: this.items });
    }
}

// Ад-хок полиморфная функция сериализации
function serializeEntity(entity: Serializable): string {
    return entity.serialize();
}

// Использование
const user = new User("John Doe", "john@example.com");
const product = new Product("Laptop", 999.99);
const order = new Order(123, ["item1", "item2"]);

console.log(serializeEntity(user));    // {"type":"user","name":"John Doe","email":"john@example.com"}
console.log(serializeEntity(product)); // {"type":"product","name":"Laptop","price":999.99}
console.log(serializeEntity(order));   // {"type":"order","id":123,"items":["item1","item2"]}
```

### 2. Фабрика компонентов с ад-хок полиморфизмом

```typescript
// Типы компонентов
type ComponentType = 'button' | 'input' | 'select' | 'textarea';

// Интерфейсы для разных компонентов
interface BaseComponentProps {
    id: string;
    className?: string;
}

interface ButtonProps extends BaseComponentProps {
    type: 'button';
    text: string;
    variant: 'primary' | 'secondary' | 'danger';
    onClick: () => void;
}

interface InputProps extends BaseComponentProps {
    type: 'input';
    placeholder: string;
    value: string;
    onChange: (value: string) => void;
}

interface SelectProps extends BaseComponentProps {
    type: 'select';
    options: { value: string; label: string }[];
    value: string;
    onChange: (value: string) => void;
}

interface TextareaProps extends BaseComponentProps {
    type: 'textarea';
    placeholder: string;
    value: string;
    onChange: (value: string) => void;
    rows?: number;
}

type ComponentProps = ButtonProps | InputProps | SelectProps | TextareaProps;

// Ад-хок полиморфная функция для создания компонентов
function createComponent(props: ButtonProps): string;
function createComponent(props: InputProps): string;
function createComponent(props: SelectProps): string;
function createComponent(props: TextareaProps): string;
function createComponent(props: ComponentProps): string {
    const baseClass = `component ${props.className || ''}`;
    
    switch (props.type) {
        case 'button':
            return `<button id="${props.id}" class="${baseClass} btn-${props.variant}" onclick="${props.onClick}">${props.text}</button>`;
        
        case 'input':
            return `<input id="${props.id}" class="${baseClass}" placeholder="${props.placeholder}" value="${props.value}" onchange="this.onchange(this.value)" />`;
        
        case 'select':
            const options = props.options.map(opt => 
                `<option value="${opt.value}" ${opt.value === props.value ? 'selected' : ''}>${opt.label}</option>`
            ).join('');
            return `<select id="${props.id}" class="${baseClass}" onchange="this.onchange(this.value)">${options}</select>`;
        
        case 'textarea':
            return `<textarea id="${props.id}" class="${baseClass}" placeholder="${props.placeholder}" rows="${props.rows || 3}" onchange="this.onchange(this.value)">${props.value}</textarea>`;
        
        default:
            const _exhaustiveCheck: never = props;
            return _exhaustiveCheck;
    }
}

// Использование
const button = createComponent({
    type: 'button',
    id: 'submit-btn',
    text: 'Submit',
    variant: 'primary',
    className: 'form-button',
    onClick: () => console.log('Button clicked')
});

const input = createComponent({
    type: 'input',
    id: 'name-input',
    placeholder: 'Enter your name',
    value: '',
    className: 'form-input',
    onChange: (value) => console.log('Input changed:', value)
});
```

### 3. Валидатор с ад-хок полиморфизмом

```typescript
// Интерфейсы для разных типов валидации
interface StringValidator {
    type: 'string';
    value: string;
    minLength?: number;
    maxLength?: number;
    pattern?: RegExp;
}

interface NumberValidator {
    type: 'number';
    value: number;
    min?: number;
    max?: number;
}

interface ArrayValidator {
    type: 'array';
    value: any[];
    minLength?: number;
    maxLength?: number;
}

interface ObjectValidator {
    type: 'object';
    value: Record<string, any>;
    requiredKeys?: string[];
}

type Validator = StringValidator | NumberValidator | ArrayValidator | ObjectValidator;

// Результат валидации
interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

// Ад-хок полиморфная функция валидации
function validate(validator: StringValidator): ValidationResult;
function validate(validator: NumberValidator): ValidationResult;
function validate(validator: ArrayValidator): ValidationResult;
function validate(validator: ObjectValidator): ValidationResult;
function validate(validator: Validator): ValidationResult {
    const errors: string[] = [];
    
    switch (validator.type) {
        case 'string':
            if (validator.minLength !== undefined && validator.value.length < validator.minLength) {
                errors.push(`String is too short. Minimum length is ${validator.minLength}`);
            }
            if (validator.maxLength !== undefined && validator.value.length > validator.maxLength) {
                errors.push(`String is too long. Maximum length is ${validator.maxLength}`);
            }
            if (validator.pattern && !validator.pattern.test(validator.value)) {
                errors.push('String does not match required pattern');
            }
            break;
            
        case 'number':
            if (validator.min !== undefined && validator.value < validator.min) {
                errors.push(`Number is too small. Minimum value is ${validator.min}`);
            }
            if (validator.max !== undefined && validator.value > validator.max) {
                errors.push(`Number is too large. Maximum value is ${validator.max}`);
            }
            break;
            
        case 'array':
            if (validator.minLength !== undefined && validator.value.length < validator.minLength) {
                errors.push(`Array is too short. Minimum length is ${validator.minLength}`);
            }
            if (validator.maxLength !== undefined && validator.value.length > validator.maxLength) {
                errors.push(`Array is too long. Maximum length is ${validator.maxLength}`);
            }
            break;
            
        case 'object':
            if (validator.requiredKeys) {
                for (const key of validator.requiredKeys) {
                    if (!(key in validator.value)) {
                        errors.push(`Required key '${key}' is missing`);
                    }
                }
            }
            break;
            
        default:
            const _exhaustiveCheck: never = validator;
            return { isValid: false, errors: [`Unknown validator type: ${_exhaustiveCheck}`] };
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
}

// Использование
const stringValidation = validate({
    type: 'string',
    value: 'hello',
    minLength: 3,
    maxLength: 10,
    pattern: /^[a-z]+$/i
});

const numberValidation = validate({
    type: 'number',
    value: 42,
    min: 1,
    max: 100
});

const arrayValidation = validate({
    type: 'array',
    value: [1, 2, 3],
    minLength: 1,
    maxLength: 10
});

const objectValidation = validate({
    type: 'object',
    value: { name: 'John', age: 30 },
    requiredKeys: ['name', 'age']
});

console.log('String validation:', stringValidation);
console.log('Number validation:', numberValidation);
console.log('Array validation:', arrayValidation);
console.log('Object validation:', objectValidation);
```

## Преимущества ад-хок полиморфизма

1. **Улучшенная читаемость кода** - одинаковые операции имеют одинаковые имена для разных типов
2. **Типовая безопасность** - ошибки типов выявляются на этапе компиляции
3. **Производительность** - оптимизация возможна на этапе компиляции
4. **Расширяемость** - легко добавлять новые реализации для новых типов
5. **Семантическая ясность** - разработчики могут использовать привычные операторы и функции

## Недостатки ад-хок полиморфизма

1. **Ограниченная гибкость** - работает только с типами, для которых определена реализация
2. **Сложность реализации** - требует больше кода для определения разных реализаций
3. **Увеличенный размер бинарника** - каждая реализация добавляет код
4. **Сложность отладки** - может быть трудно определить, какая реализация используется

## Заключение

Ад-хок полиморфизм является мощной концепцией, позволяющей использовать одну и ту же операцию с разными типами данных, при этом обеспечивая разные реализации для каждого типа. В JavaScript и TypeScript он реализуется через перегрузки функций, discriminated unions и type guards.

Этот подход особенно полезен для создания выразительных API, где одна и та же операция может иметь разное поведение в зависимости от типа данных, но при этом сохраняется типовая безопасность и возможность статической проверки.

## См. также

- [[Полиморфизм-в-JavaScript]]
- [[Типы данных]]
- [[TypeScript]]
- [[Функциональное программирование]]
- [[Объектно-ориентированное программирование]]