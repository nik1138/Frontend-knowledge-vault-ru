---
aliases: [Polymorphism, Полиморфизм]
tags: [programming, frontend, oop, architecture]
---

# Полиморфизм

**Полиморфизм** — это принцип объектно-ориентированного программирования, при котором объекты разных классов могут обрабатываться через один и тот же интерфейс, при этом каждый объект сохраняет свои уникальные характеристики и поведение. Слово "полиморфизм" происходит от греческих "poly" (много) и "morph" (форма), что означает "много форм".

## Основные понятия

### Что такое полиморфизм

Полиморфизм позволяет использовать объекты разных типов через общий интерфейс, при этом каждый объект будет вести себя в соответствии со своей спецификой. Это достигается через наследование и переопределение методов.

```javascript
// Базовый класс
class Shape {
  constructor(color) {
    this.color = color;
  }
  
  // Абстрактный метод (должен быть реализован в дочерних классах)
  draw() {
    throw new Error('Метод draw должен быть реализован');
  }
  
  // Общий метод для всех фигур
  setColor(newColor) {
    this.color = newColor;
  }
  
  getColor() {
    return this.color;
  }
}

// Конкретные реализации
class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }
  
  draw() {
    console.log(`Рисуем круг радиуса ${this.radius} цвета ${this.color}`);
  }
  
  getArea() {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }
  
  draw() {
    console.log(`Рисуем прямоугольник ${this.width}x${this.height} цвета ${this.color}`);
  }
  
  getArea() {
    return this.width * this.height;
  }
}

class Triangle extends Shape {
  constructor(color, base, height) {
    super(color);
    this.base = base;
    this.height = height;
  }
  
  draw() {
    console.log(`Рисуем треугольник с основанием ${this.base} и высотой ${this.height} цвета ${this.color}`);
  }
  
  getArea() {
    return 0.5 * this.base * this.height;
  }
}

// Полиморфное использование
const shapes = [
  new Circle('красный', 5),
  new Rectangle('синий', 10, 8),
  new Triangle('зеленый', 6, 4)
];

// Все фигуры вызывают один и тот же метод, но ведут себя по-разному
shapes.forEach(shape => {
  shape.draw(); // Полиморфный вызов метода
});
// Вывод:
// Рисуем круг радиуса 5 цвета красный
// Рисуем прямоугольник 10x8 цвета синий
// Рисуем треугольник с основанием 6 и высотой 4 цвета зеленый
```

## Типы полиморфизма

### 1. Подтиповый полиморфизм (наследование)

```javascript
// Пример подтипового полиморфизма
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  makeSound() {
    console.log(`${this.name} издает звук`);
  }
  
  move() {
    console.log(`${this.name} двигается`);
  }
}

class Dog extends Animal {
  makeSound() {
    console.log(`${this.name} лает: Гав! Гав!`);
  }
  
  move() {
    console.log(`${this.name} бегает на четырех лапах`);
  }
  
  fetch() {
    console.log(`${this.name} принесает палку`);
  }
}

class Bird extends Animal {
  makeSound() {
    console.log(`${this.name} щебечет: Чик-чирик!`);
  }
  
  move() {
    console.log(`${this.name} летает`);
  }
  
  fly() {
    console.log(`${this.name} взлетает в небо`);
  }
}

// Полиморфная функция
function animalAction(animal) {
  animal.makeSound(); // Вызов метода, специфичного для каждого типа
  animal.move();      // Вызов метода, специфичного для каждого типа
}

// Использование
const animals = [new Dog('Бобик'), new Bird('Чижик')];

animals.forEach(animal => {
  animalAction(animal); // Полиморфный вызов
});
```

### 2. Параметрический полиморфизм (дженерики)

```javascript
// В JavaScript параметрический полиморфизм реализуется через функции и дженерики в TypeScript
class Container {
  constructor(item) {
    this.item = item;
  }
  
  getValue() {
    return this.item;
  }
  
  setValue(newValue) {
    this.item = newValue;
  }
}

// Функция, работающая с любым типом данных
function processContainer(container) {
  console.log('Значение контейнера:', container.getValue());
  return container.getValue();
}

// Использование с разными типами
const numberContainer = new Container(42);
const stringContainer = new Container('Привет');
const objectContainer = new Container({ name: 'Иван', age: 25 });

processContainer(numberContainer); // 42
processContainer(stringContainer);  // 'Привет'
processContainer(objectContainer);  // { name: 'Иван', age: 25 }
```

### 3. Ад-хок полиморфизм (перегрузка функций)

```javascript
// JavaScript не поддерживает перегрузку функций, но можно имитировать через проверку типов
class Calculator {
  // Метод работает с разными типами данных
  add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
      return a + b;
    } else if (typeof a === 'string' && typeof b === 'string') {
      return a + b;
    } else if (Array.isArray(a) && Array.isArray(b)) {
      return [...a, ...b];
    } else {
      throw new Error('Неподдерживаемые типы данных');
    }
  }
}

const calc = new Calculator();
console.log(calc.add(5, 3));           // 8
console.log(calc.add('Hello', ' World')); // 'Hello World'
console.log(calc.add([1, 2], [3, 4]));   // [1, 2, 3, 4]
```

## Практические примеры полиморфизма во фронтенде

### Полиморфные компоненты

```jsx
// Базовый компонент
class BaseComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { data: null, loading: false };
  }
  
  // Абстрактный метод для получения данных
  async fetchData() {
    throw new Error('Метод fetchData должен быть реализован');
  }
  
  async componentDidMount() {
    this.setState({ loading: true });
    try {
      const data = await this.fetchData();
      this.setState({ data, loading: false });
    } catch (error) {
      console.error('Ошибка загрузки данных:', error);
      this.setState({ loading: false });
    }
  }
  
  render() {
    const { data, loading } = this.state;
    
    if (loading) return <div>Загрузка...</div>;
    if (!data) return <div>Нет данных</div>;
    
    return this.renderContent(data);
  }
  
  // Абстрактный метод для рендеринга содержимого
  renderContent(data) {
    throw new Error('Метод renderContent должен быть реализован');
  }
}

// Конкретные компоненты
class UserComponent extends BaseComponent {
  async fetchData() {
    const response = await fetch(`/api/users/${this.props.userId}`);
    return response.json();
  }
  
  renderContent(user) {
    return (
      <div className="user-profile">
        <h2>{user.name}</h2>
        <p>{user.email}</p>
        <p>Роль: {user.role}</p>
      </div>
    );
  }
}

class PostComponent extends BaseComponent {
  async fetchData() {
    const response = await fetch(`/api/posts/${this.props.postId}`);
    return response.json();
  }
  
  renderContent(post) {
    return (
      <div className="post">
        <h2>{post.title}</h2>
        <div className="post-content">{post.content}</div>
        <p>Автор: {post.author}</p>
      </div>
    );
  }
}

// Полиморфное использование компонентов
function Dashboard({ items }) {
  return (
    <div className="dashboard">
      {items.map((item, index) => {
        // Рендеринг разных компонентов через один интерфейс
        switch (item.type) {
          case 'user':
            return <UserComponent key={index} userId={item.id} />;
          case 'post':
            return <PostComponent key={index} postId={item.id} />;
          default:
            return null;
        }
      })}
    </div>
  );
}
```

### Полиморфные сервисы

```javascript
// Интерфейс для сервисов уведомлений
class NotificationService {
  constructor() {
    if (new.target === NotificationService) {
      throw new TypeError('Cannot instantiate abstract class');
    }
  }
  
  async send(message, recipient) {
    throw new Error('Метод send должен быть реализован');
  }
}

// Конкретные реализации
class EmailService extends NotificationService {
  async send(message, recipient) {
    console.log(`Отправляем email "${message}" на ${recipient}`);
    // Реальная логика отправки email
    return { success: true, method: 'email' };
  }
}

class SMSService extends NotificationService {
  async send(message, recipient) {
    console.log(`Отправляем SMS "${message}" на ${recipient}`);
    // Реальная логика отправки SMS
    return { success: true, method: 'sms' };
  }
}

class PushService extends NotificationService {
  async send(message, recipient) {
    console.log(`Отправляем push-уведомление "${message}" пользователю ${recipient}`);
    // Реальная логика отправки push-уведомлений
    return { success: true, method: 'push' };
  }
}

// Полиморфная функция для отправки уведомлений
async function sendNotification(service, message, recipient) {
  return await service.send(message, recipient);
}

// Использование
const services = [
  new EmailService(),
  new SMSService(),
  new PushService()
];

const message = 'Ваш заказ готов!';
const recipient = 'user@example.com';

for (const service of services) {
  await sendNotification(service, message, recipient);
}
```

### Полиморфные валидаторы

```javascript
// Базовый класс валидатора
class Validator {
  constructor() {
    if (new.target === Validator) {
      throw new TypeError('Cannot instantiate abstract class');
    }
  }
  
  validate(value) {
    throw new Error('Метод validate должен быть реализован');
  }
  
  getErrorMessage() {
    throw new Error('Метод getErrorMessage должен быть реализован');
  }
}

// Конкретные валидаторы
class EmailValidator extends Validator {
  validate(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  getErrorMessage() {
    return 'Некорректный email адрес';
  }
}

class PasswordValidator extends Validator {
  validate(password) {
    return password.length >= 8;
  }
  
  getErrorMessage() {
    return 'Пароль должен содержать не менее 8 символов';
  }
}

class PhoneValidator extends Validator {
  validate(phone) {
    const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
    return phoneRegex.test(phone);
  }
  
  getErrorMessage() {
    return 'Некорректный номер телефона';
  }
}

// Полиморфная функция проверки
function validateField(validator, value) {
  const isValid = validator.validate(value);
  return {
    isValid,
    error: isValid ? null : validator.getErrorMessage()
  };
}

// Использование
const validators = {
  email: new EmailValidator(),
  password: new PasswordValidator(),
  phone: new PhoneValidator()
};

function validateForm(formData) {
  const errors = {};
  
  for (const [field, value] of Object.entries(formData)) {
    if (validators[field]) {
      const result = validateField(validators[field], value);
      if (!result.isValid) {
        errors[field] = result.error;
      }
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}

// Пример использования
const formData = {
  email: 'invalid-email',
  password: '123',
  phone: '+1234567890'
};

const result = validateForm(formData);
console.log(result); // { isValid: false, errors: { email: 'Некорректный email адрес', password: 'Пароль должен содержать не менее 8 символов' } }
```

## Полиморфизм в функциональном программировании

```javascript
// Полиморфизм через функции высшего порядка
const shapeDrawer = {
  circle: (radius, color) => `Рисуем круг радиуса ${radius} цвета ${color}`,
  rectangle: (width, height, color) => `Рисуем прямоугольник ${width}x${height} цвета ${color}`,
  triangle: (base, height, color) => `Рисуем треугольник с основанием ${base} и высотой ${height} цвета ${color}`
};

// Полиморфная функция
function drawShape(shapeType, ...params) {
  if (shapeDrawer[shapeType]) {
    return shapeDrawer[shapeType](...params);
  }
  throw new Error(`Неизвестный тип фигуры: ${shapeType}`);
}

console.log(drawShape('circle', 5, 'красный'));      // Рисуем круг радиуса 5 цвета красный
console.log(drawShape('rectangle', 10, 8, 'синий')); // Рисуем прямоугольник 10x8 цвета синий
console.log(drawShape('triangle', 6, 4, 'зеленый')); // Рисуем треугольник с основанием 6 и высотой 4 цвета зеленый

// Полиморфизм через интерфейсы (в TypeScript)
// function processUser<T extends { id: number, name: string }>(user: T): T {
//   console.log(`Обрабатываем пользователя: ${user.name}`);
//   return user;
// }
```

## Продвинутые паттерны полиморфизма

### Стратегия (Strategy Pattern)

```javascript
// Паттерн стратегия - пример полиморфизма
class PaymentProcessor {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  async process(amount) {
    return await this.strategy.pay(amount);
  }
}

class CreditCardStrategy {
  async pay(amount) {
    console.log(`Оплата ${amount} руб. по кредитной карте`);
    // Логика оплаты по кредитной карте
    return { success: true, method: 'credit_card' };
  }
}

class PayPalStrategy {
  async pay(amount) {
    console.log(`Оплата ${amount} руб. через PayPal`);
    // Логика оплаты через PayPal
    return { success: true, method: 'paypal' };
  }
}

class CryptoStrategy {
  async pay(amount) {
    console.log(`Оплата ${amount} руб. криптовалютой`);
    // Логика оплаты криптовалютой
    return { success: true, method: 'crypto' };
  }
}

// Использование
const processor = new PaymentProcessor(new CreditCardStrategy());
await processor.process(1000); // Оплата 1000 руб. по кредитной карте

processor.setStrategy(new PayPalStrategy());
await processor.process(1000); // Оплата 1000 руб. через PayPal
```

### Шаблонный метод (Template Method Pattern)

```javascript
// Шаблонный метод - еще один пример полиморфизма
class DataProcessor {
  async process() {
    const rawData = await this.loadData();
    const transformedData = this.transformData(rawData);
    const validatedData = this.validateData(transformedData);
    await this.saveData(validatedData);
    
    return validatedData;
  }
  
  // Абстрактные методы, реализуемые в подклассах
  async loadData() {
    throw new Error('Метод loadData должен быть реализован');
  }
  
  transformData(data) {
    throw new Error('Метод transformData должен быть реализован');
  }
  
  validateData(data) {
    throw new Error('Метод validateData должен быть реализован');
  }
  
  async saveData(data) {
    throw new Error('Метод saveData должен быть реализован');
  }
}

class UserProcessor extends DataProcessor {
  async loadData() {
    const response = await fetch('/api/users');
    return response.json();
  }
  
  transformData(users) {
    return users.map(user => ({
      ...user,
      fullName: `${user.firstName} ${user.lastName}`,
      isActive: user.status === 'active'
    }));
  }
  
  validateData(users) {
    return users.filter(user => user.email && user.email.includes('@'));
  }
  
  async saveData(users) {
    await fetch('/api/processed-users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(users)
    });
  }
}

class ProductProcessor extends DataProcessor {
  async loadData() {
    const response = await fetch('/api/products');
    return response.json();
  }
  
  transformData(products) {
    return products.map(product => ({
      ...product,
      priceWithTax: product.price * 1.2,
      inStock: product.quantity > 0
    }));
  }
  
  validateData(products) {
    return products.filter(product => product.name && product.price > 0);
  }
  
  async saveData(products) {
    await fetch('/api/processed-products', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(products)
    });
  }
}

// Полиморфное использование
const userProcessor = new UserProcessor();
const productProcessor = new ProductProcessor();

await userProcessor.process();    // Обработка пользовательских данных
await productProcessor.process(); // Обработка товарных данных
```

## Преимущества полиморфизма

### 1. Расширяемость

```javascript
// Легко добавлять новые типы без изменения существующего кода
class Shape {} // Базовый класс

class Circle extends Shape {
  draw() { console.log('Круг'); }
}

class Square extends Shape {
  draw() { console.log('Квадрат'); }
}

// Можно легко добавить новый тип
class Pentagon extends Shape {
  draw() { console.log('Пятиугольник'); }
}

// Существующий код продолжает работать
function renderAll(shapes) {
  shapes.forEach(shape => shape.draw());
}
```

### 2. Повторное использование кода

```javascript
// Общий код работает с разными типами
function calculateTotal(items) {
  return items.reduce((total, item) => total + item.getPrice(), 0);
}

// Разные классы с одинаковым интерфейсом
class Product {
  constructor(price) {
    this.price = price;
  }
  
  getPrice() {
    return this.price;
  }
}

class Service {
  constructor(hourlyRate, hours) {
    this.hourlyRate = hourlyRate;
    this.hours = hours;
  }
  
  getPrice() {
    return this.hourlyRate * this.hours;
  }
}

const items = [new Product(100), new Service(50, 3)];
console.log(calculateTotal(items)); // 250
```

## Связанные концепции

- [[Объектно-ориентированное программирование]] - основа для понимания полиморфизма
- [[Наследование]] - механизм, обеспечивающий полиморфизм
- [[Абстракция]] - абстрактные классы и интерфейсы для полиморфизма
- [[Интерфейсы]] - контракты для полиморфного поведения
- [[Композиция-и-агрегация]] - альтернативы наследованию с полиморфизмом

## Лучшие практики

1. **Создавайте четкие интерфейсы** - определяйте, какие методы должны быть реализованы
2. **Следуйте принципу подстановки Барбары Лисков** - дочерние классы должны быть заменяемыми для родительских
3. **Используйте абстрактные классы** - для определения контрактов
4. **Документируйте ожидаемое поведение** - четко описывайте, что должен делать каждый метод
5. **Тестируйте полиморфное поведение** - убедитесь, что все реализации работают корректно
6. **Избегайте чрезмерной сложности** - не создавайте слишком глубокие иерархии

## Заключение

Полиморфизм является мощным инструментом объектно-ориентированного программирования, позволяющим создавать гибкие и расширяемые системы. Он позволяет работать с объектами разных типов через общий интерфейс, что упрощает код и делает его более универсальным. В фронтенд-разработке полиморфизм особенно полезен для создания переиспользуемых компонентов, сервисов и валидаторов, которые могут работать с разными типами данных и реализовывать разное поведение при сохранении единого интерфейса.