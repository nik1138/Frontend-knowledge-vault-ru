---
aliases: [Scoped Slots, Slot Props, Скоуп-слоты, Слоты с пропсами]
tags: [frontend, components, slots, vue, svelte, react]
---

# Скоуп-слоты

Скоуп-слоты (scoped slots в Vue и slot props в Svelte) - это механизм, позволяющий передавать данные из дочернего компонента в родительский, где они могут быть использованы в шаблоне. Это мощный инструмент для создания гибких и переиспользуемых компонентов, которые могут предоставлять внутреннее состояние родительскому компоненту для отображения.

## Основы скоуп-слотов

Скоуп-слоты позволяют дочернему компоненту передавать данные родительскому компоненту, который затем может использовать эти данные при отображении содержимого слота. Это особенно полезно при создании компонентов, которые должны отображать список элементов или предоставлять информацию о внутреннем состоянии.

## Скоуп-слоты в Vue.js

В Vue.js скоуп-слоты реализуются через атрибуты у тега `<slot>`:

```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <slot :user="userData" :isLoggedIn="checkAuth()" :showDetails="showDetails">
      <h3>{{ userData.name }}</h3>
      <p>{{ userData.email }}</p>
    </slot>
  </div>
</template>

<script>
export default {
  data() {
    return {
      userData: {
        name: 'Иван',
        email: 'ivan@example.com',
        role: 'admin'
      }
    }
  },
  methods: {
    checkAuth() {
      return true; // условная проверка
    },
    showDetails() {
      return this.userData.role === 'admin';
    }
  }
}
</script>
```

Использование скоуп-слотов в родительском компоненте:

```vue
<!-- ParentComponent.vue -->
<template>
  <UserCard v-slot="slotProps">
    <div v-if="slotProps.isLoggedIn">
      <h2>Привет, {{ slotProps.user.name }}!</h2>
      <p>Ваш email: {{ slotProps.user.email }}</p>
      <p>Роль: {{ slotProps.user.role }}</p>
      <button v-if="slotProps.showDetails()">Показать детали</button>
    </div>
    <div v-else>
      <p>Пожалуйста, войдите в систему</p>
    </div>
  </UserCard>
</template>
```

## Слоты с пропсами в Svelte

В Svelte слоты с пропсами реализуются с использованием директивы `let`:

```svelte
<!-- UserCard.svelte -->
<script>
  let userData = {
    name: 'Иван',
    email: 'ivan@example.com',
    role: 'admin'
  };

  function checkAuth() {
    return true; // условная проверка
  }

  function showDetails() {
    return userData.role === 'admin';
  }
</script>

<div class="user-card">
  <slot {userData} {isLoggedIn=checkAuth()} {showDetails}></slot>
</div>
```

Использование слотов с пропсами в родительском компоненте:

```svelte
<!-- ParentComponent.svelte -->
<script>
  import UserCard from './UserCard.svelte';
</script>

<UserCard let:userData let:isLoggedIn let:showDetails>
  {#if isLoggedIn}
    <h2>Привет, {userData.name}!</h2>
    <p>Ваш email: {userData.email}</p>
    <p>Роль: {userData.role}</p>
    {#if showDetails()}
      <button>Показать детали</button>
    {/if}
  {/if}
</UserCard>
```

## Практические применения

### 1. Компонент списка с пользовательским отображением элементов

```vue
<!-- UserList.vue -->
<template>
  <ul class="user-list">
    <li v-for="user in users" :key="user.id" class="user-item">
      <slot :user="user" :index="index" :isSelected="isSelected(user)">
        <!-- Резервный контент по умолчанию -->
        <span>{{ user.name }}</span>
      </slot>
    </li>
  </ul>
</template>

<script>
export default {
  name: 'UserList',
  props: {
    users: {
      type: Array,
      required: true
    }
  },
  methods: {
    isSelected(user) {
      return this.selectedUserId === user.id;
    }
  },
  data() {
    return {
      selectedUserId: null
    }
  }
}
</script>
```

```vue
<!-- Использование -->
<UserList :users="userList" v-slot="slotProps">
  <div class="user-card" :class="{ selected: slotProps.isSelected }">
    <img :src="slotProps.user.avatar" :alt="slotProps.user.name" class="avatar">
    <div class="user-info">
      <h3>{{ slotProps.user.name }}</h3>
      <p>{{ slotProps.user.email }}</p>
      <button @click="selectUser(slotProps.user)">Выбрать</button>
    </div>
  </div>
</UserList>
```

### 2. Компонент таблицы с настраиваемыми ячейками

```vue
<!-- DataTable.vue -->
<template>
  <table class="data-table">
    <thead>
      <tr>
        <th v-for="column in columns" :key="column.key">{{ column.label }}</th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="(item, index) in items" :key="item.id">
        <td v-for="column in columns" :key="column.key">
          <slot :name="column.key" :item="item" :index="index">
            {{ item[column.key] }}
          </slot>
        </td>
      </tr>
    </tbody>
  </table>
</template>

<script>
export default {
  name: 'DataTable',
  props: {
    items: {
      type: Array,
      required: true
    },
    columns: {
      type: Array,
      required: true
    }
  }
}
</script>
```

## Сравнение с Render Props в React

Скоуп-слоты в Vue и слоты с пропсами в Svelte аналогичны паттерну Render Props в React. В React это выглядит так:

```jsx
// React Render Props
const UserCard = ({ render }) => {
  const userData = {
    name: 'Иван',
    email: 'ivan@example.com',
    role: 'admin'
  };
  
  const checkAuth = () => true;
  
  return (
    <div className="user-card">
      {render({ userData, isLoggedIn: checkAuth() })}
    </div>
  );
};

// Использование
<UserCard render={({ userData, isLoggedIn }) => (
  <div>
    {isLoggedIn && <h2>Привет, {userData.name}!</h2>}
  </div>
)} />
```

## Лучшие практики

1. **Используйте осмысленные имена** для передаваемых данных, чтобы облегчить понимание компонента.
2. **Документируйте скоуп-слоты** - четко указывайте, какие данные и функции передаются в слот.
3. **Предоставляйте резервный контент** для скоуп-слотов, чтобы компоненты были более устойчивыми.
4. **Избегайте передачи слишком большого количества данных** в скоуп-слот, чтобы не усложнять его использование.
5. **Рассмотрите использование TypeScript** для строгой типизации данных, передаваемых через скоуп-слоты.

## Преимущества скоуп-слотов

- **Гибкость**: Позволяют создавать компоненты, которые могут адаптироваться к различным требованиям отображения
- **Инкапсуляция**: Компонент может управлять своим внутренним состоянием, но при этом предоставлять данные для отображения
- **Переиспользуемость**: Компоненты могут использоваться в различных контекстах с разными способами отображения

## Связанные темы

- [[Слоты-в-Vue]]
- [[Слоты-в-Svelte]]
- [[Именованные-слоты]]
- [[Render-Props-в-React]]
- [[Компоненты-высшего-порядка]]

## Теги

#frontend #components #slots #scoped-slots #slot-props #vue #svelte #javascript #web-development