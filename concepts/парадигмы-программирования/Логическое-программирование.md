---
aliases: ["Логическая парадигма", "Дедуктивное программирование", "Программирование на основе логики"]
tags: [programming/paradigms, frontend, concepts, logic]
---

# Логическое программирование

## Определение

**Логическое программирование** — это парадигма программирования, в которой задача формулируется в терминах логических утверждений (фактов и правил), а решение находится с помощью логического вывода. Вместо описания последовательности шагов для решения задачи, программист описывает отношения между объектами и их свойствами.

## Основные понятия

### Факты
**Факты** — это утверждения, которые считаются истинными в данной области. Они описывают отношения между объектами.

### Правила
**Правила** — это логические утверждения, которые определяют, при каких условиях что-то является истинным. Они имеют вид "если-то" (условие → заключение).

### Запросы
**Запросы** — это вопросы, которые задаются системе для получения информации из базы знаний.

## Примеры на языке Prolog (классический язык логического программирования)

```prolog
% Факты
родитель(иван, мария).
родитель(иван, петр).
родитель(мария, анна).
родитель(мария, алексей).

% Правила
бабушка(X, Z) :- родитель(X, Y), родитель(Y, Z).
сестра(X, Y) :- родитель(Z, X), родитель(Z, Y), X \= Y, женщина(X).
```

## Логическое программирование в JavaScript

Хотя JavaScript не является чисто логическим языком программирования, можно имитировать логическое программирование с помощью различных подходов:

### Использование библиотек для логического программирования

```javascript
// Пример с библиотекой "logic-programming" (условный пример)
// В реальности можно использовать библиотеки вроде kanren, core.logic и т.д.

class LogicEngine {
  constructor() {
    this.facts = [];
    this.rules = [];
  }
  
  addFact(fact) {
    this.facts.push(fact);
  }
  
  addRule(rule) {
    this.rules.push(rule);
  }
  
  query(pattern) {
    // Поиск соответствий в фактах и применение правил
    return this.facts.filter(fact => this.matches(fact, pattern));
  }
  
  matches(fact, pattern) {
    // Простая проверка соответствия
    return Object.keys(pattern).every(key => 
      pattern[key] === '*' || fact[key] === pattern[key]
    );
  }
}

// Использование
const engine = new LogicEngine();

// Добавление фактов
engine.addFact({ name: 'иван', child: 'мария', type: 'parent' });
engine.addFact({ name: 'иван', child: 'петр', type: 'parent' });
engine.addFact({ name: 'мария', child: 'анна', type: 'parent' });

// Запрос
const parents = engine.query({ type: 'parent', child: 'мария' });
console.log(parents); // [{ name: 'иван', child: 'мария', type: 'parent' }]
```

### Использование функций для моделирования логических отношений

```javascript
// Моделирование логических отношений с помощью функций
const familyTree = [
  { parent: 'иван', child: 'мария' },
  { parent: 'иван', child: 'петр' },
  { parent: 'мария', child: 'анна' },
  { parent: 'мария', child: 'алексей' }
];

// Функция для поиска родителей
const findParents = (child) => {
  return familyTree
    .filter(relation => relation.child === child)
    .map(relation => relation.parent);
};

// Функция для поиска детей
const findChildren = (parent) => {
  return familyTree
    .filter(relation => relation.parent === parent)
    .map(relation => relation.child);
};

// Функция для поиска бабушек/дедушек
const findGrandparents = (grandchild) => {
  const parents = findParents(grandchild);
  return parents.flatMap(parent => findParents(parent));
};

console.log(findGrandparents('анна')); // ['иван']
```

## Основные принципы логического программирования

### 1. Декларативность
Программа описывает, что известно о проблеме, а не как решать проблему. Это делает код более близким к естественному языку и легче понимаемым.

### 2. Логический вывод
Система автоматически выводит новые знания из существующих фактов и правил. Это позволяет находить решения без явного программирования алгоритма.

### 3. Унификация
Процесс сопоставления и привязки переменных, который позволяет находить решения уравнений в терминах логических выражений.

### 4. Обратимость
В логическом программировании часто можно использовать одни и те же отношения для решения задач в обе стороны (например, найти родителя по ребенку или ребенка по родителю).

## Преимущества логического программирования

- **Выразительность**: Легко выражать сложные логические отношения
- **Декларативность**: Код ближе к естественному описанию проблемы
- **Автоматический вывод**: Система сама находит решения на основе заданных фактов и правил
- **Гибкость**: Один и тот же набор фактов и правил может использоваться для решения различных задач
- **Простота прототипирования**: Быстро можно проверить логические модели

## Недостатки логического программирования

- **Сложность отладки**: Трудно отследить, как система пришла к определенному решению
- **Производительность**: Может быть медленнее, чем императивные подходы для некоторых задач
- **Кривая обучения**: Требует изменения мышления, особенно для разработчиков с императивным опытом
- **Ограниченная область применения**: Не все задачи хорошо подходят для логического программирования
- **Ограниченные библиотеки**: В отличие от других парадигм, меньше готовых решений

## Применение в веб-разработке

Хотя логическое программирование не так распространено в веб-разработке, как другие парадигмы, оно может быть полезно в следующих сценариях:

### Валидация данных

```javascript
// Пример логического подхода к валидации
class Validator {
  constructor() {
    this.rules = [];
  }
  
  addRule(condition, message) {
    this.rules.push({ condition, message });
  }
  
  validate(data) {
    const errors = [];
    
    for (const rule of this.rules) {
      if (!rule.condition(data)) {
        errors.push(rule.message);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Определение правил валидации
const userValidator = new Validator();
userValidator.addRule(
  user => user.age >= 18,
  'Пользователь должен быть совершеннолетним'
);
userValidator.addRule(
  user => user.email.includes('@'),
  'Email должен содержать символ @'
);

// Валидация
const result = userValidator.validate({ age: 16, email: 'invalid-email' });
console.log(result); // { isValid: false, errors: ['Пользователь должен быть совершеннолетним', 'Email должен содержать символ @'] }
```

### Решение логических головоломок

```javascript
// Пример решения логической задачи (условно)
function solveLogicPuzzle() {
  // Определение возможных значений
  const people = ['Анна', 'Борис', 'Вика'];
  const colors = ['красный', 'синий', 'зеленый'];
  const drinks = ['чай', 'кофе', 'сок'];
  
  // Перебор всех возможных комбинаций
  for (const person of people) {
    for (const color of colors) {
      for (const drink of drinks) {
        // Проверка логических условий
        if (isValidCombination(person, color, drink)) {
          return { person, color, drink };
        }
      }
    }
  }
}

function isValidCombination(person, color, drink) {
  // Проверка логических правил
  // (условные правила для примера)
  return (
    (person === 'Анна') ? (color !== 'красный') : true &&
    (person === 'Борис') ? (drink === 'кофе') : true
  );
}
```

### Системы рекомендаций

```javascript
// Пример системы рекомендаций с логическим подходом
class RecommendationEngine {
  constructor() {
    this.rules = [
      // Правило: если пользователь молодой и любит технологии, рекомендовать гаджеты
      {
        condition: user => user.age < 30 && user.interests.includes('технологии'),
        recommendation: 'гаджеты'
      },
      // Правило: если пользователь любит спорт, рекомендовать спортивные товары
      {
        condition: user => user.interests.includes('спорт'),
        recommendation: 'спортивные товары'
      },
      // Правило: если пользователь любит книги, рекомендовать литературу
      {
        condition: user => user.interests.includes('книги'),
        recommendation: 'литература'
      }
    ];
  }
  
  getRecommendations(user) {
    return this.rules
      .filter(rule => rule.condition(user))
      .map(rule => rule.recommendation);
  }
}

const engine = new RecommendationEngine();
const recommendations = engine.getRecommendations({
  age: 25,
  interests: ['технологии', 'книги']
});

console.log(recommendations); // ['гаджеты', 'литература']
```

## Практические рекомендации

- Используйте логическое программирование для задач, связанных с логическим выводом и правилами
- Рассмотрите специализированные языки (Prolog, Datalog) для сложных логических задач
- В JavaScript можно использовать логический подход для валидации, систем правил и анализа данных
- Помните, что не все задачи подходят для логического программирования
- Используйте логическое программирование в сочетании с другими парадигмами для лучшего результата

## Заключение

Логическое программирование предлагает уникальный подход к решению задач, основанный на логических отношениях и автоматическом выводе. Хотя оно не так широко используется в веб-разработке, как другие парадигмы, оно может быть чрезвычайно полезным для определенных типов задач, особенно тех, которые требуют сложного логического анализа, валидации или систем правил. Понимание этой парадигмы расширяет горизонты программиста и может привести к более изящным решениям в определенных ситуациях.

## См. также
- [[Декларативное-программирование]]
- [[Функциональное-программирование]]
- [[Системы правил]]
- [[Валидация данных]]
- [[Prolog]]
- [[Datalog]]