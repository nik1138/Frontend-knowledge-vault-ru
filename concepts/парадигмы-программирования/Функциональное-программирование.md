---
aliases: ["Функциональная парадигма", "ФП", "Функциональный подход"]
tags: [programming/paradigms, frontend, javascript, concepts, functional]
---

# Функциональное программирование

## Определение

**Функциональное программирование** — это парадигма программирования, основанная на использовании функций как основных строительных блоков программы. В этой парадигме вычисления рассматриваются как вычисление математических функций, а изменение состояния и изменяемые данные избегаются.

## Основные принципы

### 1. Чистые функции (Pure Functions)

**Чистая функция** — это функция, которая:
- Возвращает одинаковый результат при одинаковых аргументах
- Не имеет побочных эффектов (не изменяет внешнее состояние)
- Не зависит от внешнего состояния

```javascript
// Чистая функция
function add(a, b) {
  return a + b;
}

// Нечистая функция (зависит от внешнего состояния)
let multiplier = 2;
function multiplyByGlobal(num) {
  return num * multiplier; // Зависит от внешней переменной
}

// Нечистая функция (имеет побочный эффект)
function logAndReturn(value) {
  console.log(value); // Побочный эффект: вывод в консоль
  return value;
}
```

### 2. Неизменяемость (Immutability)

В функциональном программировании данные не изменяются после создания. Вместо этого создаются новые структуры данных.

```javascript
// Императивный подход (изменяемый)
const user = { name: 'Иван', age: 25 };
user.age = 26; // Изменение существующего объекта

// Функциональный подход (неизменяемый)
const user = { name: 'Иван', age: 25 };
const updatedUser = { ...user, age: 26 }; // Создание нового объекта
```

### 3. Функции высшего порядка

Функции, которые принимают другие функции в качестве аргументов или возвращают функции.

```javascript
// Функция высшего порядка
function applyOperation(numbers, operation) {
  return numbers.map(operation);
}

// Пример использования
const numbers = [1, 2, 3, 4];
const doubled = applyOperation(numbers, x => x * 2);
console.log(doubled); // [2, 4, 6, 8]
```

### 4. Отсутствие побочных эффектов

Функции не должны изменять внешнее состояние, взаимодействовать с внешними ресурсами или иметь непредсказуемые результаты.

## Примеры на JavaScript

### Обработка массивов функциональным способом:

```javascript
const users = [
  { name: 'Иван', age: 25, active: true },
  { name: 'Мария', age: 30, active: false },
  { name: 'Петр', age: 22, active: true }
];

// Функциональный подход: цепочка операций
const result = users
  .filter(user => user.active)      // Отфильтровать активных пользователей
  .map(user => user.name)           // Извлечь имена
  .sort();                          // Отсортировать по алфавиту

console.log(result); // ['Иван', 'Петр']
```

### Каррирование (Currying)

Преобразование функции с несколькими аргументами в последовательность функций с одним аргументом:

```javascript
// Каррированная функция
const multiply = a => b => a * b;

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

### Композиция функций

Создание новой функции путем объединения двух или более функций:

```javascript
// Утилиты для композиции
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

// Пример использования
const add10 = x => x + 10;
const multiplyBy2 = x => x * 2;
const subtract5 = x => x - 5;

const calculate = pipe(add10, multiplyBy2, subtract5);
console.log(calculate(5)); // ((5 + 10) * 2) - 5 = 25
```

## Преимущества функционального программирования

- **Предсказуемость**: Чистые функции всегда возвращают одинаковый результат для одинаковых аргументов
- **Тестируемость**: Легко тестировать, так как функции не зависят от внешнего состояния
- **Параллелизм**: Безопасно для многопоточного выполнения, так как нет общего изменяемого состояния
- **Модульность**: Функции легко комбинировать и повторно использовать
- **Читаемость**: Код часто более выразителен и близок к математической нотации

## Недостатки функционального программирования

- **Кривая обучения**: Требует изменения мышления, особенно для разработчиков с императивным опытом
- **Производительность**: Иногда может быть менее эффективным из-за создания промежуточных структур данных
- **Сложность отладки**: Цепочки функций могут быть сложнее отлаживать
- **Меньше контроля**: Меньше контроля над памятью и производительностью

## Применение в веб-разработке

Функциональный подход активно используется в современных JavaScript-библиотеках:

```javascript
// Redux - функциональный подход к управлению состоянием
const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}
```

```javascript
// React с функциональными компонентами и хуками
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // Чистая функция для получения данных
    const fetchUser = async (id) => {
      const response = await fetch(`/api/users/${id}`);
      const userData = await response.json();
      return userData;
    };
    
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  return user ? <div>{user.name}</div> : <div>Загрузка...</div>;
}
```

## Практические рекомендации

- Используйте методы массивов (map, filter, reduce) вместо циклов
- Создавайте чистые функции, избегая побочных эффектов
- Используйте деструктуризацию и спред-операторы для работы с данными
- Применяйте неизменяемые структуры данных
- Рассмотрите использование библиотек для функционального программирования (например, Ramda)

## Заключение

Функциональное программирование предоставляет мощные инструменты для создания более надежного и поддерживаемого кода. Хотя полный переход к функциональному стилю может потребовать времени, даже частичное применение его принципов может значительно улучшить качество кода веб-приложений.

## См. также
- [[Декларативное-программирование]]
- [[Императивное-программирование]]
- [[React]]
- [[Redux]]
- [[Чистая функция]]
- [[Каррирование]]
- [[Композиция функций]]