---
aliases: [декораторы в JS, декораторы в TypeScript, функциональное программирование, паттерны проектирования]
tags: [frontend, javascript, typescript, patterns, oop, functional-programming]
---

# Декораторы в фронтенд-разработке

## Обзор

**Декораторы** — это паттерн проектирования, который позволяет добавлять новое поведение к объектам или функциям динамически, не изменяя их исходный код. В контексте фронтенд-разработки декораторы особенно полезны для добавления логики к компонентам, функциям, классам или методам без модификации их оригинальной реализации.

Декораторы особенно популярны в TypeScript и могут использоваться с различными фреймворками, такими как [[Angular]], [[React]] и [[Vue.js]].

## Принцип работы

Декоратор — это функция, которая принимает другую функцию, класс или метод в качестве аргумента и возвращает новую версию с добавленной функциональностью. Это позволяет реализовать сквозные аспекты, такие как:

- Логирование
- Кеширование
- Валидация
- Аутентификация
- Обработка ошибок

## Примеры использования в фронтенд-разработке

### 1. Декоратор для логирования

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Вызов метода ${propertyKey} с аргументами:`, args);
        const result = originalMethod.apply(this, args);
        console.log(`Результат метода ${propertyKey}:`, result);
        return result;
    };

    return descriptor;
}

class UserService {
    @log
    getUser(id: number) {
        return { id, name: 'John Doe' };
    }
}
```

### 2. Декоратор для кеширования

```typescript
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map();

    descriptor.value = function (...args: any[]) {
        const key = JSON.stringify(args);
        if (cacheMap.has(key)) {
            console.log('Возвращаем из кеша');
            return cacheMap.get(key);
        }

        const result = originalMethod.apply(this, args);
        cacheMap.set(key, result);
        return result;
    };

    return descriptor;
}

class ApiService {
    @cache
    async fetchData(url: string) {
        const response = await fetch(url);
        return response.json();
    }
}
```

### 3. Декоратор для валидации

```typescript
function validate(validationSchema: any) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;

        descriptor.value = function (...args: any[]) {
            // Простая проверка на наличие аргументов
            if (args.length !== validationSchema.length) {
                throw new Error(`Ожидается ${validationSchema.length} аргументов`);
            }

            // Проверка типов аргументов
            for (let i = 0; i < args.length; i++) {
                if (typeof args[i] !== validationSchema[i]) {
                    throw new Error(`Аргумент ${i} должен быть типа ${validationSchema[i]}`);
                }
            }

            return originalMethod.apply(this, args);
        };

        return descriptor;
    };
}

class Calculator {
    @validate(['number', 'number'])
    add(a: number, b: number) {
        return a + b;
    }
}
```

## Использование декораторов в React

В React декораторы можно использовать для добавления дополнительной функциональности к компонентам, например, для обработки аутентификации или логирования:

```typescript
function withAuth(WrappedComponent: React.ComponentType) {
    return function AuthenticatedComponent(props: any) {
        // Логика проверки аутентификации
        const isAuthenticated = checkAuth();

        if (!isAuthenticated) {
            return <div>Требуется аутентификация</div>;
        }

        return <WrappedComponent {...props} />;
    };
}

// Использование
const ProtectedComponent = withAuth(MyComponent);
```

## Преимущества использования декораторов

- **Разделение ответственности**: Основная логика компонента или функции остается чистой
- **Повторное использование**: Один декоратор можно применить к нескольким элементам
- **Читаемость**: Поведение компонента становится более очевидным
- **Тестируемость**: Легче тестировать отдельные аспекты функциональности

## Недостатки и ограничения

- **Сложность отладки**: Дополнительные слои абстракции могут усложнить отладку
- **Производительность**: Накладные расходы на дополнительные вызовы функций
- **Поддержка**: Не все браузеры поддерживают декораторы (требуется транспиляция через [[Babel]] или [[TypeScript]])

## Связь с другими паттернами

- [[Паттерны проектирования]]
- [[Функциональное программирование]]
- [[HOC (Higher-Order Components)]]
- [[Middleware]]

## Заключение

Декораторы — мощный инструмент, который позволяет добавлять дополнительное поведение к существующему коду без его модификации. В фронтенд-разработке они особенно полезны для реализации сквозных аспектов, таких как логирование, кеширование и валидация. Правильное использование декораторов делает код более чистым, модульным и легким для тестирования.

> [!tip] Совет
> Используйте декораторы умеренно и только там, где они действительно улучшают читаемость и поддерживаемость кода.

> [!warning] Важно
> Декораторы все еще находятся в стадии предложения (proposal) для JavaScript, поэтому используйте их осторожно в продакшене и убедитесь, что ваша сборка правильно обрабатывает их транспиляцию.