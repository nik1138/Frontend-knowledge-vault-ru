---
aliases: ["Рефакторинг", "Refactoring", "Улучшение кода"]
tags: [programming, maintainability, code-quality, refactoring]
---

# Рефакторинг

## Обзор

Рефакторинг - это процесс изменения внутренней структуры кода без изменения его внешнего поведения. Это ключевая практика для поддержания [[Поддерживаемость]] программного обеспечения и улучшения его архитектуры со временем.

Цель рефакторинга:
- **Улучшить читаемость** кода
- **Повысить поддерживаемость** системы
- **Упростить добавление нового функционала**
- **Снизить сложность** и технический долг
- **Улучшить производительность** (вторичная цель)

## Принципы рефакторинга

### Безопасность

Рефакторинг должен быть безопасным:
- **Пишите тесты** перед началом рефакторинга
- **Делайте маленькие шаги** с частыми проверками
- **Используйте систему контроля версий** для возможности отката изменений

### Постоянство

Рефакторинг - это не разовое мероприятие:
- **Интегрируйте** его в ежедневную разработку
- **Выделяйте время** на рефакторинг в спринтах
- **Рефакторьте понемногу** при каждом взаимодействии с кодом

## Общие паттерны рефакторинга

### Упрощение условий

```javascript
// До рефакторинга
function processOrder(order) {
  if (order.status === 'pending') {
    if (order.amount > 100) {
      if (order.customer.type === 'premium') {
        return applyDiscount(order, 0.1);
      } else {
        return processStandardOrder(order);
      }
    } else {
      return processStandardOrder(order);
    }
  } else {
    throw new Error('Invalid order status');
  }
}

// После рефакторинга
function processOrder(order) {
  validateOrderStatus(order);
  
  if (isPremiumCustomer(order) && isLargeOrder(order)) {
    return applyDiscount(order, 0.1);
  }
  
  return processStandardOrder(order);
}

function validateOrderStatus(order) {
  if (order.status !== 'pending') {
    throw new Error('Invalid order status');
  }
}

function isPremiumCustomer(order) {
  return order.customer.type === 'premium';
}

function isLargeOrder(order) {
  return order.amount > 100;
}
```

### Извлечение методов

```javascript
// До рефакторинга
function calculateInvoiceTotal(items, tax, discount) {
  let subtotal = 0;
  for (let i = 0; i < items.length; i++) {
    subtotal += items[i].price * items[i].quantity;
  }
  
  let discountAmount = 0;
  if (discount > 0) {
    discountAmount = subtotal * discount;
  }
  
  let taxAmount = (subtotal - discountAmount) * tax;
  let total = subtotal - discountAmount + taxAmount;
  
  return total;
}

// После рефакторинга
function calculateInvoiceTotal(items, tax, discount) {
  const subtotal = calculateSubtotal(items);
  const discountAmount = calculateDiscount(subtotal, discount);
  const taxAmount = calculateTax(subtotal, discountAmount, tax);
  return subtotal - discountAmount + taxAmount;
}

function calculateSubtotal(items) {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

function calculateDiscount(subtotal, discount) {
  return discount > 0 ? subtotal * discount : 0;
}

function calculateTax(subtotal, discountAmount, tax) {
  return (subtotal - discountAmount) * tax;
}
```

### Замена вложенных условий на защитные проверки

```javascript
// До рефакторинга
function processUser(user) {
  if (user !== null) {
    if (user.isActive) {
      if (user.hasPermission) {
        return performAction(user);
      } else {
        throw new Error('User lacks permission');
      }
    } else {
      throw new Error('User is not active');
    }
  } else {
    throw new Error('User is null');
  }
}

// После рефакторинга
function processUser(user) {
  if (user === null) {
    throw new Error('User is null');
  }
  
  if (!user.isActive) {
    throw new Error('User is not active');
  }
  
  if (!user.hasPermission) {
    throw new Error('User lacks permission');
  }
  
  return performAction(user);
}
```

### Замена условий на полиморфизм

```javascript
// До рефакторинга
class PaymentProcessor {
  processPayment(payment, type) {
    if (type === 'credit') {
      // обработка кредитной карты
      validateCreditCard(payment.card);
      chargeCreditCard(payment.card, payment.amount);
      sendConfirmation(payment.email);
    } else if (type === 'paypal') {
      // обработка PayPal
      validatePayPal(payment.email);
      chargePayPal(payment.email, payment.amount);
      sendConfirmation(payment.email);
    } else if (type === 'bank') {
      // обработка банковского перевода
      validateBankAccount(payment.account);
      processBankTransfer(payment.account, payment.amount);
      sendConfirmation(payment.email);
    }
  }
}

// После рефакторинга
class PaymentProcessor {
  processPayment(paymentMethod) {
    paymentMethod.validate();
    paymentMethod.charge();
    paymentMethod.sendConfirmation();
  }
}

class CreditCardPayment {
  validate() { /* ... */ }
  charge() { /* ... */ }
  sendConfirmation() { /* ... */ }
}

class PayPalPayment {
  validate() { /* ... */ }
  charge() { /* ... */ }
  sendConfirmation() { /* ... */ }
}

class BankTransferPayment {
  validate() { /* ... */ }
  charge() { /* ... */ }
  sendConfirmation() { /* ... */ }
}
```

## Индикаторы необходимости рефакторинга

### Code Smells

#### Длинные методы

```javascript
// Плохо
function processUserData(userData) {
  // 50 строк кода в одном методе
  // проверки, преобразования, валидации, сохранения
}

// Хорошо
function processUserData(userData) {
  const validatedData = validateUserData(userData);
  const transformedData = transformUserData(validatedData);
  return saveUserData(transformedData);
}
```

#### Повторяющийся код

```javascript
// Плохо
function processOrder(order) {
  // одинаковая валидация в нескольких местах
  if (!order.customer) {
    throw new Error('Customer is required');
  }
  if (!order.items || order.items.length === 0) {
    throw new Error('Order must have items');
  }
  // обработка заказа
}

function processReturn(returnOrder) {
  // та же валидация
  if (!returnOrder.customer) {
    throw new Error('Customer is required');
  }
  if (!returnOrder.items || returnOrder.items.length === 0) {
    throw new Error('Order must have items');
  }
  // обработка возврата
}

// Хорошо
function processOrder(order) {
  validateOrder(order);
  // обработка заказа
}

function processReturn(returnOrder) {
  validateOrder(returnOrder);
  // обработка возврата
}

function validateOrder(order) {
  if (!order.customer) {
    throw new Error('Customer is required');
  }
  if (!order.items || order.items.length === 0) {
    throw new Error('Order must have items');
  }
}
```

#### Жесткая связанность

```javascript
// Плохо
class OrderService {
  constructor() {
    this.emailService = new EmailService(); // жесткая зависимость
    this.paymentService = new PaymentService();
    this.inventoryService = new InventoryService();
  }
  
  processOrder(order) {
    // использование сервисов
  }
}

// Хорошо
class OrderService {
  constructor(emailService, paymentService, inventoryService) {
    this.emailService = emailService; // внедрение зависимостей
    this.paymentService = paymentService;
    this.inventoryService = inventoryService;
  }
  
  processOrder(order) {
    // использование сервисов
  }
}
```

## Инструменты рефакторинга

### IDE возможности

Современные IDE предоставляют автоматические возможности рефакторинга:
- **Переименование** переменных и функций
- **Извлечение методов** и функций
- **Перемещение** кода между файлами
- **Внедрение зависимостей**

### Статические анализаторы

Используйте инструменты для обнаружения code smells:

```json
// .eslintrc.js
module.exports = {
  rules: {
    'max-lines-per-function': ['warn', 30],
    'max-params': ['warn', 4],
    'complexity': ['warn', 5],
    'no-duplicate-code': 'error'
  }
};
```

## Практические рекомендации

### Пошаговый подход

1. **Напишите тесты** для проверяемого кода
2. **Определите проблему** в структуре кода
3. **Выберите подходящий паттерн** рефакторинга
4. **Сделайте маленький шаг** изменений
5. **Запустите тесты** для проверки корректности
6. **Повторите** до достижения цели

### Приоритизация

Фокусируйтесь на:
- **Часто изменяемом коде** - рефакторьте его в первую очередь
- **Критических компонентах** - улучшайте надежность
- **Коде с высоким техническим долгом** - снижайте риски

### Командная работа

- Обсуждайте рефакторинг в команде
- Устанавливайте стандарты рефакторинга
- Проводите код-ревью с акцентом на поддерживаемость

## Типичные ошибки

### Рефакторинг без тестов

```javascript
// Плохо - рефакторинг без тестов
// Изменяем код и надеемся, что ничего не сломается

// Хорошо - сначала пишем тесты
describe('calculateInvoiceTotal', () => {
  test('should calculate total with discount', () => {
    const items = [{ price: 100, quantity: 2 }];
    const total = calculateInvoiceTotal(items, 0.1, 0.05);
    expect(total).toBeCloseTo(189.1);
  });
});
```

### Слишком амбициозный рефакторинг

```javascript
// Плохо - пытаемся рефакторить весь модуль за раз
// Это приводит к большим изменениям и высокому риску

// Хорошо - постепенный рефакторинг
// Рефакторим по одному методу или классу за раз
```

## Измерение эффективности

Отслеживайте метрики:
- **Сложность кода** (cyclomatic complexity)
- **Повторяющийся код** (duplicate code)
- **Покрытие тестами** (test coverage)
- **Время разработки** новых функций

## Ссылки

- [[Чистый-код]]
- [[Документирование-кода]]
- [[Поддерживаемость]]
- [[Управление-зависимостями]]
- [[Best Practices]]

> [!tip] Совет
> Используйте технику "boy scout rule" - оставляйте код в лучшем состоянии, чем нашли его. Даже небольшие улучшения при каждом взаимодействии с кодом со временем создают значительную разницу.

> [!warning] Важно
> Рефакторинг не должен изменять поведение системы. Всегда убедитесь, что тесты проходят до и после рефакторинга.