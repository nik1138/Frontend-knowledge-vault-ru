---
aliases: [Слоистая архитектура, Многоуровневая архитектура]
tags: [architecture, patterns, software-design]
---

# Слоистая архитектура

## Обзор

Слоистая архитектура (Layered Architecture) - это один из самых распространенных и фундаментальных паттернов проектирования программного обеспечения. Она организует компоненты приложения в горизонтальные слои, каждый из которых отвечает за определенный уровень абстракции. Этот подход позволяет создавать системы, которые легко понимать, тестировать, поддерживать и расширять.

## Принципы слоистой архитектуры

### Основные принципы

1. **Слабая связанность между слоями**: Каждый слой должен быть максимально независим от других слоев
2. **Сильная связанность внутри слоя**: Компоненты внутри одного слоя должны тесно работать друг с другом
3. **Направленные зависимости**: Зависимости должны идти только в одном направлении (обычно сверху вниз)
4. **Инкапсуляция**: Каждый слой инкапсулирует свою функциональность и предоставляет четкий интерфейс
5. **Разделение ответственности**: Каждый слой отвечает за конкретный аспект системы

### Стандартные слои

Типичная слоистая архитектура состоит из следующих слоев:

1. **Presentation Layer (Слой представления)** - отвечает за взаимодействие с пользователем
2. **Business Logic Layer (Слой бизнес-логики)** - содержит бизнес-правила и логику приложения
3. **Data Access Layer (Слой доступа к данным)** - обеспечивает доступ к базе данных и другим источникам данных
4. **Infrastructure Layer (Инфраструктурный слой)** - предоставляет общие сервисы и инфраструктуру

## Слой представления (Presentation Layer)

Слой представления отвечает за взаимодействие с пользователем. Он обрабатывает ввод пользователя и отображает информацию.

### Компоненты слоя представления

- **Контроллеры** (в MVC)
- **Представления** (Views)
- **Формы** (Forms)
- **API контроллеры** (REST API)
- **Компоненты пользовательского интерфейса**

### Пример реализации

```typescript
// presentation/controllers/user.controller.ts
import { Request, Response } from 'express';
import { UserService } from '../business/user.service';
import { User } from '../business/models/user.model';

export class UserController {
  private userService: UserService;

  constructor(userService: UserService) {
    this.userService = userService;
  }

  async getAllUsers(req: Request, res: Response): Promise<void> {
    try {
      const users = await this.userService.getAllUsers();
      res.status(200).json(users);
    } catch (error) {
      res.status(500).json({ error: 'Ошибка получения пользователей' });
    }
  }

  async getUserById(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.params.id);
      const user = await this.userService.getUserById(userId);
      
      if (!user) {
        res.status(404).json({ error: 'Пользователь не найден' });
        return;
      }
      
      res.status(200).json(user);
    } catch (error) {
      res.status(500).json({ error: 'Ошибка получения пользователя' });
    }
  }

  async createUser(req: Request, res: Response): Promise<void> {
    try {
      const userData = req.body;
      const newUser = await this.userService.createUser(userData);
      res.status(201).json(newUser);
    } catch (error) {
      res.status(500).json({ error: 'Ошибка создания пользователя' });
    }
  }
}
```

### Паттерны в слое представления

- **Model-View-Controller (MVC)**
- **Model-View-Presenter (MVP)**
- **Model-View-ViewModel (MVVM)**
- **Front Controller**

## Слой бизнес-логики (Business Logic Layer)

Слой бизнес-логики содержит бизнес-правила и логику приложения. Это сердце приложения, где происходит обработка данных в соответствии с бизнес-требованиями.

### Компоненты слоя бизнес-логики

- **Сервисы** (Services)
- **Доменные модели** (Domain Models)
- **Фабрики** (Factories)
- **Спецификации** (Specifications)
- **Репозитории** (в некоторых реализациях)

### Пример реализации

```typescript
// business/services/user.service.ts
import { UserRepository } from '../repositories/user.repository';
import { User } from '../models/user.model';
import { UserValidator } from '../validators/user.validator';

export class UserService {
  private userRepository: UserRepository;
  private validator: UserValidator;

  constructor(userRepository: UserRepository) {
    this.userRepository = userRepository;
    this.validator = new UserValidator();
  }

  async getAllUsers(): Promise<User[]> {
    // Бизнес-логика: проверка прав доступа, аудит и т.д.
    return await this.userRepository.findAll();
  }

  async getUserById(id: number): Promise<User | null> {
    // Бизнес-логика: проверка прав доступа
    const user = await this.userRepository.findById(id);
    
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    return user;
  }

  async createUser(userData: Partial<User>): Promise<User> {
    // Валидация данных
    const validationErrors = this.validator.validate(userData);
    if (validationErrors.length > 0) {
      throw new Error(`Ошибка валидации: ${validationErrors.join(', ')}`);
    }

    // Бизнес-логика: проверка уникальности email
    const existingUser = await this.userRepository.findByEmail(userData.email!);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }

    // Создание пользователя
    const user = new User(
      userData.name!,
      userData.email!,
      userData.password!
    );

    // Хеширование пароля
    user.hashPassword();

    // Сохранение в репозитории
    const savedUser = await this.userRepository.save(user);
    
    // Бизнес-логика: отправка уведомления
    await this.sendWelcomeEmail(savedUser);
    
    return savedUser;
  }

  async updateUser(id: number, userData: Partial<User>): Promise<User> {
    // Получение существующего пользователя
    const existingUser = await this.userRepository.findById(id);
    if (!existingUser) {
      throw new Error('Пользователь не найден');
    }

    // Обновление данных
    Object.assign(existingUser, userData);
    
    // Валидация обновленных данных
    const validationErrors = this.validator.validate(existingUser);
    if (validationErrors.length > 0) {
      throw new Error(`Ошибка валидации: ${validationErrors.join(', ')}`);
    }

    // Сохранение обновленного пользователя
    return await this.userRepository.save(existingUser);
  }

  private async sendWelcomeEmail(user: User): Promise<void> {
    // Логика отправки приветственного email
    console.log(`Отправка приветственного email для ${user.email}`);
  }
}
```

### Бизнес-правила

Бизнес-правила могут включать:

- Проверки данных
- Валидации
- Логику аутентификации и авторизации
- Финансовые расчеты
- Рабочие процессы
- Правила безопасности

## Слой доступа к данным (Data Access Layer)

Слой доступа к данным отвечает за взаимодействие с базами данных и другими источниками данных. Он инкапсулирует всю логику доступа к данным и предоставляет абстракцию от конкретной реализации хранилища.

### Компоненты слоя доступа к данным

- **Репозитории** (Repositories)
- **DAO** (Data Access Objects)
- **ORM** (Object-Relational Mapping)
- **SQL-запросы**
- **Подключения к базе данных**

### Пример реализации

```typescript
// data/repositories/user.repository.ts
import { User } from '../../business/models/user.model';
import { DatabaseConnection } from '../connections/database.connection';

export class UserRepository {
  private connection: DatabaseConnection;

  constructor(connection: DatabaseConnection) {
    this.connection = connection;
  }

  async findAll(): Promise<User[]> {
    const query = 'SELECT * FROM users ORDER BY id';
    const result = await this.connection.query(query);
    return result.map(row => this.mapRowToUser(row));
  }

  async findById(id: number): Promise<User | null> {
    const query = 'SELECT * FROM users WHERE id = ?';
    const result = await this.connection.query(query, [id]);
    
    if (result.length === 0) {
      return null;
    }
    
    return this.mapRowToUser(result[0]);
  }

  async findByEmail(email: string): Promise<User | null> {
    const query = 'SELECT * FROM users WHERE email = ?';
    const result = await this.connection.query(query, [email]);
    
    if (result.length === 0) {
      return null;
    }
    
    return this.mapRowToUser(result[0]);
  }

  async save(user: User): Promise<User> {
    if (user.id) {
      // Обновление существующего пользователя
      const query = `
        UPDATE users 
        SET name = ?, email = ?, password = ?, updated_at = NOW() 
        WHERE id = ?
      `;
      await this.connection.query(query, [user.name, user.email, user.password, user.id]);
    } else {
      // Создание нового пользователя
      const query = `
        INSERT INTO users (name, email, password, created_at, updated_at) 
        VALUES (?, ?, ?, NOW(), NOW())
      `;
      const result = await this.connection.query(query, [user.name, user.email, user.password]);
      user.id = result.insertId;
    }
    
    return user;
  }

  async delete(id: number): Promise<boolean> {
    const query = 'DELETE FROM users WHERE id = ?';
    const result = await this.connection.query(query, [id]);
    return result.affectedRows > 0;
  }

  private mapRowToUser(row: any): User {
    const user = new User(row.name, row.email, row.password);
    user.id = row.id;
    user.createdAt = row.created_at;
    user.updatedAt = row.updated_at;
    return user;
  }
}
```

### Паттерны доступа к данным

- **Repository Pattern**
- **Data Mapper**
- **Active Record**
- **DAO (Data Access Object)**

## Инфраструктурный слой (Infrastructure Layer)

Инфраструктурный слой предоставляет общие сервисы и инфраструктуру для всего приложения. Он содержит технические детали, которые не относятся к бизнес-логике.

### Компоненты инфраструктурного слоя

- **Логирование**
- **Конфигурация**
- **Кэширование**
- **Соединения с базой данных**
- **Отправка email/SMS**
- **Файловое хранилище**
- **Внедрение зависимостей**

### Пример реализации

```typescript
// infrastructure/database/connection.ts
import { Pool, PoolConfig } from 'mysql2/promise';

export class DatabaseConnection {
  private pool: Pool;

  constructor(config: PoolConfig) {
    this.pool = require('mysql2/promise').createPool(config);
  }

  async query(sql: string, params?: any[]): Promise<any[]> {
    const connection = await this.pool.getConnection();
    try {
      const [rows] = await connection.execute(sql, params || []);
      return Array.isArray(rows) ? rows : [rows];
    } finally {
      connection.release();
    }
  }

  async close(): Promise<void> {
    await this.pool.end();
  }
}

// infrastructure/logging/logger.ts
export interface ILogger {
  info(message: string, meta?: any): void;
  error(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  debug(message: string, meta?: any): void;
}

export class ConsoleLogger implements ILogger {
  info(message: string, meta?: any): void {
    console.log(`[INFO] ${message}`, meta || '');
  }

  error(message: string, meta?: any): void {
    console.error(`[ERROR] ${message}`, meta || '');
  }

  warn(message: string, meta?: any): void {
    console.warn(`[WARN] ${message}`, meta || '');
  }

  debug(message: string, meta?: any): void {
    console.debug(`[DEBUG] ${message}`, meta || '');
  }
}

// infrastructure/cache/redis-cache.ts
import Redis from 'redis';

export class RedisCache {
  private client: Redis.RedisClientType;

  constructor(redisUrl: string) {
    this.client = Redis.createClient({ url: redisUrl });
    this.client.connect();
  }

  async set(key: string, value: string, expiration?: number): Promise<void> {
    if (expiration) {
      await this.client.set(key, value, { EX: expiration });
    } else {
      await this.client.set(key, value);
    }
  }

  async get(key: string): Promise<string | null> {
    return await this.client.get(key);
  }

  async delete(key: string): Promise<boolean> {
    const result = await this.client.del(key);
    return result > 0;
  }
}
```

## Варианты слоистой архитектуры

### Трехслойная архитектура

Самая простая форма слоистой архитектуры:

```
┌─────────────────────────┐
│    Presentation Layer   │
├─────────────────────────┤
│   Business Logic Layer  │
├─────────────────────────┤
│    Data Access Layer    │
└─────────────────────────┘
```

### Четырехслойная архитектура

Более детализированная структура:

```
┌─────────────────────────┐
│    Presentation Layer   │
├─────────────────────────┤
│   Service Layer         │
├─────────────────────────┤
│   Domain Layer          │
├─────────────────────────┤
│   Data Access Layer     │
├─────────────────────────┤
│   Infrastructure Layer  │
└─────────────────────────┘
```

### Шестислойная архитектура (N-слоев)

Дополнительные слои для специфических задач:

- **Application Layer** - координация между слоями
- **Domain Services Layer** - доменные сервисы
- **Integration Layer** - интеграция с внешними системами

## Преимущества слоистой архитектуры

### 1. Разделение ответственности

Каждый слой отвечает за конкретную функциональность, что упрощает понимание и поддержку кода.

### 2. Тестируемость

Отделение слоев позволяет легко создавать модульные тесты для каждой части системы.

```typescript
// Тестирование сервиса без зависимости от базы данных
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: UserRepository;

  beforeEach(() => {
    mockUserRepository = {
      findById: jest.fn(),
      save: jest.fn(),
      findByEmail: jest.fn()
    } as any;
    
    userService = new UserService(mockUserRepository as UserRepository);
  });

  it('should create a new user', async () => {
    const userData = { name: 'John Doe', email: 'john@example.com', password: 'password' };
    const expectedUser = new User('John Doe', 'john@example.com', 'password');
    expectedUser.id = 1;
    
    (mockUserRepository.findByEmail as jest.Mock).mockResolvedValue(null);
    (mockUserRepository.save as jest.Mock).mockResolvedValue(expectedUser);

    const result = await userService.createUser(userData);

    expect(result.name).toBe('John Doe');
    expect(mockUserRepository.findByEmail).toHaveBeenCalledWith('john@example.com');
    expect(mockUserRepository.save).toHaveBeenCalledWith(expect.any(User));
  });
});
```

### 3. Повторное использование

Компоненты слоев могут быть переиспользованы в разных частях приложения или даже в других приложениях.

### 4. Независимость технологий

Слои могут быть реализованы с использованием разных технологий, что позволяет легко заменять компоненты.

### 5. Масштабируемость

Слоистая архитектура позволяет масштабировать отдельные слои независимо друг от друга.

## Недостатки слоистой архитектуры

### 1. Перформанс

Многоуровневая архитектура может привести к дополнительным вызовам между слоями, что может повлиять на производительность.

### 2. Сложность

Для небольших приложений слоистая архитектура может быть избыточной и усложнять код.

### 3. Жесткая зависимость

Хотя зависимости направлены в одном направлении, изменения в нижних слоях могут повлиять на верхние.

### 4. Потенциальная избыточность

Может потребоваться создание множества классов и интерфейсов для поддержки архитектуры.

## Стратегии реализации

### 1. Внедрение зависимостей

Использование контейнера внедрения зависимостей для управления зависимостями между слоями:

```typescript
// dependency-injection/container.ts
export class DIContainer {
  private services = new Map<string, any>();

  register<T>(token: string, factory: () => T): void {
    this.services.set(token, factory);
  }

  resolve<T>(token: string): T {
    const factory = this.services.get(token);
    if (!factory) {
      throw new Error(`Сервис ${token} не зарегистрирован`);
    }
    return factory();
  }
}

// Регистрация сервисов
const container = new DIContainer();

container.register('database', () => new DatabaseConnection(dbConfig));
container.register('userRepository', () => new UserRepository(container.resolve('database')));
container.register('userService', () => new UserService(container.resolve('userRepository')));
container.register('userController', () => new UserController(container.resolve('userService')));
```

### 2. Интерфейсы и абстракции

Использование интерфейсов для ослабления связей между слоями:

```typescript
// interfaces/user.repository.interface.ts
export interface IUserRepository {
  findAll(): Promise<User[]>;
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: User): Promise<User>;
  delete(id: number): Promise<boolean>;
}

// business/services/user.service.ts
export class UserService {
  constructor(private userRepository: IUserRepository) {} // Зависимость от интерфейса, а не от реализации
}
```

### 3. Паттерн "Спецификация"

Для сложных бизнес-правил можно использовать паттерн Specification:

```typescript
// business/specifications/user.specification.ts
export interface ISpecification<T> {
  isSatisfiedBy(candidate: T): boolean;
  and(other: ISpecification<T>): ISpecification<T>;
  or(other: ISpecification<T>): ISpecification<T>;
  not(): ISpecification<T>;
}

export class UserAgeSpecification implements ISpecification<User> {
  constructor(private minAge: number) {}

  isSatisfiedBy(user: User): boolean {
    return user.age >= this.minAge;
  }

  and(other: ISpecification<User>): ISpecification<User> {
    return new AndSpecification(this, other);
  }

  or(other: ISpecification<User>): ISpecification<User> {
    return new OrSpecification(this, other);
  }

  not(): ISpecification<User> {
    return new NotSpecification(this);
  }
}

class AndSpecification<T> implements ISpecification<T> {
  constructor(private left: ISpecification<T>, private right: ISpecification<T>) {}

  isSatisfiedBy(candidate: T): boolean {
    return this.left.isSatisfiedBy(candidate) && this.right.isSatisfiedBy(candidate);
  }

  // Реализация остальных методов...
}
```

## Практические примеры

### Пример: Система управления заказами

```
Presentation Layer
├── OrderController
├── ProductController
└── CustomerController

Business Logic Layer
├── OrderService
├── ProductService
├── CustomerService
├── OrderValidator
└── BusinessRulesEngine

Data Access Layer
├── OrderRepository
├── ProductRepository
├── CustomerRepository
└── DatabaseConnection

Infrastructure Layer
├── Logger
├── Cache
├── EmailService
└── Configuration
```

### Пример: Микросервисная архитектура с использованием слоистой архитектуры

Каждый микросервис может использовать слоистую архитектуру:

```typescript
// Микросервис аутентификации
// auth-service/
├── presentation/
│   ├── controllers/
│   │   ├── auth.controller.ts
│   │   └── user.controller.ts
│   └── middleware/
├── business/
│   ├── services/
│   │   ├── auth.service.ts
│   │   └── user.service.ts
│   ├── models/
│   │   ├── user.model.ts
│   │   └── token.model.ts
│   └── validators/
├── data/
│   ├── repositories/
│   │   └── user.repository.ts
│   └── connections/
└── infrastructure/
    ├── jwt/
    ├── hashing/
    ├── logging/
    └── config/
```

## Лучшие практики

### 1. Четкое определение границ слоев

Каждый слой должен иметь четко определенную ответственность и не пересекаться с другими слоями.

### 2. Минимизация зависимостей

Следите за тем, чтобы зависимости не нарушали направление потока данных.

### 3. Использование DTO

Используйте Data Transfer Objects для передачи данных между слоями, чтобы избежать передачи внутренних моделей.

```typescript
// dto/user.dto.ts
export interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

export interface UserResponseDto {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}
```

### 4. Обработка ошибок

Реализуйте централизованную обработку ошибок на каждом уровне.

```typescript
// business/errors/business-error.ts
export abstract class BusinessError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ValidationError extends BusinessError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR');
  }
}

export class NotFoundError extends BusinessError {
  constructor(message: string) {
    super(message, 'NOT_FOUND_ERROR');
  }
}
```

### 5. Мониторинг и логирование

Реализуйте логирование на всех уровнях для отслеживания производительности и ошибок.

## Заключение

Слоистая архитектура остается одной из самых важных и широко используемых архитектурных моделей в разработке программного обеспечения. Она предоставляет структурированный подход к построению приложений, обеспечивая четкое разделение ответственности, тестируемость и поддерживаемость.

Ключевые преимущества слоистой архитектуры:

- Четкое разделение ответственности
- Легкость тестирования
- Возможность независимого развития слоев
- Повторное использование компонентов
- Простота понимания и поддержки

При правильной реализации слоистая архитектура может значительно упростить разработку и поддержку сложных приложений. Однако важно учитывать контекст приложения и не использовать архитектуру, которая будет избыточной для простых задач.

Ссылки на связанные концепции: [[Microservices Architecture]], [[Clean Architecture]], [[Domain-Driven Design]], [[SOLID Principles]], [[Design Patterns]], [[Enterprise Architecture]], [[System Architecture]].