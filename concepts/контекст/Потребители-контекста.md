---
aliases: [Context Consumers, Потребители контекста, Context Consumer]
tags: [context, consumers, state-management, frontend, react, vue, svelte]
---

# Потребители-контекста

## Обзор

Потребители контекста - это компоненты или функции, которые получают и используют данные из контекста, установленного провайдерами. Они позволяют компонентам получать доступ к общему состоянию без необходимости передавать пропсы на каждом уровне дерева компонентов. Потребители играют ключевую роль в паттерне "Контекст", обеспечивая доступ к данным, установленным в провайдерах.

## Роль потребителей контекста

Потребители контекста выполняют следующие функции:
- Получают данные из контекста
- Реагируют на изменения в контексте
- Используют данные для рендеринга компонентов
- Могут вызывать методы для обновления контекста

## Потребители в различных фреймворках

### React

В React потребители контекста реализуются через хук `useContext` или компонент `<Context.Consumer>`.

#### Использование хука useContext

```jsx
import React, { useContext } from 'react';
import { ThemeContext, UserContext } from './contexts';

// Простой потребитель
const ThemedButton = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <button 
      className={`btn btn-${theme}`}
      onClick={toggleTheme}
    >
      Текущая тема: {theme}
    </button>
  );
};

// Потребитель нескольких контекстов
const UserProfile = () => {
  const { user } = useContext(UserContext);
  const { theme } = useContext(ThemeContext);

  if (!user) {
    return <div>Пожалуйста, войдите в систему</div>;
  }

  return (
    <div className={`profile profile-${theme}`}>
      <h2>Профиль пользователя: {user.name}</h2>
      <p>Роль: {user.role}</p>
    </div>
  );
};
```

#### Использование компонента Consumer (устаревший подход)

```jsx
import React from 'react';
import { ThemeContext } from './contexts';

// Использование Consumer (устаревший способ)
const ThemedTitle = () => {
  return (
    <ThemeContext.Consumer>
      {({ theme }) => (
        <h1 className={`title title-${theme}`}>
          Заголовок с темой {theme}
        </h1>
      )}
    </ThemeContext.Consumer>
  );
};
```

#### Кастомные хуки для потребления контекста

```jsx
// hooks/useTheme.js
import { useContext } from 'react';
import { ThemeContext } from '../contexts/ThemeContext';

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// Использование кастомных хуков
const ProtectedComponent = () => {
  const { user, loading } = useAuth();
  const { theme } = useTheme();

  if (loading) return <div>Загрузка...</div>;
  if (!user) return <div>Доступ запрещен</div>;

  return (
    <div className={`protected protected-${theme}`}>
      <h2>Защищенный контент</h2>
    </div>
  );
};
```

### Vue

В Vue потребители контекста реализуются через функцию `inject`, доступную в Composition API.

#### Использование inject в Composition API

```vue
<!-- UserProfile.vue -->
<template>
  <div v-if="user" :class="`profile profile-${theme}`">
    <h2>Профиль: {{ user.name }}</h2>
    <p>Роль: {{ user.role }}</p>
    <p>Текущая тема: {{ theme }}</p>
    <button @click="toggleTheme">Сменить тему</button>
  </div>
  <div v-else>
    Пользователь не авторизован
  </div>
</template>

<script setup>
import { inject } from 'vue';

// Внедряем значения из контекста
const user = inject('user');
const theme = inject('theme');
const toggleTheme = inject('toggleTheme');
</script>
```

#### Использование с дефолтными значениями

```vue
<!-- OptionalConsumer.vue -->
<template>
  <div :class="`component component-${theme}`">
    <p>Язык интерфейса: {{ language }}</p>
    <p>Тема: {{ theme }}</p>
  </div>
</template>

<script setup>
import { inject } from 'vue';

// Внедряем с дефолтными значениями
const language = inject('language', 'en'); // 'en' - значение по умолчанию
const theme = inject('theme', 'light');   // 'light' - значение по умолчанию
</script>
```

#### Создание кастомных композиций для потребления

```javascript
// composables/useAppContext.js
import { inject } from 'vue';

const APP_CONTEXT_KEY = Symbol('appContext');

export function useAppContext() {
  const context = inject(APP_CONTEXT_KEY);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
}

// composables/useTheme.js
import { inject } from 'vue';

const THEME_KEY = Symbol('theme');

export function useTheme() {
  const themeContext = inject(THEME_KEY);
  if (!themeContext) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return themeContext;
}
```

#### Использование в Options API

```vue
<!-- ComponentWithInject.vue -->
<template>
  <div :class="`component component-${theme}`">
    <p>Пользователь: {{ user?.name || 'Гость' }}</p>
    <p>Тема: {{ theme }}</p>
  </div>
</template>

<script>
export default {
  name: 'ComponentWithInject',
  inject: ['user', 'theme'],
  computed: {
    isLoggedIn() {
      return !!this.user;
    }
  },
  methods: {
    handleAction() {
      // Можем использовать внедренные значения
      console.log(`Текущая тема: ${this.theme}`);
    }
  }
};
</script>
```

### Svelte

В Svelte потребители контекста реализуются через функцию `getContext`.

#### Использование getContext

```svelte
<!-- UserProfile.svelte -->
<script>
  import { getContext } from 'svelte';
  
  // Определяем ключи контекста
  const USER_CONTEXT = Symbol('user');
  const THEME_CONTEXT = Symbol('theme');
  
  // Получаем значения из контекста
  const { user, updateUser } = getContext(USER_CONTEXT);
  const { theme, toggleTheme } = getContext(THEME_CONTEXT);
</script>

{#if $user}
  <div class="profile">
    <h2>Профиль: {$user.name}</h2>
    <p>Роль: {$user.role}</p>
    <p>Текущая тема: {$theme}</p>
    <button on:click={toggleTheme}>Сменить тему</button>
  </div>
{:else}
  <div>Пользователь не авторизован</div>
{/if}
```

#### Проверка наличия контекста

```svelte
<!-- SafeConsumer.svelte -->
<script>
  import { getContext, hasContext } from 'svelte';
  
  const REQUIRED_CONTEXT = Symbol('required');
  
  // Проверяем наличие контекста
  const hasCtx = hasContext(REQUIRED_CONTEXT);
  let context;
  
  if (hasCtx) {
    context = getContext(REQUIRED_CONTEXT);
  } else {
    // Обработка отсутствия контекста
    console.warn('Контекст не найден');
    context = { theme: 'light', user: null };
  }
</script>

<div class="consumer">
  {#if hasCtx}
    <p>Контекст доступен: {context.theme}</p>
  {:else}
    <p>Контекст недоступен</p>
  {/if}
</div>
```

#### Использование с Svelte Stores

```svelte
<!-- ThemeConsumer.svelte -->
<script>
  import { getContext } from 'svelte';
  
  const THEME_CONTEXT = Symbol('theme');
  
  // Получаем хранилище из контекста
  const themeStore = getContext(THEME_CONTEXT);
  
  // Подписываемся на изменения
  let currentTheme;
  
  $: currentTheme = $themeStore;
</script>

<div class="themed-element" class:dark={currentTheme === 'dark'}>
  Текущая тема: {currentTheme}
</div>
```

## Лучшие практики при создании потребителей

### 1. Проверяйте наличие контекста

Всегда проверяйте, что контекст доступен, особенно в библиотечных компонентах:

```jsx
// React
export const useCustomContext = () => {
  const context = useContext(CustomContext);
  if (!context) {
    throw new Error('useCustomContext must be used within a CustomProvider');
  }
  return context;
};

// Vue
export function useCustomContext() {
  const context = inject(CUSTOM_CONTEXT_KEY);
  if (!context) {
    throw new Error('useCustomContext must be used within a CustomProvider');
  }
  return context;
}

// Svelte
const context = getContext(CONTEXT_KEY);
if (!context) {
  console.error('Context not available');
}
```

### 2. Используйте кастомные хуки/композиции

Создавайте кастомные хуки или композиции для инкапсуляции логики потребления контекста:

```jsx
// hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
  const { user, loading, login, logout } = useContext(AuthContext);
  
  const isLoggedIn = !!user;
  
  return {
    user,
    loading,
    isLoggedIn,
    login,
    logout
  };
};
```

### 3. Оптимизируйте перерендеры

Избегайте ненужных перерендеров при использовании контекста:

```jsx
// Используйте React.memo для компонентов
const MemoizedComponent = React.memo(({ userId }) => {
  const { users } = useContext(UsersContext);
  const user = users.find(u => u.id === userId);
  
  return <div>{user.name}</div>;
});

// Извлекайте только нужные данные
const UserName = ({ userId }) => {
  const users = useContext(UsersContext).users;
  const user = users.find(u => u.id === userId);
  
  return <span>{user.name}</span>;
};
```

### 4. Используйте Selectors для извлечения данных

Для сложных объектов контекста создавайте селекторы:

```jsx
// selectors/contextSelectors.js
export const selectUser = (context) => context.user;
export const selectTheme = (context) => context.theme;
export const selectUserPermissions = (context) => context.user?.permissions || [];

// В компоненте
const UserComponent = () => {
  const context = useContext(AppContext);
  const user = selectUser(context);
  const permissions = selectUserPermissions(context);
  
  return (
    <div>
      {/* Используем извлеченные данные */}
    </div>
  );
};
```

### 5. Обрабатывайте асинхронные данные

При работе с асинхронными данными в контексте учитывайте состояния загрузки:

```jsx
const AsyncDataComponent = () => {
  const { data, loading, error, refresh } = useContext(AsyncDataContext);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error.message}</div>;
  if (!data) return <div>Нет данных</div>;

  return (
    <div>
      <button onClick={refresh}>Обновить</button>
      {/* Отображение данных */}
    </div>
  );
};
```

## Потенциальные проблемы и решения

### 1. Частые перерендеры

Контекст может вызывать перерендеры при любом изменении значения:

```jsx
// Проблема: изменение любой части контекста вызывает перерендер всех потребителей
const contextValue = {
  user: state.user,
  theme: state.theme,
  updateUser: (user) => dispatch({ type: 'UPDATE_USER', user }),
  toggleTheme: () => dispatch({ type: 'TOGGLE_THEME' })
};

// Решение: разделение контекста
const UserContext = createContext();
const ThemeContext = createContext();

// Или использование React.memo
const ThemeDependentComponent = React.memo(({ theme }) => (
  <div className={theme}>Компонент темы</div>
));
```

### 2. Сложность тестирования

При тестировании компонентов, использующих контекст, необходимо оборачивать их в провайдеры:

```jsx
// tests/Component.test.js
import React from 'react';
import { render, screen } from '@testing-library/react';
import { ThemeProvider } from '../contexts/ThemeProvider';
import { AuthProvider } from '../contexts/AuthProvider';
import Component from '../Component';

const AllProviders = ({ children }) => (
  <AuthProvider>
    <ThemeProvider>
      {children}
    </ThemeProvider>
  </AuthProvider>
);

test('component renders with context', () => {
  render(
    <AllProviders>
      <Component />
    </AllProviders>
  );
  
  expect(screen.getByText(/theme/i)).toBeInTheDocument();
});
```

### 3. Глубокие обновления объектов

При обновлении вложенных свойств объекта в контексте может не произойти перерендер:

```jsx
// Проблема: такой подход может не вызвать перерендер
const updateNestedValue = (newValue) => {
  contextValue.user.profile.settings.language = newValue;
  // Это не вызовет перерендер, так как ссылка на объект не изменилась
};

// Решение: создание нового объекта
const updateNestedValue = (newValue) => {
  setUser(prev => ({
    ...prev,
    profile: {
      ...prev.profile,
      settings: {
        ...prev.profile.settings,
        language: newValue
      }
    }
  }));
};
```

## Ссылки и ресурсы

- [[Контекст-в-React]]
- [[Контекст-в-Vue]]
- [[Контекст-в-Svelte]]
- [[Провайдеры-контекста]]
- [[Глобальное-состояние]]
- [[Компонентная-архитектура]]
- [[Хранилища-данных]]

## Заключение

Потребители контекста играют важную роль в архитектуре современных фронтенд-приложений, обеспечивая доступ к общему состоянию без необходимости передавать пропсы на каждом уровне. Правильное использование потребителей требует понимания особенностей каждого фреймворка и следования лучшим практикам для обеспечения производительности и поддерживаемости кода.