---
aliases: [Data Streams, Потоки Данных]
tags: [programming, frontend, reactive, javascript]
---

# Потоки данных

**Потоки данных** — это концепция, при которой данные рассматриваются как непрерывный поток, который можно наблюдать, преобразовывать и комбинировать. В контексте фронтенд-разработки потоки данных позволяют эффективно обрабатывать события, асинхронные операции и изменения состояния.

## Основные понятия

### Что такое поток данных

Поток данных — это последовательность данных, которые могут быть получены асинхронно и обработаны по мере поступления:

```javascript
// Простой пример потока данных с помощью генератора
function* numberStream() {
  let count = 0;
  while (true) {
    yield count++;
    await new Promise(resolve => setTimeout(resolve, 1000)); // Задержка 1 сек
  }
}

// Использование потока
async function useStream() {
  const stream = numberStream();
  for await (const value of stream) {
    console.log(value);
    if (value > 5) break; // Прерываем после 5 итераций
  }
}
```

### Основные операции над потоками

```javascript
// Основные операции: map, filter, reduce
class DataStream {
  constructor(source) {
    this.source = source;
    this.operators = [];
  }
  
  map(fn) {
    this.operators.push(stream => stream.map(fn));
    return this;
  }
  
  filter(fn) {
    this.operators.push(stream => stream.filter(fn));
    return this;
  }
  
  reduce(fn, initialValue) {
    this.operators.push(stream => stream.reduce(fn, initialValue));
    return this;
  }
  
  async execute() {
    let result = await this.source;
    for (const operator of this.operators) {
      result = operator(result);
    }
    return result;
  }
}

// Использование
async function example() {
  const stream = new DataStream(
    Promise.resolve([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  );
  
  const result = await stream
    .filter(x => x % 2 === 0) // Оставить только четные
    .map(x => x * 2)         // Удвоить
    .execute();
    
  console.log(result); // [4, 8, 12, 16, 20]
}
```

## Потоки данных в браузере

### События как потоки

```javascript
// События мыши как поток данных
function mouseMoveStream(element) {
  return new ReadableStream({
    start(controller) {
      const handler = (event) => {
        controller.enqueue({
          x: event.clientX,
          y: event.clientY,
          timestamp: Date.now()
        });
      };
      
      element.addEventListener('mousemove', handler);
      
      // Очистка ресурсов
      this.cancel = () => {
        element.removeEventListener('mousemove', handler);
      };
    }
  });
}

// Использование потока событий
async function trackMouse() {
  const stream = mouseMoveStream(document);
  const reader = stream.getReader();
  
  try {
    while (true) {
      const { value } = await reader.read();
      console.log(`Позиция мыши: ${value.x}, ${value.y}`);
    }
  } finally {
    reader.releaseLock();
  }
}
```

### Fetch API как поток данных

```javascript
// Поток данных из API
async function* apiDataStream(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  
  try {
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) break;
      
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop(); // Последняя строка может быть неполной
      
      for (const line of lines) {
        if (line.trim()) {
          try {
            yield JSON.parse(line);
          } catch (e) {
            console.error('Ошибка парсинга JSON:', line);
          }
        }
      }
    }
  } finally {
    reader.release();
  }
}

// Использование потока API данных
async function processApiData() {
  for await (const data of apiDataStream('/api/stream-data')) {
    console.log('Получены данные:', data);
    // Обработка данных
  }
}
```

## Практическое применение в фронтенде

### Обработка пользовательского ввода

```javascript
// Поток данных из поля ввода с debounce
function createInputDataStream(inputElement, delay = 300) {
  return new Observable(observer => {
    let timeoutId;
    
    const handler = (event) => {
      // Отменяем предыдущий таймаут
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      // Устанавливаем новый таймаут
      timeoutId = setTimeout(() => {
        observer.next(event.target.value);
      }, delay);
    };
    
    inputElement.addEventListener('input', handler);
    
    // Функция очистки
    return () => {
      inputElement.removeEventListener('input', handler);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  });
}

// Использование с RxJS
import { fromEvent } from 'rxjs';
import { map, filter, debounceTime, distinctUntilChanged } from 'rxjs/operators';

function setupSearchStream() {
  const searchInput = document.getElementById('search-input');
  
  const searchStream = fromEvent(searchInput, 'input').pipe(
    map(event => event.target.value),
    filter(value => value.length >= 3), // Только если длина >= 3
    debounceTime(500), // Задержка 500мс
    distinctUntilChanged() // Только если значение изменилось
  );
  
  searchStream.subscribe(async (searchTerm) => {
    try {
      const results = await searchAPI(searchTerm);
      displayResults(results);
    } catch (error) {
      console.error('Ошибка поиска:', error);
    }
  });
}
```

### Потоки данных в React

```jsx
// Пользовательский хук для работы с потоками данных
function useDataStream(promiseFactory, dependencies = []) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const result = await promiseFactory();
        if (!cancelled) {
          setData(result);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, dependencies);
  
  return { data, loading, error };
}

// Использование хука
function UserList() {
  const { data: users, loading, error } = useDataStream(
    () => fetch('/api/users').then(r => r.json()),
    [] // Пустой массив зависимостей = выполнить один раз
  );
  
  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error.message}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### WebSocket как поток данных

```javascript
// WebSocket как поток данных
class WebSocketStream {
  constructor(url) {
    this.url = url;
    this.socket = null;
    this.observers = [];
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }
  
  connect() {
    this.socket = new WebSocket(this.url);
    
    this.socket.onopen = () => {
      console.log('Соединение установлено');
      this.reconnectAttempts = 0;
    };
    
    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.notifyObservers(data);
      } catch (e) {
        console.error('Ошибка парсинга сообщения:', event.data);
      }
    };
    
    this.socket.onclose = () => {
      console.log('Соединение закрыто');
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        setTimeout(() => {
          this.reconnectAttempts++;
          this.connect();
        }, 1000 * this.reconnectAttempts); // Экспоненциальная задержка
      }
    };
    
    this.socket.onerror = (error) => {
      console.error('Ошибка WebSocket:', error);
    };
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  }
  
  notifyObservers(data) {
    this.observers.forEach(observer => {
      if (typeof observer === 'function') {
        observer(data);
      } else if (observer.next) {
        observer.next(data);
      }
    });
  }
  
  send(data) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(data));
    }
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.close();
    }
  }
}

// Использование WebSocket потока
function setupRealTimeUpdates() {
  const wsStream = new WebSocketStream('ws://localhost:8080/updates');
  
  wsStream.subscribe(data => {
    console.log('Получены обновления:', data);
    updateUI(data);
  });
  
  wsStream.connect();
  
  // Отправка данных
  wsStream.send({ type: 'subscribe', channel: 'user-updates' });
  
  return wsStream;
}
```

## Потоки данных с RxJS

### Основы RxJS

```javascript
import { Observable, Subject, BehaviorSubject } from 'rxjs';
import { 
  map, 
  filter, 
  debounceTime, 
  distinctUntilChanged, 
  switchMap, 
  catchError 
} from 'rxjs/operators';

// Создание потока из события
const clickStream = fromEvent(document, 'click');

// Создание потока с начальным значением
const counterStream = new BehaviorSubject(0);

// Комбинирование потоков
clickStream.subscribe(() => {
  counterStream.next(counterStream.value + 1);
});

// Подписка на изменения
counterStream.subscribe(count => {
  console.log('Счетчик:', count);
});
```

### Комплексные потоки данных

```javascript
// Комплексный пример с комбинированием потоков
function createComplexDataStream() {
  // Поток поисковых запросов
  const searchInput = document.getElementById('search-input');
  const searchStream = fromEvent(searchInput, 'input').pipe(
    map(event => event.target.value),
    filter(query => query.length >= 2),
    debounceTime(300),
    distinctUntilChanged()
  );
  
  // Поток результатов поиска
  const searchResultsStream = searchStream.pipe(
    switchMap(query => 
      fetch(`/api/search?q=${encodeURIComponent(query)}`).then(r => r.json())
    ),
    catchError(error => {
      console.error('Ошибка поиска:', error);
      return []; // Возвращаем пустой массив при ошибке
    })
  );
  
  // Поток фильтров
  const filterStream = new Subject();
  
  // Комбинированный поток
  const combinedStream = combineLatest([
    searchResultsStream,
    filterStream.pipe(startWith('all')) // Начальное значение
  ]).pipe(
    map(([results, filter]) => 
      filter === 'all' 
        ? results 
        : results.filter(item => item.category === filter)
    )
  );
  
  return combinedStream;
}
```

## Преимущества потоков данных во фронтенде

### 1. Управление сложной асинхронностью

```javascript
// Управление несколькими асинхронными операциями
function createUserDataStream(userId) {
  return combineLatest([
    // Поток базовой информации о пользователе
    from(fetch(`/api/users/${userId}`)).pipe(
      switchMap(response => response.json())
    ),
    
    // Поток последних действий пользователя
    from(fetch(`/api/users/${userId}/activity`)).pipe(
      switchMap(response => response.json())
    ),
    
    // Поток статистики пользователя
    from(fetch(`/api/users/${userId}/stats`)).pipe(
      switchMap(response => response.json())
    )
  ]).pipe(
    map(([user, activity, stats]) => ({
      ...user,
      activity: activity.slice(0, 5), // Последние 5 действий
      stats
    }))
  );
}
```

### 2. Эффективная обработка событий

```javascript
// Эффективная обработка событий с использованием потоков
function setupEventStreams() {
  const button = document.getElementById('my-button');
  
  // Поток кликов с ограничением частоты
  const clickStream = fromEvent(button, 'click').pipe(
    throttleTime(1000), // Один клик в секунду максимум
    map(() => Date.now())
  );
  
  // Поток двойных кликов
  const doubleClickStream = fromEvent(button, 'click').pipe(
    buffer(clickStream.pipe(debounceTime(250))),
    filter(clicks => clicks.length >= 2),
    map(clicks => clicks.length)
  );
  
  clickStream.subscribe(timestamp => {
    console.log('Клик в', new Date(timestamp).toLocaleTimeString());
  });
  
  doubleClickStream.subscribe(count => {
    console.log(`Двойной клик! (${count} кликов)`);
  });
}
```

### 3. Централизованное управление состоянием

```javascript
// Централизованное состояние как поток данных
class AppStateStream {
  constructor() {
    this.stateSubject = new BehaviorSubject({
      user: null,
      theme: 'light',
      notifications: []
    });
    
    this.actionsSubject = new Subject();
    
    // Обработка действий
    this.actionsSubject.pipe(
      scan(this.reducer, this.stateSubject.value)
    ).subscribe(this.stateSubject);
  }
  
  reducer(state, action) {
    switch (action.type) {
      case 'SET_USER':
        return { ...state, user: action.payload };
      case 'SET_THEME':
        return { ...state, theme: action.payload };
      case 'ADD_NOTIFICATION':
        return {
          ...state,
          notifications: [...state.notifications, action.payload]
        };
      default:
        return state;
    }
  }
  
  dispatch(action) {
    this.actionsSubject.next(action);
  }
  
  select(selector) {
    return this.stateSubject.pipe(
      map(selector),
      distinctUntilChanged()
    );
  }
}

// Использование
const appState = new AppStateStream();

// Подписка на изменения темы
appState.select(state => state.theme).subscribe(theme => {
  document.body.className = theme;
});

// Подписка на пользователя
appState.select(state => state.user).subscribe(user => {
  if (user) {
    console.log('Пользователь вошел:', user.name);
  }
});
```

## Связанные концепции

- [[Реактивное программирование]] - основа потоков данных
- [[Асинхронное программирование]] - асинхронная природа потоков
- [[Управление состоянием]] - потоки данных для управления состоянием
- [[Функциональное программирование]] - функциональные операции над потоками
- [[Иммутабельность]] - неизменяемость данных в потоках

## Лучшие практики

1. **Используйте операторы трансформации** - map, filter, reduce для обработки данных
2. **Управляйте подписками** - всегда отписывайтесь от потоков
3. **Обрабатывайте ошибки** - используйте catchError и другие операторы обработки ошибок
4. **Ограничивайте частоту** - используйте debounce, throttle для оптимизации
5. **Комбинируйте потоки осознанно** - избегайте чрезмерной сложности
6. **Тестируйте потоки данных** - используйте marble тесты для RxJS

## Заключение

Потоки данных предоставляют мощный способ обработки асинхронных событий и изменений в фронтенд-приложениях. Они позволяют создавать более реактивные, предсказуемые и легко тестируемые приложения. Понимание и правильное использование потоков данных является важным навыком для современных фронтенд-разработчиков.