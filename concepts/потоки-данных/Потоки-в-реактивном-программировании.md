---
aliases: ["Reactive Streams", "Reactive Programming", "Реактивное программирование"]
tags: ["#frontend", "#reactive-programming", "#streams", "#observables", "#async"]
---

# Потоки в реактивном программировании

Потоки в реактивном программировании — это способ моделирования и обработки асинхронных данных, которые могут изменяться со временем. Реактивное программирование основывается на понятии потоков данных (streams), которые могут быть наблюдаемыми (observables) и реагировать на изменения в данных.

## Основные концепции

Реактивное программирование строится на нескольких ключевых концепциях:

1. **Потоки (Streams)** — последовательности данных, которые могут изменяться со временем
2. **Наблюдатели (Observers)** — сущности, которые подписываются на потоки и реагируют на изменения
3. **Операторы (Operators)** — функции для преобразования, фильтрации и комбинирования потоков
4. **Подписки (Subscriptions)** — механизм управления жизненным циклом наблюдения

### Преимущества реактивного программирования

- **Обработка асинхронных данных** — эффективная работа с событиями, HTTP-запросами, пользовательским вводом
- **Композиция** — возможность комбинировать простые потоки в сложные
- **Управление состоянием** — централизованное управление изменяющимися данными
- **Отмена операций** — возможность отмены подписок и освобождения ресурсов

### Недостатки

- **Сложность начального понимания** — требует парадигменного сдвига в мышлении
- **Сложность отладки** — сложные цепочки операторов могут быть трудны для отладки
- **Утечки памяти** — неправильное управление подписками может привести к утечкам

## Примеры реализации

### На чистом JavaScript с использованием Observable

```javascript
// Простая реализация Observable
class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }

  subscribe(observer) {
    return this._subscribe(observer);
  }

  static fromEvent(element, eventName) {
    return new Observable(observer => {
      const handler = (event) => observer.next(event);
      element.addEventListener(eventName, handler);
      
      // Возвращаем функцию отписки
      return () => {
        element.removeEventListener(eventName, handler);
      };
    });
  }

  static of(...values) {
    return new Observable(observer => {
      values.forEach(value => observer.next(value));
      observer.complete();
      return () => {};
    });
  }

  map(project) {
    return new Observable(observer => {
      const subscription = this.subscribe({
        next: value => {
          try {
            observer.next(project(value));
          } catch (error) {
            observer.error(error);
          }
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
      
      return () => subscription();
    });
  }

  filter(predicate) {
    return new Observable(observer => {
      const subscription = this.subscribe({
        next: value => {
          try {
            if (predicate(value)) {
              observer.next(value);
            }
          } catch (error) {
            observer.error(error);
          }
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
      
      return () => subscription();
    });
  }

  debounceTime(delay) {
    return new Observable(observer => {
      let timeoutId;
      const subscription = this.subscribe({
        next: value => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => observer.next(value), delay);
        },
        error: error => observer.error(error),
        complete: () => {
          clearTimeout(timeoutId);
          observer.complete();
        }
      });
      
      return () => {
        clearTimeout(timeoutId);
        subscription();
      };
    });
  }
}

// Использование
const button = document.querySelector('#myButton');

// Создаем поток кликов
const clicks$ = Observable.fromEvent(button, 'click');

// Преобразуем поток - подсчитываем клики
const counter$ = clicks$.pipe(
  scan((count, _) => count + 1, 0)
);

// Подписываемся на поток
const subscription = counter$.subscribe({
  next: count => console.log(`Кликов: ${count}`),
  error: error => console.error('Ошибка:', error),
  complete: () => console.log('Поток завершен')
});

// Для отмены подписки
// subscription();
```

### С использованием RxJS

```javascript
import { fromEvent, interval, merge } from 'rxjs';
import { 
  map, 
  filter, 
  debounceTime, 
  scan, 
  throttleTime, 
  distinctUntilChanged 
} from 'rxjs/operators';

// Создание потока событий
const click$ = fromEvent(document, 'click');
const timer$ = interval(1000);

// Комбинирование потоков
const combined$ = merge(
  click$.pipe(map(() => 'click')),
  timer$.pipe(map(i => `timer: ${i}`))
);

// Преобразование и фильтрация
const processed$ = combined$.pipe(
  filter(value => value !== 'timer: 0'), // Фильтруем первое значение таймера
  debounceTime(300), // Подавляем частые события
  scan((acc, value) => [...acc, value], []) // Собираем все значения
);

// Подписка на результат
const subscription = processed$.subscribe({
  next: values => console.log('Накопленные значения:', values),
  error: error => console.error('Ошибка:', error)
});

// Отписка
// subscription.unsubscribe();
```

## Реактивные паттерны

### Subject

Subject — это специальный тип Observable, который может как производить, так и потреблять значения:

```javascript
import { Subject } from 'rxjs';

const subject = new Subject();

subject.subscribe({
  next: value => console.log('Observer 1:', value)
});

subject.subscribe({
  next: value => console.log('Observer 2:', value)
});

subject.next('Привет'); // Оба наблюдателя получат это значение
subject.next('Мир');
```

### BehaviorSubject

BehaviorSubject хранит последнее значение и передает его новым подписчикам:

```javascript
import { BehaviorSubject } from 'rxjs';

const behaviorSubject = new BehaviorSubject('Изначальное значение');

behaviorSubject.subscribe(value => console.log('Первый:', value)); // 'Изначальное значение'

behaviorSubject.next('Новое значение');
behaviorSubject.subscribe(value => console.log('Второй:', value)); // 'Новое значение'
```

## Практические применения

### Поиск с задержкой (debounce)

```javascript
import { fromEvent } from 'rxjs';
import { 
  map, 
  debounceTime, 
  distinctUntilChanged, 
  switchMap 
} from 'rxjs/operators';

const searchInput = document.querySelector('#search-input');
const searchResults = document.querySelector('#search-results');

const searchInput$ = fromEvent(searchInput, 'input').pipe(
  map(event => event.target.value),
  debounceTime(300), // Задержка 300мс
  distinctUntilChanged(), // Только если значение изменилось
  switchMap(query => {
    if (query.length < 2) {
      return of([]); // Возвращаем пустой массив, если запрос короткий
    }
    // Выполняем асинхронный запрос
    return fetch(`/api/search?q=${query}`)
      .then(response => response.json())
      .catch(error => []);
  })
);

searchInput$.subscribe(results => {
  searchResults.innerHTML = results
    .map(item => `<div>${item.title}</div>`)
    .join('');
});
```

### Обработка пользовательского ввода

```javascript
import { fromEvent } from 'rxjs';
import { 
  map, 
  filter, 
  debounceTime, 
  distinctUntilChanged 
} from 'rxjs/operators';

const input = document.querySelector('#username-input');
const validationMessage = document.querySelector('#validation-message');

const usernameValid$ = fromEvent(input, 'input').pipe(
  map(event => event.target.value),
  filter(value => value.length >= 3), // Минимальная длина
  debounceTime(500), // Задержка перед валидацией
  distinctUntilChanged(), // Только если значение изменилось
  map(username => validateUsername(username)) // Валидация
);

usernameValid$.subscribe(isValid => {
  validationMessage.textContent = isValid 
    ? 'Имя пользователя доступно' 
    : 'Имя пользователя недоступно';
  validationMessage.style.color = isValid ? 'green' : 'red';
});

function validateUsername(username) {
  // Простая валидация - в реальности это будет асинхронный запрос
  return !['admin', 'root', 'user'].includes(username);
}
```

## Сравнение с традиционным подходом

В традиционном программировании обработка асинхронных данных часто требует сложного управления состоянием и обработки колбэков. Реактивное программирование предоставляет более декларативный способ описания потоков данных и их преобразований.

## Практические рекомендации

1. **Начинайте с простого** — не используйте сложные операторы без необходимости
2. **Управляйте подписками** — всегда отписывайтесь от потоков, чтобы избежать утечек памяти
3. **Используйте операторы осознанно** — понимайте, что делает каждый оператор
4. **Тестируйте потоки** — реактивные потоки требуют специфических подходов к тестированию
5. **Используйте инструменты разработчика** — RxJS DevTools для отладки потоков

## Заключение

Потоки в реактивном программировании предоставляют мощный способ моделирования и обработки асинхронных данных. Они особенно полезны для обработки пользовательского ввода, HTTP-запросов и других асинхронных событий в фронтенд-приложениях.

Для более глубокого понимания рекомендуется изучить [[Потоки-и-состояние]] и [[Управление-потоками]].

## См. также

- [[Потоки-и-состояние]]
- [[Управление-потоками]]
- [[Однонаправленный-поток-данных]]
- [[Двунаправленный-поток-данных]]
- [[Состояние-приложения]]
- [[Асинхронное-программирование]]
- [[Наблюдаемые-объекты]]