---
aliases: ["Unidirectional Data Flow", "Flux Pattern", "Односторонний поток данных"]
tags: ["#frontend", "#architecture", "#reactive-programming", "#state-management"]
---

# Однонаправленный поток данных

Однонаправленный поток данных (Unidirectional Data Flow) — это архитектурный паттерн, при котором данные движутся по одному направлению через приложение. Это означает, что изменения состояния происходят в одном месте, и все компоненты, зависящие от этого состояния, обновляются последовательно, обеспечивая предсказуемое поведение приложения.

## Основные концепции

В однонаправленном потоке данных обычно выделяют следующие элементы:

1. **Состояние (State)** — централизованное хранилище данных приложения
2. **Действия (Actions)** — события, инициирующие изменение состояния
3. **Редьюсеры (Reducers)** — чистые функции, определяющие как изменяется состояние на основе действий
4. **Представление (View)** — компоненты, отображающие данные и генерирующие действия

### Преимущества

- **Предсказуемость** — легче понимать, как данные изменяются
- **Отладка** — проще отслеживать изменения состояния
- **Тестируемость** — редьюсеры легко тестировать как чистые функции
- **Поддерживаемость** — структура кода более понятна и организована

### Недостатки

- **Сложность начального понимания** — требует больше кода для простых задач
- **Бойлерплейт** — необходимость создания множества вспомогательных функций и структур

## Пример реализации

Рассмотрим простой пример на JavaScript, демонстрирующий основные концепции:

```javascript
// Состояние приложения
const initialState = {
  count: 0,
  todos: []
};

// Типы действий
const ActionTypes = {
  INCREMENT: 'INCREMENT',
  DECREMENT: 'DECREMENT',
  ADD_TODO: 'ADD_TODO'
};

// Редьюсер
function reducer(state = initialState, action) {
  switch (action.type) {
    case ActionTypes.INCREMENT:
      return {
        ...state,
        count: state.count + 1
      };
    case ActionTypes.DECREMENT:
      return {
        ...state,
        count: state.count - 1
      };
    case ActionTypes.ADD_TODO:
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload.text,
            completed: false
          }
        ]
      };
    default:
      return state;
  }
}

// Диспетчер действий
function createStore(reducer, initialState) {
  let state = initialState;
  let listeners = [];

  function getState() {
    return state;
  }

  function dispatch(action) {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
  }

  function subscribe(listener) {
    listeners.push(listener);
    return () => {
      listeners = listeners.filter(l => l !== listener);
    };
  }

  return {
    getState,
    dispatch,
    subscribe
  };
}

// Использование
const store = createStore(reducer, initialState);

// Подписка на изменения состояния
store.subscribe(() => {
  console.log('Состояние изменилось:', store.getState());
});

// Выполнение действий
store.dispatch({ type: ActionTypes.INCREMENT });
store.dispatch({ 
  type: ActionTypes.ADD_TODO, 
  payload: { text: 'Изучить однонаправленный поток данных' } 
});
```

## Реализации в популярных фреймворках

### React (с использованием Redux)

Redux — это популярная библиотека для управления состоянием, реализующая принципы однонаправленного потока данных:

```jsx
import React from 'react';
import { createStore } from 'redux';
import { Provider, useSelector, useDispatch } from 'react-redux';

// Редьюсер
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

// Создание хранилища
const store = createStore(counterReducer);

// Компонент
const Counter = () => {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>
        Увеличить
      </button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>
        Уменьшить
      </button>
    </div>
  );
};

// Обертка приложения
const App = () => (
  <Provider store={store}>
    <Counter />
  </Provider>
);
```

### Vue.js

В Vue.js можно реализовать однонаправленный поток данных с помощью Vuex:

```javascript
import { createStore } from 'vuex';

const store = createStore({
  state() {
    return {
      count: 0
    }
  },
  mutations: {
    increment(state) {
      state.count++;
    },
    decrement(state) {
      state.count--;
    }
  },
  actions: {
    increment({ commit }) {
      commit('increment');
    },
    decrement({ commit }) {
      commit('decrement');
    }
  }
});

// В компоненте
export default {
  computed: {
    count() {
      return this.$store.state.count;
    }
  },
  methods: {
    increment() {
      this.$store.dispatch('increment');
    },
    decrement() {
      this.$store.dispatch('decrement');
    }
  }
}
```

## Сравнение с двунаправленным потоком данных

[[Двунаправленный-поток-данных]] позволяет изменять данные как из модели, так и из представления, что может привести к неожиданным изменениям состояния. Однонаправленный поток данных обеспечивает более предсказуемое поведение, особенно в сложных приложениях.

## Практические рекомендации

1. **Начинайте с простого** — не используйте сложные архитектуры для маленьких приложений
2. **Организуйте действия** — используйте константы для типов действий
3. **Создавайте чистые редьюсеры** — они не должны иметь побочных эффектов
4. **Используйте инструменты разработчика** — такие как Redux DevTools для отладки
5. **Разделяйте сложные редьюсеры** — используйте `combineReducers` для улучшения читаемости

## Заключение

Однонаправленный поток данных — мощный инструмент для управления состоянием в современных фронтенд-приложениях. Он обеспечивает предсказуемость, тестируемость и поддерживаемость кода, особенно в крупных проектах.

Для более глубокого понимания потоков данных рекомендуется изучить [[Потоки-и-состояние]] и [[Управление-потоками]].

## См. также

- [[Двунаправленный-поток-данных]]
- [[Потоки-в-реактивном-программировании]]
- [[Потоки-и-состояние]]
- [[Управление-потоками]]
- [[Состояние-приложения]]
- [[Архитектура-фронтенд-приложений]]