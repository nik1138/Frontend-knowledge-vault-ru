---
aliases: [Компоненты, Component Approach]
tags: [programming, frontend, architecture, react, vue]
---

# Компонентный подход

**Компонентный подход** — это методология разработки программного обеспечения, при которой приложение строится из независимых, переиспользуемых компонентов. Каждый компонент инкапсулирует в себе определенную функциональность, визуальное представление и состояние.

## Основные принципы компонентного подхода

### 1. Инкапсуляция

Каждый компонент инкапсулирует свою логику, представление и состояние:

```jsx
// React компонент с инкапсуляцией
function Counter({ initialValue = 0 }) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);
  
  return (
    <div className="counter">
      <h3>Счетчик: {count}</h3>
      <div className="counter-buttons">
        <button onClick={decrement}>-</button>
        <button onClick={reset}>Сброс</button>
        <button onClick={increment}>+</button>
      </div>
    </div>
  );
}
```

### 2. Повторное использование

Компоненты могут использоваться многократно в разных частях приложения:

```jsx
// Использование компонента в разных местах
function App() {
  return (
    <div>
      <Counter initialValue={0} />
      <Counter initialValue={10} />
      <Counter initialValue={100} />
    </div>
  );
}
```

### 3. Композиция

Компоненты могут объединяться для создания более сложных компонентов:

```jsx
// Композиция компонентов
function Dashboard() {
  return (
    <div className="dashboard">
      <Header />
      <MainContent>
        <UserProfile />
        <RecentActivity />
        <StatCards />
      </MainContent>
      <Footer />
    </div>
  );
}

function MainContent({ children }) {
  return <main className="main-content">{children}</main>;
}
```

## Типы компонентов

### Компоненты представления (Dumb/Presentational Components)

```jsx
// Компонент только для отображения данных
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
        <p>{user.role}</p>
      </div>
      <div className="user-actions">
        <button onClick={() => onEdit(user.id)}>Редактировать</button>
        <button onClick={() => onDelete(user.id)}>Удалить</button>
      </div>
    </div>
  );
}
```

### Контейнерные компоненты (Smart/Container Components)

```jsx
// Компонент с логикой и состоянием
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUsers()
      .then(setUsers)
      .finally(() => setLoading(false));
  }, []);
  
  const handleEdit = (userId) => {
    // Логика редактирования
  };
  
  const handleDelete = (userId) => {
    setUsers(users.filter(user => user.id !== userId));
  };
  
  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

## Структура компонентов

### Жизненный цикл компонента (React Class Components)

```jsx
class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      loading: true,
      error: null
    };
  }
  
  // Монтирование
  componentDidMount() {
    this.fetchUserProfile();
  }
  
  // Обновление
  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.fetchUserProfile();
    }
  }
  
  // Размонтирование
  componentWillUnmount() {
    // Очистка ресурсов
    this.cancelPendingRequests();
  }
  
  fetchUserProfile = async () => {
    this.setState({ loading: true, error: null });
    
    try {
      const user = await api.getUser(this.props.userId);
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  };
  
  render() {
    const { user, loading, error } = this.state;
    
    if (loading) return <div>Загрузка профиля...</div>;
    if (error) return <div>Ошибка: {error}</div>;
    if (!user) return <div>Пользователь не найден</div>;
    
    return (
      <div className="user-profile">
        <h2>{user.name}</h2>
        <p>{user.email}</p>
      </div>
    );
  }
}
```

### Хуки в функциональных компонентах

```jsx
// Функциональный компонент с хуками
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isCancelled = false;
    
    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const userData = await api.getUser(userId);
        
        if (!isCancelled) {
          setUser(userData);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message);
        }
      } finally {
        if (!isCancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchUser();
    
    // Функция очистки
    return () => {
      isCancelled = true;
    };
  }, [userId]);
  
  if (loading) return <div>Загрузка профиля...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  if (!user) return <div>Пользователь не найден</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

## Продвинутые паттерны компонентов

### Render Props

```jsx
// Компонент с render prop
function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return children({ data, loading, error });
}

// Использование
function App() {
  return (
    <DataFetcher url="/api/users">
      {({ data, loading, error }) => {
        if (loading) return <div>Загрузка...</div>;
        if (error) return <div>Ошибка: {error.message}</div>;
        return <UserList users={data} />;
      }}
    </DataFetcher>
  );
}
```

### Higher-Order Components (HOC)

```jsx
// HOC для аутентификации
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
      // Проверка аутентификации
      checkAuthStatus()
        .then(auth => {
          setIsAuthenticated(auth);
          setLoading(false);
        });
    }, []);
    
    if (loading) return <div>Проверка аутентификации...</div>;
    if (!isAuthenticated) return <div>Требуется аутентификация</div>;
    
    return <WrappedComponent {...props} />;
  };
}

// Использование HOC
const ProtectedProfile = withAuth(UserProfile);
```

### Compound Components

```jsx
// Компонент с внутренними компонентами
function Tabs({ children, activeTab, onTabChange }) {
  return (
    <div className="tabs">
      <div className="tab-list">
        {React.Children.map(children, (child, index) => {
          if (child.type === Tab) {
            return React.cloneElement(child, {
              isActive: activeTab === index,
              onClick: () => onTabChange(index)
            });
          }
          return child;
        })}
      </div>
      <div className="tab-content">
        {React.Children.toArray(children)[activeTab]}
      </div>
    </div>
  );
}

function Tab({ children, isActive, onClick }) {
  return (
    <button 
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// Использование
function App() {
  const [activeTab, setActiveTab] = useState(0);
  
  return (
    <Tabs activeTab={activeTab} onTabChange={setActiveTab}>
      <Tab>Профиль</Tab>
      <Tab>Настройки</Tab>
      <Tab>Сообщения</Tab>
      
      <div>Содержимое профиля</div>
      <div>Содержимое настроек</div>
      <div>Содержимое сообщений</div>
    </Tabs>
  );
}
```

## Архитектура компонентов

### Система дизайна компонентов

```jsx
// Базовые компоненты (атомы)
const Button = ({ children, variant = 'primary', onClick, disabled }) => (
  <button 
    className={`btn btn--${variant} ${disabled ? 'btn--disabled' : ''}`}
    onClick={onClick}
    disabled={disabled}
  >
    {children}
  </button>
);

const Input = ({ label, value, onChange, type = 'text', ...props }) => (
  <div className="input-group">
    {label && <label>{label}</label>}
    <input 
      type={type} 
      value={value} 
      onChange={onChange} 
      {...props} 
    />
  </div>
);

// Композитные компоненты (молекулы)
const FormField = ({ label, value, onChange, error, ...props }) => (
  <div className="form-field">
    <Input label={label} value={value} onChange={onChange} {...props} />
    {error && <span className="error">{error}</span>}
  </div>
);

// Сложные компоненты (организмы)
const UserForm = ({ onSubmit, initialData = {} }) => {
  const [formData, setFormData] = useState(initialData);
  const [errors, setErrors] = useState({});
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validateUser(formData);
    if (Object.keys(validationErrors).length === 0) {
      onSubmit(formData);
    } else {
      setErrors(validationErrors);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="user-form">
      <FormField 
        label="Имя" 
        value={formData.name || ''} 
        onChange={e => setFormData({...formData, name: e.target.value})}
        error={errors.name}
      />
      <FormField 
        label="Email" 
        value={formData.email || ''} 
        onChange={e => setFormData({...formData, email: e.target.value})}
        error={errors.email}
      />
      <Button type="submit">Сохранить</Button>
    </form>
  );
};
```

## Лучшие практики компонентного подхода

### 1. Четкая иерархия

```jsx
// Хорошо: логическая иерархия
const App = () => (
  <Layout>
    <Navigation />
    <Main>
      <Hero />
      <Features />
      <Testimonials />
    </Main>
    <Footer />
  </Layout>
);
```

### 2. Управление пропсами

```jsx
// Использование destructuring и defaultProps
function Avatar({ 
  src, 
  alt = 'Аватар пользователя', 
  size = 'medium', 
  rounded = true 
}) {
  const sizeClasses = {
    small: 'avatar--small',
    medium: 'avatar--medium', 
    large: 'avatar--large'
  };
  
  return (
    <img 
      src={src} 
      alt={alt}
      className={`
        avatar 
        ${sizeClasses[size]} 
        ${rounded ? 'avatar--rounded' : ''}
      `}
    />
  );
}

Avatar.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  rounded: PropTypes.bool
};
```

### 3. Обработка состояния

```jsx
// Пользовательский хук для управления состоянием компонента
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  
  return [value, { toggle, setTrue, setFalse }];
}

// Использование в компоненте
function Dropdown({ children }) {
  const [isOpen, { toggle, setFalse }] = useToggle(false);
  
  return (
    <div className="dropdown">
      <button onClick={toggle}>Меню</button>
      {isOpen && (
        <div className="dropdown-menu" onClick={setFalse}>
          {children}
        </div>
      )}
    </div>
  );
}
```

## Связанные концепции

- [[Модульность]] - компоненты как модули функциональности
- [[Управление состоянием]] - работа с состоянием компонентов
- [[Типизация]] - типизация компонентов и пропсов
- [[Жизненный цикл компонента]] - управление жизненным циклом
- [[Декларативное программирование]] - декларативный подход к созданию UI
- [[Реактивное программирование]] - реактивность компонентов

## Преимущества компонентного подхода

1. **Повторное использование**: компоненты можно использовать в разных частях приложения
2. **Поддерживаемость**: изменения в компоненте автоматически применяются ко всем его использованиям
3. **Тестируемость**: компоненты можно тестировать изолированно
4. **Масштабируемость**: легче добавлять новую функциональность
5. **Совместная работа**: команды могут работать над разными компонентами независимо

## Заключение

Компонентный подход является фундаментальным принципом современной фронтенд-разработки. Он позволяет создавать более организованные, поддерживаемые и масштабируемые приложения. Понимание и правильное применение компонентного подхода критически важно для разработки качественного фронтенда.