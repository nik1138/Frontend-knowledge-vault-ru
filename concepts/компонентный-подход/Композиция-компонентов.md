---
aliases: ["Композиция компонентов", "Комбинирование компонентов", "Composition"]
tags: [frontend, components, react, vue, angular, architecture]
---

# Композиция компонентов

Композиция компонентов — это фундаментальный принцип компонентного подхода, заключающийся в создании сложных интерфейсов путём объединения простых и переиспользуемых компонентов. Это позволяет строить иерархические структуры компонентов, где каждый уровень отвечает за определённую часть функциональности.

## Основные понятия

**Композиция** — это процесс объединения нескольких компонентов в более сложную структуру, где каждый компонент выполняет свою конкретную задачу. Это альтернатива наследованию и позволяет создавать гибкие и масштабируемые интерфейсы.

### Принципы композиции

1. **Компоненты высокого порядка** (Higher-Order Components)
2. **Контейнеры и презентационные компоненты**
3. **Слоты и дочерние элементы**
4. **Render props**

## Реализация в различных фреймворках

### React

#### Базовая композиция

```jsx
// Простой компонент-контейнер
function Card({ title, children }) {
  return (
    <div className="card">
      <div className="card-header">
        <h2>{title}</h2>
      </div>
      <div className="card-body">
        {children}
      </div>
    </div>
  );
}

// Компонент-содержимое
function UserProfile({ user }) {
  return (
    <div>
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.bio}</p>
    </div>
  );
}

// Композиция компонентов
function App() {
  const user = {
    name: "Алексей Петров",
    avatar: "/avatar.jpg",
    bio: "Разработчик интерфейсов"
  };

  return (
    <Card title="Профиль пользователя">
      <UserProfile user={user} />
    </Card>
  );
}
```

#### Render Props

```jsx
// Компонент, предоставляющий данные через render prop
class DataFetcher extends React.Component {
  constructor(props) {
    super(props);
    this.state = { data: null, loading: true };
  }

  async componentDidMount() {
    try {
      const response = await fetch(this.props.url);
      const data = await response.json();
      this.setState({ data, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  }

  render() {
    return this.props.children(this.state);
  }
}

// Использование с render prop
function UserList() {
  return (
    <DataFetcher url="/api/users">
      {({ data, loading, error }) => {
        if (loading) return <div>Загрузка...</div>;
        if (error) return <div>Ошибка: {error.message}</div>;
        
        return (
          <ul>
            {data.map(user => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>
        );
      }}
    </DataFetcher>
  );
}
```

#### Компоненты высокого порядка (HOC)

```jsx
// HOC для добавления логики загрузки данных
function withData(WrappedComponent, url) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { data: null, loading: true };
    }

    async componentDidMount() {
      try {
        const response = await fetch(url);
        const data = await response.json();
        this.setState({ data, loading: false });
      } catch (error) {
        this.setState({ error, loading: false });
      }
    }

    render() {
      return (
        <WrappedComponent
          {...this.props}
          data={this.state.data}
          loading={this.state.loading}
          error={this.state.error}
        />
      );
    }
  };
}

// Использование HOC
function PostList({ data, loading, error }) {
  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error.message}</div>;

  return (
    <ul>
      {data.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

const PostListWithData = withData(PostList, '/api/posts');
```

#### Хуки для композиции

```jsx
// Кастомный хук для управления формой
import { useState, useCallback } from 'react';

function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  const handleChange = useCallback((name, value) => {
    setValues(prev => ({
      ...prev,
      [name]: value
    }));
  }, []);

  const reset = useCallback(() => {
    setValues(initialValues);
  }, [initialValues]);

  return { values, handleChange, reset };
}

// Использование кастомного хука
function ContactForm() {
  const { values, handleChange, reset } = useForm({
    name: '',
    email: '',
    message: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Отправлено:', values);
    reset();
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={values.name}
        onChange={(e) => handleChange('name', e.target.value)}
        placeholder="Имя"
      />
      <input
        type="email"
        value={values.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder="Email"
      />
      <textarea
        value={values.message}
        onChange={(e) => handleChange('message', e.target.value)}
        placeholder="Сообщение"
      />
      <button type="submit">Отправить</button>
    </form>
  );
}
```

### Vue.js

#### Базовая композиция

```vue
<!-- Card.vue -->
<template>
  <div class="card">
    <div class="card-header">
      <slot name="header"></slot>
    </div>
    <div class="card-body">
      <slot></slot>
    </div>
    <div class="card-footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>

<style>
.card {
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 16px;
}
</style>
```

```vue
<!-- UserProfile.vue -->
<template>
  <div class="user-profile">
    <img :src="user.avatar" :alt="user.name" />
    <h3>{{ user.name }}</h3>
    <p>{{ user.bio }}</p>
  </div>
</template>

<script>
export default {
  name: 'UserProfile',
  props: {
    user: Object
  }
}
</script>
```

```vue
<!-- App.vue -->
<template>
  <Card>
    <template #header>
      <h2>Профиль пользователя</h2>
    </template>
    
    <UserProfile :user="user" />
    
    <template #footer>
      <button @click="editProfile">Редактировать</button>
    </template>
  </Card>
</template>

<script>
import Card from './Card.vue';
import UserProfile from './UserProfile.vue';

export default {
  components: {
    Card,
    UserProfile
  },
  data() {
    return {
      user: {
        name: "Алексей Петров",
        avatar: "/avatar.jpg",
        bio: "Разработчик интерфейсов"
      }
    };
  },
  methods: {
    editProfile() {
      // Логика редактирования
    }
  }
}
</script>
```

#### Composition API для композиции

```vue
<!-- useUser.js -->
import { ref, onMounted } from 'vue';

export function useUser(userId) {
  const user = ref(null);
  const loading = ref(true);
  const error = ref(null);

  async function fetchUser() {
    try {
      loading.value = true;
      const response = await fetch(`/api/users/${userId}`);
      user.value = await response.json();
    } catch (err) {
      error.value = err;
    } finally {
      loading.value = false;
    }
  }

  onMounted(fetchUser);

  return { user, loading, error, fetchUser };
}
```

```vue
<!-- UserProfile.vue -->
<template>
  <div v-if="loading">Загрузка...</div>
  <div v-else-if="error">Ошибка: {{ error.message }}</div>
  <div v-else class="user-profile">
    <img :src="user.avatar" :alt="user.name" />
    <h3>{{ user.name }}</h3>
    <p>{{ user.bio }}</p>
  </div>
</template>

<script>
import { useUser } from './composables/useUser';

export default {
  name: 'UserProfile',
  props: {
    userId: String
  },
  setup(props) {
    const { user, loading, error, fetchUser } = useUser(props.userId);

    return {
      user,
      loading,
      error,
      fetchUser
    };
  }
}
</script>
```

#### Mixins для композиции (устаревший подход)

```javascript
// userMixin.js
export const userMixin = {
  data() {
    return {
      user: null,
      loading: true,
      error: null
    };
  },
  methods: {
    async fetchUser(userId) {
      try {
        this.loading = true;
        const response = await fetch(`/api/users/${userId}`);
        this.user = await response.json();
      } catch (err) {
        this.error = err;
      } finally {
        this.loading = false;
      }
    }
  },
  mounted() {
    this.fetchUser(this.userId);
  }
};
```

### Angular

#### Базовая композиция

```typescript
// card.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-card',
  template: `
    <div class="card">
      <div class="card-header">
        <ng-content select="[slot=header]"></ng-content>
      </div>
      <div class="card-body">
        <ng-content></ng-content>
      </div>
      <div class="card-footer">
        <ng-content select="[slot=footer]"></ng-content>
      </div>
    </div>
  `,
  styles: [`
    .card {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 16px;
    }
  `]
})
export class CardComponent { }
```

```typescript
// user-profile.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `
    <div class="user-profile">
      <img [src]="user.avatar" [alt]="user.name" />
      <h3>{{ user.name }}</h3>
      <p>{{ user.bio }}</p>
    </div>
  `
})
export class UserProfileComponent {
  @Input() user: any;
}
```

```html
<!-- app.component.html -->
<app-card>
  <div slot="header">
    <h2>Профиль пользователя</h2>
  </div>
  
  <app-user-profile [user]="user"></app-user-profile>
  
  <div slot="footer">
    <button (click)="editProfile()">Редактировать</button>
  </div>
</app-card>
```

## Паттерны композиции

### Контейнеры и презентационные компоненты

```jsx
// Презентационный компонент
function UserCard({ user, onEdit }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.bio}</p>
      <button onClick={onEdit}>Редактировать</button>
    </div>
  );
}

// Контейнерный компонент
class UserContainer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { user: null };
  }

  async componentDidMount() {
    const response = await fetch(`/api/users/${this.props.userId}`);
    const user = await response.json();
    this.setState({ user });
  }

  handleEdit = () => {
    // Логика редактирования
  }

  render() {
    if (!this.state.user) return <div>Загрузка...</div>;
    return <UserCard user={this.state.user} onEdit={this.handleEdit} />;
  }
}
```

### Provider Pattern

```jsx
// ThemeContext.js
import React, { createContext, useContext } from 'react';

const ThemeContext = createContext();

export function ThemeProvider({ children, theme }) {
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const theme = useContext(ThemeContext);
  if (theme === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return theme;
}
```

```jsx
// App.js
function App() {
  const [theme, setTheme] = React.useState('light');

  return (
    <ThemeProvider theme={{ current: theme, setTheme }}>
      <Header />
      <MainContent />
      <Footer />
    </ThemeProvider>
  );
}

// Header.js
function Header() {
  const { current: theme } = useTheme();

  return (
    <header className={`header ${theme}`}>
      <h1>Мой сайт</h1>
      <ThemeToggle />
    </header>
  );
}
```

### Compound Components

```jsx
// Accordion.js
import React, { useState, createContext, useContext } from 'react';

const AccordionContext = createContext();

export function Accordion({ children, defaultIndex = 0 }) {
  const [activeIndex, setActiveIndex] = useState(defaultIndex);

  return (
    <AccordionContext.Provider value={{ activeIndex, setActiveIndex }}>
      <div className="accordion">
        {React.Children.map(children, (child, index) =>
          React.cloneElement(child, { index })
        )}
      </div>
    </AccordionContext.Provider>
  );
}

export function AccordionItem({ children, index }) {
  const { activeIndex, setActiveIndex } = useContext(AccordionContext);
  const isActive = index === activeIndex;

  return (
    <div className={`accordion-item ${isActive ? 'active' : ''}`}>
      {React.Children.map(children, child => {
        if (child.type === AccordionHeader) {
          return React.cloneElement(child, { onClick: () => setActiveIndex(index) });
        }
        return child;
      })}
    </div>
  );
}

export function AccordionHeader({ children, onClick }) {
  return (
    <div className="accordion-header" onClick={onClick}>
      {children}
    </div>
  );
}

export function AccordionContent({ children }) {
  const { activeIndex } = useContext(AccordionContext);
  const isActive = activeIndex !== undefined;

  return (
    <div className={`accordion-content ${isActive ? 'active' : ''}`}>
      {children}
    </div>
  );
}
```

## Лучшие практики

1. **Создавайте компоненты с одной ответственностью** - каждый компонент должен выполнять одну конкретную задачу
2. **Используйте композицию вместо наследования** - композиция более гибкая и предсказуемая
3. **Создавайте переиспользуемые компоненты** - изолируйте общую функциональность в отдельные компоненты
4. **Документируйте интерфейс компонентов** - понятные пропсы и слоты делают компоненты легче в использовании
5. **Используйте именованные слоты** - это делает композицию более явной и понятной

## Антипаттерны

1. **Слишком глубокая иерархия компонентов** - усложняет отладку и понимание
2. **Компоненты с множественной ответственностью** - нарушают принцип единственной ответственности
3. **Избыточное дублирование логики** - вместо этого используйте кастомные хуки или композицию
4. **Сложные цепочки пропсов** - используйте контекст для передачи данных через несколько уровней

## Заключение

Композиция компонентов — мощный инструмент для создания гибких и поддерживаемых интерфейсов. Правильное использование паттернов композиции позволяет создавать переиспользуемые, тестируемые и понятные компоненты.

См. также: [[Компоненты-и-их-свойства]], [[Жизненный-цикл-компонентов]], [[Переиспользование-компонентов]], [[Стили-компонентов]]

</content>