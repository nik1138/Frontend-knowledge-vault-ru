---
aliases: ["Цикл жизни компонента", "Lifecycle", "Компонентный жизненный цикл"]
tags: [frontend, components, react, vue, angular, lifecycle]
---

# Жизненный цикл компонентов

Жизненный цикл компонента — это последовательность фаз, через которые проходит компонент от своего создания до уничтожения. Понимание жизненного цикла позволяет разработчику управлять поведением компонента на разных этапах, выполнять инициализацию, обновление и очистку ресурсов.

## Основные фазы жизненного цикла

Жизненный цикл компонента обычно включает следующие фазы:

1. **Монтирование** — создание и вставка компонента в DOM
2. **Обновление** — изменение состояния или свойств компонента
3. **Размонтирование** — удаление компонента из DOM и очистка ресурсов

## Реализация в различных фреймворках

### React

В React существуют два подхода к работе с жизненным циклом: классовые компоненты и хуки.

#### Классовые компоненты

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    console.log('1. Конструктор');
  }

  static getDerivedStateFromProps(props, state) {
    console.log('2. getDerivedStateFromProps');
    // Возврат нового состояния или null
    return null;
  }

  componentDidMount() {
    console.log('3. componentDidMount');
    // Выполняется после монтирования
    // Здесь можно делать API вызовы, добавлять обработчики событий
  }

  shouldComponentUpdate(nextProps, nextState) {
    console.log('4. shouldComponentUpdate');
    // Определяет, должен ли компонент перерисовываться
    return true;
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('5. getSnapshotBeforeUpdate');
    // Выполняется перед обновлением DOM
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('6. componentDidUpdate');
    // Выполняется после обновления
    // Здесь можно работать с DOM после обновления
  }

  componentWillUnmount() {
    console.log('7. componentWillUnmount');
    // Выполняется перед размонтированием
    // Здесь нужно очищать ресурсы: таймеры, подписки, обработчики
  }

  render() {
    console.log('Render');
    return <div>Счётчик: {this.state.count}</div>;
  }
}
```

#### Функциональные компоненты с хуками

```jsx
import React, { useState, useEffect } from 'react';

function MyComponent({ initialCount }) {
  const [count, setCount] = useState(initialCount);

  // Эквивалент componentDidMount
  useEffect(() => {
    console.log('Component mounted');
    
    // Очистка (эквивалент componentWillUnmount)
    return () => {
      console.log('Component will unmount');
    };
  }, []); // Пустой массив зависимостей означает выполнение только при монтировании

  // Эквивалент componentDidUpdate
  useEffect(() => {
    console.log('Count updated:', count);
    
    // Очистка после обновления
    return () => {
      console.log('Cleanup after count update');
    };
  }, [count]); // Выполняется при изменении count

  // Комбинация componentDidMount и componentDidUpdate
  useEffect(() => {
    console.log('Component mounted or updated');
  }); // Выполняется при каждом рендере

  return (
    <div>
      <p>Счётчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

##### Практические примеры использования useEffect

**API вызовы:**
```jsx
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Ошибка загрузки пользователя:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]); // Перезагружаем при изменении userId

  if (loading) return <div>Загрузка...</div>;
  if (!user) return <div>Пользователь не найден</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

**Подписка на события:**
```jsx
import { useState, useEffect } from 'react';

function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);

    // Очистка - удаление обработчика
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Выполняется только при монтировании

  return (
    <div>
      Ширина: {windowSize.width}, Высота: {windowSize.height}
    </div>
  );
}
```

### Vue.js

В Vue.js жизненный цикл представлен хуками:

```javascript
export default {
  name: 'MyComponent',
  
  // 1. setup() (для Composition API)
  // Вызывается перед созданием компонента
  
  // 2. beforeCreate
  beforeCreate() {
    console.log('beforeCreate: Экземпляр создается, но перед инициализацией');
  },
  
  // 3. created
  created() {
    console.log('created: Экземпляр создан, реактивность инициализирована');
    // Здесь можно обращаться к this.data, this.methods
    // API вызовы часто делают здесь
  },
  
  // 4. beforeMount
  beforeMount() {
    console.log('beforeMount: DOM еще не создан');
  },
  
  // 5. mounted
  mounted() {
    console.log('mounted: Компонент вставлен в DOM');
    // Здесь можно работать с DOM элементами
  },
  
  // 6. beforeUpdate
  beforeUpdate() {
    console.log('beforeUpdate: Компонент обновляется');
  },
  
  // 7. updated
  updated() {
    console.log('updated: Компонент обновлен в DOM');
  },
  
  // 8. beforeUnmount (ранее beforeDestroy)
  beforeUnmount() {
    console.log('beforeUnmount: Компонент будет размонтирован');
  },
  
  // 9. unmounted (ранее destroyed)
  unmounted() {
    console.log('unmounted: Компонент размонтирован');
  },
  
  // Рендер функция или шаблон
  template: `<div>Счётчик: {{ count }}</div>`
}
```

#### Composition API в Vue 3

```vue
<template>
  <div>
    <p>Счётчик: {{ count }}</p>
    <button @click="increment">+</button>
  </div>
</template>

<script>
import { ref, onMounted, onUpdated, onUnmounted } from 'vue';

export default {
  name: 'MyComponent',
  setup() {
    const count = ref(0);
    
    const increment = () => {
      count.value++;
    };
    
    // Эквивалент mounted
    onMounted(() => {
      console.log('Компонент смонтирован');
      // API вызовы, DOM манипуляции
    });
    
    // Эквивалент updated
    onUpdated(() => {
      console.log('Компонент обновлён');
    });
    
    // Эквивалент unmounted
    onUnmounted(() => {
      console.log('Компонент будет размонтирован');
      // Очистка ресурсов
    });
    
    return {
      count,
      increment
    };
  }
}
</script>
```

### Angular

В Angular жизненный цикл представлен интерфейсами:

```typescript
import { Component, OnInit, OnDestroy, OnChanges, DoCheck, 
         AfterViewInit, AfterViewChecked, AfterContentInit, AfterContentChecked } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `<div>Счётчик: {{ count }}</div>`
})
export class MyComponent implements OnInit, OnDestroy, OnChanges, DoCheck, 
                                    AfterViewInit, AfterViewChecked, AfterContentInit, AfterContentChecked {
  
  count = 0;
  
  // 1. ngOnChanges - вызывается при изменении входных свойств
  ngOnChanges() {
    console.log('ngOnChanges: Входные свойства изменились');
  }
  
  // 2. ngOnInit - вызывается после инициализации компонента
  ngOnInit() {
    console.log('ngOnInit: Компонент инициализирован');
    // API вызовы, инициализация данных
  }
  
  // 3. ngDoCheck - вызывается при проверке изменений
  ngDoCheck() {
    console.log('ngDoCheck: Проверка изменений');
  }
  
  // 4. ngAfterContentInit - вызывается после проецирования контента
  ngAfterContentInit() {
    console.log('ngAfterContentInit: Контент инициализирован');
  }
  
  // 5. ngAfterContentChecked - вызывается после проверки контента
  ngAfterContentChecked() {
    console.log('ngAfterContentChecked: Контент проверен');
  }
  
  // 6. ngAfterViewInit - вызывается после инициализации представления
  ngAfterViewInit() {
    console.log('ngAfterViewInit: Представление инициализировано');
    // Работа с ViewChild элементами
  }
  
  // 7. ngAfterViewChecked - вызывается после проверки представления
  ngAfterViewChecked() {
    console.log('ngAfterViewChecked: Представление проверено');
  }
  
  // 8. ngOnDestroy - вызывается перед уничтожением компонента
  ngOnDestroy() {
    console.log('ngOnDestroy: Компонент будет уничтожен');
    // Очистка ресурсов, отписка от событий
  }
}
```

## Практические применения

### Инициализация данных

```jsx
// React
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId).then(userData => setUser(userData));
  }, [userId]); // Перезагрузка при изменении userId

  return user ? <div>{user.name}</div> : <div>Загрузка...</div>;
}
```

### Управление подписками

```jsx
// React
function Chat({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const subscription = subscribeToRoom(roomId, newMessage => {
      setMessages(prev => [...prev, newMessage]);
    });

    // Очистка при размонтировании или изменении roomId
    return () => {
      subscription.unsubscribe();
    };
  }, [roomId]);

  return (
    <ul>
      {messages.map((msg, i) => <li key={i}>{msg}</li>)}
    </ul>
  );
}
```

### Анимации и DOM манипуляции

```javascript
// Vue.js
export default {
  mounted() {
    // Анимация при монтировании
    this.$el.style.opacity = 0;
    setTimeout(() => {
      this.$el.style.transition = 'opacity 0.5s';
      this.$el.style.opacity = 1;
    }, 100);
  },
  
  updated() {
    // Анимация при обновлении
    this.$el.style.backgroundColor = 'yellow';
    setTimeout(() => {
      this.$el.style.backgroundColor = '';
    }, 300);
  }
}
```

## Обработка ошибок

### React Error Boundaries

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Ошибка компонента:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```

## Лучшие практики

1. **Используйте хуки в React** вместо классовых компонентов для новых проектов
2. **Очищайте ресурсы** в соответствующих методах жизненного цикла
3. **Избегайте ненужных вызовов API** при обновлениях компонента
4. **Оптимизируйте производительность** с помощью memo, useCallback, useMemo
5. **Документируйте логику** в хуках жизненного цикла

## Заключение

Понимание жизненного цикла компонентов позволяет создавать более предсказуемые и эффективные приложения. Каждый фреймворк предоставляет свои инструменты для управления жизненным циклом, но общие принципы остаются схожими.

См. также: [[Компоненты-и-их-свойства]], [[Композиция-компонентов]], [[Переиспользование-компонентов]], [[Стили-компонентов]]

</content>