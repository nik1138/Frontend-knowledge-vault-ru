---
aliases: [Композиция вместо наследования, Принцип композиции, Композиция над наследованием]
tags: [programming, principles, oop, design-patterns]
---

# Композиция вместо наследования

Композиция вместо наследования — это принцип объектно-ориентированного программирования, утверждающий, что объекты должны доставлять функциональность посредством делегирования и агрегирования, а не через наследование от базового класса. Этот принцип помогает создавать более гибкий, поддерживаемый и тестируемый код.

## Суть принципа

> Сделай композицию, а не наследование, чтобы достичь повторного использования кода.

Композиция позволяет создавать сложные объекты, комбинируя более простые. Вместо создания иерархии классов, объекты получают необходимую функциональность через включение других объектов.

## Проблемы наследования

### 1. Жесткая иерархия

```javascript
// Проблема: жесткая иерархия наследования
class Animal {
  move() { console.log('Животное двигается'); }
}

class Mammal extends Animal {
  breathe() { console.log('Млекопитающее дышит'); }
}

class Dog extends Mammal {
  bark() { console.log('Собака лает'); }
}

class Cat extends Mammal {
  meow() { console.log('Кошка мяукает'); }
}

// Проблема возникает, когда нам нужно создать летающую собаку
// Мы не можем просто наследовать от класса, который умеет летать
// Это приводит к созданию сложных иерархий
```

### 2. Нарушение инкапсуляции

```javascript
// Проблема: наследование нарушает инкапсуляцию
class Vehicle {
  constructor() {
    this.speed = 0;
  }
  
  accelerate() {
    this.speed += 10;
  }
  
  // Внутренние детали реализации доступны в подклассах
  getSpeed() {
    return this.speed;
  }
}

class Car extends Vehicle {
  // Car имеет доступ ко всем внутренним деталям Vehicle
  // Это нарушает инкапсуляцию
  constructor() {
    super();
    this.wheels = 4;
  }
  
  // Может напрямую манипулировать внутренним состоянием родителя
  emergencyBrake() {
    this.speed = 0; // Прямой доступ к внутреннему состоянию
  }
}
```

## Решение через композицию

### 1. Пример с поведением

```javascript
// Решение: использование композиции
class MoveBehavior {
  move() {
    console.log('Движение');
  }
}

class FlyBehavior {
  fly() {
    console.log('Полет');
  }
}

class BarkBehavior {
  bark() {
    console.log('Лай');
  }
}

class Animal {
  constructor(name) {
    this.name = name;
    this.moveBehavior = new MoveBehavior();
    this.barkBehavior = new BarkBehavior();
  }
  
  move() {
    this.moveBehavior.move();
  }
  
  bark() {
    this.barkBehavior.bark();
  }
}

class FlyingDog {
  constructor(name) {
    this.name = name;
    this.moveBehavior = new MoveBehavior();
    this.flyBehavior = new FlyBehavior();
    this.barkBehavior = new BarkBehavior();
  }
  
  move() {
    this.moveBehavior.move();
  }
  
  fly() {
    this.flyBehavior.fly();
  }
  
  bark() {
    this.barkBehavior.bark();
  }
}

const dog = new FlyingDog('Бобик');
dog.fly(); // "Полет"
dog.bark(); // "Лай"
```

### 2. Пример с функциональностью

```javascript
// Пример: композиция в веб-разработке
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class DatabaseConnection {
  connect() {
    console.log('Подключение к базе данных');
  }
  
  query(sql) {
    console.log(`Выполнение запроса: ${sql}`);
  }
}

class Cache {
  get(key) {
    console.log(`Получение из кэша: ${key}`);
  }
  
  set(key, value) {
    console.log(`Сохранение в кэш: ${key}`);
  }
}

class UserService {
  constructor() {
    this.logger = new Logger();
    this.db = new DatabaseConnection();
    this.cache = new Cache();
  }
  
  async getUser(id) {
    try {
      this.logger.log(`Получение пользователя с ID: ${id}`);
      
      // Попробуем получить из кэша
      let user = this.cache.get(`user:${id}`);
      if (!user) {
        // Если нет в кэше, получим из базы
        user = await this.db.query(`SELECT * FROM users WHERE id = ${id}`);
        this.cache.set(`user:${id}`, user);
      }
      
      return user;
    } catch (error) {
      this.logger.log(`Ошибка получения пользователя: ${error.message}`);
      throw error;
    }
  }
}
```

## Практические примеры композиции

### 1. Компоненты в React

```jsx
// Плохой пример: наследование компонентов
class BaseComponent extends React.Component {
  renderHeader() {
    return <div className="header">Шапка</div>;
  }
  
  renderFooter() {
    return <div className="footer">Подвал</div>;
  }
}

class UserComponent extends BaseComponent {
  render() {
    return (
      <div>
        {this.renderHeader()}
        <div>Содержимое пользователя</div>
        {this.renderFooter()}
      </div>
    );
  }
}

// Хороший пример: композиция через props и children
function Layout({ header, footer, children }) {
  return (
    <div>
      {header}
      {children}
      {footer}
    </div>
  );
}

function UserComponent() {
  return (
    <Layout 
      header={<div className="header">Шапка</div>}
      footer={<div className="footer">Подвал</div>}
    >
      <div>Содержимое пользователя</div>
    </Layout>
  );
}

// Или через композицию компонентов
function Header() {
  return <div className="header">Шапка</div>;
}

function Footer() {
  return <div className="footer">Подвал</div>;
}

function UserComponent() {
  return (
    <div>
      <Header />
      <div>Содержимое пользователя</div>
      <Footer />
    </div>
  );
}
```

### 2. Миксины и композиция

```javascript
// Пример: функциональная композиция
const canLog = (target) => {
  target.prototype.log = function(message) {
    console.log(`[${this.constructor.name}] ${message}`);
  };
  return target;
};

const canValidate = (target) => {
  target.prototype.validate = function(data) {
    return Object.keys(this.validationRules || {})
      .every(key => this.validationRules[key](data[key]));
  };
  return target;
};

// Использование композиции
@canLog
@canValidate
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
    this.validationRules = {
      name: (value) => typeof value === 'string' && value.length > 0,
      email: (value) => typeof value === 'string' && value.includes('@')
    };
  }
}

// Или через функциональную композицию
const createValidatableLogger = (BaseClass) => class extends BaseClass {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
  
  validate(data) {
    return true; // Простая валидация
  }
};

const ValidatableLoggerUser = createValidatableLogger(User);
```

### 3. Композиция с использованием стратегии

```javascript
// Пример: паттерн стратегия через композицию
class PaymentStrategy {
  pay(amount) {
    throw new Error('Метод pay() должен быть реализован');
  }
}

class CreditCardStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} с кредитной карты ${this.cardNumber}`);
    // Логика оплаты кредитной картой
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email, password) {
    super();
    this.email = email;
    this.password = password;
  }
  
  pay(amount) {
    console.log(`Оплата ${amount} через PayPal ${this.email}`);
    // Логика оплаты через PayPal
  }
}

class PaymentProcessor {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  processPayment(amount) {
    return this.strategy.pay(amount);
  }
}

// Использование
const creditCard = new CreditCardStrategy('1234-5678-9012-3456', '123');
const processor = new PaymentProcessor(creditCard);
processor.processPayment(100);

// Легко изменить стратегию
const paypal = new PayPalStrategy('user@example.com', 'password');
processor.setStrategy(paypal);
processor.processPayment(100);
```

## Преимущества композиции над наследованием

1. **Гибкость**: Поведение можно изменять во время выполнения
2. **Повторное использование**: Компоненты можно использовать в разных контекстах
3. **Простота тестирования**: Легче создавать mock-объекты
4. **Избегание жесткой иерархии**: Нет проблем с глубокой иерархией наследования
5. **Открытость/закрытость**: Легко добавлять новое поведение без изменения существующего кода

## Практические рекомендации

### 1. Используйте делегирование

```javascript
// Вместо наследования
class AdvancedCalculator extends BasicCalculator {
  scientificOperations() {
    // Научные операции
  }
}

// Используйте делегирование
class Calculator {
  constructor() {
    this.basic = new BasicCalculator();
    this.scientific = new ScientificOperations();
  }
  
  add(a, b) {
    return this.basic.add(a, b);
  }
  
  sin(value) {
    return this.scientific.sin(value);
  }
}
```

### 2. Принципы при проектировании

```javascript
// Пример: композиция с инъекцией зависимостей
class EmailService {
  send(to, subject, body) {
    console.log(`Отправка письма на ${to}`);
  }
}

class SMSService {
  send(phone, message) {
    console.log(`Отправка SMS на ${phone}`);
  }
}

class NotificationService {
  constructor(emailService, smsService) {
    this.emailService = emailService;
    this.smsService = smsService;
  }
  
  notifyUser(user, message) {
    if (user.preferredContact === 'email') {
      this.emailService.send(user.email, 'Уведомление', message);
    } else {
      this.smsService.send(user.phone, message);
    }
  }
}

// Теперь легко тестировать и заменять сервисы
const notificationService = new NotificationService(
  new EmailService(),
  new SMSService()
);
```

## Заключение

Композиция вместо наследования — мощный принцип, который помогает создавать более гибкий и поддерживаемый код. Вместо создания жестких иерархий классов, композиция позволяет комбинировать поведение через делегирование и агрегирование. Это делает код более модульным, тестируемым и легким для расширения.

> [[SOLID]] | [[DRY]] | [[KISS]] | [[YAGNI]]