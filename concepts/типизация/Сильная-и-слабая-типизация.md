---
aliases: ["Сильная типизация", "Слабая типизация", "Strong vs Weak Typing"]
tags: [programming, типизация, frontend, javascript, typescript, coercion]
---

# Сильная и слабая типизация

## Определение

**Сильная типизация** (или строгая типизация) — это система типов, в которой значения разных типов не могут быть неявно преобразованы друг в друга без явного указания разработчика. Язык требует явного преобразования типов.

**Слабая типизация** (или нестрогая типизация) — это система типов, в которой значения разных типов могут быть автоматически преобразованы друг в друга в определенных контекстах, даже если это может привести к неожиданным результатам.

> [!warning] Важно
> Термины "сильная" и "слабая" типизация часто путают со статической и динамической типизацией. Это разные концепции. Язык может быть статически типизированным и при этом иметь слабую типизацию, или динамически типизированным с сильной типизацией.

## Примеры языков

### Языки со "считающейся" сильной типизацией:
- Python
- Ruby
- Haskell
- TypeScript (в строгом режиме)
- Rust

### Языки со "считающейся" слабой типизацией:
- JavaScript
- PHP
- C/C++
- Perl

## Примеры в JavaScript (слабая типизация)

JavaScript — классический пример языка со слабой типизацией, где происходят неявные преобразования типов:

### Пример 1: Сложение строк и чисел
```javascript
console.log(5 + "10");     // "510" (число 5 преобразуется в строку и происходит конкатенация)
console.log("5" - 3);      // 2 (строка "5" преобразуется в число)
console.log("5" * "2");    // 10 (обе строки преобразуются в числа)
```

### Пример 2: Логические преобразования
```javascript
console.log(true + false); // 1 (true = 1, false = 0)
console.log("5" == 5);     // true (неявное преобразование)
console.log("5" === 5);    // false (строгое сравнение без преобразования)
```

### Пример 3: Пустые значения
```javascript
console.log([] + []);      // "" (пустая строка)
console.log({} + {});      // "[object Object][object Object]"
console.log([1, 2] + [3, 4]); // "1,23,4"
```

## Примеры в Python (сильная типизация)

Python, напротив, имеет более сильную типизацию:

```python
print(5 + "10")  # TypeError: unsupported operand type(s) for +: 'int' and 'str'
print(5 + int("10"))  # 15 (нужно явное преобразование)
print(str(5) + "10")  # "510" (нужно явное преобразование)
```

## Неявные преобразования в JavaScript

JavaScript автоматически преобразует типы в следующих случаях:

### 1. Операторы +, -, *, /, %:
```javascript
"5" - 2;    // 3 (строка преобразуется в число)
"5" * 2;    // 10
"5" / 2;    // 2.5
```

### 2. Операторы сравнения:
```javascript
"5" == 5;   // true
"0" == false; // true
null == undefined; // true
```

### 3. Логические контексты:
```javascript
if ("0") { console.log("true"); } // Выведет "true", потому что "0" - это строка, а не пустое значение
if (0) { console.log("true"); }   // Не выполнится
```

## Проблемы со слабой типизацией

Слабая типизация может привести к неожиданным результатам:

```javascript
console.log([] == ![]);     // true (массив преобразуется к логическому значению)
console.log(0 == []);       // true (пустой массив преобразуется к 0)
console.log(0 == false);    // true
console.log([] == false);   // true
console.log(0 === false);   // false (строгое сравнение)
```

## Преимущества сильной типизации

> [!tip] Преимущества сильной типизации
> - **Предсказуемость**: Поведение кода более предсказуемо
> - **Безопасность**: Меньше вероятность ошибок из-за неожиданных преобразований
> - **Ясность**: Код более понятен и документирован
> - **Отладка**: Проще находить и исправлять ошибки

## Рекомендации для фронтенд-разработчиков

### 1. Используйте строгое сравнение (=== и !==):
```javascript
// Плохо
if (userInput == 0) { /* ... */ }

// Хорошо
if (userInput === 0) { /* ... */ }
```

### 2. Явно преобразуйте типы:
```javascript
// Плохо
const total = price + tax;

// Лучше
const total = Number(price) + Number(tax);

// Или с проверкой
const total = parseFloat(price) + parseFloat(tax);
```

### 3. Используйте TypeScript:
```typescript
function calculateTotal(price: number, tax: number): number {
  return price + tax; // Типы строго определены
}
```

### 4. Избегайте неявных преобразований:
```javascript
// Плохо
if (value) { /* ... */ }

// Лучше
if (value !== null && value !== undefined && value !== "") { /* ... */ }
```

## Практический пример

Представим функцию валидации формы:

### Без учета типизации:
```javascript
function validateAge(input) {
  if (input > 0 && input < 150) {  // Что, если input - строка?
    return true;
  }
  return false;
}

console.log(validateAge("25"));    // true (работает, но неочевидно)
console.log(validateAge("025"));   // true (ведет себя неожиданно)
console.log(validateAge("25x"));   // false (NaN преобразуется к false)
```

### С явной типизацией:
```javascript
function validateAge(input) {
  const age = Number(input);
  if (isNaN(age) || age <= 0 || age >= 150) {
    return false;
  }
  return true;
}

console.log(validateAge("25"));    // true
console.log(validateAge("025"));   // true
console.log(validateAge("25x"));   // false
```

## Заключение

Хотя слабая типизация может показаться удобной, она часто приводит к трудноуловимим ошибкам. Для фронтенд-разработчиков важно понимать, как происходят неявные преобразования в JavaScript, и использовать строгие методы проверки типов, а также применять TypeScript для более надежной типизации.

## См. также
- [[Статическая и динамическая типизация]]
- [[Выведение типов]]
- [[Аннотации типов]]
- [[TypeScript для фронтенд-разработчиков]]
- [[Проверка типов в JavaScript]]