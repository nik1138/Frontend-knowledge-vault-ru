---
aliases: ["Оповещения", "Alerting System", "Система оповещений"]
tags: [frontend, monitoring, alerts, notifications, observability]
---

# Алертинг

Алертинг - это система уведомлений, предназначенная для информирования разработчиков, операторов и других заинтересованных сторон о критических событиях, ошибках, ухудшении производительности или других важных изменениях в работе фронтенд-приложения. Эффективная система алертинга позволяет быстро реагировать на проблемы и предотвращать ухудшение пользовательского опыта.

## Зачем нужен алертинг

- **Быстрое реагирование**: Оповещение о проблемах в реальном времени
- **Профилактика**: Предотвращение каскадных сбоев
- **Мониторинг SLA**: Контроль соблюдения соглашений об уровне обслуживания
- **Управление инцидентами**: Организация процесса реагирования на проблемы
- **Контроль качества**: Мониторинг ключевых метрик приложения

## Типы алертов

### 1. Алерты об ошибках
- Превышение порога ошибок за единицу времени
- Конкретные типы критических ошибок
- Ошибки аутентификации/авторизации

### 2. Алерты производительности
- Превышение времени загрузки страницы
- Ухудшение Core Web Vitals
- Высокое потребление ресурсов

### 3. Алерты доступности
- Недоступность ключевых функций
- Падение API-сервисов
- Проблемы с CDN или статическими ресурсами

### 4. Алерты пользовательского поведения
- Резкое падение конверсии
- Изменение паттернов использования
- Подозрительная активность

## Принципы эффективного алертинга

### 1. Правило "Достаточно одного алерта"
Каждый алерт должен указывать на одну проблему, а не на симптомы проблемы.

### 2. Правило "Действие обязательно"
Каждый алерт должен требовать какого-либо действия, иначе он бесполезен.

### 3. Правило "Правильный уровень шума"
Не перегружайте команду алертами - это приведет к "усталости от алертов".

### 4. Правило "Контекст и ясность"
Каждый алерт должен содержать достаточно информации для понимания и устранения проблемы.

## Реализация системы алертинга

### Базовая система алертинга

```javascript
class AlertSystem {
  constructor(options = {}) {
    this.alerts = new Map();
    this.subscribers = new Set();
    this.throttling = new Map(); // Для предотвращения спама
    this.throttleInterval = options.throttleInterval || 300000; // 5 минут по умолчанию
    this.rules = options.rules || [];
    
    this.setupDefaultRules();
  }
  
  // Подписка на алерты
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }
  
  // Проверка и срабатывание алертов
  checkAlerts(metricName, value, context = {}) {
    for (const rule of this.rules) {
      if (rule.metric === metricName && rule.condition(value)) {
        this.triggerAlert({
          id: rule.id,
          name: rule.name,
          severity: rule.severity,
          metric: metricName,
          value,
          context,
          timestamp: new Date().toISOString()
        });
      }
    }
  }
  
  // Срабатывание алерта
  triggerAlert(alert) {
    // Проверяем, не был ли алерт недавно отправлен (для предотвращения спама)
    const lastTriggered = this.throttling.get(alert.id);
    const now = Date.now();
    
    if (lastTriggered && (now - lastTriggered) < this.throttleInterval) {
      return; // Алерт был недавно отправлен
    }
    
    // Обновляем время последнего срабатывания
    this.throttling.set(alert.id, now);
    
    // Сохраняем алерт
    this.alerts.set(alert.id, alert);
    
    // Уведомляем подписчиков
    for (const subscriber of this.subscribers) {
      subscriber(alert);
    }
  }
  
  // Установка правил алертинга
  addRule(rule) {
    this.rules.push(rule);
  }
  
  setupDefaultRules() {
    // Примеры правил
    this.addRule({
      id: 'high_error_rate',
      name: 'Высокий процент ошибок',
      metric: 'error_rate',
      condition: (value) => value > 0.05, // Более 5% ошибок
      severity: 'HIGH'
    });
    
    this.addRule({
      id: 'slow_lcp',
      name: 'Медленный LCP',
      metric: 'lcp',
      condition: (value) => value > 4000, // Более 4 секунд
      severity: 'MEDIUM'
    });
    
    this.addRule({
      id: 'high_cls',
      name: 'Высокий CLS',
      metric: 'cls',
      condition: (value) => value > 0.25, // Более 0.25
      severity: 'MEDIUM'
    });
  }
}

// Использование
const alertSystem = new AlertSystem();

// Подписка на алерты
const unsubscribe = alertSystem.subscribe((alert) => {
  console.warn('Алерт сработал:', alert);
  
  // Здесь можно отправить алерт в Slack, email или другую систему
  sendAlertToSlack(alert);
});

// Проверка метрик
alertSystem.checkAlerts('error_rate', 0.08); // Вызовет алерт
alertSystem.checkAlerts('lcp', 5000); // Вызовет алерт
```

### Расширенная система алертинга

```javascript
class AdvancedAlertSystem extends AlertSystem {
  constructor(options = {}) {
    super(options);
    
    this.alertHistory = new Map();
    this.alertLimits = options.alertLimits || {
      HIGH: 10,    // Максимум 10 HIGH алертов в час
      MEDIUM: 20,  // Максимум 20 MEDIUM алертов в час
      LOW: 50      // Максимум 50 LOW алертов в час
    };
    
    this.activeAlerts = new Map(); // Активные алерты (еще не подавлены)
    this.suppressionRules = options.suppressionRules || [];
    
    // Установка правил подавления
    this.setupSuppressionRules();
  }
  
  // Подавление алертов
  isSuppressed(alert) {
    for (const rule of this.suppressionRules) {
      if (rule.condition(alert)) {
        return true;
      }
    }
    return false;
  }
  
  // Срабатывание алерта с проверкой подавления
  triggerAlert(alert) {
    // Проверяем, не подавлен ли алерт
    if (this.isSuppressed(alert)) {
      return;
    }
    
    // Проверяем лимиты по типу алерта
    if (!this.checkAlertLimit(alert.severity)) {
      console.warn(`Лимит алертов ${alert.severity} превышен`);
      return;
    }
    
    // Проверяем, не был ли алерт недавно отправлен
    const lastTriggered = this.throttling.get(alert.id);
    const now = Date.now();
    
    if (lastTriggered && (now - lastTriggered) < this.throttleInterval) {
      return;
    }
    
    // Обновляем время последнего срабатывания
    this.throttling.set(alert.id, now);
    
    // Увеличиваем счетчик алертов за последний час
    this.incrementAlertCount(alert.severity);
    
    // Помечаем алерт как активный
    this.activeAlerts.set(alert.id, alert);
    
    // Сохраняем историю алертов
    if (!this.alertHistory.has(alert.id)) {
      this.alertHistory.set(alert.id, []);
    }
    this.alertHistory.get(alert.id).push(alert);
    
    // Уведомляем подписчиков
    for (const subscriber of this.subscribers) {
      subscriber(alert);
    }
  }
  
  // Проверка лимита алертов
  checkAlertLimit(severity) {
    const count = this.getAlertCountInLastHour(severity);
    return count < this.alertLimits[severity];
  }
  
  // Увеличение счетчика алертов
  incrementAlertCount(severity) {
    const now = Date.now();
    if (!this.alertCounts) this.alertCounts = {};
    
    if (!this.alertCounts[severity]) {
      this.alertCounts[severity] = [];
    }
    
    this.alertCounts[severity].push(now);
    
    // Удаляем старые записи (старше 1 часа)
    this.alertCounts[severity] = this.alertCounts[severity]
      .filter(timestamp => now - timestamp < 3600000);
  }
  
  // Получение количества алертов за последний час
  getAlertCountInLastHour(severity) {
    if (!this.alertCounts || !this.alertCounts[severity]) {
      return 0;
    }
    
    const now = Date.now();
    return this.alertCounts[severity]
      .filter(timestamp => now - timestamp < 3600000)
      .length;
  }
  
  setupSuppressionRules() {
    // Правило: подавлять алерты в нерабочее время (например, с 22:00 до 8:00)
    this.suppressionRules.push({
      condition: (alert) => {
        const hour = new Date(alert.timestamp).getHours();
        return hour >= 22 || hour < 8; // Нерабочее время
      },
      description: 'Подавление алертов в нерабочее время'
    });
    
    // Правило: подавлять алерты во время планового обслуживания
    this.suppressionRules.push({
      condition: (alert) => {
        return this.isMaintenanceWindow(alert.timestamp);
      },
      description: 'Подавление алертов во время обслуживания'
    });
  }
  
  isMaintenanceWindow(timestamp) {
    // Проверка, находится ли время в окне обслуживания
    // Реализация зависит от конкретных требований
    return false;
  }
  
  // Метод для ручного подавления алерта
  suppressAlert(alertId, duration = 3600000) { // 1 час по умолчанию
    const suppressionEnd = Date.now() + duration;
    this.throttling.set(alertId, suppressionEnd);
  }
  
  // Метод для снятия подавления
  unsuppressAlert(alertId) {
    this.throttling.delete(alertId);
  }
}

// Использование расширенной системы
const advancedAlertSystem = new AdvancedAlertSystem({
  alertLimits: {
    HIGH: 5,
    MEDIUM: 15,
    LOW: 30
  }
});
```

## Интеграция с внешними системами оповещений

### Slack-интеграция
```javascript
class SlackAlertNotifier {
  constructor(webhookUrl, options = {}) {
    this.webhookUrl = webhookUrl;
    this.channel = options.channel || '#alerts';
    this.username = options.username || 'Frontend Monitor';
    this.emoji = options.emoji || ':warning:';
  }
  
  async sendAlert(alert) {
    const color = this.getAlertColor(alert.severity);
    const message = this.formatAlertMessage(alert);
    
    const payload = {
      channel: this.channel,
      username: this.username,
      icon_emoji: this.emoji,
      attachments: [
        {
          color: color,
          title: alert.name,
          text: message,
          fields: [
            {
              title: "Метрика",
              value: alert.metric,
              short: true
            },
            {
              title: "Значение",
              value: alert.value,
              short: true
            },
            {
              title: "Важность",
              value: alert.severity,
              short: true
            },
            {
              title: "Время",
              value: new Date(alert.timestamp).toLocaleString(),
              short: true
            }
          ],
          footer: "Frontend Monitoring System",
          ts: Math.floor(Date.now() / 1000)
        }
      ]
    };
    
    try {
      await fetch(this.webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
    } catch (error) {
      console.error('Ошибка отправки алерта в Slack:', error);
    }
  }
  
  getAlertColor(severity) {
    switch (severity) {
      case 'HIGH': return 'danger';
      case 'MEDIUM': return 'warning';
      case 'LOW': return 'good';
      default: return '#AB2B1D';
    }
  }
  
  formatAlertMessage(alert) {
    let message = `Метрика "${alert.metric}" превысила пороговое значение: ${alert.value}`;
    
    if (alert.context && Object.keys(alert.context).length > 0) {
      message += '\n\nКонтекст: ' + JSON.stringify(alert.context, null, 2);
    }
    
    return message;
  }
}

// Использование
const slackNotifier = new SlackAlertNotifier('YOUR_SLACK_WEBHOOK_URL');

advancedAlertSystem.subscribe((alert) => {
  slackNotifier.sendAlert(alert);
});
```

### Email-уведомления
```javascript
class EmailAlertNotifier {
  constructor(apiKey, options = {}) {
    this.apiKey = apiKey;
    this.from = options.from || 'alerts@yoursite.com';
    this.to = options.to || ['admin@yoursite.com'];
    this.apiEndpoint = options.apiEndpoint || 'https://api.your-email-service.com/send';
  }
  
  async sendAlert(alert) {
    const htmlContent = this.createHtmlAlert(alert);
    const subject = `Алерт: ${alert.name} - ${alert.severity} приоритет`;
    
    const payload = {
      from: this.from,
      to: Array.isArray(this.to) ? this.to : [this.to],
      subject,
      html: htmlContent
    };
    
    try {
      await fetch(this.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify(payload)
      });
    } catch (error) {
      console.error('Ошибка отправки email алерта:', error);
    }
  }
  
  createHtmlAlert(alert) {
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px;">
        <h2 style="color: #d32f2f;">${alert.name}</h2>
        <div style="background-color: #f5f5f5; padding: 15px; border-radius: 5px;">
          <p><strong>Метрика:</strong> ${alert.metric}</p>
          <p><strong>Значение:</strong> ${alert.value}</p>
          <p><strong>Важность:</strong> ${alert.severity}</p>
          <p><strong>Время:</strong> ${new Date(alert.timestamp).toLocaleString()}</p>
        </div>
        ${alert.context ? `
          <div style="margin-top: 15px;">
            <h3>Контекст:</h3>
            <pre style="background-color: #f9f9f9; padding: 10px; overflow-x: auto;">${JSON.stringify(alert.context, null, 2)}</pre>
          </div>
        ` : ''}
      </div>
    `;
  }
}
```

### Push-уведомления
```javascript
class PushAlertNotifier {
  constructor(options = {}) {
    this.vapidPublicKey = options.vapidPublicKey;
    this.subscribers = new Set();
  }
  
  async subscribeUser(subscription) {
    this.subscribers.add(subscription);
  }
  
  async sendAlert(alert) {
    const payload = JSON.stringify({
      title: `Алерт: ${alert.name}`,
      body: `Метрика ${alert.metric} = ${alert.value}`,
      icon: '/alert-icon.png',
      badge: '/badge-icon.png',
      data: {
        alert: alert,
        url: '/alerts'
      }
    });
    
    const promises = [];
    
    for (const subscription of this.subscribers) {
      promises.push(this.sendPushNotification(subscription, payload));
    }
    
    await Promise.allSettled(promises);
  }
  
  async sendPushNotification(subscription, payload) {
    try {
      await fetch('/api/send-push', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          subscription,
          payload
        })
      });
    } catch (error) {
      console.error('Ошибка отправки push-уведомления:', error);
      // Удаляем подписку, если она больше не валидна
      if (error.code === 410) {
        this.subscribers.delete(subscription);
      }
    }
  }
}
```

## Алертинг на основе машинного обучения

```javascript
class MLBasedAlertSystem extends AdvancedAlertSystem {
  constructor(options = {}) {
    super(options);
    
    this.anomalyDetectors = new Map();
    this.baselineCalculators = new Map();
    this.anomalyThreshold = options.anomalyThreshold || 2; // 2 стандартных отклонения
  }
  
  // Обучение модели на основе исторических данных
  trainBaseline(metricName, historicalData) {
    // Вычисляем среднее и стандартное отклонение
    const mean = historicalData.reduce((sum, val) => sum + val, 0) / historicalData.length;
    const variance = historicalData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / historicalData.length;
    const stdDev = Math.sqrt(variance);
    
    this.baselineCalculators.set(metricName, {
      mean,
      stdDev,
      lastUpdate: Date.now()
    });
  }
  
  // Проверка на аномалии
  checkAnomaly(metricName, value) {
    const baseline = this.baselineCalculators.get(metricName);
    
    if (!baseline) {
      return false; // Нет базовой модели
    }
    
    const zScore = Math.abs(value - baseline.mean) / baseline.stdDev;
    return zScore > this.anomalyThreshold;
  }
  
  // Переопределяем метод проверки алертов
  checkAlerts(metricName, value, context = {}) {
    // Проверяем обычные правила
    super.checkAlerts(metricName, value, context);
    
    // Проверяем аномалии
    if (this.checkAnomaly(metricName, value)) {
      this.triggerAlert({
        id: `anomaly_${metricName}`,
        name: `Аномалия в метрике ${metricName}`,
        severity: 'MEDIUM',
        metric: metricName,
        value,
        context,
        timestamp: new Date().toISOString(),
        type: 'anomaly'
      });
    }
  }
  
  // Обновление модели на лету
  updateBaseline(metricName, newValue) {
    let baseline = this.baselineCalculators.get(metricName);
    
    if (!baseline) {
      // Инициализируем базовую модель
      this.baselineCalculators.set(metricName, {
        mean: newValue,
        stdDev: 0,
        count: 1,
        sum: newValue,
        sumSquares: newValue * newValue
      });
      return;
    }
    
    // Обновляем статистику
    baseline.count++;
    baseline.sum += newValue;
    baseline.sumSquares += newValue * newValue;
    
    // Пересчитываем среднее
    baseline.mean = baseline.sum / baseline.count;
    
    // Пересчитываем стандартное отклонение
    const variance = (baseline.sumSquares - (baseline.sum * baseline.sum) / baseline.count) / baseline.count;
    baseline.stdDev = Math.sqrt(variance);
  }
}

// Использование системы с ML
const mlAlertSystem = new MLBasedAlertSystem();

// Обучение на исторических данных
mlAlertSystem.trainBaseline('page_load_time', [1200, 1300, 1100, 1400, 1250, 1350]);

// Проверка новых значений
mlAlertSystem.checkAlerts('page_load_time', 3000); // Может вызвать алерт об аномалии
```

## Алертинг для различных метрик

### Алертинг ошибок
```javascript
class ErrorAlertSystem {
  constructor(alertSystem) {
    this.alertSystem = alertSystem;
    this.errorCounts = new Map();
    this.timeWindow = 300000; // 5 минут
    
    this.setupErrorRules();
  }
  
  setupErrorRules() {
    // Правило: высокий процент ошибок
    this.alertSystem.addRule({
      id: 'high_error_rate',
      name: 'Высокий процент ошибок JavaScript',
      metric: 'js_error_rate',
      condition: (value) => value > 0.05,
      severity: 'HIGH'
    });
    
    // Правило: большое количество ошибок за короткий период
    this.alertSystem.addRule({
      id: 'error_spike',
      name: 'Всплеск ошибок',
      metric: 'error_count',
      condition: (value) => value > 100, // Более 100 ошибок за 5 минут
      severity: 'HIGH'
    });
  }
  
  recordError(error) {
    const now = Date.now();
    
    // Группируем ошибки по типу
    const errorType = this.getErrorType(error);
    
    if (!this.errorCounts.has(errorType)) {
      this.errorCounts.set(errorType, []);
    }
    
    this.errorCounts.get(errorType).push(now);
    
    // Удаляем старые ошибки за пределами окна
    this.cleanupOldErrors(errorType);
    
    // Проверяем количество ошибок
    const count = this.getErrorCount(errorType);
    this.alertSystem.checkAlerts('error_count', count, {
      errorType,
      count
    });
  }
  
  getErrorType(error) {
    // Определяем тип ошибки по сообщению или стеку
    if (error.message.includes('Network')) return 'network_error';
    if (error.message.includes('TypeError')) return 'type_error';
    if (error.message.includes('ReferenceError')) return 'reference_error';
    return 'other_error';
  }
  
  getErrorCount(errorType) {
    this.cleanupOldErrors(errorType);
    return this.errorCounts.get(errorType)?.length || 0;
  }
  
  cleanupOldErrors(errorType) {
    const errors = this.errorCounts.get(errorType);
    if (!errors) return;
    
    const now = Date.now();
    const filtered = errors.filter(timestamp => now - timestamp <= this.timeWindow);
    this.errorCounts.set(errorType, filtered);
  }
  
  calculateErrorRate(totalRequests, errorCount) {
    return totalRequests > 0 ? errorCount / totalRequests : 0;
  }
}

// Использование
const errorAlertSystem = new ErrorAlertSystem(advancedAlertSystem);

// Глобальный обработчик ошибок с алертингом
window.addEventListener('error', (event) => {
  errorAlertSystem.recordError(event.error);
});

window.addEventListener('unhandledrejection', (event) => {
  errorAlertSystem.recordError(event.reason);
});
```

### Алертинг производительности
```javascript
class PerformanceAlertSystem {
  constructor(alertSystem) {
    this.alertSystem = alertSystem;
    
    this.setupPerformanceRules();
  }
  
  setupPerformanceRules() {
    // Core Web Vitals алерты
    this.alertSystem.addRule({
      id: 'poor_lcp',
      name: 'Плохой Largest Contentful Paint',
      metric: 'lcp',
      condition: (value) => value > 4000, // хуже 4 секунд
      severity: 'MEDIUM'
    });
    
    this.alertSystem.addRule({
      id: 'poor_fid',
      name: 'Плохой First Input Delay',
      metric: 'fid',
      condition: (value) => value > 300, // хуже 300мс
      severity: 'MEDIUM'
    });
    
    this.alertSystem.addRule({
      id: 'poor_cls',
      name: 'Плохой Cumulative Layout Shift',
      metric: 'cls',
      condition: (value) => value > 0.25, // хуже 0.25
      severity: 'MEDIUM'
    });
    
    // Алерты для других метрик
    this.alertSystem.addRule({
      id: 'slow_fcp',
      name: 'Медленный First Contentful Paint',
      metric: 'fcp',
      condition: (value) => value > 3000,
      severity: 'LOW'
    });
    
    this.alertSystem.addRule({
      id: 'high_resource_load_time',
      name: 'Медленная загрузка ресурса',
      metric: 'resource_load_time',
      condition: (value) => value > 10000, // более 10 секунд
      severity: 'MEDIUM'
    });
  }
  
  // Метод для проверки метрик производительности
  checkPerformanceMetrics(metrics) {
    if (metrics.lcp !== undefined) {
      this.alertSystem.checkAlerts('lcp', metrics.lcp, {
        url: metrics.url,
        device: metrics.device
      });
    }
    
    if (metrics.fid !== undefined) {
      this.alertSystem.checkAlerts('fid', metrics.fid, {
        url: metrics.url,
        device: metrics.device
      });
    }
    
    if (metrics.cls !== undefined) {
      this.alertSystem.checkAlerts('cls', metrics.cls, {
        url: metrics.url,
        device: metrics.device
      });
    }
    
    if (metrics.fcp !== undefined) {
      this.alertSystem.checkAlerts('fcp', metrics.fcp, {
        url: metrics.url,
        device: metrics.device
      });
    }
  }
}

// Использование с Web Vitals
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

const perfAlertSystem = new PerformanceAlertSystem(advancedAlertSystem);

function sendMetrics(metric) {
  perfAlertSystem.checkPerformanceMetrics({
    [metric.name.toLowerCase()]: metric.value,
    url: window.location.href,
    device: navigator.userAgent
  });
}

getCLS(sendMetrics);
getFID(sendMetrics);
getFCP(sendMetrics);
getLCP(sendMetrics);
getTTFB(sendMetrics);
```

## Управление алертами через интерфейс

```javascript
class AlertDashboard {
  constructor(alertSystem) {
    this.alertSystem = alertSystem;
    this.activeAlerts = [];
    this.alertHistory = [];
  }
  
  // Получение активных алертов
  getActiveAlerts() {
    return Array.from(this.alertSystem.activeAlerts.values());
  }
  
  // Получение истории алертов
  getAlertHistory(limit = 100) {
    const allHistory = [];
    
    for (const alerts of this.alertSystem.alertHistory.values()) {
      allHistory.push(...alerts);
    }
    
    // Сортируем по времени и возвращаем последние
    return allHistory
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
      .slice(0, limit);
  }
  
  // Подавление алерта
  suppressAlert(alertId, duration) {
    this.alertSystem.suppressAlert(alertId, duration);
  }
  
  // Сброс подавления
  unsuppressAlert(alertId) {
    this.alertSystem.unsuppressAlert(alertId);
  }
  
  // Изменение пороговых значений
  updateRuleThreshold(ruleId, newThreshold) {
    const rule = this.alertSystem.rules.find(r => r.id === ruleId);
    if (rule) {
      rule.condition = (value) => value > newThreshold;
    }
  }
  
  // Создание пользовательского правила
  createCustomRule(ruleConfig) {
    this.alertSystem.addRule({
      id: ruleConfig.id || `custom_${Date.now()}`,
      name: ruleConfig.name,
      metric: ruleConfig.metric,
      condition: ruleConfig.condition,
      severity: ruleConfig.severity || 'MEDIUM'
    });
  }
  
  // Рендеринг дашборда
  renderDashboard(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = `
      <div class="alert-dashboard">
        <h2>Дашборд алертов</h2>
        
        <div class="alert-stats">
          <div class="stat-card">
            <h3>${this.getActiveAlerts().length}</h3>
            <p>Активные алерты</p>
          </div>
          <div class="stat-card">
            <h3>${this.getAlertHistory().length}</h3>
            <p>Всего алертов</p>
          </div>
        </div>
        
        <div class="active-alerts">
          <h3>Активные алерты</h3>
          <div id="active-alerts-list">
            ${this.renderAlertsList(this.getActiveAlerts())}
          </div>
        </div>
        
        <div class="alert-history">
          <h3>История алертов</h3>
          <div id="alert-history-list">
            ${this.renderAlertsList(this.getAlertHistory(10))}
          </div>
        </div>
      </div>
    `;
  }
  
  renderAlertsList(alerts) {
    return alerts.map(alert => `
      <div class="alert-item ${alert.severity.toLowerCase()}">
        <div class="alert-header">
          <span class="alert-name">${alert.name}</span>
          <span class="alert-time">${new Date(alert.timestamp).toLocaleString()}</span>
        </div>
        <div class="alert-details">
          <div>Метрика: ${alert.metric}</div>
          <div>Значение: ${alert.value}</div>
          <div>Важность: ${alert.severity}</div>
        </div>
        <div class="alert-actions">
          <button onclick="suppressAlert('${alert.id}')">Подавить</button>
        </div>
      </div>
    `).join('');
  }
}

// Использование дашборда
const dashboard = new AlertDashboard(advancedAlertSystem);
dashboard.renderDashboard('alert-dashboard-container');
```

## Лучшие практики алертинга

### 1. Сегментация алертов
```javascript
// Алерты по уровням важности
const alertPriorities = {
  CRITICAL: { 
    channels: ['slack_critical', 'sms', 'phone'], 
    responseTime: 5 * 60 * 1000 // 5 минут
  },
  HIGH: { 
    channels: ['slack', 'email'], 
    responseTime: 15 * 60 * 1000 // 15 минут
  },
  MEDIUM: { 
    channels: ['email', 'dashboard'], 
    responseTime: 60 * 60 * 1000 // 1 час
  },
  LOW: { 
    channels: ['dashboard', 'daily_report'], 
    responseTime: 24 * 60 * 60 * 1000 // 24 часа
  }
};
```

### 2. Учет времени и пользователей
```javascript
// Умный алертинг с учетом времени и пользователей
function shouldSendAlert(alert, userContext) {
  // Не отправлять алерты ночью для низкоприоритетных событий
  const hour = new Date(alert.timestamp).getHours();
  if (hour >= 22 || hour < 8) {
    if (alert.severity === 'LOW' || alert.severity === 'MEDIUM') {
      return false;
    }
  }
  
  // Не отправлять алерты для тестовых пользователей
  if (userContext && userContext.isTestUser) {
    return alert.severity === 'CRITICAL';
  }
  
  return true;
}
```

### 3. Автоматическое подавление
```javascript
// Система автоматического подавления алертов
class AutoSuppressionSystem {
  constructor() {
    this.suppressionPatterns = new Map();
  }
  
  addSuppressionPattern(pattern, duration) {
    this.suppressionPatterns.set(pattern, {
      pattern,
      duration,
      lastTriggered: null
    });
  }
  
  shouldSuppress(alert) {
    for (const [key, suppression] of this.suppressionPatterns) {
      if (this.matchesPattern(alert, suppression.pattern)) {
        const now = Date.now();
        if (!suppression.lastTriggered || 
            now - suppression.lastTriggered > suppression.duration) {
          suppression.lastTriggered = now;
          return true;
        }
      }
    }
    return false;
  }
  
  matchesPattern(alert, pattern) {
    // Реализация сопоставления с шаблоном
    return alert.name.includes(pattern.keyword) && 
           alert.severity === pattern.severity;
  }
}
```

## Заключение

Эффективная система алертинга - это критический компонент надежного фронтенд-приложения. Она позволяет:

- Быстро реагировать на проблемы
- Предотвращать ухудшение пользовательского опыта
- Поддерживать высокий уровень доступности и производительности
- Оптимизировать процессы мониторинга и управления инцидентами

При создании системы алертинга важно:

- [[Мониторинг-ошибок|Интегрировать с системами мониторинга ошибок]]
- [[Мониторинг-производительности|Связать с метриками производительности]]
- [[Аналитика-использования|Учитывать поведение пользователей]]
- [[Логирование|Основывать на структурированных логах]]

## См. также
- [[Мониторинг-ошибок]]
- [[Мониторинг-производительности]]
- [[Аналитика-использования]]
- [[Логирование]]