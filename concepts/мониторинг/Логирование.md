---
aliases: ["Logging", "Системы логирования", "Журналы событий"]
tags: [frontend, logging, monitoring, debugging, events]
---

# Логирование

Логирование - это процесс записи событий, происходящих в приложении, с целью последующего анализа, отладки и мониторинга. В контексте фронтенд-разработки логирование играет важную роль в понимании поведения приложения в продакшене, выявлении проблем и улучшении пользовательского опыта.

## Зачем нужно логирование

- **Отладка проблем**: Понимание контекста возникновения ошибок
- **Мониторинг состояния приложения**: Отслеживание работы ключевых функций
- **Анализ пользовательского поведения**: Понимание того, как пользователи используют приложение
- **Аудит безопасности**: Отслеживание подозрительной активности
- **Производительность**: Замер времени выполнения операций

## Уровни логирования

### 1. TRACE (отладка)
Самый подробный уровень, содержит детальную информацию о выполнении операций.

### 2. DEBUG (отладка)
Используется для отладочной информации, полезной при разработке и тестировании.

### 3. INFO (информация)
Общая информация о работе приложения, подтверждение нормального хода выполнения.

### 4. WARN (предупреждение)
Потенциально проблемные ситуации, которые не прерывают работу приложения.

### 5. ERROR (ошибка)
Ошибки, которые не позволяют выполнить конкретную операцию, но не критичны для всего приложения.

### 6. FATAL (фатальная ошибка)
Критические ошибки, которые приводят к завершению работы приложения.

## Встроенные механизмы логирования

### Консольные методы
```javascript
// Различные уровни логирования
console.log('Обычное информационное сообщение');
console.info('Информационное сообщение');
console.warn('Предупреждение');
console.error('Сообщение об ошибке');
console.debug('Отладочная информация');

// Группировка логов
console.group('Загрузка данных');
console.log('Начало загрузки');
console.log('Получение данных с сервера');
console.log('Обработка данных');
console.groupEnd();

// Таблицы
console.table([
  { name: 'Иван', age: 30 },
  { name: 'Мария', age: 25 }
]);

// Трассировка стека
function a() { b(); }
function b() { c(); }
function c() { console.trace('Трассировка вызовов'); }
a();
```

## Создание собственной системы логирования

```javascript
class Logger {
  constructor(options = {}) {
    this.level = options.level || 'INFO';
    this.enabled = options.enabled !== false; // По умолчанию включено
    this.prefix = options.prefix || '';
    this.transport = options.transport || this.defaultTransport;
    this.formatter = options.formatter || this.defaultFormatter;
    this.context = options.context || {};
    
    // Уровни логирования с числовыми значениями для сравнения
    this.levels = {
      'TRACE': 0,
      'DEBUG': 1,
      'INFO': 2,
      'WARN': 3,
      'ERROR': 4,
      'FATAL': 5
    };
  }
  
  // Проверка, нужно ли логировать на данном уровне
  shouldLog(level) {
    return this.enabled && this.levels[level] >= this.levels[this.level];
  }
  
  // Базовый метод логирования
  log(level, message, meta = {}) {
    if (!this.shouldLog(level)) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta: {
        ...this.context,
        ...meta
      },
      prefix: this.prefix
    };
    
    this.transport(logEntry);
  }
  
  // Методы для разных уровней
  trace(message, meta) { this.log('TRACE', message, meta); }
  debug(message, meta) { this.log('DEBUG', message, meta); }
  info(message, meta) { this.log('INFO', message, meta); }
  warn(message, meta) { this.log('WARN', message, meta); }
  error(message, meta) { this.log('ERROR', message, meta); }
  fatal(message, meta) { this.log('FATAL', message, meta); }
  
  // Установка контекста для всех последующих логов
  setContext(context) {
    this.context = { ...this.context, ...context };
  }
  
  // Временный контекст для одного лога
  withContext(context, callback) {
    const originalContext = { ...this.context };
    this.setContext(context);
    
    try {
      return callback(this);
    } finally {
      this.context = originalContext;
    }
  }
  
  // Метод форматирования по умолчанию
  defaultFormatter(entry) {
    return `[${entry.timestamp}] ${entry.level} ${entry.prefix ? entry.prefix + ' - ' : ''}${entry.message}`;
  }
  
  // Метод отправки по умолчанию
  defaultTransport(entry) {
    const formattedMessage = this.formatter(entry);
    
    switch (entry.level) {
      case 'TRACE':
      case 'DEBUG':
        console.debug(formattedMessage, entry.meta);
        break;
      case 'INFO':
        console.info(formattedMessage, entry.meta);
        break;
      case 'WARN':
        console.warn(formattedMessage, entry.meta);
        break;
      case 'ERROR':
        console.error(formattedMessage, entry.meta);
        break;
      case 'FATAL':
        console.error(formattedMessage, entry.meta);
        break;
      default:
        console.log(formattedMessage, entry.meta);
    }
  }
}

// Использование
const logger = new Logger({
  level: 'INFO',
  prefix: 'MyApp',
  enabled: true
});

logger.info('Приложение запущено');
logger.error('Произошла ошибка', { userId: 123, action: 'login' });
```

## Расширенная система логирования с транспортом

```javascript
class AdvancedLogger extends Logger {
  constructor(options = {}) {
    super(options);
    
    // Массив транспортов для отправки логов в разные системы
    this.transports = options.transports || [this.defaultTransport];
    
    // Буфер для логов (для отправки пачками)
    this.buffer = [];
    this.bufferSize = options.bufferSize || 10;
    this.flushInterval = options.flushInterval || 30000; // 30 секунд
    
    // Запуск периодической отправки
    if (this.flushInterval > 0) {
      setInterval(() => {
        this.flush();
      }, this.flushInterval);
    }
  }
  
  // Переопределяем метод транспорта для работы с несколькими транспортами
  transport(entry) {
    // Добавляем в буфер для отправки на сервер
    if (this.shouldSendToServer(entry)) {
      this.buffer.push(entry);
      
      // Отправляем, если буфер полон
      if (this.buffer.length >= this.bufferSize) {
        this.flush();
      }
    }
    
    // Выводим в консоль
    this.transports.forEach(transport => {
      if (transport !== this.serverTransport) {
        transport(entry);
      }
    });
  }
  
  // Определяем, нужно ли отправлять лог на сервер
  shouldSendToServer(entry) {
    // Отправляем только WARN, ERROR и FATAL в продакшене
    // и все в девелопменте
    const isProd = process.env.NODE_ENV === 'production';
    return isProd ? this.levels[entry.level] >= this.levels.WARN : true;
  }
  
  // Метод отправки на сервер
  serverTransport = (entry) => {
    // Отправляем через sendBeacon для надежности
    if (navigator.sendBeacon) {
      const data = JSON.stringify([entry]);
      navigator.sendBeacon('/api/logs', data);
    } else {
      // Резервный метод
      fetch('/api/logs', {
        method: 'POST',
        body: JSON.stringify([entry]),
        keepalive: true
      }).catch(() => {
        // Игнорируем ошибки отправки логов
      });
    }
  };
  
  // Отправка накопленных логов
  flush() {
    if (this.buffer.length === 0) return;
    
    const logsToSend = [...this.buffer];
    this.buffer = [];
    
    // Отправляем через sendBeacon
    if (navigator.sendBeacon) {
      const data = JSON.stringify(logsToSend);
      navigator.sendBeacon('/api/logs', data);
    } else {
      fetch('/api/logs', {
        method: 'POST',
        body: JSON.stringify(logsToSend),
        keepalive: true
      }).catch(() => {
        // Возвращаем логи в буфер при ошибке
        this.buffer = [...logsToSend, ...this.buffer];
      });
    }
  }
}

// Создание логгера с несколькими транспортами
const advancedLogger = new AdvancedLogger({
  level: 'DEBUG',
  prefix: 'AdvancedApp',
  transports: [
    (entry) => {
      // Консольный транспорт
      console.log(`%c[${entry.level}] ${entry.message}`, 
        entry.level === 'ERROR' ? 'color: red;' : 
        entry.level === 'WARN' ? 'color: orange;' : 
        'color: gray;');
    },
    (entry) => {
      // Отправка в удаленную систему (например, LogRocket, Sentry)
      if (window.Sentry && entry.level === 'ERROR') {
        Sentry.captureMessage(`${entry.message}`, {
          contexts: { log: entry }
        });
      }
    }
  ],
  bufferSize: 5,
  flushInterval: 10000
});
```

## Логирование в разных контекстах

### Логирование API вызовов
```javascript
class APILogger {
  constructor(logger) {
    this.logger = logger;
  }
  
  async request(url, options = {}) {
    const startTime = Date.now();
    const requestId = this.generateRequestId();
    
    this.logger.info('API request started', {
      requestId,
      url,
      method: options.method || 'GET',
      userAgent: navigator.userAgent
    });
    
    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'X-Request-ID': requestId
        }
      });
      
      const duration = Date.now() - startTime;
      
      if (response.ok) {
        this.logger.info('API request completed', {
          requestId,
          url,
          status: response.status,
          duration,
          userAgent: navigator.userAgent
        });
      } else {
        this.logger.warn('API request failed', {
          requestId,
          url,
          status: response.status,
          duration,
          userAgent: navigator.userAgent
        });
      }
      
      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.logger.error('API request error', {
        requestId,
        url,
        error: error.message,
        duration,
        userAgent: navigator.userAgent
      });
      
      throw error;
    }
  }
  
  generateRequestId() {
    return 'req_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
}

// Использование
const apiLogger = new APILogger(advancedLogger);

// Обертка для fetch
const apiCall = async (url, options) => {
  const response = await apiLogger.request(url, options);
  return response.json();
};
```

### Логирование пользовательских действий
```javascript
class UserActionLogger {
  constructor(logger) {
    this.logger = logger;
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // Логирование кликов
    document.addEventListener('click', (event) => {
      this.logUserAction('click', {
        element: this.getElementInfo(event.target),
        position: { x: event.clientX, y: event.clientY },
        timestamp: Date.now()
      });
    });
    
    // Логирование ввода в формы
    document.addEventListener('input', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        this.logUserAction('input', {
          element: this.getElementInfo(event.target),
          valueLength: event.target.value.length,
          timestamp: Date.now()
        });
      }
    });
    
    // Логирование отправки форм
    document.addEventListener('submit', (event) => {
      this.logUserAction('form_submit', {
        form: this.getElementInfo(event.target),
        timestamp: Date.now()
      });
    });
  }
  
  logUserAction(action, details) {
    this.logger.info(`User ${action}`, {
      action,
      details,
      url: window.location.href,
      userAgent: navigator.userAgent,
      userId: window.currentUser?.id || 'anonymous'
    });
  }
  
  getElementInfo(element) {
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      textContent: element.textContent?.substring(0, 50) || '',
      href: element.href || '',
      name: element.name || ''
    };
  }
}

// Инициализация логирования действий пользователя
const userActionLogger = new UserActionLogger(advancedLogger);
```

## Структурированное логирование

```javascript
class StructuredLogger extends AdvancedLogger {
  constructor(options = {}) {
    super(options);
    
    // Форматтер для структурированных логов
    this.formatter = (entry) => {
      return JSON.stringify({
        timestamp: entry.timestamp,
        level: entry.level,
        message: entry.message,
        prefix: entry.prefix,
        meta: entry.meta
      });
    };
  }
  
  // Метод для логирования с автоматическим добавлением контекста
  logWithContext(context, level, message, meta = {}) {
    return this.withContext(context, (logger) => {
      logger.log(level, message, meta);
    });
  }
  
  // Логирование операций с замером времени
  async timeOperation(operationName, operation, context = {}) {
    const startTime = Date.now();
    
    try {
      this.info(`Starting ${operationName}`, { ...context, operation: operationName });
      
      const result = await operation();
      
      const duration = Date.now() - startTime;
      this.info(`Completed ${operationName}`, { 
        ...context, 
        operation: operationName, 
        duration 
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.error(`Failed ${operationName}`, { 
        ...context, 
        operation: operationName, 
        duration,
        error: error.message 
      });
      
      throw error;
    }
  }
}

// Использование структурированного логирования
const structuredLogger = new StructuredLogger({
  level: 'INFO',
  prefix: 'StructuredApp'
});

// Логирование с контекстом
structuredLogger.logWithContext(
  { userId: 123, sessionId: 'abc123' },
  'INFO', 
  'User performed action', 
  { action: 'button_click', buttonId: 'submit' }
);

// Логирование операции с замером времени
const result = await structuredLogger.timeOperation(
  'data_fetch',
  () => fetch('/api/data').then(r => r.json()),
  { userId: 123 }
);
```

## Интеграция с внешними системами логирования

### LogRocket
```javascript
class LogRocketLogger {
  constructor(logger) {
    this.logger = logger;
    
    if (window.LogRocket) {
      // Интеграция с LogRocket
      LogRocket.init('your-app-id');
      
      // Логирование ошибок в LogRocket
      this.logger.transports.push((entry) => {
        if (entry.level === 'ERROR' || entry.level === 'FATAL') {
          LogRocket.captureMessage(`${entry.level}: ${entry.message}`, {
            level: entry.level,
            meta: entry.meta
          });
        }
      });
    }
  }
  
  // Метод для записи пользовательских действий в LogRocket
  recordUserAction(action, data) {
    if (window.LogRocket) {
      LogRocket.record({ action, data });
    }
  }
}
```

### Sentry
```javascript
class SentryLogger {
  constructor(logger) {
    this.logger = logger;
    
    if (window.Sentry) {
      // Интеграция с Sentry
      Sentry.init({
        dsn: 'YOUR_SENTRY_DSN',
        integrations: [
          new Sentry.BrowserTracing(),
        ],
        tracesSampleRate: 0.1,
      });
      
      // Логирование ошибок в Sentry
      this.logger.transports.push((entry) => {
        if (entry.level === 'ERROR' || entry.level === 'FATAL') {
          Sentry.captureMessage(`${entry.level}: ${entry.message}`, {
            level: entry.level,
            contexts: { log: entry }
          });
        }
      });
    }
  }
  
  // Метод для добавления контекста к Sentry
  setUserContext(user) {
    if (window.Sentry) {
      Sentry.setUser(user);
    }
  }
  
  setTags(tags) {
    if (window.Sentry) {
      Object.keys(tags).forEach(key => {
        Sentry.setTag(key, tags[key]);
      });
    }
  }
}
```

## Логирование в React

```jsx
import { createContext, useContext, useEffect } from 'react';

// Контекст логгера
const LoggerContext = createContext();

// Провайдер логгера
export const LoggerProvider = ({ logger, children }) => {
  return (
    <LoggerContext.Provider value={logger}>
      {children}
    </LoggerContext.Provider>
  );
};

// Хук для получения логгера
export const useLogger = () => {
  const logger = useContext(LoggerContext);
  if (!logger) {
    throw new Error('useLogger must be used within LoggerProvider');
  }
  return logger;
};

// HOC для автоматического логирования событий компонента
export const withLogging = (WrappedComponent, componentName) => {
  return (props) => {
    const logger = useLogger();
    
    useEffect(() => {
      logger.info(`${componentName} mounted`, { props: Object.keys(props) });
      return () => {
        logger.info(`${componentName} unmounted`);
      };
    }, []);
    
    const logEvent = (eventName, data) => {
      logger.info(`${componentName} ${eventName}`, data);
    };
    
    return <WrappedComponent {...props} logEvent={logEvent} />;
  };
};

// Пример использования в компоненте
const ProductCard = ({ product, onAddToCart }) => {
  const logger = useLogger();
  
  const handleClick = () => {
    logger.info('Product card clicked', { productId: product.id });
    onAddToCart(product);
  };
  
  return (
    <div className="product-card" onClick={handleClick}>
      <h3>{product.name}</h3>
      <p>{product.price}</p>
    </div>
  );
};
```

## Логирование в Vue.js

```javascript
// Плагин Vue для логирования
const LoggingPlugin = {
  install(Vue, { logger }) {
    Vue.prototype.$logger = logger;
    
    // Глобальный обработчик ошибок
    Vue.config.errorHandler = (err, vm, info) => {
      logger.error('Vue error', {
        error: err.message,
        component: vm.$options.name,
        info
      });
    };
    
    // Миксин для автоматического логирования
    Vue.mixin({
      created() {
        if (this.$options.name) {
          logger.debug(`${this.$options.name} component created`);
        }
      },
      mounted() {
        if (this.$options.name) {
          logger.info(`${this.$options.name} component mounted`);
        }
      }
    });
  }
};

// Использование
Vue.use(LoggingPlugin, { logger: structuredLogger });

// В компоненте
export default {
  name: 'ProductPage',
  methods: {
    addToCart(product) {
      this.$logger.info('Add to cart clicked', { productId: product.id });
      // Логика добавления в корзину
    }
  }
};
```

## Управление логированием в продакшене

```javascript
class ProductionLogger extends StructuredLogger {
  constructor(options = {}) {
    // В продакшене уменьшаем уровень логирования
    const prodOptions = {
      ...options,
      level: process.env.NODE_ENV === 'production' ? 'WARN' : 'DEBUG'
    };
    
    super(prodOptions);
    
    // В продакшене ограничиваем объем данных
    if (process.env.NODE_ENV === 'production') {
      this.setupProductionConstraints();
    }
  }
  
  setupProductionConstraints() {
    // Ограничение на объем передаваемых данных
    this.maxMessageLength = 1000;
    this.maxMetaSize = 5000;
    
    // Фильтрация чувствительных данных
    this.transports.push((entry) => {
      const filteredEntry = this.filterSensitiveData(entry);
      
      // Отправка только определенных типов логов в продакшене
      if (this.isProductionLogAllowed(filteredEntry)) {
        this.sendToRemote(filteredEntry);
      }
    });
  }
  
  filterSensitiveData(entry) {
    const filtered = { ...entry };
    
    // Удаление чувствительных данных из мета
    if (filtered.meta) {
      const meta = { ...filtered.meta };
      
      // Удаление потенциально чувствительных полей
      delete meta.password;
      delete meta.token;
      delete meta.creditCard;
      delete meta.ssn;
      
      // Маскирование email
      if (meta.email) {
        meta.email = this.maskEmail(meta.email);
      }
      
      filtered.meta = meta;
    }
    
    // Ограничение длины сообщения
    if (filtered.message && filtered.message.length > this.maxMessageLength) {
      filtered.message = filtered.message.substring(0, this.maxMessageLength) + '...';
    }
    
    return filtered;
  }
  
  maskEmail(email) {
    const [localPart, domain] = email.split('@');
    if (localPart.length > 2) {
      return localPart[0] + '*'.repeat(localPart.length - 2) + localPart[localPart.length - 1] + '@' + domain;
    }
    return email;
  }
  
  isProductionLogAllowed(entry) {
    // В продакшене отправляем только WARN, ERROR и FATAL
    return this.levels[entry.level] >= this.levels.WARN;
  }
  
  sendToRemote(entry) {
    // Отправка в удаленную систему логирования
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/logs', JSON.stringify([entry]));
    }
  }
}

// Инициализация продакшн логгера
const prodLogger = new ProductionLogger({
  prefix: 'ProdApp'
});
```

## Лучшие практики логирования

### 1. Структурированные сообщения
```javascript
// Хорошо: структурированное сообщение с понятными полями
logger.info('User logged in', {
  userId: 123,
  loginMethod: 'email',
  timestamp: new Date().toISOString()
});

// Плохо: неструктурированное сообщение
logger.info(`User ${userId} logged in using ${loginMethod} at ${timestamp}`);
```

### 2. Уместное количество информации
```javascript
// Хорошо: только необходимая информация
logger.error('API request failed', {
  url: '/api/users',
  status: 500,
  userId: 123
});

// Плохо: слишком много информации
logger.error('API request failed: user with id 123 tried to access /api/users endpoint but received 500 status code at ' + new Date().toISOString());
```

### 3. Согласованные форматы
```javascript
// Создание шаблонов для часто используемых логов
const logTemplates = {
  userAction: (action, userId, details) => ({
    action,
    userId,
    details,
    timestamp: new Date().toISOString()
  }),
  
  apiCall: (endpoint, method, status, duration) => ({
    endpoint,
    method,
    status,
    duration
  })
};

// Использование шаблонов
logger.info('User action', logTemplates.userAction('login', 123, { method: 'email' }));
```

### 4. Контекстные логи
```javascript
// Добавление контекста к логам
function createUserLogger(userId) {
  return prodLogger.withContext({ userId }, (logger) => logger);
}

const userLogger = createUserLogger(123);
userLogger.info('Profile updated', { field: 'email' });
```

## Заключение

Эффективное логирование - это ключевой компонент надежного фронтенд-приложения. Хорошо спроектированная система логирования позволяет:

- Быстро диагностировать и устранять проблемы
- Понимать поведение пользователей и улучшать UX
- Отслеживать производительность и надежность приложения
- Обеспечивать безопасность и аудит действий

При создании системы логирования важно:

- [[Мониторинг-ошибок|Интегрировать с системами мониторинга ошибок]]
- [[Мониторинг-производительности|Коррелировать с метриками производительности]]
- [[Аналитика-использования|Использовать для анализа поведения пользователей]]
- [[Алертинг|Настроить оповещения на основе логов]]

## См. также
- [[Мониторинг-ошибок]]
- [[Мониторинг-производительности]]
- [[Аналитика-использования]]
- [[Алертинг]]