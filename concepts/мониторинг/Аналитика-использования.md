---
aliases: ["User Analytics", "Аналитика пользователей", "Поведение пользователей"]
tags: [frontend, analytics, user-behavior, tracking, events]
---

# Аналитика использования

Аналитика использования - это процесс сбора, анализа и интерпретации данных о том, как пользователи взаимодействуют с веб-приложением. Это важный аспект мониторинга, который помогает понять поведение пользователей, выявить проблемы с пользовательским интерфейсом и принять обоснованные решения по улучшению продукта.

## Зачем нужна аналитика использования

- **Понимание пользовательского поведения**: Как пользователи перемещаются по приложению, какие функции используются чаще всего
- **Оптимизация пользовательского опыта**: Выявление узких мест и улучшение UX на основе реальных данных
- **Принятие решений на основе данных**: Обоснование изменений в интерфейсе и функциональности
- **Измерение успеха функций**: Оценка влияния новых функций на поведение пользователей
- **Персонализация**: Адаптация интерфейса под различные группы пользователей

## Типы аналитики использования

### 1. Page View Analytics (аналитика просмотров страниц)
Отслеживание посещений страниц и переходов между ними.

### 2. Event Tracking (отслеживание событий)
Регистрация конкретных действий пользователей: клики, отправка форм, воспроизведение видео и т.д.

### 3. Funnel Analysis (анализ воронки)
Отслеживание последовательности шагов, которые пользователь должен выполнить для достижения цели.

### 4. Cohort Analysis (когортный анализ)
Анализ поведения групп пользователей, объединенных по какому-либо признаку (время регистрации, источник трафика и т.д.).

### 5. Heatmap Analysis (анализ тепловых карт)
Визуализация областей, в которых пользователи чаще всего кликают, перемещают мышь или прокручивают.

## Популярные инструменты аналитики

### Google Analytics 4
Современная версия Google Analytics с упором на машинное обучение и конфиденциальность пользователей.

```javascript
// Отправка пользовательского события в GA4
function trackEvent(eventName, eventParams = {}) {
  if (window.gtag) {
    gtag('event', eventName, {
      ...eventParams,
      custom_parameter: 'value'
    });
  }
}

// Пример отслеживания клика по кнопке
document.getElementById('cta-button').addEventListener('click', () => {
  trackEvent('button_click', {
    button_id: 'cta-button',
    page_location: window.location.href
  });
});
```

### Yandex Metrica
Российский сервис веб-аналитики.

```javascript
// Отправка события в Яндекс.Метрику
function ymReachGoal(target, params) {
  if (typeof ym !== 'undefined') {
    ym(XXXXXXX, 'reachGoal', target, params);
  }
}

// Пример использования
ymReachGoal('ORDER_COMPLETED', {
  order_id: '12345',
  revenue: 5000
});
```

### Mixpanel
Платформа аналитики, ориентированная на анализ пользовательских событий и поведения.

```javascript
// Отправка события в Mixpanel
function trackMixpanelEvent(eventName, properties = {}) {
  if (window.mixpanel) {
    mixpanel.track(eventName, {
      ...properties,
      $current_url: window.location.href
    });
  }
}

// Пример отслеживания регистрации
trackMixpanelEvent('User Registration', {
  user_id: '12345',
  registration_method: 'email'
});
```

### Hotjar
Инструмент для сбора тепловых карт, записей сессий и опросов пользователей.

## Создание собственной системы аналитики

Для специфических требований или конфиденциальности можно создать собственную систему аналитики:

```javascript
class UserAnalytics {
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/api/analytics';
    this.userId = options.userId || this.generateAnonymousId();
    this.sessionId = this.generateSessionId();
    this.buffer = [];
    this.maxBufferSize = options.maxBufferSize || 10;
    this.debug = options.debug || false;
    
    this.init();
  }
  
  init() {
    // Устанавливаем обработчики событий
    this.setupEventListeners();
    
    // Отправляем событие начала сессии
    this.track('session_start', {
      user_agent: navigator.userAgent,
      screen_resolution: `${screen.width}x${screen.height}`,
      viewport_size: `${window.innerWidth}x${window.innerHeight}`,
      language: navigator.language,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    });
    
    // Регулярная отправка буфера
    setInterval(() => {
      this.flush();
    }, 30000); // Каждые 30 секунд
  }
  
  generateAnonymousId() {
    return 'user_' + Math.random().toString(36).substr(2, 9);
  }
  
  generateSessionId() {
    return 'sess_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
  
  setupEventListeners() {
    // Отслеживание кликов
    document.addEventListener('click', (event) => {
      this.trackClick(event);
    });
    
    // Отслеживание просмотров страниц
    window.addEventListener('popstate', () => {
      this.trackPageView();
    });
    
    // Отслеживание отправки форм
    document.addEventListener('submit', (event) => {
      this.trackFormSubmit(event);
    });
    
    // Отслеживание прокрутки страницы
    let scrollTimeout;
    document.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.trackScrollDepth();
      }, 500);
    });
    
    // Отслеживание времени на странице
    let pageVisibilityLastTime = Date.now();
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Пользователь ушел со страницы
        this.track('page_exit', {
          time_on_page: Date.now() - pageVisibilityLastTime
        });
      } else {
        // Пользователь вернулся
        pageVisibilityLastTime = Date.now();
        this.track('page_return');
      }
    });
    
    // Отслеживание покидания страницы
    window.addEventListener('beforeunload', () => {
      this.track('page_unload', {
        time_on_page: Date.now() - pageVisibilityLastTime
      });
      this.flush(true); // Принудительная отправка
    });
  }
  
  track(eventName, properties = {}) {
    const event = {
      event_name: eventName,
      user_id: this.userId,
      session_id: this.sessionId,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      referrer: document.referrer,
      properties: {
        ...properties,
        page_title: document.title
      }
    };
    
    if (this.debug) {
      console.log('Analytics event:', event);
    }
    
    this.buffer.push(event);
    
    // Отправляем если буфер полон
    if (this.buffer.length >= this.maxBufferSize) {
      this.flush();
    }
  }
  
  trackClick(event) {
    const element = event.target;
    const elementInfo = {
      tag_name: element.tagName.toLowerCase(),
      class_name: element.className,
      id: element.id,
      text: element.textContent?.substring(0, 100) || element.value || '',
      href: element.href || '',
      position_x: event.clientX,
      position_y: event.clientY
    };
    
    this.track('click', elementInfo);
  }
  
  trackPageView() {
    this.track('page_view', {
      page_url: window.location.href,
      page_title: document.title
    });
  }
  
  trackFormSubmit(event) {
    const form = event.target;
    const formInfo = {
      form_id: form.id,
      form_name: form.name,
      action: form.action,
      method: form.method
    };
    
    this.track('form_submit', formInfo);
  }
  
  trackScrollDepth() {
    const scrollPercent = Math.round(
      (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100
    );
    
    if (scrollPercent >= 25 && !this.scrolled25) {
      this.scrolled25 = true;
      this.track('scroll_depth', { depth: 25 });
    }
    if (scrollPercent >= 50 && !this.scrolled50) {
      this.scrolled50 = true;
      this.track('scroll_depth', { depth: 50 });
    }
    if (scrollPercent >= 75 && !this.scrolled75) {
      this.scrolled75 = true;
      this.track('scroll_depth', { depth: 75 });
    }
    if (scrollPercent >= 90 && !this.scrolled90) {
      this.scrolled90 = true;
      this.track('scroll_depth', { depth: 90 });
    }
  }
  
  flush(immediate = false) {
    if (this.buffer.length === 0) return;
    
    // Для немедленной отправки (например, при unload) - используем sendBeacon
    if (immediate && navigator.sendBeacon) {
      const data = JSON.stringify({
        events: [...this.buffer],
        user_id: this.userId,
        session_id: this.sessionId
      });
      
      navigator.sendBeacon(this.apiEndpoint, data);
      this.buffer = [];
    } else {
      // Для обычной отправки используем fetch
      const eventsToSend = [...this.buffer];
      this.buffer = [];
      
      fetch(this.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          events: eventsToSend,
          user_id: this.userId,
          session_id: this.sessionId
        })
      }).catch(error => {
        console.error('Analytics error:', error);
        // Возвращаем события в буфер при ошибке
        this.buffer = [...eventsToSend, ...this.buffer];
      });
    }
  }
}

// Инициализация аналитики
const analytics = new UserAnalytics({
  apiEndpoint: '/api/user-events',
  userId: window.currentUser?.id, // Если пользователь авторизован
  debug: false
});
```

## Расширенная аналитика событий

### Отслеживание пользовательского пути (User Journey)
```javascript
class UserJourneyTracker {
  constructor(analytics) {
    this.analytics = analytics;
    this.journey = [];
    this.startTime = Date.now();
  }
  
  addStep(stepName, properties = {}) {
    const step = {
      step_name: stepName,
      timestamp: Date.now(),
      url: window.location.href,
      properties
    };
    
    this.journey.push(step);
    
    // Отправляем событие
    this.analytics.track('user_journey_step', {
      step: stepName,
      journey_length: this.journey.length,
      time_from_start: Date.now() - this.startTime,
      ...properties
    });
  }
  
  completeJourney(journeyName, finalProperties = {}) {
    const totalTime = Date.now() - this.startTime;
    
    this.analytics.track('user_journey_complete', {
      journey_name: journeyName,
      steps_count: this.journey.length,
      total_time: totalTime,
      success: true,
      ...finalProperties
    });
    
    // Сброс состояния
    this.journey = [];
    this.startTime = Date.now();
  }
  
  abandonJourney(journeyName, reason = 'unknown') {
    const totalTime = Date.now() - this.startTime;
    
    this.analytics.track('user_journey_abandoned', {
      journey_name: journeyName,
      steps_completed: this.journey.length,
      total_time: totalTime,
      reason
    });
    
    // Сброс состояния
    this.journey = [];
    this.startTime = Date.now();
  }
}

// Пример использования
const checkoutJourney = new UserJourneyTracker(analytics);

// На каждом шаге оформления заказа
checkoutJourney.addStep('cart_view');
checkoutJourney.addStep('shipping_info_filled');
checkoutJourney.addStep('payment_info_filled');

// При успешном завершении
checkoutJourney.completeJourney('checkout', { order_value: 5000 });

// При выходе из процесса
checkoutJourney.abandonJourney('checkout', 'payment_failed');
```

### Отслеживание A/B тестов
```javascript
class ABTestTracker {
  constructor(analytics) {
    this.analytics = analytics;
    this.activeTests = this.getStoredTests();
  }
  
  getStoredTests() {
    try {
      return JSON.parse(localStorage.getItem('ab_tests')) || {};
    } catch {
      return {};
    }
  }
  
  assignToTest(testName, variants) {
    if (this.activeTests[testName]) {
      return this.activeTests[testName];
    }
    
    // Рандомное присвоение варианта
    const variant = variants[Math.floor(Math.random() * variants.length)];
    
    this.activeTests[testName] = variant;
    this.saveTests();
    
    // Отслеживаем участие в тесте
    this.analytics.track('ab_test_assigned', {
      test_name: testName,
      variant
    });
    
    return variant;
  }
  
  saveTests() {
    localStorage.setItem('ab_tests', JSON.stringify(this.activeTests));
  }
  
  trackConversion(testName, conversionEvent, properties = {}) {
    const variant = this.activeTests[testName];
    
    if (variant) {
      this.analytics.track(conversionEvent, {
        ab_test: testName,
        ab_variant: variant,
        ...properties
      });
    }
  }
}

// Использование
const abTracker = new ABTestTracker(analytics);

// Присвоение пользователя к тесту
const buttonColorVariant = abTracker.assignToTest('cta_button_color', ['red', 'blue', 'green']);

// Применение варианта в интерфейсе
document.getElementById('cta-button').style.backgroundColor = buttonColorVariant;

// Отслеживание конверсии
document.getElementById('cta-button').addEventListener('click', () => {
  abTracker.trackConversion('cta_button_color', 'button_click');
});
```

## Аналитика производительности на основе пользовательского поведения

```javascript
class PerformanceBehaviorAnalytics {
  constructor(analytics) {
    this.analytics = analytics;
    this.performanceData = {};
    
    this.setupPerformanceMonitoring();
  }
  
  setupPerformanceMonitoring() {
    // Мониторинг Core Web Vitals
    if ('PerformanceObserver' in window) {
      // LCP
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.performanceData.lcp = lastEntry.startTime;
        this.analytics.track('performance_lcp', {
          value: lastEntry.startTime,
          url: lastEntry.name
        });
      }).observe({ entryTypes: ['largest-contentful-paint'] });
      
      // FID
      new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const firstEntry = entries[0];
        
        this.analytics.track('performance_fid', {
          value: firstEntry.processingStart - firstEntry.startTime
        });
      }).observe({ entryTypes: ['first-input'] });
      
      // CLS
      let clsValue = 0;
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        }
        
        this.performanceData.cls = clsValue;
        this.analytics.track('performance_cls', {
          value: clsValue
        });
      }).observe({ entryTypes: ['layout-shift'] });
    }
  }
  
  correlatePerformanceWithBehavior() {
    // Связываем производительность с пользовательским поведением
    this.analytics.track('performance_behavior_correlation', {
      lcp: this.performanceData.lcp,
      cls: this.performanceData.cls,
      user_actions_count: this.getUserActionsCount()
    });
  }
  
  getUserActionsCount() {
    // В реальном приложении это значение будет отслеживаться
    // в системе аналитики
    return 10; // заглушка
  }
}

const perfBehaviorAnalytics = new PerformanceBehaviorAnalytics(analytics);
```

## Конфиденциальность и GDPR

При реализации аналитики важно учитывать требования конфиденциальности:

```javascript
class PrivacyAwareAnalytics {
  constructor(options = {}) {
    this.consentGiven = this.checkConsent();
    this.analytics = options.analytics;
    this.storageKey = 'analytics_consent';
  }
  
  checkConsent() {
    // Проверяем, дал ли пользователь согласие
    const consent = localStorage.getItem(this.storageKey);
    return consent === 'true';
  }
  
  requestConsent() {
    // Показываем пользователю запрос на согласие
    return new Promise((resolve) => {
      if (confirm('Разрешите сбор анонимной аналитики для улучшения работы сайта?')) {
        localStorage.setItem(this.storageKey, 'true');
        resolve(true);
      } else {
        localStorage.setItem(this.storageKey, 'false');
        resolve(false);
      }
    });
  }
  
  async track(eventName, properties = {}) {
    if (!this.consentGiven) {
      this.consentGiven = await this.requestConsent();
    }
    
    if (this.consentGiven && this.analytics) {
      // Анонимизация данных
      const anonymizedProperties = this.anonymizeProperties(properties);
      this.analytics.track(eventName, anonymizedProperties);
    }
  }
  
  anonymizeProperties(properties) {
    // Удаляем или маскируем персональные данные
    const anonymized = { ...properties };
    
    // Удаляем потенциально идентифицирующие данные
    delete anonymized.email;
    delete anonymized.phone;
    delete anonymized.full_name;
    
    // Маскируем IP-адрес
    if (anonymized.ip_address) {
      anonymized.ip_address = this.maskIpAddress(anonymized.ip_address);
    }
    
    return anonymized;
  }
  
  maskIpAddress(ip) {
    const parts = ip.split('.');
    parts[parts.length - 1] = 'XXX';
    return parts.join('.');
  }
}
```

## Лучшие практики аналитики использования

### 1. Структурированные события
```javascript
// Хорошо: структурированные имена событий
analytics.track('product_add_to_cart', {
  product_id: '12345',
  product_name: 'Ноутбук',
  category: 'Электроника',
  price: 50000
});

// Плохо: неструктурированные события
analytics.track('click', {
  target: 'button',
  text: 'Купить'
});
```

### 2. Контекстные данные
```javascript
// Включение контекста в события
function trackProductView(productId, category) {
  analytics.track('product_view', {
    product_id: productId,
    category,
    page_url: window.location.href,
    referrer: document.referrer,
    user_status: window.currentUser ? 'authenticated' : 'guest'
  });
}
```

### 3. Управление объемом данных
```javascript
class AnalyticsRateLimiter {
  constructor(maxEventsPerMinute = 100) {
    this.maxEventsPerMinute = maxEventsPerMinute;
    this.eventsInCurrentMinute = 0;
    this.currentMinute = Math.floor(Date.now() / 60000);
    
    setInterval(() => {
      const currentMinute = Math.floor(Date.now() / 60000);
      if (currentMinute !== this.currentMinute) {
        this.eventsInCurrentMinute = 0;
        this.currentMinute = currentMinute;
      }
    }, 1000);
  }
  
  canTrackEvent() {
    if (this.eventsInCurrentMinute < this.maxEventsPerMinute) {
      this.eventsInCurrentMinute++;
      return true;
    }
    return false;
  }
}
```

## Аналитика в разных фреймворках

### React
```jsx
import { useEffect } from 'react';

function useAnalyticsEvent(eventName, properties) {
  useEffect(() => {
    if (window.analytics) {
      window.analytics.track(eventName, properties);
    }
  }, [eventName, properties]);
}

// Хук для отслеживания просмотров страниц
function usePageView(pageName) {
  useEffect(() => {
    if (window.analytics) {
      window.analytics.track('page_view', {
        page_name: pageName,
        url: window.location.href
      });
    }
  }, [pageName]);
}

// Компонент с аналитикой
function ProductCard({ product }) {
  useAnalyticsEvent('product_impression', {
    product_id: product.id,
    product_name: product.name
  });
  
  const handleClick = () => {
    window.analytics.track('product_click', {
      product_id: product.id,
      product_name: product.name
    });
  };
  
  return (
    <div onClick={handleClick} className="product-card">
      <h3>{product.name}</h3>
      <p>{product.price}</p>
    </div>
  );
}
```

### Vue.js
```javascript
// Vue mixin для аналитики
const analyticsMixin = {
  methods: {
    trackEvent(eventName, properties = {}) {
      if (window.analytics) {
        window.analytics.track(eventName, {
          ...properties,
          component: this.$options.name,
          route: this.$route ? this.$route.name : undefined
        });
      }
    }
  },
  
  mounted() {
    // Отслеживание просмотра компонента
    this.trackEvent('component_view', {
      component: this.$options.name
    });
  }
};

// Использование в компоненте
export default {
  name: 'ProductPage',
  mixins: [analyticsMixin],
  
  methods: {
    addToCart(product) {
      this.trackEvent('add_to_cart', {
        product_id: product.id,
        product_name: product.name
      });
    }
  }
};
```

## Визуализация и анализ данных

### Создание дашбордов
Для эффективного использования данных аналитики важно создать понятные дашборды:

- **Пользовательские метрики**: DAU, WAU, MAU, время сессии
- **Конверсии**: Прохождение воронок, конверсия по страницам
- **Технические метрики**: Производительность, ошибки
- **Сравнения**: До/после изменений, A/B тестирование

## Заключение

Аналитика использования - это мощный инструмент для понимания поведения пользователей и улучшения продукта. При правильной реализации она позволяет:

- Принимать решения на основе данных, а не предположений
- Понимать, где пользователи сталкиваются с трудностями
- Измерять влияние изменений в интерфейсе
- Персонализировать опыт для разных групп пользователей
- Улучшать конверсию и удержание

При реализации аналитики важно:

- [[Мониторинг-ошибок|Сопоставлять поведение пользователей с возникающими ошибками]]
- [[Мониторинг-производительности|Коррелировать производительность с пользовательским поведением]]
- [[Логирование|Собирать достаточный контекст для анализа]]
- [[Алертинг|Настроить оповещения о значительных изменениях в поведении пользователей]]

## См. также
- [[Мониторинг-ошибок]]
- [[Мониторинг-производительности]]
- [[Логирование]]
- [[Алертинг]]