---
aliases: ["Performance Monitoring", "Производительность фронтенда", "Web Performance"]
tags: [frontend, performance, monitoring, web-vitals, lighthouse]
---

# Мониторинг производительности

Мониторинг производительности фронтенд-приложений - это процесс измерения, анализа и оптимизации различных аспектов производительности веб-приложений с целью обеспечения быстрой загрузки, плавного взаимодействия и хорошего пользовательского опыта. Он включает в себя отслеживание ключевых метрик, таких как время загрузки страницы, интерактивность и визуальная стабильность.

## Основные метрики производительности

### Core Web Vitals (основные веб-показатели)

Google определил три ключевых метрики, которые важны для измерения качества пользовательского опыта:

#### 1. Largest Contentful Paint (LCP) - Наибольший контентный элемент
- **Что измеряет**: Время от начала загрузки страницы до отображения самого большого контентного элемента (изображения или текста)
- **Хорошее значение**: ≤ 2.5 секунд
- **Почему важно**: Показывает, когда основной контент страницы становится видимым

#### 2. First Input Delay (FID) - Задержка первого ввода
- **Что измеряет**: Время от первого взаимодействия пользователя с сайтом до момента, когда браузер может отреагировать
- **Хорошее значение**: ≤ 100 миллисекунд
- **Почему важно**: Показывает, насколько быстро сайт реагирует на действия пользователя

#### 3. Cumulative Layout Shift (CLS) - Совокупное смещение макета
- **Что измеряет**: Неожиданное смещение элементов на странице во время загрузки
- **Хорошее значение**: ≤ 0.1
- **Почему важно**: Показывает стабильность визуального представления страницы

### Дополнительные метрики производительности

#### First Contentful Paint (FCP) - Первое отображение контента
- Время от начала загрузки до отображения первого байта контента

#### Time to Interactive (TTI) - Время до интерактивности
- Время, когда страница становится полностью интерактивной

#### Total Blocking Time (TBT) - Общее время блокировки
- Сумма всех продолжительностей блокировок между FCP и TTI

#### First Meaningful Paint (FMP) - Первое значимое отображение
- Время отображения основного контента страницы

## Инструменты для измерения производительности

### Web Vitals JavaScript Library
Google предоставляет библиотеку для измерения Core Web Vitals в реальных условиях использования:

```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

// Отправка метрик в аналитическую систему
function sendToAnalytics(metric) {
  // Отправка метрики на сервер
  navigator.sendBeacon('/analytics', JSON.stringify(metric));
}

// Регистрация метрик
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### Performance API

Встроенный в браузер API для измерения производительности:

```javascript
// Измерение времени выполнения кода
const measureName = 'my-operation';
performance.mark(`start-${measureName}`);

// Ваш код здесь
someOperation();

performance.mark(`end-${measureName}`);
performance.measure(measureName, `start-${measureName}`, `end-${measureName}`);

// Получение результатов измерений
const measures = performance.getEntriesByName(measureName);
const measure = measures[0];
console.log(`${measureName}: ${measure.duration}ms`);
```

### Navigation Timing API

Для измерения времени загрузки страницы:

```javascript
function getNavigationTiming() {
  const timing = performance.getEntriesByType('navigation')[0];
  
  if (timing) {
    return {
      // Время от начала загрузки до получения первого байта
      responseStart: timing.responseStart,
      // Время от начала загрузки до завершения получения ответа
      responseEnd: timing.responseEnd,
      // Время до DOMContentLoaded
      domContentLoaded: timing.domContentLoadedEventEnd,
      // Время до полной загрузки
      loadComplete: timing.loadEventEnd,
      // Время до DOM интерактивности
      domInteractive: timing.domInteractive,
      // Время загрузки домена
      domainLookupTime: timing.domainLookupEnd - timing.domainLookupStart,
      // Время подключения к серверу
      connectTime: timing.connectEnd - timing.connectStart,
      // Время получения ответа
      responseTime: timing.responseEnd - timing.responseStart
    };
  }
}
```

## Практические методы мониторинга

### 1. Реальный пользовательский мониторинг (RUM)

```javascript
class PerformanceMonitor {
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/performance-metrics';
    this.sampleRate = options.sampleRate || 1.0; // 100% по умолчанию
    this.metrics = {};
    
    this.initialize();
  }
  
  initialize() {
    // Проверяем, нужно ли отправлять метрики (учитываем сэмплирование)
    if (Math.random() > this.sampleRate) {
      return;
    }
    
    // Измеряем Core Web Vitals
    this.measureCoreWebVitals();
    
    // Измеряем время загрузки страницы
    this.measurePageLoadTime();
    
    // Измеряем время до интерактивности
    this.measureTimeToInteractive();
    
    // Отправляем метрики при завершении загрузки
    if (document.readyState === 'complete') {
      this.sendMetrics();
    } else {
      window.addEventListener('load', () => {
        setTimeout(() => this.sendMetrics(), 0);
      });
    }
  }
  
  measureCoreWebVitals() {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(metric => this.setMetric('CLS', metric));
      getFID(metric => this.setMetric('FID', metric));
      getFCP(metric => this.setMetric('FCP', metric));
      getLCP(metric => this.setMetric('LCP', metric));
      getTTFB(metric => this.setMetric('TTFB', metric));
    });
  }
  
  measurePageLoadTime() {
    const measureName = 'page-load-time';
    performance.mark(`start-${measureName}`);
    
    const checkLoad = () => {
      if (document.readyState === 'complete') {
        performance.mark(`end-${measureName}`);
        performance.measure(measureName, `start-${measureName}`, `end-${measureName}`);
        
        const entries = performance.getEntriesByName(measureName);
        if (entries.length > 0) {
          this.setMetric('pageLoadTime', {
            name: measureName,
            value: entries[0].duration,
            rating: this.getRating(entries[0].duration, 2000, 4000)
          });
        }
      } else {
        setTimeout(checkLoad, 100);
      }
    };
    
    checkLoad();
  }
  
  measureTimeToInteractive() {
    const measureName = 'time-to-interactive';
    let tti = null;
    
    const checkTTI = () => {
      // Проверяем, готова ли страница к взаимодействию
      if (document.readyState === 'complete' && this.isInteractive()) {
        performance.mark(`end-${measureName}`);
        
        const startMark = performance.getEntriesByName(`start-${measureName}`);
        if (startMark.length > 0) {
          performance.measure(measureName, `start-${measureName}`, `end-${measureName}`);
          
          const entries = performance.getEntriesByName(measureName);
          if (entries.length > 0) {
            this.setMetric('TTI', {
              name: measureName,
              value: entries[0].duration,
              rating: this.getRating(entries[0].duration, 3000, 6000)
            });
          }
        }
        return;
      }
      
      setTimeout(checkTTI, 100);
    };
    
    performance.mark(`start-${measureName}`);
    checkTTI();
  }
  
  isInteractive() {
    // Проверяем, готова ли страница к взаимодействию
    // Это упрощенная проверка - в реальности может быть сложнее
    return document.readyState === 'complete';
  }
  
  setMetric(name, metric) {
    this.metrics[name] = metric;
  }
  
  getRating(value, goodThreshold, poorThreshold) {
    if (value <= goodThreshold) return 'good';
    if (value <= poorThreshold) return 'needs-improvement';
    return 'poor';
  }
  
  sendMetrics() {
    const performanceData = {
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString(),
      metrics: this.metrics,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      }
    };
    
    // Отправка данных на сервер
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.apiEndpoint, JSON.stringify(performanceData));
    } else {
      // Резервный метод для старых браузеров
      fetch(this.apiEndpoint, {
        method: 'POST',
        body: JSON.stringify(performanceData),
        keepalive: true
      }).catch(err => console.error('Failed to send performance data:', err));
    }
  }
}

// Инициализация мониторинга производительности
const perfMonitor = new PerformanceMonitor({
  sampleRate: 0.1, // Отправлять 10% сэмплов
  apiEndpoint: '/api/performance'
});
```

### 2. Мониторинг загрузки ресурсов

```javascript
class ResourcePerformanceMonitor {
  constructor() {
    this.resourceMetrics = [];
    this.setupResourceObserver();
  }
  
  setupResourceObserver() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'resource') {
            this.recordResourceMetric(entry);
          }
        });
      });
      
      observer.observe({ entryTypes: ['resource'] });
    }
  }
  
  recordResourceMetric(entry) {
    const resourceMetric = {
      name: entry.name,
      entryType: entry.entryType,
      startTime: entry.startTime,
      duration: entry.duration,
      transferSize: entry.transferSize,
      decodedBodySize: entry.decodedBodySize,
      contentType: entry.responseEnd > 0 ? this.getContentType(entry.name) : undefined,
      loadTime: entry.responseEnd - entry.startTime,
      connectTime: entry.connectEnd - entry.connectStart,
      dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
      redirectTime: entry.redirectEnd - entry.redirectStart
    };
    
    this.resourceMetrics.push(resourceMetric);
    
    // Отправляем метрики для ресурсов, которые превышают порог
    if (resourceMetric.duration > 1000) { // Больше 1 секунды
      this.reportSlowResource(resourceMetric);
    }
  }
  
  getContentType(url) {
    if (url.includes('.js')) return 'script';
    if (url.includes('.css')) return 'stylesheet';
    if (url.includes('.png') || url.includes('.jpg') || url.includes('.jpeg') || url.includes('.gif') || url.includes('.webp')) return 'image';
    if (url.includes('.woff') || url.includes('.woff2') || url.includes('.ttf') || url.includes('.eot')) return 'font';
    return 'other';
  }
  
  reportSlowResource(resourceMetric) {
    // Отправляем информацию о медленно загружающихся ресурсах
    console.warn('Slow resource detected:', resourceMetric);
    
    // Здесь можно отправить метрику в систему мониторинга
    // например, в Sentry, LogRocket или другую систему
  }
  
  getSlowResources(threshold = 1000) {
    return this.resourceMetrics.filter(resource => resource.duration > threshold);
  }
  
  getResourceStats() {
    const stats = {
      total: this.resourceMetrics.length,
      slow: this.resourceMetrics.filter(r => r.duration > 1000).length,
      totalSize: this.resourceMetrics.reduce((sum, r) => sum + r.transferSize, 0),
      avgLoadTime: this.resourceMetrics.reduce((sum, r) => sum + r.duration, 0) / this.resourceMetrics.length
    };
    
    return stats;
  }
}

// Инициализация мониторинга ресурсов
const resourceMonitor = new ResourcePerformanceMonitor();
```

### 3. Мониторинг анимаций и FPS

```javascript
class AnimationPerformanceMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 0;
    this.fpsHistory = [];
    
    this.startMonitoring();
  }
  
  startMonitoring() {
    const updateFPS = (currentTime) => {
      this.frameCount++;
      
      const delta = currentTime - this.lastTime;
      
      if (delta >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / delta);
        this.fpsHistory.push({
          fps: this.fps,
          timestamp: Date.now()
        });
        
        // Ограничиваем историю до последних 100 значений
        if (this.fpsHistory.length > 100) {
          this.fpsHistory.shift();
        }
        
        this.frameCount = 0;
        this.lastTime = currentTime;
        
        // Проверяем, не слишком ли низкий FPS
        if (this.fps < 30) {
          this.reportLowFPS(this.fps);
        }
      }
      
      requestAnimationFrame(updateFPS);
    };
    
    requestAnimationFrame(updateFPS);
  }
  
  reportLowFPS(fps) {
    console.warn(`Low FPS detected: ${fps} FPS`);
    
    // Отправляем информацию о низком FPS в систему мониторинга
    const lowFPSData = {
      fps,
      timestamp: new Date().toISOString(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // Отправка данных
    navigator.sendBeacon('/api/low-fps', JSON.stringify(lowFPSData));
  }
  
  getAverageFPS() {
    if (this.fpsHistory.length === 0) return 0;
    
    const sum = this.fpsHistory.reduce((acc, entry) => acc + entry.fps, 0);
    return Math.round(sum / this.fpsHistory.length);
  }
  
  getFPSPercentile(percentile) {
    if (this.fpsHistory.length === 0) return 0;
    
    const sortedFPS = this.fpsHistory.map(entry => entry.fps).sort((a, b) => a - b);
    const index = Math.floor(sortedFPS.length * (percentile / 100));
    return sortedFPS[index] || 0;
  }
}

// Инициализация мониторинга анимаций
const animationMonitor = new AnimationPerformanceMonitor();
```

## Интеграция с популярными инструментами

### Lighthouse CI
Lighthouse CI позволяет автоматически запускать Lighthouse и сохранять результаты:

```javascript
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      numberOfRuns: 3,
      url: [
        'https://yoursite.com/page1',
        'https://yoursite.com/page2'
      ],
      startServerCommand: 'npm run start',
      startServerReadyPattern: 'Server running',
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['warn', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }],
      },
    },
    upload: {
      target: 'temporary-public-storage',
    },
  },
};
```

### WebPageTest API
```javascript
const WebPageTest = require('webpagetest');
const wpt = new WebPageTest('your-webpagetest-server.com', 'your-api-key');

// Запуск теста производительности
wpt.runTest('https://yoursite.com', {
  location: 'Dulles:Chrome',
  runs: 3,
  firstViewOnly: true
}, (err, data) => {
  if (err) {
    console.error('WebPageTest error:', err);
    return;
  }
  
  console.log('Test ID:', data.data.testId);
});
```

## Лучшие практики мониторинга производительности

### 1. Установка пороговых значений
```javascript
const PERFORMANCE_THRESHOLDS = {
  LCP: { good: 2500, poor: 4000 }, // milliseconds
  FID: { good: 100, poor: 300 },   // milliseconds
  CLS: { good: 0.1, poor: 0.25 },  // unitless
  FCP: { good: 1800, poor: 3000 }, // milliseconds
  TTI: { good: 3800, poor: 7300 }  // milliseconds
};
```

### 2. Сегментация данных
```javascript
function getPerformanceContext() {
  return {
    deviceType: getDeviceType(),
    connectionType: getConnectionType(),
    pageType: getPageType(),
    userLocation: getUserLocation(),
    browser: getBrowserInfo()
  };
}

function getDeviceType() {
  const width = window.innerWidth;
  if (width <= 768) return 'mobile';
  if (width <= 1024) return 'tablet';
  return 'desktop';
}

function getConnectionType() {
  return navigator.connection ? navigator.connection.effectiveType : 'unknown';
}
```

### 3. Корреляция с бизнес-метриками
```javascript
class PerformanceBusinessMetrics {
  constructor() {
    this.pageLoadStartTime = performance.now();
  }
  
  trackConversionEvent(eventName, data) {
    const loadTime = performance.now() - this.pageLoadStartTime;
    
    // Связываем время загрузки со значимыми действиями пользователя
    if (eventName === 'purchase' || eventName === 'signup') {
      this.sendPerformanceConversionData({
        loadTime,
        eventType: eventName,
        eventData: data,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  sendPerformanceConversionData(data) {
    // Отправляем данные о производительности и конверсиях
    fetch('/api/performance-conversions', {
      method: 'POST',
      body: JSON.stringify(data),
      keepalive: true
    });
  }
}
```

## Улучшение производительности на основе метрик

### Оптимизация Largest Contentful Paint (LCP)
- Оптимизация изображений (использование WebP, lazy loading)
- Приоритетная загрузка критических ресурсов
- Оптимизация CSS и JavaScript

### Уменьшение First Input Delay (FID)
- Разделение больших JavaScript-бандлов
- Использование requestIdleCallback для тяжелых операций
- Оптимизация обработчиков событий

### Снижение Cumulative Layout Shift (CLS)
- Заранее определение размеров изображений и iframe
- Избегание динамической вставки контента над существующим
- Использование font-display: swap для шрифтов

## Заключение

Мониторинг производительности - это непрерывный процесс, который должен быть интегрирован в весь цикл разработки. Ключевые моменты:

- Регулярное измерение Core Web Vitals и других метрик
- Установка пороговых значений и алертинг на ухудшение производительности
- Корреляция метрик производительности с бизнес-результатами
- Использование данных для принятия решений об оптимизации

Эффективный мониторинг производительности позволяет:

- [[Мониторинг-ошибок|Отслеживать влияние изменений на производительность]]
- [[Аналитика-использования|Понимать, как производительность влияет на поведение пользователей]]
- [[Алертинг|Быстро реагировать на ухудшение метрик]]
- [[Логирование|Собирать контекстные данные для диагностики проблем]]

## См. также
- [[Мониторинг-ошибок]]
- [[Аналитика-использования]]
- [[Алертинг]]
- [[Логирование]]