---
aliases: ["Отслеживание ошибок", "Ошибки в приложении", "Frontend Error Monitoring"]
tags: [frontend, monitoring, errors, debugging]
---

# Мониторинг ошибок

Мониторинг ошибок - это критически важный аспект разработки фронтенд-приложений, позволяющий отслеживать, регистрировать и анализировать ошибки, возникающие в браузере пользователя. Эффективный мониторинг ошибок помогает быстро выявлять и устранять проблемы, улучшая пользовательский опыт и стабильность приложения.

## Зачем нужен мониторинг ошибок

- **Быстрое обнаружение проблем**: Позволяет выявлять ошибки в продакшене до того, как пользователи начнут жаловаться
- **Понимание влияния**: Определяет, сколько пользователей затрагивает та или иная ошибка
- **Улучшение качества кода**: Помогает выявлять слабые места в архитектуре и логике приложения
- **Сокращение времени восстановления**: Быстрое реагирование на критические ошибки

## Виды ошибок во фронтенде

### 1. JavaScript ошибки
- Синтаксические ошибки
- Ошибки выполнения
- Ошибки типа (TypeError)
- Ошибки доступа к undefined/null значениям

### 2. Ошибки сети
- Неудачные HTTP-запросы
- Таймауты
- Проблемы с CORS

### 3. Ошибки ресурсов
- Не загружаются изображения
- Ошибки при загрузке скриптов или стилей
- Проблемы с шрифтами

### 4. Ошибки пользовательского интерфейса
- Проблемы с рендерингом
- Ошибки при взаимодействии с DOM
- Проблемы с анимациями

## Инструменты для мониторинга ошибок

### Встроенные механизмы браузера

#### window.onerror
```javascript
window.onerror = function(message, source, lineno, colno, error) {
  console.error('Ошибка JavaScript:', {
    message,
    source,
    lineno,
    colno,
    error
  });
  
  // Отправка ошибки в систему мониторинга
  sendErrorToMonitoring({
    message,
    source,
    lineno,
    colno,
    stack: error?.stack,
    userAgent: navigator.userAgent,
    url: window.location.href
  });
  
  return true; // Предотвращает стандартное поведение
};
```

#### addEventListener('error')
```javascript
window.addEventListener('error', function(event) {
  console.error('Ошибка:', event.error);
  
  sendErrorToMonitoring({
    type: 'js_error',
    message: event.error.message,
    stack: event.error.stack,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });
});
```

#### addEventListener('unhandledrejection')
```javascript
window.addEventListener('unhandledrejection', function(event) {
  console.error('Необработанное обещание:', event.reason);
  
  sendErrorToMonitoring({
    type: 'unhandled_promise_rejection',
    reason: event.reason,
    stack: event.reason?.stack
  });
  
  // Предотвращаем вывод в консоль
  event.preventDefault();
});
```

## Популярные сервисы мониторинга ошибок

### Sentry
Sentry - один из самых популярных сервисов для мониторинга ошибок. Он предоставляет:

- Группировку ошибок
- Подробные трассировки стека
- Контекстные данные (браузер, ОС, пользовательские данные)
- Интеграции с различными фреймворками

```javascript
import * as Sentry from '@sentry/browser';
import { Integrations } from '@sentry/tracing';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  integrations: [
    new Integrations.BrowserTracing(),
  ],
  tracesSampleRate: 1.0,
});

// Отправка пользовательской ошибки
Sentry.captureException(new Error('Произошла пользовательская ошибка'));
```

### Rollbar
```javascript
import Rollbar from 'rollbar';

const rollbar = new Rollbar({
  accessToken: 'YOUR_ROLLBAR_ACCESS_TOKEN',
  captureUncaught: true,
  captureUnhandledRejections: true,
});

// Отправка ошибки
rollbar.error('Произошла ошибка', errorObject);
```

### LogRocket
LogRocket предоставляет не только мониторинг ошибок, но и запись сессий пользователей:

```javascript
import LogRocket from 'logrocket';
LogRocket.init('your-app-id');

// Запись пользовательских действий
LogRocket.captureMessage('Пользователь нажал кнопку');
```

## Создание собственной системы мониторинга

Для небольших проектов или специфических требований можно создать собственную систему мониторинга:

```javascript
class ErrorMonitor {
  constructor(apiEndpoint, options = {}) {
    this.apiEndpoint = apiEndpoint;
    this.options = options;
    this.buffer = [];
    this.maxBufferSize = options.maxBufferSize || 10;
    
    this.setupGlobalHandlers();
  }
  
  setupGlobalHandlers() {
    // Обработка обычных ошибок JavaScript
    window.onerror = (message, source, lineno, colno, error) => {
      this.captureError({
        type: 'javascript_error',
        message,
        source,
        lineno,
        colno,
        stack: error?.stack,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent
      });
      
      return true;
    };
    
    // Обработка необработанных Promise ошибок
    window.addEventListener('unhandledrejection', (event) => {
      this.captureError({
        type: 'unhandled_promise_rejection',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack,
        timestamp: new Date().toISOString(),
        url: window.location.href
      });
    });
  }
  
  captureError(errorData) {
    // Добавляем информацию о пользователе если доступна
    if (window.currentUser) {
      errorData.user = window.currentUser;
    }
    
    // Добавляем в буфер
    this.buffer.push(errorData);
    
    // Отправляем если буфер полон
    if (this.buffer.length >= this.maxBufferSize) {
      this.flush();
    }
    
    // Или отправляем через таймаут
    if (!this.flushTimeout) {
      this.flushTimeout = setTimeout(() => {
        this.flush();
        this.flushTimeout = null;
      }, 1000);
    }
  }
  
  flush() {
    if (this.buffer.length === 0) return;
    
    const errorsToSend = [...this.buffer];
    this.buffer = [];
    
    // Отправляем ошибки на сервер
    fetch(this.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ errors: errorsToSend })
    }).catch(error => {
      console.error('Ошибка при отправке ошибок:', error);
      // Возвращаем ошибки в буфер при неудаче
      this.buffer = [...errorsToSend, ...this.buffer];
    });
  }
}

// Инициализация мониторинга ошибок
const errorMonitor = new ErrorMonitor('/api/errors', {
  maxBufferSize: 5
});
```

## Лучшие практики мониторинга ошибок

### 1. Фильтрация и нормализация ошибок
```javascript
class ErrorFilter {
  constructor() {
    // Список ошибок, которые не нужно отслеживать
    this.ignoredErrors = [
      /Script error/i,
      /ResizeObserver loop limit exceeded/i,
      /Non-Error promise rejection captured with keys/i
    ];
  }
  
  shouldIgnore(error) {
    return this.ignoredErrors.some(pattern => pattern.test(error.message));
  }
  
  normalize(error) {
    // Нормализация сообщений об ошибках для лучшей группировки
    if (error.message.includes('Network Error')) {
      error.normalizedMessage = 'Network Error';
    }
    
    return error;
  }
}
```

### 2. Сбор контекстной информации
```javascript
function getErrorContext() {
  return {
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: new Date().toISOString(),
    referrer: document.referrer,
    viewport: {
      width: window.innerWidth,
      height: window.innerHeight
    },
    connection: navigator.connection ? {
      effectiveType: navigator.connection.effectiveType,
      rtt: navigator.connection.rtt
    } : undefined,
    // Любые другие данные, которые могут быть полезны для диагностики
    appState: window.appState || undefined
  };
}
```

### 3. Управление объемом данных
```javascript
class RateLimiter {
  constructor(maxErrorsPerMinute = 100) {
    this.maxErrorsPerMinute = maxErrorsPerMinute;
    this.errorsInCurrentMinute = 0;
    this.currentMinute = Math.floor(Date.now() / 60000);
    
    setInterval(() => {
      const currentMinute = Math.floor(Date.now() / 60000);
      if (currentMinute !== this.currentMinute) {
        this.errorsInCurrentMinute = 0;
        this.currentMinute = currentMinute;
      }
    }, 1000);
  }
  
  shouldAllowError() {
    if (this.errorsInCurrentMinute < this.maxErrorsPerMinute) {
      this.errorsInCurrentMinute++;
      return true;
    }
    return false;
  }
}
```

## Примеры обработки специфических ошибок

### Ошибки при работе с API
```javascript
async function apiCall(url, options = {}) {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} - ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    // Логируем ошибку с контекстом
    Sentry.captureException(error, {
      contexts: {
        api: {
          url,
          method: options.method || 'GET',
          status: error.status
        }
      }
    });
    
    throw error;
  }
}
```

### Ошибки при загрузке ресурсов
```javascript
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => resolve(img);
    img.onerror = (event) => {
      const error = new Error(`Failed to load image: ${src}`);
      Sentry.captureException(error, {
        contexts: {
          resource: {
            type: 'image',
            src
          }
        }
      });
      reject(error);
    };
    
    img.src = src;
  });
}
```

## Интеграция с фреймворками

### React
```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    Sentry.captureException(error, {
      contexts: {
        react: {
          componentStack: errorInfo.componentStack
        }
      }
    });
  }

  render() {
    if (this.state.hasError) {
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```

### Vue.js
```javascript
Vue.config.errorHandler = function (err, vm, info) {
  // err: error thrown
  // vm: component in which error occurred
  // info: Vue-specific error information (e.g. which lifecycle hook)
  
  Sentry.captureException(err, {
    contexts: {
      vue: {
        component: vm.$options.name,
        info
      }
    }
  });
};
```

## Заключение

Мониторинг ошибок - это неотъемлемая часть разработки качественного фронтенд-приложения. Он позволяет:

- Быстро реагировать на проблемы в продакшене
- Понимать реальный опыт пользователей
- Предотвращать повторение одних и тех же ошибок
- Улучшать стабильность и надежность приложения

При выборе инструмента мониторинга ошибок важно учитывать:

- [[Масштабируемость]] - способность системы обрабатывать большой объем ошибок
- [[Алертинг]] - возможность настройки уведомлений о критических ошибках
- [[Аналитика-использования]] - возможность получения контекста ошибок
- [[Логирование]] - детализация информации об ошибках
- [[Мониторинг-производительности]] - интеграция с системами мониторинга производительности

## См. также
- [[Логирование]]
- [[Алертинг]]
- [[Мониторинг-производительности]]
- [[Аналитика-использования]]