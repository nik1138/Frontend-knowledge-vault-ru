# Наследование

Наследование — это один из основных принципов объектно-ориентированного программирования, при котором один класс (дочерний или подкласс) получает свойства и методы другого класса (родительского или суперкласса). Наследование позволяет создавать новые классы на основе существующих, перенимая их функциональность и расширяя ее.

## Основные характеристики наследования

### Отношение "является"
Наследование выражает отношение "является" между классами. Например, собака является животным, автомобиль является транспортным средством.

### Переиспользование кода
Дочерние классы автоматически получают все свойства и методы родительского класса, что способствует переиспользованию кода.

### Иерархия классов
Наследование создает иерархическую структуру классов, где каждый уровень может добавлять или изменять функциональность.

## Примеры наследования

### В JavaScript
```javascript
// Наследование в JavaScript
class Animal {
  constructor(name, species) {
    this.name = name;
    this.species = species;
  }
  
  speak() {
    console.log(`${this.name} издает звук`);
  }
  
  getInfo() {
    return `${this.name} - ${this.species}`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name, 'Собака'); // Вызов конструктора родительского класса
    this.breed = breed;
  }
  
  // Переопределение метода родительского класса
  speak() {
    console.log(`${this.name} лает`);
  }
  
  // Добавление нового метода
  fetch() {
    console.log(`${this.name} принес палку`);
  }
}

class Cat extends Animal {
  constructor(name, color) {
    super(name, 'Кошка');
    this.color = color;
  }
  
  // Переопределение метода родительского класса
  speak() {
    console.log(`${this.name} мяукает`);
  }
  
  // Добавление нового метода
  purr() {
    console.log(`${this.name} мурлычет`);
  }
}

// Использование
const dog = new Dog('Бобик', 'Овчарка');
const cat = new Cat('Мурка', 'Рыжая');

dog.speak(); // Бобик лает
dog.fetch(); // Бобик принес палку
console.log(dog.getInfo()); // Бобик - Собака

cat.speak(); // Мурка мяукает
cat.purr(); // Мурка мурлычет
console.log(cat.getInfo()); // Мурка - Кошка
```

### В TypeScript
```typescript
// Наследование в TypeScript
abstract class Vehicle {
  protected brand: string;
  protected year: number;
  
  constructor(brand: string, year: number) {
    this.brand = brand;
    this.year = year;
  }
  
  start(): void {
    console.log(`${this.brand} запускается`);
  }
  
  abstract getFuelType(): string;
  
  getInfo(): string {
    return `${this.brand} ${this.year} года, топливо: ${this.getFuelType()}`;
  }
}

class Car extends Vehicle {
  private doors: number;
  
  constructor(brand: string, year: number, doors: number) {
    super(brand, year); // Вызов конструктора родительского класса
    this.doors = doors;
  }
  
  // Реализация абстрактного метода
  getFuelType(): string {
    return 'Бензин';
  }
  
  // Переопределение метода родительского класса
  start(): void {
    console.log(`Автомобиль ${this.brand} заводится ключом`);
  }
  
  // Добавление нового метода
  openTrunk(): void {
    console.log('Багажник открыт');
  }
}

class ElectricCar extends Car {
  private batteryCapacity: number;
  
  constructor(brand: string, year: number, doors: number, batteryCapacity: number) {
    super(brand, year, doors); // Вызов конструктора родительского класса
    this.batteryCapacity = batteryCapacity;
  }
  
  // Переопределение метода родительского класса
  getFuelType(): string {
    return 'Электричество';
  }
  
  // Переопределение метода родительского класса
  start(): void {
    console.log(`Электромобиль ${this.brand} запускается кнопкой`);
  }
  
  // Добавление нового метода
  charge(): void {
    console.log('Автомобиль заряжается');
  }
}

// Использование
const car = new Car('Toyota', 2020, 4);
const electricCar = new ElectricCar('Tesla', 2022, 4, 75);

car.start(); // Автомобиль Toyota заводится ключом
console.log(car.getInfo()); // Toyota 2020 года, топливо: Бензин

electricCar.start(); // Электромобиль Tesla запускается кнопкой
electricCar.charge(); // Автомобиль заряжается
console.log(electricCar.getInfo()); // Tesla 2022 года, топливо: Электричество
```

## Типы наследования

### Одиночное наследование
Класс наследуется от одного родительского класса.

### Множественное наследование
Класс наследуется от нескольких родительских классов. Поддерживается не во всех языках программирования.

### Многоуровневое наследование
Класс наследуется от другого дочернего класса, создавая цепочку наследования.

## Преимущества наследования

### Переиспользование кода
Наследование позволяет повторно использовать код родительских классов, избегая дублирования.

### Расширяемость
Новые функции могут быть легко добавлены через создание подклассов.

### Полиморфизм
Наследование является основой для реализации полиморфизма.

### Моделирование реальных отношений
Наследование позволяет естественным образом моделировать иерархические отношения реального мира.

## Недостатки наследования

### Жесткая связанность
Дочерние классы тесно связаны с родительскими, что может привести к проблемам при изменении родительского класса.

### Сложность иерархии
Слишком глубокая иерархия наследования может усложнить понимание кода.

### Нарушение инкапсуляции
Дочерние классы могут зависеть от деталей реализации родительского класса.

### Проблема хрупкости базового класса
Изменения в родительском классе могут непредсказуемо повлиять на дочерние классы.

## Наследование vs Композиция

### Когда использовать наследование
- Когда существует отношение "является" между классами
- Когда дочерний класс является специализированной версией родительского
- Когда необходимо расширить существующий функционал
- Когда иерархия классов стабильна

### Когда использовать композицию
- Когда отношения выражаются как "имеет"
- Когда необходимо изменять поведение во время выполнения
- Когда нужно избежать жесткой иерархии наследования
- Когда требуется большая гибкость

## Паттерны, использующие наследование

### Шаблонный метод (Template Method)
```javascript
// Шаблонный метод использует наследование
class DataProcessor {
  // Шаблонный метод
  process() {
    this.readData();
    this.processData();
    this.saveData();
  }
  
  readData() {
    console.log('Чтение данных');
  }
  
  processData() {
    // Метод, который должен быть переопределен
    throw new Error('Метод processData должен быть реализован в подклассе');
  }
  
  saveData() {
    console.log('Сохранение данных');
  }
}

class XMLDataProcessor extends DataProcessor {
  // Переопределение метода родительского класса
  processData() {
    console.log('Обработка XML данных');
  }
}

class JSONDataProcessor extends DataProcessor {
  // Переопределение метода родительского класса
  processData() {
    console.log('Обработка JSON данных');
  }
}

// Использование
const xmlProcessor = new XMLDataProcessor();
xmlProcessor.process(); // Чтение данных -> Обработка XML данных -> Сохранение данных

const jsonProcessor = new JSONDataProcessor();
jsonProcessor.process(); // Чтение данных -> Обработка JSON данных -> Сохранение данных
```

### Стратегия (Strategy)
```javascript
// Стратегия может использовать наследование
abstract class SortStrategy {
  abstract sort(data: number[]): number[];
}

class QuickSort extends SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка быстрой сортировкой');
    return [...data].sort((a, b) => a - b);
  }
}

class MergeSort extends SortStrategy {
  sort(data: number[]): number[] {
    console.log('Сортировка сортировкой слиянием');
    return [...data].sort((a, b) => a - b);
  }
}

class Sorter {
  private strategy: SortStrategy;
  
  constructor(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy: SortStrategy) {
    this.strategy = strategy;
  }
  
  sort(data: number[]): number[] {
    return this.strategy.sort(data);
  }
}
```

## Связь с другими концепциями

- [[Объектно-ориентированное программирование]] - Наследование является одним из основных принципов ООП
- [[SOLID]] - Принцип подстановки Барбары Лисков (LSP) связан с наследованием
- [[Полиморфизм]] - Наследование является основой для реализации полиморфизма
- [[Композиция]] - Альтернативный подход к расширению функциональности
- [[DRY (Don't Repeat Yourself)]] - Наследование способствует избеганию дублирования кода

## Применение в современных технологиях

### В [[ts]]
TypeScript поддерживает наследование через:
- Классы и расширение классов
- Абстрактные классы
- Модификаторы доступа для контроля наследования

### В [[js]]
JavaScript поддерживает наследование через:
- Классы (ES6+) и extends
- Прототипное наследование
- super() для вызова методов родительского класса

### В [[react]]
React компоненты использовали наследование в классовых компонентах:
- Component и PureComponent как базовые классы
- Расширение функциональности через наследование

## Теги
#inheritance #oop #programming-concepts #design-principles #software-design