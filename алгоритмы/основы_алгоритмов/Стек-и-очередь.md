---
aliases: ["Стек", "Очередь", "LIFO", "FIFO", "Структуры данных: Стек и Очередь"]
tags: [алгоритмы, структуры-данных, программирование, computer-science, стек, очередь]
---

# Стек и Очередь

## Определение и основы

Стек и очередь — это фундаментальные структуры данных, которые определяют порядок доступа к элементам. Обе структуры широко используются в алгоритмах и системном программировании.

### Стек (Stack)

Стек — это структура данных, работающая по принципу **LIFO** (Last In, First Out) — "последним пришел, первым ушел". Элементы добавляются и удаляются только с одного конца, называемого "вершиной" стека.

#### Основные операции со стеком:
- **push(item)** — добавить элемент на вершину стека
- **pop()** — удалить и вернуть элемент с вершины стека
- **peek()/top()** — посмотреть элемент на вершине стека без удаления
- **isEmpty()** — проверить, пуст ли стек
- **size()** — получить количество элементов в стеке

### Очередь (Queue)

Очередь — это структура данных, работающая по принципу **FIFO** (First In, First Out) — "первым пришел, первым ушел". Элементы добавляются в конец очереди и удаляются из начала.

#### Основные операции с очередью:
- **enqueue(item)** — добавить элемент в конец очереди
- **dequeue()** — удалить и вернуть элемент из начала очереди
- **front()/peek()** — посмотреть элемент в начале очереди без удаления
- **isEmpty()** — проверить, пуста ли очередь
- **size()** — получить количество элементов в очереди

## Реализация стека и очереди

### Реализация стека на массиве

**Псевдокод:**
```
КЛАСС Стек
    ПОЛЕ items // массив для хранения элементов

    КОНСТРУКТОР()
        items ← пустой_массив
    КОНЕЦ КОНСТРУКТОР

    МЕТОД push(элемент)
        ДОБАВИТЬ элемент в конец items
    КОНЕЦ МЕТОД

    МЕТОД pop()
        ЕСЛИ isEmpty() ТОГДА
            ВОЗВРАТ ОШИБКА("Стек пуст")
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ УДАЛИТЬ_И_ВЕРНУТЬ_ПОСЛЕДНИЙ_ЭЛЕМЕНТ(items)
    КОНЕЦ МЕТОД

    МЕТОД peek()
        ЕСЛИ isEmpty() ТОГДА
            ВОЗВРАТ NULL
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ ПОСЛЕДНИЙ_ЭЛЕМЕНТ(items)
    КОНЕЦ МЕТОД

    МЕТОД isEmpty()
        ВОЗВРАТ (длина(items) = 0)
    КОНЕЦ МЕТОД

    МЕТОД size()
        ВОЗВРАТ длина(items)
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(item) {
        this.items.push(item);
    }

    pop() {
        if (this.isEmpty()) {
            throw new Error("Стек пуст");
        }
        return this.items.pop();
    }

    peek() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}
```

### Реализация очереди на массиве

**Псевдокод:**
```
КЛАСС Очередь
    ПОЛЕ items // массив для хранения элементов

    КОНСТРУКТОР()
        items ← пустой_массив
    КОНЕЦ КОНСТРУКТОР

    МЕТОД enqueue(элемент)
        ДОБАВИТЬ элемент в конец items
    КОНЕЦ МЕТОД

    МЕТОД dequeue()
        ЕСЛИ isEmpty() ТОГДА
            ВОЗВРАТ ОШИБКА("Очередь пуста")
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ УДАЛИТЬ_И_ВЕРНУТЬ_ПЕРВЫЙ_ЭЛЕМЕНТ(items)
    КОНЕЦ МЕТОД

    МЕТОД front()
        ЕСЛИ isEmpty() ТОГДА
            ВОЗВРАТ NULL
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ ПЕРВЫЙ_ЭЛЕМЕНТ(items)
    КОНЕЦ МЕТОД

    МЕТОД isEmpty()
        ВОЗВРАТ (длина(items) = 0)
    КОНЕЦ МЕТОД

    МЕТОД size()
        ВОЗВРАТ длина(items)
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(item) {
        this.items.push(item);
    }

    dequeue() {
        if (this.isEmpty()) {
            throw new Error("Очередь пуста");
        }
        return this.items.shift(); // shift() имеет O(n) сложность
    }

    front() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}
```

> [!tip] Оптимизация
> Для эффективной реализации очереди можно использовать два стека или связный список, чтобы избежать O(n) сложности операции dequeue.

### Оптимизированная очередь на двух стеках

**Псевдокод:**
```
КЛАСС ОптимизированнаяОчередь
    ПОЛЕ inStack // стек для добавления элементов
    ПОЛЕ outStack // стек для извлечения элементов

    КОНСТРУКТОР()
        inStack ← НОВЫЙ Стек()
        outStack ← НОВЫЙ Стек()
    КОНЕЦ КОНСТРУКТОР

    МЕТОД enqueue(элемент)
        inStack.push(элемент)
    КОНЕЦ МЕТОД

    МЕТОД dequeue()
        ЕСЛИ outStack.isEmpty() ТОГДА
            ПОКА !inStack.isEmpty()
                outStack.push(inStack.pop())
            КОНЕЦ ПОКА
        КОНЕЦ ЕСЛИ

        ЕСЛИ outStack.isEmpty() ТОГДА
            ВОЗВРАТ ОШИБКА("Очередь пуста")
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ outStack.pop()
    КОНЕЦ МЕТОД

    МЕТОД front()
        ЕСЛИ outStack.isEmpty() ТОГДА
            ПОКА !inStack.isEmpty()
                outStack.push(inStack.pop())
            КОНЕЦ ПОКА
        КОНЕЦ ЕСЛИ

        ЕСЛИ outStack.isEmpty() ТОГДА
            ВОЗВРАТ NULL
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ outStack.peek()
    КОНЕЦ МЕТОД

    МЕТОД isEmpty()
        ВОЗВРАТ (inStack.isEmpty() И outStack.isEmpty())
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class OptimizedQueue {
    constructor() {
        this.inStack = new Stack();
        this.outStack = new Stack();
    }

    enqueue(item) {
        this.inStack.push(item);
    }

    dequeue() {
        if (this.outStack.isEmpty()) {
            while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }

        if (this.outStack.isEmpty()) {
            throw new Error("Очередь пуста");
        }

        return this.outStack.pop();
    }

    front() {
        if (this.outStack.isEmpty()) {
            while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }

        if (this.outStack.isEmpty()) {
            return null;
        }

        return this.outStack.peek();
    }

    isEmpty() {
        return this.inStack.isEmpty() && this.outStack.isEmpty();
    }
}
```

## Применение стека

### 1. Обработка вызовов функций

Стек вызовов (call stack) используется для отслеживания активных функций в программе. Каждый вызов функции добавляется в стек, а по завершении — удаляется.

### 2. Обратная польская нотация

Стек используется для вычисления выражений в обратной польской нотации:
**Псевдокод:**
```
АЛГОРИТМ evaluateRPN(токены)
НАЧАЛО
    стек ← НОВЫЙ Стек()

    ДЛЯ каждый токен в токены
        ЕСЛИ токен в ['+', '-', '*', '/'] ТОГДА
            b ← стек.pop()
            a ← стек.pop()

            ВЫБОР токен
                СЛУЧАЙ '+': стек.push(a + b)
                СЛУЧАЙ '-': стек.push(a - b)
                СЛУЧАЙ '*': стек.push(a * b)
                СЛУЧАЙ '/': стек.push(ОКРУГЛИТЬ(a / b))
            КОНЕЦ ВЫБОР
        ИНАЧЕ
            стек.push(ПРЕОБРАЗОВАТЬ_В_ЧИСЛО(токен))
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ стек.pop()
КОНЕЦ
```

**JavaScript:**
```javascript
function evaluateRPN(tokens) {
    const stack = new Stack();

    for (const token of tokens) {
        if (['+', '-', '*', '/'].includes(token)) {
            const b = stack.pop();
            const a = stack.pop();

            switch (token) {
                case '+': stack.push(a + b); break;
                case '-': stack.push(a - b); break;
                case '*': stack.push(a * b); break;
                case '/': stack.push(Math.trunc(a / b)); break;
            }
        } else {
            stack.push(parseInt(token));
        }
    }

    return stack.pop();
}
```

### 3. Проверка сбалансированных скобок

**Псевдокод:**
```
АЛГОРИТМ isBalancedBrackets(выражение)
НАЧАЛО
    стек ← НОВЫЙ Стек()
    скобки ← СЛОВАРЬ { '(': ')', '[': ']', '{': '}' }

    ДЛЯ каждый символ в выражение
        ЕСЛИ символ в скобки ТОГДА
            стек.push(символ)
        ИНАЧЕ ЕСЛИ символ в значения(скобки) ТОГДА
            ЕСЛИ стек.isEmpty() ИЛИ скобки[стек.pop()] ≠ символ ТОГДА
                ВОЗВРАТ ЛОЖЬ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ стек.isEmpty()
КОНЕЦ
```

**JavaScript:**
```javascript
function isBalancedBrackets(expression) {
    const stack = new Stack();
    const brackets = {
        '(': ')',
        '[': ']',
        '{': '}'
    };

    for (const char of expression) {
        if (brackets[char]) {
            stack.push(char);
        } else if (Object.values(brackets).includes(char)) {
            if (stack.isEmpty() || brackets[stack.pop()] !== char) {
                return false;
            }
        }
    }

    return stack.isEmpty();
}
```

### 4. Обход дерева в глубину (DFS)

Стек используется для реализации DFS без рекурсии:
**Псевдокод:**
```
АЛГОРИТМ dfsIterative(граф, старт)
НАЧАЛО
    стек ← НОВЫЙ Стек()
    посещенные ← НОВОЕ МНОЖЕСТВО()

    стек.push(старт)

    ПОКА !стек.isEmpty()
        узел ← стек.pop()

        ЕСЛИ !посещенные.содержит(узел) ТОГДА
            посещенные.добавить(узел)
            ВЫВОД узел

            // Добавляем соседей в стек
            ДЛЯ каждый сосед в граф[узел] || []
                ЕСЛИ !посещенные.содержит(сосед) ТОГДА
                    стек.push(сосед)
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
КОНЕЦ
```

**JavaScript:**
```javascript
function dfsIterative(graph, start) {
    const stack = new Stack();
    const visited = new Set();

    stack.push(start);

    while (!stack.isEmpty()) {
        const node = stack.pop();

        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);

            // Добавляем соседей в стек
            for (const neighbor of graph[node] || []) {
                if (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
}
```

## Применение очереди

### 1. Обход дерева в ширину (BFS)

Очередь используется для реализации BFS:
**Псевдокод:**
```
АЛГОРИТМ bfs(граф, старт)
НАЧАЛО
    очередь ← НОВАЯ Очередь()
    посещенные ← НОВОЕ МНОЖЕСТВО()

    очередь.enqueue(старт)
    посещенные.добавить(старт)

    ПОКА !очередь.isEmpty()
        узел ← очередь.dequeue()
        ВЫВОД узел

        ДЛЯ каждый сосед в граф[узел] || []
            ЕСЛИ !посещенные.содержит(сосед) ТОГДА
                посещенные.добавить(сосед)
                очередь.enqueue(сосед)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ПОКА
КОНЕЦ
```

**JavaScript:**
```javascript
function bfs(graph, start) {
    const queue = new Queue();
    const visited = new Set();

    queue.enqueue(start);
    visited.add(start);

    while (!queue.isEmpty()) {
        const node = queue.dequeue();
        console.log(node);

        for (const neighbor of graph[node] || []) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.enqueue(neighbor);
            }
        }
    }
}
```

### 2. Потоковое шифрование

Очередь может использоваться для реализации систем потоковой передачи данных, где элементы обрабатываются в порядке поступления.

### 3. Управление задачами

Очередь используется для планирования задач в операционных системах и приложениях.

## Сложность операций

| Структура | Push/Enqueue | Pop/Dequeue | Peek | Память |
|-----------|--------------|-------------|------|--------|
| Стек (на массиве) | O(1) | O(1) | O(1) | O(n) |
| Очередь (на массиве) | O(1) | O(n) | O(1) | O(n) |
| Очередь (на 2 стеках) | O(1) амортизированно | O(1) амортизированно | O(1) | O(n) |

## Сравнение стека и очереди

| Характеристика | Стек | Очередь |
|----------------|------|---------|
| Принцип доступа | LIFO | FIFO |
| Основные операции | push, pop | enqueue, dequeue |
| Использование | Вызовы функций, DFS | Планирование задач, BFS |
| Пример из жизни | Стек тарелок | Очередь в магазине |

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют стек и очередь в различных системах:

- **[[Яндекс]]** применяет стеки для обработки поисковых запросов, анализа сессий пользователей и реализации алгоритмов обхода графов
- **[[Сбер]]** использует очереди для обработки финансовых транзакций, систем мессенджинга и асинхронной обработки данных
- **[[VK]]** применяет стеки и очереди для обработки социальных событий, обхода социальных графов и управления задачами
- **[[Т-Платформы]]** и другие отечественные разработчики используют эти структуры в системах управления ресурсами и обработки данных

Особое внимание уделяется оптимизации этих структур для эффективного использования вычислительных ресурсов, где важна эффективность использования памяти и процессорного времени.

## Практические рекомендации

1. **Выбирайте правильную структуру** — стек для LIFO-сценариев, очередь для FIFO-сценариев
2. **Учитывайте производительность** — используйте оптимизированные реализации для критичных по производительности участков
3. **Обрабатывайте граничные случаи** — проверяйте пустоту стека/очереди перед операциями
4. **Используйте встроенные структуры** — в некоторых языках есть встроенные эффективные реализации
5. **Рассмотрите двустороннюю очередь (deque)** — если нужны операции с обеих сторон

## Связанные темы

- [[Деревья-и-графы]] — стек и очередь используются для обхода деревьев и графов
- [[Поиск-и-обход]] — алгоритмы поиска используют стек и очередь
- [[Структуры-данных]] — другие фундаментальные структуры данных

## Ключевые выводы

- Стек и очередь — базовые структуры данных с разными принципами доступа к элементам
- Эти структуры широко используются в алгоритмах и системном программировании
- Знание этих структур критически важно для разработки эффективных систем
- Понимание сложности операций помогает выбирать оптимальные реализации для конкретных задач

#алгоритмы #стек #очередь #структуры-данных #программирование #computer-science