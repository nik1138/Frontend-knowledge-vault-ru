---
aliases: ["Алгоритмы сортировки", "Методы сортировки", "Сортировка массивов"]
tags: [алгоритмы, сортировка, программирование, computer-science, эффективность]
---

# Сортировка и упорядочивание

## Определение и основы

Сортировка — это процесс упорядочивания элементов в последовательности по заданному критерию. Это одна из фундаментальных задач в компьютерных науках, с которой сталкивается каждый разработчик. Сортировка используется как самостоятельная операция и как вспомогательная процедура для других алгоритмов.

## Классификация алгоритмов сортировки

Алгоритмы сортировки можно классифицировать по нескольким критериям:

### По временной сложности:
- **Квадратичные** (O(n²)): сортировка пузырьком, выбором, вставками
- **Линейитмические** (O(n log n)): быстрая сортировка, сортировка слиянием, пирамидальная
- **Линейные** (O(n)): подсчетом, поразрядная, блочная (при определенных условиях)

### По использованию дополнительной памяти:
- **Сортировки на месте** (in-place): используют O(1) дополнительной памяти
- **Сортировки не на месте**: требуют дополнительной памяти для временного хранения данных

### По устойчивости:
- **Устойчивые** (stable): сохраняют относительный порядок элементов с одинаковыми ключами
- **Неустойчивые** (unstable): могут изменить порядок элементов с одинаковыми ключами

## Популярные алгоритмы сортировки

### 1. Сортировка пузырьком

Самый простой алгоритм, но наименее эффективный для больших массивов. Сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.

**Псевдокод:**
```
АЛГОРИТМ bubbleSort(массив)
НАЧАЛО
    n ← длина(массив)
    ДЛЯ i ОТ 0 ДО n - 2
        ДЛЯ j ОТ 0 ДО n - i - 2
            ЕСЛИ массив[j] > массив[j + 1] ТОГДА
                ПОМЕНЯТЬ_МЕСТАМИ(массив[j], массив[j + 1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ
    ВОЗВРАТ массив
КОНЕЦ

// Временная сложность: O(n²)
// Пространственная сложность: O(1)
// Устойчивая: Да
```

**JavaScript:**
```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Меняем местами
            }
        }
    }
    return arr;
}

// Временная сложность: O(n²)
// Пространственная сложность: O(1)
// Устойчивая: Да
```

### 2. Сортировка выбором

На каждом шаге находит минимальный элемент из неотсортированной части массива и помещает его в начало.

**Псевдокод:**
```
АЛГОРИТМ selectionSort(массив)
НАЧАЛО
    n ← длина(массив)
    ДЛЯ i ОТ 0 ДО n - 2
        minIdx ← i
        ДЛЯ j ОТ i + 1 ДО n - 1
            ЕСЛИ массив[j] < массив[minIdx] ТОГДА
                minIdx ← j
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
        ПОМЕНЯТЬ_МЕСТАМИ(массив[i], массив[minIdx])
    КОНЕЦ ДЛЯ
    ВОЗВРАТ массив
КОНЕЦ

// Временная сложность: O(n²)
// Пространственная сложность: O(1)
// Устойчивая: Нет
```

**JavaScript:**
```javascript
function selectionSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        let minIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
    }
    return arr;
}

// Временная сложность: O(n²)
// Пространственная сложность: O(1)
// Устойчивая: Нет
```

### 3. Сортировка вставками

Строит отсортированную последовательность по одному элементу за раз, вставляя каждый новый элемент на свое место.

**Псевдокод:**
```
АЛГОРИТМ insertionSort(массив)
НАЧАЛО
    ДЛЯ i ОТ 1 ДО длина(массив) - 1
        ключ ← массив[i]
        j ← i - 1

        ПОКА j >= 0 И массив[j] > ключ
            массив[j + 1] ← массив[j]
            j ← j - 1
        КОНЕЦ ПОКА
        массив[j + 1] ← ключ
    КОНЕЦ ДЛЯ
    ВОЗВРАТ массив
КОНЕЦ

// Временная сложность: O(n²) в худшем случае, O(n) в лучшем
// Пространственная сложность: O(1)
// Устойчивая: Да
```

**JavaScript:**
```javascript
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}

// Временная сложность: O(n²) в худшем случае, O(n) в лучшем
// Пространственная сложность: O(1)
// Устойчивая: Да
```

### 4. Быстрая сортировка (QuickSort)

Алгоритм "разделяй и властвуй". Выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше или равны опорному.

**Псевдокод:**
```
АЛГОРИТМ quickSort(массив, низ = 0, высок = длина(массив) - 1)
НАЧАЛО
    ЕСЛИ низ < высок ТОГДА
        pi ← partition(массив, низ, высок)
        quickSort(массив, низ, pi - 1)
        quickSort(массив, pi + 1, высок)
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ массив
КОНЕЦ

АЛГОРИТМ partition(массив, низ, высок)
НАЧАЛО
    опора ← массив[высок] // Опорный элемент
    i ← низ - 1 // Индекс меньшего элемента

    ДЛЯ j ОТ низ ДО высок - 1
        ЕСЛИ массив[j] < опора ТОГДА
            i ← i + 1
            ПОМЕНЯТЬ_МЕСТАМИ(массив[i], массив[j])
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ
    ПОМЕНЯТЬ_МЕСТАМИ(массив[i + 1], массив[высок])
    ВОЗВРАТ i + 1
КОНЕЦ

// Временная сложность: O(n log n) в среднем, O(n²) в худшем
// Пространственная сложность: O(log n) из-за рекурсии
// Устойчивая: Нет
```

**JavaScript:**
```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high]; // Опорный элемент
    let i = low - 1; // Индекс меньшего элемента

    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Временная сложность: O(n log n) в среднем, O(n²) в худшем
// Пространственная сложность: O(log n) из-за рекурсии
// Устойчивая: Нет
```

### 5. Сортировка слиянием (MergeSort)

Также алгоритм "разделяй и властвуй". Разделяет массив на две половины, рекурсивно сортирует каждую, а затем сливает отсортированные половины.

**Псевдокод:**
```
АЛГОРИТМ mergeSort(массив)
НАЧАЛО
    ЕСЛИ длина(массив) <= 1 ТОГДА
        ВОЗВРАТ массив
    КОНЕЦ ЕСЛИ

    середина ← ОКРУГЛИТЬ(длина(массив) / 2)
    левый ← mergeSort(СРЕЗ(массив, 0, середина))
    правый ← mergeSort(СРЕЗ(массив, середина, длина(массив)))

    ВОЗВРАТ merge(левый, правый)
КОНЕЦ

АЛГОРИТМ merge(левый, правый)
НАЧАЛО
    результат ← пустой_массив
    левый_индекс ← 0
    правый_индекс ← 0

    ПОКА левый_индекс < длина(левый) И правый_индекс < длина(правый)
        ЕСЛИ левый[левый_индекс] < правый[правый_индекс] ТОГДА
            ДОБАВИТЬ левый[левый_индекс] в результат
            левый_индекс ← левый_индекс + 1
        ИНАЧЕ
            ДОБАВИТЬ правый[правый_индекс] в результат
            правый_индекс ← правый_индекс + 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА

    // Добавляем оставшиеся элементы
    ПОКА левый_индекс < длина(левый)
        ДОБАВИТЬ левый[левый_индекс] в результат
        левый_индекс ← левый_индекс + 1
    КОНЕЦ ПОКА

    ПОКА правый_индекс < длина(правый)
        ДОБАВИТЬ правый[правый_индекс] в результат
        правый_индекс ← правый_индекс + 1
    КОНЕЦ ПОКА

    ВОЗВРАТ результат
КОНЕЦ

// Временная сложность: O(n log n) во всех случаях
// Пространственная сложность: O(n)
// Устойчивая: Да
```

**JavaScript:**
```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }

    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));

    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    let leftIdx = 0;
    let rightIdx = 0;

    while (leftIdx < left.length && rightIdx < right.length) {
        if (left[leftIdx] < right[rightIdx]) {
            result.push(left[leftIdx]);
            leftIdx++;
        } else {
            result.push(right[rightIdx]);
            rightIdx++;
        }
    }

    return result
        .concat(left.slice(leftIdx))
        .concat(right.slice(rightIdx));
}

// Временная сложность: O(n log n) во всех случаях
// Пространственная сложность: O(n)
// Устойчивая: Да
```

### 6. Пирамидальная сортировка (HeapSort)

Использует структуру данных "куча" для сортировки. Сначала строит максимальную кучу, затем многократно извлекает максимальный элемент и перестраивает кучу.

**Псевдокод:**
```
АЛГОРИТМ heapSort(массив)
НАЧАЛО
    n ← длина(массив)

    // Построение кучи
    ДЛЯ i ОТ ОКРУГЛИТЬ(n / 2) - 1 ДО 0 ШАГ -1
        heapify(массив, n, i)
    КОНЕЦ ДЛЯ

    // Извлечение элементов из кучи
    ДЛЯ i ОТ n - 1 ДО 1 ШАГ -1
        ПОМЕНЯТЬ_МЕСТАМИ(массив[0], массив[i]) // Перемещаем текущий максимум в конец
        heapify(массив, i, 0) // Восстанавливаем кучу
    КОНЕЦ ДЛЯ

    ВОЗВРАТ массив
КОНЕЦ

АЛГОРИТМ heapify(массив, n, i)
НАЧАЛО
    наибольший ← i
    левый ← 2 * i + 1
    правый ← 2 * i + 2

    ЕСЛИ левый < n И массив[левый] > массив[наибольший] ТОГДА
        наибольший ← левый
    КОНЕЦ ЕСЛИ

    ЕСЛИ правый < n И массив[правый] > массив[наибольший] ТОГДА
        наибольший ← правый
    КОНЕЦ ЕСЛИ

    ЕСЛИ наибольший ≠ i ТОГДА
        ПОМЕНЯТЬ_МЕСТАМИ(массив[i], массив[наибольший])
        heapify(массив, n, наибольший)
    КОНЕЦ ЕСЛИ
КОНЕЦ

// Временная сложность: O(n log n) во всех случаях
// Пространственная сложность: O(1)
// Устойчивая: Нет
```

**JavaScript:**
```javascript
function heapSort(arr) {
    const n = arr.length;

    // Построение кучи
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Извлечение элементов из кучи
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]]; // Перемещаем текущий максимум в конец
        heapify(arr, i, 0); // Восстанавливаем кучу
    }

    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    let left = 2 * i + 1;
    let right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}

// Временная сложность: O(n log n) во всех случаях
// Пространственная сложность: O(1)
// Устойчивая: Нет
```

## Сравнение алгоритмов сортировки

| Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Устойчивость | Примечание |
|----------|---------------|----------------|---------------|--------|--------------|------------|
| Пузырьком | O(n) | O(n²) | O(n²) | O(1) | Да | Прост, но неэффективен |
| Выбором | O(n²) | O(n²) | O(n²) | O(1) | Нет | Прост, неэффективен |
| Вставками | O(n) | O(n²) | O(n²) | O(1) | Да | Хорош для малых массивов |
| Быстрая | O(n log n) | O(n log n) | O(n²) | O(log n) | Нет | На практике очень быстра |
| Слиянием | O(n log n) | O(n log n) | O(n log n) | O(n) | Да | Гарантированная эффективность |
| Пирамидальная | O(n log n) | O(n log n) | O(n log n) | O(1) | Нет | Гарантированная эффективность |

## Практические рекомендации по выбору алгоритма

### Для малых массивов (< 50 элементов):
- Сортировка вставками часто быстрее, чем более сложные алгоритмы из-за низкой константы

### Для средних и больших массивов:
- Быстрая сортировка: в большинстве случаев самая быстрая, но с риском O(n²) в худшем случае
- Сортировка слиянием: стабильная производительность, гарантия O(n log n), устойчивая
- Пирамидальная сортировка: гарантия O(n log n), минимальное использование памяти

### Когда важна устойчивость:
- Сортировка слиянием или сортировка вставками

### Когда важна экономия памяти:
- Пирамидальная сортировка или быстрая сортировка

## Специальные алгоритмы сортировки

### Поразрядная сортировка (Radix Sort)

Сортирует числа по разрядам, начиная с младшего. Эффективна для целых чисел с ограниченным диапазоном.

**Псевдокод:**
```
АЛГОРИТМ radixSort(массив)
НАЧАЛО
    ЕСЛИ длина(массив) = 0 ТОГДА
        ВОЗВРАТ массив
    КОНЕЦ ЕСЛИ

    maxNum ← МАКС(массив)
    exp ← 1

    ПОКА ОКРУГЛИТЬВНИЗ(maxNum / exp) > 0
        countingSortByDigit(массив, exp)
        exp ← exp * 10
    КОНЕЦ ПОКА

    ВОЗВРАТ массив
КОНЕЦ

АЛГОРИТМ countingSortByDigit(массив, exp)
НАЧАЛО
    вывод ← МАССИВ_РАЗМЕРА(длина(массив))
    count ← МАССИВ_РАЗМЕРА(10) заполнить 0

    // Подсчет количества элементов для каждой цифры
    ДЛЯ i ОТ 0 ДО длина(массив) - 1
        индекс ← ОКРУГЛИТЬВНИЗ(массив[i] / exp) % 10
        count[индекс] ← count[индекс] + 1
    КОНЕЦ ДЛЯ

    // Преобразование count в позиции
    ДЛЯ i ОТ 1 ДО 9
        count[i] ← count[i] + count[i - 1]
    КОНЕЦ ДЛЯ

    // Построение выходного массива
    ДЛЯ i ОТ длина(массив) - 1 ДО 0 ШАГ -1
        индекс ← ОКРУГЛИТЬВНИЗ(массив[i] / exp) % 10
        вывод[count[индекс] - 1] ← массив[i]
        count[индекс] ← count[индекс] - 1
    КОНЕЦ ДЛЯ

    // Копирование выходного массива в исходный
    ДЛЯ i ОТ 0 ДО длина(массив) - 1
        массив[i] ← вывод[i]
    КОНЕЦ ДЛЯ
КОНЕЦ

// Временная сложность: O(d * (n + k)), где d - количество разрядов, k - основание системы счисления
```

**JavaScript:**
```javascript
function radixSort(arr) {
    if (arr.length === 0) return arr;

    const maxNum = Math.max(...arr);
    let exp = 1;

    while (Math.floor(maxNum / exp) > 0) {
        countingSortByDigit(arr, exp);
        exp *= 10;
    }

    return arr;
}

function countingSortByDigit(arr, exp) {
    const output = new Array(arr.length);
    const count = new Array(10).fill(0);

    // Подсчет количества элементов для каждой цифры
    for (let i = 0; i < arr.length; i++) {
        count[Math.floor(arr[i] / exp) % 10]++;
    }

    // Преобразование count в позиции
    for (let i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // Построение выходного массива
    for (let i = arr.length - 1; i >= 0; i--) {
        output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];
        count[Math.floor(arr[i] / exp) % 10]--;
    }

    // Копирование выходного массива в исходный
    for (let i = 0; i < arr.length; i++) {
        arr[i] = output[i];
    }
}

// Временная сложность: O(d * (n + k)), где d - количество разрядов, k - основание системы счисления
```

### Сортировка подсчетом (Counting Sort)

Используется, когда известен ограниченный диапазон значений. Подсчитывает количество вхождений каждого значения.

**Псевдокод:**
```
АЛГОРИТМ countingSort(массив, maxValue)
НАЧАЛО
    counts ← МАССИВ_РАЗМЕРА(maxValue + 1) заполнить 0
    вывод ← пустой_массив

    // Подсчет количества вхождений
    ДЛЯ каждый num в массив
        counts[num] ← counts[num] + 1
    КОНЕЦ ДЛЯ

    // Восстановление отсортированного массива
    ДЛЯ i ОТ 0 ДО длина(counts) - 1
        ДЛЯ j ОТ 0 ДО counts[i] - 1
            ДОБАВИТЬ i в вывод
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ вывод
КОНЕЦ

// Временная сложность: O(n + k), где k - диапазон значений
```

**JavaScript:**
```javascript
function countingSort(arr, maxValue) {
    const counts = new Array(maxValue + 1).fill(0);
    const output = [];

    // Подсчет количества вхождений
    for (const num of arr) {
        counts[num]++;
    }

    // Восстановление отсортированного массива
    for (let i = 0; i < counts.length; i++) {
        for (let j = 0; j < counts[i]; j++) {
            output.push(i);
        }
    }

    return output;
}

// Временная сложность: O(n + k), где k - диапазон значений
```

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют алгоритмы сортировки в различных системах:

- **[[Яндекс]]** применяет оптимизированные алгоритмы сортировки для обработки поисковых результатов, сортировки рекомендаций и анализа данных
- **[[Сбер]]** использует сортировки для обработки транзакций, анализа финансовых данных и систем машинного обучения
- **[[VK]]** применяет алгоритмы сортировки для сортировки новостных лент, социальных рекомендаций и медиа-контента
- **[[Т-Платформы]]** и другие отечественные разработчики используют сортировки в системах анализа данных и оптимизации

Особое внимание уделяется оптимизации алгоритмов для эффективной обработки больших объемов данных.

## Практические рекомендации

1. **Используйте встроенные методы сортировки** — в большинстве языков программирования реализованы эффективные алгоритмы (например, Timsort в Python, Introsort в C++)
2. **Учитывайте тип данных** — для чисел могут подойти специализированные алгоритмы (поразрядная сортировка)
3. **Оценивайте объем данных** — для малых массивов простые алгоритмы могут быть эффективнее
4. **Рассмотрите устойчивость** — если важен порядок равных элементов, выбирайте устойчивые алгоритмы
5. **Тестируйте производительность** — реальная производительность может отличаться от теоретической

## Ключевые выводы

- Сортировка — одна из фундаментальных задач в программировании
- Выбор алгоритма зависит от требований к производительности, памяти и устойчивости
- Знание алгоритмов сортировки особенно важно из-за необходимости оптимизации
- Понимание различных алгоритмов позволяет выбирать наиболее подходящий для конкретной задачи

#алгоритмы #сортировка #программирование #computer-science #эффективность