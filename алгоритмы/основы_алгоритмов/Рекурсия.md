---
aliases: ["Рекурсивные функции", "Рекурсивные алгоритмы", "Рекурсивное программирование"]
tags: [алгоритмы, рекурсия, программирование, computer-science, функциональное-программирование]
---

# Рекурсия

## Определение и основы

Рекурсия — это метод программирования, при котором функция вызывает саму себя для решения задачи. Рекурсивная функция состоит из двух основных компонентов:
- **Базовый случай** — условие, при котором рекурсия прекращается
- **Рекурсивный случай** — вызов функции с измененными параметрами, приближающими к базовому случаю

Рекурсия особенно полезна для решения задач, которые можно разбить на аналогичные, но более мелкие подзадачи. Это естественный способ решения многих математических и алгоритмических задач.

## Структура рекурсивной функции

**Псевдокод:**
```
АЛГОРИТМ РекурсивнаяФункция(параметры)
НАЧАЛО
    ЕСЛИ условие_базового_случая ТОГДА
        ВОЗВРАТ базовое_значение
    ИНАЧЕ
        ВОЗВРАТ РекурсивнаяФункция(измененные_параметры)
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

**JavaScript:**
```javascript
function recursiveFunction(parameters) {
    // Базовый случай - условие остановки рекурсии
    if (baseCaseCondition) {
        return baseValue;
    }

    // Рекурсивный случай - вызов функции с измененными параметрами
    return recursiveFunction(modifiedParameters);
}
```

## Примеры рекурсивных алгоритмов

### 1. Вычисление факториала

**Псевдокод:**
```
АЛГОРИТМ Факториал(n)
НАЧАЛО
    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ 1
    ИНАЧЕ
        ВОЗВРАТ n * Факториал(n - 1)
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

**JavaScript:**
```javascript
function factorial(n) {
    // Базовый случай
    if (n <= 1) {
        return 1;
    }
    // Рекурсивный случай
    return n * factorial(n - 1);
}

// Пример использования
console.log(factorial(5)); // 120
```

**Сложность**: 
- Временная: O(n)
- Пространственная: O(n) из-за глубины стека вызовов

### 2. Числа Фибоначчи

**Псевдокод:**
```
АЛГОРИТМ Фибоначчи(n)
НАЧАЛО
    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ n
    ИНАЧЕ
        ВОЗВРАТ Фибоначчи(n - 1) + Фибоначчи(n - 2)
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

**JavaScript:**
```javascript
function fibonacci(n) {
    // Базовые случаи
    if (n <= 1) {
        return n;
    }
    // Рекурсивный случай
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Пример использования
console.log(fibonacci(10)); // 55
```

**Сложность**: 
- Временная: O(2ⁿ) - неэффективная реализация
- Пространственная: O(n) - глубина стека

> [!warning] Важно
> Наивная рекурсивная реализация чисел Фибоначчи крайне неэффективна. См. [[Динамическое-программирование]] для оптимизированных подходов.

### 3. Обход дерева

**Псевдокод:**
```
АЛГОРИТМ ЦентрированныйОбход(узел)
НАЧАЛО
    ЕСЛИ узел = NULL ТОГДА
        ВОЗВРАТ
    КОНЕЦ ЕСЛИ

    ЦентрированныйОбход(узел.левый);   // Обход левого поддерева
    ВЫВОД узел.значение;               // Обработка текущего узла
    ЦентрированныйОбход(узел.правый);  // Обход правого поддерева
КОНЕЦ
```

**JavaScript:**
```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

function inorderTraversal(node) {
    if (node === null) {
        return;
    }

    inorderTraversal(node.left);   // Обход левого поддерева
    console.log(node.value);       // Обработка текущего узла
    inorderTraversal(node.right);  // Обход правого поддерева
}
```

### 4. Быстрая сортировка (QuickSort)

**Псевдокод:**
```
АЛГОРИТМ БыстраяСортировка(массив)
НАЧАЛО
    ЕСЛИ длина(массив) <= 1 ТОГДА
        ВОЗВРАТ массив
    КОНЕЦ ЕСЛИ

    опора ← массив[длина(массив) / 2]
    левый ← [] // элементы меньше опоры
    средний ← [] // элементы равные опоре
    правый ← [] // элементы больше опоры

    ДЛЯ каждый элемент в массив
        ЕСЛИ элемент < опора ТОГДА
            ДОБАВИТЬ элемент в левый
        ИНАЧЕ ЕСЛИ элемент = опора ТОГДА
            ДОБАВИТЬ элемент в средний
        ИНАЧЕ
            ДОБАВИТЬ элемент в правый
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ объединить(
        БыстраяСортировка(левый),
        средний,
        БыстраяСортировка(правый)
    )
КОНЕЦ
```

**JavaScript:**
```javascript
function quickSort(arr) {
    // Базовый случай
    if (arr.length <= 1) {
        return arr;
    }

    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);

    // Рекурсивные вызовы для подмассивов
    return [
        ...quickSort(left),
        ...middle,
        ...quickSort(right)
    ];
}
```

## Преимущества рекурсии

1. **Читаемость** — рекурсивные решения часто более интуитивно понятны
2. **Элегантность** — некоторые задачи естественно выражаются через рекурсию
3. **Соответствие математическому определению** — многие математические функции определены рекурсивно
4. **Естественность для древовидных структур** — идеально подходит для работы с деревьями и графами

## Недостатки рекурсии

1. **Потребление памяти** — каждый рекурсивный вызов добавляет новый фрейм в стек
2. **Переполнение стека** — при большой глубине рекурсии возможен Stack Overflow
3. **Производительность** — в некоторых случаях рекурсивные решения менее эффективны
4. **Сложность отладки** — труднее отслеживать выполнение рекурсивных функций

## Оптимизации рекурсии

### 1. Хвостовая рекурсия

**Псевдокод:**
```
АЛГОРИТМ ФакториалХвостовой(n, аккумулятор = 1)
НАЧАЛО
    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ аккумулятор
    ИНАЧЕ
        ВОЗВРАТ ФакториалХвостовой(n - 1, n * аккумулятор)
    КОНЕЦ ЕСЛИ
КОНЕЦ
```

**JavaScript:**
```javascript
function factorialTailRecursive(n, accumulator = 1) {
    if (n <= 1) {
        return accumulator;
    }
    return factorialTailRecursive(n - 1, n * accumulator);
}
```

В некоторых языках (но не в JavaScript до ES6) хвостовая рекурсия может быть оптимизирована компилятором.

### 2. Мемоизация

**Псевдокод:**
```
АЛГОРИТМ ФибоначчиМемо(n, мемо = пустой_словарь)
НАЧАЛО
    ЕСЛИ n в мемо ТОГДА
        ВОЗВРАТ мемо[n]
    КОНЕЦ ЕСЛИ

    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ n
    КОНЕЦ ЕСЛИ

    мемо[n] ← ФибоначчиМемо(n - 1, мемо) + ФибоначчиМемо(n - 2, мемо)
    ВОЗВРАТ мемо[n]
КОНЕЦ
```

**JavaScript:**
```javascript
function fibonacciMemo(n, memo = {}) {
    if (n in memo) {
        return memo[n];
    }

    if (n <= 1) {
        return n;
    }

    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}
```

### 3. Преобразование в итерацию

```javascript
function factorialIterative(n) {
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

## Рекурсия в современной ИТ-индустрии

Современные IT-компании активно используют рекурсивные алгоритмы в различных областях:

- **[[Яндекс]]** применяет рекурсивные алгоритмы для обработки иерархических данных, поиска в глубину для графов и анализа структур данных
- **[[Сбер]]** использует рекурсивные подходы в системах обработки финансовых транзакций и анализа сложных иерархических структур
- **[[VK]]** применяет рекурсию для работы с социальными графами и древовидными структурами данных
- **[[Т-Платформы]]** и другие отечественные разработчики используют рекурсивные алгоритмы в системах анализа данных и обработки сложных структур

Особое внимание уделяется оптимизации рекурсивных алгоритмов для эффективного использования вычислительных ресурсов.

## Практические рекомендации

1. **Всегда определяйте базовый случай** — без него рекурсия будет бесконечной
2. **Убедитесь, что рекурсия приближается к базовому случаю** — каждый вызов должен уменьшать проблему
3. **Учитывайте ограничения стека** — в JavaScript глубина стека ограничена
4. **Рассмотрите итеративные альтернативы** — для критичных по производительности участков
5. **Используйте мемоизацию** — для оптимизации повторяющихся вычислений
6. **Тестируйте с разными входными данными** — особенно с граничными случаями

## Рекурсия vs Итерация

| Характеристика | Рекурсия | Итерация |
|----------------|----------|----------|
| Потребление памяти | Высокое (стек вызовов) | Низкое |
| Скорость | Может быть медленнее | Обычно быстрее |
| Читаемость | Высокая для некоторых задач | Может быть сложнее для древовидных структур |
| Ограничения | Глубина стека | Нет ограничений (кроме логики) |

## Рекурсивные структуры данных

Рекурсия особенно полезна для работы с рекурсивными структурами данных:

- [[Деревья-и-графы]] — естественно обходятся рекурсивно
- [[Стек-и-очередь]] — могут быть реализованы рекурсивно
- Графы — алгоритмы поиска в глубину (DFS) используют рекурсию

## Ключевые выводы

- Рекурсия — мощный инструмент для решения задач, которые можно разбить на подзадачи
- Важно всегда определять базовый случай и убедиться, что рекурсия сходится
- Рекурсия используется в сложных системах анализа данных
- Следует учитывать ограничения производительности и памяти при использовании рекурсии
- Существуют методы оптимизации рекурсивных алгоритмов, такие как мемоизация

#алгоритмы #рекурсия #программирование #computer-science