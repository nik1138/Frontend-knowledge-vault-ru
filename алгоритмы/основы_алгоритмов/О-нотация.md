---
aliases: ["Нотация О-большое", "Асимптотическая нотация", "О-нотация в алгоритмах"]
tags: [алгоритмы, сложность, математика, программирование, computer-science]
---

# О-нотация

## Определение и основы

О-нотация (или O-нотация) — это математическая нотация, используемая для описания асимптотического поведения функций, в частности, для оценки сложности алгоритмов. Она показывает верхнюю границу роста времени выполнения или объема памяти в зависимости от размера входных данных.

Формально говоря, если f(n) и g(n) — две функции, то f(n) = O(g(n)) означает, что существует положительная константа c и значение n₀, такие что f(n) ≤ c * g(n) для всех n ≥ n₀.

## Типы асимптотических нотаций

### O (Big O) — верхняя граница
Обозначает асимптотическую верхнюю границу. Используется для оценки худшего случая алгоритма.

### Ω (Big Omega) — нижняя граница
Обозначает асимптотическую нижнюю границу. Показывает лучший случай алгоритма.

### Θ (Big Theta) — точная граница
Обозначает асимптотически точную границу. Используется, когда верхняя и нижняя границы совпадают.

### o (Little o) — строгая верхняя граница
Обозначает функцию, которая растет строго медленнее, чем указанная.

### ω (Little omega) — строгая нижняя граница
Обозначает функцию, которая растет строго быстрее, чем указанная.

## Популярные классы сложности

| Обозначение | Название | Пример |
|-------------|----------|---------|
| O(1) | Константная | Доступ к элементу массива по индексу |
| O(log n) | Логарифмическая | [[Поиск-и-обход#Бинарный поиск|Бинарный поиск]] |
| O(n) | Линейная | [[Поиск-и-обход#Линейный поиск|Линейный поиск]] |
| O(n log n) | Линейитмическая | [[Сортировка-и-упорядочивание#Сортировка слиянием|Сортировка слиянием]] |
| O(n²) | Квадратичная | [[Сортировка-и-упорядочивание#Сортировка пузырьком|Сортировка пузырьком]] |
| O(2ⁿ) | Экспоненциальная | Решение задачи коммивояжера методом полного перебора |
| O(n!) | Факториальная | Перебор всех перестановок |

## Примеры анализа с помощью О-нотации

### Пример 1: Константная сложность

**Псевдокод:**
```
АЛГОРИТМ ПолучитьПервыйЭлемент(массив)
НАЧАЛО
    ВОЗВРАТ массив[0]
КОНЕЦ
```

**JavaScript:**
```javascript
function getFirstElement(arr) {
    return arr[0]; // O(1)
}
```

Функция всегда выполняет одну операцию, независимо от размера массива.

### Пример 2: Линейная сложность

**Псевдокод:**
```
АЛГОРИТМ НайтиМаксимум(массив)
НАЧАЛО
    макс ← массив[0]
    ДЛЯ i ОТ 1 ДО (длина(массив) - 1)
        ЕСЛИ массив[i] > макс ТОГДА
            макс ← массив[i]
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ
    ВОЗВРАТ макс
КОНЕЦ
```

**JavaScript:**
```javascript
function findMax(arr) {
    let max = arr[0];
    for (let i = 1; i < arr.length; i++) { // O(n)
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
```

Цикл выполняется n раз, где n — размер массива.

### Пример 3: Квадратичная сложность

**Псевдокод:**
```
АЛГОРИТМ ИмеетДубликаты(массив)
НАЧАЛО
    ДЛЯ i ОТ 0 ДО (длина(массив) - 1)
        ДЛЯ j ОТ (i + 1) ДО (длина(массив) - 1)
            ЕСЛИ массив[i] = массив[j] ТОГДА
                ВОЗВРАТ ИСТИНА
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ
    ВОЗВРАТ ЛОЖЬ
КОНЕЦ
```

**JavaScript:**
```javascript
function hasDuplicate(arr) {
    for (let i = 0; i < arr.length; i++) { // O(n)
        for (let j = i + 1; j < arr.length; j++) { // O(n)
            if (arr[i] === arr[j]) {
                return true;
            }
        }
    }
    return false;
} // Общая сложность: O(n²)
```

Два вложенных цикла, каждый из которых может выполниться до n раз.

### Пример 4: Логарифмическая сложность

**Псевдокод:**
```
АЛГОРИТМ БинарныйПоиск(массив, цель)
НАЧАЛО
    левый ← 0
    правый ← длина(массив) - 1

    ПОКА левый <= правый
        середина ← (левый + правый) / 2
        ЕСЛИ массив[середина] = цель ТОГДА
            ВОЗВРАТ середина
        ИНАЧЕ ЕСЛИ массив[середина] < цель ТОГДА
            левый ← середина + 1
        ИНАЧЕ
            правый ← середина - 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
    ВОЗВРАТ -1
КОНЕЦ
```

**JavaScript:**
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) { // O(log n)
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

На каждом шаге диапазон поиска уменьшается вдвое.

## Правила работы с О-нотацией

### 1. Игнорирование констант
O(2n) = O(n), O(100) = O(1), O(n/2) = O(n)

### 2. Игнорирование младших членов
O(n² + n) = O(n²), O(n + log n) = O(n)

### 3. Сложение сложностей
Если алгоритм состоит из двух последовательных частей со сложностями O(f(n)) и O(g(n)), общая сложность O(f(n) + g(n)).

### 4. Умножение сложностей
Для вложенных структур: O(f(n)) * O(g(n)) = O(f(n) * g(n)).

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют О-нотацию при:
- Разработке высоконагруженных систем в [[Яндекс]], [[Сбер]], [[VK]]
- Оптимизации алгоритмов для вычислительного оборудования
- Создании систем обработки больших данных
- Разработке алгоритмов для искусственного интеллекта и машинного обучения

О-нотация особенно важна при работе с большими объемами данных, где миллионы пользователей генерируют миллиарды запросов ежедневно.

## Практические рекомендации

1. **Используйте О-нотацию для сравнения алгоритмов** — это позволяет выбрать наиболее эффективное решение до реализации
2. **Учитывайте реальные объемы данных** — в современных системах часто имеют дело с миллионами и миллиардами записей
3. **Не забывайте о константах** — хотя О-нотация игнорирует их, на практике алгоритм с худшей О-нотацией может быть быстрее при малых n
4. **Анализируйте все случаи** — худший, лучший и средний
5. **Проверяйте теоретические оценки эмпирически** — реальная производительность может отличаться из-за особенностей архитектуры

## Распространенные ошибки

- **Игнорирование пространственной сложности** — память может быть ограничена, особенно в embedded системах
- **Оценка только худшего случая** — средний случай может быть более реалистичным
- **Пренебрежение константами** — для малых объемов данных константы могут быть значимы
- **Неправильная оценка рекурсивных алгоритмов** — необходимо учитывать глубину рекурсии и количество вызовов

## Связанные концепции

- [[Сложность-алгоритмов]] — общее понятие о сложности алгоритмов
- [[Рекурсия]] — особенности анализа сложности рекурсивных алгоритмов
- [[Динамическое-программирование]] — как О-нотация применяется в динамическом программировании

## Ключевые выводы

- О-нотация — основной инструмент для анализа эффективности алгоритмов
- Правильное понимание О-нотации позволяет принимать обоснованные решения при выборе алгоритмов
- Знание О-нотации особенно важно из-за необходимости оптимизации
- О-нотация помогает прогнозировать поведение алгоритмов при увеличении объема данных

#алгоритмы #о-нотация #сложность #программирование #computer-science