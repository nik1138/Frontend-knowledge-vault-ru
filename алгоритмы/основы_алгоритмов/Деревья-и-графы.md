---
aliases: ["Деревья", "Графы", "Структуры данных: Деревья и Графы", "Алгоритмы на деревьях и графах"]
tags: [алгоритмы, деревья, графы, структуры-данных, программирование, computer-science]
---

# Деревья и графы

## Определение и основы

Деревья и графы — это нелинейные структуры данных, которые моделируют иерархические и сетевые отношения между элементами. Они широко используются в компьютерных науках для представления сложных взаимосвязей.

## Деревья

### Основные понятия

**Дерево** — это связный ациклический граф с одной выделенной вершиной, называемой корнем. У дерева с n вершинами всегда n-1 рёбер.

**Терминология:**
- **Корень** — вершина без родителя
- **Лист** — вершина без детей
- **Родитель** — вершина, находящаяся на уровень выше
- **Ребенок** — вершина, находящаяся на уровень ниже
- **Путь** — последовательность вершин от корня к листу
- **Глубина** — расстояние от корня до вершины
- **Высота** — максимальная глубина в дереве

### Типы деревьев

#### 1. Бинарное дерево

Каждая вершина имеет не более двух детей (левый и правый).

**Псевдокод:**
```
КЛАСС BinaryTreeNode
    ПОЛЕ значение
    ПОЛЕ левый
    ПОЛЕ правый

    КОНСТРУКТОР(значение)
        ЭТО.значение ← значение
        ЭТО.левый ← NULL
        ЭТО.правый ← NULL
    КОНЕЦ КОНСТРУКТОР
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class BinaryTreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}
```

#### 2. Бинарное дерево поиска (BST)

Для каждой вершины все значения в левом поддереве меньше значения в вершине, а все значения в правом поддереве больше.

**Псевдокод:**
```
КЛАСС BST
    ПОЛЕ корень

    КОНСТРУКТОР()
        ЭТО.корень ← NULL
    КОНЕЦ КОНСТРУКТОР

    МЕТОД insert(значение)
        ЭТО.корень ← ЭТО.insertNode(ЭТО.корень, значение)
    КОНЕЦ МЕТОД

    МЕТОД insertNode(узел, значение)
        ЕСЛИ узел = NULL ТОГДА
            ВОЗВРАТ НОВЫЙ BinaryTreeNode(значение)
        КОНЕЦ ЕСЛИ

        ЕСЛИ значение < узел.значение ТОГДА
            узел.левый ← ЭТО.insertNode(узел.левый, значение)
        ИНАЧЕ ЕСЛИ значение > узел.значение ТОГДА
            узел.правый ← ЭТО.insertNode(узел.правый, значение)
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ узел
    КОНЕЦ МЕТОД

    МЕТОД search(значение)
        ВОЗВРАТ ЭТО.searchNode(ЭТО.корень, значение)
    КОНЕЦ МЕТОД

    МЕТОД searchNode(узел, значение)
        ЕСЛИ узел = NULL ИЛИ узел.значение = значение ТОГДА
            ВОЗВРАТ узел
        КОНЕЦ ЕСЛИ

        ЕСЛИ значение < узел.значение ТОГДА
            ВОЗВРАТ ЭТО.searchNode(узел.левый, значение)
        ИНАЧЕ
            ВОЗВРАТ ЭТО.searchNode(узел.правый, значение)
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class BST {
    constructor() {
        this.root = null;
    }

    insert(value) {
        this.root = this.insertNode(this.root, value);
    }

    insertNode(node, value) {
        if (node === null) {
            return new BinaryTreeNode(value);
        }

        if (value < node.value) {
            node.left = this.insertNode(node.left, value);
        } else if (value > node.value) {
            node.right = this.insertNode(node.right, value);
        }

        return node;
    }

    search(value) {
        return this.searchNode(this.root, value);
    }

    searchNode(node, value) {
        if (node === null || node.value === value) {
            return node;
        }

        if (value < node.value) {
            return this.searchNode(node.left, value);
        } else {
            return this.searchNode(node.right, value);
        }
    }
}
```

#### 3. Сбалансированные деревья

- **AVL-дерево** — сбалансированное по высоте
- **Красно-черное дерево** — сбалансированное с использованием цветов вершин
- **B-дерево** — используется в базах данных и файловых системах

### Обход деревьев

**Псевдокод:**
```
// Прямой обход (pre-order): корень -> левое поддерево -> правое поддерево
АЛГОРИТМ preOrderTraversal(узел, результат = [])
НАЧАЛО
    ЕСЛИ узел ≠ NULL ТОГДА
        ДОБАВИТЬ узел.значение в результат
        preOrderTraversal(узел.левый, результат)
        preOrderTraversal(узел.правый, результат)
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ результат
КОНЕЦ

// Центрированный обход (in-order): левое поддерево -> корень -> правое поддерево
АЛГОРИТМ inOrderTraversal(узел, результат = [])
НАЧАЛО
    ЕСЛИ узел ≠ NULL ТОГДА
        inOrderTraversal(узел.левый, результат)
        ДОБАВИТЬ узел.значение в результат
        inOrderTraversal(узел.правый, результат)
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ результат
КОНЕЦ

// Концевой обход (post-order): левое поддерево -> правое поддерево -> корень
АЛГОРИТМ postOrderTraversal(узел, результат = [])
НАЧАЛО
    ЕСЛИ узел ≠ NULL ТОГДА
        postOrderTraversal(узел.левый, результат)
        postOrderTraversal(узел.правый, результат)
        ДОБАВИТЬ узел.значение в результат
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ результат
КОНЕЦ
```

**JavaScript:**
```javascript
// Прямой обход (pre-order): корень -> левое поддерево -> правое поддерево
function preOrderTraversal(node, result = []) {
    if (node !== null) {
        result.push(node.value);
        preOrderTraversal(node.left, result);
        preOrderTraversal(node.right, result);
    }
    return result;
}

// Центрированный обход (in-order): левое поддерево -> корень -> правое поддерево
function inOrderTraversal(node, result = []) {
    if (node !== null) {
        inOrderTraversal(node.left, result);
        result.push(node.value);
        inOrderTraversal(node.right, result);
    }
    return result;
}

// Концевой обход (post-order): левое поддерево -> правое поддерево -> корень
function postOrderTraversal(node, result = []) {
    if (node !== null) {
        postOrderTraversal(node.left, result);
        postOrderTraversal(node.right, result);
        result.push(node.value);
    }
    return result;
}
```

## Графы

### Основные понятия

**Граф** — это набор вершин (узлов) и ребер (связей) между ними. Граф может быть:
- **Ориентированным** (направленным) — ребра имеют направление
- **Неориентированным** — ребра не имеют направления
- **Взвешенным** — каждое ребро имеет вес или стоимость
- **Связным** — между любыми двумя вершинами существует путь

### Представление графов

#### 1. Матрица смежности

**Псевдокод:**
```
КЛАСС GraphMatrix
    ПОЛЕ вершины
    ПОЛЕ матрица

    КОНСТРУКТОР(вершины)
        ЭТО.вершины ← вершины
        ЭТО.матрица ← МАТРИЦА(вершины × вершины) заполнить 0
    КОНЕЦ КОНСТРУКТОР

    МЕТОД addEdge(из, в, вес = 1)
        ЭТО.матрица[из][в] ← вес
    КОНЕЦ МЕТОД

    МЕТОД hasEdge(из, в)
        ВОЗВРАТ ЭТО.матрица[из][в] ≠ 0
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class GraphMatrix {
    constructor(vertices) {
        this.vertices = vertices;
        this.matrix = Array(vertices).fill().map(() => Array(vertices).fill(0));
    }

    addEdge(u, v, weight = 1) {
        this.matrix[u][v] = weight;
    }

    hasEdge(u, v) {
        return this.matrix[u][v] !== 0;
    }
}
```

#### 2. Список смежности

**Псевдокод:**
```
КЛАСС GraphList
    ПОЛЕ вершины
    ПОЛЕ список_смежности

    КОНСТРУКТОР(вершины)
        ЭТО.вершины ← вершины
        ЭТО.список_смежности ← НОВАЯ КАРТА()

        ДЛЯ i ОТ 0 ДО вершины - 1
            ЭТО.список_смежности.установить(i, пустой_список)
        КОНЕЦ ДЛЯ
    КОНЕЦ КОНСТРУКТОР

    МЕТОД addEdge(из, в, вес = 1)
        ЭТО.список_смежности.получить(из).добавить(ОБЪЕКТ { вершина: в, вес: вес })
    КОНЕЦ МЕТОД

    МЕТОД getNeighbors(из)
        ВОЗВРАТ ЭТО.список_смежности.получить(из)
    КОНЕЦ МЕТОД
КОНЕЦ КЛАСС
```

**JavaScript:**
```javascript
class GraphList {
    constructor(vertices) {
        this.vertices = vertices;
        this.adjList = new Map();

        for (let i = 0; i < vertices; i++) {
            this.adjList.set(i, []);
        }
    }

    addEdge(u, v, weight = 1) {
        this.adjList.get(u).push({ vertex: v, weight });
    }

    getNeighbors(u) {
        return this.adjList.get(u);
    }
}
```

### Алгоритмы на графах

#### 1. Поиск в глубину (DFS)

**Псевдокод:**
```
АЛГОРИТМ dfs(граф, стартовая_вершина)
НАЧАЛО
    посещенные ← НОВОЕ МНОЖЕСТВО()
    результат ← пустой_список

    ФУНКЦИЯ dfsHelper(вершина)
        посещенные.добавить(вершина)
        результат.добавить(вершина)

        соседи ← граф.getNeighbors(вершина)
        ДЛЯ каждый сосед в соседи
            ЕСЛИ !посещенные.содержит(сосед.вершина) ТОГДА
                dfsHelper(сосед.вершина)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ

    dfsHelper(стартовая_вершина)
    ВОЗВРАТ результат
КОНЕЦ
```

**JavaScript:**
```javascript
function dfs(graph, startVertex) {
    const visited = new Set();
    const result = [];

    function dfsHelper(vertex) {
        visited.add(vertex);
        result.push(vertex);

        const neighbors = graph.getNeighbors(vertex);
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor.vertex)) {
                dfsHelper(neighbor.vertex);
            }
        }
    }

    dfsHelper(startVertex);
    return result;
}
```

#### 2. Поиск в ширину (BFS)

**Псевдокод:**
```
АЛГОРИТМ bfs(граф, стартовая_вершина)
НАЧАЛО
    посещенные ← НОВОЕ МНОЖЕСТВО()
    очередь ← НОВАЯ Очередь()
    результат ← пустой_список

    очередь.enqueue(стартовая_вершина)
    посещенные.добавить(стартовая_вершина)

    ПОКА очередь.длина > 0
        вершина ← очередь.dequeue()
        результат.добавить(вершина)

        соседи ← граф.getNeighbors(вершина)
        ДЛЯ каждый сосед в соседи
            ЕСЛИ !посещенные.содержит(сосед.вершина) ТОГДА
                посещенные.добавить(сосед.вершина)
                очередь.enqueue(сосед.вершина)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ПОКА

    ВОЗВРАТ результат
КОНЕЦ
```

**JavaScript:**
```javascript
function bfs(graph, startVertex) {
    const visited = new Set();
    const queue = [startVertex];
    const result = [];

    visited.add(startVertex);

    while (queue.length > 0) {
        const vertex = queue.shift();
        result.push(vertex);

        const neighbors = graph.getNeighbors(vertex);
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor.vertex)) {
                visited.add(neighbor.vertex);
                queue.push(neighbor.vertex);
            }
        }
    }

    return result;
}
```

#### 3. Алгоритм Дейкстры (кратчайший путь в взвешенном графе)

```javascript
function dijkstra(graph, start) {
    const distances = {};
    const visited = new Set();
    const previous = {};
    const nodes = new MinHeap(); // Предполагаем реализацию MinHeap
    
    // Инициализация
    for (let i = 0; i < graph.vertices; i++) {
        distances[i] = i === start ? 0 : Infinity;
        nodes.insert(i, distances[i]);
    }
    
    while (!nodes.isEmpty()) {
        const current = nodes.extractMin();
        const currentDistance = distances[current];
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        const neighbors = graph.getNeighbors(current);
        for (const neighbor of neighbors) {
            if (visited.has(neighbor.vertex)) continue;
            
            const distance = currentDistance + neighbor.weight;
            
            if (distance < distances[neighbor.vertex]) {
                distances[neighbor.vertex] = distance;
                previous[neighbor.vertex] = current;
                nodes.update(neighbor.vertex, distance);
            }
        }
    }
    
    return { distances, previous };
}
```

#### 4. Алгоритм Крускала (минимальное остовное дерево)

```javascript
function kruskal(graph) {
    // Получаем все ребра и сортируем по весу
    const edges = [];
    for (let u = 0; u < graph.vertices; u++) {
        const neighbors = graph.getNeighbors(u);
        for (const neighbor of neighbors) {
            if (u < neighbor.vertex) { // Избегаем дубликатов
                edges.push({ u, v: neighbor.vertex, weight: neighbor.weight });
            }
        }
    }
    
    edges.sort((a, b) => a.weight - b.weight);
    
    const result = [];
    const dsu = new DisjointSetUnion(graph.vertices); // Система непересекающихся множеств
    
    for (const edge of edges) {
        if (dsu.find(edge.u) !== dsu.find(edge.v)) {
            result.push(edge);
            dsu.union(edge.u, edge.v);
        }
    }
    
    return result;
}
```

## Сложность алгоритмов

| Алгоритм | Время (список смежности) | Время (матрица смежности) | Память |
|----------|---------------------------|---------------------------|--------|
| DFS | O(V + E) | O(V²) | O(V) |
| BFS | O(V + E) | O(V²) | O(V) |
| Дейкстра (с кучей) | O(E log V) | O(V² log V) | O(V) |
| Крускал | O(E log E) | O(V² log V) | O(V) |

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют деревья и графы в различных системах:

- **[[Яндекс]]** применяет графовые алгоритмы для построения маршрутов в Яндекс.Картах, анализа социальных графов, рекомендательных систем и поискового ранжирования
- **[[Сбер]]** использует деревья решений и графы для анализа финансовых транзакций, выявления мошенничества и построения кредитных моделей
- **[[VK]]** применяет графовые алгоритмы для анализа социальных сетей, рекомендаций и построения сообществ
- **[[Т-Платформы]]** и другие отечественные разработчики используют деревья и графы в системах анализа данных, оптимизации и моделирования

Особое внимание уделяется оптимизации алгоритмов для эффективной обработки больших графов.

## Практические рекомендации

1. **Выбирайте правильное представление графа** — список смежности для разреженных графов, матрица для плотных
2. **Учитывайте размер данных** — для больших графов важна эффективность использования памяти
3. **Рассмотрите сбалансированные деревья** — для обеспечения стабильной производительности
4. **Используйте профилирование** — для определения узких мест в графовых алгоритмах
5. **Тестируйте на реальных данных** — производительность может значительно отличаться от теоретических оценок

## Связанные темы

- [[Поиск-и-обход]] — алгоритмы обхода деревьев и графов
- [[Стек-и-очередь]] — структуры данных, используемые в алгоритмах обхода
- [[Динамическое-программирование]] — может применяться в задачах на деревьях
- [[Жадные-алгоритмы]] — некоторые графовые алгоритмы (Крускал, Прим) являются жадными

## Ключевые выводы

- Деревья и графы — мощные структуры данных для моделирования сложных отношений
- Выбор правильного алгоритма зависит от типа задачи и структуры данных
- Знание графовых алгоритмов особенно важно для анализа больших данных
- Эти структуры данных лежат в основе многих современных систем и приложений

#алгоритмы #деревья #графы #структуры-данных #программирование #computer-science