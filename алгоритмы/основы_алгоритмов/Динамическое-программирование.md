---
aliases: ["ДП", "Dynamic Programming", "Оптимизация с помощью ДП"]
tags: [алгоритмы, динамическое-программирование, программирование, computer-science, оптимизация]
---

# Динамическое программирование

## Определение и основы

Динамическое программирование (ДП) — это метод решения сложных задач путем разбиения их на более простые подзадачи. Ключевая идея динамического программирования заключается в том, чтобы решить каждую подзадачу только один раз и сохранить результат для последующего использования, избегая избыточных вычислений.

Для задачи применимо динамическое программирование, если она обладает двумя свойствами:
1. **Оптимальная подструктура** — оптимальное решение задачи содержит оптимальные решения подзадач
2. **Перекрывающиеся подзадачи** — задача может быть разбита на подзадачи, которые многократно решаются

## Подходы к динамическому программированию

### 1. Сверху (Top-down) - мемоизация

Решение задачи сводится к рекурсивному решению подзадач с сохранением результатов в кэше.

**Псевдокод:**
```
АЛГОРИТМ fibonacciTopDown(n, мемо = пустой_словарь)
НАЧАЛО
    ЕСЛИ n в мемо ТОГДА
        ВОЗВРАТ мемо[n]
    КОНЕЦ ЕСЛИ

    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ n
    КОНЕЦ ЕСЛИ

    мемо[n] ← fibonacciTopDown(n - 1, мемо) + fibonacciTopDown(n - 2, мемо)
    ВОЗВРАТ мемо[n]
КОНЕЦ
```

**JavaScript:**
```javascript
function fibonacciTopDown(n, memo = {}) {
    if (n in memo) {
        return memo[n];
    }

    if (n <= 1) {
        return n;
    }

    memo[n] = fibonacciTopDown(n - 1, memo) + fibonacciTopDown(n - 2, memo);
    return memo[n];
}
```

### 2. Снизу (Bottom-up) - табуляция

Решение задачи строится последовательно, начиная с базовых случаев и используя их для решения более сложных подзадач.

**Псевдокод:**
```
АЛГОРИТМ fibonacciBottomUp(n)
НАЧАЛО
    ЕСЛИ n <= 1 ТОГДА
        ВОЗВРАТ n
    КОНЕЦ ЕСЛИ

    dp ← МАССИВ_РАЗМЕРА(n + 1)
    dp[0] ← 0
    dp[1] ← 1

    ДЛЯ i ОТ 2 ДО n
        dp[i] ← dp[i - 1] + dp[i - 2]
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[n]
КОНЕЦ
```

**JavaScript:**
```javascript
function fibonacciBottomUp(n) {
    if (n <= 1) {
        return n;
    }

    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

## Классические задачи динамического программирования

### 1. Задача о рюкзаке (Knapsack Problem)

Дано n предметов с весами и стоимостями, и рюкзак с ограниченной вместимостью. Нужно выбрать подмножество предметов, чтобы максимизировать общую стоимость, не превышая вместимость рюкзака.

**Псевдокод:**
```
АЛГОРИТМ knapsack(веса, стоимости, вместимость)
НАЧАЛО
    n ← длина(веса)
    dp ← МАТРИЦА(n + 1, вместимость + 1) заполнить 0

    ДЛЯ i ОТ 1 ДО n
        ДЛЯ w ОТ 0 ДО вместимость
            ЕСЛИ веса[i - 1] <= w ТОГДА
                // Берем максимум между взятием и не взятием предмета
                dp[i][w] ← МАКС(
                    dp[i - 1][w], // Не берем предмет
                    dp[i - 1][w - веса[i - 1]] + стоимости[i - 1] // Берем предмет
                )
            ИНАЧЕ
                dp[i][w] ← dp[i - 1][w] // Не можем взять предмет
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[n][вместимость]
КОНЕЦ
```

**JavaScript:**
```javascript
function knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                // Берем максимум между взятием и не взятием предмета
                dp[i][w] = Math.max(
                    dp[i - 1][w], // Не берем предмет
                    dp[i - 1][w - weights[i - 1]] + values[i - 1] // Берем предмет
                );
            } else {
                dp[i][w] = dp[i - 1][w]; // Не можем взять предмет
            }
        }
    }

    return dp[n][capacity];
}
```

### 2. Наибольшая общая подпоследовательность (LCS)

Найти наибольшую общую подпоследовательность двух последовательностей.

**Псевдокод:**
```
АЛГОРИТМ longestCommonSubsequence(текст1, текст2)
НАЧАЛО
    m ← длина(текст1)
    n ← длина(текст2)

    // dp[i][j] - длина LCS для текст1[0..i-1] и текст2[0..j-1]
    dp ← МАТРИЦА(m + 1, n + 1) заполнить 0

    ДЛЯ i ОТ 1 ДО m
        ДЛЯ j ОТ 1 ДО n
            ЕСЛИ текст1[i - 1] = текст2[j - 1] ТОГДА
                dp[i][j] ← dp[i - 1][j - 1] + 1
            ИНАЧЕ
                dp[i][j] ← МАКС(dp[i - 1][j], dp[i][j - 1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[m][n]
КОНЕЦ
```

**JavaScript:**
```javascript
function longestCommonSubsequence(text1, text2) {
    const m = text1.length;
    const n = text2.length;

    // dp[i][j] - длина LCS для text1[0..i-1] и text2[0..j-1]
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];
}
```

### 3. Редакционное расстояние (Levenshtein Distance)

Минимальное количество операций (вставка, удаление, замена символа), необходимых для преобразования одной строки в другую.

**Псевдокод:**
```
АЛГОРИТМ editDistance(слово1, слово2)
НАЧАЛО
    m ← длина(слово1)
    n ← длина(слово2)

    dp ← МАТРИЦА(m + 1, n + 1) заполнить 0

    // Инициализация - преобразование пустой строки
    ДЛЯ i ОТ 0 ДО m
        dp[i][0] ← i // Удаление всех символов
    КОНЕЦ ДЛЯ
    ДЛЯ j ОТ 0 ДО n
        dp[0][j] ← j // Вставка всех символов
    КОНЕЦ ДЛЯ

    ДЛЯ i ОТ 1 ДО m
        ДЛЯ j ОТ 1 ДО n
            ЕСЛИ слово1[i - 1] = слово2[j - 1] ТОГДА
                dp[i][j] ← dp[i - 1][j - 1] // Без изменения
            ИНАЧЕ
                dp[i][j] ← 1 + МИН(
                    dp[i - 1][j],     // Удаление
                    dp[i][j - 1],     // Вставка
                    dp[i - 1][j - 1]  // Замена
                )
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[m][n]
КОНЕЦ
```

**JavaScript:**
```javascript
function editDistance(word1, word2) {
    const m = word1.length;
    const n = word2.length;

    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

    // Инициализация - преобразование пустой строки
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i; // Удаление всех символов
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j; // Вставка всех символов
    }

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]; // Без изменения
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i - 1][j],     // Удаление
                    dp[i][j - 1],     // Вставка
                    dp[i - 1][j - 1]  // Замена
                );
            }
        }
    }

    return dp[m][n];
}
```

### 4. Максимальная сумма подмассива (Задача Кадане)

Найти непрерывный подмассив с максимальной суммой.

**Псевдокод:**
```
АЛГОРИТМ maxSubarraySum(числа)
НАЧАЛО
    ЕСЛИ длина(числа) = 0 ТОГДА
        ВОЗВРАТ 0
    КОНЕЦ ЕСЛИ

    maxSoFar ← числа[0]
    maxEndingHere ← числа[0]

    ДЛЯ i ОТ 1 ДО длина(числа) - 1
        maxEndingHere ← МАКС(числа[i], maxEndingHere + числа[i])
        maxSoFar ← МАКС(maxSoFar, maxEndingHere)
    КОНЕЦ ДЛЯ

    ВОЗВРАТ maxSoFar
КОНЕЦ
```

**JavaScript:**
```javascript
function maxSubarraySum(nums) {
    if (nums.length === 0) return 0;

    let maxSoFar = nums[0];
    let maxEndingHere = nums[0];

    for (let i = 1; i < nums.length; i++) {
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}
```

### 5. Умножение цепочек матриц

Найти оптимальный порядок умножения цепочки матриц для минимизации количества скалярных умножений.

**Псевдокод:**
```
АЛГОРИТМ matrixChainMultiplication(размерности)
НАЧАЛО
    n ← длина(размерности) - 1
    dp ← МАТРИЦА(n, n) заполнить 0

    // l - длина цепочки
    ДЛЯ l ОТ 2 ДО n
        ДЛЯ i ОТ 0 ДО n - l
            j ← i + l - 1
            dp[i][j] ← БЕСКОНЕЧНОСТЬ

            ДЛЯ k ОТ i ДО j - 1
                стоимость ← dp[i][k] + dp[k + 1][j] +
                           размерности[i] * размерности[k + 1] * размерности[j + 1]

                dp[i][j] ← МИН(dp[i][j], стоимость)
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[0][n - 1]
КОНЕЦ
```

**JavaScript:**
```javascript
function matrixChainMultiplication(dimensions) {
    const n = dimensions.length - 1;
    const dp = Array(n).fill().map(() => Array(n).fill(0));

    // l - длина цепочки
    for (let l = 2; l <= n; l++) {
        for (let i = 0; i < n - l + 1; i++) {
            const j = i + l - 1;
            dp[i][j] = Infinity;

            for (let k = i; k < j; k++) {
                const cost = dp[i][k] + dp[k + 1][j] +
                           dimensions[i] * dimensions[k + 1] * dimensions[j + 1];

                dp[i][j] = Math.min(dp[i][j], cost);
            }
        }
    }

    return dp[0][n - 1];
}
```

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют динамическое программирование в различных системах:

- **[[Яндекс]]** применяет ДП для оптимизации маршрутов в транспортных системах, алгоритмов рекомендаций и обработки текста
- **[[Сбер]]** использует динамическое программирование для оптимизации финансовых моделей, анализа последовательностей транзакций и задач планирования
- **[[VK]]** применяет ДП для анализа временных рядов, оптимизации алгоритмов ленты и обработки мультимедийных данных
- **[[Т-Платформы]]** и другие отечественные разработчики используют ДП в системах оптимизации, анализа данных и вычислительных задач

Особое внимание уделяется оптимизации алгоритмов для решения сложных оптимизационных задач.

## Практические рекомендации

1. **Определите структуру решения** — подумайте, как можно разбить задачу на подзадачи
2. **Найдите рекуррентное соотношение** — определите, как решение задачи связано с решениями подзадач
3. **Выберите подход** — мемоизация или табуляция, в зависимости от специфики задачи
4. **Оптимизируйте память** — часто можно сократить пространственную сложность, храня только необходимые значения
5. **Проверьте базовые случаи** — убедитесь, что правильно обрабатываете тривиальные случаи

## Оптимизация памяти

Во многих задачах ДП можно оптимизировать использование памяти, храня только необходимые значения:

**Псевдокод:**
```
// Вместо хранения всей таблицы для LCS
// АЛГОРИТМ spaceOptimizedLCS(текст1, текст2)
НАЧАЛО
    m ← длина(текст1)
    n ← длина(текст2)

    // Храним только текущую и предыдущую строки
    предыдущая ← МАССИВ_РАЗМЕРА(n + 1) заполнить 0
    текущая ← МАССИВ_РАЗМЕРА(n + 1) заполнить 0

    ДЛЯ i ОТ 1 ДО m
        ДЛЯ j ОТ 1 ДО n
            ЕСЛИ текст1[i - 1] = текст2[j - 1] ТОГДА
                текущая[j] ← предыдущая[j - 1] + 1
            ИНАЧЕ
                текущая[j] ← МАКС(предыдущая[j], текущая[j - 1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
        // Меняем местами массивы
        ВРЕМЕННЫЙ ← предыдущая
        предыдущая ← текущая
        текущая ← ВРЕМЕННЫЙ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ предыдущая[n]
КОНЕЦ
```

**JavaScript:**
```javascript
// Вместо хранения всей таблицы для LCS
// function spaceOptimizedLCS(text1, text2) {
    const m = text1.length;
    const n = text2.length;

    // Храним только текущую и предыдущую строки
    let prev = Array(n + 1).fill(0);
    let curr = Array(n + 1).fill(0);

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                curr[j] = prev[j - 1] + 1;
            } else {
                curr[j] = Math.max(prev[j], curr[j - 1]);
            }
        }
        // Меняем местами массивы
        [prev, curr] = [curr, prev];
    }

    return prev[n];
}
```

## Сравнение с другими подходами

| Метод | Преимущества | Недостатки | Когда использовать |
|-------|-------------|------------|-------------------|
| Динамическое программирование | Избегает повторных вычислений | Требует дополнительной памяти | При перекрывающихся подзадачах |
| Жадные алгоритмы | Быстрые, простые | Не всегда дают оптимальное решение | Когда локально оптимальный выбор приводит к глобально оптимальному решению |
| Рекурсия | Интуитивно понятна | Может быть неэффективной из-за повторных вызовов | Для простых задач без перекрывающихся подзадач |

## Ключевые выводы

- Динамическое программирование — мощный метод решения задач с перекрывающимися подзадачами
- Ключ к успеху — правильно идентифицировать структуру задачи и рекуррентное соотношение
- ДП применяется для решения сложных оптимизационных задач
- Понимание ДП позволяет разрабатывать эффективные алгоритмы для обработки больших объемов данных

#алгоритмы #динамическое-программирование #оптимизация #программирование #computer-science