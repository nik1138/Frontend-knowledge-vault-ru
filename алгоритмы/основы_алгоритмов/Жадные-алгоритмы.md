---
aliases: ["Жадные алгоритмы", "Greedy Algorithms", "Оптимизация с помощью жадных алгоритмов"]
tags: [алгоритмы, жадные-алгоритмы, программирование, computer-science, оптимизация]
---

# Жадные алгоритмы

## Определение и основы

Жадные алгоритмы — это класс алгоритмов, которые на каждом шаге делают локально оптимальный выбор в надежде получить глобально оптимальное решение. Идея заключается в том, чтобы на каждом этапе выбирать то, что кажется лучшим в данный момент, без учета последствий этого выбора для будущих шагов.

Жадный алгоритм обычно состоит из следующих компонентов:
1. **Функция выбора** — выбирает наиболее подходящий элемент на каждом шаге
2. **Функция решения** — проверяет, можно ли добавить элемент к текущему решению
3. **Функция цели** — проверяет, достигнуто ли решение задачи
4. **Функция стоимости/ценности** — определяет "ценность" элемента

## Когда применимы жадные алгоритмы

Жадные алгоритмы дают оптимальное решение, если задача обладает:
1. **Свойством жадного выбора** — глобально оптимальное решение может быть достигнуто с помощью последовательности локально оптимальных решений
2. **Свойством оптимальной подструктуры** — оптимальное решение задачи содержит оптимальные решения подзадач

## Классические задачи с жадными решениями

### 1. Задача о выборе активностей

Дано множество активностей с временем начала и окончания. Нужно выбрать максимальное количество совместимых (непересекающихся) активностей.

**Псевдокод:**
```
АЛГОРИТМ activitySelection(активности)
НАЧАЛО
    // Сортируем активности по времени окончания
    СОРТИРОВАТЬ(активности, по: активность.конец)

    выбранные ← пустой_список
    lastEnd ← -1

    ДЛЯ каждая активность в активности
        ЕСЛИ активность.начало >= lastEnd ТОГДА
            ДОБАВИТЬ активность в выбранные
            lastEnd ← активность.конец
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ выбранные
КОНЕЦ

// Пример использования
активности ← [
    { начало: 1, конец: 4 },
    { начало: 3, конец: 5 },
    { начало: 0, конец: 6 },
    { начало: 5, конец: 7 },
    { начало: 3, конец: 9 },
    { начало: 5, конец: 9 },
    { начало: 6, конец: 10 },
    { начало: 8, конец: 11 },
    { начало: 8, конец: 12 },
    { начало: 2, конец: 14 },
    { начало: 12, конец: 16 }
]

ВЫВОД activitySelection(активности) // Выбирает максимальное количество совместимых активностей
```

**JavaScript:**
```javascript
function activitySelection(activities) {
    // Сортируем активности по времени окончания
    activities.sort((a, b) => a.end - b.end);

    const selected = [];
    let lastEnd = -1;

    for (const activity of activities) {
        if (activity.start >= lastEnd) {
            selected.push(activity);
            lastEnd = activity.end;
        }
    }

    return selected;
}

// Пример использования
const activities = [
    { start: 1, end: 4 },
    { start: 3, end: 5 },
    { start: 0, end: 6 },
    { start: 5, end: 7 },
    { start: 3, end: 9 },
    { start: 5, end: 9 },
    { start: 6, end: 10 },
    { start: 8, end: 11 },
    { start: 8, end: 12 },
    { start: 2, end: 14 },
    { start: 12, end: 16 }
];

console.log(activitySelection(activities)); // Выбирает максимальное количество совместимых активностей
```

### 2. Код Хаффмана

Алгоритм построения оптимального префиксного кода для сжатия данных.

```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    insert(node) {
        this.heap.push(node);
        this.heapifyUp(this.heap.length - 1);
    }
    
    extractMin() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.heapifyDown(0);
        return min;
    }
    
    // Реализация heapifyUp и heapifyDown опущена для краткости
}

**Псевдокод:**
```
КЛАСС HuffmanNode
    ПОЛЕ символ
    ПОЛЕ частота
    ПОЛЕ левый
    ПОЛЕ правый

    КОНСТРУКТОР(символ, частота)
        ЭТО.символ ← символ
        ЭТО.частота ← частота
        ЭТО.левый ← NULL
        ЭТО.правый ← NULL
    КОНЕЦ КОНСТРУКТОР
КОНЕЦ КЛАСС

АЛГОРИТМ huffmanCoding(символы, частоты)
НАЧАЛО
    minHeap ← НОВАЯ MinHeap()

    // Создаем узлы и добавляем в кучу
    ДЛЯ i ОТ 0 ДО длина(символы) - 1
        minHeap.insert(НОВЫЙ HuffmanNode(символы[i], частоты[i]))
    КОНЕЦ ДЛЯ

    // Повторяем, пока не останется один узел
    ПОКА длина(minHeap.heap) > 1
        левый ← minHeap.extractMin()
        правый ← minHeap.extractMin()

        новыйУзел ← НОВЫЙ HuffmanNode(NULL, левый.частота + правый.частота)
        новыйУзел.левый ← левый
        новыйУзел.правый ← правый

        minHeap.insert(новыйУзел)
    КОНЕЦ ПОКА

    ВОЗВРАТ minHeap.extractMin() // Корень дерева Хаффмана
КОНЕЦ
```

**JavaScript:**
```javascript
class HuffmanNode {
    constructor(char, freq) {
        this.char = char;
        this.freq = freq;
        this.left = null;
        this.right = null;
    }
}

function huffmanCoding(chars, freq) {
    const minHeap = new MinHeap();

    // Создаем узлы и добавляем в кучу
    for (let i = 0; i < chars.length; i++) {
        minHeap.insert(new HuffmanNode(chars[i], freq[i]));
    }

    // Повторяем, пока не останется один узел
    while (minHeap.heap.length > 1) {
        const left = minHeap.extractMin();
        const right = minHeap.extractMin();

        const newNode = new HuffmanNode(null, left.freq + right.freq);
        newNode.left = left;
        newNode.right = right;

        minHeap.insert(newNode);
    }

    return minHeap.extractMin(); // Корень дерева Хаффмана
}
```

### 3. Минимальное остовное дерево (Алгоритм Прима)

**Псевдокод:**
```
АЛГОРИТМ primMST(граф)
НАЧАЛО
    вершины ← граф.вершины
    ключ ← МАССИВ(вершины) заполнить БЕСКОНЕЧНОСТЬ
    родитель ← МАССИВ(вершины) заполнить -1
    mstSet ← МАССИВ(вершины) заполнить ЛОЖЬ

    ключ[0] ← 0 // Начинаем с вершины 0
    результат ← []

    ДЛЯ count ОТ 0 ДО вершины - 2
        // Находим вершину с минимальным ключом
        мин ← БЕСКОНЕЧНОСТЬ
        u ← -1

        ДЛЯ v ОТ 0 ДО вершины - 1
            ЕСЛИ !mstSet[v] И ключ[v] < мин ТОГДА
                мин ← ключ[v]
                u ← v
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        mstSet[u] ← ИСТИНА

        // Обновляем ключи смежных вершин
        ДЛЯ v ОТ 0 ДО вершины - 1
            ЕСЛИ граф[u][v] И !mstSet[v] И граф[u][v] < ключ[v] ТОГДА
                родитель[v] ← u
                ключ[v] ← граф[u][v]
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    // Формируем результат
    ДЛЯ i ОТ 1 ДО вершины - 1
        результат.добавить(ОБЪЕКТ { из: родитель[i], в: i, вес: ключ[i] })
    КОНЕЦ ДЛЯ

    ВОЗВРАТ результат
КОНЕЦ
```

**JavaScript:**
```javascript
function primMST(graph) {
    const vertices = graph.vertices;
    const key = Array(vertices).fill(Infinity);
    const parent = Array(vertices).fill(-1);
    const mstSet = Array(vertices).fill(false);

    key[0] = 0; // Начинаем с вершины 0
    const result = [];

    for (let count = 0; count < vertices - 1; count++) {
        // Находим вершину с минимальным ключом
        let min = Infinity;
        let u = -1;

        for (let v = 0; v < vertices; v++) {
            if (!mstSet[v] && key[v] < min) {
                min = key[v];
                u = v;
            }
        }

        mstSet[u] = true;

        // Обновляем ключи смежных вершин
        for (let v = 0; v < vertices; v++) {
            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    // Формируем результат
    for (let i = 1; i < vertices; i++) {
        result.push({ from: parent[i], to: i, weight: key[i] });
    }

    return result;
}
```

### 4. Задача о размене монет

**Псевдокод:**
```
АЛГОРИТМ coinChange(монеты, сумма)
НАЧАЛО
    СОРТИРОВАТЬ(монеты, по убыванию) // Сортируем монеты по убыванию

    результат ← []
    остаток ← сумма

    ДЛЯ каждая монета в монеты
        ПОКА остаток >= монета
            ДОБАВИТЬ монета в результат
            остаток ← остаток - монета
        КОНЕЦ ПОКА
    КОНЕЦ ДЛЯ

    ВОЗВРАТ (остаток = 0) ? результат : NULL // NULL если невозможно разменять
КОНЕЦ

// ВАЖНО: Этот алгоритм работает оптимально только для определенных систем монет (например, для стандартной системы)
```

**JavaScript:**
```javascript
function coinChange(coins, amount) {
    coins.sort((a, b) => b - a); // Сортируем монеты по убыванию

    const result = [];
    let remaining = amount;

    for (const coin of coins) {
        while (remaining >= coin) {
            result.push(coin);
            remaining -= coin;
        }
    }

    return remaining === 0 ? result : null; // null если невозможно разменять
}

// ВАЖНО: Этот алгоритм работает оптимально только для определенных систем монет (например, для стандартной системы)
```

### 5. Задача о дробном рюкзаке

В отличие от классической задачи о рюкзаке, в дробной задаче можно брать часть предмета.

**Псевдокод:**
```
АЛГОРИТМ fractionalKnapsack(предметы, вместимость)
НАЧАЛО
    // Сортируем по удельной стоимости (цене/весу)
    СОРТИРОВАТЬ(предметы, по: (предмет.ценность / предмет.вес), по убыванию)

    общаяЦенность ← 0
    оставшаясяВместимость ← вместимость

    ДЛЯ каждый предмет в предметы
        ЕСЛИ оставшаясяВместимость >= предмет.вес ТОГДА
            // Берем весь предмет
            общаяЦенность ← общаяЦенность + предмет.ценность
            оставшаясяВместимость ← оставшаясяВместимость - предмет.вес
        ИНАЧЕ
            // Берем часть предмета
            доля ← оставшаясяВместимость / предмет.вес
            общаяЦенность ← общаяЦенность + предмет.ценность * доля
            ПРЕРВАТЬ // Рюкзак заполнен
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ общаяЦенность
КОНЕЦ
```

**JavaScript:**
```javascript
function fractionalKnapsack(items, capacity) {
    // Сортируем по удельной стоимости (цене/весу)
    items.sort((a, b) => (b.value / b.weight) - (a.value / a.weight));

    let totalValue = 0;
    let remainingCapacity = capacity;

    for (const item of items) {
        if (remainingCapacity >= item.weight) {
            // Берем весь предмет
            totalValue += item.value;
            remainingCapacity -= item.weight;
        } else {
            // Берем часть предмета
            const fraction = remainingCapacity / item.weight;
            totalValue += item.value * fraction;
            break; // Рюкзак заполнен
        }
    }

    return totalValue;
}
```

## Преимущества и недостатки жадных алгоритмов

### Преимущества:
- Как правило, проще в реализации, чем другие подходы
- Обычно более эффективны по времени выполнения
- Интуитивно понятны
- Хорошо подходят для определенных классов задач

### Недостатки:
- Не всегда дают оптимальное решение
- Требуется доказательство корректности
- Не подходят для всех задач
- Иногда сложно определить, что жадный подход работает

## Сравнение с другими подходами

| Метод | Оптимальность | Сложность | Когда использовать |
|-------|---------------|-----------|-------------------|
| Жадные алгоритмы | Только для задач с жадным свойством | Обычно O(n log n) или O(n) | Когда локальный выбор приводит к глобальному оптимуму |
| [[Динамическое-программирование]] | Глобальный оптимум | Обычно O(n²) или O(n³) | При перекрывающихся подзадачах и оптимальной подструктуре |
| [[Рекурсия]] | Зависит от реализации | Может быть экспоненциальным | Для задач, которые можно разбить на подзадачи |

## Применение в современной ИТ-индустрии

Современные IT-компании активно используют жадные алгоритмы в различных системах:

- **[[Яндекс]]** применяет жадные алгоритмы для задач распределения ресурсов, оптимизации маршрутов и алгоритмов ранжирования
- **[[Сбер]]** использует жадные подходы для оптимизации процессов обработки транзакций, управления портфелями и алгоритмов скоринга
- **[[VK]]** применяет жадные алгоритмы для оптимизации рекламных кампаний, распределения вычислительных ресурсов и алгоритмов ленты
- **[[Т-Платформы]]** и другие отечественные разработчики используют жадные алгоритмы в системах планирования, оптимизации и управления ресурсами

Особое внимание уделяется применению жадных алгоритмов для решения задач оптимизации в условиях ограниченных ресурсов.

## Практические рекомендации

1. **Проверьте свойства задачи** — убедитесь, что задача обладает свойством жадного выбора и оптимальной подструктурой
2. **Докажите корректность** — строго докажите, что жадный подход дает оптимальное решение
3. **Анализируйте сложность** — жадные алгоритмы часто более эффективны, чем альтернативы
4. **Рассмотрите альтернативы** — если жадный подход не работает, рассмотрите [[Динамическое-программирование]] или другие методы
5. **Тестируйте на примерах** — проверьте работу алгоритма на нескольких тестовых примерах

## Когда НЕ использовать жадные алгоритмы

- Задача о рюкзаке (0-1) — требует [[Динамическое-программирование]]
- Нахождение самого длинного пути в графе
- Задача коммивояжера — жадный подход дает приближенное, но не оптимальное решение
- Многие задачи на деревьях и графах, где локальный выбор может привести к глобально неоптимальному решению

## Ключевые выводы

- Жадные алгоритмы — эффективный подход для решения определенных классов задач оптимизации
- Ключ к успеху — правильная идентификация задач, подходящих для жадного подхода
- Жадные алгоритмы применяются для решения задач оптимизации ресурсов
- Всегда проверяйте, применим ли жадный подход к конкретной задаче, и доказывайте его корректность

#алгоритмы #жадные-алгоритмы #оптимизация #программирование #computer-science