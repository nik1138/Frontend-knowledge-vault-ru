---
aliases: ["Множества и отображения", "Sets and Maps", "Set", "Map", "HashSet", "HashMap"]
tags: ["#dsa", "#set", "#map", "#data-structures", "#algorithms", "#collections"]
---

# Множества и отображения

## Введение

Множества и отображения - это абстрактные типы данных, широко используемые в программировании. Множество хранит уникальные элементы, а отображение (ассоциативный массив) хранит пары "ключ-значение". Эти структуры данных являются основой для многих алгоритмов и приложений.

## Определения

### Множество (Set)
**Множество** - это коллекция уникальных элементов без определенного порядка. Основные операции: добавление, удаление и проверка принадлежности элемента.

### Отображение (Map)
**Отображение** (или словарь) - это коллекция пар "ключ-значение", где каждый ключ уникален. Основные операции: вставка, удаление, поиск по ключу.

## Реализации

### Множества

#### HashSet
- Реализован на основе хэш-таблицы
- Время операций: O(1) в среднем случае
- Порядок элементов не гарантируется

#### Псевдокод для HashSet:

```
СТРУКТУРА HashSet
    ДАННЫЕ:
        хэш_таблица - внутренняя хэш-таблица для хранения элементов
        размер - количество элементов в множестве

    МЕТОД add(элемент)
        хэш = вычислить_хэш(элемент)
        корзина = хэш_таблица[хэш МОДУЛЬ размер_таблицы]

        ЕСЛИ элемент НЕ в корзине ТОГДА
            ДОБАВИТЬ элемент В корзину
            размер = размер + 1
            ВОЗВРАТ ИСТИНА
        ИНАЧЕ
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД contains(элемент)
        хэш = вычислить_хэш(элемент)
        корзина = хэш_таблица[хэш МОДУЛЬ размер_таблицы]

        ВОЗВРАТ (элемент В корзине)
    КОНЕЦ МЕТОДА

    МЕТОД remove(элемент)
        хэш = вычислить_хэш(элемент)
        корзина = хэш_таблица[хэш МОДУЛЬ размер_таблицы]

        ЕСЛИ элемент В корзине ТОГДА
            УДАЛИТЬ элемент ИЗ корзины
            размер = размер - 1
            ВОЗВРАТ ИСТИНА
        ИНАЧЕ
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД size()
        ВОЗВРАТ размер
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Реализация Set с использованием встроенных возможностей JavaScript
const hashSet = new Set();
hashSet.add(1);
hashSet.add(2);
hashSet.add(3);
hashSet.add(1); // Не добавится, т.к. уже существует

console.log(hashSet.has(2)); // true
hashSet.delete(2);
console.log(hashSet.size); // 2
```

```java
import java.util.HashSet;
import java.util.Set;

Set<Integer> hashSet = new HashSet<>();
hashSet.add(1);
hashSet.add(2);
hashSet.add(3);
hashSet.add(1); // Не добавится, т.к. уже существует

System.out.println(hashSet.contains(2)); // true
hashSet.remove(2);
```

#### TreeSet
- Реализован на основе сбалансированного бинарного дерева поиска (обычно красно-черного дерева)
- Время операций: O(log n)
- Элементы хранятся в отсортированном порядке

```java
import java.util.TreeSet;

Set<Integer> treeSet = new TreeSet<>();
treeSet.add(3);
treeSet.add(1);
treeSet.add(2);

// Элементы будут отсортированы: [1, 2, 3]
for (int num : treeSet) {
    System.out.print(num + " ");
}
```

#### LinkedHashSet
- Сохраняет порядок вставки элементов
- Комбинация хэш-таблицы и двусвязного списка
- Время операций: O(1) в среднем случае

```java
import java.util.LinkedHashSet;

Set<Integer> linkedSet = new LinkedHashSet<>();
linkedSet.add(3);
linkedSet.add(1);
linkedSet.add(2);

// Элементы будут в порядке вставки: [3, 1, 2]
for (int num : linkedSet) {
    System.out.print(num + " ");
}
```

### Отображения

#### HashMap
- Реализован на основе хэш-таблицы
- Время операций: O(1) в среднем случае
- Порядок пар не гарантируется

```java
import java.util.HashMap;
import java.util.Map;

Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("один", 1);
hashMap.put("два", 2);
hashMap.put("три", 3);

Integer value = hashMap.get("два"); // Возвращает 2
hashMap.put("два", 20); // Обновление значения

System.out.println(hashMap.containsKey("один")); // true
System.out.println(hashMap.containsValue(3)); // true
```

#### TreeMap
- Реализован на основе сбалансированного бинарного дерева поиска
- Время операций: O(log n)
- Пары хранятся в отсортированном порядке по ключу

```java
import java.util.TreeMap;

Map<String, Integer> treeMap = new TreeMap<>();
treeMap.put("яблоко", 5);
treeMap.put("банан", 3);
treeMap.put("апельсин", 8);

// Пары будут отсортированы по ключу
for (Map.Entry<String, Integer> entry : treeMap.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

#### LinkedHashMap
- Сохраняет порядок вставки пар
- Комбинация хэш-таблицы и двусвязного списка
- Время операций: O(1) в среднем случае

```java
import java.util.LinkedHashMap;

Map<String, Integer> linkedMap = new LinkedHashMap<>();
linkedMap.put("первый", 1);
linkedMap.put("второй", 2);
linkedMap.put("третий", 3);

// Пары будут в порядке вставки
for (Map.Entry<String, Integer> entry : linkedMap.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

## Операции и сложность

### Операции множеств:

| Операция | HashSet | TreeSet | LinkedHashSet |
|----------|---------|---------|---------------|
| add | O(1) | O(log n) | O(1) |
| remove | O(1) | O(log n) | O(1) |
| contains | O(1) | O(log n) | O(1) |
| итерация | O(n) | O(n) | O(n) |

### Операции отображений:

| Операция | HashMap | TreeMap | LinkedHashMap |
|----------|---------|---------|---------------|
| put | O(1) | O(log n) | O(1) |
| get | O(1) | O(log n) | O(1) |
| remove | O(1) | O(log n) | O(1) |
| итерация | O(n) | O(n) | O(n) |

## Практические применения

### Множества:
- Удаление дубликатов из коллекции
- Проверка уникальности элементов
- Математические операции над множествами (объединение, пересечение)
- Кэширование уникальных значений

### Отображения:
- Кэширование результатов вычислений
- Индексирование данных
- Подсчет частоты элементов
- Реализация lookup-таблиц

```java
// Пример: подсчет частоты слов
import java.util.*;

public class WordFrequency {
    public static Map<String, Integer> countWords(String[] words) {
        Map<String, Integer> frequencyMap = new HashMap<>();
        
        for (String word : words) {
            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);
        }
        
        return frequencyMap;
    }
    
    // Пример использования
    public static void main(String[] args) {
        String[] words = {"яблоко", "банан", "яблоко", "апельсин", "банан", "яблоко"};
        Map<String, Integer> frequencies = countWords(words);
        
        for (Map.Entry<String, Integer> entry : frequencies.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

## Применение в индустрии

В современной IT-индустрии:
- HashSet и HashMap широко используются в высоконагруженных системах
- TreeMap применяется для задач, требующих упорядоченности
- Важно понимание различий между реализациями для оптимизации производительности
- Актуальны вопросы thread-safety при многопоточном использовании

Крупные технологические компании:
- Проверяют знание различных реализаций Set и Map
- Ожидают понимания различий в производительности
- Тестируют умение выбрать подходящую реализацию для задачи
- Часто задают задачи на эффективное использование коллекций

## Thread-safety

### Небезопасные реализации:
- HashSet, HashMap, LinkedHashSet, LinkedHashMap, TreeSet, TreeMap - не являются потокобезопасными

### Потокобезопасные альтернативы:
- ConcurrentHashMap - потокобезопасная реализация Map
- Collections.synchronizedSet/Set/Map - синхронизированные обертки

```javascript
// Потокобезопасные реализации (в среде с поддержкой многопоточности, например Web Workers)
// В однопоточном окружении JavaScript веба безопасность потоков не так актуальна
// Но для демонстрации структур данных:

// Использование Map в JavaScript
const jsMap = new Map();
jsMap.set("ключ", 100);
const jsValue = jsMap.get("ключ");

// Обычный объект как альтернатива
const objMap = {};
objMap["ключ"] = 100;
const objValue = objMap["ключ"];

// Операции над множествами в JavaScript
const set1 = new Set([1, 2, 3, 4, 5]);
const set2 = new Set([4, 5, 6, 7, 8]);

// Объединение
const union = new Set([...set1, ...set2]);

// Пересечение
const intersection = new Set([...set1].filter(x => set2.has(x)));

// Разность
const difference = new Set([...set1].filter(x => !set2.has(x)));
```

```java
// Потокобезопасные реализации
import java.util.concurrent.ConcurrentHashMap;

Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
concurrentMap.put("ключ", 100);
Integer value = concurrentMap.get("ключ");

// Синхронизированная обертка
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
```

## Продвинутые операции

### Операции над множествами:

```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));

// Объединение
Set<Integer> union = new HashSet<>(set1);
union.addAll(set2);

// Пересечение
Set<Integer> intersection = new HashSet<>(set1);
intersection.retainAll(set2);

// Разность
Set<Integer> difference = new HashSet<>(set1);
difference.removeAll(set2);
```

### Stream API с коллекциями:

```java
import java.util.stream.Collectors;

// Фильтрация и преобразование
List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
Set<String> filteredSet = words.stream()
    .filter(word -> word.length() > 4)
    .map(String::toUpperCase)
    .collect(Collectors.toSet());

// Группировка по длине слова
Map<Integer, List<String>> groupedByLength = words.stream()
    .collect(Collectors.groupingBy(String::length));
```

## Примеры задач на собеседованиях

- Проверка уникальности элементов в массиве
- Найти пересечение двух массивов
- Подсчет частоты элементов
- Найти первый неповторяющийся символ
- Реализовать LRU-кэш

## Связанные темы

- [[Хэш-таблицы]]
- [[Бинарные-деревья-поиска]]
- [[Алгоритмы-поиска]]
- [[Коллекции-в-Java]]
- [[Stream-API]]

## Заключение

Множества и отображения являются важными абстракциями в программировании, обеспечивающими эффективную работу с уникальными элементами и парами "ключ-значение". Знание различных реализаций и умение эффективно их использовать остается критически важным как для прохождения технических собеседований, так и для разработки производительных приложений.