---
aliases: ["Графы", "Graph", "Graphs"]
tags: ["#dsa", "#graph", "#data-structures", "#algorithms", "#networks"]
---

# Графы

## Введение

Графы - это структуры данных, состоящие из вершин (узлов) и рёбер (соединений между вершинами). Графы находят широкое применение в социальных сетях, транспортных системах, рекомендательных системах и многих других областях.

## Определение

**Граф** - это набор вершин (узлов) и рёбер (соединений между узлами). Формально граф G определяется как G = (V, E), где V - множество вершин, а E - множество рёбер.

## Типы графов

### По направлению рёбер:
- **Ориентированный граф (направленный)** - рёбра имеют направление
- **Неориентированный граф (ненаправленный)** - рёбра не имеют направления

### По наличию циклов:
- **Ациклический граф** - граф без циклов
- **Циклический граф** - граф с циклами

### По взвешенности:
- **Взвешенный граф** - каждому ребру присвоен вес
- **Невзвешенный граф** - рёбрам не присвоены веса

## Представление графов

### Матрица смежности
- Квадратная матрица размером n×n, где n - количество вершин
- matrix[i][j] = 1, если существует ребро между вершинами i и j
- Память: O(n²), проверка ребра: O(1)

#### Псевдокод для представления графа с помощью матрицы смежности:

```
СТРУКТУРА ГрафМатрица
    ДАННЫЕ:
        матрица[][] - двумерный массив размером n×n
        количество_вершин - общее количество вершин
        количество_рёбер - общее количество рёбер

    МЕТОД создатьГраф(n)
        количество_вершин = n
        количество_рёбер = 0
        // Инициализируем матрицу нулями
        ОТ i = 0 ДО n-1
            ОТ j = 0 ДО n-1
                матрица[i][j] = 0
            КОНЕЦ ОТ
        КОНЕЦ ОТ
    КОНЕЦ МЕТОДА

    МЕТОД добавитьРебро(u, v, ориентированный)
        ЕСЛИ u < количество_вершин И v < количество_вершин ТОГДА
            матрица[u][v] = 1
            количество_рёбер = количество_рёбер + 1
            ЕСЛИ НЕ ориентированный ТОГДА
                матрица[v][u] = 1
                количество_рёбер = количество_рёбер + 1
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД естьРебро(u, v)
        ВОЗВРАТ (матрица[u][v] == 1)
    КОНЕЦ МЕТОДА

    МЕТОД получитьСоседей(вершина)
        список = []
        ОТ i = 0 ДО количество_вершин-1
            ЕСЛИ матрица[вершина][i] == 1 ТОГДА
                ДОБАВИТЬ список, i
            КОНЕЦ ЕСЛИ
        КОНЕЦ ОТ
        ВОЗВРАТ список
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Пример матрицы смежности для неориентированного графа в JavaScript
class GraphMatrix {
    constructor(n) {
        this.vertices = n;
        this.edges = 0;
        this.matrix = Array(n).fill().map(() => Array(n).fill(0));
    }

    addEdge(u, v, directed = false) {
        if (u < this.vertices && v < this.vertices) {
            this.matrix[u][v] = 1;
            this.edges++;
            if (!directed) {
                this.matrix[v][u] = 1;
                this.edges++;
            }
        }
    }

    hasEdge(u, v) {
        return this.matrix[u][v] === 1;
    }

    getNeighbors(vertex) {
        const neighbors = [];
        for (let i = 0; i < this.vertices; i++) {
            if (this.matrix[vertex][i] === 1) {
                neighbors.push(i);
            }
        }
        return neighbors;
    }
}

// Пример использования
const graph = new GraphMatrix(5);
graph.addEdge(0, 1);
graph.addEdge(1, 0); // Для неориентированного графа
```

```java
// Пример матрицы смежности для неориентированного графа
int[][] adjacencyMatrix = new int[5][5];
adjacencyMatrix[0][1] = 1;
adjacencyMatrix[1][0] = 1; // Для неориентированного графа
```

### Список смежности
- Массив списков, где для каждой вершины хранится список смежных вершин
- Память: O(V + E), где V - количество вершин, E - количество рёбер

#### Псевдокод для представления графа с помощью списка смежности:

```
СТРУКТУРА ГрафСписок
    ДАННЫЕ:
        список_смежности[] - массив списков для каждой вершины
        количество_вершин - общее количество вершин
        количество_рёбер - общее количество рёбер

    МЕТОД создатьГраф(n)
        количество_вершин = n
        количество_рёбер = 0
        // Инициализируем пустые списки для каждой вершины
        ОТ i = 0 ДО n-1
            список_смежности[i] = []
        КОНЕЦ ОТ
    КОНЕЦ МЕТОДА

    МЕТОД добавитьРебро(u, v, ориентированный)
        ЕСЛИ u < количество_вершин И v < количество_вершин ТОГДА
            ДОБАВИТЬ список_смежности[u], v
            количество_рёбер = количество_рёбер + 1
            ЕСЛИ НЕ ориентированный ТОГДА
                ДОБАВИТЬ список_смежности[v], u
                количество_рёбер = количество_рёбер + 1
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД естьРебро(u, v)
        ВОЗВРАТ (v В список_смежности[u])
    КОНЕЦ МЕТОДА

    МЕТОД получитьСоседей(вершина)
        ВОЗВРАТ список_смежности[вершина]
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Пример списка смежности в JavaScript
class GraphList {
    constructor() {
        this.adjacencyList = new Map();
    }

    addEdge(u, v, directed = false) {
        // Убедимся, что обе вершины существуют в списке
        if (!this.adjacencyList.has(u)) {
            this.adjacencyList.set(u, []);
        }
        if (!this.adjacencyList.has(v)) {
            this.adjacencyList.set(v, []);
        }

        // Добавляем ребро u -> v
        this.adjacencyList.get(u).push(v);

        // Если граф неориентированный, добавляем ребро v -> u
        if (!directed) {
            this.adjacencyList.get(v).push(u);
        }
    }

    getNeighbors(vertex) {
        return this.adjacencyList.get(vertex) || [];
    }

    hasEdge(u, v) {
        const neighbors = this.adjacencyList.get(u) || [];
        return neighbors.includes(v);
    }
}

// Пример использования
const graph = new GraphList();
graph.addEdge(0, 1);
graph.addEdge(1, 2);
console.log(graph.getNeighbors(1)); // [0, 2]
```

```java
// Пример списка смежности в Java
import java.util.*;

class Graph {
    private Map<Integer, List<Integer>> adjacencyList;

    public Graph() {
        adjacencyList = new HashMap<>();
    }

    public void addEdge(int u, int v, boolean directed) {
        adjacencyList.putIfAbsent(u, new ArrayList<>());
        adjacencyList.putIfAbsent(v, new ArrayList<>());

        adjacencyList.get(u).add(v);
        if (!directed) {
            adjacencyList.get(v).add(u);
        }
    }

    public List<Integer> getNeighbors(int vertex) {
        return adjacencyList.getOrDefault(vertex, new ArrayList<>());
    }
}
```

## Основные операции

### Обход графа:
- **Поиск в ширину (BFS)** - обход в ширину
- **Поиск в глубину (DFS)** - обход в глубину

#### Псевдокод для BFS и DFS:

```
АЛГОРИТМ BFS(граф, начальная_вершина)
    ВХОД: граф - представление графа, начальная_вершина - стартовая вершина
    ВЫХОД: посещенные вершины в порядке обхода

    посещенные = пустое множество
    очередь = пустая очередь
    добавить начальная_вершина в очередь
    добавить начальная_вершина в посещенные

    ПОКА очередь не пуста ВЫПОЛНЯТЬ
        текущая_вершина = извлечь из очереди
        ВЫВОД текущая_вершина

        ДЛЯ каждой соседней_вершины В соседи(текущая_вершина) ВЫПОЛНЯТЬ
            ЕСЛИ соседняя_вершина НЕ в посещенные ТОГДА
                добавить соседнюю_вершину в посещенные
                добавить соседнюю_вершину в очередь
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_рекурсивный(граф, вершина, посещенные)
    ВХОД: граф - представление графа, вершина - текущая вершина, посещенные - множество посещенных вершин
    ВЫХОД: обход в глубину

    добавить вершина в посещенные
    ВЫВОД вершина

    ДЛЯ каждой соседней_вершины В соседи(вершина) ВЫПОЛНЯТЬ
        ЕСЛИ соседняя_вершина НЕ в посещенные ТОГДА
            DFS_рекурсивный(граф, соседняя_вершина, посещенные)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_итеративный(граф, начальная_вершина)
    ВХОД: граф - представление графа, начальная_вершина - стартовая вершина
    ВЫХОД: обход в глубину

    стек = пустой стек
    посещенные = пустое множество
    добавить начальная_вершина в стек

    ПОКА стек не пуст ВЫПОЛНЯТЬ
        текущая_вершина = вершина из стека
        ЕСЛИ текущая_вершина НЕ в посещенные ТОГДА
            добавить текущая_вершина в посещенные
            ВЫВОД текущая_вершина

            ДЛЯ каждой соседней_вершины В соседи(текущая_вершина) ВЫПОЛНЯТЬ
                ЕСЛИ соседняя_вершина НЕ в посещенные ТОГДА
                    добавить соседнюю_вершину в стек
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА
```

```javascript
// BFS реализация в JavaScript
function bfs(graph, startVertex) {
    const visited = new Set();
    const queue = [startVertex];
    visited.add(startVertex);

    while (queue.length > 0) {
        const currentVertex = queue.shift();
        console.log(currentVertex);

        const neighbors = graph.getNeighbors(currentVertex);
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
}

// DFS реализация (рекурсивная) в JavaScript
function dfsRecursive(graph, vertex, visited = new Set()) {
    visited.add(vertex);
    console.log(vertex);

    const neighbors = graph.getNeighbors(vertex);
    for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
            dfsRecursive(graph, neighbor, visited);
        }
    }
}

// DFS реализация (итеративная) в JavaScript
function dfsIterative(graph, startVertex) {
    const visited = new Set();
    const stack = [startVertex];

    while (stack.length > 0) {
        const currentVertex = stack.pop();

        if (!visited.has(currentVertex)) {
            visited.add(currentVertex);
            console.log(currentVertex);

            const neighbors = graph.getNeighbors(currentVertex);
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
}
```

```java
// BFS реализация
public void bfs(int startVertex) {
    Set<Integer> visited = new HashSet<>();
    Queue<Integer> queue = new LinkedList<>();

    visited.add(startVertex);
    queue.offer(startVertex);

    while (!queue.isEmpty()) {
        int currentVertex = queue.poll();
        System.out.print(currentVertex + " ");

        for (int neighbor : getNeighbors(currentVertex)) {
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
}

// DFS реализация (рекурсивная)
public void dfs(int vertex, Set<Integer> visited) {
    visited.add(vertex);
    System.out.print(vertex + " ");

    for (int neighbor : getNeighbors(vertex)) {
        if (!visited.contains(neighbor)) {
            dfs(neighbor, visited);
        }
    }
}
```

## Алгоритмы на графах

### Алгоритмы поиска:
- **BFS** - находит кратчайший путь в невзвешенном графе
- **DFS** - используется для обнаружения циклов, топологической сортировки

### Алгоритмы нахождения кратчайшего пути:
- **Алгоритм Дейкстры** - для взвешенных графов без отрицательных весов
- **Алгоритм Беллмана-Форда** - для графов с отрицательными весами
- **Алгоритм Флойда-Уоршелла** - находит кратчайшие пути между всеми парами вершин

### Алгоритмы остовных деревьев:
- **Алгоритм Крускала** - находит минимальное остовное дерево
- **Алгоритм Прима** - находит минимальное остовное дерево

## Сложность операций

### Для списка смежности:
- BFS: O(V + E)
- DFS: O(V + E)
- Добавление ребра: O(1)
- Проверка смежности: O(degree)

### Для матрицы смежности:
- BFS: O(V²)
- DFS: O(V²)
- Добавление ребра: O(1)
- Проверка смежности: O(1)

## Практические применения

### В социальных сетях:
- Моделирование отношений между пользователями
- Рекомендация друзей
- Анализ сообществ

### В транспортных системах:
- Поиск кратчайших маршрутов
- Оптимизация логистики
- Планирование маршрутов

### В веб-поиске:
- Моделирование структуры интернета
- PageRank алгоритм

### В базах данных:
- Моделирование отношений между сущностями
- Оптимизация запросов

## Применение в индустрии

В современной IT-индустрии:
- Графы активно используются в социальных сетях
- Применяются в системах доставки и логистики
- Используются в рекомендательных системах
- Важны для анализа сетевых структур и безопасности

Крупные технологические компании:
- Проверяют знание основных алгоритмов на графах
- Ожидают умения выбрать подходящее представление графа
- Тестируют понимание сложности различных алгоритмов
- Часто задают задачи на BFS/DFS на собеседованиях

## Разновидности графов

### Специальные типы графов:
- **Дерево** - связный ациклический граф
- **Двудольный граф** - граф, вершины которого можно разделить на два множества
- **Полный граф** - граф, в котором каждая пара вершин соединена ребром
- **Планарный граф** - граф, который можно нарисовать на плоскости без пересечения рёбер

## Примеры задач на собеседованиях

- Количество островов (связных компонентов)
- Проверка двудольности графа
- Цикл в графе
- Кратчайший путь в лабиринте
- Топологическая сортировка

## Связанные темы

- [[Деревья]]
- [[Алгоритмы-поиска]]
- [[Алгоритмы-сортировки]]
- [[Бинарные-деревья-поиска]]
- [[Сетевые-алгоритмы]]

## Заключение

Графы являются мощной структурой данных, позволяющей моделировать сложные взаимосвязи между объектами. Знание графов и умение применять алгоритмы на графах остается критически важным как для прохождения технических собеседований, так и для решения реальных задач в разработке программного обеспечения.