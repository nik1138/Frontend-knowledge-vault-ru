---
aliases: ["Деревья", "Tree", "Дерево"]
tags: ["#dsa", "#tree", "#data-structures", "#algorithms", "#recursion"]
---

# Деревья

## Введение

Деревья - это иерархическая структура данных, состоящая из узлов, где каждый узел имеет значение и может содержать ссылки на дочерние узлы. Деревья широко используются в базах данных, файловых системах, алгоритмах поиска и во многих других приложениях.

## Определение

**Дерево** - это нелинейная структура данных, представляющая собой набор узлов, организованных в иерархическом порядке. Оно состоит из:
- **Корня** - верхнего узла без родителя
- **Узлов** - элементов, содержащих данные и ссылки на дочерние узлы
- **Листьев** - узлов без дочерних элементов
- **Рёбер** - связей между узлами

## Терминология

- **Корень (Root)** - верхний узел дерева без родителя
- **Лист (Leaf)** - узел без дочерних элементов
- **Родитель (Parent)** - узел, имеющий дочерние узлы
- **Ребёнок (Child)** - узел, имеющий родителя
- **Глубина узла** - количество рёбер от корня до узла
- **Высота узла** - количество рёбер на самом длинном пути от узла до листа
- **Поддерево** - часть дерева, состоящая из узла и всех его потомков

## Виды деревьев

### Бинарное дерево
Каждый узел имеет не более двух дочерних узлов (левый и правый).

### Полное бинарное дерево
Все уровни, кроме, возможно, последнего, полностью заполнены, и все узлы находятся как можно левее.

### Сбалансированное дерево
Разница высот левого и правого поддеревьев для любого узла не превышает 1.

### Вырожденное дерево
Каждый внутренний узел имеет только одного ребёнка, фактически становится списком.

## Основные операции

### Обход дерева:
- **Прямой (Pre-order)**: корень → левое поддерево → правое поддерево
- **Центральный (In-order)**: левое поддерево → корень → правое поддерево
- **Концевой (Post-order)**: левое поддерево → правое поддерево → корень
- **По уровням (Level-order)**: обход по уровням сверху вниз

#### Псевдокод для обхода дерева:

```
СТРУКТУРА УзелДерева
    ДАННЫЕ:
        значение
        левый - указатель на левый дочерний узел
        правый - указатель на правый дочерний узел
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ PreOrder(корень)
    ВХОД: корень - корневой узел дерева
    ЕСЛИ корень ≠ NULL ТОГДА
        ВЫВОД корень.значение
        PreOrder(корень.левый)
        PreOrder(корень.правый)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ InOrder(корень)
    ВХОД: корень - корневой узел дерева
    ЕСЛИ корень ≠ NULL ТОГДА
        InOrder(корень.левый)
        ВЫВОД корень.значение
        InOrder(корень.правый)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ PostOrder(корень)
    ВХОД: корень - корневой узел дерева
    ЕСЛИ корень ≠ NULL ТОГДА
        PostOrder(корень.левый)
        PostOrder(корень.правый)
        ВЫВОД корень.значение
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ LevelOrder(корень)
    ВХОД: корень - корневой узел дерева
    ОЧЕРЕДЬ очередь
    ЕСЛИ корень ≠ NULL ТОГДА
        очередь.добавить(корень)
        ПОКА очередь.не_пуста() ВЫПОЛНЯТЬ
            узел = очередь.извлечь()
            ВЫВОД узел.значение
            ЕСЛИ узел.левый ≠ NULL ТОГДА
                очередь.добавить(узел.левый)
            КОНЕЦ ЕСЛИ
            ЕСЛИ узел.правый ≠ NULL ТОГДА
                очередь.добавить(узел.правый)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ПОКА
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
// Пример рекурсивного обхода дерева в JavaScript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// Pre-order обход
function preOrder(root) {
    if (root !== null) {
        console.log(root.val + " ");
        preOrder(root.left);
        preOrder(root.right);
    }
}

// In-order обход
function inOrder(root) {
    if (root !== null) {
        inOrder(root.left);
        console.log(root.val + " ");
        inOrder(root.right);
    }
}

// Post-order обход
function postOrder(root) {
    if (root !== null) {
        postOrder(root.left);
        postOrder(root.right);
        console.log(root.val + " ");
    }
}

// Level-order обход (используя очередь)
function levelOrder(root) {
    if (root === null) return;

    const queue = [root];
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node.val + " ");

        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
}
```

```java
// Пример рекурсивного обхода дерева в Java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

// Pre-order обход
public void preOrder(TreeNode root) {
    if (root != null) {
        System.out.print(root.val + " ");
        preOrder(root.left);
        preOrder(root.right);
    }
}

// In-order обход
public void inOrder(TreeNode root) {
    if (root != null) {
        inOrder(root.left);
        System.out.print(root.val + " ");
        inOrder(root.right);
    }
}
```

## Реализация дерева

#### Псевдокод для реализации бинарного дерева:

```
СТРУКТУРА УзелДерева
    ДАННЫЕ:
        значение
        левый - указатель на левый дочерний узел
        правый - указатель на правый дочерний узел
КОНЕЦ СТРУКТУРЫ

СТРУКТУРА BinaryTree
    ДАННЫЕ:
        корень - указатель на корневой узел дерева

    МЕТОД создатьДерево()
        корень = NULL
    КОНЕЦ МЕТОДА

    МЕТОД вставить(узел, значение)
        ВХОД: узел - текущий узел, значение - вставляемое значение
        ВЫХОД: обновленный узел

        ЕСЛИ узел = NULL ТОГДА
            НОВЫЙ_УЗЕЛ = НОВЫЙ УзелДерева(значение)
            ВОЗВРАТ НОВЫЙ_УЗЕЛ
        КОНЕЦ ЕСЛИ

        ЕСЛИ значение < узел.значение ТОГДА
            узел.левый = вставить(узел.левый, значение)
        ИНАЧЕ ЕСЛИ значение > узел.значение ТОГДА
            узел.правый = вставить(узел.правый, значение)
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ узел
    КОНЕЦ МЕТОДА

    МЕТОД вставитьЗначение(значение)
        корень = вставить(корень, значение)
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Пример реализации бинарного дерева в JavaScript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class BinaryTree {
    constructor() {
        this.root = null;
    }

    // Метод для вставки узла
    insert(value) {
        this.root = this.insertRec(this.root, value);
    }

    insertRec(node, value) {
        if (node === null) {
            return new TreeNode(value);
        }

        if (value < node.val) {
            node.left = this.insertRec(node.left, value);
        } else if (value > node.val) {
            node.right = this.insertRec(node.right, value);
        }

        return node;
    }
}

// Пример использования
const tree = new BinaryTree();
tree.insert(5);
tree.insert(3);
tree.insert(7);
```

```java
// Пример реализации бинарного дерева
class BinaryTree {
    TreeNode root;

    public BinaryTree() {
        root = null;
    }

    // Метод для вставки узла
    public void insert(int value) {
        root = insertRec(root, value);
    }

    private TreeNode insertRec(TreeNode root, int value) {
        if (root == null) {
            root = new TreeNode(value);
            return root;
        }

        if (value < root.val) {
            root.left = insertRec(root.left, value);
        } else if (value > root.val) {
            root.right = insertRec(root.right, value);
        }

        return root;
    }
}
```

## Сложность операций

### Для сбалансированного дерева:
- Поиск: O(log n)
- Вставка: O(log n)
- Удаление: O(log n)

### Для вырожденного дерева:
- Поиск: O(n)
- Вставка: O(n)
- Удаление: O(n)

## Практические применения

### В реальных проектах:
- Файловые системы (иерархия папок)
- DOM-дерево в веб-разработке
- Организационные структуры
- Системы рекомендаций
- Игровые деревья решений
- XML/HTML парсинг

### В базах данных:
- B-деревья и B+ деревья для индексации
- Поиск и сортировка данных

### В алгоритмах:
- Алгоритмы поиска в ширину и глубину
- Алгоритмы наименьшего остовного дерева
- Задачи динамического программирования на деревьях

## Применение в индустрии

В современной IT-индустрии:
- Деревья активно используются в разработке поисковых систем
- Важны для построения рекомендательных систем
- Применяются в системах хранения и индексации данных
- Востребованы в задачах машинного обучения и анализа данных

Крупные технологические компании:
- Проверяют знание различных видов деревьев и их свойств
- Ожидают умения реализовать обходы дерева
- Тестируют понимание балансировки деревьев
- Часто задают задачи на деревья на собеседованиях

## Разновидности деревьев

### N-арные деревья
Каждый узел может иметь до N дочерних узлов.

### Trie (Префиксное дерево)
Используется для хранения строк и эффективного поиска по префиксу.

### Сегментное дерево
Используется для эффективного выполнения запросов на отрезке (например, сумма, минимум, максимум).

### Дерево отрезков
Применяется для решения задач на обновление и запросы на отрезке.

## Примеры задач на собеседованиях

- Максимальная глубина дерева
- Проверка симметричности дерева
- Сериализация и десериализация дерева
- Найти путь в дереве
- Lowest Common Ancestor (LCA)

## Связанные темы

- [[Бинарные-деревья-поиска]]
- [[Графы]]
- [[Кучи]]
- [[Алгоритмы-обхода-деревьев]]
- [[Динамическое-программирование-на-деревьях]]

## Заключение

Деревья являются одной из самых важных структур данных в программировании. Знание деревьев и умение работать с ними остается критически важным как для прохождения технических собеседований, так и для решения реальных задач в разработке программного обеспечения.