---
aliases: ["Строки и их обработка", "Strings", "String Processing", "Обработка строк"]
tags: ["#dsa", "#strings", "#algorithms", "#text-processing", "#pattern-matching"]
---

# Строки и их обработка

## Введение

Строки - это последовательности символов, используемые для представления текстовой информации. Обработка строк является одной из самых важных тем, особенно в контексте веб-разработки, поисковых систем, обработки естественного языка и систем безопасности.

## Определение

**Строка** - это упорядоченная последовательность символов, обычно заканчивающаяся специальным символом (в некоторых языках). В большинстве современных языков программирования строки являются неизменяемыми объектами (immutable).

## Представление строк

### В Java:
- Класс `String` - неизменяемый
- Классы `StringBuilder` и `StringBuffer` - изменяемые строки
- Строки хранятся в пуле строк (string pool)

```java
String str1 = "Hello";
String str2 = new String("World");
StringBuilder sb = new StringBuilder("Mutable string");
```

### В других языках:
- Python: строки неизменяемы
- C/C++: строки как массивы символов или объекты std::string
- JavaScript: строки неизменяемы

## Основные операции со строками

### Создание и инициализация

#### Псевдокод для работы со строками:

```
АЛГОРИТМ СоздатьСтроку(символы)
    ВХОД: символы - массив символов
    ВЫХОД: строка

    строка = выделить_память(размер = длина(символы))
    ОТ i = 0 ДО длина(символы) - 1
        строка[i] = символы[i]
    КОНЕЦ ОТ
    строка[длина(символы)] = '\0'  // терминирующий символ
    ВОЗВРАТ строка
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ Конкатенация(строка1, строка2)
    ВХОД: строка1, строка2 - строки для объединения
    ВЫХОД: новая строка - результат объединения

    длина1 = длина(строка1)
    длина2 = длина(строка2)
    новая_строка = выделить_память(размер = длина1 + длина2 + 1)

    // Копируем первую строку
    ОТ i = 0 ДО длина1 - 1
        новая_строка[i] = строка1[i]
    КОНЕЦ ОТ

    // Копируем вторую строку
    ОТ i = 0 ДО длина2 - 1
        новая_строка[длина1 + i] = строка2[i]
    КОНЕЦ ОТ

    новая_строка[длина1 + длина2] = '\0'  // терминирующий символ
    ВОЗВРАТ новая_строка
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ДоступКСимволу(строка, индекс)
    ВХОД: строка - строка, индекс - позиция символа
    ВЫХОД: символ по указанному индексу

    ЕСЛИ индекс >= 0 И индекс < длина(строка) ТОГДА
        ВОЗВРАТ строка[индекс]
    ИНАЧЕ
        ВОЗВРАТ ОШИБКА "Индекс за пределами строки"
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
// Создание строк
const emptyString = "";
const literalString = "Привет, мир!";
const fromChar = String.fromCharCode(72, 101, 108, 108, 111); // 'Hello'
const fromSubstring = "Hello World".substring(0, 5);

// Конкатенация строк
const result = "Hello" + " " + "World";
const concatResult = "Hello".concat(" ", "World");

// Альтернативный способ создания строки из массива символов
const charArray = ['H', 'e', 'l', 'l', 'o'];
const fromCharArray = charArray.join('');
```

```java
// Создание строк
String emptyString = "";
String literalString = "Привет, мир!";
String fromChar = new String(new char[] {'H', 'e', 'l', 'l', 'o'});
String fromSubstring = "Hello World".substring(0, 5);

// Конкатенация строк
String result = "Hello" + " " + "World";
String concatResult = "Hello".concat(" ").concat("World");
```

### Доступ к символам

#### Псевдокод для доступа к символам строки:

```
АЛГОРИТМ ПереборСимволов(строка)
    ВХОД: строка - строка для перебора
    ВЫХОД: вывод каждого символа

    длина = длина(строка)
    ОТ i = 0 ДО длина - 1
        ВЫВОД "Символ " + i + ": " + строка[i]
    КОНЕЦ ОТ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ПреобразоватьВМассив(строка)
    ВХОД: строка - строка для преобразования
    ВЫХОД: массив символов

    длина = длина(строка)
    массив = выделить_массив(размер = длина)

    ОТ i = 0 ДО длина - 1
        массив[i] = строка[i]
    КОНЕЦ ОТ

    ВОЗВРАТ массив
КОНЕЦ АЛГОРИТМА
```

```javascript
const text = "Привет";
const firstChar = text.charAt(0); // 'П'
const lastChar = text.charAt(text.length - 1); // 'т'

// Перебор символов
for (let i = 0; i < text.length; i++) {
    console.log(`Символ ${i}: ${text.charAt(i)}`);
}

// Использование for...of
for (const char of text) {
    console.log(char);
}

// Преобразование в массив и перебор
for (const char of text) {
    console.log(char);
}
```

```java
String text = "Привет";
char firstChar = text.charAt(0); // 'П'
char lastChar = text.charAt(text.length() - 1); // 'т'

// Перебор символов
for (int i = 0; i < text.length(); i++) {
    System.out.println("Символ " + i + ": " + text.charAt(i));
}

// Использование foreach
for (char c : text.toCharArray()) {
    System.out.println(c);
}
```

### Сравнение строк

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

// Сравнение по значению
boolean isEqual = str1.equals(str2); // true
boolean isEqual2 = str1.equals(str3); // true

// Сравнение с игнорированием регистра
boolean caseInsensitive = str1.equalsIgnoreCase("HELLO"); // true

// Лексикографическое сравнение
int comparison = str1.compareTo("World"); // отрицательное число, т.к. "Hello" < "World"
```

## Операции поиска и извлечения

### Поиск подстроки

```java
String text = "Программирование на Java";
int index = text.indexOf("Java"); // возвращает 17
int lastIndex = text.lastIndexOf("а"); // возвращает 21
boolean contains = text.contains("Java"); // true

// Поиск с определенной позиции
int indexFrom = text.indexOf("а", 10); // поиск 'а' начиная с позиции 10
```

### Извлечение подстрок

```java
String text = "Программирование на Java";
String substring = text.substring(0, 12); // "Программиров"
String fromIndex = text.substring(17); // "Java"

// Разделение строки
String[] parts = "один,два,три".split(",");
String[] words = "Один Два Три".split("\\s+"); // по пробелам
```

## Изменение строк

```java
String original = "  Привет, мир!  ";

// Удаление пробелов
String trimmed = original.trim();

// Замена символов/подстрок
String replaced = original.replace("мир", "Вася");
String replacedRegex = original.replaceAll("\\s+", "_"); // замена всех пробелов на _

// Преобразование регистра
String upper = original.toUpperCase();
String lower = original.toLowerCase();

// Проверки
boolean starts = original.startsWith("  Привет");
boolean ends = original.endsWith("мир!  ");
boolean isEmpty = original.isEmpty();
boolean isBlank = original.isBlank(); // true для строки с только пробельными символами
```

## Алгоритмы обработки строк

### Проверка на палиндром

#### Псевдокод для проверки палиндрома:

```
АЛГОРИТМ ПроверитьПалиндром(строка)
    ВХОД: строка - строка для проверки
    ВЫХОД: true если строка является палиндромом, иначе false

    левый = 0
    правый = длина(строка) - 1

    ПОКА левый < правый ВЫПОЛНЯТЬ
        ЕСЛИ строка[левый] ≠ строка[правый] ТОГДА
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ
        левый = левый + 1
        правый = правый - 1
    КОНЕЦ ПОКА

    ВОЗВРАТ ИСТИНА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ПроверитьПалиндромАлфавитноцифровой(строка)
    ВХОД: строка - строка для проверки
    ВЫХОД: true если строка является палиндромом (только буквы и цифры), иначе false

    левый = 0
    правый = длина(строка) - 1

    ПОКА левый < правый ВЫПОЛНЯТЬ
        ПОКА левый < правый И НЕ (строка[левый] - буква ИЛИ строка[левый] - цифра) ВЫПОЛНЯТЬ
            левый = левый + 1
        КОНЕЦ ПОКА

        ПОКА левый < правый И НЕ (строка[правый] - буква ИЛИ строка[правый] - цифра) ВЫПОЛНЯТЬ
            правый = правый - 1
        КОНЕЦ ПОКА

        ЕСЛИ преобразовать_в_нижний(строка[левый]) ≠ преобразовать_в_нижний(строка[правый]) ТОГДА
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ

        левый = левый + 1
        правый = правый - 1
    КОНЕЦ ПОКА

    ВОЗВРАТ ИСТИНА
КОНЕЦ АЛГОРИТМА
```

```javascript
// Проверка палиндрома в JavaScript
function isPalindrome(s) {
    let left = 0;
    let right = s.length - 1;

    while (left < right) {
        if (s[left] !== s[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

// Палиндром с учетом только букв и цифр
function isPalindromeAlphanumeric(s) {
    let left = 0, right = s.length - 1;

    while (left < right) {
        while (left < right && !isAlphanumeric(s[left])) {
            left++;
        }
        while (left < right && !isAlphanumeric(s[right])) {
            right--;
        }

        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

// Вспомогательная функция для проверки алфавитно-цифрового символа
function isAlphanumeric(char) {
    return /[a-zA-Z0-9]/.test(char);
}
```

```java
public boolean isPalindrome(String s) {
    int left = 0;
    int right = s.length() - 1;

    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

// Палиндром с учетом только букв и цифр
public boolean isPalindromeAlphanumeric(String s) {
    int left = 0, right = s.length() - 1;

    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }

        if (Character.toLowerCase(s.charAt(left)) !=
            Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

### Поиск подстроки (Алгоритм Кнута-Морриса-Пратта)

```java
public int[] computeLPSArray(String pattern) {
    int len = 0;
    int i = 1;
    int[] lps = new int[pattern.length()];
    
    while (i < pattern.length()) {
        if (pattern.charAt(i) == pattern.charAt(len)) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

public List<Integer> kmpSearch(String text, String pattern) {
    List<Integer> result = new ArrayList<>();
    int[] lps = computeLPSArray(pattern);
    
    int i = 0; // индекс для text
    int j = 0; // индекс для pattern
    
    while (i < text.length()) {
        if (pattern.charAt(j) == text.charAt(i)) {
            i++;
            j++;
        }
        
        if (j == pattern.length()) {
            result.add(i - j);
            j = lps[j - 1];
        } else if (i < text.length() && pattern.charAt(j) != text.charAt(i)) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    return result;
}
```

### Редакционное расстояние (Расстояние Левенштейна)

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    
    int[][] dp = new int[m + 1][n + 1];
    
    // Инициализация базовых случаев
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(
                    Math.min(dp[i - 1][j], dp[i][j - 1]), // удаление, вставка
                    dp[i - 1][j - 1] // замена
                );
            }
        }
    }
    
    return dp[m][n];
}
```

## Эффективная работа со строками

### StringBuilder vs String concatenation

```java
// Неэффективный способ (создает много промежуточных строк)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += "a"; // создает новую строку на каждой итерации
}

// Эффективный способ
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("a");
}
String efficientResult = sb.toString();
```

### Работа с большими текстами

```java
// Использование StringBuilder для эффективной конкатенации
public String joinStrings(List<String> strings, String delimiter) {
    if (strings.isEmpty()) return "";
    
    StringBuilder sb = new StringBuilder();
    sb.append(strings.get(0));
    
    for (int i = 1; i < strings.size(); i++) {
        sb.append(delimiter);
        sb.append(strings.get(i));
    }
    
    return sb.toString();
}
```

## Регулярные выражения

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// Проверка email
String emailRegex = "^[A-Za-z0-9+_.-]+@(.+)$";
Pattern emailPattern = Pattern.compile(emailRegex);
Matcher emailMatcher = emailPattern.matcher("user@example.com");
boolean isEmail = emailMatcher.matches();

// Поиск чисел в строке
String textWithNumbers = "В тексте есть числа: 123, 456 и 789";
Pattern numberPattern = Pattern.compile("\\d+");
Matcher numberMatcher = numberPattern.matcher(textWithNumbers);

while (numberMatcher.find()) {
    System.out.println("Найдено число: " + numberMatcher.group());
}
```

## Практические применения

### В веб-разработке:
- Валидация пользовательского ввода
- Обработка URL и параметров запроса
- Работа с HTML/XML

### В поисковых системах:
- Поиск по ключевым словам
- Автодополнение запросов
- Обработка естественного языка

### В системах безопасности:
- Обнаружение SQL-инъекций
- Проверка форматов данных
- Фильтрация вредоносного кода

## Применение в индустрии

В современной IT-индустрии:
- Обработка строк важна для поисковых технологий
- Актуальны задачи на обработку естественного языка
- Важно понимание эффективности операций со строками
- Применяются в системах анализа текста и чат-ботах

Крупные технологические компании:
- Проверяют знание алгоритмов поиска подстрок
- Ожидают понимания различий между String, StringBuilder, StringBuffer
- Тестируют умение решать задачи на обработку текста
- Часто задают задачи на редакционное расстояние и палиндромы

## Часто используемые методы

| Метод | Описание | Сложность |
|-------|----------|-----------|
| length() | Длина строки | O(1) |
| charAt(i) | Символ по индексу | O(1) |
| substring(start, end) | Подстрока | O(n) |
| indexOf(str) | Поиск подстроки | O(n*m) |
| equals(str) | Сравнение строк | O(n) |
| replace(old, new) | Замена | O(n) |
| split(regex) | Разделение | O(n) |

## Примеры задач на собеседованиях

- Проверка анаграмм
- Поиск самой длинной подстроки без повторов
- Преобразование строки в число (atoi)
- Сериализация и десериализация строк
- Поиск всех перестановок строки

## Связанные темы

- [[Алгоритмы-поиска]]
- [[Динамическое-программирование]]
- [[Регулярные-выражения]]
- [[Текстовые-алгоритмы]]
- [[Хэш-таблицы]]

## Заключение

Обработка строк является важной темой в программировании, требующей понимания как базовых операций, так и сложных алгоритмов. Знание эффективных методов работы со строками остается критически важным как для прохождения технических собеседований, так и для решения реальных задач в разработке программного обеспечения.