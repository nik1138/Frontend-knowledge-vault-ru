---
aliases: ["Кучи", "Heap", "Binary Heap", "Пирамида"]
tags: ["#dsa", "#heap", "#data-structures", "#algorithms", "#priority-queue"]
---

# Кучи

## Введение

Куча (или пирамида) - это специализированная структура данных, удовлетворяющая свойству кучи. Кучи находят широкое применение в приоритетных очередях, алгоритмах сортировки, задачах оптимизации и системах планирования задач.

## Определение

**Куча** - это полное бинарное дерево, которое удовлетворяет свойству кучи:
- В **max-куче**: значение родителя больше или равно значений детей
- В **min-куче**: значение родителя меньше или равно значений детей

## Свойства кучи

### Структурное свойство:
- Куча должна быть полным бинарным деревом
- Все уровни, кроме, возможно, последнего, полностью заполнены
- Узлы на последнем уровне находятся как можно левее

### Свойство упорядоченности:
- Max-куча: для каждого узла i, heap[parent(i)] ≥ heap[i]
- Min-кucha: для каждого узла i, heap[parent(i)] ≤ heap[i]

## Реализация

### На основе массива:
- Корень находится по индексу 0
- Для узла с индексом i:
  - Левый потомок: 2*i + 1
  - Правый потомок: 2*i + 2
  - Родитель: (i-1)/2

#### Псевдокод для min-кучи:

```
СТРУКТУРА MinHeap
    ДАННЫЕ:
        heap[] - массив для хранения элементов кучи
        size - текущий размер кучи
        capacity - максимальная вместимость кучи

    МЕТОД parent(i)
        ВОЗВРАТ (i - 1) / 2
    КОНЕЦ МЕТОДА

    МЕТОД left(i)
        ВОЗВРАТ 2 * i + 1
    КОНЕЦ МЕТОДА

    МЕТОД right(i)
        ВОЗВРАТ 2 * i + 2
    КОНЕЦ МЕТОДА

    МЕТОД swap(i, j)
        ВРЕМЕННЫЙ = heap[i]
        heap[i] = heap[j]
        heap[j] = ВРЕМЕННЫЙ
    КОНЕЦ МЕТОДА

    МЕТОД heapify(i)
        левый = left(i)
        правый = right(i)
        smallest = i

        ЕСЛИ левый < size И heap[левый] < heap[smallest] ТОГДА
            smallest = левый
        КОНЕЦ ЕСЛИ

        ЕСЛИ правый < size И heap[правый] < heap[smallest] ТОГДА
            smallest = правый
        КОНЕЦ ЕСЛИ

        ЕСЛИ smallest ≠ i ТОГДА
            swap(i, smallest)
            heapify(smallest)
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД insert(value)
        ЕСЛИ size == capacity ТОГДА
            ВЫВОД "Куча переполнена"
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        heap[size] = value
        текущий = size
        size = size + 1

        // Восстановление свойства кучи
        ПОКА текущий ≠ 0 И heap[parent(текущий)] > heap[текущий] ВЫПОЛНЯТЬ
            swap(текущий, parent(текущий))
            текущий = parent(текущий)
        КОНЕЦ ПОКА
    КОНЕЦ МЕТОДА

    МЕТОД extractMin()
        ЕСЛИ size <= 0 ТОГДА
            ВЫВОД "Куча пуста"
            ВОЗВРАТ НИЧТО
        КОНЕЦ ЕСЛИ

        ЕСЛИ size == 1 ТОГДА
            size = size - 1
            ВОЗВРАТ heap[0]
        КОНЕЦ ЕСЛИ

        корень = heap[0]
        heap[0] = heap[size - 1]
        size = size - 1
        heapify(0)

        ВОЗВРАТ корень
    КОНЕЦ МЕТОДА

    МЕТОД getMin()
        ЕСЛИ size <= 0 ТОГДА
            ВЫВОД "Куча пуста"
            ВОЗВРАТ НИЧТО
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ heap[0]
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Пример реализации min-кучи на основе массива в JavaScript
class MinHeap {
    constructor(capacity) {
        this.heap = new Array(capacity);
        this.size = 0;
        this.capacity = capacity;
    }

    parent(i) { return Math.floor((i - 1) / 2); }
    left(i) { return 2 * i + 1; }
    right(i) { return 2 * i + 2; }

    swap(i, j) {
        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }

    // Восстановление свойства кучи
    heapify(i) {
        let left = this.left(i);
        let right = this.right(i);
        let smallest = i;

        if (left < this.size && this.heap[left] < this.heap[smallest]) {
            smallest = left;
        }

        if (right < this.size && this.heap[right] < this.heap[smallest]) {
            smallest = right;
        }

        if (smallest !== i) {
            this.swap(i, smallest);
            this.heapify(smallest);
        }
    }

    // Вставка элемента
    insert(value) {
        if (this.size === this.capacity) {
            throw new Error("Heap is full");
        }

        let current = this.size;
        this.heap[current] = value;
        this.size++;

        // Восстановление свойства кучи
        while (current !== 0 && this.heap[this.parent(current)] > this.heap[current]) {
            this.swap(current, this.parent(current));
            current = this.parent(current);
        }
    }

    // Извлечение минимального элемента
    extractMin() {
        if (this.size <= 0) {
            throw new Error("Heap is empty");
        }

        if (this.size === 1) {
            this.size--;
            return this.heap[0];
        }

        const root = this.heap[0];
        this.heap[0] = this.heap[this.size - 1];
        this.size--;
        this.heapify(0);

        return root;
    }

    // Получение минимального элемента без извлечения
    getMin() {
        if (this.size <= 0) {
            throw new Error("Heap is empty");
        }
        return this.heap[0];
    }
}

// Пример использования
const minHeap = new MinHeap(10);
minHeap.insert(3);
minHeap.insert(2);
minHeap.insert(15);
console.log(minHeap.getMin()); // 2
console.log(minHeap.extractMin()); // 2
console.log(minHeap.getMin()); // 3
```


## Основные операции

### Операции с кучей:
- **Вставка (insert)**: O(log n)
- **Извлечение минимума/максимума**: O(log n)
- **Получение минимума/максимума**: O(1)
- **Построение кучи**: O(n)

#### Псевдокод для операций с кучей:

```
АЛГОРИТМ Вставка(куча, значение)
    ВХОД: куча - структура данных кучи, значение - вставляемое значение
    ВЫХОД: обновленная куча

    куча[куча.размер] = значение
    текущий = куча.размер
    куча.размер = куча.размер + 1

    ПОКА текущий ≠ 0 И куча[родитель(текущий)] > куча[текущий] ВЫПОЛНЯТЬ
        ПОМЕНЯТЬ местами куча[текущий] и куча[родитель(текущий)]
        текущий = родитель(текущий)
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ИзвлечьМинимум(куча)
    ВХОД: куча - структура данных кучи
    ВЫХОД: минимальное значение

    ЕСЛИ куча.размер ≤ 0 ТОГДА
        ВОЗВРАТ ОШИБКА "Куча пуста"
    КОНЕЦ ЕСЛИ

    ЕСЛИ куча.размер = 1 ТОГДА
        куча.размер = куча.размер - 1
        ВОЗВРАТ куча[0]
    КОНЕЦ ЕСЛИ

    корень = куча[0]
    куча[0] = куча[куча.размер - 1]
    куча.размер = куча.размер - 1
    heapify(куча, 0)

    ВОЗВРАТ корень
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ heapify(куча, i)
    ВХОД: куча - структура данных кучи, i - индекс узла для восстановления свойства кучи
    ВЫХОД: обновленная куча

    левый = 2 * i + 1
    правый = 2 * i + 2
    минимальный = i

    ЕСЛИ левый < куча.размер И куча[левый] < куча[минимальный] ТОГДА
        минимальный = левый
    КОНЕЦ ЕСЛИ

    ЕСЛИ правый < куча.размер И куча[правый] < куча[минимальный] ТОГДА
        минимальный = правый
    КОНЕЦ ЕСЛИ

    ЕСЛИ минимальный ≠ i ТОГДА
        ПОМЕНЯТЬ местами куча[i] и куча[минимальный]
        heapify(куча, минимальный)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
// Пример использования кучи в JavaScript
const minHeap = new MinHeap(10);
minHeap.insert(3);
minHeap.insert(2);
minHeap.insert(15);
minHeap.insert(5);
minHeap.insert(4);
minHeap.insert(45);

console.log(minHeap.getMin()); // Выводит 2
console.log(minHeap.extractMin()); // Выводит 2
console.log(minHeap.getMin()); // Выводит 3
```


## Виды куч

### Бинарная куча:
- Наиболее распространенная реализация
- Каждый узел имеет не более двух потомков

### d-ичная куча:
- Каждый узел имеет до d потомков
- Более широкое дерево, но меньшая высота

### Фибоначчиева куча:
- Более сложная структура с лучшей амортизированной сложностью
- Используется в алгоритмах, где часто выполняется уменьшение ключа

## Алгоритм сортировки кучей (Heap Sort)

```javascript
// Реализация сортировки кучей
function heapSort(arr) {
    const n = arr.length;

    // Построение max-кучи
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Извлечение элементов из кучи по одному
    for (let i = n - 1; i > 0; i--) {
        // Перемещаем текущий корень в конец
        [arr[0], arr[i]] = [arr[i], arr[0]];

        // Вызываем heapify на уменьшенной куче
        heapify(arr, i, 0);
    }
}

function heapify(arr, n, i) {
    let largest = i; // Инициализируем наибольший элемент как корень
    let left = 2 * i + 1;
    let right = 2 * i + 2;

    // Если левый потомок больше корня
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // Если правый потомок больше, чем самый большой элемент на данный момент
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // Если самый большой элемент не корень
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];

        // Рекурсивно преобразуем затронутое поддерево
        heapify(arr, n, largest);
    }
}

// Пример использования
const array = [64, 34, 25, 12, 22, 11, 90];
console.log("До сортировки:", array);
heapSort(array);
console.log("После сортировки:", array);
```


## Применения

### В приоритетных очередях:
- Планирование задач в операционных системах
- Алгоритмы графов (Дейкстра, Прима)
- Обработка событий в реальном времени

### В сортировке:
- Сортировка кучей с гарантированной O(n log n)
- Часто используется в embedded системах

### В задачах оптимизации:
- Нахождение k наименьших/наибольших элементов
- Слияние отсортированных списков
- Задачи на медиану потока

## Сложность операций

| Операция | Время |
|----------|-------|
| Вставка | O(log n) |
| Извлечение | O(log n) |
| Получение min/max | O(1) |
| Построение | O(n) |
| Сортировка | O(n log n) |

## Применение в индустрии

В современной IT-индустрии:
- Кучи активно используются в системах планирования задач
- Важны для реализации алгоритмов графов
- Применяются в системах рекомендаций для выбора наиболее релевантных элементов
- Используются в финансовых системах для обработки ордеров

Крупные технологические компании:
- Проверяют знание реализации кучи и операций над ней
- Ожидают понимания различий между min- и max-кучей
- Тестируют умение применять кучи для решения задач
- Часто задают задачи на приоритетные очереди

## Преимущества и недостатки

### Преимущества:
- Быстрое извлечение максимального/минимального элемента
- Эффективная реализация приоритетной очереди
- Гарантированная сложность операций
- Эффективное использование памяти

### Недостатки:
- Нет эффективного поиска произвольного элемента
- Нарушение кэш-локальности из-за прыжков по памяти
- Сложнее реализовать по сравнению с простыми структурами

## Примеры задач на собеседованиях

- Найти k-й по величине элемент
- Слияние k отсортированных списков
- Непрерывная медиана
- Планирование задач с приоритетами
- Алгоритм Дейкстры

## Связанные темы

- [[Стеки-и-очереди]]
- [[Алгоритмы-сортировки]]
- [[Графы]]
- [[Бинарные-деревья-поиска]]
- [[Алгоритмы-на-графах]]

## Заключение

Кучи являются важной структурой данных, обеспечивающей эффективную работу с приоритетами. Знание куч и умение их применять остается критически важным как для прохождения технических собеседований, так и для решения задач оптимизации и планирования в разработке программного обеспечения.