---
aliases: ["Стеки и очереди", "Стек", "Очередь", "Stack and Queue"]
tags: ["#dsa", "#stack", "#queue", "#data-structures", "#algorithms"]
---

# Стеки и очереди

## Введение

Стеки и очереди - это абстрактные структуры данных, основанные на принципах LIFO (Last In, First Out) и FIFO (First In, First Out) соответственно. Эти структуры широко применяются в разработке программного обеспечения, особенно в системах, требующих управления последовательностью операций.

## Определение

### Стек (Stack)
**Стек** - это структура данных, работающая по принципу "последним пришёл - первым ушёл" (LIFO). Элементы добавляются и удаляются только с одного конца, называемого "вершиной" стека.

### Очередь (Queue)
**Очередь** - это структура данных, работающая по принципу "первым пришёл - первым ушёл" (FIFO). Элементы добавляются в конец очереди и удаляются из начала.

## Операции с стеком

### Основные операции стека:
- **push(item)** - добавление элемента на вершину стека
- **pop()** - удаление и возврат элемента с вершины стека
- **peek()/top()** - возврат элемента с вершины стека без удаления
- **isEmpty()** - проверка, пуст ли стек
- **size()** - возврат количества элементов в стеке

#### Псевдокод для операций стека:

```
СТРУКТУРА Стек
    ДАННЫЕ:
        элементы[] - массив для хранения элементов
        вершина - индекс вершины стека
        максимальный_размер - максимальный размер стека

    МЕТОД push(элемент)
        ЕСЛИ вершина < максимальный_размер - 1 ТОГДА
            вершина = вершина + 1
            элементы[вершина] = элемент
        ИНАЧЕ
            ВЫВОД "Стек переполнен"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД pop()
        ЕСЛИ вершина >= 0 ТОГДА
            элемент = элементы[вершина]
            вершина = вершина - 1
            ВОЗВРАТ элемент
        ИНАЧЕ
            ВОЗВРАТ ОШИБКА "Стек пуст"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД peek()
        ЕСЛИ вершина >= 0 ТОГДА
            ВОЗВРАТ элементы[вершина]
        ИНАЧЕ
            ВОЗВРАТ ОШИБКА "Стек пуст"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД isEmpty()
        ВОЗВРАТ (вершина < 0)
    КОНЕЦ МЕТОДА

    МЕТОД size()
        ВОЗВРАТ вершина + 1
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ ПримерИспользованияСтека
    стек = НОВЫЙ Стек(10)  // Создаем стек размером 10

    стек.push(10)
    стек.push(20)
    элемент = стек.pop()    // Возвращает 20
    элемент = стек.peek()   // Возвращает 10
КОНЕЦ АЛГОРИТМА
```

```javascript
// Пример реализации стека в JavaScript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.isEmpty()) {
            return "Стек пуст";
        }
        return this.items.pop();
    }

    peek() {
        if (this.isEmpty()) {
            return "Стек пуст";
        }
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}

// Пример использования
const stack = new Stack();
stack.push(10);
stack.push(20);
const topElement = stack.pop(); // Возвращает 20
const peekElement = stack.peek(); // Возвращает 10
```

```java
// Пример реализации стека в Java
import java.util.Stack;

Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.push(20);
int topElement = stack.pop(); // Возвращает 20
int peekElement = stack.peek(); // Возвращает 10
```

## Операции с очередью

### Основные операции очереди:
- **enqueue(item)** - добавление элемента в конец очереди
- **dequeue()** - удаление и возврат элемента из начала очереди
- **front()/peek()** - возврат элемента из начала очереди без удаления
- **isEmpty()** - проверка, пуста ли очередь
- **size()** - возврат количества элементов в очереди

#### Псевдокод для операций очереди:

```
СТРУКТУРА Очередь
    ДАННЫЕ:
        элементы[] - массив для хранения элементов
        начало - индекс начала очереди
        конец - индекс конца очереди
        размер - текущий размер очереди
        максимальный_размер - максимальный размер очереди

    МЕТОД enqueue(элемент)
        ЕСЛИ размер < максимальный_размер ТОГДА
            элементы[конец] = элемент
            конец = (конец + 1) МОДУЛЬ максимальный_размер
            размер = размер + 1
        ИНАЧЕ
            ВЫВОД "Очередь переполнена"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД dequeue()
        ЕСЛИ размер > 0 ТОГДА
            элемент = элементы[начало]
            начало = (начало + 1) МОДУЛЬ максимальный_размер
            размер = размер - 1
            ВОЗВРАТ элемент
        ИНАЧЕ
            ВОЗВРАТ ОШИБКА "Очередь пуста"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД peek()
        ЕСЛИ размер > 0 ТОГДА
            ВОЗВРАТ элементы[начало]
        ИНАЧЕ
            ВОЗВРАТ ОШИБКА "Очередь пуста"
        КОНЕЦ ЕСЛИ
    КОНЕЦ МЕТОДА

    МЕТОД isEmpty()
        ВОЗВРАТ (размер == 0)
    КОНЕЦ МЕТОДА

    МЕТОД size()
        ВОЗВРАТ размер
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ ПримерИспользованияОчереди
    очередь = НОВЫЙ Очередь(10)  // Создаем очередь размером 10

    очередь.enqueue(10)
    очередь.enqueue(20)
    элемент = очередь.dequeue()    // Возвращает 10
    элемент = очередь.peek()      // Возвращает 20
КОНЕЦ АЛГОРИТМА
```

```javascript
// Пример реализации очереди в JavaScript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) {
            return "Очередь пуста";
        }
        return this.items.shift();
    }

    peek() {
        if (this.isEmpty()) {
            return "Очередь пуста";
        }
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}

// Пример использования
const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
const frontElement = queue.dequeue(); // Возвращает 10
const peekElement = queue.peek(); // Возвращает 20
```

```java
// Пример реализации очереди в Java
import java.util.LinkedList;
import java.util.Queue;

Queue<Integer> queue = new LinkedList<>();
queue.offer(10); // или add(10)
queue.offer(20);
int frontElement = queue.poll(); // Возвращает 10
int peekElement = queue.peek(); // Возвращает 20
```

## Реализации

### Реализация стека:
- На основе массива (фиксированный размер или динамический массив)
- На основе связного списка
- С использованием встроенных классов (например, `java.util.Stack`)

### Реализация очереди:
- На основе массива (циклический буфер)
- На основе связного списка
- С использованием встроенных классов (например, `java.util.LinkedList` как очередь)

## Сложность операций

### Стек:
- Push: O(1)
- Pop: O(1)
- Peek: O(1)
- isEmpty: O(1)

### Очередь:
- Enqueue: O(1)
- Dequeue: O(1)
- Peek: O(1)
- isEmpty: O(1)

## Практические применения

### Применения стека:
- Обработка вызовов функций (стек вызовов)
- Обработка выражений (например, преобразование инфиксной записи в постфиксную)
- Отмена операций (Undo в текстовых редакторах)
- Проверка сбалансированности скобок
- Алгоритмы обхода графов (DFS)

### Применения очереди:
- Обработка задач по принципу "первым пришёл - первым обслужен"
- Алгоритмы поиска в ширину (BFS)
- Буферизация данных
- Планирование задач в операционных системах
- Асинхронная обработка запросов

## Вариации структур

### Дек (Deque - Double-ended queue)
- Элементы можно добавлять и удалять с обоих концов
- Объединяет возможности стека и очереди

### Приоритетная очередь
- Элементы извлекаются в зависимости от их приоритета
- Реализуется с помощью кучи

## Применение в индустрии

В современной IT-индустрии:
- Стеки и очереди активно используются в разработке высоконагруженных систем
- Особое внимание уделяется эффективности реализации и минимизации накладных расходов
- Часто используются в банковских и финансовых приложениях для обработки транзакций
- Важны при реализации алгоритмов обхода графов в социальных сетях

Крупные технологические компании проверяют понимание:
- Различий между стеком и очередью
- Практических применений каждой структуры
- Умения реализовать стек или очередь с нуля
- Знания встроенных реализаций в различных языках

## Примеры задач на собеседованиях

- Проверка сбалансированности скобок
- Обратное вывод строки
- Оценка постфиксных выражений
- Реализация LRU-кэша
- Задачи на BFS/DFS с использованием стека/очереди

## Связанные темы

- [[Массивы-и-списки]]
- [[Связные-списки]]
- [[Деревья]]
- [[Графы]]
- [[Алгоритмы-поиска]]

## Заключение

Стеки и очереди являются важными структурами данных, применяемыми во множестве алгоритмов и систем. Знание этих структур остается критически важным для прохождения собеседований и эффективной разработки программного обеспечения.