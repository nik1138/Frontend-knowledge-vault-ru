---
aliases: ["Бинарные деревья поиска", "BST", "Binary Search Tree"]
tags: ["#dsa", "#bst", "#binary-search-tree", "#data-structures", "#algorithms", "#tree"]
---

# Бинарные деревья поиска

## Введение

Бинарное дерево поиска (BST - Binary Search Tree) - это особый вид бинарного дерева, в котором для каждого узла все элементы в левом поддереве меньше значения узла, а все элементы в правом поддереве больше значения узла. BST находят широкое применение в базах данных, поисковых системах и алгоритмах сортировки.

## Определение

**Бинарное дерево поиска** - это бинарное дерево, в котором для каждого узла выполняются следующие условия:
- Все значения в левом поддереве меньше значения узла
- Все значения в правом поддереве больше значения узла
- Оба поддерева также являются бинарными деревьями поиска

## Структура узла

```javascript
// Определение узла бинарного дерева поиска
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## Основные операции

### Поиск (Search)
- Время: O(log n) для сбалансированного дерева, O(n) для вырожденного
- Алгоритм: рекурсивное или итеративное сравнение с корнем

#### Псевдокод для поиска в BST:

```
АЛГОРИТМ РекурсивныйПоиск(корень, значение)
    ВХОД: корень - корень дерева, значение - искомое значение
    ВЫХОД: узел с искомым значением или NULL

    ЕСЛИ корень = NULL ИЛИ корень.значение = значение ТОГДА
        ВОЗВРАТ корень
    КОНЕЦ ЕСЛИ

    ЕСЛИ значение < корень.значение ТОГДА
        ВОЗВРАТ РекурсивныйПоиск(корень.левый, значение)
    ИНАЧЕ
        ВОЗВРАТ РекурсивныйПоиск(корень.правый, значение)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ИтеративныйПоиск(корень, значение)
    ВХОД: корень - корень дерева, значение - искомое значение
    ВЫХОД: узел с искомым значением или NULL

    текущий = корень
    ПОКА текущий ≠ NULL И текущий.значение ≠ значение ВЫПОЛНЯТЬ
        ЕСЛИ значение < текущий.значение ТОГДА
            текущий = текущий.левый
        ИНАЧЕ
            текущий = текущий.правый
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА

    ВОЗВРАТ текущий
КОНЕЦ АЛГОРИТМА
```

```javascript
// Рекурсивный поиск
function searchBST(root, val) {
    if (root === null || root.val === val) {
        return root;
    }

    if (val < root.val) {
        return searchBST(root.left, val);
    } else {
        return searchBST(root.right, val);
    }
}

// Итеративный поиск
function searchBSTIterative(root, val) {
    let current = root;
    while (current !== null && current.val !== val) {
        if (val < current.val) {
            current = current.left;
        } else {
            current = current.right;
        }
    }
    return current;
}
```

```java
// Рекурсивный поиск
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null || root.val == val) {
        return root;
    }

    if (val < root.val) {
        return searchBST(root.left, val);
    } else {
        return searchBST(root.right, val);
    }
}

// Итеративный поиск
function searchBSTIterative(root, val) {
    while (root !== null && root.val !== val) {
        if (val < root.val) {
            root = root.left;
        } else {
            root = root.right;
        }
    }
    return root;
}
```

### Вставка (Insert)
- Время: O(log n) для сбалансированного дерева, O(n) для вырожденного
- Алгоритм: рекурсивное или итеративное движение к листу с последующей вставкой

```javascript
// Рекурсивная вставка
function insertIntoBST(root, val) {
    if (root === null) {
        return new TreeNode(val);
    }

    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else if (val > root.val) {
        root.right = insertIntoBST(root.right, val);
    }

    return root;
}

// Итеративная вставка
function insertIntoBSTIterative(root, val) {
    if (root === null) {
        return new TreeNode(val);
    }

    let current = root;
    while (true) {
        if (val < current.val) {
            if (current.left === null) {
                current.left = new TreeNode(val);
                break;
            }
            current = current.left;
        } else {
            if (current.right === null) {
                current.right = new TreeNode(val);
                break;
            }
            current = current.right;
        }
    }
    return root;
}
```

### Удаление (Delete)
- Время: O(log n) для сбалансированного дерева, O(n) для вырожденного
- Три случая: узел без потомков, с одним потомком, с двумя потомками

#### Псевдокод для удаления узла в BST:

```
АЛГОРИТМ УдалитьУзел(корень, ключ)
    ВХОД: корень - корень дерева, ключ - значение для удаления
    ВЫХОД: обновленный корень дерева

    ЕСЛИ корень = NULL ТОГДА
        ВОЗВРАТ NULL
    КОНЕЦ ЕСЛИ

    ЕСЛИ ключ < корень.значение ТОГДА
        корень.левый = УдалитьУзел(корень.левый, ключ)
    ИНАЧЕ ЕСЛИ ключ > корень.значение ТОГДА
        корень.правый = УдалитьУзел(корень.правый, ключ)
    ИНАЧЕ
        // Найден узел для удаления

        // Случай 1: узел без потомков
        ЕСЛИ корень.левый = NULL И корень.правый = NULL ТОГДА
            ВОЗВРАТ NULL
        КОНЕЦ ЕСЛИ

        // Случай 2: узел с одним потомком
        ЕСЛИ корень.левый = NULL ТОГДА
            ВОЗВРАТ корень.правый
        ИНАЧЕ ЕСЛИ корень.правый = NULL ТОГДА
            ВОЗВРАТ корень.левый
        КОНЕЦ ЕСЛИ

        // Случай 3: узел с двумя потомками
        // Находим минимальное значение в правом поддереве
        minNode = НайтиМин(корень.правый)

        // Заменяем значение удаляемого узла
        корень.значение = minNode.значение

        // Удаляем минимальный узел из правого поддерева
        корень.правый = УдалитьУзел(корень.правый, minNode.значение)
    КОНЕЦ ЕСЛИ

    ВОЗВРАТ корень
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ НайтиМин(узел)
    ВХОД: узел - корень поддерева
    ВЫХОД: узел с минимальным значением

    ПОКА узел.левый ≠ NULL ВЫПОЛНЯТЬ
        узел = узел.левый
    КОНЕЦ ПОКА

    ВОЗВРАТ узел
КОНЕЦ АЛГОРИТМА
```

```javascript
// Удаление узла в JavaScript
function deleteNode(root, key) {
    if (root === null) {
        return null;
    }

    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        // Найден узел для удаления

        // Случай 1: узел без потомков
        if (root.left === null && root.right === null) {
            return null;
        }

        // Случай 2: узел с одним потомком
        if (root.left === null) {
            return root.right;
        }
        if (root.right === null) {
            return root.left;
        }

        // Случай 3: узел с двумя потомками
        // Находим минимальное значение в правом поддереве
        const minNode = findMin(root.right);

        // Заменяем значение удаляемого узла
        root.val = minNode.val;

        // Удаляем минимальный узел из правого поддерева
        root.right = deleteNode(root.right, minNode.val);
    }

    return root;
}

function findMin(node) {
    while (node.left !== null) {
        node = node.left;
    }
    return node;
}
```

```javascript
// Удаление узла
function deleteNode(root, key) {
    if (root === null) {
        return null;
    }

    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        // Найден узел для удаления

        // Случай 1: узел без потомков
        if (root.left === null && root.right === null) {
            return null;
        }

        // Случай 2: узел с одним потомком
        if (root.left === null) {
            return root.right;
        }
        if (root.right === null) {
            return root.left;
        }

        // Случай 3: узел с двумя потомками
        // Находим минимальное значение в правом поддереве
        const minNode = findMin(root.right);

        // Заменяем значение удаляемого узла
        root.val = minNode.val;

        // Удаляем минимальный узел из правого поддерева
        root.right = deleteNode(root.right, minNode.val);
    }

    return root;
}

function findMin(node) {
    while (node.left !== null) {
        node = node.left;
    }
    return node;
}
```

## Обходы BST

### In-order обход (по возрастанию)
- Возвращает отсортированную последовательность
- Время: O(n)

```javascript
// Рекурсивный in-order обход
function inorderTraversal(root) {
    if (root !== null) {
        inorderTraversal(root.left);
        console.log(root.val + " ");
        inorderTraversal(root.right);
    }
}

// Итеративный in-order обход с использованием стека
function inorderTraversalIterative(root) {
    const result = [];
    const stack = [];
    let current = root;

    while (current !== null || stack.length > 0) {
        while (current !== null) {
            stack.push(current);
            current = current.left;
        }

        current = stack.pop();
        result.push(current.val);
        current = current.right;
    }

    return result;
}
```

## Реализация BST

```javascript
// Полная реализация BST
class BinarySearchTree {
    constructor() {
        this.root = null;
    }

    insert(val) {
        this.root = this.insertRec(this.root, val);
    }

    insertRec(root, val) {
        if (root === null) {
            root = new TreeNode(val);
            return root;
        }

        if (val < root.val) {
            root.left = this.insertRec(root.left, val);
        } else if (val > root.val) {
            root.right = this.insertRec(root.right, val);
        }

        return root;
    }

    search(val) {
        return this.searchRec(this.root, val) !== null;
    }

    searchRec(root, val) {
        if (root === null || root.val === val) {
            return root;
        }

        if (val < root.val) {
            return this.searchRec(root.left, val);
        }
        return this.searchRec(root.right, val);
    }

    delete(val) {
        this.root = this.deleteRec(this.root, val);
    }

    deleteRec(root, val) {
        if (root === null) {
            return root;
        }

        if (val < root.val) {
            root.left = this.deleteRec(root.left, val);
        } else if (val > root.val) {
            root.right = this.deleteRec(root.right, val);
        } else {
            if (root.left === null) {
                return root.right;
            } else if (root.right === null) {
                return root.left;
            }

            root.val = this.findMin(root.right).val;
            root.right = this.deleteRec(root.right, root.val);
        }

        return root;
    }

    findMin(root) {
        while (root.left !== null) {
            root = root.left;
        }
        return root;
    }
}
```

## Сложность операций

| Операция | Средний случай | Худший случай |
|----------|----------------|---------------|
| Поиск | O(log n) | O(n) |
| Вставка | O(log n) | O(n) |
| Удаление | O(log n) | O(n) |
| Обход | O(n) | O(n) |

## Сбалансированные BST

### Проблема:
- BST может вырождаться в список при вставке отсортированных данных
- В худшем случае все операции становятся O(n)

### Решения:
- **AVL-деревья** - самобалансирующиеся деревья с высотным балансом
- **Красно-черные деревья** - самобалансирующиеся деревья с цветовым балансом
- **Splay-деревья** - деревья, которые перемещают часто используемые элементы к корню

## Практические применения

### В базах данных:
- Индексация для быстрого поиска
- Оптимизация запросов

### В поисковых системах:
- Организация индексов документов
- Сортировка результатов

### В компиляторах:
- Организация таблиц символов
- Управление областью видимости

### В операционных системах:
- Управление виртуальной памятью
- Планирование задач

## Применение в индустрии

В современной IT-индустрии:
- BST активно используются в поисковых технологиях
- Применяются в системах хранения и индексации данных
- Важны для построения рекомендательных систем
- Используются в алгоритмах машинного обучения

Крупные технологические компании:
- Проверяют понимание свойств BST
- Ожидают умения реализовать основные операции
- Тестируют знание различий между сбалансированными и обычными BST
- Часто задают задачи на модификацию BST

## Преимущества и недостатки

### Преимущества:
- Упорядоченность данных
- Быстрые операции поиска, вставки и удаления в среднем случае
- Возможность получения отсортированной последовательности
- Меньше памяти по сравнению с хэш-таблицами

### Недостатки:
- Худшая производительность при вырождении в список
- Сложнее реализации по сравнению с хэш-таблицами
- Нет прямого доступа к элементам по индексу

## Примеры задач на собеседованиях

- Проверка корректности BST
- Найти k-й наименьший элемент
- Найти ближайшее значение к заданному
- Преобразовать отсортированный массив в BST
- Найти пересечение двух BST

## Связанные темы

- [[Деревья]]
- [[Хэш-таблицы]]
- [[Алгоритмы-сортировки]]
- [[Графы]]
- [[Кучи]]

## Заключение

Бинарные деревья поиска являются важной структурой данных, обеспечивающей эффективный поиск, вставку и удаление в отсортированной последовательности. Знание BST и умение их использовать остается критически важным как для прохождения технических собеседований, так и для решения задач, требующих поддержания упорядоченности данных.