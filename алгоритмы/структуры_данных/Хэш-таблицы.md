---
aliases: ["Хэш-таблицы", "Hash Table", "Hash Map", "Хэш-карта"]
tags: ["#dsa", "#hash-table", "#hash-map", "#data-structures", "#algorithms", "#performance"]
---

# Хэш-таблицы

## Введение

Хэш-таблица - это структура данных, обеспечивающая эффективный доступ к данным за среднее время O(1). Хэш-таблицы являются одной из самых важных и часто используемых структур данных, применяемых в базах данных, кэшировании, веб-разработке и многих других областях.

## Определение

**Хэш-таблица** (или хэш-карта) - это структура данных, реализующая абстрактный тип данных "ассоциативный массив", который позволяет хранить пары "ключ-значение". Доступ к значениям осуществляется через вычисление хэш-функции от ключа.

## Основные компоненты

### Хэш-функция
Функция, преобразующая ключ в индекс массива. Хорошая хэш-функция:
- Равномерно распределяет ключи по индексам
- Быстро вычисляется
- Минимизирует коллизии

### Корзина (Bucket)
Место в массиве, куда помещается пара "ключ-значение" по вычисленному индексу.

## Принцип работы

1. При вставке вычисляется хэш от ключа
2. По хэшу определяется индекс в массиве
3. Значение помещается в соответствующую корзину
4. При поиске повторяется тот же процесс

## Обработка коллизий

Коллизия - ситуация, когда разные ключи дают одинаковый хэш.

### Метод цепочек (Separate Chaining)
- Каждая корзина содержит список (или другую структуру) пар "ключ-значение"
- При коллизии новая пара добавляется в список

#### Псевдокод для хэш-таблицы с методом цепочек:

```
СТРУКТУРА Запись
    ДАННЫЕ:
        ключ
        значение
        следующая_запись - указатель на следующую запись
КОНЕЦ СТРУКТУРЫ

СТРУКТУРА ХэшТаблица
    ДАННЫЕ:
        корзины[] - массив списков для хранения записей
        размер - текущее количество записей
        вместимость - максимальное количество корзин

    МЕТОД инициализировать()
        вместимость = 16
        РАЗМЕР корзины = вместимость
        размер = 0
        ОТ i = 0 ДО вместимость-1
            корзины[i] = ПУСТОЙ_СПИСОК
        КОНЕЦ ОТ
    КОНЕЦ МЕТОДА

    МЕТОД получитьИндексКорзины(ключ)
        хэш = вычислитьХэш(ключ)
        ВОЗВРАТ |хэш| МОДУЛЬ вместимость
    КОНЕЦ МЕТОДА

    МЕТОД вставить(ключ, значение)
        индекс = получитьИндексКорзины(ключ)
        список = корзины[индекс]

        ДЛЯ каждой записи В список ВЫПОЛНЯТЬ
            ЕСЛИ запись.ключ = ключ ТОГДА
                запись.значение = значение
                ВОЗВРАТ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        НОВАЯ_ЗАПИСЬ = НОВАЯ Запись(ключ, значение)
        ДОБАВИТЬ список, НОВАЯ_ЗАПИСЬ
        размер = размер + 1
    КОНЕЦ МЕТОДА

    МЕТОД получить(ключ)
        индекс = получитьИндексКорзины(ключ)
        список = корзины[индекс]

        ДЛЯ каждой записи В список ВЫПОЛНЯТЬ
            ЕСЛИ запись.ключ = ключ ТОГДА
                ВОЗВРАТ запись.значение
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ НИЧТО
    КОНЕЦ МЕТОДА

    МЕТОД удалить(ключ)
        индекс = получитьИндексКорзины(ключ)
        список = корзины[индекс]

        ДЛЯ каждой записи В список ВЫПОЛНЯТЬ
            ЕСЛИ запись.ключ = ключ ТОГДА
                УДАЛИТЬ запись ИЗ список
                размер = размер - 1
                ВОЗВРАТ ИСТИНА
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ МЕТОДА
КОНЕЦ СТРУКТУРЫ
```

```javascript
// Пример реализации хэш-таблицы с методом цепочек в JavaScript
class HashTable {
    constructor() {
        this.buckets = [];
        this.capacity = 16;
        this.size = 0;

        // Инициализируем пустые массивы для каждой корзины
        for (let i = 0; i < this.capacity; i++) {
            this.buckets[i] = [];
        }
    }

    // Простая хэш-функция
    getBucketIndex(key) {
        let hash = 0;
        const str = String(key);
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Преобразование в 32-битное целое
        }
        return Math.abs(hash) % this.capacity;
    }

    put(key, value) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        // Проверяем, существует ли уже запись с таким ключом
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket[i][1] = value; // Обновляем значение
                return;
            }
        }

        // Добавляем новую запись
        bucket.push([key, value]);
        this.size++;
    }

    get(key) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                return bucket[i][1];
            }
        }

        return null;
    }

    remove(key) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i][0] === key) {
                bucket.splice(i, 1);
                this.size--;
                return true;
            }
        }

        return false;
    }
}

// Пример использования
const hashTable = new HashTable();
hashTable.put("ключ1", 100);
hashTable.put("ключ2", 200);
console.log(hashTable.get("ключ1")); // 100
hashTable.remove("ключ1");
```

```javascript
// Пример реализации хэш-таблицы с методом цепочек
class HashTable {
    constructor(initialCapacity = 16) {
        this.buckets = new Array(initialCapacity);
        for (let i = 0; i < initialCapacity; i++) {
            this.buckets[i] = [];
        }
        this.size = 0;
    }

    // Простая хэш-функция
    getBucketIndex(key) {
        let hash = 0;
        const str = String(key);
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0; // Преобразуем в 32-битное целое
        }
        return Math.abs(hash) % this.buckets.length;
    }

    put(key, value) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key === key) {
                bucket[i].value = value;
                return;
            }
        }

        bucket.push({ key, value });
        this.size++;
    }

    get(key) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key === key) {
                return bucket[i].value;
            }
        }

        return undefined;
    }

    remove(key) {
        const index = this.getBucketIndex(key);
        const bucket = this.buckets[index];

        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key === key) {
                bucket.splice(i, 1);
                this.size--;
                return true;
            }
        }

        return false;
    }
}
```

### Открытая адресация (Open Addressing)
- Все элементы хранятся непосредственно в массиве
- При коллизии ищется следующая свободная ячейка
- Варианты: линейный пробинг, квадратичный пробинг, двойное хэширование

## Операции и сложность

### Основные операции:
- **Вставка (put)**: O(1) в среднем случае
- **Поиск (get)**: O(1) в среднем случае
- **Удаление (remove)**: O(1) в среднем случае

### В худшем случае (при многих коллизиях):
- Все операции: O(n)

## Встроенные реализации

### В Java:
- `HashMap` - основная реализация хэш-таблицы
- `LinkedHashMap` - сохраняет порядок вставки
- `TreeMap` - основан на красно-черном дереве

### В Python:
- `dict` - встроенная хэш-таблица
- `collections.defaultdict`
- `collections.OrderedDict`

```javascript
// Пример использования Map в JavaScript
const map = new Map();
map.set("ключ1", 100);
map.set("ключ2", 200);
const value = map.get("ключ1"); // Возвращает 100
const exists = map.has("ключ1"); // true

// Использование объекта как хэш-таблицы в JavaScript
const objMap = {};
objMap["ключ1"] = 100;
objMap["ключ2"] = 200;
const objValue = objMap["ключ1"]; // Возвращает 100
const objExists = "ключ1" in objMap; // true
```

```javascript
// Пример использования Map в JavaScript
const map = new Map();
map.set("ключ1", 100);
map.set("ключ2", 200);
const value = map.get("ключ1"); // Возвращает 100
const exists = map.has("ключ1"); // true

// Также можно использовать обычный объект
const obj = {};
obj["ключ1"] = 100;
obj["ключ2"] = 200;
const value2 = obj["ключ1"]; // Возвращает 100
const exists2 = "ключ1" in obj; // true
```

## Применения

### В реальных проектах:
- Кэширование данных
- Базы данных (хэш-индексы)
- Реализация множеств и отображений
- Подсчет частоты элементов
- Ускорение поиска

### В веб-разработке:
- Хранение сессий пользователей
- Кэширование результатов запросов
- Реализация куки и сессий

## Преимущества и недостатки

### Преимущества:
- Быстрый доступ к данным (O(1) в среднем случае)
- Гибкость ключей (любой хэшируемый тип)
- Эффективное использование памяти при хорошем распределении

### Недостатки:
- Плохая производительность при коллизиях
- Нет упорядоченности элементов (в стандартной реализации)
- Зависит от качества хэш-функции
- Проблемы с кэш-локальностью при больших таблицах

## Применение в индустрии

В современной IT-индустрии:
- Хэш-таблицы широко используются в высоконагруженных системах
- Важно понимание внутреннего устройства для оптимизации производительности
- Актуальны вопросы безопасности хэш-функций (атаки через коллизии)
- Применяются в системах кэширования (Redis, Memcached)

Крупные технологические компании:
- Проверяют знание внутреннего устройства хэш-таблиц
- Ожидают понимания обработки коллизий
- Тестируют знание встроенных реализаций в разных языках
- Часто задают задачи, требующие эффективного использования хэш-таблиц

## Практические рекомендации

### При реализации:
- Выбирайте хорошую хэш-функцию
- Поддерживайте коэффициент загрузки (load factor) в разумных пределах
- Рассмотрите возможность рехэширования при росте

### При использовании:
- Используйте встроенные реализации, когда это возможно
- Помните о необходимости переопределения `equals()` и `hashCode()`
- Учитывайте thread-safety при многопоточном использовании

## Примеры задач на собеседованиях

- Проверка уникальности элементов
- Подсчет частоты элементов
- Проверка анаграмм
- Два числа, дающие заданную сумму
- Неповторяющийся элемент в массиве

## Связанные темы

- [[Множества-и-отображения]]
- [[Алгоритмы-поиска]]
- [[Бинарные-деревья-поиска]]
- [[Хэш-функции]]
- [[Коллизии-в-хэш-таблицах]]

## Заключение

Хэш-таблицы являются одной из самых важных структур данных в программировании. Знание хэш-таблиц и умение эффективно их использовать остается критически важным как для прохождения технических собеседований, так и для создания высокопроизводительных приложений.