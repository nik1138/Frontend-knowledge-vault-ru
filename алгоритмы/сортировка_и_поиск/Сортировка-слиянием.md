---
aliases: ["Merge Sort", "Сортировка слиянием", "Сортировка объединением"]
tags: [алгоритмы, сортировка, эффективность, подготовка-к-собеседованиям]
---

# Сортировка слиянием

## Определение

Сортировка слиянием (Merge Sort) - это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй". Он рекурсивно разделяет массив на две половины, сортирует каждую половину, а затем объединяет (слияние) отсортированные половины в один отсортированный массив.

## История

Алгоритм был изобретен Джоном фон Нейманом в 1945 году. Сортировка слиянием остается важной благодаря своей стабильности и гарантированной эффективности.

## Принцип работы

1. Разделение массива на две половины до тех пор, пока каждый подмассив не будет содержать один элемент
2. Слияние пар отсортированных подмассивов в большие отсортированные подмассивы
3. Повторение процесса до тех пор, пока не будет один отсортированный массив

## Псевдокод

```
АЛГОРИТМ Сортировка_Слиянием(массив)
    ВХОД: массив - неотсортированный массив элементов
    ВЫХОД: отсортированный массив элементов

    ЕСЛИ ДЛИНА(массив) <= 1:
        ВОЗВРАТИТЬ массив
    КОНЕЦ ЕСЛИ

    mid = ДЛИНА(массив) / 2
    left = Сортировка_Слиянием(ПОДМАССИВ(массив, 0, mid))
    right = Сортировка_Слиянием(ПОДМАССИВ(массив, mid, ДЛИНА(массив)))

    ВОЗВРАТИТЬ СЛИЯНИЕ(left, right)
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ СЛИЯНИЕ(левый_массив, правый_массив)
    ВХОД: левый_массив, правый_массив - два отсортированных массива
    ВЫХОД: объединенный отсортированный массив

    result = []
    i = 0  // индекс для левого массива
    j = 0  // индекс для правого массива

    WHILE i < ДЛИНА(левый_массив) И j < ДЛИНА(правый_массив):
        ЕСЛИ левый_массив[i] <= правый_массив[j]:
            ДОБАВИТЬ(левый_массив[i], result)
            i = i + 1
        ИНАЧЕ:
            ДОБАВИТЬ(правый_массив[j], result)
            j = j + 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ WHILE

    // Добавляем оставшиеся элементы
    WHILE i < ДЛИНА(левый_массив):
        ДОБАВИТЬ(левый_массив[i], result)
        i = i + 1
    КОНЕЦ WHILE

    WHILE j < ДЛИНА(правый_массив):
        ДОБАВИТЬ(правый_массив[j], result)
        j = j + 1
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ result
КОНЕЦ АЛГОРИТМА
```

## Реализация на JavaScript

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }

    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));

    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    let i = 0, j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }

    // Добавляем оставшиеся элементы
    return result.concat(left.slice(i)).concat(right.slice(j));
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log("До сортировки:", numbers);
console.log("После сортировки:", mergeSort([...numbers]));
```

## Ин-плейс реализация (оптимизированная)

```javascript
function mergeSortInPlace(arr, tempArr = new Array(arr.length), left = 0, right = arr.length - 1) {
    if (left < right) {
        const mid = Math.floor((left + right) / 2);

        // Рекурсивно сортируем левую и правую половины
        mergeSortInPlace(arr, tempArr, left, mid);
        mergeSortInPlace(arr, tempArr, mid + 1, right);

        // Сливаем отсортированные половины
        mergeInPlace(arr, tempArr, left, mid, right);
    }
}

function mergeInPlace(arr, tempArr, left, mid, right) {
    // Копируем данные во временный массив
    for (let i = left; i <= right; i++) {
        tempArr[i] = arr[i];
    }

    let i = left;      // Индекс для левой половины
    let j = mid + 1;   // Индекс для правой половины
    let k = left;      // Индекс для объединенного массива

    // Сливаем временные массивы обратно в arr[left:right+1]
    while (i <= mid && j <= right) {
        if (tempArr[i] <= tempArr[j]) {
            arr[k] = tempArr[i];
            i++;
        } else {
            arr[k] = tempArr[j];
            j++;
        }
        k++;
    }

    // Копируем оставшиеся элементы левой половины
    while (i <= mid) {
        arr[k] = tempArr[i];
        i++;
        k++;
    }

    // Копируем оставшиеся элементы правой половины
    while (j <= right) {
        arr[k] = tempArr[j];
        j++;
        k++;
    }
}
```

## Временная сложность

- **Лучший случай**: O(n log n)
- **Средний случай**: O(n log n)
- **Худший случай**: O(n log n)

## Пространственная сложность

- O(n) - требуется дополнительная память для хранения временных массивов

## Преимущества

- Гарантированная O(n log n) сложность во всех случаях
- Устойчивая сортировка (не меняет относительный порядок равных элементов)
- Хорошо работает с большими объемами данных
- Предсказуемое поведение (не зависит от входных данных)
- Подходит для сортировки связных списков

## Недостатки

- Требует O(n) дополнительной памяти
- Медленнее [[Быстрая-сортировка]] в среднем случае
- Не является алгоритмом на месте (in-place)

## Практическое применение

Сортировка слиянием используется:

- В системах, где важна стабильность (например, при сортировке по нескольким критериям)
- В приложениях, где необходима гарантированная производительность
- В сортировке внешних данных (когда данные не помещаются в оперативную память)
- В банках и финансовых системах, где важна надежность
- В образовательных целях и при обучении новых сотрудников

> [!tip] Практический совет
> Сортировка слиянием часто используется в сочетании с другими алгоритмами (например, в Timsort - гибрид Merge Sort и Insertion Sort), чтобы получить преимущества нескольких подходов.

> [!warning] Важно
> При работе с большими объемами данных учитывайте требования к памяти при использовании сортировки слиянием, так как она требует дополнительной памяти.

## Сравнение с другими алгоритмами

- [[Быстрая-сортировка]] - быстрее в среднем случае, но с худшей гарантией производительности
- [[Пирамидальная-сортировка]] - эффективна с O(n log n) и O(1) по памяти, но нестабильна
- [[Сортировка-пузырьком]] - значительно медленнее с O(n²) сложностью

## Применение в реальных системах

Сортировка слиянием может применяться:

1. **В аналитических системах** - для сортировки больших наборов данных
2. **В системах обработки транзакций** - где важна стабильность и предсказуемость
3. **В ETL-процессах** - для сортировки данных перед загрузкой в хранилища
4. **В поисковых системах** - для сортировки результатов поиска по релевантности

## Заключение

Сортировка слиянием остается важным алгоритмом благодаря своей стабильности и гарантированной эффективности. Несмотря на требование дополнительной памяти, этот алгоритм находит применение в системах, где важна предсказуемость и надежность.