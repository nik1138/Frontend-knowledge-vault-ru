---
aliases: ["Binary Search", "Двоичный поиск", "Бисекция"]
tags: [алгоритмы, поиск, эффективность, подготовка-к-собеседованиям]
---

# Бинарный поиск

## Определение

Бинарный поиск (Binary Search) - это эффективный алгоритм поиска элемента в отсортированном массиве, который работает по принципу "разделяй и властвуй". Алгоритм сравнивает искомый элемент со средним элементом массива и, в зависимости от результата, продолжает поиск в одной из половин.

## Принцип работы

1. Сравнение искомого значения со средним элементом массива
2. Если значения равны, элемент найден
3. Если искомое значение меньше среднего, поиск продолжается в левой половине
4. Если искомое значение больше среднего, поиск продолжается в правой половине
5. Повторение процесса до нахождения элемента или исчерпания диапазона поиска

## Псевдокод

```
АЛГОРИТМ Бинарный_Поиск(массив, цель)
    ВХОД: массив - отсортированный список элементов для поиска, цель - искомое значение
    ВЫХОД: индекс элемента или -1, если элемент не найден

    left = 0
    right = ДЛИНА(массив) - 1

    WHILE left <= right:
        mid = (left + right) / 2  // Находим средний индекс

        ЕСЛИ массив[mid] = цель:
            ВОЗВРАТИТЬ mid  // Элемент найден
        ИНАЧЕ ЕСЛИ массив[mid] < цель:
            left = mid + 1  // Искомое значение в правой половине
        ИНАЧЕ:
            right = mid - 1  // Искомое значение в левой половине
        КОНЕЦ ЕСЛИ
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ -1  // Элемент не найден
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ Бинарный_Поиск_Рекурсивный(массив, цель, left, right)
    ВХОД: массив - отсортированный список элементов, цель - искомое значение, left - левая граница, right - правая граница
    ВЫХОД: индекс элемента или -1, если элемент не найден

    ЕСЛИ left > right:
        ВОЗВРАТИТЬ -1  // Элемент не найден

    mid = (left + right) / 2

    ЕСЛИ массив[mid] = цель:
        ВОЗВРАТИТЬ mid  // Элемент найден
    ИНАЧЕ ЕСЛИ массив[mid] < цель:
        ВОЗВРАТИТЬ Бинарный_Поиск_Рекурсивный(массив, цель, mid + 1, right)
    ИНАЧЕ:
        ВОЗВРАТИТЬ Бинарный_Поиск_Рекурсивный(массив, цель, left, mid - 1)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

## Реализация на Python

```python
def binary_search(arr, target):
    """
    Бинарный поиск элемента в отсортированном массиве
    :param arr: отсортированный список элементов для поиска
    :param target: искомое значение
    :return: индекс элемента или -1, если элемент не найден
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2  # Находим средний индекс

        if arr[mid] == target:
            return mid  # Элемент найден
        elif arr[mid] < target:
            left = mid + 1  # Искомое значение в правой половине
        else:
            right = mid - 1  # Искомое значение в левой половине

    return -1  # Элемент не найден

# Пример использования
numbers = [11, 12, 22, 25, 34, 64, 90]  # Массив должен быть отсортирован
target = 25
result = binary_search(numbers, target)

if result != -1:
    print(f"Элемент {target} найден по индексу {result}")
else:
    print(f"Элемент {target} не найден в массиве")
```

## Реализация на JavaScript

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (arr[mid] === target) {
            return mid;  // Элемент найден
        } else if (arr[mid] < target) {
            left = mid + 1;  // Искомое значение в правой половине
        } else {
            right = mid - 1;  // Искомое значение в левой половине
        }
    }

    return -1;  // Элемент не найден
}

// Пример использования
const numbers = [11, 12, 22, 25, 34, 64, 90];  // Массив должен быть отсортирован
const target = 25;
const result = binarySearch(numbers, target);

if (result !== -1) {
    console.log(`Элемент ${target} найден по индексу ${result}`);
} else {
    console.log(`Элемент ${target} не найден в массиве`);
}
```

## Рекурсивная реализация

```python
def binary_search_recursive(arr, target, left=0, right=None):
    """
    Рекурсивная реализация бинарного поиска
    :param arr: отсортированный список элементов для поиска
    :param target: искомое значение
    :param left: левая граница поиска
    :param right: правая граница поиска
    :return: индекс элемента или -1, если элемент не найден
    """
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return -1  # Элемент не найден
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid  # Элемент найден
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
```

## Временная сложность

- **Лучший случай**: O(1) - когда искомый элемент находится в середине массива
- **Средний случай**: O(log n)
- **Худший случай**: O(log n)

## Пространственная сложность

- Итеративная версия: O(1)
- Рекурсивная версия: O(log n) - из-за стека вызовов

## Преимущества

- Высокая эффективность с O(log n) сложностью
- Хорошо работает с большими объемами данных
- Предсказуемое поведение (всегда log n сравнений в худшем случае)
- Подходит для поиска в больших отсортированных структурах данных

## Недостатки

- Требует предварительной сортировки данных
- Неэффективен для часто изменяющихся данных
- Более сложен в реализации по сравнению с линейным поиском
- Требует прямого доступа к элементам (не подходит для связных списков)

## Практическое применение

Бинарный поиск используется:

- В поисковых системах (Яндекс, Mail.Ru и др.)
- В базах данных для индексации и поиска
- В алгоритмах машинного обучения для оптимизации параметров
- В финансовых системах для поиска транзакций по времени
- В системах рекомендаций для поиска пользователей или контента

> [!tip] Практический совет
> Часто используют модифицированные версии бинарного поиска, например, для поиска границ диапазонов (lower_bound, upper_bound), что особенно полезно при работе с временными рядами и статистикой.

> [!warning] Важно
> Перед использованием бинарного поиска убедитесь, что данные отсортированы. В противном случае алгоритм будет возвращать некорректные результаты.

## Расширенные варианты бинарного поиска

1. **Поиск границ диапазона**:
```python
def lower_bound(arr, target):
    """
    Поиск левой границы вхождения элемента
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """
    Поиск правой границы вхождения элемента
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left
```

2. **Поиск в частично отсортированном массиве**:
```python
def search_rotated_array(arr, target):
    """
    Поиск в повернутом отсортированном массиве
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        
        # Проверяем, какая половина отсортирована
        if arr[left] <= arr[mid]:  # Левая половина отсортирована
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # Правая половина отсортирована
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

## Сравнение с другими алгоритмами

- [[Линейный-поиск]] - менее эффективен с O(n) сложностью, но не требует сортировки
- [[Поиск-в-глубину]] - используется для поиска в графах и деревьях
- [[Поиск-в-ширину]] - также используется для поиска в графах, но с другим подходом

## Заключение

Бинарный поиск остается одним из самых важных алгоритмов поиска благодаря своей эффективности. Понимание этого алгоритма и его модификаций критически важно как для решения практических задач, так и для прохождения технических собеседований в ведущие IT-компании.