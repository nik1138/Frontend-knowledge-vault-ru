---
aliases: ["BFS", "Breadth-First Search", "Поиск в ширину", "Обход в ширину"]
tags: [алгоритмы, поиск, графы, деревья, подготовка-к-собеседованиям]
---

# Поиск в ширину

## Определение

Поиск в ширину (Breadth-First Search, BFS) - это алгоритм обхода или поиска в структурах данных типа дерево или граф. Алгоритм начинает с корневого узла и исследует все соседние узлы на текущем уровне перед переходом к узлам следующего уровня.

## Принцип работы

1. Помещаем начальный узел в очередь
2. Помечаем его как посещенный
3. Извлекаем узел из очереди и посещаем его
4. Добавляем всех непосещенных соседей в конец очереди
5. Повторяем шаги 3-4 до тех пор, пока очередь не станет пустой

## Псевдокод

```
АЛГОРИТМ BFS_Для_Графа(граф, начальный_узел)
    ВХОД: граф - структура графа, начальный_узел - узел, с которого начинается обход
    ВЫХОД: список посещенных узлов в порядке обхода

    посещенные = ПУСТОЕ_МНОЖЕСТВО
    очередь = ОЧЕРЕДЬ()
    ДОБАВИТЬ(начальный_узел, очередь)
    результат = []

    ДОБАВИТЬ(начальный_узел, посещенные)

    WHILE очередь НЕ пуста:
        узел = ВЗЯТЬ_ИЗ_ОЧЕРЕДИ(очередь)
        ДОБАВИТЬ(узел, результат)

        FOR каждый сосед IN граф[узел]:
            ЕСЛИ сосед НЕ в посещенные:
                ДОБАВИТЬ(сосед, посещенные)
                ДОБАВИТЬ(сосед, очередь)
            КОНЕЦ ЕСЛИ
        КОНЕЦ FOR
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ BFS_Поиск_Пути(граф, начальный_узел, конечный_узел)
    ВХОД: граф - структура графа, начальный_узел, конечный_узел - узлы, между которыми ищется путь
    ВЫХОД: список узлов, представляющих кратчайший путь, или NULL

    ЕСЛИ начальный_узел = конечный_узел:
        ВОЗВРАТИТЬ [начальный_узел]
    КОНЕЦ ЕСЛИ

    посещенные = ПУСТОЕ_МНОЖЕСТВО
    очередь = ОЧЕРЕДЬ()
    ДОБАВИТЬ((начальный_узел, [начальный_узел]), очередь)  // Храним узел и путь до него
    ДОБАВИТЬ(начальный_узел, посещенные)

    WHILE очередь НЕ пуста:
        узел, путь = ВЗЯТЬ_ИЗ_ОЧЕРЕДИ(очередь)

        FOR каждый сосед IN граф[узел]:
            ЕСЛИ сосед = конечный_узел:
                ВОЗВРАТИТЬ путь + [сосед]
            ИНАЧЕ ЕСЛИ сосед НЕ в посещенные:
                ДОБАВИТЬ(сосед, посещенные)
                ДОБАВИТЬ((сосед, путь + [сосед]), очередь)
            КОНЕЦ ЕСЛИ
        КОНЕЦ FOR
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ NULL  // Путь не найден
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ BFS_Для_Дерева(корень)
    ВХОД: корень - корневой узел дерева
    ВЫХОД: список значений узлов в порядке обхода по уровням

    ЕСЛИ корень = NULL:
        ВОЗВРАТИТЬ []
    КОНЕЦ ЕСЛИ

    очередь = ОЧЕРЕДЬ()
    ДОБАВИТЬ(корень, очередь)
    результат = []

    WHILE очередь НЕ пуста:
        узел = ВЗЯТЬ_ИЗ_ОЧЕРЕДИ(очередь)
        ДОБАВИТЬ(узел.значение, результат)

        ЕСЛИ узел.левый НЕ NULL:
            ДОБАВИТЬ(узел.левый, очередь)
        КОНЕЦ ЕСЛИ
        ЕСЛИ узел.правый НЕ NULL:
            ДОБАВИТЬ(узел.правый, очередь)
        КОНЕЦ ЕСЛИ
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА
```

## Реализация на Python

```python
from collections import deque

def bfs(graph, start):
    """
    Поиск в ширину для графа
    :param graph: граф в виде словаря смежности
    :param start: начальный узел
    :return: список посещенных узлов в порядке обхода
    """
    visited = set()
    queue = deque([start])
    result = []

    visited.add(start)

    while queue:
        vertex = queue.popleft()
        result.append(vertex)

        # Обходим всех соседей текущего узла
        for neighbor in graph.get(vertex, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result

def bfs_find_path(graph, start, end):
    """
    BFS для нахождения кратчайшего пути между двумя узлами
    :param graph: граф в виде словаря смежности
    :param start: начальный узел
    :param end: конечный узел
    :return: список узлов, представляющих кратчайший путь, или None
    """
    if start == end:
        return [start]

    visited = set()
    queue = deque([(start, [start])])  # Храним узел и путь до него
    visited.add(start)

    while queue:
        vertex, path = queue.popleft()

        for neighbor in graph.get(vertex, []):
            if neighbor == end:
                return path + [neighbor]

            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None  # Путь не найден

# Пример использования
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("BFS обход:", bfs(graph, 'A'))
print("Кратчайший путь от A до F:", bfs_find_path(graph, 'A', 'F'))
```

## Реализация для дерева

```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def bfs_tree(root):
    """
    BFS для бинарного дерева (обход в ширину)
    """
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        node = queue.popleft()
        result.append(node.val)

        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return result

def bfs_tree_levels(root):
    """
    BFS для бинарного дерева с возвратом уровней
    """
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        current_level = []

        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(current_level)

    return result

# Пример дерева
#       1
#      / \
#     2   3
#    / \   \
#   4   5   6
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.right = TreeNode(6)

print("BFS дерева:", bfs_tree(root))
print("Уровни дерева:", bfs_tree_levels(root))
```

## Реализация на JavaScript

```javascript
// BFS для графа
function bfs(graph, start) {
    const visited = new Set();
    const queue = [start];
    const result = [];

    visited.add(start);

    while (queue.length > 0) {
        const vertex = queue.shift();
        result.push(vertex);

        const neighbors = graph[vertex] || [];
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }

    return result;
}

// BFS для нахождения кратчайшего пути между двумя узлами
function bfsFindPath(graph, start, end) {
    if (start === end) {
        return [start];
    }

    const visited = new Set();
    const queue = [[start, [start]]]; // Храним узел и путь до него
    visited.add(start);

    while (queue.length > 0) {
        const [vertex, path] = queue.shift();

        const neighbors = graph[vertex] || [];
        for (const neighbor of neighbors) {
            if (neighbor === end) {
                return path.concat([neighbor]);
            }

            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, path.concat([neighbor])]);
            }
        }
    }

    return null; // Путь не найден
}

// BFS для дерева (обход в ширину)
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function bfsTree(root) {
    if (!root) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node.val);

        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }

    return result;
}

// BFS для дерева с возвратом уровней
function bfsTreeLevels(root) {
    if (!root) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }

        result.push(currentLevel);
    }

    return result;
}

// Пример использования
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
};

console.log("BFS обход:", bfs(graph, 'A'));
console.log("Кратчайший путь от A до F:", bfsFindPath(graph, 'A', 'F'));

// Пример дерева
//       1
//      / \
//     2   3
//    / \   \
//   4   5   6
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.right = new TreeNode(6);

console.log("BFS дерева:", bfsTree(root));
console.log("Уровни дерева:", bfsTreeLevels(root));
```

## Временная сложность

- Для графа: O(V + E), где V - количество вершин, E - количество рёбер
- Для дерева: O(N), где N - количество узлов

## Пространственная сложность

O(V) - в худшем случае, когда все вершины находятся в очереди одновременно

## Преимущества

- Гарантирует нахождение кратчайшего пути в невзвешенном графе
- Постепенно расширяет область поиска, что полезно для поиска ближайших соседей
- Хорошо подходит для задач, где важна "близость" к начальному узлу
- Легко модифицируется для решения различных задач на графах

## Недостатки

- Требует больше памяти, чем [[Поиск-в-глубину]], особенно для "широких" графов
- Может быть менее эффективным по памяти для глубоких и узких графов
- Не всегда подходит для задач, где важна глубина поиска

## Практическое применение

BFS используется:

- В поисковых системах (Яндекс) для анализа веб-ссылок и ранжирования
- В социальных сетях для поиска кратчайших связей между пользователями
- В транспортных системах (например, в навигаторах) для поиска кратчайших маршрутов
- В системах рекомендаций для нахождения похожих пользователей или контента
- В игровых движках для поиска кратчайших путей
- В системах сетевого анализа для выявления связей и кластеров

> [!tip] Практический совет
> BFS часто используется для задач, где важна "близость" или "уровень" узла от начального. Например, в рекомендательных системах для поиска пользователей на минимальном расстоянии от целевого пользователя.

> [!warning] Важно
> BFS требует больше памяти, чем DFS, особенно для графов с высокой шириной. При работе с большими графами учитывайте ограничения по памяти.

## Расширенные применения

1. **Поиск кратчайшего пути в лабиринте**:
```python
def shortest_path_maze(maze, start, end):
    """
    Поиск кратчайшего пути в лабиринте
    :param maze: двумерный массив, где 0 - проход, 1 - стена
    :param start: начальная позиция (row, col)
    :param end: конечная позиция (row, col)
    :return: длина кратчайшего пути или -1, если путь не существует
    """
    if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1:
        return -1
    
    rows, cols = len(maze), len(maze[0])
    queue = deque([(start[0], start[1], 0)])  # (row, col, distance)
    visited = set()
    visited.add(start)
    
    # Возможные направления движения
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    while queue:
        row, col, dist = queue.popleft()
        
        if (row, col) == end:
            return dist
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                maze[new_row][new_col] == 0 and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, dist + 1))
    
    return -1  # Путь не найден
```

2. **Проверка двудольности графа**:
```python
def is_bipartite(graph):
    """
    Проверка, является ли граф двудольным
    """
    color = {}
    
    for node in graph:
        if node not in color:
            queue = deque([node])
            color[node] = 0
            
            while queue:
                current = queue.popleft()
                
                for neighbor in graph[current]:
                    if neighbor not in color:
                        color[neighbor] = 1 - color[current]
                        queue.append(neighbor)
                    elif color[neighbor] == color[current]:
                        return False  # Граф не двудольный
    
    return True
```

## Сравнение с другими алгоритмами

- [[Поиск-в-глубину]] - использует меньше памяти для "узких" графов, но не гарантирует кратчайший путь
- [[Бинарный-поиск]] - эффективен для поиска в отсортированных массивах
- [[Линейный-поиск]] - прост, но менее эффективен для больших структур

## Заключение

Поиск в ширину остается важным алгоритмом благодаря его способности находить кратчайшие пути в невзвешенных графах. Понимание этого алгоритма критически важно для решения задач на графах и деревьях, а также для прохождения технических собеседований в ведущие IT-компании.