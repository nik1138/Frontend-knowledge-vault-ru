---
aliases: ["Поиск минимума и максимума", "Min-Max Search", "Поиск экстремумов"]
tags: [алгоритмы, поиск, оптимизация, подготовка-к-собеседованиям]
---

# Поиск минимума и максимума

## Определение

Поиск минимума и максимума - это алгоритмы, которые находят наименьший и наибольший элементы в коллекции данных. Эти алгоритмы являются фундаментальными и часто используются как вспомогательные в более сложных алгоритмах.

## Принцип работы

Алгоритм последовательно просматривает элементы коллекции, сравнивая их с текущими минимальным и максимальным значениями, обновляя эти значения при необходимости.

## Псевдокод

```
АЛГОРИТМ Найти_Мин_Макс_Линейный(массив)
    ВХОД: массив - список элементов
    ВЫХОД: пара (минимум, максимум)

    ЕСЛИ ДЛИНА(массив) = 0:
        ВОЗВРАТИТЬ ОШИБКА("Массив не должен быть пустым")
    КОНЕЦ ЕСЛИ

    min_val = max_val = массив[0]

    FOR i = 1 ДО ДЛИНА(массив) - 1:
        ЕСЛИ массив[i] < min_val:
            min_val = массив[i]
        ИНАЧЕ ЕСЛИ массив[i] > max_val:
            max_val = массив[i]
        КОНЕЦ ЕСЛИ
    КОНЕЦ FOR

    ВОЗВРАТИТЬ (min_val, max_val)
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ Найти_Мин_Макс_Оптимизированный(массив)
    ВХОД: массив - список элементов
    ВЫХОД: пара (минимум, максимум)

    ЕСЛИ ДЛИНА(массив) = 0:
        ВОЗВРАТИТЬ ОШИБКА("Массив не должен быть пустым")
    КОНЕЦ ЕСЛИ

    n = ДЛИНА(массив)

    // Инициализация min и max
    ЕСЛИ n НЕЧЕТНОЕ:
        min_val = max_val = массив[0]
        start_idx = 1
    ИНАЧЕ:
        ЕСЛИ массив[0] > массив[1]:
            max_val = массив[0]
            min_val = массив[1]
        ИНАЧЕ:
            min_val = массив[0]
            max_val = массив[1]
        КОНЕЦ ЕСЛИ
        start_idx = 2
    КОНЕЦ ЕСЛИ

    // Обработка пар элементов
    FOR i = start_idx ДО n - 2 С ШАГОМ 2:
        ЕСЛИ массив[i] > массив[i + 1]:
            local_max = массив[i]
            local_min = массив[i + 1]
        ИНАЧЕ:
            local_min = массив[i]
            local_max = массив[i + 1]
        КОНЕЦ ЕСЛИ

        ЕСЛИ local_max > max_val:
            max_val = local_max
        КОНЕЦ ЕСЛИ
        ЕСЛИ local_min < min_val:
            min_val = local_min
        КОНЕЦ ЕСЛИ
    КОНЕЦ FOR

    ВОЗВРАТИТЬ (min_val, max_val)
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ Найти_Мин_Макс_Разделяй_И_Властвуй(массив, low, high)
    ВХОД: массив - список элементов, low - начальный индекс, high - конечный индекс
    ВЫХОД: пара (минимум, максимум)

    // Базовый случай: только один элемент
    ЕСЛИ low = high:
        ВОЗВРАТИТЬ (массив[low], массив[low])
    КОНЕЦ ЕСЛИ

    // Базовый случай: два элемента
    ЕСЛИ high = low + 1:
        ЕСЛИ массив[low] > массив[high]:
            ВОЗВРАТИТЬ (массив[high], массив[low])
        ИНАЧЕ:
            ВОЗВРАТИТЬ (массив[low], массив[high])
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЕСЛИ

    // Разделение массива на две половины
    mid = (low + high) / 2
    min1, max1 = Найти_Мин_Макс_Разделяй_И_Властвуй(массив, low, mid)
    min2, max2 = Найти_Мин_Макс_Разделяй_И_Властвуй(массив, mid + 1, high)

    // Объединение результатов
    ВОЗВРАТИТЬ (МИН(min1, min2), МАКС(max1, max2))
КОНЕЦ АЛГОРИТМА
```

## Реализация на Python

```python
def find_min_max_linear(arr):
    """
    Поиск минимума и максимума за один проход (линейный поиск)
    :param arr: список элементов
    :return: кортеж (минимум, максимум)
    """
    if not arr:
        raise ValueError("Массив не должен быть пустым")

    min_val = max_val = arr[0]

    for num in arr[1:]:
        if num < min_val:
            min_val = num
        elif num > max_val:
            max_val = num

    return min_val, max_val

def find_min_max_optimized(arr):
    """
    Оптимизированный поиск минимума и максимума
    Сравнивает элементы попарно, уменьшая количество сравнений
    :param arr: список элементов
    :return: кортеж (минимум, максимум)
    """
    if not arr:
        raise ValueError("Массив не должен быть пустым")

    n = len(arr)

    # Инициализация min и max
    if n % 2 == 1:
        min_val = max_val = arr[0]
        start_idx = 1
    else:
        if arr[0] > arr[1]:
            max_val, min_val = arr[0], arr[1]
        else:
            min_val, max_val = arr[0], arr[1]
        start_idx = 2

    # Обработка пар элементов
    for i in range(start_idx, n - 1, 2):
        if arr[i] > arr[i + 1]:
            local_max, local_min = arr[i], arr[i + 1]
        else:
            local_min, local_max = arr[i], arr[i + 1]

        if local_max > max_val:
            max_val = local_max
        if local_min < min_val:
            min_val = local_min

    return min_val, max_val

def find_min_max_divide_conquer(arr, low=0, high=None):
    """
    Поиск минимума и максимума методом "разделяй и властвуй"
    :param arr: список элементов
    :param low: начальный индекс
    :param high: конечный индекс
    :return: кортеж (минимум, максимум)
    """
    if high is None:
        high = len(arr) - 1

    # Базовый случай: только один элемент
    if low == high:
        return arr[low], arr[low]

    # Базовый случай: два элемента
    if high == low + 1:
        if arr[low] > arr[high]:
            return arr[high], arr[low]
        else:
            return arr[low], arr[high]

    # Разделение массива на две половины
    mid = (low + high) // 2
    min1, max1 = find_min_max_divide_conquer(arr, low, mid)
    min2, max2 = find_min_max_divide_conquer(arr, mid + 1, high)

    # Объединение результатов
    return min(min1, min2), max(max1, max2)

# Пример использования
numbers = [64, 34, 25, 12, 22, 11, 90]
print(f"Массив: {numbers}")
print(f"Минимум и максимум (линейный): {find_min_max_linear(numbers)}")
print(f"Минимум и максимум (оптимизированный): {find_min_max_optimized(numbers)}")
print(f"Минимум и максимум (разделяй и властвуй): {find_min_max_divide_conquer(numbers)}")
```

## Реализация на JavaScript

```javascript
function findMinMaxLinear(arr) {
    if (arr.length === 0) {
        throw new Error("Массив не должен быть пустым");
    }

    let minVal = maxVal = arr[0];

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < minVal) {
            minVal = arr[i];
        } else if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }

    return [minVal, maxVal];
}

function findMinMaxOptimized(arr) {
    if (arr.length === 0) {
        throw new Error("Массив не должен быть пустым");
    }

    let n = arr.length;
    let minVal, maxVal;

    // Инициализация min и max
    if (n % 2 === 1) {
        minVal = maxVal = arr[0];
        let startIdx = 1;
    } else {
        if (arr[0] > arr[1]) {
            [maxVal, minVal] = [arr[0], arr[1]];
        } else {
            [minVal, maxVal] = [arr[0], arr[1]];
        }
        let startIdx = 2;
    }

    // Обработка пар элементов
    for (let i = startIdx; i < n - 1; i += 2) {
        let localMin, localMax;
        if (arr[i] > arr[i + 1]) {
            [localMax, localMin] = [arr[i], arr[i + 1]];
        } else {
            [localMin, localMax] = [arr[i], arr[i + 1]];
        }

        if (localMax > maxVal) {
            maxVal = localMax;
        }
        if (localMin < minVal) {
            minVal = localMin;
        }
    }

    return [minVal, maxVal];
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log("Минимум и максимум (линейный):", findMinMaxLinear(numbers));
console.log("Минимум и максимум (оптимизированный):", findMinMaxOptimized(numbers));
```

## Временная сложность

- **Линейный поиск**: O(n) - один проход по массиву
- **Оптимизированный поиск**: O(n) - но с меньшим количеством сравнений (3n/2 - 2)
- **Разделяй и властвуй**: O(n) - но с дополнительными накладными расходами на рекурсию

## Пространственная сложность

- **Линейный и оптимизированный**: O(1) - константное количество дополнительной памяти
- **Разделяй и властвуй**: O(log n) - из-за стека рекурсивных вызовов

## Преимущества

- Простота реализации и понимания
- Гарантированное нахождение точных значений минимума и максимума
- Эффективность - только один проход по данным в простейшем случае
- Применимость к любым сравнимым данным

## Недостатки

- Неэффективность при частых запросах на изменяющихся данных (лучше использовать структуры данных типа дерево отрезков)
- Не подходит для параллельной обработки без дополнительных модификаций
- Требует полного просмотра данных

## Практическое применение

Поиск минимума и максимума используется:

- В аналитических системах для определения экстремальных значений показателей
- В финансовых системах банков (Сбер, ВТБ) для анализа экстремальных значений транзакций
- В системах мониторинга для выявления аномальных значений
- В игровых движках для определения границ игрового поля
- В системах обработки сигналов для определения амплитуды
- В системах машинного обучения для нормализации данных

> [!tip] Практический совет
> При частых запросах на изменяющихся данных часто используются специальные структуры данных (например, кучи или сегментные деревья), которые позволяют быстро обновлять и запрашивать минимум/максимум.

> [!warning] Важно
> При работе с большими объемами данных учитывайте, что простой линейный поиск может быть недостаточно эффективным. Рассмотрите использование параллельных алгоритмов или специализированных структур данных.

## Расширенные применения

1. **Поиск k-го минимума/максимума**:
```python
import heapq

def find_kth_smallest(arr, k):
    """
    Поиск k-го наименьшего элемента с использованием кучи
    """
    if k < 1 or k > len(arr):
        raise ValueError("k вне допустимого диапазона")
    
    # Используем max-heap для хранения k наименьших элементов
    heap = []
    
    for num in arr:
        if len(heap) < k:
            heapq.heappush(heap, -num)  # Отрицательные значения для max-heap
        elif -heap[0] > num:
            heapq.heapreplace(heap, -num)
    
    return -heap[0]

def find_kth_largest(arr, k):
    """
    Поиск k-го наибольшего элемента
    """
    return find_kth_smallest(arr, len(arr) - k + 1)
```

2. **Поиск минимума/максимума в скользящем окне**:
```python
from collections import deque

def sliding_window_maximum(arr, window_size):
    """
    Поиск максимума в скользящем окне
    """
    if not arr or window_size <= 0:
        return []
    
    if window_size == 1:
        return arr[:]
    
    dq = deque()  # Дек для хранения индексов
    result = []
    
    for i in range(len(arr)):
        # Удаляем индексы, которые вышли за пределы окна
        while dq and dq[0] <= i - window_size:
            dq.popleft()
        
        # Удаляем индексы элементов, меньших текущего
        while dq and arr[dq[-1]] <= arr[i]:
            dq.pop()
        
        dq.append(i)
        
        # Если достигли размера окна, добавляем максимум
        if i >= window_size - 1:
            result.append(arr[dq[0]])
    
    return result
```

## Сравнение с другими алгоритмами

- [[Линейный-поиск]] - общий алгоритм поиска, в то время как поиск минимума/максимума - специализированный
- [[Бинарный-поиск]] - эффективнее для поиска в отсортированных массивах, но не находит минимум/максимум в общем случае
- [[Сортировка-пузырьком]] - может находить минимум/максимум, но менее эффективна

## Заключение

Поиск минимума и максимума остается важным алгоритмом благодаря своей простоте и широкому спектру применения. Понимание различных подходов к решению этой задачи критически важно для оптимизации производительности в реальных системах и прохождения технических собеседований.