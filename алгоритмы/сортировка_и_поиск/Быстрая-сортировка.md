---
aliases: ["Quick Sort", "Быстрая сортировка", "Квиксорт"]
tags: [алгоритмы, сортировка, эффективность, подготовка-к-собеседованиям]
---

# Быстрая сортировка

## Определение

Быстрая сортировка (Quick Sort) - это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй". Он выбирает опорный элемент (pivot) и разделяет массив на две части: элементы меньше опорного и элементы больше или равны опорному. Затем рекурсивно применяется к каждой из частей.

## История

Алгоритм был разработан английским информатиком Тони Хоаром в 1960 году. Быстрая сортировка остается одним из самых популярных алгоритмов благодаря своей средней эффективности.

## Принцип работы

1. Выбор опорного элемента (pivot) из массива
2. Разделение массива на два подмассива:
   - Элементы меньше опорного
   - Элементы больше или равны опорного
3. Рекурсивное применение быстрой сортировки к каждому подмассиву
4. Объединение результатов

## Псевдокод

```
АЛГОРИТМ Быстрая_Сортировка(массив)
    ВХОД: массив - неотсортированный массив элементов
    ВЫХОД: отсортированный массив элементов

    ЕСЛИ ДЛИНА(массив) <= 1:
        ВОЗВРАТИТЬ массив
    КОНЕЦ ЕСЛИ

    pivot = ВЫБРАТЬ_ОПОРНЫЙ_ЭЛЕМЕНТ(массив)
    left = []  // Элементы меньше опорного
    right = [] // Элементы больше или равны опорному

    FOR i = 0 ДО ДЛИНА(массив)-1:
        ЕСЛИ массив[i] < pivot:
            ДОБАВИТЬ(массив[i], left)
        ИНАЧЕ:
            ДОБАВИТЬ(массив[i], right)
        КОНЕЦ ЕСЛИ
    КОНЕЦ FOR

    ВОЗВРАТИТЬ ОБЪЕДИНИТЬ(
        Быстрая_Сортировка(left),
        [pivot],
        Быстрая_Сортировка(right)
    )
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ Быстрая_Сортировка_Ин_Плейс(массив, low, high)
    ВХОД: массив - массив элементов, low - начальный индекс, high - конечный индекс
    ВЫХОД: отсортированный массив

    ЕСЛИ low < high:
        pivot_index = РАЗДЕЛИТЬ(массив, low, high)
        Быстрая_Сортировка_Ин_Плейс(массив, low, pivot_index - 1)
        Быстрая_Сортировка_Ин_Плейс(массив, pivot_index + 1, high)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ РАЗДЕЛИТЬ(массив, low, high)
    ВХОД: массив - массив элементов, low - начальный индекс, high - конечный индекс
    ВЫХОД: индекс опорного элемента

    pivot = массив[high]
    i = low - 1

    FOR j = low ДО high-1:
        ЕСЛИ массив[j] <= pivot:
            i = i + 1
            ОБМЕН(массив[i], массив[j])
        КОНЕЦ ЕСЛИ
    КОНЕЦ FOR

    ОБМЕН(массив[i + 1], массив[high])
    ВОЗВРАТИТЬ i + 1
КОНЕЦ АЛГОРИТМА
```

## Реализация на JavaScript

```javascript
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }

    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);

    return [...quickSort(left), ...middle, ...quickSort(right)];
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log("До сортировки:", numbers);
console.log("После сортировки:", quickSort([...numbers]));
```

## Ин-плейс реализация (оптимизированная)

```javascript
function quickSortInPlace(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        // Разделяем массив и получаем индекс опорного элемента
        const pivotIndex = partition(arr, low, high);

        // Рекурсивно сортируем элементы до и после разделения
        quickSortInPlace(arr, low, pivotIndex - 1);
        quickSortInPlace(arr, pivotIndex + 1, high);
    }
}

function partition(arr, low, high) {
    // Выбираем самый правый элемент как опорный
    const pivot = arr[high];

    // Индекс для меньшего элемента
    let i = low - 1;

    for (let j = low; j < high; j++) {
        // Если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]]; // Меняем местами
        }
    }

    // Меняем опорный элемент с элементом в правильной позиции
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log("До сортировки:", numbers);
quickSortInPlace(numbers);
console.log("После сортировки:", numbers);
```

## Временная сложность

- **Лучший случай**: O(n log n) - когда опорный элемент делит массив на равные части
- **Средний случай**: O(n log n)
- **Худший случай**: O(n²) - когда опорный элемент всегда является минимальным или максимальным элементом

## Пространственная сложность

- **Лучший случай**: O(log n) - при сбалансированном разделении
- **Худший случай**: O(n) - при несбалансированном разделении (глубина рекурсии)

## Преимущества

- В среднем случае - один из самых быстрых алгоритмов сортировки
- Не требует дополнительной памяти для хранения данных (ин-плейс версия)
- Хорошо работает с кэш-памятью благодаря локальности ссылок
- Эффективен для больших массивов

## Недостатки

- Худшая временная сложность O(n²) при неудачном выборе опорного элемента
- Неустойчив (не сохраняет относительный порядок равных элементов)
- Плохо работает с уже отсортированными или почти отсортированными массивами без оптимизации

## Практическое применение

Быстрая сортировка широко используется:

- В стандартных библиотеках многих языков программирования (часто в модифицированном виде)
- В высоконагруженных системах (например, в Яндексе, Сбере, Тинькофф)
- Для сортировки больших объемов данных в аналитических системах
- В задачах, где важна средняя производительность

> [!tip] Практический совет
> Часто используют модифицированные версии быстрой сортировки (например, Introsort), чтобы избежать худшего случая O(n²). В промышленной разработке рекомендуется использовать встроенные реализации, но знание алгоритма важно для собеседований.

> [!warning] Важно
> При реализации в продакшене учитывайте защиту от худшего случая (например, случайный выбор опорного элемента или использование медианы из трех).

## Оптимизации

1. **Случайный выбор опорного элемента**:
```javascript
function randomizedPartition(arr, low, high) {
    // Случайно выбираем индекс и меняем с последним элементом
    const randomIndex = Math.floor(Math.random() * (high - low + 1)) + low;
    [arr[randomIndex], arr[high]] = [arr[high], arr[randomIndex]];
    return partition(arr, low, high);
}
```

2. **Использование сортировки вставками для малых подмассивов**:
```javascript
function optimizedQuickSort(arr, low = 0, high = arr.length - 1, threshold = 10) {
    if (low < high) {
        if (high - low + 1 <= threshold) {
            insertionSort(arr, low, high);
        } else {
            const pivotIndex = partition(arr, low, high);
            optimizedQuickSort(arr, low, pivotIndex - 1, threshold);
            optimizedQuickSort(arr, pivotIndex + 1, high, threshold);
        }
    }
}

function insertionSort(arr, low, high) {
    for (let i = low + 1; i <= high; i++) {
        const key = arr[i];
        let j = i - 1;

        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = key;
    }
}
```

## Сравнение с другими алгоритмами

- [[Сортировка-слиянием]] - стабильна с гарантированной O(n log n), но требует O(n) дополнительной памяти
- [[Пирамидальная-сортировка]] - эффективна с O(n log n) и O(1) по памяти, но медленнее в среднем случае
- [[Сортировка-пузырьком]] - значительно медленнее с O(n²) сложностью

## Заключение

Быстрая сортировка остается одним из самых важных алгоритмов благодаря своей эффективности в среднем случае. Понимание этого алгоритма критически важно как для практической разработки, так и для прохождения технических собеседований.