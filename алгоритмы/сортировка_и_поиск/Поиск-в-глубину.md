---
aliases: ["DFS", "Depth-First Search", "Поиск в глубину", "Обход в глубину"]
tags: [алгоритмы, поиск, графы, деревья, подготовка-к-собеседованиям]
---

# Поиск в глубину

## Определение

Поиск в глубину (Depth-First Search, DFS) - это алгоритм обхода или поиска в структурах данных типа дерево или граф. Алгоритм начинает с корневого узла (или произвольного узла в графе) и исследует как можно более далекие узлы вдоль каждой ветви перед тем, как вернуться.

## Принцип работы

1. Выбирается начальный узел
2. Помечается как посещенный
3. Рекурсивно посещаются все непосещенные соседние узлы
4. При достижении "тупика" (все соседи посещены или отсутствуют) происходит возврат к предыдущему узлу
5. Процесс продолжается до тех пор, пока все достижимые узлы не будут посещены

## Псевдокод

```
АЛГОРИТМ DFS_Рекурсивный(граф, узел, посещенные)
    ВХОД: граф - структура графа, узел - текущий узел, посещенные - множество посещенных узлов
    ВЫХОД: список посещенных узлов в порядке обхода

    ДОБАВИТЬ(узел, посещенные)
    результат = [узел]

    FOR каждый сосед IN граф[узел]:
        ЕСЛИ сосед НЕ в посещенные:
            результат.РАСШИРИТЬ(DFS_Рекурсивный(граф, сосед, посещенные))
        КОНЕЦ ЕСЛИ
    КОНЕЦ FOR

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_Итеративный(граф, начальный_узел)
    ВХОД: граф - структура графа, начальный_узел - узел, с которого начинается обход
    ВЫХОД: список посещенных узлов в порядке обхода

    посещенные = ПУСТОЕ_МНОЖЕСТВО
    стек = [начальный_узел]
    результат = []

    WHILE стек НЕ пуст:
        узел = ВЗЯТЬ_ИЗ_СТЕКА(стек)

        ЕСЛИ узел НЕ в посещенные:
            ДОБАВИТЬ(узел, посещенные)
            ДОБАВИТЬ(узел, результат)

            FOR каждый сосед IN граф[узел]:
                ЕСЛИ сосед НЕ в посещенные:
                    ДОБАВИТЬ(сосед, стек)
                КОНЕЦ ЕСЛИ
            КОНЕЦ FOR
        КОНЕЦ ЕСЛИ
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_Для_Дерева_Рекурсивный(корень)
    ВХОД: корень - корневой узел дерева
    ВЫХОД: список значений узлов в порядке обхода

    ЕСЛИ корень = NULL:
        ВОЗВРАТИТЬ []
    КОНЕЦ ЕСЛИ

    результат = [корень.значение]
    результат.РАСШИРИТЬ(DFS_Для_Дерева_Рекурсивный(корень.левый))
    результат.РАСШИРИТЬ(DFS_Для_Дерева_Рекурсивный(корень.правый))

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_Для_Дерева_Итеративный(корень)
    ВХОД: корень - корневой узел дерева
    ВЫХОД: список значений узлов в порядке обхода

    ЕСЛИ корень = NULL:
        ВОЗВРАТИТЬ []
    КОНЕЦ ЕСЛИ

    стек = [корень]
    результат = []

    WHILE стек НЕ пуст:
        узел = ВЗЯТЬ_ИЗ_СТЕКА(стек)
        ДОБАВИТЬ(узел.значение, результат)

        // Сначала добавляем правый потомок, затем левый (чтобы левый был обработан первым)
        ЕСЛИ узел.правый НЕ NULL:
            ДОБАВИТЬ(узел.правый, стек)
        КОНЕЦ ЕСЛИ
        ЕСЛИ узел.левый НЕ NULL:
            ДОБАВИТЬ(узел.левый, стек)
        КОНЕЦ ЕСЛИ
    КОНЕЦ WHILE

    ВОЗВРАТИТЬ результат
КОНЕЦ АЛГОРИТМА
```

## Реализация на Python

```python
def dfs_recursive(graph, start, visited=None):
    """
    Рекурсивная реализация поиска в глубину
    :param graph: граф в виде словаря смежности
    :param start: начальный узел
    :param visited: множество посещенных узлов
    :return: список посещенных узлов в порядке обхода
    """
    if visited is None:
        visited = set()

    visited.add(start)
    result = [start]

    # Обходим всех соседей текущего узла
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result.extend(dfs_recursive(graph, neighbor, visited))

    return result

def dfs_iterative(graph, start):
    """
    Итеративная реализация поиска в глубину с использованием стека
    :param graph: граф в виде словаря смежности
    :param start: начальный узел
    :return: список посещенных узлов в порядке обхода
    """
    visited = set()
    stack = [start]
    result = []

    while stack:
        vertex = stack.pop()

        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)

            # Добавляем соседей в стек (в обратном порядке для сохранения порядка обхода)
            for neighbor in reversed(graph.get(vertex, [])):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result

# Пример использования
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("Рекурсивный DFS:", dfs_recursive(graph, 'A'))
print("Итеративный DFS:", dfs_iterative(graph, 'A'))
```

## Реализация для дерева

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def dfs_tree_recursive(root):
    """
    DFS для бинарного дерева (рекурсивный подход)
    """
    if not root:
        return []

    result = [root.val]
    result.extend(dfs_tree_recursive(root.left))
    result.extend(dfs_tree_recursive(root.right))

    return result

def dfs_tree_iterative(root):
    """
    DFS для бинарного дерева (итеративный подход)
    """
    if not root:
        return []

    stack = [root]
    result = []

    while stack:
        node = stack.pop()
        result.append(node.val)

        # Сначала добавляем правый потомок, затем левый (чтобы левый был обработан первым)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

# Пример дерева
#       1
#      / \
#     2   3
#    / \
#   4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("DFS дерева (рекурсивно):", dfs_tree_recursive(root))
print("DFS дерева (итеративно):", dfs_tree_iterative(root))
```

## Реализация на JavaScript

```javascript
// DFS для графа (рекурсивный подход)
function dfsRecursive(graph, start, visited = new Set(), result = []) {
    visited.add(start);
    result.push(start);

    const neighbors = graph[start] || [];
    for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
            dfsRecursive(graph, neighbor, visited, result);
        }
    }

    return result;
}

// DFS для графа (итеративный подход)
function dfsIterative(graph, start) {
    const visited = new Set();
    const stack = [start];
    const result = [];

    while (stack.length > 0) {
        const vertex = stack.pop();

        if (!visited.has(vertex)) {
            visited.add(vertex);
            result.push(vertex);

            // Добавляем соседей в стек (в обратном порядке для сохранения порядка обхода)
            const neighbors = graph[vertex] || [];
            for (let i = neighbors.length - 1; i >= 0; i--) {
                const neighbor = neighbors[i];
                if (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }

    return result;
}

// DFS для дерева (рекурсивный подход)
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function dfsTreeRecursive(root) {
    if (!root) return [];

    const result = [root.val];
    result.push(...dfsTreeRecursive(root.left));
    result.push(...dfsTreeRecursive(root.right));

    return result;
}

// DFS для дерева (итеративный подход)
function dfsTreeIterative(root) {
    if (!root) return [];

    const stack = [root];
    const result = [];

    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);

        // Сначала добавляем правый потомок, затем левый (чтобы левый был обработан первым)
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }

    return result;
}

// Пример использования
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
};

console.log("Рекурсивный DFS:", dfsRecursive(graph, 'A'));
console.log("Итеративный DFS:", dfsIterative(graph, 'A'));

// Пример дерева
//       1
//      / \
//     2   3
//    / \
//   4   5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log("DFS дерева (рекурсивно):", dfsTreeRecursive(root));
console.log("DFS дерева (итеративно):", dfsTreeIterative(root));
```

## Временная сложность

- Для графа: O(V + E), где V - количество вершин, E - количество рёбер
- Для дерева: O(N), где N - количество узлов

## Пространственная сложность

- Рекурсивная версия: O(h), где h - высота дерева/глубина графа (из-за стека вызовов)
- Итеративная версия: O(h) для хранения стека

## Преимущества

- Эффективен по памяти для "узких" графов
- Хорошо подходит для задач поиска пути в лабиринтах
- Полезен для топологической сортировки
- Может использоваться для обнаружения циклов в графе
- Подходит для решения головоломок с единственным решением

## Недостатки

- Может застрять в бесконечном цикле в графе с циклами (без отслеживания посещенных узлов)
- Не гарантирует нахождение кратчайшего пути
- Может потребовать много памяти при большой глубине рекурсии

## Практическое применение

DFS используется:

- В социальных сетях (ВКонтакте, Одноклассники) для поиска связей между пользователями
- В рекомендательных системах для анализа сетей связей
- В картографических сервисах (например, 2GIS) для поиска маршрутов
- В системах анализа кода для поиска зависимостей
- В игровых движках для поиска путей и решения головоломок
- В системах машинного обучения для построения деревьев решений

> [!tip] Практический совет
> Часто используют комбинации DFS и BFS в зависимости от задачи. Для задач, где важна глубина поиска или требуется минимальное количество памяти, выбирают DFS.

> [!warning] Важно
> При реализации DFS в промышленных системах обязательно отслеживайте посещенные узлы, чтобы избежать бесконечных циклов в графах с циклами.

## Расширенные применения

1. **Обнаружение циклов в графе**:
```python
def has_cycle_directed(graph):
    """
    Проверка наличия цикла в ориентированном графе
    """
    WHITE, GRAY, BLACK = 0, 1, 2
    color = {u: WHITE for u in graph}
    
    def dfs_visit(u):
        color[u] = GRAY
        for v in graph.get(u, []):
            if color[v] == GRAY:  # Обнаружен обратное ребро
                return True
            if color[v] == WHITE and dfs_visit(v):
                return True
        color[u] = BLACK
        return False
    
    for u in graph:
        if color[u] == WHITE:
            if dfs_visit(u):
                return True
    return False
```

2. **Топологическая сортировка**:
```python
def topological_sort(graph):
    """
    Топологическая сортировка с использованием DFS
    """
    visited = set()
    stack = []
    
    def dfs_topo(node):
        visited.add(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs_topo(neighbor)
        stack.append(node)
    
    for node in graph:
        if node not in visited:
            dfs_topo(node)
    
    return stack[::-1]  # Возвращаем в обратном порядке
```

## Сравнение с другими алгоритмами

- [[Поиск-в-ширину]] - находит кратчайший путь, но требует больше памяти
- [[Бинарный-поиск]] - эффективен для поиска в отсортированных массивах
- [[Линейный-поиск]] - прост, но менее эффективен для больших структур

## Заключение

Поиск в глубину остается важным алгоритмом благодаря своей эффективности и широкому спектру применения. Понимание этого алгоритма критически важно для решения задач на графах и деревьях, а также для прохождения технических собеседований в ведущие IT-компании.