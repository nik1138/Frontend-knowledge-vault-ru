---
aliases: ["Heap Sort", "Пирамидальная сортировка", "Сортировка кучей"]
tags: [алгоритмы, сортировка, эффективность, подготовка-к-собеседованиям]
---

# Пирамидальная сортировка

## Определение

Пирамидальная сортировка (Heap Sort) - это эффективный алгоритм сортировки, основанный на структуре данных "куча" (heap). Алгоритм строит максимальную кучу из входных данных, а затем многократно извлекает максимальный элемент из кучи и помещает его в конец массива.

## История

Алгоритм был разработан Дж. У. Дж. Уильямсом в 1964 году. Пирамидальная сортировка используется в системах, где важна гарантированная временная сложность и минимальное использование дополнительной памяти.

## Принцип работы

1. Построение максимальной кучи из неотсортированного массива
2. Перемещение корня кучи (наибольшего элемента) в конец массива
3. Уменьшение размера кучи на 1
4. Восстановление свойства кучи для оставшихся элементов
5. Повторение шагов 2-4 до тех пор, пока куча не будет пустой

## Псевдокод

```
АЛГОРИТМ Пирамидальная_Сортировка(массив)
    ВХОД: массив - неотсортированный массив элементов
    ВЫХОД: отсортированный массив элементов

    n = ДЛИНА(массив)

    // Построение максимальной кучи (перегруппировка массива)
    FOR i = n/2 - 1 DOWNTO 0:
        ВЫЗВАТЬ heapify(массив, n, i)
    КОНЕЦ FOR

    // Извлечение элементов из кучи по одному
    FOR i = n - 1 DOWNTO 1:
        // Перемещаем текущий корень в конец
        ОБМЕН(массив[0], массив[i])
        // Вызываем heapify для уменьшенной кучи
        ВЫЗВАТЬ heapify(массив, i, 0)
    КОНЕЦ FOR

    ВОЗВРАТИТЬ массив
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ heapify(массив, n, i)
    ВХОД: массив - массив, n - размер кучи, i - индекс корня поддерева
    ВЫХОД: преобразованное поддерево в максимальную кучу

    largest = i      // Инициализация наибольшего элемента как корень
    left = 2 * i + 1 // Левый потомок
    right = 2 * i + 2 // Правый потомок

    // Если левый потомок существует и больше корня
    ЕСЛИ left < n И массив[left] > массив[largest]:
        largest = left
    КОНЕЦ ЕСЛИ

    // Если правый потомок существует и больше текущего largest
    ЕСЛИ right < n И массив[right] > массив[largest]:
        largest = right
    КОНЕЦ ЕСЛИ

    // Если largest не корень
    ЕСЛИ largest != i:
        ОБМЕН(массив[i], массив[largest])
        ВЫЗВАТЬ heapify(массив, n, largest) // Рекурсивно преобразуем поддерево
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

## Реализация на Python

```python
def heapify(arr, n, i):
    """
    Функция для преобразования поддерева с корнем в i в максимальную кучу
    :param arr: массив
    :param n: размер кучи
    :param i: индекс корня поддерева
    """
    largest = i  # Инициализация наибольшего элемента как корень
    left = 2 * i + 1     # Левый потомок
    right = 2 * i + 2    # Правый потомок

    # Если левый потомок существует и больше корня
    if left < n and arr[left] > arr[largest]:
        largest = left

    # Если правый потомок существует и больше текущего largest
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Если largest не корень
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Обмен
        # Рекурсивно преобразуем поддерево
        heapify(arr, n, largest)

def heap_sort(arr):
    """
    Пирамидальная сортировка
    :param arr: список элементов для сортировки
    :return: отсортированный список
    """
    n = len(arr)

    # Построение максимальной кучи
    # Начинаем с последнего узла, у которого есть потомки
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извлечение элементов из кучи по одному
    for i in range(n - 1, 0, -1):
        # Перемещаем текущий корень в конец
        arr[0], arr[i] = arr[i], arr[0]

        # Вызываем heapify для уменьшенной кучи
        heapify(arr, i, 0)

    return arr

# Пример использования
numbers = [64, 34, 25, 12, 22, 11, 90]
print(f"До сортировки: {numbers}")
heap_sort(numbers)
print(f"После сортировки: {numbers}")
```

## Реализация на JavaScript

```javascript
function heapify(arr, n, i) {
    let largest = i;  // Инициализация наибольшего элемента как корень
    let left = 2 * i + 1;     // Левый потомок
    let right = 2 * i + 2;    // Правый потомок

    // Если левый потомок существует и больше корня
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // Если правый потомок существует и больше текущего largest
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // Если largest не корень
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];  // Обмен
        // Рекурсивно преобразуем поддерево
        heapify(arr, n, largest);
    }
}

function heapSort(arr) {
    const n = arr.length;

    // Построение максимальной кучи
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Извлечение элементов из кучи по одному
    for (let i = n - 1; i > 0; i--) {
        // Перемещаем текущий корень в конец
        [arr[0], arr[i]] = [arr[i], arr[0]];

        // Вызываем heapify для уменьшенной кучи
        heapify(arr, i, 0);
    }

    return arr;
}

// Пример использования
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log("До сортировки:", numbers);
console.log("После сортировки:", heapSort([...numbers]));
```

## Временная сложность

- **Лучший случай**: O(n log n)
- **Средний случай**: O(n log n)
- **Худший случай**: O(n log n)

## Пространственная сложность

- O(1) - алгоритм сортировки на месте, не требует дополнительной памяти, кроме стека вызовов рекурсии

## Преимущества

- Гарантированная O(n log n) сложность во всех случаях
- Алгоритм на месте (in-place) - требует только O(1) дополнительной памяти
- Не чувствителен к входным данным
- Хорошо работает с большими объемами данных

## Недостатки

- Неустойчив (не сохраняет относительный порядок равных элементов)
- Медленнее [[Быстрая-сортировка]] в среднем случае
- Не адаптивен к частично отсортированным данным
- Плохая локальность ссылок по сравнению с другими алгоритмами

## Практическое применение

Пирамидальная сортировка используется:

- В системах реального времени, где важна предсказуемость производительности
- В embedded системах с ограниченной памятью
- В космических и военных системах, где важна надежность
- В системах, где критична максимальная временная сложность
- При реализации приоритетных очередей

> [!tip] Практический совет
> Пирамидальная сортировка может быть предпочтительной в системах, где важна гарантия максимального времени выполнения, например, в системах управления транспортом или финансовыми транзакциями.

> [!warning] Важно
> Несмотря на гарантированную сложность, в среднем случае пирамидальная сортировка медленнее [[Быстрая-сортировка]], поэтому в общем случае последняя часто предпочтительнее.

## Сравнение с другими алгоритмами

- [[Быстрая-сортировка]] - быстрее в среднем случае, но с худшей гарантией производительности
- [[Сортировка-слиянием]] - стабильна с гарантированной O(n log n), но требует O(n) дополнительной памяти
- [[Сортировка-пузырьком]] - значительно медленнее с O(n²) сложностью

## Реализация приоритетной очереди

```python
class MaxHeap:
    def __init__(self):
        self.heap = []
    
    def parent(self, i):
        return (i - 1) // 2
    
    def left_child(self, i):
        return 2 * i + 1
    
    def right_child(self, i):
        return 2 * i + 2
    
    def insert(self, key):
        self.heap.append(key)
        self._heapify_up(len(self.heap) - 1)
    
    def _heapify_up(self, i):
        while i != 0 and self.heap[self.parent(i)] < self.heap[i]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)
    
    def extract_max(self):
        if len(self.heap) == 0:
            return None
        
        root = self.heap[0]
        
        # Перемещаем последний элемент в корень
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        
        # Восстанавливаем свойства кучи
        if len(self.heap) > 0:
            self._heapify_down(0)
        
        return root
    
    def _heapify_down(self, i):
        while True:
            largest = i
            left = self.left_child(i)
            right = self.right_child(i)
            
            if left < len(self.heap) and self.heap[left] > self.heap[largest]:
                largest = left
            
            if right < len(self.heap) and self.heap[right] > self.heap[largest]:
                largest = right
            
            if largest == i:
                break
            
            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]
            i = largest
```

## Заключение

Пирамидальная сортировка остается важным алгоритмом благодаря своей гарантированной эффективности и минимальному использованию памяти. Несмотря на то, что она не так часто используется в повседневной разработке, как [[Быстрая-сортировка]], знание этого алгоритма критически важно для понимания структур данных и прохождения технических собеседований.