---
aliases: ["Оптимизация памяти в DP", "Memory optimization in DP", "Space optimization"]
tags: [алгоритмы, динамическое_программирование, оптимизация, память]
---

# Оптимизация по памяти

## Общее описание

**Оптимизация по памяти** в динамическом программировании — это техника уменьшения объема памяти, необходимого для решения задачи, без изменения временной сложности алгоритма. Это особенно важно в условиях ограниченных ресурсов или при работе с большими объемами данных.

## Основные методы оптимизации

### 1. Сжатие размерности таблицы

Многие задачи DP используют только несколько предыдущих строк или столбцов таблицы для вычисления текущего значения. В таких случаях можно сократить размерность таблицы.

#### Пример: [[Задача-о-рюкзаке]] с оптимизацией по памяти

**Базовое решение:**

```
АЛГОРИТМ Рюкзак_Базовый(weights, values, capacity)
    n = ДЛИНА(weights)
    // dp[i][w] - максимальная стоимость для первых i предметов и вместимости w
    СОЗДАТЬ dp[n+1][capacity+1] и инициализировать нулями

    ДЛЯ i ОТ 1 ДО n ВКЛЮЧАЯ
        ДЛЯ w ОТ 0 ДО capacity ВКЛЮЧАЯ
            dp[i][w] = dp[i-1][w]  // Не берем i-й предмет

            ЕСЛИ weights[i-1] <= w ТО
                dp[i][w] = МАКСИМУМ(dp[i][w], dp[i-1][w - weights[i-1]] + values[i-1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[n][capacity]
КОНЕЦ АЛГОРИТМ
```

```javascript
function knapsackBasic(weights, values, capacity) {
    const n = weights.length;
    // dp[i][w] - максимальная стоимость для первых i предметов и вместимости w
    const dp = Array(n + 1).fill(null).map(() => Array(capacity + 1).fill(0));

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            dp[i][w] = dp[i-1][w];  // Не берем i-й предмет

            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w],
                                   dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}
```

**Оптимизированное решение:**

```
АЛГОРИТМ Рюкзак_Оптимизированный(weights, values, capacity)
    n = ДЛИНА(weights)
    // Используем только один массив, так как dp[i][w] зависит только от dp[i-1][w]
    СОЗДАТЬ dp[capacity+1] и инициализировать нулями

    ДЛЯ i ОТ 0 ДО n-1 ВКЛЮЧАЯ
        // Обход в обратном порядке, чтобы не использовать обновленные значения
        ДЛЯ w ОТ capacity ДО weights[i] ВКЛЮЧАЯ С ШАГОМ -1
            dp[w] = МАКСИМУМ(dp[w], dp[w - weights[i]] + values[i])
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[capacity]
КОНЕЦ АЛГОРИТМ
```

```javascript
function knapsackOptimized(weights, values, capacity) {
    const n = weights.length;
    // Используем только один массив, так как dp[i][w] зависит только от dp[i-1][w]
    const dp = new Array(capacity + 1).fill(0);

    for (let i = 0; i < n; i++) {
        // Обход в обратном порядке, чтобы не использовать обновленные значения
        for (let w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }

    return dp[capacity];
}
```

**Сравнение:**
- Базовое решение: O(n * W) по памяти
- Оптимизированное: O(W) по памяти

### 2. Использование двух строк вместо всей таблицы

Для задач, где текущее состояние зависит только от предыдущего, можно использовать только две строки таблицы.

#### Пример: [[Наибольшая-общая-подпоследовательность]] с оптимизацией

**Базовое решение:**
```javascript
function lcsBasic(X, Y) {
    const m = X.length;
    const n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[m][n];
}
```

**Оптимизированное решение:**
```javascript
function lcsOptimized(X, Y) {
    const m = X.length;
    const n = Y.length;
    // Используем только две строки
    let prev = new Array(n + 1).fill(0);
    let curr = new Array(n + 1).fill(0);

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = Math.max(prev[j], curr[j-1]);
            }
        }
        // Меняем местами строки
        [prev, curr] = [curr, prev];
    }

    return prev[n];
}
```

### 3. Использование переменных вместо массивов

Для задач, где текущее состояние зависит только от нескольких предыдущих значений, можно использовать переменные.

#### Пример: Числа Фибоначчи

```javascript
function fibonacciOptimized(n) {
    if (n <= 1) {
        return n;
    }

    // Вместо массива из n элементов используем две переменные
    let prev2 = 0, prev1 = 1;

    for (let i = 2; i <= n; i++) {
        const current = prev1 + prev2;
        [prev2, prev1] = [prev1, current];
    }

    return prev1;
}
```

## Продвинутые методы оптимизации

### 1. Метод двух указателей

Для некоторых задач можно использовать метод двух указателей, чтобы избежать хранения промежуточных результатов.

### 2. Скользящее окно

Когда текущее состояние зависит только от фиксированного числа предыдущих состояний, можно использовать скользящее окно.

```javascript
function slidingWindowMax(arr, k) {
    // Используем массив как очередь для хранения индексов
    const dq = [];
    const result = [];

    for (let i = 0; i < arr.length; i++) {
        // Удаляем элементы, которые вышли за пределы окна
        while (dq.length > 0 && dq[0] <= i - k) {
            dq.shift();
        }

        // Удаляем элементы, которые не могут быть максимумом
        while (dq.length > 0 && arr[dq[dq.length - 1]] <= arr[i]) {
            dq.pop();
        }

        dq.push(i);

        // Добавляем максимум текущего окна в результат
        if (i >= k - 1) {
            result.push(arr[dq[0]]);
        }
    }

    return result;
}
```

### 3. Использование битовых масок

Для задач с небольшим количеством состояний можно использовать битовые маски для компактного хранения информации.

## Практические применения

1. **Мобильные приложения**: Экономия памяти особенно важна на устройствах с ограниченными ресурсами
2. **Встраиваемые системы**: В IoT-устройствах и системах реального времени
3. **Большие данные**: При обработке больших массивов информации
4. **Игровая индустрия**: Оптимизация алгоритмов для консольных игр и мобильных приложений
5. **Финансовые системы**: Обработка потоков данных с ограничениями по памяти
6. **Системы анализа**: В системах мониторинга и анализа больших объемов данных

## Примеры оптимизации

### Задача: Максимальная сумма без двух соседних элементов

**Без оптимизации:**
```javascript
function maxSumNonAdjacentBasic(arr) {
    if (arr.length === 0) {
        return 0;
    }
    if (arr.length === 1) {
        return Math.max(0, arr[0]);
    }

    const n = arr.length;
    const dp = new Array(n).fill(0);
    dp[0] = Math.max(0, arr[0]);
    dp[1] = Math.max(dp[0], arr[1]);

    for (let i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + arr[i]);
    }

    return dp[n-1];
}
```

**С оптимизацией:**
```javascript
function maxSumNonAdjacentOptimized(arr) {
    if (arr.length === 0) {
        return 0;
    }
    if (arr.length === 1) {
        return Math.max(0, arr[0]);
    }

    // Используем только две переменные вместо массива
    let prev2 = Math.max(0, arr[0]);
    let prev1 = Math.max(prev2, arr[1]);

    for (let i = 2; i < arr.length; i++) {
        const current = Math.max(prev1, prev2 + arr[i]);
        [prev2, prev1] = [prev1, current];
    }

    return prev1;
}
```

## Рекомендации по оптимизации

1. **Анализ зависимости**: Определите, от каких предыдущих состояний зависит текущее
2. **Оценка размерности**: Рассмотрите возможность уменьшения размерности таблицы
3. **Порядок вычислений**: Убедитесь, что при оптимизации порядок вычислений не нарушается
4. **Тестирование**: Проверяйте корректность оптимизированного решения на различных тестах
5. **Профилирование**: Используйте инструменты профилирования для измерения реальной эффективности

## Заключение

Оптимизация по памяти — важный аспект реализации алгоритмов динамического программирования. В условиях современных требований к эффективности и ограничений по ресурсам, особенно в российской IT-индустрии 2025 года, умение оптимизировать использование памяти становится критически важным навыком. Правильная оптимизация может значительно улучшить производительность приложений и расширить сферу их применения.

## См. также
- [[Основы-динамического-программирования]]
- [[Таблица-для-хранения-результатов]]
- [[Рекурсивные-и-итеративные-решения]]
- [[Примеры-на-массивах]]