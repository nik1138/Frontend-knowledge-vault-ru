---
aliases: ["Таблица DP", "DP Table", "Хранилище результатов DP"]
tags: [алгоритмы, динамическое_программирование, оптимизация, структуры данных]
---

# Таблица для хранения результатов

## Общее описание

**Таблица для хранения результатов** — это структура данных, используемая в динамическом программировании для хранения результатов вычисленных подзадач. Это позволяет избежать повторных вычислений и эффективно строить решения более сложных задач на основе решений более простых.

Таблица может быть реализована как массив, матрица или многомерная структура в зависимости от количества параметров, определяющих состояние задачи.

## Виды таблиц

### 1. Одномерная таблица
Используется, когда состояние задачи определяется одним параметром.

**Пример: Числа Фибоначчи**

```
АЛГОРИТМ Фибоначчи(n)
    ЕСЛИ n <= 1 ТО
        ВОЗВРАТ n
    КОНЕЦ ЕСЛИ
    СОЗДАТЬ массив dp размером n+1
    dp[0] = 0
    dp[1] = 1
    ДЛЯ i ОТ 2 ДО n ВКЛЮЧАЯ
        dp[i] = dp[i-1] + dp[i-2]
    КОНЕЦ ДЛЯ
    ВОЗВРАТ dp[n]
КОНЕЦ АЛГОРИТМ
```

```javascript
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    const dp = new Array(n + 1).fill(0);
    dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

### 2. Двумерная таблица
Используется, когда состояние задачи определяется двумя параметрами.

**Пример: [[Наибольшая-общая-подпоследовательность]]**
```javascript
function lcsLength(X, Y) {
    const m = X.length;
    const n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[m][n];
}
```

### 3. Многомерная таблица
Используется для задач с несколькими параметрами состояния.

**Пример: [[Задача-о-рюкзаке]] с дополнительными ограничениями**
```javascript
function knapsack3D(weights, values, categories, capacity, maxCategories) {
    const n = weights.length;
    // dp[i][w][c] = максимальная стоимость для первых i предметов,
    // с вместимостью w и количеством категорий c
    const dp = Array(n + 1).fill(null).map(() =>
        Array(capacity + 1).fill(null).map(() =>
            Array(maxCategories + 1).fill(0)
        )
    );

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            for (let c = 0; c <= maxCategories; c++) {
                // Не берем i-й предмет
                dp[i][w][c] = dp[i-1][w][c];

                // Берем i-й предмет, если возможно
                if (weights[i-1] <= w && c >= categories[i-1]) {
                    dp[i][w][c] = Math.max(
                        dp[i][w][c],
                        dp[i-1][w - weights[i-1]][c - categories[i-1]] + values[i-1]
                    );
                }
            }
        }
    }

    return dp[n][capacity][maxCategories];
}
```

## Выбор структуры данных

### Массивы
- Наиболее эффективны по времени доступа
- Подходят для задач с числовыми индексами
- Используются в большинстве классических задач DP

### Хэш-таблицы (ассоциативные массивы)
- Подходят для задач с нечисловыми или разреженными параметрами
- Могут быть полезны при [[Мемоизация]]
- Имеют больший оверхед по сравнению с массивами

### Смешанные структуры
- Комбинация массивов и хэш-таблиц
- Используются в сложных задачах с различными типами состояний

## Оптимизация таблицы

### 1. Сжатие размерности
Многие задачи позволяют использовать только 1D массив вместо 2D, если текущее состояние зависит только от предыдущего.

```javascript
// Вместо 2D массива для LCS
function lcsLengthOptimized(X, Y) {
    const m = X.length;
    const n = Y.length;
    let prev = Array(n + 1).fill(0);
    let curr = Array(n + 1).fill(0);

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = Math.max(prev[j], curr[j-1]);
            }
        }
        [prev, curr] = [curr, prev];
    }

    return prev[n];
}
```

### 2. Использование только необходимых значений
В некоторых задачах можно обойтись несколькими переменными вместо целой таблицы.

```javascript
// Числа Фибоначчи с оптимизацией памяти
function fibonacciOptimized(n) {
    if (n <= 1) {
        return n;
    }
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b];
    }
    return b;
}
```

## Практические рекомендации

1. **Выбор подходящей размерности**: Анализируйте параметры задачи для определения минимально необходимой размерности таблицы
2. **Учет ограничений по памяти**: В условиях ограниченных ресурсов используйте [[Оптимизация-по-памяти]]
3. **Инициализация таблицы**: Правильно устанавливайте начальные значения (базовые случаи)
4. **Порядок заполнения**: Следите за тем, чтобы при вычислении значения ячейки все необходимые предыдущие значения уже были рассчитаны
5. **Отладка таблицы**: В сложных задачах полезно выводить промежуточные состояния таблицы для проверки корректности

## Примеры использования в различных задачах

### 1. Редакционное расстояние
Двумерная таблица, где dp[i][j] — минимальное расстояние между префиксами строк длины i и j.

### 2. Умножение матриц
Трехмерная таблица для оптимизации порядка умножения матриц.

### 3. Рюкзак с кратными предметами
Двумерная таблица, где третий параметр может быть закодирован в индексах.

## Заполнение таблицы: пошаговый подход

1. **Определение состояния**: Определите параметры, описывающие подзадачу
2. **Определение размерности**: Решите, сколько измерений потребуется для таблицы
3. **Инициализация**: Установите базовые значения (граничные условия)
4. **Определение переходов**: Определите, как вычислить значение для текущего состояния на основе предыдущих
5. **Порядок вычислений**: Убедитесь, что при вычислении значения ячейки все зависимости уже вычислены
6. **Извлечение результата**: Определите, где в таблице находится ответ на исходную задачу

## Заключение

Таблица для хранения результатов — ключевой компонент реализации динамического программирования. Правильный выбор структуры и эффективное использование таблицы позволяют решать сложные задачи с приемлемой временной и пространственной сложностью. В условиях развития высоконагруженных систем в российской IT-индустрии 2025 года, оптимизация таблиц DP становится особенно важной.

## См. также
- [[Основы-динамического-программирования]]
- [[Мемоизация]]
- [[Оптимизация-по-памяти]]
- [[Примеры-на-массивах]]