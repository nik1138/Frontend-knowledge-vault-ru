---
aliases: ["Рекурсивные и итеративные DP", "Top-down vs Bottom-up", "Подходы к DP"]
tags: [алгоритмы, динамическое_программирование, рекурсия, итерации, оптимизация]
---

# Рекурсивные и итеративные решения

## Общее описание

В динамическом программировании существуют два основных подхода к реализации решений: **рекурсивный** (top-down) и **итеративный** (bottom-up). Оба подхода используют одинаковую логику решения задачи, но отличаются способом вычисления и хранения результатов подзадач.

## Рекурсивный подход (Top-down)

Рекурсивный подход начинает решение задачи с её конечной цели и рекурсивно разбивает её на более простые подзадачи. Для избежания повторных вычислений используется [[Мемоизация]].

### Основные характеристики:
- Решение задачи "сверху вниз"
- Использование рекурсии с кэшированием
- Вычисление только необходимых подзадач
- Возможное переполнение стека при глубокой рекурсии

### Пример: Числа Фибоначчи (рекурсивно с мемоизацией)

```
АЛГОРИТМ Фибоначчи_Мемо(n, memo)
    ЕСЛИ n В memo ТО
        ВОЗВРАТ memo[n]
    КОНЕЦ ЕСЛИ

    ЕСЛИ n <= 1 ТО
        ВОЗВРАТ n
    КОНЕЦ ЕСЛИ

    memo[n] = Фибоначчи_Мемо(n-1, memo) + Фибоначчи_Мемо(n-2, memo)
    ВОЗВРАТ memo[n]
КОНЕЦ АЛГОРИТМ
```

```javascript
function fibonacciMemo(n, memo = new Map()) {
    if (memo.has(n)) {
        return memo.get(n);
    }

    if (n <= 1) {
        return n;
    }

    const result = fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo);
    memo.set(n, result);
    return result;
}

// Использование Map для мемоизации
const memo = new Map();
function fibonacciCached(n) {
    if (memo.has(n)) {
        return memo.get(n);
    }

    if (n <= 1) {
        memo.set(n, n);
        return n;
    }

    const result = fibonacciCached(n-1) + fibonacciCached(n-2);
    memo.set(n, result);
    return result;
}
```

### Пример: [[Задача-о-рюкзаке]] (рекурсивно)

```javascript
function knapsackRecursive(weights, values, capacity) {
    const n = weights.length;
    const memo = new Map();

    function dp(i, w) {
        if (i === 0 || w === 0) {
            return 0;
        }

        const key = `${i},${w}`;
        if (memo.has(key)) {
            return memo.get(key);
        }

        let result;
        if (weights[i-1] > w) {
            // Не можем взять i-й предмет
            result = dp(i-1, w);
        } else {
            // Выбираем максимум между взятием и непринятием i-го предмета
            result = Math.max(
                dp(i-1, w),  // Не берем предмет
                dp(i-1, w - weights[i-1]) + values[i-1]  // Берем предмет
            );
        }

        memo.set(key, result);
        return result;
    }

    return dp(n, capacity);
}
```

## Итеративный подход (Bottom-up)

Итеративный подход начинает с самых простых подзадач и последовательно строит решение более сложных задач, пока не достигнет цели.

### Основные характеристики:
- Решение задачи "снизу вверх"
- Использование таблицы для хранения результатов
- Гарантированное вычисление всех необходимых подзадач
- Более предсказуемое использование памяти и времени

### Пример: Числа Фибоначчи (итеративно)

```javascript
function fibonacciIter(n) {
    if (n <= 1) {
        return n;
    }

    const dp = new Array(n + 1).fill(0);
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}

// Оптимизированная версия по памяти
function fibonacciIterOptimized(n) {
    if (n <= 1) {
        return n;
    }

    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b];
    }

    return b;
}
```

### Пример: [[Задача-о-рюкзаке]] (итеративно)

```javascript
function knapsackIterative(weights, values, capacity) {
    const n = weights.length;
    // dp[i][w] - максимальная стоимость для первых i предметов и вместимости w
    const dp = Array(n + 1).fill(null).map(() => Array(capacity + 1).fill(0));

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            // Не берем i-й предмет
            dp[i][w] = dp[i-1][w];

            // Если можем взять i-й предмет, проверяем, выгодно ли это
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w],
                              dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}
```

## Сравнение подходов

| Характеристика | Рекурсивный (Top-down) | Итеративный (Bottom-up) |
|----------------|------------------------|--------------------------|
| Направление вычислений | Сверху вниз | Снизу вверх |
| Вычисление подзадач | Только необходимые | Все подзадачи в определенном порядке |
| Использование стека | Да, может быть переполнение | Нет |
| Использование памяти | Только для нужных состояний | Для всех возможных состояний |
| Читаемость кода | Часто более интуитивная | Требует планирования порядка вычислений |
| Сложность реализации | Иногда проще для понимания | Требует тщательного планирования |

## Практические рекомендации

### Когда использовать рекурсивный подход:
1. **Когда структура задачи естественным образом выражается рекурсивно**
2. **Когда не все подзадачи будут вычислены** (разреженные задачи)
3. **Для прототипирования и понимания логики решения**
4. **В системах с достаточной глубиной стека**

### Когда использовать итеративный подход:
1. **Когда важна производительность и предсказуемость**
2. **В системах с ограничениями по стеку**
3. **Когда все или большинство подзадач будут вычислены**
4. **В высоконагруженных системах**

### Примеры из практики:
1. **Финансовые системы**: Итеративный подход для расчета сложных финансовых инструментов
2. **Игровые движки**: Рекурсивный подход для ИИ и построения деревьев решений
3. **Системы анализа данных**: Комбинация обоих подходов для оптимизации вычислений
4. **Мобильные приложения**: Итеративный подход для экономии ресурсов

## Преобразование между подходами

Любую задачу, решаемую рекурсивно, можно решить итеративно, и наоборот. Преобразование требует понимания структуры задачи:

1. **Рекурсивное определение состояния** → **Итеративная таблица**
2. **Рекурсивные вызовы** → **Циклы с правильным порядком**
3. **Базовые случаи** → **Инициализация таблицы**

## Пример: Одинаковые решения разными подходами

Рассмотрим задачу нахождения количества путей в матрице:

### Рекурсивный подход:
```javascript
function countPathsRecursive(m, n) {
    const memo = new Map();

    function dp(i, j) {
        const key = `${i},${j}`;
        if (memo.has(key)) {
            return memo.get(key);
        }

        if (i === 0 || j === 0) {
            return 1;
        }

        const result = dp(i-1, j) + dp(i, j-1);
        memo.set(key, result);
        return result;
    }

    return dp(m-1, n-1);
}
```

### Итеративный подход:
```javascript
function countPathsIterative(m, n) {
    const dp = Array(m).fill(null).map(() => Array(n).fill(0));

    // Инициализация первой строки и столбца
    for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (let j = 0; j < n; j++) {
        dp[0][j] = 1;
    }

    // Заполнение таблицы
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
}
```

## Заключение

Оба подхода к реализации динамического программирования имеют свои преимущества и недостатки. Выбор между рекурсивным и итеративным подходом зависит от конкретной задачи, ограничений системы и требований к производительности. В условиях развития российской IT-индустрии в 2025 году, понимание обоих подходов и умение выбирать наиболее подходящий для конкретной ситуации становится важным навыком для разработчиков.

## См. также
- [[Основы-динамического-программирования]]
- [[Мемоизация]]
- [[Таблица-для-хранения-результатов]]
- [[Оптимизация-по-памяти]]