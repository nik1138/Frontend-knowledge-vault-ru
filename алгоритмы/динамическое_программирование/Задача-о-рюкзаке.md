---
aliases: ["Задача о рюкзаке", "Knapsack problem", "Ограниченный рюкзак"]
tags: [алгоритмы, динамическое_программирование, оптимизация, задачи]
---

# Задача о рюкзаке

## Определение задачи

**Задача о рюкзаке** — одна из классических задач комбинаторной оптимизации. Существует несколько вариантов этой задачи, но основная формулировка следующая:

Имеется набор из n предметов, каждый из которых имеет вес w[i] и стоимость c[i]. Также имеется рюкзак, вместимость которого ограничена W. Требуется выбрать подмножество предметов, чтобы:
- Суммарный вес не превышал вместимости рюкзака
- Суммарная стоимость была максимальной

## Виды задачи о рюкзаке

### 1. 0/1 рюкзак
Каждый предмет можно либо взять, либо не взять (0 или 1 экземпляр каждого предмета).

### 2. Рюкзак с повторениями (Unbounded Knapsack)
Можно брать любое количество экземпляров каждого предмета.

### 3. Ограниченный рюкзак
Для каждого предмета задано максимальное количество экземпляров.

## Решение задачи 0/1 рюкзака

### Состояние
dp[i][w] — максимальная стоимость, которую можно получить, используя первые i предметов и рюкзак вместимостью w.

### Переход
```
dp[i][w] = max(
    dp[i-1][w],                    // Не берем i-й предмет
    dp[i-1][w-weight[i]] + cost[i] // Берем i-й предмет (если w >= weight[i])
)
```

### Реализация

```
АЛГОРИТМ 0/1_рюкзак(weights, costs, capacity)
    n = ДЛИНА(weights)
    // Создаем таблицу dp размером (n+1) x (capacity+1)
    СОЗДАТЬ dp[n+1][capacity+1] и инициализировать нулями

    ДЛЯ i ОТ 1 ДО n ВКЛЮЧАЯ
        ДЛЯ w ОТ 0 ДО capacity ВКЛЮЧАЯ
            // Не берем i-й предмет
            dp[i][w] = dp[i-1][w]

            // Если можем взять i-й предмет, проверяем выгодно ли это
            ЕСЛИ weights[i-1] <= w ТО
                dp[i][w] = МАКСИМУМ(dp[i][w], dp[i-1][w - weights[i-1]] + costs[i-1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[n][capacity]
КОНЕЦ АЛГОРИТМ
```

```javascript
function knapsack01(weights, costs, capacity) {
    const n = weights.length;
    // Создаем таблицу dp размером (n+1) x (capacity+1)
    const dp = Array(n + 1).fill(null).map(() => Array(capacity + 1).fill(0));

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            // Не берем i-й предмет
            dp[i][w] = dp[i-1][w];

            // Если можем взять i-й предмет, проверяем выгодно ли это
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w],
                                   dp[i-1][w - weights[i-1]] + costs[i-1]);
            }
        }
    }

    return dp[n][capacity];
}

// Пример использования
const weights = [2, 1, 3, 2];
const costs = [12, 10, 20, 15];
const capacity = 5;
const result = knapsack01(weights, costs, capacity);
console.log(`Максимальная стоимость: ${result}`); // Вывод: 37
```

## Решение задачи о неограниченном рюкзаке

### Переход
```
dp[w] = max(
    dp[w],                    // Не берем ни одного нового предмета
    dp[w-weight[i]] + cost[i] // Берем i-й предмет (если w >= weight[i])
) для всех i
```

### Реализация

```javascript
function unboundedKnapsack(weights, costs, capacity) {
    const dp = new Array(capacity + 1).fill(0);

    for (let w = 1; w <= capacity; w++) {
        for (let i = 0; i < weights.length; i++) {
            if (weights[i] <= w) {
                dp[w] = Math.max(dp[w], dp[w - weights[i]] + costs[i]);
            }
        }
    }

    return dp[capacity];
}

// Пример использования
const weights = [1, 3, 4];
const costs = [1, 4, 5];
const capacity = 7;
const result = unboundedKnapsack(weights, costs, capacity);
console.log(`Максимальная стоимость: ${result}`); // Вывод: 9
```

## Оптимизация по памяти

Для задачи 0/1 рюкзака можно оптимизировать использование памяти с [[Оптимизация-по-памяти]]:

```javascript
function knapsack01Optimized(weights, costs, capacity) {
    const dp = new Array(capacity + 1).fill(0);

    for (let i = 0; i < weights.length; i++) {
        // Обход в обратном порядке, чтобы не использовать обновленные значения
        for (let w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + costs[i]);
        }
    }

    return dp[capacity];
}
```

## Практические применения

1. **Логистика и доставка**: Оптимизация загрузки транспорта с учетом веса и стоимости грузов
2. **Финансовое планирование**: Выбор портфеля инвестиций с ограниченным бюджетом
3. **Ресурсное планирование**: Распределение ограниченных ресурсов между проектами
4. **Игровая индустрия**: Системы инвентаря и оптимизация снаряжения
5. **Производство**: Планирование загрузки оборудования с учетом приоритетов задач

## Сложность алгоритма

- **Временная сложность**: O(n * W), где n — количество предметов, W — вместимость рюкзака
- **Пространственная сложность**: O(n * W) для базовой реализации, O(W) при оптимизации

## Примеры задач

### Задача A: Классический 0/1 рюкзак
- Вход: веса и стоимости предметов, вместимость рюкзака
- Выход: максимальная стоимость

### Задача B: Рюкзак с дополнительными ограничениями
- Вход: предметы с весом, стоимостью и типом
- Ограничение: не более одного предмета каждого типа
- Выход: максимальная стоимость

## Заключение

Задача о рюкзаке — важная классическая задача, решение которой дает понимание принципов динамического программирования. Ее вариации часто встречаются на олимпиадах по программированию и в реальных приложениях, особенно в компаниях, занимающихся логистикой, e-commerce и оптимизацией.

## См. также
- [[Основы-динамического-программирования]]
- [[Мемоизация]]
- [[Рекурсивные-и-итеративные-решения]]
- [[Оптимизация-по-памяти]]