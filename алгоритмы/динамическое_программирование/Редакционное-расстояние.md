---
aliases: ["Расстояние Левенштейна", "Edit Distance", "Минимальное редакционное расстояние"]
tags: [алгоритмы, динамическое_программирование, строки, расстояния]
---

# Редакционное расстояние

## Определение задачи

**Редакционное расстояние** (также известное как **расстояние Левенштейна**) — это минимальное количество операций, необходимых для преобразования одной строки в другую. Классически разрешены три типа операций:
- Вставка символа
- Удаление символа
- Замена символа

Например, расстояние между строками "kitten" и "sitting" равно 3:
1. kitten → sitten (заменить 'k' на 's')
2. sitten → sittin (заменить 'e' на 'i')
3. sittin → sitting (вставить 'g' в конец)

## Формальное определение

Для двух строк X длины m и Y длины n, редакционное расстояние — это минимальное количество операций вставки, удаления и замены, необходимых для преобразования X в Y.

## Подход к решению

### Состояние
dp[i][j] — минимальное редакционное расстояние между префиксами X[0...i-1] и Y[0...j-1].

### Переход
```
if X[i-1] == Y[j-1]:
    dp[i][j] = dp[i-1][j-1]  # Нет необходимости в операции
else:
    dp[i][j] = 1 + min(
        dp[i-1][j],      # Удаление из X
        dp[i][j-1],      # Вставка в X
        dp[i-1][j-1]     # Замена в X
    )
```

### Реализация

```
АЛГОРИТМ Редакционное_Расстояние(X, Y)
    m = ДЛИНА(X)
    n = ДЛИНА(Y)
    // Создаем таблицу dp размером (m+1) x (n+1)
    СОЗДАТЬ dp[m+1][n+1] и инициализировать нулями

    // Инициализация первой строки и столбца
    ДЛЯ i ОТ 0 ДО m ВКЛЮЧАЯ
        dp[i][0] = i  // Удаление всех символов из X
    КОНЕЦ ДЛЯ
    ДЛЯ j ОТ 0 ДО n ВКЛЮЧАЯ
        dp[0][j] = j  // Вставка всех символов из Y
    КОНЕЦ ДЛЯ

    // Заполняем таблицу
    ДЛЯ i ОТ 1 ДО m ВКЛЮЧАЯ
        ДЛЯ j ОТ 1 ДО n ВКЛЮЧАЯ
            ЕСЛИ X[i-1] == Y[j-1] ТО
                dp[i][j] = dp[i-1][j-1]
            ИНАЧЕ
                dp[i][j] = 1 + МИНИМУМ(
                    dp[i-1][j],      // Удаление
                    dp[i][j-1],      // Вставка
                    dp[i-1][j-1]     // Замена
                )
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[m][n]
КОНЕЦ АЛГОРИТМ
```

```javascript
function editDistance(X, Y) {
    const m = X.length;
    const n = Y.length;
    // Создаем таблицу dp размером (m+1) x (n+1)
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    // Инициализация первой строки и столбца
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i; // Удаление всех символов из X
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j; // Вставка всех символов из Y
    }

    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i-1][j],      // Удаление
                    dp[i][j-1],      // Вставка
                    dp[i-1][j-1]     // Замена
                );
            }
        }
    }

    return dp[m][n];
}

// Пример использования
const X = "kitten";
const Y = "sitting";
const distance = editDistance(X, Y);
console.log(`Редакционное расстояние: ${distance}`); // Вывод: 3
```

## Вариации задачи

### 1. Взвешенное редакционное расстояние
Разные операции могут иметь разный вес. Например, замена 'a' на 'o' может быть дешевле, чем замена 'a' на 'z'.

### 2. Расстояние Дамерау-Левенштейна
К трем базовым операциям добавляется транспозиция (перестановка двух соседних символов).

### 3. Расстояние с ограничениями
Некоторые пары символов могут быть недопустимы для замены.

## Практические применения

1. **Системы автокоррекции**: В поисковых системах для исправления опечаток
2. **Поиск похожих строк**: В базах данных и системах рекомендаций
3. **Биоинформатика**: Сравнение последовательностей нуклеотидов или аминокислот
4. **Системы контроля версий**: Для определения изменений между файлами
5. **Плагиатизм-детекторы**: Сравнение текстов с учетом возможных изменений
6. **Машинное обучение**: В задачах NLP для оценки схожести текстов
7. **Генетические алгоритмы**: Для оценки схожести хромосом
8. **Техническая поддержка**: Автоматическое сопоставление запросов с базой знаний

## Оптимизация памяти

Как и в других задачах DP, можно оптимизировать использование памяти до O(min(m,n)):

```javascript
function editDistanceOptimized(X, Y) {
    let m = X.length;
    let n = Y.length;
    // Используем только две строки вместо всей таблицы
    if (m < n) {
        [X, Y] = [Y, X];
        [m, n] = [n, m];
    }

    let prev = Array.from({length: n + 1}, (_, i) => i);
    let curr = Array(n + 1).fill(0);

    for (let i = 1; i <= m; i++) {
        curr[0] = i;
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                curr[j] = prev[j-1];
            } else {
                curr[j] = 1 + Math.min(prev[j], curr[j-1], prev[j-1]);
            }
        }
        // Меняем местами строки
        [prev, curr] = [curr, prev];
    }

    return prev[n];
}
```

## Расширения алгоритма

### Восстановление последовательности операций

```javascript
function editOperations(X, Y) {
    const m = X.length;
    const n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    // Инициализация
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }

    // Заполнение таблицы
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i-1] === Y[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
            }
        }
    }

    // Восстановление операций
    const operations = [];
    let i = m, j = n;
    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && X[i-1] === Y[j-1]) {
            i--;
            j--;
        } else if (i > 0 && j > 0 && dp[i][j] === dp[i-1][j-1] + 1) {
            operations.push(`Заменить '${X[i-1]}' на '${Y[j-1]}' на позиции ${i-1}`);
            i--;
            j--;
        } else if (i > 0 && dp[i][j] === dp[i-1][j] + 1) {
            operations.push(`Удалить '${X[i-1]}' с позиции ${i-1}`);
            i--;
        } else if (j > 0 && dp[i][j] === dp[i][j-1] + 1) {
            operations.push(`Вставить '${Y[j-1]}' на позицию ${i}`);
            j--;
        }
    }

    return [operations.reverse(), dp[m][n]];
}
```

## Сложность алгоритма

- **Временная сложность**: O(m * n), где m и n — длины входных строк
- **Пространственная сложность**: O(m * n) для базовой реализации, O(min(m,n)) при оптимизации

## Примеры задач

### Задача A: Найти редакционное расстояние
- Вход: две строки
- Выход: минимальное количество операций для преобразования одной строки в другую

### Задача B: Найти редакционное расстояние с ограничениями
- Вход: две строки и ограничения на типы операций
- Выход: минимальное количество операций с учетом ограничений

### Задача C: Найти k-ближайших строк
- Вход: строка, набор строк и число k
- Выход: k строк с наименьшим редакционным расстоянием

## Заключение

Редакционное расстояние — важный инструмент в области обработки строк и находит широкое применение в современных технологиях. В условиях развития ИИ и систем обработки естественного языка в 2025 году, понимание и умение эффективно реализовывать алгоритмы вычисления редакционного расстояния становится особенно ценным навыком.

## См. также
- [[Наибольшая-общая-подпоследовательность]]
- [[Основы-динамического-программирования]]
- [[Примеры-на-массивах]]
- [[Оптимизация-по-памяти]]