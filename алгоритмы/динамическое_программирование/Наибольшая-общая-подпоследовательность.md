---
aliases: ["LCS", "Longest Common Subsequence", "Наибольшая общая подпоследовательность"]
tags: [алгоритмы, динамическое_программирование, строки, последовательности]
---

# Наибольшая общая подпоследовательность

## Определение задачи

**Наибольшая общая подпоследовательность (LCS)** — это задача поиска самой длинной последовательности, которая является подпоследовательностью двух или более последовательностей. Подпоследовательность — это последовательность, которая может быть получена из другой последовательности удалением некоторых элементов без изменения порядка оставшихся элементов.

Например, для строк "ABCDGH" и "AEDFHR" наибольшей общей подпоследовательностью является "ADH" длиной 3.

## Формальное определение

Для двух последовательностей X = <x₁, x₂, ..., xₘ> и Y = <y₁, y₂, ..., yₙ>, наибольшая общая подпоследовательность — это последовательность Z = <z₁, z₂, ..., zₖ>, такая что:
- Z является подпоследовательностью X
- Z является подпоследовательностью Y
- k максимально возможное значение

## Подход к решению

### Состояние
dp[i][j] — длина наибольшей общей подпоследовательности для префиксов X[0...i-1] и Y[0...j-1].

### Переход
```
if X[i-1] == Y[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

**Псевдокод:**
```
АЛГОРИТМ Длина_LCS(X, Y)
    m = ДЛИНА(X)
    n = ДЛИНА(Y)
    // Создаем таблицу dp размером (m+1) x (n+1)
    СОЗДАТЬ dp[m+1][n+1] и инициализировать нулями

    // Заполняем таблицу
    ДЛЯ i ОТ 1 ДО m ВКЛЮЧАЯ
        ДЛЯ j ОТ 1 ДО n ВКЛЮЧАЯ
            ЕСЛИ X[i-1] == Y[j-1] ТО
                dp[i][j] = dp[i-1][j-1] + 1
            ИНАЧЕ
                dp[i][j] = МАКСИМУМ(dp[i-1][j], dp[i][j-1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ dp[m][n]
КОНЕЦ АЛГОРИТМ

АЛГОРИТМ Строка_LCS(X, Y)
    m = ДЛИНА(X)
    n = ДЛИНА(Y)
    // Создаем таблицу dp размером (m+1) x (n+1)
    СОЗДАТЬ dp[m+1][n+1] и инициализировать нулями

    // Заполняем таблицу
    ДЛЯ i ОТ 1 ДО m ВКЛЮЧАЯ
        ДЛЯ j ОТ 1 ДО n ВКЛЮЧАЯ
            ЕСЛИ X[i-1] == Y[j-1] ТО
                dp[i][j] = dp[i-1][j-1] + 1
            ИНАЧЕ
                dp[i][j] = МАКСИМУМ(dp[i-1][j], dp[i][j-1])
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
    КОНЕЦ ДЛЯ

    // Восстанавливаем саму подпоследовательность
    СОЗДАТЬ список lcs
    i = m
    j = n
    ПОКА i > 0 И j > 0
        ЕСЛИ X[i-1] == Y[j-1] ТО
            ДОБАВИТЬ X[i-1] в lcs
            i = i - 1
            j = j - 1
        ИНАЧЕ ЕСЛИ dp[i-1][j] > dp[i][j-1] ТО
            i = i - 1
        ИНАЧЕ
            j = j - 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА

    РАЗВЕРНУТЬ lcs
    ВОЗВРАТ ОБЪЕДИНИТЬ(lcs)
КОНЕЦ АЛГОРИТМ
```

**JavaScript реализация:**
```javascript
function lcsLength(X, Y) {
    const m = X.length;
    const n = Y.length;
    
    // Создаем таблицу dp размером (m+1) x (n+1)
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];
}

function lcsString(X, Y) {
    const m = X.length;
    const n = Y.length;
    
    // Создаем таблицу dp размером (m+1) x (n+1)
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

    // Заполняем таблицу
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // Восстанавливаем саму подпоследовательность
    let lcs = [];
    let i = m;
    let j = n;
    
    while (i > 0 && j > 0) {
        if (X[i - 1] === Y[j - 1]) {
            lcs.push(X[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return lcs.reverse().join('');
}

// Пример использования
const str1 = "ABCDGH";
const str2 = "AEDFHR";
console.log(`Длина LCS: ${lcsLength(str1, str2)}`); // Выводит 3
console.log(`LCS: "${lcsString(str1, str2)}"`); // Выводит "ADH"
```

## Временная и пространственная сложность

- **Временная сложность:** O(m*n), где m и n — длины входных строк
- **Пространственная сложность:** O(m*n) для хранения таблицы dp

## Применение в российской ИТ-индустрии 2025 года

Задача нахождения наибольшей общей подпоследовательности применяется в различных сферах:
- Сравнение текстов и файлов
- Биоинформатика для анализа последовательностей ДНК
- Системы контроля версий (Git)
- Плагины для проверки плагиата

В России эта задача особенно актуальна для компаний, разрабатывающих:
- Системы для работы с документами
- Сравнение юридических текстов
- Анализ текстовых данных
- Компьютерные системы для биоинформатики

## Практические советы

1. **Оптимизация памяти:** Если нужно только вычислить длину LCS, можно использовать только две строки таблицы, что снизит пространственную сложность до O(min(m,n)).
2. **Для восстановления самой подпоследовательности:** Требуется полная таблица, но можно восстановить путь с использованием рекурсивного подхода, чтобы избежать хранения всей таблицы.

## Связанные темы

- [[Редакционное-расстояние]] - задача вычисления минимального количества операций для преобразования одной строки в другую
- [[Строки-и-их-обработка]] - работа со строками в алгоритмах
- [[Динамическое-программирование]] - общий метод решения задач оптимизации

## Заключение

Алгоритм нахождения наибольшей общей подпоследовательности является важным компонентом многих систем обработки текста и биоинформатики. Понимание его работы и эффективной реализации позволяет решать задачи, требующие сравнения последовательностей, с оптимальной временной сложностью.