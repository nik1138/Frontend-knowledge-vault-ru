---
aliases: ["Примеры DP на массивах", "Массивные задачи DP", "DP с массивами"]
tags: [алгоритмы, динамическое_программирование, массивы, последовательности]
---

# Примеры на массивах

## Общее описание

Задачи динамического программирования на массивах представляют собой обширный класс задач, в которых состояние определяется индексами массива или подпоследовательностями элементов. Эти задачи особенно важны, поскольку они лежат в основе многих алгоритмов, используемых в системах обработки данных, финансовых приложениях и аналитике.

## Основные типы задач на массивах

### 1. Подпоследовательности и подмассивы

#### Максимальная сумма подмассива (Задача Кадане)

```
АЛГОРИТМ Максимальная_Сумма_Подмассива(arr)
    ЕСЛИ arr ПУСТОЙ ТО
        ВОЗВРАТ 0
    КОНЕЦ ЕСЛИ

    max_ending_here = arr[0]
    max_so_far = arr[0]

    ДЛЯ i ОТ 1 ДО ДЛИНА(arr)-1 ВКЛЮЧАЯ
        max_ending_here = МАКСИМУМ(arr[i], max_ending_here + arr[i])
        max_so_far = МАКСИМУМ(max_so_far, max_ending_here)
    КОНЕЦ ДЛЯ

    ВОЗВРАТ max_so_far
КОНЕЦ АЛГОРИТМ
```

```javascript
function maxSubarraySum(arr) {
    if (arr.length === 0) {
        return 0;
    }

    let maxEndingHere = arr[0];
    let maxSoFar = arr[0];

    for (let i = 1; i < arr.length; i++) {
        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// Пример
const arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
const result = maxSubarraySum(arr);
console.log(`Максимальная сумма подмассива: ${result}`); // Вывод: 6 (подмассив [4, -1, 2, 1])
```

#### Наибольшая возрастающая подпоследовательность (LIS)
```javascript
function longestIncreasingSubsequence(arr) {
    if (arr.length === 0) {
        return 0;
    }

    const n = arr.length;
    const dp = new Array(n).fill(1); // dp[i] - длина LIS, заканчивающейся в позиции i

    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }

    return Math.max(...dp);
}

// Пример
const arrLIS = [10, 9, 2, 5, 3, 7, 101, 18];
const resultLIS = longestIncreasingSubsequence(arrLIS);
console.log(`Длина LIS: ${resultLIS}`); // Вывод: 4 (подпоследовательность [2, 3, 7, 18])
```

### 2. Покрытие массива

#### Минимальное количество квадратов, чтобы покрыть прямоугольник
```javascript
function minSquares(n, m) {
    // dp[i][j] - минимальное количество квадратов для покрытия прямоугольника i x j
    const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));

    // Инициализация
    for (let i = 0; i <= n; i++) {
        for (let j = 0; j <= m; j++) {
            if (i === j) {
                dp[i][j] = 1; // Квадрат покрывается одним квадратом
            } else if (i === 0 || j === 0) {
                dp[i][j] = 0; // Пустой прямоугольник не требует квадратов
            }
        }
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (dp[i][j] === Infinity) {
                // Попробовать все возможные разбиения
                for (let k = 1; k < i; k++) {
                    dp[i][j] = Math.min(dp[i][j], dp[k][j] + dp[i-k][j]);
                }
                for (let k = 1; k < j; k++) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[i][j-k]);
                }
            }
        }
    }

    return dp[n][m];
}
```

### 3. Разбиение массива

#### Разбиение массива на две части с минимальной разностью сумм
```javascript
function minSubsetSumDifference(arr) {
    const totalSum = arr.reduce((a, b) => a + b, 0);
    const n = arr.length;

    // dp[i][j] - можно ли получить сумму j, используя первые i элементов
    const dp = Array(n + 1).fill(null).map(() => Array(totalSum + 1).fill(false));

    // Базовый случай
    for (let i = 0; i <= n; i++) {
        dp[i][0] = true; // Можно получить сумму 0
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 0; j <= totalSum; j++) {
            // Не включаем текущий элемент
            dp[i][j] = dp[i-1][j];

            // Включаем текущий элемент, если возможно
            if (arr[i-1] <= j) {
                dp[i][j] = dp[i][j] || dp[i-1][j - arr[i-1]];
            }
        }
    }

    // Найти минимальную разность
    let minDiff = Infinity;
    for (let j = Math.floor(totalSum / 2); j >= 0; j--) {
        if (dp[n][j]) {
            minDiff = totalSum - 2 * j;
            break;
        }
    }

    return minDiff;
}
```

## Практические применения в российских реалиях 2025 года

1. **Финансовый анализ**: Оптимизация инвестиционных портфелей, анализ временных рядов цен
2. **Аналитика данных**: Поиск трендов в больших массивах информации
3. **Системы рекомендаций**: Определение последовательностей действий пользователей
4. **Обработка сигналов**: Анализ аудио/видео данных для систем безопасности
5. **Логистика**: Оптимизация маршрутов и распределения ресурсов
6. **Медицинские системы**: Анализ временных последовательностей медицинских данных

## Сложные примеры

### Максимальная сумма без двух соседних элементов
```javascript
function maxSumNonAdjacent(arr) {
    if (arr.length === 0) {
        return 0;
    }
    if (arr.length === 1) {
        return Math.max(0, arr[0]);
    }

    const n = arr.length;
    const dp = new Array(n).fill(0);
    dp[0] = Math.max(0, arr[0]);
    dp[1] = Math.max(dp[0], arr[1]);

    for (let i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + arr[i]);
    }

    return dp[n-1];
}

// Пример
const arr = [2, 1, 4, 9];
const result = maxSumNonAdjacent(arr);
console.log(`Максимальная сумма без соседних: ${result}`); // Вывод: 11 (2 + 9)
```

### Подмассив с заданной суммой
```javascript
function countSubarraysWithSum(arr, targetSum) {
    let count = 0;
    let currentSum = 0;
    // Map для хранения количества раз, когда встречалась каждая сумма
    const sumCount = new Map();
    sumCount.set(0, 1); // Начальная сумма 0 встречается 1 раз

    for (const num of arr) {
        currentSum += num;

        // Если (currentSum - targetSum) встречалась раньше,
        // значит есть подмассив с суммой targetSum
        if (sumCount.has(currentSum - targetSum)) {
            count += sumCount.get(currentSum - targetSum);
        }

        // Обновляем количество встреч текущей суммы
        sumCount.set(currentSum, (sumCount.get(currentSum) || 0) + 1);
    }

    return count;
}
```

## Оптимизация решений

### Использование префиксных сумм
Многие задачи на массивах можно упростить с использованием префиксных сумм:
```javascript
function prefixSums(arr) {
    const n = arr.length;
    const prefix = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + arr[i];
    }
    return prefix;
}

// Пример: сумма на отрезке [l, r]
function rangeSum(prefix, l, r) {
    return prefix[r + 1] - prefix[l];
}
```

### Оптимизация по памяти
Для многих задач можно оптимизировать использование памяти, храня только необходимые значения:
```javascript
function fibonacciOptimized(n) {
    if (n <= 1) {
        return n;
    }
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b];
    }
    return b;
}
```

## Заключение

Задачи динамического программирования на массивах охватывают широкий спектр приложений и являются важной частью алгоритмической подготовки. В условиях развития цифровой экономики в России в 2025 году, умение эффективно решать такие задачи становится особенно ценным. Эти алгоритмы лежат в основе многих современных систем обработки данных, аналитики и оптимизации.

## См. также
- [[Основы-динамического-программирования]]
- [[Наибольшая-общая-подпоследовательность]]
- [[Редакционное-расстояние]]
- [[Таблица-для-хранения-результатов]]