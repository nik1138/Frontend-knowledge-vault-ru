---
aliases: [Примеры алгоритмов, Реальные задачи]
tags: [алгоритмы, примеры, практика]
---

# Практические примеры

## Общее описание

Практические примеры — это важная часть обучения написанию алгоритмов, позволяющая применить теоретические знания на практике. Особое внимание уделяется решению реальных задач, с которыми сталкиваются разработчики в своей повседневной работе. Эти примеры помогают понять, как теоретические концепции применяются в реальных системах.

## Пример 1: Алгоритм обработки финансовых транзакций

### Постановка задачи

Разработать алгоритм для обработки финансовых транзакций с учетом специфики:
- Поддержка кириллических символов в описании транзакций
- Обработка большого объема транзакций

### Анализ задачи

[[Понимание проблемы]]
- Входные данные: транзакция с полями (id, сумма, дата, отправитель, получатель, описание)
- Ограничения: сумма > 0, дата <= текущей, наличие средств
- Выходные данные: результат обработки (успешно/ошибка)

### Декомпозиция задачи

[[Декомпозиция задач]]
1. Валидация транзакции
2. Проверка баланса
3. Выполнение транзакции
4. Обновление истории
5. Логирование операции

### Реализация

```
АЛГОРИТМ ОбработатьФинансовуюТранзакцию(транзакция)
НАЧАЛО
    // Этап 1: Валидация транзакции
    результат_валидации ← ПроверитьВалидность(транзакция)
    ЕСЛИ НЕ результат_валидации.успешно ТО
        ВОЗВРАТ результат_валидации
    КОНЕЦ ЕСЛИ

    // Этап 2: Проверка баланса
    баланс ← ПолучитьБаланс(транзакция.отправитель)
    ЕСЛИ баланс < транзакция.сумма ТО
        ВОЗВРАТ НОВЫЙ Результат("Недостаточно средств", КОД_ОШИБКИ_101)
    КОНЕЦ ЕСЛИ

    // Этап 3: Блокировка средств (для предотвращения гонок)
    ЕСЛИ НЕ ЗаблокироватьСредства(транзакция.отправитель, транзакция.сумма) ТО
        ВОЗВРАТ НОВЫЙ Результат("Не удалось заблокировать средства", КОД_ОШИБКИ_102)
    КОНЕЦ ЕСЛИ

    // Этап 4: Выполнение транзакции
    ПОПЫТКА
        СписатьСредства(транзакция.отправитель, транзакция.сумма)
        ЗачислитьСредства(транзакция.получатель, транзакция.сумма)

        // Этап 5: Обновление истории
        ДобавитьВИсторию(транзакция)

        // Этап 6: Логирование
        ЗаписатьЛог("Транзакция " + транзакция.id + " успешно обработана", УРОВЕНЬ_ИНФО)

        ВОЗВРАТ НОВЫЙ Результат("Успешно", КОД_УСПЕШНО)
    ИСКЛЮЧЕНИЕ (ошибка)
        // Откат транзакции при ошибке
        ОткатитьТранзакцию(транзакция)
        ЗаписатьЛог("Ошибка при обработке транзакции " + транзакция.id + ": " + ошибка, УРОВЕНЬ_ОШИБКА)
        ВОЗВРАТ НОВЫЙ Результат("Ошибка обработки", КОД_ОШИБКИ_103)
    КОНЕЦ ПОПЫТКА
КОНЕЦ

АЛГОРИТМ ПроверитьВалидность(транзакция)
НАЧАЛО
    ЕСЛИ транзакция.сумма ≤ 0 ТО
        ВОЗВРАТ НОВЫЙ Результат("Неверная сумма", ЛОЖЬ)
    КОНЕЦ ЕСЛИ

    ЕСЛИ транзакция.дата > ТЕКУЩАЯ_ДАТА() ТО
        ВОЗВРАТ НОВЫЙ Результат("Будущая дата транзакции", ЛОЖЬ)
    КОНЕЦ ЕСЛИ

    // Проверка корректности кириллических символов в описании
    ЕСЛИ НЕ ПроверитьКорректностьТекста(транзакция.описание) ТО
        ВОЗВРАТ НОВЫЙ Результат("Некорректные символы в описании", ЛОЖЬ)
    КОНЕЦ ЕСЛИ

    ВОЗВРАТ НОВЫЙ Результат("Валидация пройдена", ИСТИНА)
КОНЕЦ
```

```javascript
/**
 * Обработка финансовой транзакции
 * @param {Object} транзакция - объект транзакции с полями: id, сумма, дата, отправитель, получатель, описание
 * @return {Object} результат обработки
 */
function обработатьФинансовуюТранзакцию(транзакция) {
    // Этап 1: Валидация транзакции
    const результат_валидации = проверитьВалидность(транзакция);
    if (!результат_валидации.успешно) {
        return результат_валидации;
    }

    // Этап 2: Проверка баланса
    const баланс = получитьБаланс(транзакция.отправитель);
    if (баланс < транзакция.сумма) {
        return { сообщение: "Недостаточно средств", код: "КОД_ОШИБКИ_101", успех: false };
    }

    // Этап 3: Блокировка средств (для предотвращения гонок)
    if (!заблокироватьСредства(транзакция.отправитель, транзакция.сумма)) {
        return { сообщение: "Не удалось заблокировать средства", код: "КОД_ОШИБКИ_102", успех: false };
    }

    // Этап 4: Выполнение транзакции
    try {
        списатьСредства(транзакция.отправитель, транзакция.сумма);
        зачислитьСредства(транзакция.получатель, транзакция.сумма);

        // Этап 5: Обновление истории
        добавитьВИсторию(транзакция);

        // Этап 6: Логирование
        записатьЛог(`Транзакция ${транзакция.id} успешно обработана`, "УРОВЕНЬ_ИНФО");

        return { сообщение: "Успешно", код: "КОД_УСПЕШНО", успех: true };
    } catch (ошибка) {
        // Откат транзакции при ошибке
        откатитьТранзакцию(транзакция);
        записатьЛог(`Ошибка при обработке транзакции ${транзакция.id}: ${ошибка}`, "УРОВЕНЬ_ОШИБКА");
        return { сообщение: "Ошибка обработки", код: "КОД_ОШИБКИ_103", успех: false };
    }
}

/**
 * Проверка валидности транзакции
 * @param {Object} транзакция - объект транзакции
 * @return {Object} результат валидации
 */
function проверитьВалидность(транзакция) {
    if (транзакция.сумма <= 0) {
        return { сообщение: "Неверная сумма", успех: false };
    }

    if (транзакция.дата > new Date()) {
        return { сообщение: "Будущая дата транзакции", успех: false };
    }

    // Проверка корректности кириллических символов в описании
    if (!проверитьКорректностьТекста(транзакция.описание)) {
        return { сообщение: "Некорректные символы в описании", успех: false };
    }

    return { сообщение: "Валидация пройдена", успех: true };
}

/**
 * Проверка корректности текста (включая кириллические символы)
 * @param {string} текст - текст для проверки
 * @return {boolean} true если текст корректный
 */
function проверитьКорректностьТекста(текст) {
    // Простая проверка: содержит ли текст только разрешенные символы
    // В реальном приложении логика будет сложнее
    const регулярноеВыражение = /^[a-zA-Zа-яА-ЯёЁ0-9\s\.,!?;:'"()-]*$/;
    return регулярноеВыражение.test(текст);
}

// Заглушки для вспомогательных функций
function получитьБаланс(отправитель) {
    // В реальном приложении запрашивается баланс из базы данных
    return 1000; // Пример
}

function заблокироватьСредства(отправитель, сумма) {
    // В реальном приложении блокирует средства
    return true; // Пример
}

function списатьСредства(отправитель, сумма) {
    // В реальном приложении списывает средства
    console.log(`Списано ${сумма} у ${отправитель}`);
}

function зачислитьСредства(получатель, сумма) {
    // В реальном приложении зачисляет средства
    console.log(`Зачислено ${сумма} на ${получатель}`);
}

function добавитьВИсторию(транзакция) {
    // В реальном приложении добавляет транзакцию в историю
    console.log(`Транзакция ${транзакция.id} добавлена в историю`);
}

function записатьЛог(сообщение, уровень) {
    // В реальном приложении записывает лог
    console.log(`[${уровень}] ${сообщение}`);
}

function откатитьТранзакцию(транзакция) {
    // В реальном приложении откатывает транзакцию
    console.log(`Транзакция ${транзакция.id} откачена`);
}

// Пример использования:
// const транзакция = {
//     id: "TX001",
//     сумма: 100,
//     дата: new Date(),
//     отправитель: "user1",
//     получатель: "user2",
//     описание: "Оплата за товары"
// };
// const результат = обработатьФинансовуюТранзакцию(транзакция);
// console.log(результат);
```

## Пример 2: Алгоритм поиска кратчайшего пути в транспортной сети

### Постановка задачи

Разработать алгоритм для поиска кратчайшего пути между двумя точками в транспортной сети города с учетом:
- Времени в пути
- Платных дорог
- Ограничений по типу транспорта
- Специфики городов (пробки, погодные условия)

### Выбор метода

[[Методы проектирования алгоритмов]]
Для решения задачи используется модифицированный алгоритм Дейкстры с учетом дополнительных факторов.

### Реализация

```
АЛГОРИТМ НайтиКратчайшийПуть(граф, начальная_точка, конечная_точка, параметры_поиска)
НАЧАЛО
    // Инициализация
    расстояния ← НОВАЯ Карта()
    предшественники ← НОВАЯ Карта()
    посещенные ← НОВЫЙ Множество()

    // Установка начальных значений
    ДЛЯ каждой вершины v В граф.вершины
        расстояния[v] ← БЕСКОНЕЧНОСТЬ
    КОНЕЦ ДЛЯ
    расстояния[начальная_точка] ← 0

    // Основной цикл алгоритма
    ПОКА посещенные.размер < граф.размер
        текущая ← НайтиМинимальнуюВершину(расстояния, посещенные)

        ЕСЛИ текущая = конечная_точка ТО
            ПРЕРВАТЬ
        КОНЕЦ ЕСЛИ

        посещенные.добавить(текущая)

        // Обновление расстояний до соседей
        ДЛЯ каждого соседа В граф.соседи(текущая)
            ЕСЛИ НЕ посещенные.содержит(сосед) ТО
                вес_ребра ← ВычислитьВесРебра(текущая, сосед, параметры_поиска)
                новое_расстояние ← расстояния[текущая] + вес_ребра

                ЕСЛИ новое_расстояние < расстояния[сосед] ТО
                    расстояния[сосед] ← новое_расстояние
                    предшественники[сосед] ← текущая
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛО
    КОНЕЦ ПОКА

    // Восстановление пути
    ВОЗВРАТ ВосстановитьПуть(предшественники, начальная_точка, конечная_точка)
КОНЕЦ

АЛГОРИТМ ВычислитьВесРебра(точка1, точка2, параметры_поиска)
НАЧАЛО
    базовое_время ← ВычислитьБазовоеВремя(точка1, точка2)

    // Учет пробки
    коэффициент_пробки ← ПолучитьКоэффициентПробки(точка1, точка2, параметры_поиска.время)
    базовое_время ← базовое_время * коэффициент_пробки

    // Учет платных дорог
    ЕСЛИ параметры_поиска.игнорировать_платные ТО
        ЕСЛИ дорога_платная(точка1, точка2) ТО
            ВОЗВРАТ БЕСКОНЕЧНОСТЬ  // Избегать платных дорог
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЕСЛИ

    // Учет погодных условий (влияние на скорость)
    погодный_коэффициент ← ПолучитьПогодныйКоэффициент(параметры_поиска.погода)
    базовое_время ← базовое_время * погодный_коэффициент

    ВОЗВРАТ базовое_время
КОНЕЦ
```

```javascript
/**
 * Алгоритм поиска кратчайшего пути (модифицированный алгоритм Дейкстры)
 * @param {Object} граф - объект графа с вершинами и ребрами
 * @param {string} начальная_точка - начальная вершина
 * @param {string} конечная_точка - конечная вершина
 * @param {Object} параметры_поиска - параметры поиска пути
 * @return {Array} массив вершин, представляющий кратчайший путь
 */
function найтиКратчайшийПуть(граф, начальная_точка, конечная_точка, параметры_поиска) {
    // Инициализация
    const расстояния = {};
    const предшественники = {};
    const посещенные = new Set();

    // Установка начальных значений
    for (const вершина of Object.keys(граф.вершины)) {
        расстояния[вершина] = Infinity;
    }
    расстояния[начальная_точка] = 0;

    // Основной цикл алгоритма
    while (посещенные.size < Object.keys(граф.вершины).length) {
        const текущая = найтиМинимальнуюВершину(расстояния, посещенные);

        if (текущая === конечная_точка) {
            break;
        }

        посещенные.add(текущая);

        // Обновление расстояний до соседей
        for (const сосед of граф.соседи(текущая)) {
            if (!посещенные.has(сосед)) {
                const вес_ребра = вычислитьВесРебра(текущая, сосед, параметры_поиска);
                const новое_расстояние = расстояния[текущая] + вес_ребра;

                if (новое_расстояние < расстояния[сосед]) {
                    расстояния[сосед] = новое_расстояние;
                    предшественники[сосед] = текущая;
                }
            }
        }
    }

    // Восстановление пути
    return восстановитьПуть(предшественники, начальная_точка, конечная_точка);
}

/**
 * Найти вершину с минимальным расстоянием, которая еще не посещена
 * @param {Object} расстояния - объект с расстояниями до вершин
 * @param {Set} посещенные - множество посещенных вершин
 * @return {string} вершина с минимальным расстоянием
 */
function найтиМинимальнуюВершину(расстояния, посещенные) {
    let минимальная_вершина = null;
    let минимальное_расстояние = Infinity;

    for (const [вершина, расстояние] of Object.entries(расстояния)) {
        if (!посещенные.has(вершина) && расстояние < минимальное_расстояние) {
            минимальная_вершина = вершина;
            минимальное_расстояние = расстояние;
        }
    }

    return минимальная_вершина;
}

/**
 * Восстановить путь из предшественников
 * @param {Object} предшественники - объект с предшественниками для каждой вершины
 * @param {string} начальная_точка - начальная вершина
 * @param {string} конечная_точка - конечная вершина
 * @return {Array} массив вершин, представляющий путь
 */
function восстановитьПуть(предшественники, начальная_точка, конечная_точка) {
    const путь = [];
    let текущая = конечная_точка;

    while (текущая !== undefined) {
        путь.unshift(текущая);
        текущая = предшественники[текущая];
    }

    return путь;
}

/**
 * Вычислить вес ребра с учетом различных факторов
 * @param {string} точка1 - первая точка
 * @param {string} точка2 - вторая точка
 * @param {Object} параметры_поиска - параметры поиска
 * @return {number} вес ребра
 */
function вычислитьВесРебра(точка1, точка2, параметры_поиска) {
    let базовое_время = вычислитьБазовоеВремя(точка1, точка2);

    // Учет пробки
    const коэффициент_пробки = получитьКоэффициентПробки(точка1, точка2, параметры_поиска.время);
    базовое_время = базовое_время * коэффициент_пробки;

    // Учет платных дорог
    if (параметры_поиска.игнорировать_платные) {
        if (дорога_платная(точка1, точка2)) {
            return Infinity; // Избегать платных дорог
        }
    }

    // Учет погодных условий (влияние на скорость)
    const погодный_коэффициент = получитьПогодныйКоэффициент(параметры_поиска.погода);
    базовое_время = базовое_время * погодный_коэффициент;

    return базовое_время;
}

// Заглушки для вспомогательных функций
function вычислитьБазовоеВремя(точка1, точка2) {
    // В реальном приложении вычисляется время между двумя точками
    return 10; // Пример
}

function получитьКоэффициентПробки(точка1, точка2, время) {
    // В реальном приложении возвращается коэффициент пробки
    return 1.0; // Пример
}

function дорога_платная(точка1, точка2) {
    // В реальном приложении проверяется, является ли дорога платной
    return false; // Пример
}

function получитьПогодныйКоэффициент(погода) {
    // В реальном приложении возвращается коэффициент в зависимости от погоды
    return 1.0; // Пример
}

// Пример использования:
// const граф = {
//     вершины: { A: {}, B: {}, C: {}, D: {} },
//     соседи: function(вершина) {
//         // Возвращает соседей для данной вершины
//         const связи = {
//             A: ['B', 'C'],
//             B: ['A', 'D'],
//             C: ['A', 'D'],
//             D: ['B', 'C']
//         };
//         return связи[вершина] || [];
//     }
// };
// const параметры = { время: new Date(), игнорировать_платные: false, погода: 'ясно' };
// const путь = найтиКратчайшийПуть(граф, 'A', 'D', параметры);
// console.log(путь); // Пример вывода: ['A', 'B', 'D'] или ['A', 'C', 'D']
```

## Пример 3: Алгоритм обработки больших данных в системе мониторинга

### Постановка задачи

Разработать алгоритм для обработки и анализа больших объемов данных в системе мониторинга инфраструктуры с учетом:
- Высокой нагрузки
- Необходимости реального времени
- Ограничений по памяти

### Подход к решению

[[Итеративное улучшение]]
Алгоритм разрабатывается в несколько итераций с постепенным улучшением производительности и функциональности.

### Реализация

```
АЛГОРИТМ ОбработатьПотокДанных(источник_данных, обработчики)
НАЧАЛО
    буфер ← НОВЫЙ Буфер(РАЗМЕР_БУФЕРА)
    статистика ← НОВАЯ Статистика()

    ПОКА истинно
        данные ← источник_данных.получить()

        // Буферизация для оптимизации
        буфер.добавить(данные)

        ЕСЛИ буфер.размер >= РАЗМЕР_БУФЕРА ТО
            // Параллельная обработка буфера
            РАЗДЕЛИТЬ_НА_ПОТОКИ(буфер.данные) КАК часть
                ДЛЯ каждого элемента В часть
                    ДЛЯ каждого обработчика В обработчики
                        результат ← обработчик.обработать(элемент)

                        // Сбор статистики
                        статистика.обновить(обработчик.название, результат)
                    КОНЕЦ ДЛО
                КОНЕЦ ДЛО
            КОНЕЦ РАЗДЕЛИТЬ

            буфер.очистить()
        КОНЕЦ ЕСЛИ

        // Периодическая проверка на необходимость сохранения статистики
        ЕСЛИ статистика.время_с_последнего_сохранения > ИНТЕРВАЛ_СОХРАНЕНИЯ ТО
            СохранитьСтатистику(статистика)
            статистика.сбросить()
        КОНЕЦ ЕСЛИ

        // Проверка ограничений по памяти
        ЕСЛИ ПолучитьИспользованиеПамяти() > ПОРОГ_ПАМЯТИ ТО
            ОсвободитьПамять()
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
КОНЕЦ

АЛГОРИТМ СохранитьСтатистику(статистика)
НАЧАЛО
    // Шифрование данных перед сохранением
    зашифрованные_данные ← Зашифровать(статистика.данные, КЛЮЧ_ШИФРОВАНИЯ)

    // Сохранение в безопасное хранилище
    безопасное_хранилище.сохранить(зашифрованные_данные)

    // Логирование операции
    ЗаписатьЛог("Статистика сохранена в " + ТЕКУЩАЯ_ДАТА(), УРОВЕНЬ_ИНФО)
КОНЕЦ
```

```javascript
/**
 * Алгоритм обработки потока данных для системы мониторинга
 * @param {Object} источник_данных - объект, из которого извлекаются данные
 * @param {Array} обработчики - массив обработчиков данных
 * @return {void}
 */
function обработатьПотокДанных(источник_данных, обработчики) {
    const РАЗМЕР_БУФЕРА = 1000;
    const ИНТЕРВАЛ_СОХРАНЕНИЯ = 60000; // 1 минута в миллисекундах
    const ПОРОГ_ПАМЯТИ = 100 * 1024 * 1024; // 100 МБ в байтах

    const буфер = [];
    const статистика = {
        данные: {},
        время_с_последнего_сохранения: Date.now()
    };

    // Функция для получения использования памяти (в реальном приложении может быть сложнее)
    function получитьИспользованиеПамяти() {
        // В реальном приложении это будет более сложный расчет
        return JSON.stringify(буфер).length + JSON.stringify(статистика).length;
    }

    // Функция для освобождения памяти
    function освободитьПамять() {
        // Очистка старых данных, которые больше не нужны
        if (буфер.length > РАЗМЕР_БУФЕРА / 2) {
            буфер.splice(0, буфер.length / 2);
        }
        console.log("Память освобождена");
    }

    // Основной цикл обработки
    setInterval(() => {
        // Получение данных из источника
        const данные = источник_данных.получить();

        // Буферизация для оптимизации
        буфер.push(данные);

        if (буфер.length >= РАЗМЕР_БУФЕРА) {
            // Обработка буфера
            for (const элемент of буфер) {
                for (const обработчик of обработчики) {
                    const результат = обработчик.обработать(элемент);

                    // Сбор статистики
                    if (!статистика.данные[обработчик.название]) {
                        статистика.данные[обработчик.название] = [];
                    }
                    статистика.данные[обработчик.название].push(результат);
                }
            }

            буфер.length = 0; // Очистка буфера
        }

        // Периодическая проверка на необходимость сохранения статистики
        if (Date.now() - статистика.время_с_последнего_сохранения > ИНТЕРВАЛ_СОХРАНЕНИЯ) {
            сохранитьСтатистику(статистика);
            статистика.данные = {};
            статистика.время_с_последнего_сохранения = Date.now();
        }

        // Проверка ограничений по памяти
        if (получитьИспользованиеПамяти() > ПОРОГ_ПАМЯТИ) {
            освободитьПамять();
        }
    }, 100); // Проверка каждые 100 мс
}

/**
 * Сохранение статистики
 * @param {Object} статистика - объект статистики
 */
function сохранитьСтатистику(статистика) {
    // Шифрование данных перед сохранением
    const зашифрованные_данные = зашифровать(статистика.данные);

    // Сохранение в безопасное хранилище
    безопасноеХранилище.сохранить(зашифрованные_данные);

    // Логирование операции
    записатьЛог(`Статистика сохранена в ${new Date()}`, "УРОВЕНЬ_ИНФО");
}

// Заглушки для вспомогательных функций
function зашифровать(данные) {
    // В реальном приложении данные зашифровываются
    return JSON.stringify(данные); // Пример
}

const безопасноеХранилище = {
    сохранить: function(данные) {
        console.log("Данные сохранены в безопасное хранилище");
    }
};

function записатьЛог(сообщение, уровень) {
    console.log(`[${уровень}] ${сообщение}`);
}

// Пример использования:
// const источник = {
//     получить: function() {
//         return { метрика: "CPU", значение: Math.random() * 100, время: new Date() };
//     }
// };
// const обработчики = [
//     { название: "CPU", обработать: function(data) { return data.значение > 80 ? "ВЫСОКИЙ" : "НОРМАЛЬНЫЙ"; } },
//     { название: "MEM", обработать: function(data) { return data.значение > 90 ? "ВЫСОКИЙ" : "НОРМАЛЬНЫЙ"; } }
// ];
// обработатьПотокДанных(источник, обработчики);
```

## Пример 4: Алгоритм машинного обучения для предсказания отказов

### Постановка задачи

Разработать алгоритм машинного обучения для предсказания потенциальных отказов оборудования в промышленной системе с учетом:
- Необходимости высокой точности
- Интерпретируемости результатов

### Подход к решению

[[Тестирование и верификация]]
Алгоритм проходит строгую проверку на различных наборах данных и проверяется на соответствие требованиям.

### Реализация

```
АЛГОРИТМ ОбучитьМодельПредсказанияОтказов(обучающие_данные, параметры)
НАЧАЛО
    // Предварительная обработка данных
    очищенные_данные ← ПредобработатьДанные(обучающие_данные)

    // Разделение данных
    обучающая_выборка, тестовая_выборка ← РазделитьДанные(очищенные_данные, 0.8)

    // Выбор алгоритма в зависимости от параметров
    ЕСЛИ параметры.алгоритм = "градиентный_бустинг" ТО
        модель ← НОВЫЙ ГрадиентныйБустинг(параметры.гиперпараметры)
    ИНАЧЕ ЕСЛИ параметры.алгоритм = "случайный_лес" ТО
        модель ← НОВЫЙ СлучайныйЛес(параметры.гиперпараметры)
    ИНАЧЕ
        ВОЗВРАТ ОШИБКА("Неизвестный алгоритм")
    КОНЕЦ ИНАЧЕ

    // Обучение модели
    модель.обучить(обучающая_выборка.признаки, обучающая_выборка.метки)

    // Оценка модели
    точность ← ОценитьТочность(модель, тестовая_выборка)

    ЕСЛИ точность < ПОРОГ_ТОЧНОСТИ ТО
        ВОЗВРАТ ОШИБКА("Модель не достигла требуемой точности: " + точность)
    КОНЕЦ ЕСЛИ

    // Интерпретация результатов
    важность_признаков ← ВычислитьВажностьПризнаков(модель)

    // Сохранение модели с метаданными
    метаданные ← НОВЫЙ Метаданные(
        точность=точность,
        важность_признаков=важность_признаков,
        дата_обучения=ТЕКУЩАЯ_ДАТА(),
        параметры=параметры
    )

    СохранитьМодель(модель, метаданные)

    ВОЗВРАТ НОВЫЙ РезультатОбучения(модель, точность, важность_признаков)
КОНЕЦ

АЛГОРИТМ ПредсказатьОтказ(модель, данные_оборудования)
НАЧАЛО
    // Предсказание вероятности отказа
    вероятность_отказа ← модель.предсказать(данные_оборудования)

    // Оценка уровня риска
    уровень_риска ← КлассифицироватьРиск(вероятность_отказа)

    // Генерация рекомендаций
    рекомендации ← СгенерироватьРекомендации(уровень_риска, данные_оборудования)

    // Логирование предсказания
    ЗаписатьЛог("Предсказание: вероятность " + вероятность_отказа +
               ", уровень риска " + уровень_риска, УРОВЕНЬ_ИНФО)

    ВОЗВРАТ НОВЫЙ РезультатПредсказания(вероятность_отказа, уровень_риска, рекомендации)
КОНЕЦ
```

```javascript
/**
 * Обучение модели предсказания отказов
 * @param {Array} обучающие_данные - массив обучающих данных
 * @param {Object} параметры - параметры обучения модели
 * @return {Object} результат обучения
 */
function обучитьМодельПредсказанияОтказов(обучающие_данные, параметры) {
    // Предварительная обработка данных
    const очищенные_данные = предобработатьДанные(обучающие_данные);

    // Разделение данных
    const [обучающая_выборка, тестовая_выборка] = разделитьДанные(очищенные_данные, 0.8);

    // Выбор алгоритма в зависимости от параметров
    let модель;
    if (параметры.алгоритм === "градиентный_бустинг") {
        модель = new ГрадиентныйБустинг(параметры.гиперпараметры);
    } else if (параметры.алгоритм === "случайный_лес") {
        модель = new СлучайныйЛес(параметры.гиперпараметры);
    } else {
        return { успех: false, сообщение: "Неизвестный алгоритм" };
    }

    // Обучение модели
    модель.обучить(обучающая_выборка.признаки, обучающая_выборка.метки);

    // Оценка модели
    const точность = оценитьТочность(модель, тестовая_выборка);

    const ПОРОГ_ТОЧНОСТИ = 0.85; // 85% порог точности
    if (точность < ПОРОГ_ТОЧНОСТИ) {
        return { успех: false, сообщение: `Модель не достигла требуемой точности: ${точность}` };
    }

    // Интерпретация результатов
    const важность_признаков = вычислитьВажностьПризнаков(модель);

    // Сохранение модели с метаданными
    const метаданные = {
        точность: точность,
        важность_признаков: важность_признаков,
        дата_обучения: new Date(),
        параметры: параметры
    };

    сохранитьМодель(модель, метаданные);

    return {
        успех: true,
        модель: модель,
        точность: точность,
        важность_признаков: важность_признаков
    };
}

/**
 * Предсказать отказ оборудования
 * @param {Object} модель - обученная модель
 * @param {Object} данные_оборудования - данные об оборудовании
 * @return {Object} результат предсказания
 */
function предсказатьОтказ(модель, данные_оборудования) {
    // Предсказание вероятности отказа
    const вероятность_отказа = модель.предсказать(данные_оборудования);

    // Оценка уровня риска
    const уровень_риска = классифицироватьРиск(вероятность_отказа);

    // Генерация рекомендаций
    const рекомендации = сгенерироватьРекомендации(уровень_риска, данные_оборудования);

    // Логирование предсказания
    записатьЛог(`Предсказание: вероятность ${вероятность_отказа}, уровень риска ${уровень_риска}`, "УРОВЕНЬ_ИНФО");

    return {
        вероятность_отказа: вероятность_отказа,
        уровень_риска: уровень_риска,
        рекомендации: рекомендации
    };
}

// Заглушки для классов и функций машинного обучения
class ГрадиентныйБустинг {
    constructor(гиперпараметры) {
        this.гиперпараметры = гиперпараметры || {};
    }

    обучить(признаки, метки) {
        console.log("Модель градиентного бустинга обучена");
    }

    предсказать(данные) {
        // Возвращаем случайную вероятность для демонстрации
        return Math.random();
    }
}

class СлучайныйЛес {
    constructor(гиперпараметры) {
        this.гиперпараметры = гиперпараметры || {};
    }

    обучить(признаки, метки) {
        console.log("Модель случайного леса обучена");
    }

    предсказать(данные) {
        // Возвращаем случайную вероятность для демонстрации
        return Math.random();
    }
}

function предобработатьДанные(данные) {
    // В реальном приложении данные очищаются и нормализуются
    return данные;
}

function разделитьДанные(данные, доля) {
    const индекс = Math.floor(данные.length * доля);
    return [данные.slice(0, индекс), данные.slice(индекс)];
}

function оценитьТочность(модель, тестовая_выборка) {
    // В реальном приложении вычисляется точность модели
    return 0.9; // Пример
}

function вычислитьВажностьПризнаков(модель) {
    // В реальном приложении вычисляется важность признаков
    return { температура: 0.3, давление: 0.2, вибрация: 0.5 };
}

function сохранитьМодель(модель, метаданные) {
    console.log("Модель сохранена с метаданными:", метаданные);
}

function классифицироватьРиск(вероятность) {
    if (вероятность > 0.7) return "ВЫСОКИЙ";
    if (вероятность > 0.4) return "СРЕДНИЙ";
    return "НИЗКИЙ";
}

function сгенерироватьРекомендации(уровень_риска, данные) {
    switch (уровень_риска) {
        case "ВЫСОКИЙ":
            return "Срочно провести техническое обслуживание";
        case "СРЕДНИЙ":
            return "Запланировать проверку в ближайшее время";
        default:
            return "Оборудование в нормальном состоянии";
    }
}

// Пример использования:
// const обучающие_данные = [
//     { признаки: [25, 1.2, 0.5], метка: 0 },
//     { признаки: [80, 2.1, 0.8], метка: 1 },
//     { признаки: [30, 1.1, 0.3], метка: 0 }
// ];
// const параметры = { алгоритм: "случайный_лес", гиперпараметры: { деревья: 100 } };
// const результат = обучитьМодельПредсказанияОтказов(обучающие_данные, параметры);
// if (результат.успех) {
//     const предсказание = предсказатьОтказ(результат.модель, { температура: 75, давление: 1.8, вибрация: 0.6 });
//     console.log(предсказание);
// }
```

## Практические рекомендации

### 1. Постепенное усложнение

- Начинайте с простых примеров
- Постепенно добавляйте сложность
- Используйте [[Итеративное улучшение]] для развития алгоритмов

### 2. Тестирование в реальных условиях

- Используйте реальные наборы данных
- Тестируйте в условиях, близких к продакшену

### 3. Документирование решений

- Документируйте принятые решения
- Объясняйте выбор конкретных подходов

## Связанные концепции

[[Псевдокод и план]] - примеры начинаются с планирования
[[Отладка алгоритмов]] - важна при разработке сложных алгоритмов
[[Рефакторинг алгоритмов]] - улучшение алгоритмов на основе практики

## Ключевые выводы

- Практические примеры помогают применить теоретические знания
- Реальные задачи требуют комплексного подхода с использованием нескольких методов
- Постоянное тестирование и улучшение критически важны для успешных решений