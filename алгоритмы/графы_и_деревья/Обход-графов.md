---
aliases: [Обход графов, Поиск по графам, Алгоритмы обхода]
tags: [алгоритмы, графы, обход, программирование]
---

# Обход графов

## Общее описание

Обход графа - это систематическое посещение всех вершин графа с целью выполнения определённых операций. Это одна из фундаментальных задач в теории графов, лежащая в основе многих алгоритмов. В этой статье рассматриваются основные методы обхода графов и их применения.

## Основные методы обхода

### 1. Поиск в глубину (DFS - Depth-First Search)

DFS - это алгоритм обхода графа, который исследует вершины, насколько возможно, вдоль каждой ветви, прежде чем отступить. Работает по принципу "идти как можно глубже, а затем возвращаться".

```
АЛГОРИТМ DFS_итеративный(граф, стартовая_вершина)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины V, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ПОМЕСТИТЬ стартовую_вершину в stack

    ПОКА stack не пуст ТОГДА
        current = ВЗЯТЬ элемент из stack
        ЕСЛИ visited[current] = false ТОГДА
            visited[current] = true
            ВЫВЕСТИ current
            ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
                ЕСЛИ visited[neighbor] = false ТОГДА
                    ПОМЕСТИТЬ neighbor в stack
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЦИКЛА
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS_рекурсивный(граф, вершина, visited)
    visited[вершина] = true
    ВЫВЕСТИ вершина
    ДЛЯ КАЖДОГО neighbor в adjList[вершина] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ DFS_рекурсивный(граф, neighbor, visited)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u); // для неориентированного графа
    }

    DFS(start) {
        const visited = Array(this.vertices).fill(false);
        const stack = [];
        stack.push(start);

        while (stack.length > 0) {
            const current = stack.pop();

            if (!visited[current]) {
                visited[current] = true;
                console.log(current + " ");

                // Добавляем соседей в стек
                for (const neighbor of this.adjList[current]) {
                    if (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
    }

    // Рекурсивная версия
    DFSRecursive(vertex, visited) {
        visited[vertex] = true;
        console.log(vertex + " ");

        for (const neighbor of this.adjList[vertex]) {
            if (!visited[neighbor]) {
                this.DFSRecursive(neighbor, visited);
            }
        }
    }

    DFSRecursiveStart(start) {
        const visited = Array(this.vertices).fill(false);
        this.DFSRecursive(start, visited);
    }
}
```

```cpp
#include <vector>
#include <stack>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // для неориентированного графа
    }

    void DFS(int start) {
        vector<bool> visited(vertices, false);
        stack<int> stack;

        stack.push(start);

        while (!stack.empty()) {
            int current = stack.top();
            stack.pop();

            if (!visited[current]) {
                visited[current] = true;
                cout << current << " ";

                // Добавляем соседей в стек
                for (int neighbor : adjList[current]) {
                    if (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
    }

    // Рекурсивная версия
    void DFSRecursive(int vertex, vector<bool>& visited) {
        visited[vertex] = true;
        cout << vertex << " ";

        for (int neighbor : adjList[vertex]) {
            if (!visited[neighbor]) {
                DFSRecursive(neighbor, visited);
            }
        }
    }

    void DFSRecursive(int start) {
        vector<bool> visited(vertices, false);
        DFSRecursive(start, visited);
    }
};
```

#### Преимущества DFS:
- Использует меньше памяти в среднем случае
- Подходит для поиска пути между двумя вершинами
- Полезен для топологической сортировки
- Используется в алгоритмах поиска мостов и точек артиткуляции

#### Недостатки DFS:
- Может застрять в длинной ветви
- Не гарантирует нахождения кратчайшего пути

### 2. Поиск в ширину (BFS - Breadth-First Search)

BFS - это алгоритм обхода графа, который исследует соседние вершины на текущем уровне, прежде чем переходить к вершинам следующего уровня. Работает по принципу "слой за слоем".

```
АЛГОРИТМ BFS(граф, стартовая_вершина)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины V, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    УСТАНОВИТЬ visited[стартовая_вершина] = true
    ПОМЕСТИТЬ стартовую_вершину в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ВЫВЕСТИ current
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ visited[neighbor] = false ТОГДА
                УСТАНОВИТЬ visited[neighbor] = true
                ПОМЕСТИТЬ neighbor в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ BFS_кратчайшийПуть(граф, старт, конец)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины V, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ parent массивом длины V, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    УСТАНОВИТЬ visited[старт] = true
    ПОМЕСТИТЬ старт в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ЕСЛИ current = конец ТОГДА
            ВЫЙТИ из цикла
        КОНЕЦ ЕСЛИ
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ visited[neighbor] = false ТОГДА
                УСТАНОВИТЬ visited[neighbor] = true
                УСТАНОВИТЬ parent[neighbor] = current
                ПОМЕСТИТЬ neighbor в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    // Восстановление пути
    ИНИЦИАЛИЗИРОВАТЬ path как пустой список
    current = конец
    ПОКА current != -1 ЦИКЛ
        ДОБАВИТЬ current в path
        current = parent[current]
    КОНЕЦ ЦИКЛА
    РАЗВЕРНУТЬ path
    ВОЗВРАТ path
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u); // для неориентированного графа
    }

    BFS(start) {
        const visited = Array(this.vertices).fill(false);
        const queue = [];
        visited[start] = true;
        queue.push(start);

        while (queue.length > 0) {
            const current = queue.shift();
            console.log(current + " ");

            for (const neighbor of this.adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            }
        }
    }

    // BFS для нахождения кратчайшего пути
    shortestPath(start, end) {
        const visited = Array(this.vertices).fill(false);
        const parent = Array(this.vertices).fill(-1);
        const queue = [];
        visited[start] = true;
        queue.push(start);

        while (queue.length > 0) {
            const current = queue.shift();

            if (current === end) break;

            for (const neighbor of this.adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    queue.push(neighbor);
                }
            }
        }

        // Восстановление пути
        const path = [];
        let current = end;
        while (current !== -1) {
            path.push(current);
            current = parent[current];
        }
        return path.reverse();
    }
}
```

```cpp
#include <vector>
#include <queue>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // для неориентированного графа
    }

    void BFS(int start) {
        vector<bool> visited(vertices, false);
        queue<int> queue;

        visited[start] = true;
        queue.push(start);

        while (!queue.empty()) {
            int current = queue.front();
            queue.pop();

            cout << current << " ";

            for (int neighbor : adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            }
        }
    }

    // BFS для нахождения кратчайшего пути
    vector<int> shortestPath(int start, int end) {
        vector<bool> visited(vertices, false);
        vector<int> parent(vertices, -1);
        queue<int> queue;

        visited[start] = true;
        queue.push(start);

        while (!queue.empty()) {
            int current = queue.front();
            queue.pop();

            if (current == end) break;

            for (int neighbor : adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    queue.push(neighbor);
                }
            }
        }

        // Восстановление пути
        vector<int> path;
        int current = end;
        while (current != -1) {
            path.push_back(current);
            current = parent[current];
        }
        reverse(path.begin(), path.end());

        return path;
    }
};
```

#### Преимущества BFS:
- Гарантирует нахождение кратчайшего пути в невзвешенном графе
- Обходит вершины в порядке увеличения расстояния от начальной вершины

#### Недостатки BFS:
- Требует больше памяти для хранения очереди
- Может быть медленнее в некоторых случаях

## Применения обхода графов

### 1. Поиск компонент связности

```
АЛГОРИТМ countComponents(граф)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    components = 0

    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ВЫЗВАТЬ граф.DFS(i) // или BFS(i)
            УВЕЛИЧИТЬ components на 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    ВОЗВРАТ components
КОНЕЦ АЛГОРИТМА
```

```javascript
function countComponents(g) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);
    let components = 0;

    for (let i = 0; i < vertices; i++) {
        if (!visited[i]) {
            g.DFS(i); // или BFS(i)
            components++;
        }
    }

    return components;
}
```

```cpp
int countComponents(Graph& g) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);
    int components = 0;

    for (int i = 0; i < vertices; i++) {
        if (!visited[i]) {
            g.DFS(i); // или BFS(i)
            components++;
        }
    }

    return components;
}
```

### 2. Проверка двудольности

```
АЛГОРИТМ isBipartite(граф, старт)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ color массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь

    color[старт] = 0
    ПОМЕСТИТЬ старт в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ color[neighbor] = -1 ТОГДА
                color[neighbor] = 1 - color[current]
                ПОМЕСТИТЬ neighbor в queue
            ИНАЧЕ ЕСЛИ color[neighbor] = color[current] ТОГДА
                ВОЗВРАТ false // Не двудольный
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ true
КОНЕЦ АЛГОРИТМА
```

```javascript
function isBipartite(g, start) {
    const vertices = g.vertices;
    const color = Array(vertices).fill(-1);
    const queue = [];

    color[start] = 0;
    queue.push(start);

    while (queue.length > 0) {
        const current = queue.shift();

        for (const neighbor of g.adjList[current]) {
            if (color[neighbor] === -1) {
                color[neighbor] = 1 - color[current];
                queue.push(neighbor);
            } else if (color[neighbor] === color[current]) {
                return false; // Не двудольный
            }
        }
    }

    return true;
}
```

```cpp
bool isBipartite(Graph& g, int start) {
    int vertices = g.getVertices();
    vector<int> color(vertices, -1);
    queue<int> queue;

    color[start] = 0;
    queue.push(start);

    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();

        for (int neighbor : g.getAdjList(current)) {
            if (color[neighbor] == -1) {
                color[neighbor] = 1 - color[current];
                queue.push(neighbor);
            } else if (color[neighbor] == color[current]) {
                return false; // Не двудольный
            }
        }
    }

    return true;
}
```

### 3. Топологическая сортировка (см. [[Топологическая-сортировка]])

## Практические рекомендации

При реализации обхода графов следует учитывать:

1. **Ограничения по памяти**: рекурсивная реализация DFS может привести к переполнению стека при больших графах. В таких случаях предпочтительнее использовать итеративную версию.

2. **Параллелизм**: современные приложения всё чаще используют многопоточность. BFS может быть адаптирован для параллельного выполнения на определённых этапах.

3. **Работа с большими данными**: при работе с графами, не помещающимися в оперативную память, используются специальные подходы, такие как обход по частям или использование внешней памяти.

4. **Производительность**: выбор между DFS и BFS зависит от задачи. Для поиска кратчайшего пути в невзвешенном графе предпочтительнее BFS, для проверки связности или поиска цикла - DFS.

## Заключение

Обход графов - фундаментальный алгоритм, используемый во множестве приложений. Правильный выбор метода обхода (DFS или BFS) и его реализации критически важен для эффективности решения задачи.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Поиск-в-глубину-и-ширину]]
- [[Циклы-в-графах]]
- [[Сильно-связные-компоненты]]

#алгоритмы #графы #обход #программирование