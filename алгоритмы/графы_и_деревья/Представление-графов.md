---
aliases: [Графы, Структуры графов, Репрезентация графов]
tags: [алгоритмы, графы, структуры-данных, программирование]
---

# Представление графов

## Общее описание

Граф - это структура данных, состоящая из **вершин (узлов)** и **рёбер**, соединяющих пары вершин. Графы используются для моделирования отношений между объектами в различных приложениях: от социальных сетей до транспортных систем.

В этой статье рассматриваются основные способы представления графов в памяти компьютера, их преимущества и недостатки, а также практические рекомендации по выбору подходящего представления.

## Типы графов

- **Ориентированный граф (орграф)**: рёбра имеют направление
- **Неориентированный граф**: рёбра не имеют направления
- **Взвешенный граф**: каждому ребру приписан вес
- **Мультиграф**: может содержать несколько рёбер между одной парой вершин
- **Граф с петлями**: может содержать рёбра, соединяющие вершину с собой

## Способы представления графов

### 1. Матрица смежности

Матрица смежности - это двумерный массив размером `V x V`, где `V` - количество вершин графа.

```
АЛГОРИТМ СоздатьМатрицуСмежности(количество_вершин)
    ИНИЦИАЛИЗИРОВАТЬ adjMatrix размером V x V нулями
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ДобавитьРебро(граф, вершина_u, вершина_v, вес = 1)
    adjMatrix[вершина_u][вершина_v] = вес
    ЕСЛИ граф неориентированный ТОГДА
        adjMatrix[вершина_v][вершина_u] = вес
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ПроверитьСмежность(граф, вершина_u, вершина_v)
    ВОЗВРАТ adjMatrix[вершина_u][вершина_v] != 0
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        // Создаем матрицу смежности размером V x V, заполненную нулями
        this.adjMatrix = Array(v).fill().map(() => Array(v).fill(0));
    }

    addEdge(u, v, weight = 1) {
        this.adjMatrix[u][v] = weight;
        // Для неориентированного графа:
        // this.adjMatrix[v][u] = weight;
    }

    isAdjacent(u, v) {
        return this.adjMatrix[u][v] !== 0;
    }
}
```

```cpp
// Пример реализации матрицы смежности
#include <vector>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjMatrix;

public:
    Graph(int v) : vertices(v), adjMatrix(v, vector<int>(v, 0)) {}

    void addEdge(int u, int v, int weight = 1) {
        adjMatrix[u][v] = weight;
        // Для неориентированного графа:
        // adjMatrix[v][u] = weight;
    }

    bool isAdjacent(int u, int v) {
        return adjMatrix[u][v] != 0;
    }
};
```

**Преимущества:**
- Быстрая проверка смежности вершин: O(1)
- Простая реализация
- Удобна для плотных графов

**Недостатки:**
- Потребление памяти: O(V²)
- Неэффективна для разреженных графов

### 2. Список смежности

Список смежности - это массив списков, где каждый элемент массива представляет собой список соседей соответствующей вершины.

```
АЛГОРИТМ СоздатьСписокСмежности(количество_вершин)
    ИНИЦИАЛИЗИРОВАТЬ adjList как массив из V пустых списков
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ДобавитьРебро(граф, вершина_u, вершина_v)
    ДОБАВИТЬ вершина_v в список adjList[вершина_u]
    ЕСЛИ граф неориентированный ТОГДА
        ДОБАВИТЬ вершина_u в список adjList[вершина_v]
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ПолучитьСоседей(граф, вершина_u)
    ВОЗВРАТ список adjList[вершина_u]
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        // Создаем массив списков смежности
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        // Для неориентированного графа:
        // this.adjList[v].push(u);
    }

    getNeighbors(u) {
        return this.adjList[u];
    }
}
```

```cpp
#include <vector>
#include <list>
using namespace std;

class Graph {
private:
    int vertices;
    vector<list<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        // Для неориентированного графа:
        // adjList[v].push_back(u);
    }

    list<int> getNeighbors(int u) {
        return adjList[u];
    }
};
```

**Преимущества:**
- Экономия памяти: O(V + E), где E - количество рёбер
- Эффективен для разреженных графов
- Простое добавление рёбер

**Недостатки:**
- Проверка смежности требует O(degree) времени
- Сложнее реализация некоторых операций

### 3. Взвешенный список смежности

Для взвешенных графов используется структура, хранящая пары (сосед, вес).

```
АЛГОРИТМ СоздатьВзвешенныйГраф(количество_вершин)
    ИНИЦИАЛИЗИРОВАТЬ adjList как массив из V пустых списков
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ДобавитьВзвешенное_Ребро(граф, вершина_u, вершина_v, вес)
    ДОБАВИТЬ пару (вершина_v, вес) в список adjList[вершина_u]
    ЕСЛИ граф неориентированный ТОГДА
        ДОБАВИТЬ пару (вершина_u, вес) в список adjList[вершина_v]
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
class WeightedGraph {
    constructor(v) {
        this.vertices = v;
        // Создаем массив списков смежности для хранения пар (сосед, вес)
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v, weight) {
        this.adjList[u].push([v, weight]);
        // Для неориентированного графа:
        // this.adjList[v].push([u, weight]);
    }
}
```

```cpp
#include <vector>
#include <utility>
using namespace std;

class WeightedGraph {
private:
    int vertices;
    vector<vector<pair<int, int>>> adjList; // {сосед, вес}

public:
    WeightedGraph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v, int weight) {
        adjList[u].push_back({v, weight});
        // Для неориентированного графа:
        // adjList[v].push_back({u, weight});
    }
};
```

### 4. Список рёбер

Простая структура, представляющая граф как список рёбер.

```
АЛГОРИТМ СоздатьСписокРёбер(количество_вершин)
    ИНИЦИАЛИЗИРОВАТЬ edges как пустой список
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ДобавитьРебро(граф, вершина_u, вершина_v, вес = 1)
    ДОБАВИТЬ тройку (вершина_u, вершина_v, вес) в список edges
КОНЕЦ АЛГОРИТМА
```

```javascript
class EdgeListGraph {
    constructor(v) {
        this.vertices = v;
        // Создаем пустой список рёбер
        this.edges = [];
    }

    addEdge(u, v, weight = 1) {
        this.edges.push([u, v, weight]);
    }
}
```

```cpp
#include <vector>
#include <tuple>
using namespace std;

class EdgeListGraph {
private:
    int vertices;
    vector<tuple<int, int, int>> edges; // {вершина1, вершина2, вес}

public:
    void addEdge(int u, int v, int weight = 1) {
        edges.push_back({u, v, weight});
    }
};
```

## Выбор подходящего представления

| Тип графа | Рекомендуемое представление | Причина |
|-----------|-----------------------------|---------|
| Плотный граф (E ≈ V²) | Матрица смежности | Эффективность использования памяти |
| Разреженный граф (E << V²) | Список смежности | Экономия памяти |
| Частая проверка смежности | Матрица смежности | O(1) время проверки |
| Частый обход соседей | Список смежности | Прямой доступ к соседям |
| Частое добавление/удаление рёбер | Список смежности | Простая операция |

## Практические рекомендации

При выборе структуры представления графа следует учитывать:

1. **Ограничения по памяти**: в промышленной разработке часто работают с ограничениями по памяти, особенно при разработке для embedded систем или мобильных приложений.

2. **Производительность**: при работе с большими графами (например, социальные сети с миллионами пользователей) выбор структуры данных критически важен для производительности.

3. **Изменяемость графа**: если граф часто изменяется (добавляются/удаляются рёбра), список смежности предпочтительнее.

4. **Кэш-локальность**: современные процессоры лучше работают с последовательными структурами данных, что делает матрицу смежности эффективной при правильной организации данных.

## Заключение

Выбор подходящего способа представления графа критически важен для эффективности алгоритмов, работающих с графами. Матрица смежности предпочтительна для плотных графов и частых проверок смежности, а список смежности - для разреженных графов и экономии памяти.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Обход-графов]]
- [[Алгоритмы-на-деревьях]]
- [[Поиск-в-глубину-и-ширину]]

#алгоритмы #графы #структуры-данных #программирование