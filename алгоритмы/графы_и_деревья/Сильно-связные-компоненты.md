---
aliases: [Сильно связные компоненты, SCC, Компоненты сильной связности]
tags: [алгоритмы, графы, компоненты-связности, программирование]
---

# Сильно связные компоненты

## Общее описание

Сильно связная компонента (SCC - Strongly Connected Component) ориентированного графа - это максимальное подмножество вершин, в котором каждая вершина достижима из любой другой вершины этого подмножества. Задача выделения сильно связных компонент важна для анализа структуры ориентированных графов и находит применение в различных областях: от анализа веб-ссылок до оптимизации компиляторов.

## Основные понятия

- **Сильная связность**: ориентированный граф сильно связан, если из каждой вершины можно достичь любой другой вершины
- **Сильно связная компонента**: максимальный сильно связный подграф
- **Конденсация графа**: граф, в котором каждой SCC соответствует одна вершина, а рёбра сохраняют отношения достижимости между компонентами
- **Мост**: ребро, при удалении которого количество компонент связности увеличивается

## Алгоритмы нахождения сильно связных компонент

### 1. Алгоритм Косараджу

Алгоритм Косараджу использует два прохода DFS: сначала на исходном графе для определения порядка обхода, затем на транспонированном графе.

```
АЛГОРИТМ fillOrder(вершина v, visited, stack)
    visited[v] = true
    ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ fillOrder(neighbor, visited, stack)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ПОМЕСТИТЬ v в stack
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ dfsTranspose(вершина v, visited, component)
    visited[v] = true
    ДОБАВИТЬ v в component
    ДЛЯ КАЖДОГО neighbor в transpose[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ dfsTranspose(neighbor, visited, component)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ kosarajuSCC(граф)
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    // Первый проход DFS для определения порядка
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ВЫЗВАТЬ fillOrder(i, visited, stack)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    // Сброс посещённых вершин
    ЗАПОЛНИТЬ visited значениями false
    ИНИЦИАЛИЗИРОВАТЬ sccs как пустой список списков
    // Второй проход DFS на транспонированном графе
    ПОКА stack не пуст ТОГДА
        v = ВЗЯТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
        УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
        ЕСЛИ visited[v] = false ТОГДА
            ИНИЦИАЛИЗИРОВАТЬ component как пустой список
            ВЫЗВАТЬ dfsTranspose(v, visited, component)
            ДОБАВИТЬ component в sccs
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
    ВОЗВРАТ sccs
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
        this.transpose = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.transpose[v].push(u);
    }

    fillOrder(v, visited, stack) {
        visited[v] = true;

        for (const neighbor of this.adjList[v]) {
            if (!visited[neighbor]) {
                this.fillOrder(neighbor, visited, stack);
            }
        }

        stack.push(v);
    }

    dfsTranspose(v, visited, component) {
        visited[v] = true;
        component.push(v);

        for (const neighbor of this.transpose[v]) {
            if (!visited[neighbor]) {
                this.dfsTranspose(neighbor, visited, component);
            }
        }
    }

    kosarajuSCC() {
        const stack = [];
        const visited = Array(this.vertices).fill(false);

        // Первый проход DFS для определения порядка
        for (let i = 0; i < this.vertices; i++) {
            if (!visited[i]) {
                this.fillOrder(i, visited, stack);
            }
        }

        // Сброс посещённых вершин
        visited.fill(false);

        const sccs = [];

        // Второй проход DFS на транспонированном графе
        while (stack.length > 0) {
            const v = stack.pop();

            if (!visited[v]) {
                const component = [];
                this.dfsTranspose(v, visited, component);
                sccs.push(component);
            }
        }

        return sccs;
    }
}
```

```cpp
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;
    vector<vector<int>> transpose;

public:
    Graph(int v) : vertices(v), adjList(v), transpose(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        transpose[v].push_back(u);
    }

    void fillOrder(int v, vector<bool>& visited, stack<int>& stack) {
        visited[v] = true;

        for (int neighbor : adjList[v]) {
            if (!visited[neighbor]) {
                fillOrder(neighbor, visited, stack);
            }
        }

        stack.push(v);
    }

    void dfsTranspose(int v, vector<bool>& visited, vector<int>& component) {
        visited[v] = true;
        component.push_back(v);

        for (int neighbor : transpose[v]) {
            if (!visited[neighbor]) {
                dfsTranspose(neighbor, visited, component);
            }
        }
    }

    vector<vector<int>> kosarajuSCC() {
        stack<int> stack;
        vector<bool> visited(vertices, false);

        // Первый проход DFS для определения порядка
        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                fillOrder(i, visited, stack);
            }
        }

        // Сброс посещённых вершин
        fill(visited.begin(), visited.end(), false);

        vector<vector<int>> sccs;

        // Второй проход DFS на транспонированном графе
        while (!stack.empty()) {
            int v = stack.top();
            stack.pop();

            if (!visited[v]) {
                vector<int> component;
                dfsTranspose(v, visited, component);
                sccs.push_back(component);
            }
        }

        return sccs;
    }
};
```

#### Сложность:
- Время: O(V + E)
- Память: O(V + E)

#### Преимущества:
- Простая реализация
- Интуитивно понятен
- Использует стандартный DFS

#### Недостатки:
- Требует два прохода по графу
- Нужно хранить транспонированный граф

### 2. Алгоритм Тарьяна

Алгоритм Тарьяна находит SCC за один проход DFS, используя время обнаружения и "low-link" значения.

```
АЛГОРИТМ tarjanSCCUtil(вершина u, time, disc, low, stackMember, stack, sccs)
    disc[u] = low[u] = time
    time = time + 1
    ПОМЕСТИТЬ u в stack
    stackMember[u] = true
    ДЛЯ КАЖДОГО v в adjList[u] ЦИКЛ
        ЕСЛИ disc[v] = -1 ТОГДА
            ВЫЗВАТЬ tarjanSCCUtil(v, time, disc, low, stackMember, stack, sccs)
            low[u] = МИНИМУМ(low[u], low[v])
        ИНАЧЕ ЕСЛИ stackMember[v] = true ТОГДА
            low[u] = МИНИМУМ(low[u], disc[v])
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    // Если u - корень SCC
    ЕСЛИ low[u] = disc[u] ТОГДА
        ИНИЦИАЛИЗИРОВАТЬ component как пустой список
        ПОВТОРЯТЬ
            w = ВЗЯТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
            УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
            stackMember[w] = false
            ДОБАВИТЬ w в component
        ПОКА w != u
        ДОБАВИТЬ component в sccs
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ tarjanSCC(граф)
    ИНИЦИАЛИЗИРОВАТЬ disc массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ low массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ stackMember массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ИНИЦИАЛИЗИРОВАТЬ sccs как пустой список списков
    time = 0
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ disc[i] = -1 ТОГДА
            ВЫЗВАТЬ tarjanSCCUtil(i, time, disc, low, stackMember, stack, sccs)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ sccs
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    tarjanSCC() {
        const disc = Array(this.vertices).fill(-1);
        const low = Array(this.vertices).fill(-1);
        const stackMember = Array(this.vertices).fill(false);
        const stack = [];
        const sccs = [];
        let time = 0;

        for (let i = 0; i < this.vertices; i++) {
            if (disc[i] === -1) {
                this.tarjanSCCUtil(i, time, disc, low, stackMember, stack, sccs);
            }
        }

        return sccs;
    }

    tarjanSCCUtil(u, time, disc, low, stackMember, stack, sccs) {
        disc[u] = low[u] = time++;
        stack.push(u);
        stackMember[u] = true;

        for (const v of this.adjList[u]) {
            if (disc[v] === -1) {
                this.tarjanSCCUtil(v, time, disc, low, stackMember, stack, sccs);
                low[u] = Math.min(low[u], low[v]);
            } else if (stackMember[v]) {
                low[u] = Math.min(low[u], disc[v]);
            }
        }

        // Если u - корень SCC
        if (low[u] === disc[u]) {
            const component = [];
            let w;
            do {
                w = stack.pop();
                stackMember[w] = false;
                component.push(w);
            } while (w !== u);

            sccs.push(component);
        }
    }
}
```

```cpp
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    vector<vector<int>> tarjanSCC() {
        vector<int> disc(vertices, -1);
        vector<int> low(vertices, -1);
        vector<bool> stackMember(vertices, false);
        stack<int> stack;
        vector<vector<int>> sccs;
        int time = 0;

        for (int i = 0; i < vertices; i++) {
            if (disc[i] == -1) {
                tarjanSCCUtil(i, time, disc, low, stackMember, stack, sccs);
            }
        }

        return sccs;
    }

private:
    void tarjanSCCUtil(int u, int& time, vector<int>& disc,
                       vector<int>& low, vector<bool>& stackMember,
                       stack<int>& stack, vector<vector<int>>& sccs) {
        disc[u] = low[u] = time++;
        stack.push(u);
        stackMember[u] = true;

        for (int v : adjList[u]) {
            if (disc[v] == -1) {
                tarjanSCCUtil(v, time, disc, low, stackMember, stack, sccs);
                low[u] = min(low[u], low[v]);
            } else if (stackMember[v]) {
                low[u] = min(low[u], disc[v]);
            }
        }

        // Если u - корень SCC
        if (low[u] == disc[u]) {
            vector<int> component;
            int w;
            do {
                w = stack.top();
                stack.pop();
                stackMember[w] = false;
                component.push_back(w);
            } while (w != u);

            sccs.push_back(component);
        }
    }
};
```

#### Сложность:
- Время: O(V + E)
- Память: O(V)

#### Преимущества:
- Находит SCC за один проход
- Не требует транспонированного графа
- Эффективен по памяти

#### Недостатки:
- Более сложная реализация
- Требует понимания концепции "low-link" значений

### 3. Алгоритм Габова (Path-based)

Алгоритм Габова также находит SCC за один проход, но использует другую стратегию, основанную на путях.

```
АЛГОРИТМ gabowSCCUtil(вершина v, indexCounter, index, stackLowlink, stack, path, sccs)
    index[v] = indexCounter
    indexCounter = indexCounter + 1
    ПОМЕСТИТЬ v в stack
    ПОМЕСТИТЬ v в path
    stackLowlink[v] = index[v]
    ДЛЯ КАЖДОГО w в adjList[v] ЦИКЛ
        ЕСЛИ index[w] = -1 ТОГДА
            ВЫЗВАТЬ gabowSCCUtil(w, indexCounter, index, stackLowlink, stack, path, sccs)
        ИНАЧЕ ЕСЛИ w находится в index И index[w] < stackLowlink[v] ТОГДА
            stackLowlink[v] = index[w]
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ЕСЛИ index[v] = stackLowlink[v] ТОГДА
        ИНИЦИАЛИЗИРОВАТЬ component как пустой список
        ПОВТОРЯТЬ
            w = ВЗЯТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
            УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
            УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
            ДОБАВИТЬ w в component
        ПОКА w != v
        ДОБАВИТЬ component в sccs
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ gabowSCC(граф)
    ИНИЦИАЛИЗИРОВАТЬ index массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ stackLowlink массивом длины vertices, заполненным 0
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ИНИЦИАЛИЗИРОВАТЬ path как пустой стек
    ИНИЦИАЛИЗИРОВАТЬ sccs как пустой список списков
    indexCounter = 0
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ index[i] = -1 ТОГДА
            ВЫЗВАТЬ gabowSCCUtil(i, indexCounter, index, stackLowlink, stack, path, sccs)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ sccs
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    gabowSCC() {
        const index = Array(this.vertices).fill(-1);
        const stackLowlink = Array(this.vertices).fill(0);
        const stack = [];
        const path = [];
        const sccs = [];
        let indexCounter = 0;

        for (let i = 0; i < this.vertices; i++) {
            if (index[i] === -1) {
                this.gabowSCCUtil(i, indexCounter, index, stackLowlink,
                             stack, path, sccs);
            }
        }

        return sccs;
    }

    gabowSCCUtil(v, indexCounter, index, stackLowlink, stack, path, sccs) {
        index[v] = indexCounter++;
        stack.push(v);
        path.push(v);
        stackLowlink[v] = index[v];

        for (const w of this.adjList[v]) {
            if (index[w] === -1) {
                this.gabowSCCUtil(w, indexCounter, index, stackLowlink,
                             stack, path, sccs);
            } else if (index[w] !== -1 && index[w] < stackLowlink[v]) {
                stackLowlink[v] = index[w];
            }
        }

        if (index[v] === stackLowlink[v]) {
            const component = [];
            let w;
            do {
                w = path.pop();
                stack.pop();
                component.push(w);
            } while (w !== v);

            sccs.push(component);
        }
    }
}
```

```cpp
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    vector<vector<int>> gabowSCC() {
        vector<int> index(vertices, -1);
        vector<int> stackLowlink(vertices, 0);
        stack<int> stack;
        stack<int> path;
        vector<vector<int>> sccs;
        int indexCounter = 0;

        for (int i = 0; i < vertices; i++) {
            if (index[i] == -1) {
                gabowSCCUtil(i, indexCounter, index, stackLowlink,
                             stack, path, sccs);
            }
        }

        return sccs;
    }

private:
    void gabowSCCUtil(int v, int& indexCounter, vector<int>& index,
                      vector<int>& stackLowlink, stack<int>& stack,
                      stack<int>& path, vector<vector<int>>& sccs) {
        index[v] = indexCounter++;
        stack.push(v);
        path.push(v);
        stackLowlink[v] = index[v];

        for (int w : adjList[v]) {
            if (index[w] == -1) {
                gabowSCCUtil(w, indexCounter, index, stackLowlink,
                             stack, path, sccs);
            } else if (find(index.begin(), index.end(), w) != index.end() &&
                       index[w] < stackLowlink[v]) {
                stackLowlink[v] = index[w];
            }
        }

        if (index[v] == stackLowlink[v]) {
            vector<int> component;
            int w;
            do {
                w = path.top();
                path.pop();
                stack.pop();
                component.push_back(w);
            } while (w != v);

            sccs.push_back(component);
        }
    }
};
```

## Применения сильно связных компонент

### 1. Анализ веб-графа

SCC могут использоваться для анализа структуры интернета, выделения плотно связанных групп веб-сайтов.

### 2. Оптимизация компиляторов

В задачах анализа потока данных и оптимизации циклов.

### 3. Анализ социальных сетей

Для выделения плотно связанных сообществ пользователей.

### 4. Базы данных

В задачах нормализации и анализа зависимостей между таблицами.

## Практические рекомендации

При работе с сильно связными компонентами следует учитывать:

1. **Масштаб**: для очень больших графов (например, веб-графов) могут потребоваться распределённые алгоритмы или специализированные подходы.

2. **Память**: рекурсивные реализации могут привести к переполнению стека, особенно в системах с ограниченными ресурсами.

3. **Производительность**: алгоритм Тарьяна обычно предпочтительнее из-за более эффективного использования памяти и одного прохода по графу.

4. **Параллелизм**: современные системы всё чаще используют многопоточность, что открывает возможности для параллельных алгоритмов нахождения SCC.

## Заключение

Алгоритмы нахождения сильно связных компонент являются важным инструментом для анализа структуры ориентированных графов. Понимание этих алгоритмов и их свойств критически важно для эффективного решения задач, связанных с анализом сложных сетевых структур.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Циклы-в-графах]]
- [[Обход-графов]]
- [[Представление-графов]]

#алгоритмы #графы #компоненты-связности #программирование