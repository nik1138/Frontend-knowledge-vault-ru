---
aliases: [Остовные деревья, Минимальное остовное дерево, MST, Алгоритмы остовных деревьев]
tags: [алгоритмы, графы, остовные-деревья, программирование]
---

# Остовные деревья

## Общее описание

Остовное дерево (spanning tree) графа - это подграф, который является деревом и включает все вершины исходного графа. Минимальное остовное дерево (MST - Minimum Spanning Tree) - это остовное дерево с минимальной суммой весов рёбер. Остовные деревья находят широкое применение в сетевом дизайне, кластеризации и других областях.

## Основные понятия

- **Остовное дерево**: связный ациклический подграф, содержащий все вершины исходного графа
- **Минимальное остовное дерево (MST)**: остовное дерево с минимальной суммой весов рёбер
- **Свойство разреза**: для любого разреза в графе, если ребро минимального веса через разрез уникально, то оно принадлежит MST

## Алгоритмы построения MST

### 1. Алгоритм Крускала

Алгоритм Крускала строит MST, добавляя рёбра в порядке возрастания веса, при этом избегая циклов.

```
АЛГОРИТМ Крускала(граф)
    ИНИЦИАЛИЗИРОВАТЬ UnionFind структуру для vertices вершин
    ОТСОРТИРОВАТЬ рёбра по весу в порядке возрастания
    ИНИЦИАЛИЗИРОВАТЬ mst как пустой список

    ДЛЯ КАЖДОГО ребра (вес, u, v) в отсортированных рёбрах ЦИКЛ
        ЕСЛИ find(u) != find(v) ТОГДА
            ДОБАВИТЬ ребро в mst
            unite(u, v)
            ЕСЛИ размер mst = vertices - 1 ТОГДА
                ВЫЙТИ из цикла
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    ВОЗВРАТ mst
КОНЕЦ АЛГОРИТМА
```

```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array(n);
        this.rank = Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
        }
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // Path compression
        }
        return this.parent[x];
    }

    unite(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);

        if (rootX !== rootY) {
            // Union by rank
            if (this.rank[rootX] < this.rank[rootY]) {
                this.parent[rootX] = rootY;
            } else if (this.rank[rootX] > this.rank[rootY]) {
                this.parent[rootY] = rootX;
            } else {
                this.parent[rootY] = rootX;
                this.rank[rootX]++;
            }
        }
    }

    connected(x, y) {
        return this.find(x) === this.find(y);
    }
}

class Graph {
    constructor(v) {
        this.vertices = v;
        this.edges = []; // [вес, вершина1, вершина2]
    }

    addEdge(u, v, weight) {
        this.edges.push([weight, u, v]);
    }

    kruskalMST() {
        const mst = [];
        const uf = new UnionFind(this.vertices);

        // Сортировка рёбер по весу
        this.edges.sort((a, b) => a[0] - b[0]);

        for (const [weight, u, v] of this.edges) {
            if (!uf.connected(u, v)) {
                uf.unite(u, v);
                mst.push([weight, u, v]);

                if (mst.length === this.vertices - 1) break; // MST построен
            }
        }

        return mst;
    }
}
```

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class UnionFind {
private:
    vector<int> parent, rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            // Union by rank
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};

class Graph {
private:
    int vertices;
    vector<tuple<int, int, int>> edges; // {вес, вершина1, вершина2}

public:
    Graph(int v) : vertices(v) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back({weight, u, v});
    }

    vector<tuple<int, int, int>> kruskalMST() {
        vector<tuple<int, int, int>> mst;
        UnionFind uf(vertices);

        // Сортировка рёбер по весу
        sort(edges.begin(), edges.end());

        for (auto& edge : edges) {
            int weight, u, v;
            tie(weight, u, v) = edge;

            if (!uf.connected(u, v)) {
                uf.unite(u, v);
                mst.push_back(edge);

                if (mst.size() == vertices - 1) break; // MST построен
            }
        }

        return mst;
    }
};
```

#### Сложность:
- Время: O(E log E) из-за сортировки
- Память: O(V)

#### Преимущества:
- Простая реализация
- Хорошо работает для разреженных графов
- Использует эффективную структуру данных Union-Find

#### Недостатки:
- Требует сортировки всех рёбер
- Может быть медленнее для плотных графов

### 2. Алгоритм Прима

Алгоритм Прима строит MST, начиная с одной вершины и постепенно добавляя ближайшие вершины.

```
АЛГОРИТМ Прима(граф)
    ИНИЦИАЛИЗИРОВАТЬ inMST массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ minEdge массивом длины vertices, заполненным бесконечностью
    ИНИЦИАЛИЗИРОВАТЬ parent массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ pq как приоритетную очередь пар (вес, вершина)

    // Начинаем с вершины 0
    minEdge[0] = 0
    ПОМЕСТИТЬ (0, 0) в pq
    ИНИЦИАЛИЗИРОВАТЬ mst как пустой список

    ПОКА pq не пуста ТОГДА
        current = ВЗЯТЬ вершину с минимальным весом из pq
        ЕСЛИ inMST[current] = true ТОГДА
            ПРОДОЛЖИТЬ
        КОНЕЦ ЕСЛИ

        inMST[current] = true
        ЕСЛИ parent[current] != -1 ТОГДА
            ДОБАВИТЬ (parent[current], current, minEdge[current]) в mst
        КОНЕЦ ЕСЛИ

        ДЛЯ КАЖДОГО (neighbor, weight) в adjList[current] ЦИКЛ
            ЕСЛИ inMST[neighbor] = false И weight < minEdge[neighbor] ТОГДА
                minEdge[neighbor] = weight
                parent[neighbor] = current
                ПОМЕСТИТЬ (weight, neighbor) в pq
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ mst
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []); // [сосед, вес]
    }

    addEdge(u, v, weight) {
        this.adjList[u].push([v, weight]);
        this.adjList[v].push([u, weight]); // для неориентированного графа
    }

    primMST() {
        const inMST = Array(this.vertices).fill(false);
        const minEdge = Array(this.vertices).fill(Number.POSITIVE_INFINITY);
        const parent = Array(this.vertices).fill(-1);
        const pq = [{ weight: 0, vertex: 0 }]; // [вес, вершина]

        // Начинаем с вершины 0
        minEdge[0] = 0;

        const mst = [];

        while (pq.length > 0) {
            // Извлекаем вершину с минимальным весом
            pq.sort((a, b) => a.weight - b.weight);
            const { weight: currentWeight, vertex: current } = pq.shift();

            if (inMST[current]) continue;

            inMST[current] = true;

            if (parent[current] !== -1) {
                mst.push([parent[current], current, minEdge[current]]);
            }

            for (const [neighbor, weight] of this.adjList[current]) {
                if (!inMST[neighbor] && weight < minEdge[neighbor]) {
                    minEdge[neighbor] = weight;
                    parent[neighbor] = current;
                    pq.push({ weight: weight, vertex: neighbor });
                }
            }
        }

        return mst;
    }
}
```

```cpp
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<pair<int, int>>> adjList; // {сосед, вес}

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v, int weight) {
        adjList[u].push_back({v, weight});
        adjList[v].push_back({u, weight}); // для неориентированного графа
    }

    vector<tuple<int, int, int>> primMST() {
        vector<bool> inMST(vertices, false);
        vector<int> minEdge(vertices, INT_MAX);
        vector<int> parent(vertices, -1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

        // Начинаем с вершины 0
        minEdge[0] = 0;
        pq.push({0, 0});

        vector<tuple<int, int, int>> mst;

        while (!pq.empty()) {
            int current = pq.top().second;
            pq.pop();

            if (inMST[current]) continue;

            inMST[current] = true;

            if (parent[current] != -1) {
                mst.push_back({parent[current], current, minEdge[current]});
            }

            for (auto& edge : adjList[current]) {
                int neighbor = edge.first;
                int weight = edge.second;

                if (!inMST[neighbor] && weight < minEdge[neighbor]) {
                    minEdge[neighbor] = weight;
                    parent[neighbor] = current;
                    pq.push({weight, neighbor});
                }
            }
        }

        return mst;
    }
};
```

#### Сложность:
- Время: O((V + E) log V) с использованием бинарной кучи
- Память: O(V)

#### Преимущества:
- Хорошо работает для плотных графов
- Может быть эффективнее Крускала для плотных графов

#### Недостатки:
- Сложнее реализация
- Требует больше памяти для хранения дополнительных структур

### 3. Алгоритм Борувки

Алгоритм Борувки был первым алгоритмом для построения MST, предложенным в 1926 году.

```
АЛГОРИТМ Борувки(граф)
    ИНИЦИАЛИЗИРОВАТЬ UnionFind структуру для vertices вершин
    ИНИЦИАЛИЗИРОВАТЬ mst как пустой список
    ИНИЦИАЛИЗИРОВАТЬ cheapest массивом длины vertices, заполненным -1
    numTrees = vertices

    ПОКА numTrees > 1 ТОГДА
        ЗАПОЛНИТЬ cheapest значениями -1
        ДЛЯ i ОТ 0 ДО длина(edges)-1 ЦИКЛ
            ВЗЯТЬ (вес, u, v) из edges[i]
            setU = find(u)
            setV = find(v)
            ЕСЛИ setU != setV ТОГДА
                ЕСЛИ cheapest[setU] = -1 ИЛИ вес(edges[cheapest[setU]]) > вес ТОГДА
                    cheapest[setU] = i
                КОНЕЦ ЕСЛИ
                ЕСЛИ cheapest[setV] = -1 ИЛИ вес(edges[cheapest[setV]]) > вес ТОГДА
                    cheapest[setV] = i
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
        ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
            ЕСЛИ cheapest[i] != -1 ТОГДА
                ВЗЯТЬ (вес, u, v) из edges[cheapest[i]]
                setU = find(u)
                setV = find(v)
                ЕСЛИ setU != setV ТОГДА
                    unite(u, v)
                    ДОБАВИТЬ edges[cheapest[i]] в mst
                    УМЕНЬШИТЬ numTrees на 1
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ mst
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.edges = []; // [вес, вершина1, вершина2]
    }

    addEdge(u, v, weight) {
        this.edges.push([weight, u, v]);
    }

    boruvkaMST() {
        const uf = new UnionFind(this.vertices);
        const mst = [];

        let cheapest = Array(this.vertices).fill(-1);

        let numTrees = this.vertices;

        while (numTrees > 1) {
            cheapest.fill(-1);

            for (let i = 0; i < this.edges.length; i++) {
                const [weight, u, v] = this.edges[i];

                const setU = uf.find(u);
                const setV = uf.find(v);

                if (setU !== setV) {
                    if (cheapest[setU] === -1 ||
                        this.edges[cheapest[setU]][0] > weight) {
                        cheapest[setU] = i;
                    }

                    if (cheapest[setV] === -1 ||
                        this.edges[cheapest[setV]][0] > weight) {
                        cheapest[setV] = i;
                    }
                }
            }

            for (let i = 0; i < this.vertices; i++) {
                if (cheapest[i] !== -1) {
                    const [weight, u, v] = this.edges[cheapest[i]];

                    const setU = uf.find(u);
                    const setV = uf.find(v);

                    if (setU !== setV) {
                        uf.unite(u, v);
                        mst.push(this.edges[cheapest[i]]);
                        numTrees--;
                    }
                }
            }
        }

        return mst;
    }
}
```

```cpp
#include <vector>
#include <climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<tuple<int, int, int>> edges; // {вес, вершина1, вершина2}

public:
    Graph(int v) : vertices(v) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back({weight, u, v});
    }

    vector<tuple<int, int, int>> boruvkaMST() {
        UnionFind uf(vertices);
        vector<tuple<int, int, int>> mst;

        vector<int> cheapest(vertices, -1);

        int numTrees = vertices;

        while (numTrees > 1) {
            fill(cheapest.begin(), cheapest.end(), -1);

            for (int i = 0; i < edges.size(); i++) {
                int weight, u, v;
                tie(weight, u, v) = edges[i];

                int setU = uf.find(u);
                int setV = uf.find(v);

                if (setU != setV) {
                    if (cheapest[setU] == -1 ||
                        get<0>(edges[cheapest[setU]]) > weight) {
                        cheapest[setU] = i;
                    }

                    if (cheapest[setV] == -1 ||
                        get<0>(edges[cheapest[setV]]) > weight) {
                        cheapest[setV] = i;
                    }
                }
            }

            for (int i = 0; i < vertices; i++) {
                if (cheapest[i] != -1) {
                    int weight, u, v;
                    tie(weight, u, v) = edges[cheapest[i]];

                    int setU = uf.find(u);
                    int setV = uf.find(v);

                    if (setU != setV) {
                        uf.unite(u, v);
                        mst.push_back(edges[cheapest[i]]);
                        numTrees--;
                    }
                }
            }
        }

        return mst;
    }
};
```

#### Сложность:
- Время: O(E log V)
- Память: O(V)

## Свойства MST

1. **Уникальность**: если все рёбра имеют различные веса, то MST уникально
2. **Цикловое свойство**: для любого цикла в графе, самое тяжёлое ребро в цикле не принадлежит MST
3. **Разрезное свойство**: для любого разреза в графе, самое лёгкое ребро через разрез принадлежит MST
4. **Количество рёбер**: MST содержит ровно V-1 рёбер, где V - количество вершин

## Практические применения

### 1. Сетевой дизайн

MST используется для построения минимальных по стоимости сетей связи, электросетей, дорог и т.д.

### 2. Кластеризация

MST может быть использован для идентификации кластеров в данных, особенно в алгоритмах кластеризации на основе графов.

### 3. Приближённые алгоритмы

MST используется как основа для приближённых алгоритмов решения задачи коммивояжёра и других NP-трудных задач.

### 4. Изображения и компьютерное зрение

В задачах сегментации изображений и анализа структуры изображений.

## Практические рекомендации

При работе с остовными деревьями следует учитывать:

1. **Масштаб**: для очень больших графов могут потребоваться распределённые алгоритмы построения MST.

2. **Динамические графы**: в реальных системах граф может часто изменяться, что требует поддержки динамических MST.

3. **Производительность**: выбор между алгоритмами Крускала и Прима зависит от плотности графа и требований к производительности.

4. **Параллелизм**: современные системы всё чаще используют многопоточность, что открывает возможности для параллельных алгоритмов построения MST.

## Заключение

Алгоритмы построения минимальных остовных деревьев являются важной частью многих приложений. Понимание этих алгоритмов и их свойств критически важно для эффективного решения задач, связанных с оптимизацией соединений в сетях.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Кратчайшие-пути]]
- [[Представление-графов]]
- [[Алгоритмы-на-деревьях]]

#алгоритмы #графы #остовные-деревья #программирование