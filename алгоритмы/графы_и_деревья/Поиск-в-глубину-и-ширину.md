---
aliases: [DFS, BFS, Поиск в глубину, Поиск в ширину, Алгоритмы поиска]
tags: [алгоритмы, графы, DFS, BFS, программирование]
---

# Поиск в глубину и ширину

## Общее описание

Поиск в глубину (DFS - Depth-First Search) и поиск в ширину (BFS - Breadth-First Search) - это два фундаментальных алгоритма обхода графов, лежащие в основе множества других алгоритмов. Эти алгоритмы используются для решения широкого спектра задач: от простого обхода графа до поиска кратчайших путей и компонент связности.

## Поиск в глубину (DFS)

DFS - это алгоритм обхода графа, который исследует вершины, насколько возможно, вдоль каждой ветви, прежде чем отступить. Работает по принципу "идти как можно глубже, а затем возвращаться".

### Рекурсивная реализация DFS

```
АЛГОРИТМ DFS_рекурсивный(граф, вершина, visited)
    visited[вершина] = true
    ВЫВЕСТИ вершина
    ДЛЯ КАЖДОГО neighbor в adjList[вершина] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ DFS_рекурсивный(граф, neighbor, visited)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ DFS(граф, старт)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ВЫЗВАТЬ DFS_рекурсивный(граф, старт, visited)
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u); // для неориентированного графа
    }

    DFSRecursive(vertex, visited) {
        visited[vertex] = true;
        console.log(vertex + " ");

        for (const neighbor of this.adjList[vertex]) {
            if (!visited[neighbor]) {
                this.DFSRecursive(neighbor, visited);
            }
        }
    }

    DFS(start) {
        const visited = Array(this.vertices).fill(false);
        this.DFSRecursive(start, visited);
    }
}
```

```cpp
#include <vector>
#include <iostream>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // для неориентированного графа
    }

    void DFSRecursive(int vertex, vector<bool>& visited) {
        visited[vertex] = true;
        cout << vertex << " ";

        for (int neighbor : adjList[vertex]) {
            if (!visited[neighbor]) {
                DFSRecursive(neighbor, visited);
            }
        }
    }

    void DFS(int start) {
        vector<bool> visited(vertices, false);
        DFSRecursive(start, visited);
    }
};
```

### Итеративная реализация DFS

```
АЛГОРИТМ DFS_итеративный(граф, старт)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ПОМЕСТИТЬ старт в stack

    ПОКА stack не пуст ТОГДА
        current = ВЗЯТЬ элемент из stack
        ЕСЛИ visited[current] = false ТОГДА
            visited[current] = true
            ВЫВЕСТИ current
            ДЛЯ i ОТ длина(adjList[current])-1 ДО 0 С ШАГОМ -1 ЦИКЛ
                ЕСЛИ visited[adjList[current][i]] = false ТОГДА
                    ПОМЕСТИТЬ adjList[current][i] в stack
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЦИКЛА
        КОНЕЦ ЕСЛИ
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА
```

```javascript
function DFSIterative(g, start) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);
    const stack = [];

    stack.push(start);

    while (stack.length > 0) {
        const current = stack.pop();

        if (!visited[current]) {
            visited[current] = true;
            console.log(current + " ");

            // Добавляем соседей в стек (в обратном порядке для сохранения порядка)
            const neighbors = g.adjList[current];
            for (let i = neighbors.length - 1; i >= 0; i--) {
                if (!visited[neighbors[i]]) {
                    stack.push(neighbors[i]);
                }
            }
        }
    }
}
```

```cpp
#include <vector>
#include <stack>
using namespace std;

void DFSIterative(Graph& g, int start) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);
    stack<int> stack;

    stack.push(start);

    while (!stack.empty()) {
        int current = stack.top();
        stack.pop();

        if (!visited[current]) {
            visited[current] = true;
            cout << current << " ";

            // Добавляем соседей в стек (в обратном порядке для сохранения порядка)
            vector<int> neighbors = g.getAdjList(current);
            for (int i = neighbors.size() - 1; i >= 0; i--) {
                if (!visited[neighbors[i]]) {
                    stack.push(neighbors[i]);
                }
            }
        }
    }
}
```

### Применения DFS

#### 1. Проверка связности графа

```
АЛГОРИТМ isConnected(граф, старт)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ВЫЗВАТЬ граф.DFS(старт, visited)
    ДЛЯ КАЖДОГО v в visited ЦИКЛ
        ЕСЛИ v = false ТОГДА
            ВОЗВРАТ false
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ true
КОНЕЦ АЛГОРИТМА
```

```javascript
function isConnected(g, start) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);

    g.DFS(start, visited);

    for (const v of visited) {
        if (!v) return false;
    }

    return true;
}
```

```cpp
bool isConnected(Graph& g, int start) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);

    g.DFS(start, visited);

    for (bool v : visited) {
        if (!v) return false;
    }

    return true;
}
```

#### 2. Поиск цикла в графе

```
АЛГОРИТМ hasCycleDFS(граф, вершина, visited, recStack)
    ЕСЛИ visited[вершина] = false ТОГДА
        visited[вершина] = true
        recStack[вершина] = true
        ДЛЯ КАЖДОГО neighbor в adjList[вершина] ЦИКЛ
            ЕСЛИ visited[neighbor] = false И hasCycleDFS(граф, neighbor, visited, recStack) = true ТОГДА
                ВОЗВРАТ true
            ИНАЧЕ ЕСЛИ recStack[neighbor] = true ТОГДА
                ВОЗВРАТ true
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЕСЛИ
    recStack[вершина] = false
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ hasCycle(граф)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ recStack массивом длины vertices, заполненным false
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ hasCycleDFS(граф, i, visited, recStack) = true ТОГДА
            ВОЗВРАТ true
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА
```

```javascript
function hasCycleDFS(g, vertex, visited, recStack) {
    if (!visited[vertex]) {
        visited[vertex] = true;
        recStack[vertex] = true;

        for (const neighbor of g.adjList[vertex]) {
            if (!visited[neighbor] && hasCycleDFS(g, neighbor, visited, recStack)) {
                return true;
            } else if (recStack[neighbor]) {
                return true;
            }
        }
    }

    recStack[vertex] = false;
    return false;
}

function hasCycle(g) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);
    const recStack = Array(vertices).fill(false);

    for (let i = 0; i < vertices; i++) {
        if (hasCycleDFS(g, i, visited, recStack)) {
            return true;
        }
    }

    return false;
}
```

```cpp
bool hasCycleDFS(Graph& g, int vertex, vector<bool>& visited,
                 vector<bool>& recStack) {
    if (!visited[vertex]) {
        visited[vertex] = true;
        recStack[vertex] = true;

        for (int neighbor : g.getAdjList(vertex)) {
            if (!visited[neighbor] && hasCycleDFS(g, neighbor, visited, recStack)) {
                return true;
            } else if (recStack[neighbor]) {
                return true;
            }
        }
    }

    recStack[vertex] = false;
    return false;
}

bool hasCycle(Graph& g) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);
    vector<bool> recStack(vertices, false);

    for (int i = 0; i < vertices; i++) {
        if (hasCycleDFS(g, i, visited, recStack)) {
            return true;
        }
    }

    return false;
}
```

#### 3. Топологическая сортировка (см. [[Топологическая-сортировка]])

## Поиск в ширину (BFS)

BFS - это алгоритм обхода графа, который исследует соседние вершины на текущем уровне, прежде чем переходить к вершинам следующего уровня. Работает по принципу "слой за слоем".

### Реализация BFS

```
АЛГОРИТМ BFS(граф, старт)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    visited[старт] = true
    ПОМЕСТИТЬ старт в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ВЫВЕСТИ current
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ visited[neighbor] = false ТОГДА
                visited[neighbor] = true
                ПОМЕСТИТЬ neighbor в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u); // для неориентированного графа
    }

    BFS(start) {
        const visited = Array(this.vertices).fill(false);
        const queue = [];
        visited[start] = true;
        queue.push(start);

        while (queue.length > 0) {
            const current = queue.shift();
            console.log(current + " ");

            for (const neighbor of this.adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            }
        }
    }
}
```

```cpp
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // для неориентированного графа
    }

    void BFS(int start) {
        vector<bool> visited(vertices, false);
        queue<int> queue;

        visited[start] = true;
        queue.push(start);

        while (!queue.empty()) {
            int current = queue.front();
            queue.pop();

            cout << current << " ";

            for (int neighbor : adjList[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            }
        }
    }
};
```

### BFS для нахождения кратчайшего пути

```
АЛГОРИТМ shortestPathBFS(граф, старт, конец)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ parent массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    visited[старт] = true
    ПОМЕСТИТЬ старт в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ЕСЛИ current = конец ТОГДА
            ВЫЙТИ из цикла
        КОНЕЦ ЕСЛИ
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ visited[neighbor] = false ТОГДА
                visited[neighbor] = true
                parent[neighbor] = current
                ПОМЕСТИТЬ neighbor в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    // Восстановление пути
    ИНИЦИАЛИЗИРОВАТЬ path как пустой список
    current = конец
    ПОКА current != -1 ЦИКЛ
        ДОБАВИТЬ current в path
        current = parent[current]
    КОНЕЦ ЦИКЛА
    РАЗВЕРНУТЬ path
    ВОЗВРАТ path
КОНЕЦ АЛГОРИТМА
```

```javascript
function shortestPathBFS(g, start, end) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);
    const parent = Array(vertices).fill(-1);
    const queue = [];
    visited[start] = true;
    queue.push(start);

    while (queue.length > 0) {
        const current = queue.shift();

        if (current === end) break;

        for (const neighbor of g.adjList[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parent[neighbor] = current;
                queue.push(neighbor);
            }
        }
    }

    // Восстановление пути
    const path = [];
    let current = end;
    while (current !== -1) {
        path.push(current);
        current = parent[current];
    }
    return path.reverse();
}
```

```cpp
vector<int> shortestPathBFS(Graph& g, int start, int end) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);
    vector<int> parent(vertices, -1);
    queue<int> queue;

    visited[start] = true;
    queue.push(start);

    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();

        if (current == end) break;

        for (int neighbor : g.getAdjList(current)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parent[neighbor] = current;
                queue.push(neighbor);
            }
        }
    }

    // Восстановление пути
    vector<int> path;
    int current = end;
    while (current != -1) {
        path.push_back(current);
        current = parent[current];
    }
    reverse(path.begin(), path.end());

    return path;
}
```

### Применения BFS

#### 1. Нахождение компонент связности

```
АЛГОРИТМ countComponentsBFS(граф)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    components = 0
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ВЫЗВАТЬ граф.BFS(i)
            УВЕЛИЧИТЬ components на 1
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ components
КОНЕЦ АЛГОРИТМА
```

```javascript
function countComponentsBFS(g) {
    const vertices = g.vertices;
    const visited = Array(vertices).fill(false);
    let components = 0;

    for (let i = 0; i < vertices; i++) {
        if (!visited[i]) {
            g.BFS(i);
            components++;
        }
    }

    return components;
}
```

```cpp
int countComponentsBFS(Graph& g) {
    int vertices = g.getVertices();
    vector<bool> visited(vertices, false);
    int components = 0;

    for (int i = 0; i < vertices; i++) {
        if (!visited[i]) {
            g.BFS(i);
            components++;
        }
    }

    return components;
}
```

#### 2. Проверка двудольности графа

```
АЛГОРИТМ isBipartiteBFS(граф, старт)
    vertices = количество вершин графа
    ИНИЦИАЛИЗИРОВАТЬ color массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    color[старт] = 0
    ПОМЕСТИТЬ старт в queue

    ПОКА queue не пуста ТОГДА
        current = ВЗЯТЬ элемент из начала queue
        ДЛЯ КАЖДОГО neighbor в adjList[current] ЦИКЛ
            ЕСЛИ color[neighbor] = -1 ТОГДА
                color[neighbor] = 1 - color[current]
                ПОМЕСТИТЬ neighbor в queue
            ИНАЧЕ ЕСЛИ color[neighbor] = color[current] ТОГДА
                ВОЗВРАТ false // Не двудольный
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ true
КОНЕЦ АЛГОРИТМА
```

```javascript
function isBipartiteBFS(g, start) {
    const vertices = g.vertices;
    const color = Array(vertices).fill(-1);
    const queue = [];

    color[start] = 0;
    queue.push(start);

    while (queue.length > 0) {
        const current = queue.shift();

        for (const neighbor of g.adjList[current]) {
            if (color[neighbor] === -1) {
                color[neighbor] = 1 - color[current];
                queue.push(neighbor);
            } else if (color[neighbor] === color[current]) {
                return false; // Не двудольный
            }
        }
    }

    return true;
}
```

```cpp
bool isBipartiteBFS(Graph& g, int start) {
    int vertices = g.getVertices();
    vector<int> color(vertices, -1);
    queue<int> queue;

    color[start] = 0;
    queue.push(start);

    while (!queue.empty()) {
        int current = queue.front();
        queue.pop();

        for (int neighbor : g.getAdjList(current)) {
            if (color[neighbor] == -1) {
                color[neighbor] = 1 - color[current];
                queue.push(neighbor);
            } else if (color[neighbor] == color[current]) {
                return false; // Не двудольный
            }
        }
    }

    return true;
}
```

## Сравнение DFS и BFS

| Критерий | DFS | BFS |
|----------|-----|-----|
| Структура данных | Стек (рекурсия или явный) | Очередь |
| Память | O(h), где h - высота | O(w), где w - ширина |
| Нахождение кратчайшего пути | Нет | Да (в невзвешенном графе) |
| Поиск цикла | Да | Да |
| Топологическая сортировка | Да | Нет |
| Применение | Проверка связности, топология | Кратчайший путь, уровни |

## Практические рекомендации

При использовании DFS и BFS следует учитывать:

1. **Ограничения по памяти**: рекурсивная реализация DFS может привести к переполнению стека при работе с глубокими деревьями. В таких случаях предпочтительнее использовать итеративную версию.

2. **Производительность**: выбор между DFS и BFS зависит от задачи. BFS требует больше памяти, но гарантирует нахождение кратчайшего пути в невзвешенном графе.

3. **Параллелизм**: BFS может быть адаптирован для параллельного выполнения на отдельных уровнях, что особенно актуально для современных многопроцессорных систем.

4. **Работа с большими графами**: при работе с графами, не помещающимися в оперативную память, могут потребоваться специальные подходы, такие как обход по частям или использование внешней памяти.

## Заключение

DFS и BFS - это два фундаментальных алгоритма, каждый из которых находит применение в различных задачах. Правильный выбор между ними зависит от конкретной задачи и ограничений, с которыми приходится сталкиваться в промышленной разработке.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Обход-графов]]
- [[Кратчайшие-пути]]
- [[Циклы-в-графах]]

#алгоритмы #графы #DFS #BFS #программирование