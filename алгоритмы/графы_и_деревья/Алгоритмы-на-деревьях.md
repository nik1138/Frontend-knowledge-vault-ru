---
aliases: [Деревья, Алгоритмы деревьев, Структуры деревьев]
tags: [алгоритмы, деревья, структуры-данных, программирование]
---

# Алгоритмы на деревьях

## Общее описание

Дерево - это специальный вид графа, не содержащий циклов. Это одна из важнейших структур данных в программировании, используемая в самых разных приложениях: от файловых систем до структур данных в базах данных. В этой статье рассматриваются основные алгоритмы, работающие с деревьями, и их применения.

## Основные понятия

- **Корень**: вершина дерева, не имеющая родителя
- **Лист**: вершина, не имеющая потомков
- **Родитель/Потомок**: отношение между вершинами, где одна вершина находится на уровень выше другой
- **Уровень вершины**: расстояние от корня до вершины
- **Высота дерева**: максимальное расстояние от корня до листа

## Представление деревьев

### 1. Дерево с фиксированным количеством потомков

```
СТРУКТУРА TreeNode
    val: значение узла
    children: список потомков
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ СоздатьУзел(значение)
    СОЗДАТЬ новый узел
    УСТАНОВИТЬ val = значение
    ИНИЦИАЛИЗИРОВАТЬ children как пустой список
    ВОЗВРАТ новый узел
КОНЕЦ АЛГОРИТМА
```

```javascript
class TreeNode {
    constructor(value) {
        this.val = value;
        this.children = [];
    }
}
```

```cpp
#include <vector>
using namespace std;

class TreeNode {
public:
    int val;
    vector<TreeNode*> children;

    TreeNode(int value) : val(value) {}
};
```

### 2. Дерево с произвольным числом потомков

```
СТРУКТУРА TreeNode
    val: значение узла
    parent: родительский узел
    children: список потомков
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ СоздатьУзелСРодителем(значение)
    СОЗДАТЬ новый узел
    УСТАНОВИТЬ val = значение
    УСТАНОВИТЬ parent = null
    ИНИЦИАЛИЗИРОВАТЬ children как пустой список
    ВОЗВРАТ новый узел
КОНЕЦ АЛГОРИТМА
```

```javascript
class TreeNode {
    constructor(value) {
        this.val = value;
        this.parent = null;
        this.children = [];
    }
}
```

```cpp
class TreeNode {
public:
    int val;
    TreeNode* parent;
    vector<TreeNode*> children;

    TreeNode(int value) : val(value), parent(nullptr) {}
};
```

### 3. Бинарное дерево

```
СТРУКТУРА TreeNode
    val: значение узла
    left: левый потомок
    right: правый потомок
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ СоздатьБинарныйУзел(значение)
    СОЗДАТЬ новый узел
    УСТАНОВИТЬ val = значение
    УСТАНОВИТЬ left = null
    УСТАНОВИТЬ right = null
    ВОЗВРАТ новый узел
КОНЕЦ АЛГОРИТМА
```

```javascript
class TreeNode {
    constructor(value) {
        this.val = value;
        this.left = null;
        this.right = null;
    }
}
```

```cpp
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int value) : val(value), left(nullptr), right(nullptr) {}
};
```

## Основные алгоритмы на деревьях

### 1. Обход дерева

#### Прямой обход (Pre-order)

```
АЛГОРИТМ preOrder(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ
    КОНЕЦ ЕСЛИ
    ВЫВЕСТИ корень.val
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        ВЫЗВАТЬ preOrder(child)
    КОНЕЦ ЦИКЛА
КОНЕЦ АЛГОРИТМА
```

```javascript
function preOrder(root) {
    if (root === null) return;

    console.log(root.val + " ");
    for (const child of root.children) {
        preOrder(child);
    }
}
```

```cpp
void preOrder(TreeNode* root) {
    if (root == nullptr) return;

    cout << root->val << " ";
    for (TreeNode* child : root->children) {
        preOrder(child);
    }
}
```

#### Центрированный обход (In-order) - для бинарных деревьев

```
АЛГОРИТМ inOrder(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ
    КОНЕЦ ЕСЛИ
    ВЫЗВАТЬ inOrder(корень.left)
    ВЫВЕСТИ корень.val
    ВЫЗВАТЬ inOrder(корень.right)
КОНЕЦ АЛГОРИТМА
```

```javascript
function inOrder(root) {
    if (root === null) return;

    inOrder(root.left);
    console.log(root.val + " ");
    inOrder(root.right);
}
```

```cpp
void inOrder(TreeNode* root) {
    if (root == nullptr) return;

    inOrder(root->left);
    cout << root->val << " ";
    inOrder(root->right);
}
```

#### Обратный обход (Post-order)

```
АЛГОРИТМ postOrder(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ
    КОНЕЦ ЕСЛИ
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        ВЫЗВАТЬ postOrder(child)
    КОНЕЦ ЦИКЛА
    ВЫВЕСТИ корень.val
КОНЕЦ АЛГОРИТМА
```

```javascript
function postOrder(root) {
    if (root === null) return;

    for (const child of root.children) {
        postOrder(child);
    }
    console.log(root.val + " ");
}
```

```cpp
void postOrder(TreeNode* root) {
    if (root == nullptr) return;

    for (TreeNode* child : root->children) {
        postOrder(child);
    }
    cout << root->val << " ";
}
```

### 2. Поиск в дереве

```
АЛГОРИТМ findNode(корень, цель)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ null
    КОНЕЦ ЕСЛИ
    ЕСЛИ корень.val = цель ТОГДА
        ВОЗВРАТ корень
    КОНЕЦ ЕСЛИ
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        result = ВЫЗВАТЬ findNode(child, цель)
        ЕСЛИ result != null ТОГДА
            ВОЗВРАТ result
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ null
КОНЕЦ АЛГОРИТМА
```

```javascript
function findNode(root, target) {
    if (root === null) return null;

    if (root.val === target) return root;

    for (const child of root.children) {
        const result = findNode(child, target);
        if (result !== null) return result;
    }

    return null;
}
```

```cpp
TreeNode* findNode(TreeNode* root, int target) {
    if (root == nullptr) return nullptr;

    if (root->val == target) return root;

    for (TreeNode* child : root->children) {
        TreeNode* result = findNode(child, target);
        if (result != nullptr) return result;
    }

    return nullptr;
}
```

### 3. Вычисление высоты дерева

```
АЛГОРИТМ getHeight(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ -1
    КОНЕЦ ЕСЛИ
    maxHeight = -1
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        maxHeight = МАКСИМУМ(maxHeight, getHeight(child))
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ maxHeight + 1
КОНЕЦ АЛГОРИТМА
```

```javascript
function getHeight(root) {
    if (root === null) return -1;

    let maxHeight = -1;
    for (const child of root.children) {
        maxHeight = Math.max(maxHeight, getHeight(child));
    }

    return maxHeight + 1;
}
```

```cpp
int getHeight(TreeNode* root) {
    if (root == nullptr) return -1;

    int maxHeight = -1;
    for (TreeNode* child : root->children) {
        maxHeight = max(maxHeight, getHeight(child));
    }

    return maxHeight + 1;
}
```

### 4. Подсчет количества узлов

```
АЛГОРИТМ countNodes(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ 0
    КОНЕЦ ЕСЛИ
    count = 1
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        count = count + countNodes(child)
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ count
КОНЕЦ АЛГОРИТМА
```

```javascript
function countNodes(root) {
    if (root === null) return 0;

    let count = 1;
    for (const child of root.children) {
        count += countNodes(child);
    }

    return count;
}
```

```cpp
int countNodes(TreeNode* root) {
    if (root == nullptr) return 0;

    int count = 1;
    for (TreeNode* child : root->children) {
        count += countNodes(child);
    }

    return count;
}
```

### 5. Поиск максимального элемента

```
АЛГОРИТМ findMax(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ отрицательная_бесконечность
    КОНЕЦ ЕСЛИ
    maxValue = корень.val
    ДЛЯ КАЖДОГО child в корень.children ЦИКЛ
        maxValue = МАКСИМУМ(maxValue, findMax(child))
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ maxValue
КОНЕЦ АЛГОРИТМА
```

```javascript
function findMax(root) {
    if (root === null) return Number.NEGATIVE_INFINITY;

    let maxValue = root.val;
    for (const child of root.children) {
        maxValue = Math.max(maxValue, findMax(child));
    }

    return maxValue;
}
```

```cpp
int findMax(TreeNode* root) {
    if (root == nullptr) return INT_MIN;

    int maxValue = root->val;
    for (TreeNode* child : root->children) {
        maxValue = max(maxValue, findMax(child));
    }

    return maxValue;
}
```

## Специализированные алгоритмы

### 1. Lowest Common Ancestor (LCA)

Находит наименьшего общего предка двух вершин в дереве.

```
АЛГОРИТМ findLCA(корень, p, q)
    ЕСЛИ корень = null ИЛИ корень = p ИЛИ корень = q ТОГДА
        ВОЗВРАТ корень
    КОНЕЦ ЕСЛИ
    left = findLCA(корень.left, p, q)
    right = findLCA(корень.right, p, q)
    ЕСЛИ left = null ТОГДА
        ВОЗВРАТ right
    ИНАЧЕ ЕСЛИ right = null ТОГДА
        ВОЗВРАТ left
    ИНАЧЕ
        ВОЗВРАТ корень
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
function findLCA(root, p, q) {
    if (root === null || root === p || root === q) return root;

    const left = findLCA(root.left, p, q);
    const right = findLCA(root.right, p, q);

    if (left === null) return right;
    if (right === null) return left;

    return root;
}
```

```cpp
TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q) return root;

    TreeNode* left = findLCA(root->left, p, q);
    TreeNode* right = findLCA(root->right, p, q);

    if (left == nullptr) return right;
    if (right == nullptr) return left;

    return root;
}
```

### 2. Диаметр дерева

Находит максимальное расстояние между любыми двумя узлами дерева.

```
АЛГОРИТМ diameter(корень, maxDiameter)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ 0
    КОНЕЦ ЕСЛИ
    leftHeight = getHeight(корень.left)
    rightHeight = getHeight(корень.right)
    currentDiameter = leftHeight + rightHeight + 1
    maxDiameter = МАКСИМУМ(maxDiameter, currentDiameter)
    ВОЗВРАТ МАКСИМУМ(leftHeight, rightHeight) + 1
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ getDiameter(корень)
    maxDiameter = 0
    ВЫЗВАТЬ diameter(корень, maxDiameter)
    ВОЗВРАТ maxDiameter - 1
КОНЕЦ АЛГОРИТМА
```

```javascript
function diameter(root, diameterObj) {
    if (root === null) return 0;

    const leftHeight = getHeight(root.left);
    const rightHeight = getHeight(root.right);

    const currentDiameter = leftHeight + rightHeight + 1;
    diameterObj.maxDiameter = Math.max(diameterObj.maxDiameter, currentDiameter);

    return Math.max(leftHeight, rightHeight) + 1;
}

function getDiameter(root) {
    const diameterObj = { maxDiameter: 0 };
    diameter(root, diameterObj);
    return diameterObj.maxDiameter - 1;
}
```

```cpp
int diameter(TreeNode* root, int& maxDiameter) {
    if (root == nullptr) return 0;

    int leftHeight = getHeight(root->left);
    int rightHeight = getHeight(root->right);

    int currentDiameter = leftHeight + rightHeight + 1;
    maxDiameter = max(maxDiameter, currentDiameter);

    return max(leftHeight, rightHeight) + 1;
}

int getDiameter(TreeNode* root) {
    int maxDiameter = 0;
    diameter(root, maxDiameter);
    return maxDiameter - 1;
}
```

### 3. Проверка на симметричность (зеркальность)

```
АЛГОРИТМ isSymmetric(левый, правый)
    ЕСЛИ левый = null И правый = null ТОГДА
        ВОЗВРАТ true
    ИНАЧЕ ЕСЛИ левый = null ИЛИ правый = null ТОГДА
        ВОЗВРАТ false
    ИНАЧЕ ЕСЛИ левый.val != правый.val ТОГДА
        ВОЗВРАТ false
    ИНАЧЕ
        ВОЗВРАТ isSymmetric(левый.left, правый.right) И isSymmetric(левый.right, правый.left)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ isSymmetric(корень)
    ЕСЛИ корень = null ТОГДА
        ВОЗВРАТ true
    ИНАЧЕ
        ВОЗВРАТ isSymmetric(корень.left, корень.right)
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА
```

```javascript
function isSymmetric(left, right) {
    if (left === null && right === null) return true;
    if (left === null || right === null) return false;
    if (left.val !== right.val) return false;

    return isSymmetric(left.left, right.right) &&
           isSymmetric(left.right, right.left);
}

function isSymmetric(root) {
    if (root === null) return true;
    return isSymmetric(root.left, root.right);
}
```

```cpp
bool isSymmetric(TreeNode* left, TreeNode* right) {
    if (left == nullptr && right == nullptr) return true;
    if (left == nullptr || right == nullptr) return false;
    if (left->val != right->val) return false;

    return isSymmetric(left->left, right->right) &&
           isSymmetric(left->right, right->left);
}

bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    return isSymmetric(root->left, root->right);
}
```

## Практические применения

### 1. Файловая система

Деревья используются для представления иерархической структуры файлов и каталогов.

### 2. XML/HTML разбор

Деревья DOM используются для представления структуры XML и HTML документов.

### 3. Индексация баз данных

B-деревья и их вариации используются в СУБД для эффективного поиска и сортировки данных.

### 4. Компиляторы

Абстрактные синтаксические деревья (AST) используются для представления структуры программного кода.

## Практические рекомендации

При работе с алгоритмами на деревьях следует учитывать:

1. **Безопасность памяти**: при реализации деревьев с динамическим выделением памяти важно правильно управлять ресурсами, особенно в C++ с использованием умных указателей.

2. **Производительность**: для высоконагруженных систем (например, в банковской сфере или телекоммуникациях) важно выбирать оптимальные алгоритмы обхода и структуры данных.

3. **Сложность реализации**: в промышленной разработке предпочтение часто отдается проверенным библиотекам и структурам данных, а не самописным реализациям.

4. **Тестирование**: деревья требуют тщательного тестирования, особенно граничных случаев (пустое дерево, дерево из одного узла, вырожденное дерево).

## Заключение

Алгоритмы на деревьях являются фундаментальной частью программирования и находят применение во множестве областей. Понимание этих алгоритмов и их правильная реализация критически важны для эффективного решения задач.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Представление-графов]]
- [[Обход-графов]]
- [[Поиск-в-глубину-и-ширину]]

#алгоритмы #деревья #структуры-данных #программирование