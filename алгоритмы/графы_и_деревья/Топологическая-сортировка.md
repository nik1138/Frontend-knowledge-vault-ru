---
aliases: [Топологическая сортировка, Топосортировка, Сортировка графа]
tags: [алгоритмы, графы, сортировка, программирование]
---

# Топологическая сортировка

## Общее описание

Топологическая сортировка - это линейное упорядочивание вершин ориентированного ациклического графа (DAG - Directed Acyclic Graph), такое что для каждого направленного ребра (u, v), вершина u идет перед вершиной v в этом упорядочивании. Топологическая сортировка находит широкое применение в задачах планирования, компиляции, анализа зависимостей и других областях.

## Основные понятия

- **Ориентированный ациклический граф (DAG)**: ориентированный граф без циклов
- **Исходящая степень**: количество рёбер, исходящих из вершины
- **Входящая степень**: количество рёбер, входящих в вершину
- **Исток**: вершина с нулевой входящей степенью
- **Сток**: вершина с нулевой исходящей степенью

## Алгоритмы топологической сортировки

### 1. Алгоритм Кана (на основе входящих степеней)

Алгоритм Кана работает, последовательно удаляя вершины с нулевой входящей степенью.

```
АЛГОРИТМ ТопологическаяСортировка_Кан(граф)
    ИНИЦИАЛИЗИРОВАТЬ inDegree массивом длины vertices, заполненным 0
    // Подсчет входящих степеней
    ДЛЯ u ОТ 0 ДО vertices-1 ЦИКЛ
        ДЛЯ КАЖДОГО v в adjList[u] ЦИКЛ
            inDegree[v] = inDegree[v] + 1
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЦИКЛА

    // Очередь для вершин с нулевой входящей степенью
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ inDegree[i] = 0 ТОГДА
            ПОМЕСТИТЬ i в queue
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    ИНИЦИАЛИЗИРОВАТЬ topOrder как пустой список

    ПОКА queue не пуста ТОГДА
        u = ВЗЯТЬ элемент из начала queue
        ДОБАВИТЬ u в topOrder

        // Уменьшаем входящую степень соседей
        ДЛЯ КАЖДОГО v в adjList[u] ЦИКЛ
            inDegree[v] = inDegree[v] - 1
            ЕСЛИ inDegree[v] = 0 ТОГДА
                ПОМЕСТИТЬ v в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    // Проверка на наличие цикла
    ЕСЛИ длина(topOrder) != vertices ТОГДА
        ВЫКИНУТЬ исключение "Граф содержит цикл"
    КОНЕЦ ЕСЛИ

    ВОЗВРАТ topOrder
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    topologicalSortKahn() {
        const inDegree = Array(this.vertices).fill(0);

        // Подсчет входящих степеней
        for (let u = 0; u < this.vertices; u++) {
            for (const v of this.adjList[u]) {
                inDegree[v]++;
            }
        }

        // Очередь для вершин с нулевой входящей степенью
        const queue = [];
        for (let i = 0; i < this.vertices; i++) {
            if (inDegree[i] === 0) {
                queue.push(i);
            }
        }

        const topOrder = [];

        while (queue.length > 0) {
            const u = queue.shift();
            topOrder.push(u);

            // Уменьшаем входящую степень соседей
            for (const v of this.adjList[u]) {
                inDegree[v]--;
                if (inDegree[v] === 0) {
                    queue.push(v);
                }
            }
        }

        // Проверка на наличие цикла
        if (topOrder.length !== this.vertices) {
            throw new Error("Граф содержит цикл");
        }

        return topOrder;
    }
}
```

```cpp
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    vector<int> topologicalSortKahn() {
        vector<int> inDegree(vertices, 0);

        // Подсчет входящих степеней
        for (int u = 0; u < vertices; u++) {
            for (int v : adjList[u]) {
                inDegree[v]++;
            }
        }

        // Очередь для вершин с нулевой входящей степенью
        queue<int> queue;
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                queue.push(i);
            }
        }

        vector<int> topOrder;

        while (!queue.empty()) {
            int u = queue.front();
            queue.pop();
            topOrder.push_back(u);

            // Уменьшаем входящую степень соседей
            for (int v : adjList[u]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    queue.push(v);
                }
            }
        }

        // Проверка на наличие цикла
        if (topOrder.size() != vertices) {
            throw runtime_error("Граф содержит цикл");
        }

        return topOrder;
    }
};
```

#### Сложность:
- Время: O(V + E)
- Память: O(V)

#### Преимущества:
- Простая реализация
- Хорошо работает с разреженными графами
- Позволяет обнаружить цикл

#### Недостатки:
- Требует дополнительной памяти для хранения входящих степеней

### 2. Алгоритм на основе DFS

Этот алгоритм использует поиск в глубину и времена выхода из вершин.

```
АЛГОРИТМ dfsUtil(вершина v, visited, stack)
    visited[v] = true
    ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ dfsUtil(neighbor, visited, stack)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ПОМЕСТИТЬ v в stack
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ТопологическаяСортировка_DFS(граф)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ВЫЗВАТЬ dfsUtil(i, visited, stack)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ИНИЦИАЛИЗИРОВАТЬ result как пустой список
    ПОКА stack не пуст ТОГДА
        ДОБАВИТЬ ВЕРХНИЙ ЭЛЕМЕНТ stack в result
        УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
    КОНЕЦ ПОКА
    ЕСЛИ hasCycle() = true ТОГДА
        ВЫКИНУТЬ исключение "Граф содержит цикл"
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ result
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    dfsUtil(v, visited, stack) {
        visited[v] = true;

        for (const neighbor of this.adjList[v]) {
            if (!visited[neighbor]) {
                this.dfsUtil(neighbor, visited, stack);
            }
        }

        stack.push(v);
    }

    topologicalSortDFS() {
        const visited = Array(this.vertices).fill(false);
        const stack = [];

        for (let i = 0; i < this.vertices; i++) {
            if (!visited[i]) {
                this.dfsUtil(i, visited, stack);
            }
        }

        const result = [];
        while (stack.length > 0) {
            result.push(stack.pop());
        }

        // Проверка на наличие цикла
        if (this.hasCycle()) {
            throw new Error("Граф содержит цикл");
        }

        return result;
    }

    hasCycle() {
        const visited = Array(this.vertices).fill(false);
        const recStack = Array(this.vertices).fill(false);

        for (let i = 0; i < this.vertices; i++) {
            if (this.hasCycleUtil(i, visited, recStack)) {
                return true;
            }
        }

        return false;
    }

    hasCycleUtil(v, visited, recStack) {
        if (!visited[v]) {
            visited[v] = true;
            recStack[v] = true;

            for (const neighbor of this.adjList[v]) {
                if (!visited[neighbor] && this.hasCycleUtil(neighbor, visited, recStack)) {
                    return true;
                } else if (recStack[neighbor]) {
                    return true;
                }
            }
        }

        recStack[v] = false;
        return false;
    }
}
```

```cpp
#include <vector>
#include <stack>
#include <iostream>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    void dfsUtil(int v, vector<bool>& visited, stack<int>& Stack) {
        visited[v] = true;

        for (int neighbor : adjList[v]) {
            if (!visited[neighbor]) {
                dfsUtil(neighbor, visited, Stack);
            }
        }

        Stack.push(v);
    }

    vector<int> topologicalSortDFS() {
        vector<bool> visited(vertices, false);
        stack<int> Stack;

        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                dfsUtil(i, visited, Stack);
            }
        }

        vector<int> result;
        while (!Stack.empty()) {
            result.push_back(Stack.top());
            Stack.pop();
        }

        // Проверка на наличие цикла
        if (hasCycle()) {
            throw runtime_error("Граф содержит цикл");
        }

        return result;
    }

private:
    bool hasCycle() {
        vector<bool> visited(vertices, false);
        vector<bool> recStack(vertices, false);

        for (int i = 0; i < vertices; i++) {
            if (hasCycleUtil(i, visited, recStack)) {
                return true;
            }
        }

        return false;
    }

    bool hasCycleUtil(int v, vector<bool>& visited, vector<bool>& recStack) {
        if (!visited[v]) {
            visited[v] = true;
            recStack[v] = true;

            for (int neighbor : adjList[v]) {
                if (!visited[neighbor] && hasCycleUtil(neighbor, visited, recStack)) {
                    return true;
                } else if (recStack[neighbor]) {
                    return true;
                }
            }
        }

        recStack[v] = false;
        return false;
    }
};
```

#### Сложность:
- Время: O(V + E)
- Память: O(V)

#### Преимущества:
- Использует рекурсию DFS, что может быть интуитивно понятнее
- Может быть легко адаптирован для других задач на графах

#### Недостатки:
- Может вызвать переполнение стека при больших графах
- Требует дополнительной проверки на цикл

### 3. Алгоритм Tarjan для топологической сортировки

```
АЛГОРИТМ strongConnect(вершина v, counter, index, lowlink, onStack, stack, order)
    index[v] = counter
    lowlink[v] = counter
    counter = counter + 1
    ПОМЕСТИТЬ v в stack
    onStack[v] = true

    ДЛЯ КАЖДОГО w в adjList[v] ЦИКЛ
        ЕСЛИ index[w] = -1 ТОГДА
            ВЫЗВАТЬ strongConnect(w, counter, index, lowlink, onStack, stack, order)
            lowlink[v] = МИНИМУМ(lowlink[v], lowlink[w])
        ИНАЧЕ ЕСЛИ onStack[w] = true ТОГДА
            lowlink[v] = МИНИМУМ(lowlink[v], index[w])
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    ЕСЛИ lowlink[v] = index[v] ТОГДА
        ПОВТОРЯТЬ
            w = ВЗЯТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
            УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из stack
            onStack[w] = false
            ЕСЛИ v = w ТОГДА
                ВЫЙТИ из цикла // Обнаружен цикл
            КОНЕЦ ЕСЛИ
            ДОБАВИТЬ w в order
        ПОКА w != v
        ДОБАВИТЬ v в order
    КОНЕЦ ЕСЛИ
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ ТопологическаяСортировка_Tarjan(граф)
    ИНИЦИАЛИЗИРОВАТЬ index массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ lowlink массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ onStack массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ stack как пустой стек
    ИНИЦИАЛИЗИРОВАТЬ order как пустой список
    counter = 0

    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ index[i] = -1 ТОГДА
            ВЫЗВАТЬ strongConnect(i, counter, index, lowlink, onStack, stack, order)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    РАЗВЕРНУТЬ order
    ВОЗВРАТ order
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    topologicalSortTarjan() {
        const index = Array(this.vertices).fill(-1);
        const lowlink = Array(this.vertices).fill(-1);
        const onStack = Array(this.vertices).fill(false);
        const stack = [];
        const order = [];
        let counter = 0;

        for (let i = 0; i < this.vertices; i++) {
            if (index[i] === -1) {
                this.strongConnect(i, counter, index, lowlink, onStack, stack, order);
            }
        }

        return order.reverse();
    }

    strongConnect(v, counter, index, lowlink, onStack, stack, order) {
        index[v] = counter;
        lowlink[v] = counter;
        counter++;
        stack.push(v);
        onStack[v] = true;

        for (const w of this.adjList[v]) {
            if (index[w] === -1) {
                this.strongConnect(w, counter, index, lowlink, onStack, stack, order);
                lowlink[v] = Math.min(lowlink[v], lowlink[w]);
            } else if (onStack[w]) {
                lowlink[v] = Math.min(lowlink[v], index[w]);
            }
        }

        if (lowlink[v] === index[v]) {
            let w;
            do {
                w = stack.pop();
                onStack[w] = false;
                if (v === w) break; // Обнаружен цикл
                order.push(w);
            } while (w !== v);
            order.push(v);
        }
    }
}
```

```cpp
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    vector<int> topologicalSortTarjan() {
        vector<int> index(vertices, -1);
        vector<int> lowlink(vertices, -1);
        vector<bool> onStack(vertices, false);
        stack<int> stack;
        vector<int> order;
        int counter = 0;

        for (int i = 0; i < vertices; i++) {
            if (index[i] == -1) {
                strongConnect(i, counter, index, lowlink, onStack, stack, order);
            }
        }

        reverse(order.begin(), order.end());
        return order;
    }

private:
    void strongConnect(int v, int& counter, vector<int>& index,
                       vector<int>& lowlink, vector<bool>& onStack,
                       stack<int>& stack, vector<int>& order) {
        index[v] = counter;
        lowlink[v] = counter;
        counter++;
        stack.push(v);
        onStack[v] = true;

        for (int w : adjList[v]) {
            if (index[w] == -1) {
                strongConnect(w, counter, index, lowlink, onStack, stack, order);
                lowlink[v] = min(lowlink[v], lowlink[w]);
            } else if (onStack[w]) {
                lowlink[v] = min(lowlink[v], index[w]);
            }
        }

        if (lowlink[v] == index[v]) {
            int w;
            do {
                w = stack.top();
                stack.pop();
                onStack[w] = false;
                if (v == w) break; // Обнаружен цикл
                order.push_back(w);
            } while (w != v);
            order.push_back(v);
        }
    }
};
```

## Практические применения

### 1. Планирование задач

Топологическая сортировка используется для определения порядка выполнения задач с зависимостями, например, в системах сборки или планировщиках задач.

```cpp
// Пример: задачи с зависимостями
// Задача 1 -> Задача 2 (Задача 2 зависит от задачи 1)
// Задача 1 -> Задача 3
// Задача 2 -> Задача 4
// Результат: 1, 2, 3, 4
```

### 2. Компиляция программ

При компиляции программ определяется порядок компиляции файлов в зависимости от их взаимных зависимостей.

### 3. Анализ зависимостей

В системах управления пакетами (например, npm, pip) используется для определения порядка установки зависимостей.

### 4. Схемы данных

В базах данных и системах обработки данных для определения порядка выполнения операций с учётом зависимостей.

## Практические рекомендации

При работе с топологической сортировкой следует учитывать:

1. **Обнаружение циклов**: всегда проверяйте, что граф ациклический, так как топологическая сортировка возможна только для DAG.

2. **Производительность**: для очень больших графов могут потребоваться специализированные подходы или распределённые алгоритмы.

3. **Память**: рекурсивная реализация может привести к переполнению стека, особенно в системах с ограниченными ресурсами.

4. **Реальные зависимости**: в промышленной разработке зависимости могут быть сложными и требовать дополнительной обработки (например, обработка опциональных зависимостей).

## Заключение

Топологическая сортировка - важный инструмент для решения задач, связанных с упорядочиванием элементов с учётом зависимостей. Понимание различных алгоритмов и их свойств позволяет выбирать наиболее подходящий метод для конкретной задачи.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Поиск-в-глубину-и-ширину]]
- [[Циклы-в-графах]]
- [[Обход-графов]]

#алгоритмы #графы #сортировка #программирование