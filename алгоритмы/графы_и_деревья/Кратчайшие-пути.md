---
aliases: [Кратчайшие пути, Алгоритмы кратчайших путей, Поиск кратчайшего пути]
tags: [алгоритмы, графы, кратчайшие-пути, программирование]
---

# Кратчайшие пути

## Общее описание

Задача нахождения кратчайшего пути - одна из фундаментальных задач в теории графов. Она заключается в нахождении пути между двумя вершинами графа, имеющего минимальный суммарный вес. Эта задача находит широкое применение в реальных системах: от навигации и логистики до сетевых протоколов и анализа социальных сетей.

## Основные понятия

- **Взвешенный граф**: граф, в котором каждому ребру приписан вес (длина, стоимость и т.д.)
- **Кратчайший путь**: путь между двумя вершинами с минимальной суммой весов рёбер
- **Одноисточниковый кратчайший путь**: кратчайшие пути от одной вершины ко всем остальным
- **Все пары кратчайших путей**: кратчайшие пути между всеми парами вершин

## Алгоритмы нахождения кратчайших путей

### 1. Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайшие пути от одной вершины ко всем остальным в графе с неотрицательными весами рёбер.

```
АЛГОРИТМ Дейкстра(граф, старт)
    dist = массив длины vertices, заполненный бесконечностью
    dist[старт] = 0
    ИНИЦИАЛИЗИРОВАТЬ pq как приоритетную очередь пар (расстояние, вершина)
    ПОМЕСТИТЬ (0, старт) в pq

    ПОКА pq не пуста ТОГДА
        currentDist, currentVertex = ИЗВЛЕЧЬ минимальный элемент из pq
        ЕСЛИ currentDist > dist[currentVertex] ТОГДА
            ПРОДОЛЖИТЬ
        КОНЕЦ ЕСЛИ

        ДЛЯ КАЖДОГО (neighbor, weight) в adjList[currentVertex] ЦИКЛ
            ЕСЛИ dist[currentVertex] + weight < dist[neighbor] ТОГДА
                dist[neighbor] = dist[currentVertex] + weight
                ПОМЕСТИТЬ (dist[neighbor], neighbor) в pq
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ dist
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v, weight) {
        this.adjList[u].push([v, weight]);
    }

    dijkstra(start) {
        const dist = Array(this.vertices).fill(Number.POSITIVE_INFINITY);
        dist[start] = 0;

        // Используем простую реализацию приоритетной очереди через массив
        const pq = [{ dist: 0, vertex: start }];

        while (pq.length > 0) {
            // Извлекаем элемент с минимальным расстоянием
            pq.sort((a, b) => a.dist - b.dist);
            const { dist: currentDist, vertex: currentVertex } = pq.shift();

            if (currentDist > dist[currentVertex]) continue;

            for (const [neighbor, weight] of this.adjList[currentVertex]) {
                if (dist[currentVertex] + weight < dist[neighbor]) {
                    dist[neighbor] = dist[currentVertex] + weight;
                    pq.push({ dist: dist[neighbor], vertex: neighbor });
                }
            }
        }

        return dist;
    }
}
```

```cpp
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<pair<int, int>>> adjList; // {сосед, вес}

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v, int weight) {
        adjList[u].push_back({v, weight});
    }

    vector<int> dijkstra(int start) {
        vector<int> dist(vertices, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

        dist[start] = 0;
        pq.push({0, start});

        while (!pq.empty()) {
            int currentDist = pq.top().first;
            int currentVertex = pq.top().second;
            pq.pop();

            if (currentDist > dist[currentVertex]) continue;

            for (auto& edge : adjList[currentVertex]) {
                int neighbor = edge.first;
                int weight = edge.second;

                if (dist[currentVertex] + weight < dist[neighbor]) {
                    dist[neighbor] = dist[currentVertex] + weight;
                    pq.push({dist[neighbor], neighbor});
                }
            }
        }

        return dist;
    }
};
```

#### Сложность:
- Время: O((V + E) log V) с использованием бинарной кучи
- Память: O(V)

#### Преимущества:
- Гарантирует нахождение кратчайшего пути
- Эффективен для графов с неотрицательными весами

#### Недостатки:
- Не работает с отрицательными весами
- Может быть медленным для плотных графов

### 2. Алгоритм Беллмана-Форда

Алгоритм Беллмана-Форда находит кратчайшие пути от одной вершины ко всем остальным, даже если в графе есть рёбра с отрицательным весом. Также может обнаруживать отрицательные циклы.

```
АЛГОРИТМ БеллманФорд(граф, старт)
    dist = массив длины vertices, заполненный бесконечностью
    dist[старт] = 0

    // Релаксация рёбер V-1 раз
    ДЛЯ i ОТ 0 ДО vertices-2 ЦИКЛ
        ДЛЯ КАЖДОГО (u, v, weight) в edges ЦИКЛ
            ЕСЛИ dist[u] != бесконечность И dist[u] + weight < dist[v] ТОГДА
                dist[v] = dist[u] + weight
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЦИКЛА

    // Проверка на отрицательные циклы
    ДЛЯ КАЖДОГО (u, v, weight) в edges ЦИКЛ
        ЕСЛИ dist[u] != бесконечность И dist[u] + weight < dist[v] ТОГДА
            ВЫКИНУТЬ исключение "Обнаружен отрицательный цикл"
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА

    ВОЗВРАТ dist
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.edges = [];
    }

    addEdge(u, v, weight) {
        this.edges.push([u, v, weight]);
    }

    bellmanFord(start) {
        const dist = Array(this.vertices).fill(Number.POSITIVE_INFINITY);
        dist[start] = 0;

        // Релаксация рёбер V-1 раз
        for (let i = 0; i < this.vertices - 1; i++) {
            for (const [u, v, weight] of this.edges) {
                if (dist[u] !== Number.POSITIVE_INFINITY && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }

        // Проверка на отрицательные циклы
        for (const [u, v, weight] of this.edges) {
            if (dist[u] !== Number.POSITIVE_INFINITY && dist[u] + weight < dist[v]) {
                throw new Error("Обнаружен отрицательный цикл");
            }
        }

        return dist;
    }
}
```

```cpp
#include <vector>
#include <climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<tuple<int, int, int>> edges; // {вершина1, вершина2, вес}

public:
    Graph(int v) : vertices(v) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back({u, v, weight});
    }

    vector<int> bellmanFord(int start) {
        vector<int> dist(vertices, INT_MAX);
        dist[start] = 0;

        // Релаксация рёбер V-1 раз
        for (int i = 0; i < vertices - 1; i++) {
            for (auto& edge : edges) {
                int u, v, weight;
                tie(u, v, weight) = edge;

                if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }

        // Проверка на отрицательные циклы
        for (auto& edge : edges) {
            int u, v, weight;
            tie(u, v, weight) = edge;

            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                // Обнаружен отрицательный цикл
                throw runtime_error("Обнаружен отрицательный цикл");
            }
        }

        return dist;
    }
};
```

#### Сложность:
- Время: O(VE)
- Память: O(V)

#### Преимущества:
- Работает с отрицательными весами
- Обнаруживает отрицательные циклы

#### Недостатки:
- Медленнее алгоритма Дейкстры
- Неэффективен для больших графов

### 3. Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла находит кратчайшие пути между всеми парами вершин.

```
АЛГОРИТМ ФлойдУоршелл(граф)
    // Инициализация матрицы расстояний
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ДЛЯ j ОТ 0 ДО vertices-1 ЦИКЛ
            ЕСЛИ i = j ТОГДА
                dist[i][j] = 0
            ИНАЧЕ
                dist[i][j] = бесконечность
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЦИКЛА

    // Заполнение начальных расстояний
    ДЛЯ КАЖДОГО ребра (u, v, weight) в графе ЦИКЛ
        dist[u][v] = weight
    КОНЕЦ ЦИКЛА

    // Основной алгоритм
    ДЛЯ k ОТ 0 ДО vertices-1 ЦИКЛ
        ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
            ДЛЯ j ОТ 0 ДО vertices-1 ЦИКЛ
                ЕСЛИ dist[i][k] != бесконечность И dist[k][j] != бесконечность И
                   dist[i][k] + dist[k][j] < dist[i][j] ТОГДА
                    dist[i][j] = dist[i][k] + dist[k][j]
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЦИКЛА
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЦИКЛА
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ getDistance(граф, u, v)
    ВОЗВРАТ dist[u][v]
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        // Инициализация матрицы расстояний
        this.dist = Array(v).fill().map(() => Array(v).fill(Number.POSITIVE_INFINITY));
        for (let i = 0; i < v; i++) {
            this.dist[i][i] = 0;
        }
    }

    addEdge(u, v, weight) {
        this.dist[u][v] = weight;
    }

    floydWarshall() {
        for (let k = 0; k < this.vertices; k++) {
            for (let i = 0; i < this.vertices; i++) {
                for (let j = 0; j < this.vertices; j++) {
                    if (this.dist[i][k] !== Number.POSITIVE_INFINITY &&
                        this.dist[k][j] !== Number.POSITIVE_INFINITY &&
                        this.dist[i][k] + this.dist[k][j] < this.dist[i][j]) {
                        this.dist[i][j] = this.dist[i][k] + this.dist[k][j];
                    }
                }
            }
        }
    }

    getDistance(u, v) {
        return this.dist[u][v];
    }
}
```

```cpp
#include <vector>
#include <climits>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> dist;

public:
    Graph(int v) : vertices(v) {
        dist.assign(v, vector<int>(v, INT_MAX));
        for (int i = 0; i < v; i++) {
            dist[i][i] = 0;
        }
    }

    void addEdge(int u, int v, int weight) {
        dist[u][v] = weight;
    }

    void floydWarshall() {
        for (int k = 0; k < vertices; k++) {
            for (int i = 0; i < vertices; i++) {
                for (int j = 0; j < vertices; j++) {
                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
    }

    int getDistance(int u, int v) {
        return dist[u][v];
    }
};
```

#### Сложность:
- Время: O(V³)
- Память: O(V²)

#### Преимущества:
- Находит кратчайшие пути между всеми парами вершин
- Простая реализация

#### Недостатки:
- Высокая временная сложность
- Неэффективен для разреженных графов

### 4. Алгоритм A*

Алгоритм A* - это информированный алгоритм поиска, который использует эвристику для нахождения кратчайшего пути от начальной вершины к целевой.

```
СТРУКТУРА Node
    id: идентификатор вершины
    f: общая оценка (g + h)
    g: стоимость пути от начальной вершины
    h: эвристическая оценка до целевой вершины
КОНЕЦ СТРУКТУРЫ

АЛГОРИТМ AStar_найтиПуть(граф, старт, цель)
    ИНИЦИАЛИЗИРОВАТЬ gScore массивом длины vertices, заполненным бесконечностью
    ИНИЦИАЛИЗИРОВАТЬ cameFrom массивом длины vertices, заполненным -1
    ИНИЦИАЛИЗИРОВАТЬ openSet как приоритетную очередь узлов
    gScore[старт] = 0
    fStart = heuristic(старт, цель)
    ПОМЕСТИТЬ Node(старт, fStart, 0, heuristic(старт, цель)) в openSet

    ПОКА openSet не пуста ТОГДА
        current = ИЗВЛЕЧЬ узел с минимальным f из openSet
        ЕСЛИ current.id = цель ТОГДА
            // Восстановление пути
            ИНИЦИАЛИЗИРОВАТЬ path как пустой список
            currentId = цель
            ПОКА currentId != -1 ЦИКЛ
                ДОБАВИТЬ currentId в path
                currentId = cameFrom[currentId]
            КОНЕЦ ЦИКЛА
            РАЗВЕРНУТЬ path
            ВОЗВРАТ path
        КОНЕЦ ЕСЛИ

        ДЛЯ КАЖДОГО (neighbor, weight) в adjList[current.id] ЦИКЛ
            tentativeGScore = gScore[current.id] + weight
            ЕСЛИ tentativeGScore < gScore[neighbor] ТОГДА
                cameFrom[neighbor] = current.id
                gScore[neighbor] = tentativeGScore
                fScore = tentativeGScore + heuristic(neighbor, цель)
                ПОМЕСТИТЬ Node(neighbor, fScore, tentativeGScore, heuristic(neighbor, цель)) в openSet
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА

    ВОЗВРАТ пустой список // Путь не найден
КОНЕЦ АЛГОРИТМА
```

```javascript
class Node {
    constructor(id, f, g, h) {
        this.id = id;
        this.f = f;
        this.g = g;
        this.h = h;
    }
}

class AStar {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
        this.coordinates = Array(v).fill().map(() => [0, 0]); // координаты вершин для эвристики
    }

    addEdge(u, v, weight) {
        this.adjList[u].push([v, weight]);
        this.adjList[v].push([u, weight]); // для неориентированного графа
    }

    setCoordinates(vertex, x, y) {
        this.coordinates[vertex] = [x, y];
    }

    heuristic(u, v) {
        // Евклидово расстояние
        const dx = this.coordinates[u][0] - this.coordinates[v][0];
        const dy = this.coordinates[u][1] - this.coordinates[v][1];
        return Math.sqrt(dx * dx + dy * dy);
    }

    findPath(start, goal) {
        const gScore = Array(this.vertices).fill(Number.POSITIVE_INFINITY);
        const cameFrom = Array(this.vertices).fill(-1);
        const openSet = [];

        gScore[start] = 0.0;
        const hStart = this.heuristic(start, goal);
        openSet.push(new Node(start, hStart, 0.0, hStart));

        while (openSet.length > 0) {
            // Извлечение узла с минимальным f
            openSet.sort((a, b) => a.f - b.f);
            const current = openSet.shift();

            if (current.id === goal) {
                // Восстановление пути
                const path = [];
                let currentId = goal;
                while (currentId !== -1) {
                    path.push(currentId);
                    currentId = cameFrom[currentId];
                }
                return path.reverse();
            }

            for (const [neighbor, weight] of this.adjList[current.id]) {
                const tentativeGScore = gScore[current.id] + weight;

                if (tentativeGScore < gScore[neighbor]) {
                    cameFrom[neighbor] = current.id;
                    gScore[neighbor] = tentativeGScore;
                    const fScore = tentativeGScore + this.heuristic(neighbor, goal);
                    openSet.push(new Node(neighbor, fScore, tentativeGScore, this.heuristic(neighbor, goal)));
                }
            }
        }

        return []; // Путь не найден
    }
}
```

```cpp
#include <vector>
#include <queue>
#include <cmath>
using namespace std;

struct Node {
    int id;
    double f, g, h; // f = g + h

    bool operator>(const Node& other) const {
        return f > other.f;
    }
};

class AStar {
private:
    int vertices;
    vector<vector<pair<int, double>>> adjList; // {сосед, вес}
    vector<pair<double, double>> coordinates; // координаты вершин для эвристики

public:
    AStar(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v, double weight) {
        adjList[u].push_back({v, weight});
        adjList[v].push_back({u, weight}); // для неориентированного графа
    }

    void setCoordinates(int vertex, double x, double y) {
        if (coordinates.size() <= vertex) {
            coordinates.resize(vertex + 1);
        }
        coordinates[vertex] = {x, y};
    }

    double heuristic(int u, int v) {
        // Евклидово расстояние
        double dx = coordinates[u].first - coordinates[v].first;
        double dy = coordinates[u].second - coordinates[v].second;
        return sqrt(dx*dx + dy*dy);
    }

    vector<int> findPath(int start, int goal) {
        vector<double> gScore(vertices, numeric_limits<double>::infinity());
        vector<int> cameFrom(vertices, -1);
        priority_queue<Node, vector<Node>, greater<Node>> openSet;

        gScore[start] = 0.0;
        double hStart = heuristic(start, goal);
        openSet.push({start, hStart, 0.0, hStart});

        while (!openSet.empty()) {
            Node current = openSet.top();
            openSet.pop();

            if (current.id == goal) {
                // Восстановление пути
                vector<int> path;
                int currentId = goal;
                while (currentId != -1) {
                    path.push_back(currentId);
                    currentId = cameFrom[currentId];
                }
                reverse(path.begin(), path.end());
                return path;
            }

            for (auto& edge : adjList[current.id]) {
                int neighbor = edge.first;
                double weight = edge.second;
                double tentativeGScore = gScore[current.id] + weight;

                if (tentativeGScore < gScore[neighbor]) {
                    cameFrom[neighbor] = current.id;
                    gScore[neighbor] = tentativeGScore;
                    double fScore = tentativeGScore + heuristic(neighbor, goal);
                    openSet.push({neighbor, fScore, tentativeGScore, heuristic(neighbor, goal)});
                }
            }
        }

        return {}; // Путь не найден
    }
};
```

## Практические применения

### 1. Навигационные системы

Алгоритмы кратчайших путей используются в GPS-навигации для поиска оптимального маршрута между двумя точками.

### 2. Сетевые протоколы

Алгоритмы маршрутизации, такие как OSPF, используют варианты алгоритмов кратчайших путей для определения оптимальных маршрутов в сетях.

### 3. Логистика и транспорт

Оптимизация доставки товаров, планирование транспортных маршрутов и т.д.

### 4. Социальные сети

Алгоритмы могут использоваться для определения кратчайших социальных связей между пользователями.

## Практические рекомендации

При реализации алгоритмов кратчайших путей следует учитывать:

1. **Производительность**: для высоконагруженных систем (например, транспортных приложений) важно выбирать наиболее эффективные алгоритмы и структуры данных.

2. **Работа с большими графами**: при работе с графами с миллионами вершин могут потребоваться специализированные подходы, такие как иерархические графы или использование внешней памяти.

3. **Динамические графы**: в реальных системах граф может часто изменяться (например, изменение транспортных условий), что требует адаптации алгоритмов.

4. **Многопоточность**: современные системы всё чаще используют многопоточность, что открывает возможности для параллельных алгоритмов кратчайших путей.

## Заключение

Алгоритмы нахождения кратчайших путей являются важной частью многих приложений. Выбор конкретного алгоритма зависит от характеристик графа (наличие отрицательных весов, плотность, размер) и требований к производительности.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Поиск-в-глубину-и-ширину]]
- [[Остовные-деревья]]
- [[Представление-графов]]

#алгоритмы #графы #кратчайшие-пути #программирование