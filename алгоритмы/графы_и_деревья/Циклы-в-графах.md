---
aliases: [Циклы в графах, Обнаружение циклов, Циклические графы]
tags: [алгоритмы, графы, циклы, программирование]
---

# Циклы в графах

## Общее описание

Цикл в графе - это путь, начинающийся и заканчивающийся в одной и той же вершине, проходящий через другие вершины не более одного раза. Обнаружение циклов - важная задача в теории графов, встречающаяся во многих приложениях: от анализа зависимостей до определения топологической сортировки. В этой статье рассматриваются различные подходы к обнаружению циклов в ориентированных и неориентированных графах.

## Основные понятия

- **Цикл**: путь, начинающийся и заканчивающийся в одной вершине
- **Простой цикл**: цикл, в котором все вершины, кроме начальной/конечной, различны
- **Ориентированный цикл**: цикл в ориентированном графе, следующий направлению рёбер
- **Фундаментальный цикл**: цикл, образованный добавлением одного ребра к остовному дереву

## Обнаружение циклов в неориентированном графе

### Метод DFS с отслеживанием родителя

```
АЛГОРИТМ hasCycleUtil(вершина v, visited, parent)
    visited[v] = true
    ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ЕСЛИ hasCycleUtil(neighbor, visited, v) = true ТОГДА
                ВОЗВРАТ true
            КОНЕЦ ЕСЛИ
        ИНАЧЕ ЕСЛИ neighbor != parent ТОГДА
            // Найден цикл
            ВОЗВРАТ true
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ hasCycle(граф)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ЕСЛИ hasCycleUtil(i, visited, -1) = true ТОГДА
                ВОЗВРАТ true
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u);
    }

    hasCycleUtil(v, visited, parent) {
        visited[v] = true;

        for (const neighbor of this.adjList[v]) {
            // Если сосед не посещен, рекурсивно проверяем
            if (!visited[neighbor]) {
                if (this.hasCycleUtil(neighbor, visited, v)) {
                    return true;
                }
            }
            // Если сосед посещен и не является родителем,
            // то найден цикл
            else if (neighbor !== parent) {
                return true;
            }
        }

        return false;
    }

    hasCycle() {
        const visited = Array(this.vertices).fill(false);

        for (let i = 0; i < this.vertices; i++) {
            if (!visited[i]) {
                if (this.hasCycleUtil(i, visited, -1)) {
                    return true;
                }
            }
        }

        return false;
    }
}
```


### Метод Union-Find

```
АЛГОРИТМ find(x)
    ЕСЛИ parent[x] != x ТОГДА
        parent[x] = find(parent[x]) // Path compression
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ parent[x]
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ unite(x, y)
    rootX = find(x)
    rootY = find(y)
    ЕСЛИ rootX = rootY ТОГДА
        ВОЗВРАТ false // Обнаружен цикл
    КОНЕЦ ЕСЛИ
    // Union by rank
    ЕСЛИ rank[rootX] < rank[rootY] ТОГДА
        parent[rootX] = rootY
    ИНАЧЕ ЕСЛИ rank[rootX] > rank[rootY] ТОГДА
        parent[rootY] = rootX
    ИНАЧЕ
        parent[rootY] = rootX
        rank[rootX] = rank[rootX] + 1
    КОНЕЦ ЕСЛИ
    ВОЗВРАТ true
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ hasCycleUnionFind(граф)
    ИНИЦИАЛИЗИРОВАТЬ UnionFind структуру для vertices вершин
    ДЛЯ КАЖДОГО ребра (u, v) в edges ЦИКЛ
        ЕСЛИ unite(u, v) = false ТОГДА
            ВОЗВРАТ true // Обнаружен цикл
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА
```

```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array(n);
        this.rank = Array(n).fill(0);
        for (let i = 0; i < n; i++) {
            this.parent[i] = i;
        }
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // Path compression
        }
        return this.parent[x];
    }

    unite(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);

        if (rootX === rootY) {
            return false; // Обнаружен цикл
        }

        // Union by rank
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }

        return true;
    }
}

class Graph {
    constructor(v) {
        this.vertices = v;
        this.edges = []; // [{u, v}]
    }

    addEdge(u, v) {
        this.edges.push({u, v});
    }

    hasCycleUnionFind() {
        const uf = new UnionFind(this.vertices);

        for (const edge of this.edges) {
            const {u, v} = edge;

            if (!uf.unite(u, v)) {
                return true; // Обнаружен цикл
            }
        }

        return false;
    }
}
```


## Обнаружение циклов в ориентированном графе

### Метод DFS с отслеживанием стека рекурсии

```
АЛГОРИТМ hasCycleUtil(вершина v, visited, recStack)
    ЕСЛИ visited[v] = false ТОГДА
        visited[v] = true
        recStack[v] = true
        ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
            ЕСЛИ visited[neighbor] = false И hasCycleUtil(neighbor, visited, recStack) = true ТОГДА
                ВОЗВРАТ true
            ИНАЧЕ ЕСЛИ recStack[neighbor] = true ТОГДА
                ВОЗВРАТ true // Обнаружен цикл
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ЕСЛИ
    recStack[v] = false // Удаляем из стека рекурсии
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ hasCycle(граф)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ recStack массивом длины vertices, заполненным false
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ hasCycleUtil(i, visited, recStack) = true ТОГДА
            ВОЗВРАТ true
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    hasCycleUtil(v, visited, recStack) {
        if (!visited[v]) {
            visited[v] = true;
            recStack[v] = true;

            for (const neighbor of this.adjList[v]) {
                if (!visited[neighbor] && this.hasCycleUtil(neighbor, visited, recStack)) {
                    return true;
                } else if (recStack[neighbor]) {
                    return true; // Обнаружен цикл
                }
            }
        }

        recStack[v] = false; // Удаляем из стека рекурсии
        return false;
    }

    hasCycle() {
        const visited = Array(this.vertices).fill(false);
        const recStack = Array(this.vertices).fill(false);

        for (let i = 0; i < this.vertices; i++) {
            if (this.hasCycleUtil(i, visited, recStack)) {
                return true;
            }
        }

        return false;
    }
}
```

```cpp
class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    bool hasCycleUtil(int v, vector<bool>& visited,
                      vector<bool>& recStack) {
        if (!visited[v]) {
            visited[v] = true;
            recStack[v] = true;

            for (int neighbor : adjList[v]) {
                if (!visited[neighbor] && hasCycleUtil(neighbor, visited, recStack)) {
                    return true;
                } else if (recStack[neighbor]) {
                    return true; // Обнаружен цикл
                }
            }
        }

        recStack[v] = false; // Удаляем из стека рекурсии
        return false;
    }

    bool hasCycle() {
        vector<bool> visited(vertices, false);
        vector<bool> recStack(vertices, false);

        for (int i = 0; i < vertices; i++) {
            if (hasCycleUtil(i, visited, recStack)) {
                return true;
            }
        }

        return false;
    }
};
```

### Метод на основе топологической сортировки

```
АЛГОРИТМ hasCycleTopological(граф)
    ИНИЦИАЛИЗИРОВАТЬ queue как пустую очередь
    // Добавляем вершины с нулевой входящей степенью
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ inDegree[i] = 0 ТОГДА
            ПОМЕСТИТЬ i в queue
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    processed = 0
    ПОКА queue не пуста ТОГДА
        u = ВЗЯТЬ элемент из начала queue
        УДАЛИТЬ элемент из начала queue
        processed = processed + 1
        ДЛЯ КАЖДОГО v в adjList[u] ЦИКЛ
            inDegree[v] = inDegree[v] - 1
            ЕСЛИ inDegree[v] = 0 ТОГДА
                ПОМЕСТИТЬ v в queue
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЦИКЛА
    КОНЕЦ ПОКА
    // Если не все вершины были обработаны, то есть цикл
    ВОЗВРАТ processed != vertices
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
        this.inDegree = Array(v).fill(0);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.inDegree[v]++;
    }

    hasCycleTopological() {
        const queue = [];

        // Добавляем вершины с нулевой входящей степенью
        for (let i = 0; i < this.vertices; i++) {
            if (this.inDegree[i] === 0) {
                queue.push(i);
            }
        }

        let processed = 0;

        while (queue.length > 0) {
            const u = queue.shift();
            processed++;

            for (const v of this.adjList[u]) {
                this.inDegree[v]--;
                if (this.inDegree[v] === 0) {
                    queue.push(v);
                }
            }
        }

        // Если не все вершины были обработаны, то есть цикл
        return processed !== this.vertices;
    }
}
```

```cpp
#include <vector>
#include <queue>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;
    vector<int> inDegree;

public:
    Graph(int v) : vertices(v), adjList(v), inDegree(v, 0) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        inDegree[v]++;
    }

    bool hasCycleTopological() {
        queue<int> queue;

        // Добавляем вершины с нулевой входящей степенью
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                queue.push(i);
            }
        }

        int processed = 0;

        while (!queue.empty()) {
            int u = queue.front();
            queue.pop();
            processed++;

            for (int v : adjList[u]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    queue.push(v);
                }
            }
        }

        // Если не все вершины были обработаны, то есть цикл
        return processed != vertices;
    }
};
```

## Поиск всех циклов

### Поиск одного цикла в неориентированном графе

```
АЛГОРИТМ findCycleDFS(вершина v, parent, visited, parents, path)
    visited[v] = true
    ПОМЕСТИТЬ v в path
    parents[v] = parent
    ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ЕСЛИ findCycleDFS(neighbor, v, visited, parents, path) = true ТОГДА
                ВОЗВРАТ true
            КОНЕЦ ЕСЛИ
        ИНАЧЕ ЕСЛИ neighbor != parent ТОГДА
            // Найден цикл
            ПОМЕСТИТЬ neighbor в path
            ВОЗВРАТ true
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
    ВОЗВРАТ false
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ findCycle(граф)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ parent массивом длины vertices, заполненным -1
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ИНИЦИАЛИЗИРОВАТЬ path как пустой стек
            ЕСЛИ findCycleDFS(i, -1, visited, parent, path) = true ТОГДА
                // Восстановление цикла
                ИНИЦИАЛИЗИРОВАТЬ cycle как пустой список
                current = ВЗЯТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
                УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
                ДОБАВИТЬ current в cycle
                ПОКА ВЕРХНИЙ ЭЛЕМЕНТ path != current ЦИКЛ
                    ДОБАВИТЬ ВЕРХНИЙ ЭЛЕМЕНТ path в cycle
                    УДАЛИТЬ ВЕРХНИЙ ЭЛЕМЕНТ из path
                КОНЕЦ ЦИКЛА
                ДОБАВИТЬ ВЕРХНИЙ ЭЛЕМЕНТ path в cycle
                ВОЗВРАТ cycle
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ пустой список // Цикл не найден
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
        this.adjList[v].push(u);
    }

    findCycle() {
        const visited = Array(this.vertices).fill(false);
        const parent = Array(this.vertices).fill(-1);

        for (let i = 0; i < this.vertices; i++) {
            if (!visited[i]) {
                const path = [];
                if (this.findCycleDFS(i, -1, visited, parent, path)) {
                    // Восстановление цикла
                    const cycle = [];
                    const current = path.pop();
                    cycle.push(current);

                    while (path[path.length - 1] !== current) {
                        cycle.push(path.pop());
                    }
                    cycle.push(path.pop());

                    return cycle;
                }
            }
        }

        return []; // Цикл не найден
    }

    findCycleDFS(v, parent, visited, parents, path) {
        visited[v] = true;
        path.push(v);
        parents[v] = parent;

        for (const neighbor of this.adjList[v]) {
            if (!visited[neighbor]) {
                if (this.findCycleDFS(neighbor, v, visited, parents, path)) {
                    return true;
                }
            } else if (neighbor !== parent) {
                // Найден цикл
                path.push(neighbor);
                return true;
            }
        }

        path.pop();
        return false;
    }
}
```

```cpp
#include <vector>
#include <stack>
using namespace std;

class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    vector<int> findCycle() {
        vector<bool> visited(vertices, false);
        vector<int> parent(vertices, -1);

        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                stack<int> path;
                if (findCycleDFS(i, -1, visited, parent, path)) {
                    // Восстановление цикла
                    vector<int> cycle;
                    int current = path.top();
                    path.pop();
                    cycle.push_back(current);

                    while (path.top() != current) {
                        cycle.push_back(path.top());
                        path.pop();
                    }
                    cycle.push_back(path.top());

                    return cycle;
                }
            }
        }

        return {}; // Цикл не найден
    }

private:
    bool findCycleDFS(int v, int parent, vector<bool>& visited,
                      vector<int>& parents, stack<int>& path) {
        visited[v] = true;
        path.push(v);
        parents[v] = parent;

        for (int neighbor : adjList[v]) {
            if (!visited[neighbor]) {
                if (findCycleDFS(neighbor, v, visited, parents, path)) {
                    return true;
                }
            } else if (neighbor != parent) {
                // Найден цикл
                path.push(neighbor);
                return true;
            }
        }

        path.pop();
        return false;
    }
};
```

### Поиск всех циклов в ориентированном графе

```
АЛГОРИТМ findAllCyclesDFS(вершина v, visited, recStack, path)
    visited[v] = true
    recStack[v] = true
    ДОБАВИТЬ v в path
    ДЛЯ КАЖДОГО neighbor в adjList[v] ЦИКЛ
        ЕСЛИ visited[neighbor] = false ТОГДА
            ВЫЗВАТЬ findAllCyclesDFS(neighbor, visited, recStack, path)
        ИНАЧЕ ЕСЛИ recStack[neighbor] = true ТОГДА
            // Найден цикл
            ИНИЦИАЛИЗИРОВАТЬ cycle как пустой список
            НАЙТИ ПОЗИЦИЮ neighbor в path
            ДЛЯ КАЖДОГО элемента в path, начиная с позиции neighbor ЦИКЛ
                ДОБАВИТЬ элемент в cycle
            КОНЕЦ ЦИКЛА
            ДОБАВИТЬ neighbor в cycle // Замыкаем цикл
            ДОБАВИТЬ cycle в allCycles
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    recStack[v] = false
    УДАЛИТЬ ПОСЛЕДНИЙ ЭЛЕМЕНТ из path
КОНЕЦ АЛГОРИТМА

АЛГОРИТМ findAllCycles(граф)
    ИНИЦИАЛИЗИРОВАТЬ visited массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ recStack массивом длины vertices, заполненным false
    ИНИЦИАЛИЗИРОВАТЬ path как пустой список
    ДЛЯ i ОТ 0 ДО vertices-1 ЦИКЛ
        ЕСЛИ visited[i] = false ТОГДА
            ВЫЗВАТЬ findAllCyclesDFS(i, visited, recStack, path)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ЦИКЛА
    ВОЗВРАТ allCycles
КОНЕЦ АЛГОРИТМА
```

```javascript
class Graph {
    constructor(v) {
        this.vertices = v;
        this.adjList = Array(v).fill().map(() => []);
        this.allCycles = [];
    }

    addEdge(u, v) {
        this.adjList[u].push(v);
    }

    findAllCycles() {
        this.allCycles = []; // Очищаем предыдущие циклы
        const visited = Array(this.vertices).fill(false);
        const recStack = Array(this.vertices).fill(false);
        const path = [];

        for (let i = 0; i < this.vertices; i++) {
            if (!visited[i]) {
                this.findAllCyclesDFS(i, visited, recStack, path);
            }
        }

        return this.allCycles;
    }

    findAllCyclesDFS(v, visited, recStack, path) {
        visited[v] = true;
        recStack[v] = true;
        path.push(v);

        for (const neighbor of this.adjList[v]) {
            if (!visited[neighbor]) {
                this.findAllCyclesDFS(neighbor, visited, recStack, path);
            } else if (recStack[neighbor]) {
                // Найден цикл
                const cycle = [];
                const startIndex = path.indexOf(neighbor);
                for (let i = startIndex; i < path.length; i++) {
                    cycle.push(path[i]);
                }
                cycle.push(neighbor); // Замыкаем цикл
                this.allCycles.push(cycle);
            }
        }

        recStack[v] = false;
        path.pop();
    }
}
```

```cpp
class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;
    vector<vector<int>> allCycles;

public:
    Graph(int v) : vertices(v), adjList(v) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    vector<vector<int>> findAllCycles() {
        vector<bool> visited(vertices, false);
        vector<bool> recStack(vertices, false);
        vector<int> path;

        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                findAllCyclesDFS(i, visited, recStack, path);
            }
        }

        return allCycles;
    }

private:
    void findAllCyclesDFS(int v, vector<bool>& visited,
                          vector<bool>& recStack, vector<int>& path) {
        visited[v] = true;
        recStack[v] = true;
        path.push_back(v);

        for (int neighbor : adjList[v]) {
            if (!visited[neighbor]) {
                findAllCyclesDFS(neighbor, visited, recStack, path);
            } else if (recStack[neighbor]) {
                // Найден цикл
                vector<int> cycle;
                auto it = find(path.begin(), path.end(), neighbor);
                for (auto i = it; i != path.end(); ++i) {
                    cycle.push_back(*i);
                }
                cycle.push_back(neighbor); // Замыкаем цикл
                allCycles.push_back(cycle);
            }
        }

        recStack[v] = false;
        path.pop_back();
    }
};
```

## Практические применения

### 1. Обнаружение зависимостей

В системах управления пакетами или компиляции важно обнаруживать циклические зависимости.

### 2. Планирование задач

При планировании задач с зависимостями циклы указывают на противоречивые зависимости.

### 3. Анализ социальных сетей

Циклы могут указывать на замкнутые группы пользователей или взаимосвязи.

### 4. Системы типов

В языках программирования с параметрическим полиморфизмом циклы могут указывать на противоречивые ограничения типов.

## Практические рекомендации

При работе с обнаружением циклов следует учитывать:

1. **Производительность**: для больших графов могут потребоваться оптимизированные алгоритмы или приближённые методы.

2. **Память**: рекурсивные реализации могут привести к переполнению стека, особенно в системах с ограниченными ресурсами.

3. **Реальные данные**: в промышленной разработке графы могут быть очень большими и разреженными, что требует специальных подходов.

4. **Обработка циклов**: часто недостаточно просто обнаружить цикл - нужно также корректно обработать его наличие в контексте конкретной задачи.

## Заключение

Обнаружение циклов в графах - важная задача, встречающаяся во многих приложениях. Выбор подходящего алгоритма зависит от типа графа (ориентированный/неориентированный), размера графа и специфики задачи.

Для дальнейшего изучения рекомендуется обратиться к статьям:
- [[Поиск-в-глубину-и-ширину]]
- [[Топологическая-сортировка]]
- [[Сильно-связные-компоненты]]

#алгоритмы #графы #циклы #программирование