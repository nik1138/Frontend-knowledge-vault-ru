---
aliases: [Event Processing Algorithms, Алгоритмы обработки событий]
tags: [frontend, algorithms, events, javascript, performance, dom]
---

# Алгоритмы обработки событий

## Введение

Алгоритмы обработки событий являются фундаментальной частью фронтенд-разработки, обеспечивая интерактивность и отзывчивость веб-приложений. С увеличением сложности интерфейсов и ростом требований к производительности, эффективные алгоритмы обработки событий становятся особенно важными. Они позволяют создавать плавные пользовательские интерфейсы, оптимизировать производительность и обеспечивать надежное взаимодействие с пользователем.

## Основные понятия обработки событий

### Что такое событие в контексте DOM?

Событие в DOM - это сигнал, который указывает на то, что произошло какое-то действие (например, клик мыши, нажатие клавиши, изменение размеров окна). События проходят через три фазы:
1. **Фаза захвата (capture phase)** - событие проходит от корня документа к целевому элементу
2. **Фаза цели (target phase)** - событие достигает целевого элемента
3. **Фаза всплытия (bubbling phase)** - событие всплывает от целевого элемента к корню документа

### Типы событий

1. **UI события** - клики, наведение, изменение размеров
2. **Клавиатурные события** - нажатия клавиш, ввод текста
3. **Формовые события** - отправка формы, изменение значений
4. **События мыши** - клики, перемещение, наведение
5. **События сенсорного ввода** - для мобильных устройств
6. **События анимации** - начало, конец, итерация анимации

## Базовые алгоритмы обработки событий

### 1. Алгоритм простого слушателя событий

Самый базовый подход к обработке событий:

**Псевдокод:**
```
ФУНКЦИЯ addSimpleEventListener(элемент, тип_события, обработчик):
    элемент.addEventListener(тип_события, обработчик)
    ВОЗВРАТ () -> элемент.removeEventListener(тип_события, обработчик)

// Пример использования
кнопка = получитьЭлемент('myButton')
удалить_слушателя = addSimpleEventListener(кнопка, 'click', (событие) -> {
    вывести('Кнопка нажата')
})

// Для удаления слушателя
// удалить_слушателя()
```

**Псевдокод:**
```
ФУНКЦИЯ addSimpleEventListener(элемент, тип_события, обработчик):
    элемент.addEventListener(тип_события, обработчик)
    ВОЗВРАТ () -> элемент.removeEventListener(тип_события, обработчик)

// Пример использования
кнопка = получитьЭлемент('myButton')
удалить_слушателя = addSimpleEventListener(кнопка, 'click', (событие) -> {
    вывести('Кнопка нажата')
})

// Для удаления слушателя
// удалить_слушателя()
```

```javascript
function addSimpleEventListener(element, eventType, handler) {
    element.addEventListener(eventType, handler);
    return () => element.removeEventListener(eventType, handler);
}

// Пример использования
const button = document.getElementById('myButton');
const removeListener = addSimpleEventListener(button, 'click', (event) => {
    console.log('Кнопка нажата');
});

// Для удаления слушателя
// removeListener();
```


### 2. Алгоритм делегирования событий

Эффективный способ обработки событий для множества элементов:

**Псевдокод:**
```
КЛАСС EventDelegator:
    КОНСТРУКТОР(контейнер):
        this.container = контейнер
        this.handlers = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ addHandler(селектор, тип_события, обработчик):
        ЕСЛИ !this.handlers.содержит(тип_события):
            this.handlers.установить(тип_события, новый Map())
        КОНЕЦ ЕСЛИ

        this.handlers.получить(тип_события).установить(селектор, обработчик)

        // Добавляем один слушатель для типа события
        ЕСЛИ this.handlers.получить(тип_события).размер === 1:
            this.container.addEventListener(тип_события, this.handleEvent.привязать(this))

    ФУНКЦИЯ handleEvent(событие):
        тип_события = событие.type
        обработчики = this.handlers.получить(тип_события)

        ЕСЛИ !обработчики:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        // Проходим по всем селекторам для этого типа события
        ДЛЯ каждой (селектор, обработчик) в обработчики:
            // Проверяем, соответствует ли целевой элемент селектору
            ЕСЛИ событие.target.совпадает(селектор):
                обработчик(событие)
                ПРЕРВАТЬ // Останавливаемся на первом совпадении
            КОНЕЦ ЕСЛИ

            // Проверяем родительские элементы (всплытие)
            текущий = событие.target.parentElement
            ПОКА текущий И текущий ≠ this.container:
                ЕСЛИ текущий.совпадает(селектор):
                    обработчик(событие, текущий)
                    ВОЗВРАТ
                КОНЕЦ ЕСЛИ
                текущий = текущий.parentElement
            КОНЕЦ ПОКА
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class EventDelegator {
    constructor(container) {
        this.container = container;
        this.handlers = new Map();
    }

    addHandler(selector, eventType, handler) {
        if (!this.handlers.has(eventType)) {
            this.handlers.set(eventType, new Map());
        }

        this.handlers.get(eventType).set(selector, handler);

        // Добавляем один слушатель для типа события
        if (this.handlers.get(eventType).size === 1) {
            this.container.addEventListener(eventType, this.handleEvent.bind(this));
        }
    }

    handleEvent(event) {
        const eventType = event.type;
        const handlers = this.handlers.get(eventType);

        if (!handlers) return;

        // Проходим по всем селекторам для этого типа события
        for (const [selector, handler] of handlers) {
            // Проверяем, соответствует ли целевой элемент селектору
            if (event.target.matches(selector)) {
                handler(event);
                break; // Останавливаемся на первом совпадении
            }

            // Проверяем родительские элементы (всплытие)
            let current = event.target.parentElement;
            while (current && current !== this.container) {
                if (current.matches(selector)) {
                    handler(event, current);
                    return;
                }
                current = current.parentElement;
            }
        }
    }
}

// Пример использования
const container = document.getElementById('list-container');
const delegator = new EventDelegator(container);

delegator.addHandler('.delete-btn', 'click', (event) => {
    event.target.closest('li').remove();
});

delegator.addHandler('.edit-btn', 'click', (event) => {
    const item = event.target.closest('li');
    // Логика редактирования
});
```

### 3. Алгоритм дебаунсинга событий

Для ограничения частоты вызова обработчиков:

**Псевдокод:**
```
ФУНКЦИЯ debounce(функция, задержка):
    таймер_ид = НЕОПРЕДЕЛЕНО
    ВОЗВРАТ ФУНКЦИЯ(...аргументы):
        очиститьТаймаут(таймер_ид)
        таймер_ид = установитьТаймаут(() -> функция.применить(ЭТО, аргументы), задержка)

// Пример использования для обработки ввода
дебаунсированный_поиск = debounce((событие) -> {
    выполнитьПоиск(событие.target.value)
}, 300)

получитьЭлемент('searchInput').addEventListener('input', дебаунсированный_поиск)
```

```javascript
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Пример использования для обработки ввода
const debouncedSearch = debounce((event) => {
    performSearch(event.target.value);
}, 300);

document.getElementById('searchInput').addEventListener('input', debouncedSearch);
```

### 4. Алгоритм троттлинга событий

Для ограничения частоты вызова с фиксированным интервалом:

**Псевдокод:**
```
ФУНКЦИЯ throttle(функция, лимит):
    в_ограничении = ЛОЖЬ
    ВОЗВРАТ ФУНКЦИЯ(...аргументы):
        ЕСЛИ !в_ограничении:
            функция.применить(ЭТО, аргументы)
            в_ограничении = ИСТИНА
            установитьТаймаут(() -> в_ограничении = ЛОЖЬ, лимит)

// Пример использования для обработки скролла
троттлированный_обработчик_скролла = throttle(() -> {
    вывести('Прокрутка страницы')
}, 100)

window.addEventListener('scroll', троттлированный_обработчик_скролла)
```

```javascript
function throttle(func, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Пример использования для обработки скролла
const throttledScrollHandler = throttle(() => {
    console.log('Прокрутка страницы');
}, 100);

window.addEventListener('scroll', throttledScrollHandler);
```

## Продвинутые алгоритмы обработки событий

### 1. Алгоритм мультиплексора событий

Для обработки нескольких событий одновременно:

**Псевдокод:**
```
КЛАСС EventMultiplexer:
    КОНСТРУКТОР():
        this.eventQueues = новый Map()
        this.processors = новый Map()
        this.batchSize = 10
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ subscribe(тип_события, процессор):
        ЕСЛИ !this.eventQueues.содержит(тип_события):
            this.eventQueues.установить(тип_события, [])
        КОНЕЦ ЕСЛИ

        ЕСЛИ !this.processors.содержит(тип_события):
            this.processors.установить(тип_события, [])
        КОНЕЦ ЕСЛИ

        this.processors.получить(тип_события).добавить(процессор)

    ФУНКЦИЯ emit(тип_события, eventData):
        ЕСЛИ !this.eventQueues.содержит(тип_события):
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        очередь = this.eventQueues.получить(тип_события)
        очередь.добавить(eventData)

        // Обработка пакета, если достигли размера
        ЕСЛИ длина(очередь) >= this.batchSize:
            processBatch(тип_события)
        ИНАЧЕ:
            // Или обработка с задержкой
            установитьТаймаут(() -> processBatch(тип_события), 10)
        КОНЕЦ ЕСЛИ

    ФУНКЦИЯ processBatch(тип_события):
        очередь = this.eventQueues.получить(тип_события)
        процессоры = this.processors.получить(тип_события)

        ЕСЛИ длина(очередь) === 0:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        пакет = очередь.взять(0, this.batchSize)

        процессоры.каждый(процессор -> {
            ПОПЫТКА:
                процессор(пакет)
            ИСКЛЮЧЕНИЕ (ошибка):
                вывести_ошибку('Ошибка обработки события:', ошибка)
        })
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class EventMultiplexer {
    constructor() {
        this.eventQueues = new Map();
        this.processors = new Map();
        this.batchSize = 10;
    }

    subscribe(eventType, processor) {
        if (!this.eventQueues.has(eventType)) {
            this.eventQueues.set(eventType, []);
        }

        if (!this.processors.has(eventType)) {
            this.processors.set(eventType, []);
        }

        this.processors.get(eventType).push(processor);
    }

    emit(eventType, eventData) {
        if (!this.eventQueues.has(eventType)) {
            return;
        }

        const queue = this.eventQueues.get(eventType);
        queue.push(eventData);

        // Обработка пакета, если достигли размера
        if (queue.length >= this.batchSize) {
            this.processBatch(eventType);
        } else {
            // Или обработка с задержкой
            setTimeout(() => this.processBatch(eventType), 10);
        }
    }

    processBatch(eventType) {
        const queue = this.eventQueues.get(eventType);
        const processors = this.processors.get(eventType);

        if (queue.length === 0) return;

        const batch = queue.splice(0, this.batchSize);

        processors.forEach(processor => {
            try {
                processor(batch);
            } catch (error) {
                console.error('Ошибка обработки события:', error);
            }
        });
    }
}

// Пример использования
const multiplexer = new EventMultiplexer();

multiplexer.subscribe('user-action', (batch) => {
    // Отправка пакета действий на сервер
    sendAnalytics(batch);
});

// Генерация событий
multiplexer.emit('user-action', { type: 'click', element: 'button1' });
multiplexer.emit('user-action', { type: 'hover', element: 'menu-item' });
```

### 2. Алгоритм приоритезации событий

Для обработки событий с разными уровнями приоритета:

**Псевдокод:**
```
КЛАСС PriorityEventProcessor:
    КОНСТРУКТОР():
        this.queues = {
            high: [],
            medium: [],
            low: []
        }
        this.processing = ЛОЖЬ
        this.processInterval = 16 // ~60fps
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ addEvent(приоритет, eventHandler, ...аргументы):
        this.queues[приоритет].добавить({ handler: eventHandler, args: аргументы })

        ЕСЛИ !this.processing:
            this.startProcessing()
        КОНЕЦ ЕСЛИ

    ФУНКЦИЯ startProcessing():
        this.processing = ИСТИНА
        this.processEvents()

    ФУНКЦИЯ processEvents():
        // Обработка событий по приоритетам
        приоритеты = ['high', 'medium', 'low']

        ДЛЯ каждого приоритета в приоритеты:
            ЕСЛИ длина(this.queues[приоритет]) > 0:
                событие = this.queues[приоритет].сдвиг()
                ПОПЫТКА:
                    событие.handler(...событие.args)
                ИСКЛЮЧЕНИЕ (ошибка):
                    вывести_ошибку('Ошибка обработки события:', ошибка)
                ПРЕРВАТЬ // Обрабатываем только одно событие за цикл
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        // Продолжаем обработку, если есть события
        ЕСЛИ hasEvents():
            установитьТаймаут(() -> processEvents(), this.processInterval)
        ИНАЧЕ:
            this.processing = ЛОЖЬ
        КОНЕЦ ЕСЛИ

    ФУНКЦИЯ hasEvents():
        ВОЗВРАТ значения(this.queues).некоторые(очередь -> длина(очередь) > 0)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class PriorityEventProcessor {
    constructor() {
        this.queues = {
            high: [],
            medium: [],
            low: []
        };
        this.processing = false;
        this.processInterval = 16; // ~60fps
    }

    addEvent(priority, eventHandler, ...args) {
        this.queues[priority].push({ handler: eventHandler, args });

        if (!this.processing) {
            this.startProcessing();
        }
    }

    startProcessing() {
        this.processing = true;
        this.processEvents();
    }

    processEvents() {
        // Обработка событий по приоритетам
        const priorities = ['high', 'medium', 'low'];

        for (const priority of priorities) {
            if (this.queues[priority].length > 0) {
                const event = this.queues[priority].shift();
                try {
                    event.handler(...event.args);
                } catch (error) {
                    console.error('Ошибка обработки события:', error);
                }
                break; // Обрабатываем только одно событие за цикл
            }
        }

        // Продолжаем обработку, если есть события
        if (this.hasEvents()) {
            setTimeout(() => this.processEvents(), this.processInterval);
        } else {
            this.processing = false;
        }
    }

    hasEvents() {
        return Object.values(this.queues).some(queue => queue.length > 0);
    }
}

// Пример использования
const processor = new PriorityEventProcessor();

// Высокий приоритет - UI обновления
processor.addEvent('high', (data) => {
    updateUI(data);
}, { element: 'status', value: 'loading' });

// Средний приоритет - логика приложения
processor.addEvent('medium', (data) => {
    processBusinessLogic(data);
}, { action: 'save', item: 'document' });

// Низкий приоритет - аналитика
processor.addEvent('low', (data) => {
    sendAnalytics(data);
}, { action: 'view', page: 'dashboard' });
```

### 3. Алгоритм фильтрации и преобразования событий

Для обработки событий с предварительной обработкой:

**Псевдокод:**
```
КЛАСС EventTransformer:
    КОНСТРУКТОР():
        this.filters = []
        this.transformers = []
        this.handlers = []
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ addFilter(фильтрFn):
        this.filters.добавить(фильтрFn)
        ВОЗВРАТ this

    ФУНКЦИЯ addTransformer(трансформерFn):
        this.transformers.добавить(трансформерFn)
        ВОЗВРАТ this

    ФУНКЦИЯ addHandler(обработчикFn):
        this.handlers.добавить(обработчикFn)
        ВОЗВРАТ this

    ФУНКЦИЯ process(событие):
        // Применение фильтров
        ДЛЯ каждого фильтра в this.filters:
            ЕСЛИ !фильтр(событие):
                ВОЗВРАТ // Событие отфильтровано
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        // Применение трансформеров
        обработанное_событие = копировать(событие)
        ДЛЯ каждого трансформера в this.transformers:
            обработанное_событие = объединить(обработанное_событие, трансформер(обработанное_событие))

        // Вызов обработчиков
        ДЛЯ каждого обработчика в this.handlers:
            обработчик(обработанное_событие)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class EventTransformer {
    constructor() {
        this.filters = [];
        this.transformers = [];
        this.handlers = [];
    }

    addFilter(filterFn) {
        this.filters.push(filterFn);
        return this;
    }

    addTransformer(transformerFn) {
        this.transformers.push(transformerFn);
        return this;
    }

    addHandler(handlerFn) {
        this.handlers.push(handlerFn);
        return this;
    }

    process(event) {
        // Применение фильтров
        for (const filter of this.filters) {
            if (!filter(event)) {
                return; // Событие отфильтровано
            }
        }

        // Применение трансформеров
        let processedEvent = { ...event };
        for (const transformer of this.transformers) {
            processedEvent = { ...processedEvent, ...transformer(processedEvent) };
        }

        // Вызов обработчиков
        for (const handler of this.handlers) {
            handler(processedEvent);
        }
    }
}

// Пример использования
const mouseTracker = new EventTransformer()
    .addFilter(event => event.type === 'mousemove') // Фильтр по типу события
    .addTransformer(event => ({
        x: Math.round(event.clientX / 10) * 10, // Округление до 10 пикселей
        y: Math.round(event.clientY / 10) * 10,
        timestamp: Date.now()
    }))
    .addHandler(processedEvent => {
        // Отправка уменьшенного количества данных
        sendCoordinates(processedEvent);
    });

document.addEventListener('mousemove', (e) => mouseTracker.process(e));
```

## Алгоритмы обработки сложных взаимодействий

### 1. Алгоритм распознавания жестов

Для обработки сенсорных взаимодействий:

**Псевдокод:**
```
КЛАСС GestureRecognizer:
    КОНСТРУКТОР(элемент):
        this.element = элемент
        this.touches = новый Map()
        this.gestureStartPoints = новый Map()
        this.callbacks = новый Map()

        setupEventListeners()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ setupEventListeners():
        this.element.addEventListener('touchstart', handleTouchStart.привязать(this))
        this.element.addEventListener('touchmove', handleTouchMove.привязать(this))
        this.element.addEventListener('touchend', handleTouchEnd.привязать(this))

    ФУНКЦИЯ handleTouchStart(событие):
        ДЛЯ каждого прикосновения в событие.changedTouches:
            this.touches.установить(прикосновение.identifier, {
                startX: прикосновение.clientX,
                startY: прикосновение.clientY,
                startTime: текущее_время()
            })

            this.gestureStartPoints.установить(прикосновение.identifier, {
                x: прикосновение.clientX,
                y: прикосновение.clientY
            })
        КОНЕЦ ДЛЯ

    ФУНКЦИЯ handleTouchMove(событие):
        ДЛЯ каждого прикосновения в событие.changedTouches:
            ЕСЛИ this.touches.содержит(прикосновение.identifier):
                начальная_инфо = this.touches.получить(прикосновение.identifier)
                deltaX = прикосновение.clientX - начальная_инфо.startX
                deltaY = прикосновение.clientY - начальная_инфо.startY
                расстояние = sqrt(deltaX * deltaX + deltaY * deltaY)

                // Проверка на свайп
                ЕСЛИ расстояние > 30: // Минимальное расстояние для свайпа
                    угол = atan2(deltaY, deltaX) * 180 / π

                    направление = ''
                    ЕСЛИ угол >= -45 И угол < 45:
                        направление = 'right'
                    ЕСЛИ угол >= 45 И угол < 135:
                        направление = 'down'
                    ЕСЛИ угол >= 135 ИЛИ угол < -135:
                        направление = 'left'
                    ЕСЛИ угол >= -135 И угол < -45:
                        направление = 'up'

                    triggerGesture('swipe', { направление, расстояние, прикосновение })
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

    ФУНКЦИЯ handleTouchEnd(событие):
        ДЛЯ каждого прикосновения в событие.changedTouches:
            ЕСЛИ this.touches.содержит(прикосновение.identifier):
                начальная_инфо = this.touches.получить(прикосновение.identifier)
                длительность = текущее_время() - начальная_инфо.startTime

                // Проверка на клик (короткое нажатие)
                ЕСЛИ длительность < 200:
                    triggerGesture('tap', { прикосновение })
                КОНЕЦ ЕСЛИ

                this.touches.удалить(прикосновение.identifier)
                this.gestureStartPoints.удалить(прикосновение.identifier)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

    ФУНКЦИЯ triggerGesture(тип_жеста, данные):
        ЕСЛИ this.callbacks.содержит(тип_жеста):
            this.callbacks.получить(тип_жеста)(данные)
        КОНЕЦ ЕСЛИ

    ФУНКЦИЯ on(тип_жеста, callback):
        this.callbacks.установить(тип_жеста, callback)
КОНЕЦ КЛАССА
```

```javascript
class GestureRecognizer {
    constructor(element) {
        this.element = element;
        this.touches = new Map();
        this.gestureStartPoints = new Map();
        this.callbacks = new Map();

        this.setupEventListeners();
    }

    setupEventListeners() {
        this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
    }

    handleTouchStart(event) {
        for (const touch of event.changedTouches) {
            this.touches.set(touch.identifier, {
                startX: touch.clientX,
                startY: touch.clientY,
                startTime: Date.now()
            });

            this.gestureStartPoints.set(touch.identifier, {
                x: touch.clientX,
                y: touch.clientY
            });
        }
    }

    handleTouchMove(event) {
        for (const touch of event.changedTouches) {
            if (this.touches.has(touch.identifier)) {
                const startInfo = this.touches.get(touch.identifier);
                const deltaX = touch.clientX - startInfo.startX;
                const deltaY = touch.clientY - startInfo.startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Проверка на свайп
                if (distance > 30) { // Минимальное расстояние для свайпа
                    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

                    let direction = '';
                    if (angle >= -45 && angle < 45) direction = 'right';
                    if (angle >= 45 && angle < 135) direction = 'down';
                    if (angle >= 135 || angle < -135) direction = 'left';
                    if (angle >= -135 && angle < -45) direction = 'up';

                    this.triggerGesture('swipe', { direction, distance, touch });
                }
            }
        }
    }

    handleTouchEnd(event) {
        for (const touch of event.changedTouches) {
            if (this.touches.has(touch.identifier)) {
                const startInfo = this.touches.get(touch.identifier);
                const duration = Date.now() - startInfo.startTime;

                // Проверка на клик (короткое нажатие)
                if (duration < 200) {
                    this.triggerGesture('tap', { touch });
                }

                this.touches.delete(touch.identifier);
                this.gestureStartPoints.delete(touch.identifier);
            }
        }
    }

    triggerGesture(gestureType, data) {
        if (this.callbacks.has(gestureType)) {
            this.callbacks.get(gestureType)(data);
        }
    }

    on(gestureType, callback) {
        this.callbacks.set(gestureType, callback);
    }
}

// Пример использования
const recognizer = new GestureRecognizer(document.getElementById('touch-area'));

recognizer.on('swipe', (data) => {
    console.log(`Свайп в направлении: ${data.direction}`);
});

recognizer.on('tap', (data) => {
    console.log('Касание экрана');
});
```

### 2. Алгоритм обработки клавиатурных комбинаций

Для обработки сочетаний клавиш:

**Псевдокод:**
```
КЛАСС KeyboardShortcutManager:
    КОНСТРУКТОР():
        this.shortcuts = новый Map()
        this.activeKeys = новый Set()

        document.addEventListener('keydown', handleKeyDown.привязать(this))
        document.addEventListener('keyup', handleKeyUp.привязать(this))
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ registerShortcut(клавиши, callback, опции = {}):
        нормализованные_клавиши = normalizeKeys(клавиши)
        комбинация = {
            keys: нормализованные_клавиши,
            callback,
            preventDefault: опции.preventDefault ≠ ЛОЖЬ,
            element: опции.element ИЛИ document
        }

        this.shortcuts.установить(нормализованные_клавиши.соединить('+'), комбинация)

    ФУНКЦИЯ normalizeKeys(клавиши):
        ЕСЛИ тип клавиши === 'строка':
            ВОЗВРАТ клавиши.в_нижнем_регистре().разделить('+').карта(k -> k.обрезать())
        КОНЕЦ ЕСЛИ
        ВОЗВРАТ клавиши.карта(k -> k.в_нижнем_регистре())

    ФУНКЦИЯ handleKeyDown(событие):
        клавиша = событие.key.в_нижнем_регистре()
        this.activeKeys.добавить(клавиша)

        // Проверяем все зарегистрированные комбинации
        ДЛЯ каждой (ключ_комбинации, комбинация) в this.shortcuts:
            ЕСЛИ matchesShortcut(комбинация, this.activeKeys):
                ЕСЛИ комбинация.preventDefault:
                    событие.preventDefault()
                КОНЕЦ ЕСЛИ

                комбинация.callback(событие)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

    ФУНКЦИЯ handleKeyUp(событие):
        this.activeKeys.удалить(событие.key.в_нижнем_регистре())

    ФУНКЦИЯ matchesShortcut(комбинация, activeKeys):
        // Проверяем, что все клавиши комбинации нажаты
        ВОЗВРАТ комбинация.keys.все(клавиша -> activeKeys.содержит(клавиша)) И
               activeKeys.размер === длина(комбинация.keys)

    ФУНКЦИЯ unregisterShortcut(клавиши):
        нормализованные_клавиши = normalizeKeys(клавиши).соединить('+')
        this.shortcuts.удалить(нормализованные_клавиши)
КОНЕЦ КЛАССА
```

```javascript
class KeyboardShortcutManager {
    constructor() {
        this.shortcuts = new Map();
        this.activeKeys = new Set();

        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    }

    registerShortcut(keys, callback, options = {}) {
        const normalizedKeys = this.normalizeKeys(keys);
        const shortcut = {
            keys: normalizedKeys,
            callback,
            preventDefault: options.preventDefault !== false,
            element: options.element || document
        };

        this.shortcuts.set(normalizedKeys.join('+'), shortcut);
    }

    normalizeKeys(keys) {
        if (typeof keys === 'string') {
            return keys.toLowerCase().split('+').map(k => k.trim());
        }
        return keys.map(k => k.toLowerCase());
    }

    handleKeyDown(event) {
        const key = event.key.toLowerCase();
        this.activeKeys.add(key);

        // Проверяем все зарегистрированные комбинации
        for (const [shortcutKey, shortcut] of this.shortcuts) {
            if (this.matchesShortcut(shortcut, this.activeKeys)) {
                if (shortcut.preventDefault) {
                    event.preventDefault();
                }

                shortcut.callback(event);
            }
        }
    }

    handleKeyUp(event) {
        this.activeKeys.delete(event.key.toLowerCase());
    }

    matchesShortcut(shortcut, activeKeys) {
        // Проверяем, что все клавиши комбинации нажаты
        return shortcut.keys.every(key => activeKeys.has(key)) &&
               activeKeys.size === shortcut.keys.length;
    }

    unregisterShortcut(keys) {
        const normalizedKeys = this.normalizeKeys(keys).join('+');
        this.shortcuts.delete(normalizedKeys);
    }
}

// Пример использования
const shortcutManager = new KeyboardShortcutManager();

shortcutManager.registerShortcut('ctrl+s', (event) => {
    console.log('Сохранение документа');
    // Логика сохранения
});

shortcutManager.registerShortcut('ctrl+z', (event) => {
    console.log('Отмена действия');
    // Логика отмены
});

shortcutManager.registerShortcut(['ctrl', 'shift', 'i'], (event) => {
    console.log('Открытие инструментов разработчика');
    // Логика открытия devtools
});
```

## Современные подходы в 2025 году

### 1. Алгоритм обработки событий с веб-воркерами

Для обработки тяжелых вычислений вне основного потока:

**Псевдокод:**
```
// main-thread.js
КЛАСС WorkerEventProcessor:
    КОНСТРУКТОР(workerScript):
        this.worker = новый Worker(workerScript)
        this.eventQueue = []
        this.isProcessing = ЛОЖЬ
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ processEvent(eventData):
        this.eventQueue.добавить(eventData)

        ЕСЛИ !this.isProcessing:
            processQueue()
        КОНЕЦ ЕСЛИ

    АСИНХРОННАЯ ФУНКЦИЯ processQueue():
        this.isProcessing = ИСТИНА

        ПОКА длина(this.eventQueue) > 0:
            событие = this.eventQueue.сдвиг()

            // Отправляем событие в воркер
            this.worker.postMessage({
                type: 'process',
                data: событие
            })

            // Ждем результата
            результат = ЖДАТЬ waitForWorkerResult()

            // Обрабатываем результат в основном потоке
            handleWorkerResult(результат)

        this.isProcessing = ЛОЖЬ

    ФУНКЦИЯ waitForWorkerResult():
        ВОЗВРАТ НОВОЕ_ОБЕЩАНИЕ((разрешить) -> {
            this.worker.onmessage = (e) -> разрешить(e.data)
        })

    ФУНКЦИЯ handleWorkerResult(результат):
        // Обработка результата в основном потоке
        ЕСЛИ результат.type === 'update-dom':
            updateDOM(результат.payload)

    ФУНКЦИЯ updateDOM(данные):
        // Безопасное обновление DOM
        элемент = получитьЭлемент(данные.id)
        ЕСЛИ элемент:
            элемент.textContent = данные.value

// worker.js
self.onmessage = ФУНКЦИЯ(e):
    { type, data } = e.data

    ЕСЛИ type === 'process':
        // Выполнение тяжелых вычислений
        результат = performHeavyComputation(data)

        // Отправка результата обратно
        self.postMessage({
            type: 'processed',
            payload: результат
        })

ФУНКЦИЯ performHeavyComputation(данные):
    // Сложные вычисления, не блокирующие основной поток
    результат = 0
    ДЛЯ i ОТ 0 ДО 999999:
        результат += sqrt(i) * данные.factor

    ВОЗВРАТ {
        id: данные.id,
        value: результат
    }
```

```javascript
// main-thread.js
class WorkerEventProcessor {
    constructor(workerScript) {
        this.worker = new Worker(workerScript);
        this.eventQueue = [];
        this.isProcessing = false;
    }

    processEvent(eventData) {
        this.eventQueue.push(eventData);

        if (!this.isProcessing) {
            this.processQueue();
        }
    }

    async processQueue() {
        this.isProcessing = true;

        while (this.eventQueue.length > 0) {
            const event = this.eventQueue.shift();

            // Отправляем событие в воркер
            this.worker.postMessage({
                type: 'process',
                data: event
            });

            // Ждем результата
            const result = await this.waitForWorkerResult();

            // Обрабатываем результат в основном потоке
            this.handleWorkerResult(result);
        }

        this.isProcessing = false;
    }

    waitForWorkerResult() {
        return new Promise((resolve) => {
            this.worker.onmessage = (e) => resolve(e.data);
        });
    }

    handleWorkerResult(result) {
        // Обработка результата в основном потоке
        if (result.type === 'update-dom') {
            this.updateDOM(result.payload);
        }
    }

    updateDOM(data) {
        // Безопасное обновление DOM
        const element = document.getElementById(data.id);
        if (element) {
            element.textContent = data.value;
        }
    }
}

// worker.js
self.onmessage = function(e) {
    const { type, data } = e.data;

    if (type === 'process') {
        // Выполнение тяжелых вычислений
        const result = performHeavyComputation(data);

        // Отправка результата обратно
        self.postMessage({
            type: 'processed',
            payload: result
        });
    }
};

function performHeavyComputation(data) {
    // Сложные вычисления, не блокирующие основной поток
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
        result += Math.sqrt(i) * data.factor;
    }

    return {
        id: data.id,
        value: result
    };
}
```

### 2. Алгоритм предсказательной обработки событий

С использованием машинного обучения для предсказания действий пользователя:

**Псевдокод:**
```
КЛАСС PredictiveEventHandler:
    КОНСТРУКТОР():
        this.eventHistory = []
        this.predictedActions = новый Map()
        this.learningRate = 0.1
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ recordEvent(событие):
        this.eventHistory.добавить({
            событие,
            timestamp: текущее_время()
        })

        // Ограничиваем историю до последних 100 событий
        ЕСЛИ длина(this.eventHistory) > 100:
            this.eventHistory.сдвиг()
        КОНЕЦ ЕСЛИ

        // Обновляем предсказания на основе новой информации
        updatePredictions(событие)

    ФУНКЦИЯ updatePredictions(текущее_событие):
        // Простой алгоритм: если пользователь часто выполняет
        // последовательность событий A -> B, то при событии A
        // предсказываем вероятность события B

        последние_события = this.eventHistory.взять(-10)
        последовательность_событий = карта(последние_события, e -> e.event.type)

        // Поиск паттернов в последовательности событий
        ДЛЯ i ОТ 0 ДО длина(последовательность_событий) - 1:
            текущий = последовательность_событий[i]
            следующий = последовательность_событий[i + 1]

            ЕСЛИ !this.predictedActions.содержит(текущий):
                this.predictedActions.установить(текущий, новый Map())
            КОНЕЦ ЕСЛИ

            следующие_события = this.predictedActions.получить(текущий)
            текущее_количество = следующие_события.получить(следующий) ИЛИ 0
            следующие_события.установить(следующий, текущее_количество + this.learningRate)

    АСИНХРОННАЯ ФУНКЦИЯ handleEvent(событие):
        // Записываем событие в историю
        recordEvent(событие)

        // Получаем предсказание
        прогноз = predictNextAction(событие)

        ЕСЛИ прогноз И прогноз.confidence > 0.7:
            // Подготавливаем ресурсы для предсказанного действия
            ЖДАТЬ preloadForAction(прогноз.action)

        // Обычная обработка события
        ВОЗВРАТ processEvent(событие)

    АСИНХРОННАЯ ФУНКЦИЯ preloadForAction(действие):
        // Предзагрузка ресурсов для предсказанного действия
        вывести(`Предзагрузка для действия: ${действие}`)

        ВЫБОР:
            СЛУЧАЙ 'click':
                // Предзагрузка изображений или данных
            СЛУЧАЙ 'scroll':
                // Подготовка к виртуальному скроллингу
            СЛУЧАЙ 'input':
                // Загрузка данных для автодополнения

    ФУНКЦИЯ processEvent(событие):
        // Стандартная обработка события
        вывести(`Обработка события: ${событие.type}`)
        ВОЗВРАТ ИСТИНА
КОНЕЦ КЛАССА
```

```javascript
class PredictiveEventHandler {
    constructor() {
        this.eventHistory = [];
        this.predictedActions = new Map();
        this.learningRate = 0.1;
    }

    recordEvent(event) {
        this.eventHistory.push({
            event,
            timestamp: Date.now()
        });

        // Ограничиваем историю до последних 100 событий
        if (this.eventHistory.length > 100) {
            this.eventHistory.shift();
        }

        // Обновляем предсказания на основе новой информации
        this.updatePredictions(event);
    }

    updatePredictions(currentEvent) {
        // Простой алгоритм: если пользователь часто выполняет
        // последовательность событий A -> B, то при событии A
        // предсказываем вероятность события B

        const recentEvents = this.eventHistory.slice(-10);
        const eventSequence = recentEvents.map(e => e.event.type);

        // Поиск паттернов в последовательности событий
        for (let i = 0; i < eventSequence.length - 1; i++) {
            const current = eventSequence[i];
            const next = eventSequence[i + 1];

            if (!this.predictedActions.has(current)) {
                this.predictedActions.set(current, new Map());
            }

            const nextEvents = this.predictedActions.get(current);
            const currentCount = nextEvents.get(next) || 0;
            nextEvents.set(next, currentCount + this.learningRate);
        }
    }

    predictNextAction(currentEvent) {
        const nextEvents = this.predictedActions.get(currentEvent.type);

        if (!nextEvents) return null;

        // Находим наиболее вероятное следующее действие
        let predictedAction = null;
        let maxProbability = 0;

        for (const [action, probability] of nextEvents) {
            if (probability > maxProbability) {
                maxProbability = probability;
                predictedAction = action;
            }
        }

        return {
            action: predictedAction,
            confidence: maxProbability > 0.5 ? maxProbability : 0
        };
    }

    async handleEvent(event) {
        // Записываем событие в историю
        this.recordEvent(event);

        // Получаем предсказание
        const prediction = this.predictNextAction(event);

        if (prediction && prediction.confidence > 0.7) {
            // Подготавливаем ресурсы для предсказанного действия
            await this.preloadForAction(prediction.action);
        }

        // Обычная обработка события
        return this.processEvent(event);
    }

    async preloadForAction(action) {
        // Предзагрузка ресурсов для предсказанного действия
        console.log(`Предзагрузка для действия: ${action}`);

        switch (action) {
            case 'click':
                // Предзагрузка изображений или данных
                break;
            case 'scroll':
                // Подготовка к виртуальному скроллингу
                break;
            case 'input':
                // Загрузка данных для автодополнения
                break;
        }
    }

    processEvent(event) {
        // Стандартная обработка события
        console.log(`Обработка события: ${event.type}`);
        return true;
    }
}
```

### 3. Алгоритм адаптивной обработки событий

С учетом производительности устройства и состояния системы:

**Псевдокод:**
```
КЛАСС AdaptiveEventHandler:
    КОНСТРУКТОР():
        this.performanceLevel = estimatePerformanceLevel()
        this.eventHandlers = новый Map()
        this.throttleConfig = getThrottleConfig()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ estimatePerformanceLevel():
        // Оценка производительности на основе доступных API
        инфо = {
            memory: НЕОПРЕДЕЛЕНО,
            hardwareConcurrency: navigator.hardwareConcurrency ИЛИ 4,
            userAgent: navigator.userAgent
        }

        ПОПЫТКА:
            // Проверка доступности Performance API
            ЕСЛИ performance.memory:
                инфо.memory = performance.memory
        ИСКЛЮЧЕНИЕ (e):
            // Performance API может быть недоступен в некоторых браузерах
        КОНЕЦ ПОПЫТКИ

        // Оценка уровня производительности
        ЕСЛИ инфо.memory И инфо.memory.totalJSHeapSize:
            usageRatio = инфо.memory.usedJSHeapSize / инфо.memory.totalJSHeapSize
            ЕСЛИ usageRatio > 0.8:
                ВОЗВРАТ 'low'
        КОНЕЦ ЕСЛИ

        ЕСЛИ инфо.hardwareConcurrency < 4:
            ВОЗВРАТ 'low'

        // Проверка на мобильные устройства
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.проверить(инфо.userAgent)
        ЕСЛИ isMobile:
            ВОЗВРАТ 'medium'

        ВОЗВРАТ 'high'

    ФУНКЦИЯ getThrottleConfig():
        // Конфигурация в зависимости от производительности
        ВОЗВРАТ ВЫБОР:
            СЛУЧАЙ 'low':
                {
                    scroll: 200,    // Меньше обработчиков для скролла
                    resize: 300,    // Меньше обработчиков для ресайза
                    input: 500      // Меньше обработчиков для ввода
                }
            СЛУЧАЙ 'medium':
                {
                    scroll: 100,
                    resize: 150,
                    input: 200
                }
            ИНАЧЕ: // high
                {
                    scroll: 16,     // ~60fps
                    resize: 16,
                    input: 16
                }

    ФУНКЦИЯ addHandler(тип_события, обработчик, элемент = window):
        обработчик_для_использования = обработчик

        // Применяем троттлинг в зависимости от типа события и производительности
        ЕСЛИ this.throttleConfig[тип_события]:
            обработчик_для_использования = throttle(обработчик, this.throttleConfig[тип_события])

        элемент.addEventListener(тип_события, обработчик_для_использования)

        // Сохраняем обработчики для возможного освобождения
        ЕСЛИ !this.eventHandlers.содержит(элемент):
            this.eventHandlers.установить(элемент, новый Map())
        КОНЕЦ ЕСЛИ

        элемент_обработчики = this.eventHandlers.получить(элемент)
        ЕСЛИ !элемент_обработчики.содержит(тип_события):
            элемент_обработчики.установить(тип_события, [])
        КОНЕЦ ЕСЛИ

        элемент_обработчики.получить(тип_события).добавить(обработчик_для_использования)
КОНЕЦ КЛАССА
```

```javascript
class AdaptiveEventHandler {
    constructor() {
        this.performanceLevel = this.estimatePerformanceLevel();
        this.eventHandlers = new Map();
        this.throttleConfig = this.getThrottleConfig();
    }

    estimatePerformanceLevel() {
        // Оценка производительности на основе доступных API
        const info = {
            memory: null,
            hardwareConcurrency: navigator.hardwareConcurrency || 4,
            userAgent: navigator.userAgent
        };

        try {
            // Проверка доступности Performance API
            if (performance.memory) {
                info.memory = performance.memory;
            }
        } catch (e) {
            // Performance API может быть недоступен в некоторых браузерах
        }

        // Оценка уровня производительности
        if (info.memory && info.memory.totalJSHeapSize) {
            const usageRatio = info.memory.usedJSHeapSize / info.memory.totalJSHeapSize;
            if (usageRatio > 0.8) return 'low';
        }

        if (info.hardwareConcurrency < 4) return 'low';

        // Проверка на мобильные устройства
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(info.userAgent);
        if (isMobile) return 'medium';

        return 'high';
    }

    getThrottleConfig() {
        // Конфигурация в зависимости от производительности
        switch (this.performanceLevel) {
            case 'low':
                return {
                    scroll: 200,    // Меньше обработчиков для скролла
                    resize: 300,    // Меньше обработчиков для ресайза
                    input: 500      // Меньше обработчиков для ввода
                };
            case 'medium':
                return {
                    scroll: 100,
                    resize: 150,
                    input: 200
                };
            default: // high
                return {
                    scroll: 16,     // ~60fps
                    resize: 16,
                    input: 16
                };
        }
    }

    addHandler(eventType, handler, element = window) {
        let processedHandler = handler;

        // Применяем троттлинг в зависимости от типа события и производительности
        if (this.throttleConfig[eventType]) {
            processedHandler = throttle(handler, this.throttleConfig[eventType]);
        }

        element.addEventListener(eventType, processedHandler);

        // Сохраняем обработчики для возможного освобождения
        if (!this.eventHandlers.has(element)) {
            this.eventHandlers.set(element, new Map());
        }

        const elementHandlers = this.eventHandlers.get(element);
        if (!elementHandlers.has(eventType)) {
            elementHandlers.set(eventType, []);
        }

        elementHandlers.get(eventType).push(processedHandler);
    }

    // Метод для очистки обработчиков
    cleanup() {
        for (const [element, handlersMap] of this.eventHandlers) {
            for (const [eventType, handlers] of handlersMap) {
                for (const handler of handlers) {
                    element.removeEventListener(eventType, handler);
                }
            }
        }
        this.eventHandlers.clear();
    }
}
```

## Практические рекомендации

### 1. Оптимизация производительности

- Используйте делегирование событий для динамических элементов
- Применяйте дебаунсинг и троттлинг для частых событий
- Избегайте тяжелых вычислений в обработчиках событий
- Удаляйте обработчики событий при уничтожении компонентов

### 2. Безопасность обработки событий

- Всегда проверяйте и валидируйте данные из событий
- Используйте `preventDefault()` и `stopPropagation()` осознанно
- Экранируйте пользовательский ввод перед отображением

### 3. Обработка ошибок

**Псевдокод:**
```
КЛАСС SafeEventHandler:
    КОНСТРУКТОР(обработчик):
        this.handler = обработчик
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ handleEvent(событие):
        ПОПЫТКА:
            this.handler(событие)
        ИСКЛЮЧЕНИЕ (ошибка):
            вывести_ошибку('Ошибка в обработчике событий:', ошибка)
            // Логика восстановления или уведомления пользователя
```

```javascript
class SafeEventHandler {
    constructor(handler) {
        this.handler = handler;
    }

    handleEvent(event) {
        try {
            this.handler(event);
        } catch (error) {
            console.error('Ошибка в обработчике событий:', error);
            // Логика восстановления или уведомления пользователя
        }
    }
}
```

## Заключение

Алгоритмы обработки событий играют ключевую роль в создании интерактивных и отзывчивых веб-приложений. С ростом требований к производительности и пользовательскому опыту, разработчики должны использовать современные подходы к обработке событий, включая делегирование, оптимизацию производительности и предсказательную обработку.

## См. также

- [[Алгоритмы-для-валидации]]
- [[Алгоритмы-оптимизации-рендеринга]]
- [[Алгоритмы-анимаций]]
- [[Фреймворки-фронтенда]]

## Теги

#frontend #algorithms #events #javascript #performance #dom #event-handling #ux