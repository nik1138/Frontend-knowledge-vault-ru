---
aliases: [Table Sorting Algorithms, Сортировка в таблицах]
tags: [frontend, algorithms, sorting, tables, javascript, performance]
---

# Алгоритмы сортировки в таблицах

## Введение

Алгоритмы сортировки в таблицах являются важной частью современных веб-приложений, особенно в системах управления данными, аналитических панелях и приложениях электронной коммерции. Пользователи ожидают быстрой и интуитивной сортировки данных с возможностью множественных критериев и сохранения состояния. Эффективные алгоритмы сортировки обеспечивают положительный пользовательский опыт и высокую производительность.

## Основные понятия сортировки в таблицах

### Типы сортировки

1. **Одноколоночная сортировка** - сортировка по одному столбцу
2. **Многоколоночная сортировка** - сортировка по нескольким столбцам с приоритетами
3. **Сортировка с сохранением стабильности** - сохранение относительного порядка равных элементов

### Критерии эффективности

- Временная сложность алгоритма
- Пространственная сложность
- Стабильность сортировки
- Пользовательский опыт (время отклика)

## Базовые алгоритмы сортировки

### 1. Сортировка пузырьком (Bubble Sort)

Хотя и неэффективна для больших наборов данных, может использоваться для небольших таблиц:

**Псевдокод:**
```
ФУНКЦИЯ bubbleSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        n = длина(массив)
        копия_массива = копировать(массив)
        
        ДЛЯ i ОТ 0 ДО n - 2:
            ДЛЯ j ОТ 0 ДО n - i - 2:
                СРАВНЕНИЕ = ЕСЛИ по_возрастанию ТОГДА
                             копия_массива[j][ключ] > копия_массива[j + 1][ключ]
                           ИНАЧЕ
                             копия_массива[j][ключ] < копия_массива[j + 1][ключ]
                           КОНЕЦ ЕСЛИ
                
                ЕСЛИ СРАВНЕНИЕ:
                    ПОМЕНЯТЬ_МЕСТАМИ(копия_массива[j], копия_массива[j + 1])
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ
        
        ВОЗВРАТ копия_массива
    КОНЕЦ
```

**Псевдокод:**
```
ФУНКЦИЯ bubbleSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        n = длина(массив)
        копия_массива = копировать(массив)

        ДЛЯ i ОТ 0 ДО n - 2:
            ДЛЯ j ОТ 0 ДО n - i - 2:
                СРАВНЕНИЕ = ЕСЛИ по_возрастанию ТОГДА
                             копия_массива[j][ключ] > копия_массива[j + 1][ключ]
                           ИНАЧЕ
                             копия_массива[j][ключ] < копия_массива[j + 1][ключ]
                           КОНЕЦ ЕСЛИ

                ЕСЛИ СРАВНЕНИЕ:
                    ПОМЕНЯТЬ_МЕСТАМИ(копия_массива[j], копия_массива[j + 1])
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ копия_массива
    КОНЕЦ
```

```javascript
function bubbleSort(arr, key, ascending = true) {
    const n = arr.length;
    const result = [...arr]; // Создаем копию массива

    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            const comparison = ascending ?
                result[j][key] > result[j + 1][key] :
                result[j][key] < result[j + 1][key];

            if (comparison) {
                [result[j], result[j + 1]] = [result[j + 1], result[j]];
            }
        }
    }

    return result;
}
```


### 2. Сортировка вставками (Insertion Sort)

Хорошо работает с небольшими наборами данных и частично отсортированными массивами:

**Псевдокод:**
```
ФУНКЦИЯ insertionSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        результат = копировать(массив)
        
        ДЛЯ i ОТ 1 ДО длина(результат) - 1:
            текущий = результат[i]
            j = i - 1
            
            ПОКА j >= 0 И сравнитьЗначения(результат[j][ключ], текущий[ключ], по_возрастанию):
                результат[j + 1] = результат[j]
                j = j - 1
            КОНЕЦ ПОКА
            
            результат[j + 1] = текущий
        КОНЕЦ ДЛЯ
        
        ВОЗВРАТ результат
    КОНЕЦ
```

**Псевдокод:**
```
ФУНКЦИЯ insertionSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        результат = копировать(массив)

        ДЛЯ i ОТ 1 ДО длина(результат) - 1:
            текущий = результат[i]
            j = i - 1

            ПОКА j >= 0 И сравнитьЗначения(результат[j][ключ], текущий[ключ], по_возрастанию):
                результат[j + 1] = результат[j]
                j = j - 1
            КОНЕЦ ПОКА

            результат[j + 1] = текущий
        КОНЕЦ ДЛЯ

        ВОЗВРАТ результат
    КОНЕЦ
```

```javascript
function insertionSort(arr, key, ascending = true) {
    const result = [...arr];

    for (let i = 1; i < result.length; i++) {
        const current = result[i];
        let j = i - 1;

        while (j >= 0 && compareValues(result[j][key], current[key], ascending)) {
            result[j + 1] = result[j];
            j--;
        }

        result[j + 1] = current;
    }

    return result;
}

function compareValues(a, b, ascending) {
    // Обработка null и undefined
    if (a == null && b == null) return false;
    if (a == null) return !ascending;
    if (b == null) return ascending;

    // Сравнение строк и чисел
    const comparison = typeof a === 'string' || typeof b === 'string'
        ? String(a).localeCompare(String(b))
        : a - b;

    return ascending ? comparison > 0 : comparison < 0;
}
```


### 3. Быстрая сортировка (Quick Sort)

Более эффективный алгоритм для больших наборов данных:

**Псевдокод:**
```
ФУНКЦИЯ quickSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        ЕСЛИ длина(массив) <= 1:
            ВОЗВРАТ массив
        КОНЕЦ ЕСЛИ

        ОПОРНЫЙ = массив[floor(длина(массив) / 2)][ключ]
        равные = []
        меньше = []
        больше = []

        ДЛЯ каждого элемента в массив:
            СРАВНЕНИЕ = сравнитьЗначения(элемент[ключ], ОПОРНЫЙ, ИСТИНА)
            
            ЕСЛИ элемент[ключ] === ОПОРНЫЙ:
                равные.добавить(элемент)
            ИНАЧЕ ЕСЛИ СРАВНЕНИЕ < 0:
                меньше.добавить(элемент)
            ИНАЧЕ:
                больше.добавить(элемент)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        отсортированные_меньше = quickSort(меньше, ключ, по_возрастанию)
        отсортированные_больше = quickSort(больше, ключ, по_возрастанию)

        ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА
                 объединить(отсортированные_меньше, равные, отсортированные_больше)
               ИНАЧЕ
                 объединить(отсортированные_больше, равные, отсортированные_меньше)
               КОНЕЦ ЕСЛИ
    КОНЕЦ
```

**Псевдокод:**
```
ФУНКЦИЯ quickSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        ЕСЛИ длина(массив) <= 1:
            ВОЗВРАТ массив
        КОНЕЦ ЕСЛИ

        ОПОРНЫЙ = массив[floor(длина(массив) / 2)][ключ]
        равные = []
        меньше = []
        больше = []

        ДЛЯ каждого элемента в массив:
            СРАВНЕНИЕ = сравнитьЗначения(элемент[ключ], ОПОРНЫЙ, ИСТИНА)

            ЕСЛИ элемент[ключ] === ОПОРНЫЙ:
                равные.добавить(элемент)
            ИНАЧЕ ЕСЛИ СРАВНЕНИЕ < 0:
                меньше.добавить(элемент)
            ИНАЧЕ:
                больше.добавить(элемент)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        отсортированные_меньше = quickSort(меньше, ключ, по_возрастанию)
        отсортированные_больше = quickSort(больше, ключ, по_возрастанию)

        ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА
                 объединить(отсортированные_меньше, равные, отсортированные_больше)
               ИНАЧЕ
                 объединить(отсортированные_больше, равные, отсортированные_меньше)
               КОНЕЦ ЕСЛИ
    КОНЕЦ
```

```javascript
function quickSort(arr, key, ascending = true) {
    if (arr.length <= 1) return arr;

    const pivot = arr[Math.floor(arr.length / 2)][key];
    const equal = [];
    const less = [];
    const greater = [];

    for (const item of arr) {
        const comparison = compareValues(item[key], pivot, true);

        if (item[key] === pivot) {
            equal.push(item);
        } else if (comparison < 0) {
            less.push(item);
        } else {
            greater.push(item);
        }
    }

    const sortedLess = quickSort(less, key, ascending);
    const sortedGreater = quickSort(greater, key, ascending);

    return ascending
        ? [...sortedLess, ...equal, ...sortedGreater]
        : [...sortedGreater, ...equal, ...sortedLess];
}
```


### 4. Сортировка слиянием (Merge Sort)

Стабильный алгоритм с гарантированной сложностью O(n log n):

**Псевдокод:**
```
ФУНКЦИЯ mergeSort(массив, ключ, по_возрастанию = ИСТИНА):
    НАЧАЛО
        ЕСЛИ длина(массив) <= 1:
            ВОЗВРАТ массив
        КОНЕЦ ЕСЛИ

        середина = floor(длина(массив) / 2)
        лево = массив.взять(0, середина)
        право = массив.взять(середина)

        ВОЗВРАТ объединить(
            mergeSort(лево, ключ, по_возрастанию),
            mergeSort(право, ключ, по_возрастанию),
            ключ,
            по_возрастанию
        )
    КОНЕЦ

ФУНКЦИЯ объединить(лево, право, ключ, по_возрастанию):
    НАЧАЛО
        результат = []
        левый_индекс = 0
        правый_индекс = 0

        ПОКА левый_индекс < длина(лево) И правый_индекс < длина(право):
            СРАВНЕНИЕ = сравнитьЗначения(
                лево[левый_индекс][ключ],
                право[правый_индекс][ключ],
                по_возрастанию
            )

            ЕСЛИ СРАВНЕНИЕ <= 0:
                результат.добавить(лево[левый_индекс])
                левый_индекс = левый_индекс + 1
            ИНАЧЕ:
                результат.добавить(право[правый_индекс])
                правый_индекс = правый_индекс + 1
            КОНЕЦ ЕСЛИ
        КОНЕЦ ПОКА

        ВОЗВРАТ результат.объединить(лево.взять(левый_индекс)).объединить(право.взять(правый_индекс))
    КОНЕЦ
```

```javascript
function mergeSort(arr, key, ascending = true) {
    if (arr.length <= 1) return arr;

    const middle = Math.floor(arr.length / 2);
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);

    return merge(
        mergeSort(left, key, ascending),
        mergeSort(right, key, ascending),
        key,
        ascending
    );
}

function merge(left, right, key, ascending) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;

    while (leftIndex < left.length && rightIndex < right.length) {
        const comparison = compareValues(
            left[leftIndex][key],
            right[rightIndex][key],
            ascending
        );

        if (comparison <= 0) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }

    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}
```

## Специализированные алгоритмы для таблиц

### 1. Стабильная сортировка

Сохранение порядка элементов с одинаковыми значениями:

**Псевдокод:**
```
КЛАСС StableSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sort(массив, ключ, по_возрастанию = ИСТИНА):
        НАЧАЛО
            // Добавляем индекс для сохранения стабильности
            индексированный_массив = массив.карта((элемент, индекс) -> { элемент, оригинальный_индекс: индекс })

            индексированный_массив.сортировать((a, b) -> {
                СРАВНЕНИЕ = сравнитьЗначения(a.элемент[ключ], b.элемент[ключ], по_возрастанию)
                ЕСЛИ СРАВНЕНИЕ ≠ 0:
                    ВОЗВРАТ СРАВНЕНИЕ
                КОНЕЦ ЕСЛИ

                // Если значения равны, сохраняем первоначальный порядок
                ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА
                         a.оригинальный_индекс - b.оригинальный_индекс
                       ИНАЧЕ
                         b.оригинальный_индекс - a.оригинальный_индекс
                       КОНЕЦ ЕСЛИ
            })

            ВОЗВРАТ индексированный_массив.карта(элемент -> элемент.элемент)
        КОНЕЦ
КОНЕЦ КЛАССА
```

```javascript
class StableSort {
    static sort(arr, key, ascending = true) {
        // Добавляем индекс для сохранения стабильности
        const indexedArr = arr.map((item, index) => ({ item, originalIndex: index }));

        indexedArr.sort((a, b) => {
            const comparison = compareValues(a.item[key], b.item[key], ascending);
            if (comparison !== 0) return comparison;

            // Если значения равны, сохраняем первоначальный порядок
            return ascending ?
                a.originalIndex - b.originalIndex :
                b.originalIndex - a.originalIndex;
        });

        return indexedArr.map(item => item.item);
    }
}
```

### 2. Многоколоночная сортировка

Сортировка по нескольким критериям с приоритетами:

**Псевдокод:**
```
КЛАСС MultiColumnSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sort(массив, критерии_сортировки):
        НАЧАЛО
            копия_массива = копировать(массив)
            
            копия_массива.сортировать((a, b) -> {
                ДЛЯ каждого { ключ, по_возрастанию } в критерии_сортировки:
                    СРАВНЕНИЕ = сравнитьЗначения(a[ключ], b[ключ], по_возрастанию)
                    ЕСЛИ СРАВНЕНИЕ ≠ 0:
                        ВОЗВРАТ СРАВНЕНИЕ
                    КОНЕЦ ЕСЛИ
                КОНЕЦ ДЛЯ
                ВОЗВРАТ 0 // Все критерии равны
            })
            
            ВОЗВРАТ копия_массива
        КОНЕЦ
КОНЕЦ КЛАССА
```

```javascript
class MultiColumnSort {
    static sort(arr, sortCriteria) {
        return [...arr].sort((a, b) => {
            for (const { key, ascending } of sortCriteria) {
                const comparison = compareValues(a[key], b[key], ascending);
                if (comparison !== 0) {
                    return comparison;
                }
            }
            return 0; // Все критерии равны
        });
    }
}

// Пример использования
const sortCriteria = [
    { key: 'category', ascending: true },
    { key: 'price', ascending: false },
    { key: 'name', ascending: true }
];

const sortedData = MultiColumnSort.sort(products, sortCriteria);
```

### 3. Сортировка с пользовательскими компараторами

Гибкая сортировка с возможностью кастомной логики:

**Псевдокод:**
```
КЛАСС CustomComparatorSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sort(массив, ключ, компаратор, по_возрастанию = ИСТИНА):
        НАЧАЛО
            копия_массива = копировать(массив)
            
            копия_массива.сортировать((a, b) -> {
                СРАВНЕНИЕ = компаратор(a[ключ], b[ключ])
                ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА СРАВНЕНИЕ ИНАЧЕ -СРАВНЕНИЕ
            })
            
            ВОЗВРАТ копия_массива
        КОНЕЦ

    СТАТИЧЕСКОЕ СВОЙСТВО comparators = {
        // Сортировка по дате
        date: (a, b) -> дата(a) - дата(b),

        // Сортировка по длине строки
        length: (a, b) -> длина(строка(a)) - длина(строка(b)),

        // Сортировка с учетом регистра
        caseSensitive: (a, b) -> строка(a).сравнить(строка(b)),

        // Сортировка без учета регистра
        caseInsensitive: (a, b) -> строка(a).в_нижнем_регистре().сравнить(строка(b).в_нижнем_регистре()),

        // Сортировка чисел с плавающей точкой
        float: (a, b) -> число_с_плавающей_точкой(a) - число_с_плавающей_точкой(b)
    }
КОНЕЦ КЛАССА
```

```javascript
class CustomComparatorSort {
    static sort(arr, key, comparator, ascending = true) {
        return [...arr].sort((a, b) => {
            const comparison = comparator(a[key], b[key]);
            return ascending ? comparison : -comparison;
        });
    }

    // Встроенные компараторы
    static comparators = {
        // Сортировка по дате
        date: (a, b) => new Date(a) - new Date(b),

        // Сортировка по длине строки
        length: (a, b) => String(a).length - String(b).length,

        // Сортировка с учетом регистра
        caseSensitive: (a, b) => String(a).localeCompare(String(b)),

        // Сортировка без учета регистра
        caseInsensitive: (a, b) =>
            String(a).toLowerCase().localeCompare(String(b).toLowerCase()),

        // Сортировка чисел с плавающей точкой
        float: (a, b) => parseFloat(a) - parseFloat(b)
    };
}

// Пример использования
const sortedByDate = CustomComparatorSort.sort(
    items,
    'createdDate',
    CustomComparatorSort.comparators.date,
    false // по убыванию
);
```

## Алгоритмы сортировки для специфических типов данных

### 1. Сортировка строк с учетом локали

**Псевдокод:**
```
КЛАСС LocaleAwareSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sort(массив, ключ, локаль = 'ru-RU', по_возрастанию = ИСТИНА):
        НАЧАЛО
            копия_массива = копировать(массив)
            
            копия_массива.сортировать((a, b) -> {
                СРАВНЕНИЕ = строка(a[ключ]).сравнить(
                    строка(b[ключ]),
                    локаль,
                    { числовое: ИСТИНА, чувствительность: 'базовая' }
                )
                ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА СРАВНЕНИЕ ИНАЧЕ -СРАВНЕНИЕ
            })
            
            ВОЗВРАТ копия_массива
        КОНЕЦ
КОНЕЦ КЛАССА
```

```javascript
class LocaleAwareSort {
    static sort(arr, key, locale = 'ru-RU', ascending = true) {
        return [...arr].sort((a, b) => {
            const comparison = String(a[key]).localeCompare(
                String(b[key]),
                locale,
                { numeric: true, sensitivity: 'base' }
            );
            return ascending ? comparison : -comparison;
        });
    }
}

// Сортировка с учетом русской локали
const sorted = LocaleAwareSort.sort(data, 'name', 'ru-RU');
```

### 2. Сортировка чисел с поддержкой форматирования

**Псевдокод:**
```
КЛАСС NumberSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sort(массив, ключ, по_возрастанию = ИСТИНА):
        НАЧАЛО
            копия_массива = копировать(массив)
            
            копия_массива.сортировать((a, b) -> {
                // Попытка преобразовать к числу, учитывая возможное форматирование
                число_A = разобратьЧисло(a[ключ])
                число_B = разобратьЧисло(b[ключ])

                ВОЗВРАТ ЕСЛИ по_возрастанию ТОГДА число_A - число_B ИНАЧЕ число_B - число_A
            })
            
            ВОЗВРАТ копия_массива
        КОНЕЦ

    СТАТИЧЕСКАЯ ФУНКЦИЯ разобратьЧисло(значение):
        НАЧАЛО
            ЕСЛИ тип(значение) === 'число':
                ВОЗВРАТ значение
            КОНЕЦ ЕСЛИ

            // Удаление форматирования и преобразование к числу
            очищенное_значение = строка(значение)
                .заменить(/[^\d.,\-]/g, '') // Удаление всех нецифровых символов, кроме точки и запятой
                .заменить(',', '.') // Замена запятой на точку

            ВОЗВРАТ число(очищенное_значение) ИЛИ 0
        КОНЕЦ
КОНЕЦ КЛАССА
```

```javascript
class NumberSort {
    static sort(arr, key, ascending = true) {
        return [...arr].sort((a, b) => {
            // Попытка преобразовать к числу, учитывая возможное форматирование
            const numA = this.parseNumber(a[key]);
            const numB = this.parseNumber(b[key]);

            return ascending ? numA - numB : numB - numA;
        });
    }

    static parseNumber(value) {
        if (typeof value === 'number') return value;

        // Удаление форматирования и преобразование к числу
        const cleanValue = String(value)
            .replace(/[^\d.,\-]/g, '') // Удаление всех нецифровых символов, кроме точки и запятой
            .replace(',', '.'); // Замена запятой на точку

        return parseFloat(cleanValue) || 0;
    }
}
```

## Алгоритмы оптимизации сортировки

### 1. Сортировка с кэшированием

Для повторных сортировок одних и тех же данных:

**Псевдокод:**
```
КЛАСС CachedSort:
    КОНСТРУКТОР():
        this.cache = новый Map()
        this.maxCacheSize = 100
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ sort(массив, ключ, по_возрастанию = ИСТИНА):
        // Создание уникального ключа для кэширования
        ключ_кэша = строка(взять(массив, 0, 10)) + "_" + ключ + "_" + по_возрастанию

        ЕСЛИ this.cache.содержит(ключ_кэша):
            ВОЗВРАТ this.cache.получить(ключ_кэша)
        КОНЕЦ ЕСЛИ

        результат = копировать(массив).сортировать((a, b) -> {
            СРАВНЕНИЕ = сравнитьЗначения(a[ключ], b[ключ], по_возрастанию)
            ВОЗВРАТ СРАВНЕНИЕ
        })

        // Кэширование результата
        this.cache.установить(ключ_кэша, результат)

        // Очистка кэша при превышении размера
        ЕСЛИ this.cache.размер > this.maxCacheSize:
            первый_ключ = this.cache.ключи().первый().значение
            this.cache.удалить(первый_ключ)
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ результат
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class CachedSort {
    constructor() {
        this.cache = new Map();
        this.maxCacheSize = 100;
    }

    sort(arr, key, ascending = true) {
        // Создание уникального ключа для кэширования
        const cacheKey = `${JSON.stringify(arr.slice(0, 10))}_${key}_${ascending}`;

        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }

        const result = [...arr].sort((a, b) => {
            const comparison = compareValues(a[key], b[key], ascending);
            return comparison;
        });

        // Кэширование результата
        this.cache.set(cacheKey, result);

        // Очистка кэша при превышении размера
        if (this.cache.size > this.maxCacheSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        return result;
    }
}
```

### 2. Частичная сортировка (Top-K)

Когда нужно отсортировать только первые K элементов:

**Псевдокод:**
```
КЛАСС PartialSort:
    СТАТИЧЕСКАЯ ФУНКЦИЯ topK(массив, ключ, k, по_возрастанию = ИСТИНА):
        НАЧАЛО
            ЕСЛИ k >= длина(массив):
                ВОЗВРАТ mergeSort(массив, ключ, по_возрастанию)
            КОНЕЦ ЕСЛИ

            результат = копировать(массив)
            quickSelect(результат, 0, длина(результат) - 1, k - 1, ключ, по_возрастанию)

            // Сортируем только первые K элементов
            топ_K = взять(результат, 0, k)
            ВОЗВРАТ mergeSort(топ_K, ключ, по_возрастанию)
        КОНЕЦ

    СТАТИЧЕСКАЯ ФУНКЦИЯ quickSelect(массив, лево, право, k, ключ, по_возрастанию):
        НАЧАЛО
            ЕСЛИ лево === право:
                ВОЗВРАТ массив[лево]
            КОНЕЦ ЕСЛИ

            индекс_опорного = partition(массив, лево, право, ключ, по_возрастанию)

            ЕСЛИ k === индекс_опорного:
                ВОЗВРАТ массив[k]
            ИНАЧЕ ЕСЛИ k < индекс_опорного:
                ВОЗВРАТ quickSelect(массив, лево, индекс_опорного - 1, k, ключ, по_возрастанию)
            ИНАЧЕ:
                ВОЗВРАТ quickSelect(массив, индекс_опорного + 1, право, k, ключ, по_возрастанию)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ФУНКЦИИ

    СТАТИЧЕСКАЯ ФУНКЦИЯ partition(массив, лево, право, ключ, по_возрастанию):
        НАЧАЛО
            опорное_значение = массив[право][ключ]
            индекс_хранения = лево

            ДЛЯ i ОТ лево ДО право - 1:
                СРАВНЕНИЕ = сравнитьЗначения(массив[i][ключ], опорное_значение, по_возрастанию)
                ДОЛЖНО_ПОМЕНЯТЬ = ЕСЛИ по_возрастанию ТОГДА СРАВНЕНИЕ <= 0 ИНАЧЕ СРАВНЕНИЕ >= 0

                ЕСЛИ ДОЛЖНО_ПОМЕНЯТЬ:
                    ПОМЕНЯТЬ_МЕСТАМИ(массив[i], массив[индекс_хранения])
                    индекс_хранения++
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ

            ПОМЕНЯТЬ_МЕСТАМИ(массив[индекс_хранения], массив[право])
            ВОЗВРАТ индекс_хранения
        КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class PartialSort {
    static topK(arr, key, k, ascending = true) {
        if (k >= arr.length) {
            return mergeSort(arr, key, ascending);
        }

        // Используем быструю сортировку до K-го элемента
        const result = [...arr];
        this.quickSelect(result, 0, result.length - 1, k - 1, key, ascending);

        // Сортируем только первые K элементов
        const topK = result.slice(0, k);
        return mergeSort(topK, key, ascending);
    }

    static quickSelect(arr, left, right, k, key, ascending) {
        if (left === right) return arr[left];

        const pivotIndex = this.partition(arr, left, right, key, ascending);

        if (k === pivotIndex) {
            return arr[k];
        } else if (k < pivotIndex) {
            return this.quickSelect(arr, left, pivotIndex - 1, k, key, ascending);
        } else {
            return this.quickSelect(arr, pivotIndex + 1, right, k, key, ascending);
        }
    }

    static partition(arr, left, right, key, ascending) {
        const pivotValue = arr[right][key];
        let storeIndex = left;

        for (let i = left; i < right; i++) {
            const comparison = compareValues(arr[i][key], pivotValue, ascending);
            const shouldSwap = ascending ? comparison <= 0 : comparison >= 0;

            if (shouldSwap) {
                [arr[i], arr[storeIndex]] = [arr[storeIndex], arr[i]];
                storeIndex++;
            }
        }

        [arr[storeIndex], arr[right]] = [arr[right], arr[storeIndex]];
        return storeIndex;
    }
}
```

## Современные подходы в 2025 году

### 1. Сортировка с виртуализацией

Для таблиц с очень большим количеством строк:

**Псевдокод:**
```
КЛАСС VirtualSort:
    КОНСТРУКТОР(данные, функция_сортировки):
        this.data = данные
        this.sortFunction = функция_сортировки
        this.sortedData = НЕОПРЕДЕЛЕНО
        this.sortParams = НЕОПРЕДЕЛЕНО
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ sort(ключ, по_возрастанию = ИСТИНА):
        // Проверяем, нужна ли пересортировка
        ЕСЛИ this.sortParams И this.sortParams.key === ключ И this.sortParams.ascending === по_возрастанию:
            ВОЗВРАТ this.sortedData
        КОНЕЦ ЕСЛИ

        // Асинхронная сортировка для больших наборов данных
        this.sortedData = АСИНХРОННО НОВОЕ_ОБЕЩАНИЕ(разрешить -> {
            установитьТаймаут(() -> {
                отсортировано = this.sortFunction(this.data, ключ, по_возрастанию)
                this.sortParams = { key: ключ, ascending: по_возрастанию }
                разрешить(отсортировано)
            }, 0)
        })

        ВОЗВРАТ this.sortedData
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class VirtualSort {
    constructor(data, sortFunction) {
        this.data = data;
        this.sortFunction = sortFunction;
        this.sortedData = null;
        this.sortParams = null;
    }

    async sort(key, ascending = true) {
        // Проверяем, нужна ли пересортировка
        if (this.sortParams && this.sortParams.key === key && this.sortParams.ascending === ascending) {
            return this.sortedData;
        }

        // Асинхронная сортировка для больших наборов данных
        this.sortedData = await new Promise(resolve => {
            setTimeout(() => {
                const sorted = this.sortFunction(this.data, key, ascending);
                this.sortParams = { key, ascending };
                resolve(sorted);
            }, 0);
        });

        return this.sortedData;
    }
}
```

### 2. Сортировка с машинным обучением (персонализированная)

**Псевдокод:**
```
КЛАСС MLSort:
    КОНСТРУКТОР(данные):
        this.data = данные
        this.userPreferences = новый Map() // Предпочтения пользователя
    КОНЕЦ КОНСТРУКТОРА

    // Обучение на основе поведения пользователя
    ФУНКЦИЯ recordPreference(userId, поле, порядок):
        НАЧАЛО
            ЕСЛИ !this.userPreferences.содержит(userId):
                this.userPreferences.установить(userId, {})
            КОНЕЦ ЕСЛИ

            пользовательские_настройки = this.userPreferences.получить(userId)
            пользовательская_настройка = пользовательские_настройки[поле] ИЛИ { count: 0, totalOrder: 0 }
            пользовательская_настройка.count++
            пользовательская_настройка.totalOrder += порядок // 1 для по возрастанию, -1 для по убыванию
            пользовательские_настройки[поле] = пользовательская_настройка
        КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ sort(userId, массив, ключ, по_возрастанию = ИСТИНА):
        // Получаем предпочтения пользователя для этой колонки
        пользовательские_настройки = this.userPreferences.получить(userId) ИЛИ {}
        пользовательская_настройка = пользовательские_настройки[ключ]

        // Если у пользователя есть предпочтения, корректируем сортировку
        ЕСЛИ пользовательская_настройка И пользовательская_настройка.count > 5: // Требуем минимум 5 взаимодействий
            средний_порядок = пользовательская_настройка.totalOrder / пользовательская_настройка.count
            должен_скорректировать = модуль(средний_порядок) > 0.6 // Порог уверенности

            ЕСЛИ должен_скорректировать:
                по_возрастанию = средний_порядок > 0 // Корректируем направление сортировки
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ mergeSort(массив, ключ, по_возрастанию)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class MLSort {
    constructor(data) {
        this.data = data;
        this.userPreferences = new Map(); // Предпочтения пользователя
    }

    // Обучение на основе поведения пользователя
    recordPreference(userId, field, order) {
        if (!this.userPreferences.has(userId)) {
            this.userPreferences.set(userId, {});
        }

        const userPrefs = this.userPreferences.get(userId);
        userPrefs[field] = userPrefs[field] || { count: 0, totalOrder: 0 };
        userPrefs[field].count++;
        userPrefs[field].totalOrder += order; // 1 для по возрастанию, -1 для по убыванию
    }

    sort(userId, arr, key, ascending = true) {
        // Получаем предпочтения пользователя для этой колонки
        const userPrefs = this.userPreferences.get(userId) || {};
        const userPref = userPrefs[key];

        // Если у пользователя есть предпочтения, корректируем сортировку
        if (userPref && userPref.count > 5) { // Требуем минимум 5 взаимодействий
            const avgOrder = userPref.totalOrder / userPref.count;
            const shouldAdjust = Math.abs(avgOrder) > 0.6; // Порог уверенности

            if (shouldAdjust) {
                ascending = avgOrder > 0; // Корректируем направление сортировки
            }
        }

        return mergeSort(arr, key, ascending);
    }
}
```

## Практические рекомендации

### 1. Выбор алгоритма в зависимости от данных

- Для небольших наборов данных (< 50 элементов) - сортировка вставками
- Для средних наборов данных - сортировка слиянием или быстрая сортировка
- Для больших наборов данных - комбинация с виртуализацией и асинхронной обработкой

### 2. Оптимизация пользовательского интерфейса

**Псевдокод:**
```
КЛАСС UISortController:
    КОНСТРУКТОР(элемент_таблицы, данные):
        this.tableElement = элемент_таблицы
        this.data = данные
        this.currentSort = { key: НЕОПРЕДЕЛЕНО, ascending: ИСТИНА }
        this.loadingIndicator = createLoadingIndicator()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ init():
        НАЧАЛО
            // Добавляем обработчики кликов на заголовки таблицы
            заголовки = this.tableElement.найти('th[data-sortable]')
            ДЛЯ каждого заголовка в заголовки:
                заголовок.addEventListener('click', (e) -> {
                    handleSort(e.target.dataset.key)
                })
            КОНЕЦ ДЛЯ
        КОНЕЦ ФУНКЦИИ

    АСИНХРОННАЯ ФУНКЦИЯ handleSort(ключ):
        // Показываем индикатор загрузки
        showLoading()

        ПОПЫТКА:
            // Определяем направление сортировки
            по_возрастанию = ИСТИНА
            ЕСЛИ this.currentSort.key === ключ:
                по_возрастанию = !this.currentSort.ascending
            КОНЕЦ ЕСЛИ

            // Выполняем сортировку
            отсортированные_данные = АСИНХРОННО sortData(ключ, по_возрастанию)

            // Обновляем состояние
            this.currentSort = { key: ключ, ascending: по_возрастанию }

            // Обновляем таблицу
            updateTable(отсортированные_данные)

            // Обновляем визуальные индикаторы сортировки
            updateSortIndicators(ключ, по_возрастанию)
        НАКОНЕЦ:
            hideLoading()
        КОНЕЦ ПОПЫТКИ
    КОНЕЦ ФУНКЦИИ

    АСИНХРОННАЯ ФУНКЦИЯ sortData(ключ, по_возрастанию):
        // Используем оптимальный алгоритм в зависимости от размера данных
        ЕСЛИ длина(this.data) < 1000:
            ВОЗВРАТ mergeSort(this.data, ключ, по_возрастанию)
        ИНАЧЕ:
            // Для больших данных используем виртуализацию
            virtualSorter = новый VirtualSort(this.data, mergeSort)
            ВОЗВРАТ АСИНХРОННО virtualSorter.sort(ключ, по_возрастанию)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class UISortController {
    constructor(tableElement, data) {
        this.tableElement = tableElement;
        this.data = data;
        this.currentSort = { key: null, ascending: true };
        this.loadingIndicator = this.createLoadingIndicator();
    }

    init() {
        // Добавляем обработчики кликов на заголовки таблицы
        const headers = this.tableElement.querySelectorAll('th[data-sortable]');
        headers.forEach(header => {
            header.addEventListener('click', (e) => {
                this.handleSort(e.target.dataset.key);
            });
        });
    }

    async handleSort(key) {
        // Показываем индикатор загрузки
        this.showLoading();

        try {
            // Определяем направление сортировки
            let ascending = true;
            if (this.currentSort.key === key) {
                ascending = !this.currentSort.ascending;
            }

            // Выполняем сортировку
            const sortedData = await this.sortData(key, ascending);

            // Обновляем состояние
            this.currentSort = { key, ascending };

            // Обновляем таблицу
            this.updateTable(sortedData);

            // Обновляем визуальные индикаторы сортировки
            this.updateSortIndicators(key, ascending);
        } finally {
            this.hideLoading();
        }
    }

    async sortData(key, ascending) {
        // Используем оптимальный алгоритм в зависимости от размера данных
        if (this.data.length < 1000) {
            return mergeSort(this.data, key, ascending);
        } else {
            // Для больших данных используем виртуализацию
            const virtualSorter = new VirtualSort(this.data, mergeSort);
            return await virtualSorter.sort(key, ascending);
        }
    }

    updateSortIndicators(activeKey, ascending) {
        // Очищаем предыдущие индикаторы
        this.tableElement.querySelectorAll('th').forEach(th => {
            th.classList.remove('sort-asc', 'sort-desc');
        });

        // Добавляем индикатор активной сортировки
        const activeHeader = this.tableElement.querySelector(`th[data-key="${activeKey}"]`);
        if (activeHeader) {
            activeHeader.classList.add(ascending ? 'sort-asc' : 'sort-desc');
        }
    }

    createLoadingIndicator() {
        const indicator = document.createElement('div');
        indicator.className = 'loading-indicator';
        indicator.style.display = 'none';
        indicator.innerHTML = 'Сортировка...';
        document.body.appendChild(indicator);
        return indicator;
    }

    showLoading() {
        this.loadingIndicator.style.display = 'block';
    }

    hideLoading() {
        this.loadingIndicator.style.display = 'none';
    }
}
```

### 3. Сохранение состояния сортировки

**Псевдокод:**
```
КЛАСС SortStateManager:
    КОНСТРУКТОР(ключ_хранилища):
        this.storageKey = ключ_хранилища
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ save(состояние_сортировки):
        НАЧАЛО
            ПОПЫТКА:
                localStorage.установить(this.storageKey, JSON.stringify(состояние_сортировки))
            ИСКЛЮЧЕНИЕ (e):
                ВЫВЕСТИ_ПРЕДУПРЕЖДЕНИЕ('Не удалось сохранить состояние сортировки:', e)
            КОНЕЦ ПОПЫТКИ
        КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ load():
        НАЧАЛО
            ПОПЫТКА:
                сохраненное = localStorage.получить(this.storageKey)
                ВОЗВРАТ сохраненное ? JSON.parse(сохраненное) : НЕОПРЕДЕЛЕНО
            ИСКЛЮЧЕНИЕ (e):
                ВЫВЕСТИ_ПРЕДУПРЕЖДЕНИЕ('Не удалось загрузить состояние сортировки:', e)
                ВОЗВРАТ НЕОПРЕДЕЛЕНО
            КОНЕЦ ПОПЫТКИ
        КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ clear():
        НАЧАЛО
            localStorage.удалить(this.storageKey)
        КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SortStateManager {
    constructor(storageKey) {
        this.storageKey = storageKey;
    }

    save(sortState) {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(sortState));
        } catch (e) {
            console.warn('Не удалось сохранить состояние сортировки:', e);
        }
    }

    load() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            return stored ? JSON.parse(stored) : null;
        } catch (e) {
            console.warn('Не удалось загрузить состояние сортировки:', e);
            return null;
        }
    }

    clear() {
        localStorage.removeItem(this.storageKey);
    }
}
```

## Заключение

Алгоритмы сортировки в таблицах играют ключевую роль в современных веб-приложениях. Правильный выбор и реализация алгоритмов сортировки позволяет создать эффективный и удобный пользовательский интерфейс. Важно учитывать не только алгоритмическую эффективность, но и пользовательский опыт, персонализацию и возможность работы с большими объемами данных.

## См. также

- [[Алгоритмы-поиска-в-интерфейсах]]
- [[Алгоритмы-оптимизации-рендеринга]]
- [[Алгоритмы-анимаций]]
- [[Структуры-данных-для-фронтенда]]

## Теги

#frontend #algorithms #sorting #tables #javascript #performance #ui #data-tables