---
aliases: [Interface Search Algorithms, Поиск в интерфейсах]
tags: [frontend, algorithms, search, ui, javascript, performance]
---

# Алгоритмы поиска в интерфейсах

## Введение

Алгоритмы поиска в интерфейсах являются важной частью современных веб-приложений. Пользователи ожидают быстрого и интуитивного поиска с возможностью фильтрации, сортировки и автодополнения. Эффективные алгоритмы поиска обеспечивают положительный пользовательский опыт и повышают производительность приложений.

## Основные типы поиска в интерфейсах

### 1. Поиск по точному совпадению
Наиболее простой тип поиска, где пользователь вводит точный термин для поиска.

### 2. Поиск по частичному совпадению (fuzzy search)
Позволяет находить результаты даже при опечатках или неточном вводе.

### 3. Автодополнение (autocomplete)
Предлагает возможные варианты по мере ввода пользователем.

### 4. Поиск с фильтрацией
Комбинирует поиск с фильтрацией по различным критериям.

## Алгоритмы поиска

### 1. Алгоритм линейного поиска

Самый простой алгоритм, подходит для небольших наборов данных:

**Псевдокод:**
```
ФУНКЦИЯ linearSearch(данные, поисковый_термин):
    НАЧАЛО
        РЕЗУЛЬТАТЫ = []
        ДЛЯ каждого элемента в данные:
            ЕСЛИ элемент.name.содержит(поисковый_термин.в_нижнем_регистре):
                ДОБАВИТЬ элемент в РЕЗУЛЬТАТЫ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
        ВОЗВРАТ РЕЗУЛЬТАТЫ
    КОНЕЦ
```

**Псевдокод:**
```
ФУНКЦИЯ linearSearch(данные, поисковый_термин):
    НАЧАЛО
        РЕЗУЛЬТАТЫ = []
        ДЛЯ каждого элемента в данные:
            ЕСЛИ элемент.name.содержит(поисковый_термин.в_нижнем_регистре):
                ДОБАВИТЬ элемент в РЕЗУЛЬТАТЫ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ
        ВОЗВРАТ РЕЗУЛЬТАТЫ
    КОНЕЦ
```

```javascript
function linearSearch(data, searchTerm) {
    return data.filter(item =>
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
}
```


### 2. Алгоритм двоичного поиска

Эффективен для отсортированных массивов:

**Псевдокод:**
```
ФУНКЦИЯ binarySearch(отсортированный_массив, поисковый_термин):
    НАЧАЛО
        ЛЕВО = 0
        ПРАВО = длина(отсортированный_массив) - 1

        ПОКА ЛЕВО <= ПРАВО:
            СЕРЕДИНА = floor((ЛЕВО + ПРАВО) / 2)
            СРЕДНЕЕ_ЗНАЧЕНИЕ = отсортированный_массив[СЕРЕДИНА].в_нижнем_регистре
            ПОИСКОВОЕ_ЗНАЧЕНИЕ = поисковый_термин.в_нижнем_регистре

            ЕСЛИ СРЕДНЕЕ_ЗНАЧЕНИЕ === ПОИСКОВОЕ_ЗНАЧЕНИЕ:
                ВОЗВРАТ СЕРЕДИНА // Найден элемент
            ИНАЧЕ ЕСЛИ СРЕДНЕЕ_ЗНАЧЕНИЕ < ПОИСКОВОЕ_ЗНАЧЕНИЕ:
                ЛЕВО = СЕРЕДИНА + 1
            ИНАЧЕ:
                ПРАВО = СЕРЕДИНА - 1
            КОНЕЦ ЕСЛИ
        КОНЕЦ ПОКА

        ВОЗВРАТ -1 // Элемент не найден
    КОНЕЦ
```

**Псевдокод:**
```
ФУНКЦИЯ binarySearch(отсортированный_массив, поисковый_термин):
    НАЧАЛО
        ЛЕВО = 0
        ПРАВО = длина(отсортированный_массив) - 1

        ПОКА ЛЕВО <= ПРАВО:
            СЕРЕДИНА = floor((ЛЕВО + ПРАВО) / 2)
            СРЕДНЕЕ_ЗНАЧЕНИЕ = отсортированный_массив[СЕРЕДИНА].в_нижнем_регистре
            ПОИСКОВОЕ_ЗНАЧЕНИЕ = поисковый_термин.в_нижнем_регистре

            ЕСЛИ СРЕДНЕЕ_ЗНАЧЕНИЕ === ПОИСКОВОЕ_ЗНАЧЕНИЕ:
                ВОЗВРАТ СЕРЕДИНА // Найден элемент
            ИНАЧЕ ЕСЛИ СРЕДНЕЕ_ЗНАЧЕНИЕ < ПОИСКОВОЕ_ЗНАЧЕНИЕ:
                ЛЕВО = СЕРЕДИНА + 1
            ИНАЧЕ:
                ПРАВО = СЕРЕДИНА - 1
            КОНЕЦ ЕСЛИ
        КОНЕЦ ПОКА

        ВОЗВРАТ -1 // Элемент не найден
    КОНЕЦ
```

```javascript
function binarySearch(sortedArray, searchTerm) {
    let left = 0;
    let right = sortedArray.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const midValue = sortedArray[mid].toLowerCase();
        const searchValue = searchTerm.toLowerCase();

        if (midValue === searchValue) {
            return mid; // Найден элемент
        } else if (midValue < searchValue) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1; // Элемент не найден
}
```


### 3. Алгоритм поиска с использованием индексов

Для более сложных сценариев можно создать индекс для ускорения поиска:

**Псевдокод:**
```
КЛАСС SearchIndex:
    КОНСТРУКТОР(данные):
        this.data = данные
        this.index = buildIndex(данные)
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ buildIndex(данные):
        ИНДЕКС = новый Map()

        ДЛЯ каждого (элемент, индекс) в данные:
            СЛОВА = элемент.name.разделить(/\s+/).в_нижнем_регистре
            ДЛЯ каждого слова в СЛОВА:
                ЕСЛИ !ИНДЕКС.содержит(слово):
                    ИНДЕКС.установить(слово, [])
                КОНЕЦ ЕСЛИ
                ИНДЕКС.получить(слово).добавить(индекс)
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ ИНДЕКС
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ search(поисковый_термин):
        ТЕРМЫ = поисковый_термин.разделить(/\s+/).в_нижнем_регистре
        РЕЗУЛЬТАТЫ = новый Set()

        ДЛЯ каждого терма в ТЕРМЫ:
            ЕСЛИ this.index.содержит(терм):
                ДЛЯ каждого индекса в this.index.получить(терм):
                    РЕЗУЛЬТАТЫ.добавить(this.data[индекс])
                КОНЕЦ ДЛЯ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ массив(РЕЗУЛЬТАТЫ)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

**Псевдокод:**
```
КЛАСС SearchIndex:
    КОНСТРУКТОР(данные):
        this.data = данные
        this.index = buildIndex(данные)
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ buildIndex(данные):
        ИНДЕКС = новый Map()

        ДЛЯ каждого (элемент, индекс) в данные:
            СЛОВА = элемент.name.разделить(/\s+/).в_нижнем_регистре
            ДЛЯ каждого слова в СЛОВА:
                ЕСЛИ !ИНДЕКС.содержит(слово):
                    ИНДЕКС.установить(слово, [])
                КОНЕЦ ЕСЛИ
                ИНДЕКС.получить(слово).добавить(индекс)
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ ИНДЕКС
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ search(поисковый_термин):
        ТЕРМЫ = поисковый_термин.разделить(/\s+/).в_нижнем_регистре
        РЕЗУЛЬТАТЫ = новый Set()

        ДЛЯ каждого терма в ТЕРМЫ:
            ЕСЛИ this.index.содержит(терм):
                ДЛЯ каждого индекса в this.index.получить(терм):
                    РЕЗУЛЬТАТЫ.добавить(this.data[индекс])
                КОНЕЦ ДЛЯ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ массив(РЕЗУЛЬТАТЫ)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SearchIndex {
    constructor(data) {
        this.data = data;
        this.index = this.buildIndex(data);
    }

    buildIndex(data) {
        const index = new Map();

        data.forEach((item, index) => {
            // Создание индекса по каждому слову в названии
            const words = item.name.toLowerCase().split(/\s+/);
            words.forEach(word => {
                if (!index.has(word)) {
                    index.set(word, []);
                }
                index.get(word).push(index);
            });
        });

        return index;
    }

    search(searchTerm) {
        const terms = searchTerm.toLowerCase().split(/\s+/);
        let results = new Set();

        terms.forEach(term => {
            if (this.index.has(term)) {
                this.index.get(term).forEach(itemIndex => {
                    results.add(this.data[itemIndex]);
                });
            }
        });

        return Array.from(results);
    }
}
```


### 4. Алгоритм нечеткого поиска (Fuzzy Search)

Используется для поиска с опечатками или частичным совпадением:

```javascript
class FuzzySearch {
    constructor(data, options = {}) {
        this.data = data;
        this.threshold = options.threshold || 0.6; // Порог схожести
        this.key = options.key || 'name';
    }

    // Расстояние Левенштейна для измерения схожести строк
    levenshteinDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill().map(() =>
            Array(str1.length + 1).fill(0)
        );

        for (let i = 0; i <= str1.length; i++) {
            matrix[0][i] = i;
        }

        for (let j = 0; j <= str2.length; j++) {
            matrix[j][0] = j;
        }

        for (let j = 1; j <= str2.length; j++) {
            for (let i = 1; i <= str1.length; i++) {
                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                matrix[j][i] = Math.min(
                    matrix[j][i - 1] + 1,      // Удаление
                    matrix[j - 1][i] + 1,      // Вставка
                    matrix[j - 1][i - 1] + cost // Замена
                );
            }
        }

        return matrix[str2.length][str1.length];
    }

    fuzzySearch(searchTerm) {
        const results = [];

        this.data.forEach(item => {
            const text = item[this.key].toLowerCase();
            const term = searchTerm.toLowerCase();

            // Проверка на частичное совпадение
            if (text.includes(term)) {
                results.push({
                    item,
                    score: 1.0
                });
                return;
            }

            // Расчет расстояния Левенштейна
            const distance = this.levenshteinDistance(term, text);
            const maxLength = Math.max(term.length, text.length);
            const similarity = 1 - (distance / maxLength);

            if (similarity >= this.threshold) {
                results.push({
                    item,
                    score: similarity
                });
            }
        });

        // Сортировка по релевантности
        return results.sort((a, b) => b.score - a.score);
    }
}
```

### 5. Алгоритм три-поиска (Trie-based search)

Эффективен для автодополнения и поиска префиксов:

**Псевдокод:**
```
КЛАСС TrieNode:
    КОНСТРУКТОР():
        this.children = новый Map()
        this.isEndOfWord = ЛОЖЬ
        this.data = [] // Данные, связанные с этим узлом
    КОНЕЦ КОНСТРУКТОРА
КОНЕЦ КЛАССА

КЛАСС TrieSearch:
    КОНСТРУКТОР():
        this.root = новый TrieNode()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ insert(слово, данные):
        ТЕКУЩИЙ = this.root

        ДЛЯ каждого символа в слово.в_нижнем_регистре:
            ЕСЛИ !ТЕКУЩИЙ.children.содержит(символ):
                ТЕКУЩИЙ.children.установить(символ, новый TrieNode())
            КОНЕЦ ЕСЛИ
            ТЕКУЩИЙ = ТЕКУЩИЙ.children.получить(символ)
        КОНЕЦ ДЛЯ

        ТЕКУЩИЙ.isEndOfWord = ИСТИНА
        ТЕКУЩИЙ.data.добавить(данные)
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ search(префикс):
        ТЕКУЩИЙ = this.root

        // Проходим по префиксу
        ДЛЯ каждого символа в префикс.в_нижнем_регистре:
            ЕСЛИ !ТЕКУЩИЙ.children.содержит(символ):
                ВОЗВРАТ [] // Префикс не найден
            КОНЕЦ ЕСЛИ
            ТЕКУЩИЙ = ТЕКУЩИЙ.children.получить(символ)
        КОНЕЦ ДЛЯ

        // Собираем все слова с этим префиксом
        РЕЗУЛЬТАТЫ = []
        collectWords(ТЕКУЩИЙ, РЕЗУЛЬТАТЫ)
        ВОЗВРАТ РЕЗУЛЬТАТЫ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ collectWords(узел, результаты):
        ЕСЛИ узел.isEndOfWord:
            результаты.добавить(...узел.data)
        КОНЕЦ ЕСЛИ

        ДЛЯ каждого ребенка в узел.children.значения():
            collectWords(ребенок, результаты)
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ

    // Загрузка данных в дерево
    ФУНКЦИЯ buildFromData(данные, ключ):
        ДЛЯ каждого элемента в данные:
            // Вставляем каждое слово из текста
            СЛОВА = элемент[ключ].в_нижнем_регистре.разделить(/\s+/)
            ДЛЯ каждого слова в СЛОВА:
                insert(слово, элемент)
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class TrieNode {
    constructor() {
        this.children = new Map();
        this.isEndOfWord = false;
        this.data = []; // Данные, связанные с этим узлом
    }
}

class TrieSearch {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word, data) {
        let current = this.root;

        for (const char of word.toLowerCase()) {
            if (!current.children.has(char)) {
                current.children.set(char, new TrieNode());
            }
            current = current.children.get(char);
        }

        current.isEndOfWord = true;
        current.data.push(data);
    }

    search(prefix) {
        let current = this.root;

        // Проходим по префиксу
        for (const char of prefix.toLowerCase()) {
            if (!current.children.has(char)) {
                return []; // Префикс не найден
            }
            current = current.children.get(char);
        }

        // Собираем все слова с этим префиксом
        const results = [];
        this.collectWords(current, results);
        return results;
    }

    collectWords(node, results) {
        if (node.isEndOfWord) {
            results.push(...node.data);
        }

        for (const child of node.children.values()) {
            this.collectWords(child, results);
        }
    }

    // Загрузка данных в дерево
    buildFromData(data, key) {
        data.forEach(item => {
            // Вставляем каждое слово из текста
            const words = item[key].toLowerCase().split(/\s+/);
            words.forEach(word => {
                this.insert(word, item);
            });
        });
    }
}
```

## Алгоритмы автодополнения

### 1. Простое автодополнение

**Псевдокод:**
```
КЛАСС SimpleAutocomplete:
    КОНСТРУКТОР(данные, ключ = 'name'):
        this.data = данные
        this.key = ключ
        this.suggestions = []
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ getSuggestions(ввод):
        ЕСЛИ !ввод:
            ВОЗВРАТ []
        КОНЕЦ ЕСЛИ

        ТЕРМ = ввод.в_нижнем_регистре
        ВОЗВРАТ this.data
            .фильтр(элемент -> элемент[this.key].в_нижнем_регистре.начинаетсяС(ТЕРМ))
            .взять(10) // Ограничение на 10 результатов
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SimpleAutocomplete {
    constructor(data, key = 'name') {
        this.data = data;
        this.key = key;
        this.suggestions = [];
    }

    getSuggestions(input) {
        if (!input) return [];

        const term = input.toLowerCase();
        return this.data
            .filter(item =>
                item[this.key].toLowerCase().startsWith(term)
            )
            .slice(0, 10); // Ограничение на 10 результатов
    }
}
```

### 2. Интеллектуальное автодополнение с приоритезацией

**Псевдокод:**
```
КЛАСС IntelligentAutocomplete:
    КОНСТРУКТОР(данные, ключ = 'name'):
        this.data = данные
        this.key = ключ
        this.popularityIndex = новый Map() // Индекс популярности
    КОНЕЦ КОНСТРУКТОРА

    // Метод для обновления популярности элемента
    ФУНКЦИЯ updatePopularity(элемент):
        ЗНАЧЕНИЕ = элемент[this.key]
        ТЕКУЩЕЕ_КОЛИЧЕСТВО = this.popularityIndex.получить(ЗНАЧЕНИЕ) ИЛИ 0
        this.popularityIndex.установить(ЗНАЧЕНИЕ, ТЕКУЩЕЕ_КОЛИЧЕСТВО + 1)
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ getSuggestions(ввод):
        ЕСЛИ !ввод:
            ВОЗВРАТ []
        КОНЕЦ ЕСЛИ

        ТЕРМ = ввод.в_нижнем_регистре
        КАНДИДАТЫ = this.data.фильтр(элемент ->
            элемент[this.key].в_нижнем_регистре.содержит(ТЕРМ)
        )

        // Сортировка по релевантности и популярности
        ВОЗВРАТ КАНДИДАТЫ
            .карта(элемент -> {
                ИМЯ = элемент[this.key].в_нижнем_регистре
                ПОЗИЦИЯ = ИМЯ.найти(ТЕРМ)
                АКТУАЛЬНОСТЬ = ЕСЛИ ПОЗИЦИЯ === 0 ТОГДА 2 ИНАЧЕ 1 // Выше приоритет у совпадений в начале
                ПОПУЛЯРНОСТЬ = this.popularityIndex.получить(элемент[this.key]) ИЛИ 0

                ВОЗВРАТ {
                    элемент,
                    score: АКТУАЛЬНОСТЬ + ПОПУЛЯРНОСТЬ * 0.1
                }
            })
            .отсортировать((a, b) -> b.score - a.score)
            .взять(10)
            .карта(результат -> результат.элемент)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class IntelligentAutocomplete {
    constructor(data, key = 'name') {
        this.data = data;
        this.key = key;
        this.popularityIndex = new Map(); // Индекс популярности
    }

    // Метод для обновления популярности элемента
    updatePopularity(item) {
        const value = item[this.key];
        const currentCount = this.popularityIndex.get(value) || 0;
        this.popularityIndex.set(value, currentCount + 1);
    }

    getSuggestions(input) {
        if (!input) return [];

        const term = input.toLowerCase();
        const candidates = this.data.filter(item =>
            item[this.key].toLowerCase().includes(term)
        );

        // Сортировка по релевантности и популярности
        return candidates
            .map(item => {
                const name = item[this.key].toLowerCase();
                const position = name.indexOf(term);
                const relevance = position === 0 ? 2 : 1; // Выше приоритет у совпадений в начале
                const popularity = this.popularityIndex.get(item[this.key]) || 0;

                return {
                    item,
                    score: relevance + popularity * 0.1
                };
            })
            .sort((a, b) => b.score - a.score)
            .slice(0, 10)
            .map(result => result.item);
    }
}
```

## Алгоритмы поиска с фильтрацией

### 1. Комбинированный поиск и фильтрация

**Псевдокод:**
```
КЛАСС SearchWithFilter:
    КОНСТРУКТОР(данные):
        this.data = данные
        this.filters = {}
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ setFilter(ключ, значение):
        this.filters[ключ] = значение
        ВОЗВРАТ this
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ setSearchTerm(термин):
        this.searchTerm = термин
        ВОЗВРАТ this
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ execute():
        РЕЗУЛЬТАТЫ = [...this.data]

        // Применение фильтров
        ДЛЯ каждой (ключ, значение) в this.filters:
            ЕСЛИ значение !== undefined И значение !== null:
                ЕСЛИ массив(значение):
                    РЕЗУЛЬТАТЫ = РЕЗУЛЬТАТЫ.фильтр(элемент -> значение.содержит(элемент[ключ]))
                ИНАЧЕ:
                    РЕЗУЛЬТАТЫ = РЕЗУЛЬТАТЫ.фильтр(элемент -> элемент[ключ] === значение)
                КОНЕЦ ЕСЛИ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        // Применение поиска
        ЕСЛИ this.searchTerm:
            ТЕРМ = this.searchTerm.в_нижнем_регистре
            РЕЗУЛЬТАТЫ = РЕЗУЛЬТАТЫ.фильтр(элемент ->
                значения(элемент).некоторые(значение ->
                    строка(значение).в_нижнем_регистре.содержит(ТЕРМ)
                )
            )
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ РЕЗУЛЬТАТЫ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SearchWithFilter {
    constructor(data) {
        this.data = data;
        this.filters = {};
    }

    setFilter(key, value) {
        this.filters[key] = value;
        return this;
    }

    setSearchTerm(term) {
        this.searchTerm = term;
        return this;
    }

    execute() {
        let results = [...this.data];

        // Применение фильтров
        Object.entries(this.filters).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                if (Array.isArray(value)) {
                    results = results.filter(item => value.includes(item[key]));
                } else {
                    results = results.filter(item => item[key] === value);
                }
            }
        });

        // Применение поиска
        if (this.searchTerm) {
            const term = this.searchTerm.toLowerCase();
            results = results.filter(item =>
                Object.values(item).some(val =>
                    String(val).toLowerCase().includes(term)
                )
            );
        }

        return results;
    }
}

// Использование
const searcher = new SearchWithFilter(products);
const results = searcher
    .setFilter('category', 'electronics')
    .setFilter('inStock', true)
    .setSearchTerm('phone')
    .execute();
```

### 2. Алгоритм поиска с множественными критериями

**Псевдокод:**
```
КЛАСС MultiCriteriaSearch:
    КОНСТРУКТОР(данные):
        this.data = данные
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ search(запросы):
        ВОЗВРАТ this.data.фильтр(элемент ->
            запросы.все(запрос -> {
                ПОЛЕ = запрос.field
                ОПЕРАТОР = запрос.operator
                ЗНАЧЕНИЕ = запрос.value

                ВОЗВРАТ ВЫБОР:
                    СЛУЧАЙ 'equals':
                        элемент[ПОЛЕ] === ЗНАЧЕНИЕ
                    СЛУЧАЙ 'contains':
                        строка(элемент[ПОЛЕ]).в_нижнем_регистре.содержит(строка(ЗНАЧЕНИЕ).в_нижнем_регистре)
                    СЛУЧАЙ 'greaterThan':
                        элемент[ПОЛЕ] > ЗНАЧЕНИЕ
                    СЛУЧАЙ 'lessThan':
                        элемент[ПОЛЕ] < ЗНАЧЕНИЕ
                    СЛУЧАЙ 'in':
                        ЕСЛИ массив(ЗНАЧЕНИЕ) ТОГДА ЗНАЧЕНИЕ.содержит(элемент[ПОЛЕ]) ИНАЧЕ ЛОЖЬ
                    ИНАЧЕ:
                        ИСТИНА
            })
        )
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class MultiCriteriaSearch {
    constructor(data) {
        this.data = data;
    }

    search(queries) {
        return this.data.filter(item => {
            return queries.every(query => {
                const { field, operator, value } = query;

                switch (operator) {
                    case 'equals':
                        return item[field] === value;
                    case 'contains':
                        return String(item[field]).toLowerCase()
                            .includes(String(value).toLowerCase());
                    case 'greaterThan':
                        return item[field] > value;
                    case 'lessThan':
                        return item[field] < value;
                    case 'in':
                        return Array.isArray(value) ?
                            value.includes(item[field]) :
                            false;
                    default:
                        return true;
                }
            });
        });
    }
}

// Использование
const multiSearch = new MultiCriteriaSearch(products);
const results = multiSearch.search([
    { field: 'price', operator: 'greaterThan', value: 100 },
    { field: 'category', operator: 'equals', value: 'electronics' },
    { field: 'name', operator: 'contains', value: 'smart' }
]);
```

## Современные подходы в 2025 году

### 1. Поиск с использованием Web Workers

Для обработки больших объемов данных без блокировки UI:

**Псевдокод:**
```
// search-worker.js
ОН_СООБЩЕНИЕ = ФУНКЦИЯ(e):
    ДАННЫЕ = e.data.данные
    ПОИСКОВЫЙ_ТЕРМ = e.data.поисковый_термин

    // Выполнение поиска в воркере
    РЕЗУЛЬТАТЫ = ДАННЫЕ.фильтр(элемент ->
        элемент.name.в_нижнем_регистре.содержит(ПОИСКОВЫЙ_ТЕРМ.в_нижнем_регистре)
    )

    // Отправка результатов обратно
    ОТПРАВИТЬ_СООБЩЕНИЕ(РЕЗУЛЬТАТЫ)

// В основном потоке
КЛАСС WorkerSearch:
    КОНСТРУКТОР(данные):
        this.worker = новый Worker('search-worker.js')
        this.data = данные
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ search(поисковый_термин):
        ВОЗВРАТ НОВОЕ_ОБЕЩАНИЕ(разрешить ->
            this.worker.onmessage = ФУНКЦИЯ(e):
                разрешить(e.data)
            КОНЕЦ ФУНКЦИИ

            this.worker.postMessage({
                данные: this.data,
                поисковый_термин
            })
        )
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
// search-worker.js
self.onmessage = function(e) {
    const { data, searchTerm } = e.data;

    // Выполнение поиска в воркере
    const results = data.filter(item =>
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    // Отправка результатов обратно
    self.postMessage(results);
};

// В основном потоке
class WorkerSearch {
    constructor(data) {
        this.worker = new Worker('search-worker.js');
        this.data = data;
    }

    search(searchTerm) {
        return new Promise((resolve) => {
            this.worker.onmessage = function(e) {
                resolve(e.data);
            };

            this.worker.postMessage({
                data: this.data,
                searchTerm
            });
        });
    }
}
```

### 2. Поиск с машинным обучением (упрощенная реализация)

**Псевдокод:**
```
КЛАСС MLInfluencedSearch:
    КОНСТРУКТОР(данные):
        this.data = данные
        this.userBehavior = новый Map() // Хранение поведения пользователя
    КОНЕЦ КОНСТРУКТОРА

    // Регистрация взаимодействия пользователя
    ФУНКЦИЯ recordInteraction(userId, searchTerm, clickedItem):
        ЕСЛИ !this.userBehavior.содержит(userId):
            this.userBehavior.установить(userId, [])
        КОНЕЦ ЕСЛИ

        this.userBehavior.получить(userId).добавить({
            searchTerm,
            clickedItem,
            timestamp: текущее_время()
        })
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ search(userId, searchTerm):
        РЕЗУЛЬТАТЫ = this.data.фильтр(элемент ->
            элемент.name.в_нижнем_регистре.содержит(searchTerm.в_нижнем_регистре)
        )

        // Персонализация результатов на основе поведения
        USER_HISTORY = this.userBehavior.получить(userId) ИЛИ []

        ВОЗВРАТ РЕЗУЛЬТАТЫ.карта(элемент -> {
            СЧЕТ = 1 // Базовый счет

            // Повышение счета для часто кликаемых элементов
            CLICKED_COUNT = USER_HISTORY.фильтр(
                запись -> запись.clickedItem.id === элемент.id
            ).длина

            СЧЕТ += CLICKED_COUNT * 0.5

            ВОЗВРАТ { элемент, СЧЕТ }
        })
        .отсортировать((a, b) -> b.СЧЕТ - a.СЧЕТ)
        .карта(результат -> результат.элемент)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class MLInfluencedSearch {
    constructor(data) {
        this.data = data;
        this.userBehavior = new Map(); // Хранение поведения пользователя
    }

    // Регистрация взаимодействия пользователя
    recordInteraction(userId, searchTerm, clickedItem) {
        if (!this.userBehavior.has(userId)) {
            this.userBehavior.set(userId, []);
        }

        this.userBehavior.get(userId).push({
            searchTerm,
            clickedItem,
            timestamp: Date.now()
        });
    }

    search(userId, searchTerm) {
        const results = this.data.filter(item =>
            item.name.toLowerCase().includes(searchTerm.toLowerCase())
        );

        // Персонализация результатов на основе поведения
        const userHistory = this.userBehavior.get(userId) || [];

        return results.map(item => {
            let score = 1; // Базовый счет

            // Повышение счета для часто кликаемых элементов
            const clickedCount = userHistory.filter(
                record => record.clickedItem.id === item.id
            ).length;

            score += clickedCount * 0.5;

            return { item, score };
        })
        .sort((a, b) => b.score - a.score)
        .map(result => result.item);
    }
}
```

## Практические рекомендации

### 1. Оптимизация производительности

- Используйте индексы для часто используемых полей
- Реализуйте кэширование результатов поиска
- Применяйте дебаунсинг для поиска в реальном времени
- Используйте Web Workers для обработки больших данных

### 2. Оптимизация пользовательского опыта

**Псевдокод:**
```
// Дебаунсинг для поиска в реальном времени
ФУНКЦИЯ debounce(функция, задержка):
    ТАЙМЕР_ID = НЕОПРЕДЕЛЕНО
    ВОЗВРАТ ФУНКЦИЯ(...аргументы):
        очиститьТаймаут(ТАЙМЕР_ID)
        ТАЙМЕР_ID = установитьТаймаут(() -> функция.применить(ЭТО, аргументы), задержка)

// Использование
ДЕБАУНСЕД_ПОИСК = debounce((поисковый_термин) -> {
    выполнитьПоиск(поисковый_термин)
}, 300) // Задержка 300мс

// Обработка ввода
ПОЛУЧИТЬ_ЭЛЕМЕНТ('searchInput').addEventListener('input', (e) -> {
    ДЕБАУНСЕД_ПОИСК(e.target.value)
})
```

```javascript
// Дебаунсинг для поиска в реальном времени
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Использование
const debouncedSearch = debounce((searchTerm) => {
    performSearch(searchTerm);
}, 300); // Задержка 300мс

// Обработка ввода
document.getElementById('searchInput').addEventListener('input', (e) => {
    debouncedSearch(e.target.value);
});
```

### 3. Индикация загрузки

**Псевдокод:**
```
КЛАСС SearchWithLoading:
    КОНСТРУКТОР(функция_поиска):
        this.searchFunction = функция_поиска
        this.loadingElement = ПОЛУЧИТЬ_ЭЛЕМЕНТ('loading')
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ search(поисковый_термин):
        показатьЗагрузку()

        ПОПЫТКА:
            РЕЗУЛЬТАТЫ = АСИНХРОННО вызвать this.searchFunction(поисковый_термин)
            ВОЗВРАТ РЕЗУЛЬТАТЫ
        НАКОНЕЦ:
            скрытьЗагрузку()
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ showLoading():
        this.loadingElement.style.display = 'block'
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ hideLoading():
        this.loadingElement.style.display = 'none'
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SearchWithLoading {
    constructor(searchFunction) {
        this.searchFunction = searchFunction;
        this.loadingElement = document.getElementById('loading');
    }

    async search(searchTerm) {
        this.showLoading();

        try {
            const results = await this.searchFunction(searchTerm);
            return results;
        } finally {
            this.hideLoading();
        }
    }

    showLoading() {
        this.loadingElement.style.display = 'block';
    }

    hideLoading() {
        this.loadingElement.style.display = 'none';
    }
}
```

## Заключение

Алгоритмы поиска в интерфейсах играют ключевую роль в современных веб-приложениях. Правильный выбор и реализация алгоритмов поиска позволяет создать интуитивно понятный и быстрый пользовательский интерфейс. Важно учитывать не только точность поиска, но и производительность, персонализацию и удобство использования.

## См. также

- [[Алгоритмы-сортировки-в-таблицах]]
- [[Алгоритмы-для-валидации]]
- [[Алгоритмы-оптимизации-рендеринга]]
- [[Алгоритмы-анимаций]]

## Теги

#frontend #algorithms #search #ui #javascript #performance #fuzzy-search #autocomplete