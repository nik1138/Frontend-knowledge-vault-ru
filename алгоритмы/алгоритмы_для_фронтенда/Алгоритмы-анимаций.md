---
aliases: [Animation Algorithms, Алгоритмы анимаций]
tags: [frontend, algorithms, animations, css, javascript, performance]
---

# Алгоритмы анимаций

## Введение

Алгоритмы анимаций являются важной частью современного фронтенд-развития, обеспечивая плавные переходы, интерактивность и улучшенный пользовательский опыт. Анимации играют ключевую роль в создании современных веб-приложений, помогая визуализировать изменения данных, направлять внимание пользователя и создавать эмоциональную связь с интерфейсом.

## Основные понятия анимаций

### Что такое анимация в веб-разработке?

Анимация в веб-разработке - это процесс изменения свойств элементов интерфейса во времени для создания иллюзии движения или плавного перехода. Это может включать изменение позиции, размера, цвета, прозрачности и других CSS-свойств.

### Типы анимаций

1. **CSS-анимации** - реализуются через CSS-свойства
2. **JavaScript-анимации** - контролируются через JavaScript
3. **Canvas-анимации** - создаются на элементе canvas
4. **SVG-анимации** - анимации векторной графики

## Основные алгоритмы анимаций

### 1. Алгоритм линейной интерполяции (Lerp)

Самый простой алгоритм, который линейно изменяет значение от начального к конечному:

**Псевдокод:**
```
ФУНКЦИЯ linearInterpolation(начало, конец, прогресс):
    НАЧАЛО
        ВОЗВРАТ начало + (конец - начало) * прогресс
    КОНЕЦ

ФУНКЦИЯ animatePosition(элемент, startX, endX, duration):
    startTime = performance.now()

    ФУНКЦИЯ step(currentTime):
        elapsed = currentTime - startTime
        progress = min(elapsed / duration, 1)
        currentPosition = linearInterpolation(startX, endX, progress)
        элемент.style.left = currentPosition + 'px'

        ЕСЛИ progress < 1:
            requestAnimationFrame(step)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ

    requestAnimationFrame(step)
КОНЕЦ ФУНКЦИИ
```

```javascript
function linearInterpolation(start, end, progress) {
    return start + (end - start) * progress;
}

// Пример анимации перемещения
function animatePosition(element, startX, endX, duration) {
    const startTime = performance.now();

    function step(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const currentPosition = linearInterpolation(startX, endX, progress);
        element.style.left = currentPosition + 'px';

        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }

    requestAnimationFrame(step);
}
```

### 2. Алгоритмы плавности (Easing Functions)

Функции плавности позволяют создавать более естественные анимации:

**Псевдокод:**
```
КЛАСС EasingFunctions:
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInQuad(t): ВОЗВРАТ t * t
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeOutQuad(t): ВОЗВРАТ t * (2 - t)
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInOutQuad(t):
        ВОЗВРАТ ЕСЛИ t < 0.5 ТОГДА 2 * t * t ИНАЧЕ -1 + (4 - 2 * t) * t

    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInCubic(t): ВОЗВРАТ t * t * t
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeOutCubic(t): ВОЗВРАТ (--t) * t * t + 1
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInOutCubic(t):
        ВОЗВРАТ ЕСЛИ t < 0.5 ТОГДА 4 * t * t * t ИНАЧЕ (t - 1) * (2 * t - 2) * (2 * t - 2) + 1

    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInSine(t): ВОЗВРАТ 1 - cos(t * π / 2)
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeOutSine(t): ВОЗВРАТ sin(t * π / 2)
    СТАТИЧЕСКАЯ ФУНКЦИЯ easeInOutSine(t): ВОЗВРАТ -(cos(π * t) - 1) / 2

    СТАТИЧЕСКАЯ ФУНКЦИЯ easeOutElastic(t):
        c4 = (2 * π) / 3
        ВОЗВРАТ ЕСЛИ t === 0 ТОГДА 0 ИНАЧЕ ЕСЛИ t === 1 ТОГДА 1 ИНАЧЕ pow(2, -10 * t) * sin((t * 10 - 0.75) * c4) + 1
КОНЕЦ КЛАССА

ФУНКЦИЯ animateWithEasing(элемент, начало, конец, длительность, функция_плавности):
    startTime = performance.now()

    ФУНКЦИЯ step(currentTime):
        elapsed = currentTime - startTime
        rawProgress = min(elapsed / длительность, 1)
        easedProgress = функция_плавности(rawProgress)
        currentValue = linearInterpolation(начало, конец, easedProgress)
        элемент.style.opacity = currentValue

        ЕСЛИ rawProgress < 1:
            requestAnimationFrame(step)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ

    requestAnimationFrame(step)
КОНЕЦ ФУНКЦИИ
```

```javascript
class EasingFunctions {
    // Квадратичная плавность
    static easeInQuad(t) { return t * t; }
    static easeOutQuad(t) { return t * (2 - t); }
    static easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    // Кубическая плавность
    static easeInCubic(t) { return t * t * t; }
    static easeOutCubic(t) { return (--t) * t * t + 1; }
    static easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }

    // Синусоидальная плавность
    static easeInSine(t) { return 1 - Math.cos(t * Math.PI / 2); }
    static easeOutSine(t) { return Math.sin(t * Math.PI / 2); }
    static easeInOutSine(t) { return -(Math.cos(Math.PI * t) - 1) / 2; }

    // Эластичная плавность
    static easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }
}

// Применение функции плавности
function animateWithEasing(element, start, end, duration, easingFunction) {
    const startTime = performance.now();

    function step(currentTime) {
        const elapsed = currentTime - startTime;
        const rawProgress = Math.min(elapsed / duration, 1);
        const easedProgress = easingFunction(rawProgress);

        const currentValue = linearInterpolation(start, end, easedProgress);
        element.style.opacity = currentValue;

        if (rawProgress < 1) {
            requestAnimationFrame(step);
        }
    }

    requestAnimationFrame(step);
}
```


### 3. Алгоритм пружинной анимации (Spring Animation)

Имитирует физическое поведение пружины:

**Псевдокод:**
```
КЛАСС SpringAnimation:
    КОНСТРУКТОР(элемент, конфиг = {}):
        this.element = элемент
        this.stiffness = конфиг.stiffness ИЛИ 0.2  // Жесткость пружины
        this.damping = конфиг.damping ИЛИ 0.8      // Затухание
        this.mass = конфиг.mass ИЛИ 1              // Масса
        this.velocity = конфиг.velocity ИЛИ 0      // Начальная скорость
        this.target = конфиг.target ИЛИ 0          // Целевое значение
        this.current = конфиг.current ИЛИ 0        // Текущее значение
        this.onUpdate = конфиг.onUpdate ИЛИ () -> {}
        this.onComplete = конфиг.onComplete ИЛИ () -> {}
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ update():
        // Физические вычисления
        сила = (this.target - this.current) * this.stiffness
        сила_затухания = -this.velocity * this.damping
        ускорение = (сила + сила_затухания) / this.mass

        this.velocity += ускорение
        this.current += this.velocity

        // Применение значения
        this.onUpdate(this.current)

        // Проверка завершения анимации
        завершена = модуль(this.velocity) < 0.001 И
                   модуль(this.target - this.current) < 0.001

        ЕСЛИ !завершена:
            requestAnimationFrame(() -> this.update())
        ИНАЧЕ:
            this.onComplete()
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ start():
        this.update()
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SpringAnimation {
    constructor(element, config = {}) {
        this.element = element;
        this.stiffness = config.stiffness || 0.2;  // Жесткость пружины
        this.damping = config.damping || 0.8;      // Затухание
        this.mass = config.mass || 1;              // Масса
        this.velocity = config.velocity || 0;      // Начальная скорость
        this.target = config.target || 0;          // Целевое значение
        this.current = config.current || 0;        // Текущее значение
        this.onUpdate = config.onUpdate || (() => {});
        this.onComplete = config.onComplete || (() => {});
    }

    update() {
        // Физические вычисления
        const force = (this.target - this.current) * this.stiffness;
        const dampingForce = -this.velocity * this.damping;
        const acceleration = (force + dampingForce) / this.mass;

        this.velocity += acceleration;
        this.current += this.velocity;

        // Применение значения
        this.onUpdate(this.current);

        // Проверка завершения анимации
        const isComplete = Math.abs(this.velocity) < 0.001 &&
                          Math.abs(this.target - this.current) < 0.001;

        if (!isComplete) {
            requestAnimationFrame(() => this.update());
        } else {
            this.onComplete();
        }
    }

    start() {
        this.update();
    }
}

// Использование
const spring = new SpringAnimation(element, {
    target: 100,
    current: 0,
    onUpdate: (value) => {
        element.style.left = value + 'px';
    },
    onComplete: () => {
        console.log('Анимация завершена');
    }
});
spring.start();
```


### 4. Алгоритм анимации по кривой Безье

Для создания сложных траекторий анимации:

**Псевдокод:**
```
КЛАСС BezierAnimation:
    СТАТИЧЕСКАЯ ФУНКЦИЯ quadraticBezier(p0, p1, p2, t):
        u = 1 - t
        tt = t * t
        uu = u * u
        ut2 = 2 * u * t

        ВОЗВРАТ {
            x: uu * p0.x + ut2 * p1.x + tt * p2.x,
            y: uu * p0.y + ut2 * p1.y + tt * p2.y
        }
    КОНЕЦ ФУНКЦИИ

    СТАТИЧЕСКАЯ ФУНКЦИЯ cubicBezier(p0, p1, p2, p3, t):
        u = 1 - t
        tt = t * t
        uu = u * u
        uuu = uu * u
        ttt = tt * t
        ut3 = 3 * u * tt
        uut3 = 3 * uu * t

        ВОЗВРАТ {
            x: uuu * p0.x + ut3 * p1.x + uut3 * p2.x + ttt * p3.x,
            y: uuu * p0.y + ut3 * p1.y + uut3 * p2.y + ttt * p3.y
        }
    КОНЕЦ ФУНКЦИИ

    СТАТИЧЕСКАЯ ФУНКЦИЯ animate(элемент, точки, длительность):
        startTime = performance.now()

        ФУНКЦИЯ step(currentTime):
            elapsed = currentTime - startTime
            progress = min(elapsed / длительность, 1)

            позиция = cubicBezier(точки[0], точки[1], точки[2], точки[3], progress)

            элемент.style.left = позиция.x + 'px'
            элемент.style.top = позиция.y + 'px'

            ЕСЛИ progress < 1:
                requestAnimationFrame(step)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ФУНКЦИИ

        requestAnimationFrame(step)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class BezierAnimation {
    static quadraticBezier(p0, p1, p2, t) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const ut2 = 2 * u * t;

        return {
            x: uu * p0.x + ut2 * p1.x + tt * p2.x,
            y: uu * p0.y + ut2 * p1.y + tt * p2.y
        };
    }

    static cubicBezier(p0, p1, p2, p3, t) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * t;
        const ut3 = 3 * u * tt;
        const uut3 = 3 * uu * t;

        return {
            x: uuu * p0.x + ut3 * p1.x + uut3 * p2.x + ttt * p3.x,
            y: uuu * p0.y + ut3 * p1.y + uut3 * p2.y + ttt * p3.y
        };
    }

    static animate(element, points, duration) {
        const startTime = performance.now();

        function step(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            const position = BezierAnimation.cubicBezier(
                points[0], points[1], points[2], points[3], progress
            );

            element.style.left = position.x + 'px';
            element.style.top = position.y + 'px';

            if (progress < 1) {
                requestAnimationFrame(step);
            }
        }

        requestAnimationFrame(step);
    }
}

// Пример использования
const points = [
    { x: 0, y: 0 },      // Начальная точка
    { x: 50, y: 100 },   // Контрольная точка 1
    { x: 150, y: 50 },   // Контрольная точка 2
    { x: 200, y: 200 }   // Конечная точка
];

BezierAnimation.animate(element, points, 2000);
```

## Алгоритмы групповой анимации

### 1. Последовательная анимация

**Псевдокод:**
```
КЛАСС SequentialAnimation:
    КОНСТРУКТОР(анимации):
        this.animations = анимации
        this.currentIndex = 0
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ start():
        ДЛЯ i ОТ 0 ДО длина(this.animations) - 1:
            ЖДАТЬ runSingleAnimation(this.animations[i])
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ runSingleAnimation(анимация):
        ВОЗВРАТ НОВОЕ_ОБЕЩАНИЕ((разрешить) -> {
            // Выполняем анимацию и вызываем разрешить по завершении
            анимация.onComplete = разрешить
            анимация.start()
        })
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SequentialAnimation {
    constructor(animations) {
        this.animations = animations;
        this.currentIndex = 0;
    }

    async start() {
        for (let i = 0; i < this.animations.length; i++) {
            await this.runSingleAnimation(this.animations[i]);
        }
    }

    runSingleAnimation(animation) {
        return new Promise((resolve) => {
            // Выполняем анимацию и вызываем resolve по завершении
            animation.onComplete = resolve;
            animation.start();
        });
    }
}
```

### 2. Параллельная анимация

**Псевдокод:**
```
КЛАСС ParallelAnimation:
    КОНСТРУКТОР(анимации):
        this.animations = анимации
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ start():
        промисы = this.animations.карта(анимация -> {
            ВОЗВРАТ НОВОЕ_ОБЕЩАНИЕ((разрешить) -> {
                анимация.onComplete = разрешить
                анимация.start()
            })
        })

        ВОЗВРАТ Promise.all(промисы)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class ParallelAnimation {
    constructor(animations) {
        this.animations = animations;
    }

    start() {
        const promises = this.animations.map(anim => {
            return new Promise((resolve) => {
                anim.onComplete = resolve;
                anim.start();
            });
        });

        return Promise.all(promises);
    }
}
```

### 3. Анимация с каскадным эффектом

**Псевдокод:**
```
КЛАСС StaggeredAnimation:
    КОНСТРУКТОР(элементы, фабрика_анимации, задержка_каскада = 100):
        this.elements = элементы
        this.animationFactory = фабрика_анимации
        this.staggerDelay = задержка_каскада
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ start():
        ДЛЯ (i ОТ 0 ДО длина(this.elements)):
            элемент = this.elements[i]
            установитьТаймаут(() -> {
                анимация = this.animationFactory(элемент)
                анимация.start()
            }, i * this.staggerDelay)
        КОНЕЦ ДЛЯ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class StaggeredAnimation {
    constructor(elements, animationFactory, staggerDelay = 100) {
        this.elements = elements;
        this.animationFactory = animationFactory;
        this.staggerDelay = staggerDelay;
    }

    start() {
        this.elements.forEach((element, index) => {
            setTimeout(() => {
                const animation = this.animationFactory(element);
                animation.start();
            }, index * this.staggerDelay);
        });
    }
}

// Пример использования
const elements = document.querySelectorAll('.item');
const staggered = new StaggeredAnimation(elements, (element) => {
    return new SpringAnimation(element, {
        target: 100,
        current: 0,
        onUpdate: (value) => {
            element.style.transform = `translateX(${value}px)`;
        }
    });
});
staggered.start();
```

## Современные алгоритмы анимаций

### 1. Физически основанные анимации

**Псевдокод:**
```
КЛАСС PhysicsBasedAnimation:
    КОНСТРУКТОР(элемент, конфиг):
        this.element = элемент
        this.config = {
            gravity: конфиг.gravity ИЛИ 9.8,
            friction: конфиг.friction ИЛИ 0.95,
            bounce: конфиг.bounce ИЛИ 0.7,
            ...конфиг
        }
        this.velocity = { x: 0, y: 0 }
        this.position = { x: 0, y: 0 }
        this.target = { x: 0, y: 0 }
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ update():
        // Применение сил
        dx = this.target.x - this.position.x
        dy = this.target.y - this.position.y

        // Ускорение пропорционально расстоянию до цели
        this.velocity.x += dx * 0.1
        this.velocity.y += dy * 0.1

        // Применение трения
        this.velocity.x *= this.config.friction
        this.velocity.y *= this.config.friction

        // Обновление позиции
        this.position.x += this.velocity.x
        this.position.y += this.velocity.y

        // Применение к элементу
        this.element.style.transform = `translate(${this.position.x}px, ${this.position.y}px)`

        // Продолжаем анимацию, если движение еще не завершено
        ЕСЛИ модуль(this.velocity.x) > 0.1 ИЛИ модуль(this.velocity.y) > 0.1:
            requestAnimationFrame(() -> this.update())
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ moveTo(x, y):
        this.target.x = x
        this.target.y = y
        this.update()
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class PhysicsBasedAnimation {
    constructor(element, config) {
        this.element = element;
        this.config = {
            gravity: config.gravity || 9.8,
            friction: config.friction || 0.95,
            bounce: config.bounce || 0.7,
            ...config
        };
        this.velocity = { x: 0, y: 0 };
        this.position = { x: 0, y: 0 };
        this.target = { x: 0, y: 0 };
    }

    update() {
        // Применение сил
        const dx = this.target.x - this.position.x;
        const dy = this.target.y - this.position.y;

        // Ускорение пропорционально расстоянию до цели
        this.velocity.x += dx * 0.1;
        this.velocity.y += dy * 0.1;

        // Применение трения
        this.velocity.x *= this.config.friction;
        this.velocity.y *= this.config.friction;

        // Обновление позиции
        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;

        // Применение к элементу
        this.element.style.transform = `translate(${this.position.x}px, ${this.position.y}px)`;

        // Продолжаем анимацию, если движение еще не завершено
        if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
            requestAnimationFrame(() => this.update());
        }
    }

    moveTo(x, y) {
        this.target.x = x;
        this.target.y = y;
        this.update();
    }
}
```

### 2. Адаптивные анимации (с учетом предпочтений пользователя)

**Псевдокод:**
```
КЛАСС AdaptiveAnimation:
    КОНСТРУКТОР():
        // Проверяем предпочтения пользователя по анимациям
        this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
        this.animationSpeed = ЕСЛИ this.reducedMotion ТОГДА 0 ИНАЧЕ 1 // Отключаем анимации при предпочтении без анимаций
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ animate(элемент, начало, конец, длительность, функция_плавности):
        ЕСЛИ this.reducedMotion:
            // При предпочтении без анимаций - мгновенное изменение
            элемент.style.transform = `translateX(${конец}px)`
            ВОЗВРАТ Promise.resolve()
        КОНЕЦ ЕСЛИ

        // Нормальная анимация
        ВОЗВРАТ НОВОЕ_ОБЕЩАНИЕ((разрешить) -> {
            animateWithEasing(элемент, начало, конец, длительность * this.animationSpeed, функция_плавности)
            установитьТаймаут(разрешить, длительность * this.animationSpeed)
        })
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class AdaptiveAnimation {
    constructor() {
        // Проверяем предпочтения пользователя по анимациям
        this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        this.animationSpeed = this.reducedMotion ? 0 : 1; // Отключаем анимации при предпочтении без анимаций
    }

    animate(element, start, end, duration, easingFunction) {
        if (this.reducedMotion) {
            // При предпочтении без анимаций - мгновенное изменение
            element.style.transform = `translateX(${end}px)`;
            return Promise.resolve();
        }

        // Нормальная анимация
        return new Promise((resolve) => {
            animateWithEasing(element, start, end, duration * this.animationSpeed, easingFunction);
            setTimeout(resolve, duration * this.animationSpeed);
        });
    }
}
```

### 3. Анимации с машинным обучением (предсказание пользовательских действий)

**Псевдокод:**
```
КЛАСС PredictiveAnimation:
    КОНСТРУКТОР():
        this.actionHistory = []
        this.predictionThreshold = 0.7 // Порог уверенности для предсказания
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ recordAction(действие):
        this.actionHistory.добавить({
            действие,
            timestamp: текущее_время()
        })

        // Ограничиваем историю до последних 50 действий
        ЕСЛИ длина(this.actionHistory) > 50:
            this.actionHistory.удалить(0)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ predictNextAction():
        // Простой алгоритм: предсказываем следующее действие на основе последних действий
        ЕСЛИ длина(this.actionHistory) < 5:
            ВОЗВРАТ НЕОПРЕДЕЛЕНО
        КОНЕЦ ЕСЛИ

        // Подсчет частоты действий
        actionCounts = {}
        this.actionHistory.взять(-10).каждый(запись -> {
            actionCounts[запись.action] = (actionCounts[запись.action] ИЛИ 0) + 1
        })

        // Находим наиболее частое действие
        predictedAction = НЕОПРЕДЕЛЕНО
        maxCount = 0

        ДЛЯ каждой (действие, count) в entries(actionCounts):
            ЕСЛИ count > maxCount:
                maxCount = count
                predictedAction = действие
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        // Возвращаем предсказание с вероятностью
        ВОЗВРАТ {
            action: predictedAction,
            probability: maxCount / 10
        }
    КОНЕЦ ФУНКЦИИ

    АСИНХРОННАЯ ФУНКЦИЯ prepareForAction(действие):
        // Предварительная загрузка анимации для предсказанного действия
        ЕСЛИ действие.probability > this.predictionThreshold:
            // Подготовка к предсказанному действию (например, предзагрузка ресурсов)
            ВЫВЕСТИ_В_КОНСОЛЬ(`Подготовка к действию: ${действие.action} (вероятность: ${действие.probability})`)
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class PredictiveAnimation {
    constructor() {
        this.actionHistory = [];
        this.predictionThreshold = 0.7; // Порог уверенности для предсказания
    }

    recordAction(action) {
        this.actionHistory.push({
            action,
            timestamp: Date.now()
        });

        // Ограничиваем историю до последних 50 действий
        if (this.actionHistory.length > 50) {
            this.actionHistory.shift();
        }
    }

    predictNextAction() {
        // Простой алгоритм: предсказываем следующее действие на основе последних действий
        if (this.actionHistory.length < 5) return null;

        // Подсчет частоты действий
        const actionCounts = {};
        this.actionHistory.slice(-10).forEach(record => {
            actionCounts[record.action] = (actionCounts[record.action] || 0) + 1;
        });

        // Находим наиболее частое действие
        let predictedAction = null;
        let maxCount = 0;

        for (const [action, count] of Object.entries(actionCounts)) {
            if (count > maxCount) {
                maxCount = count;
                predictedAction = action;
            }
        }

        // Возвращаем предсказание с вероятностью
        return {
            action: predictedAction,
            probability: maxCount / 10
        };
    }

    async prepareForAction(action) {
        // Предварительная загрузка анимации для предсказанного действия
        if (action.probability > this.predictionThreshold) {
            // Подготовка к предсказанному действию (например, предзагрузка ресурсов)
            console.log(`Подготовка к действию: ${action.action} (вероятность: ${action.probability})`);
        }
    }
}
```

## Оптимизация анимаций

### 1. Использование requestAnimationFrame

**Псевдокод:**
```
КЛАСС OptimizedAnimation:
    КОНСТРУКТОР():
        this.animationId = НЕОПРЕДЕЛЕНО
        this.isRunning = ЛОЖЬ
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ start(функция_анимации):
        ЕСЛИ this.isRunning:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        this.isRunning = ИСТИНА
        АНИМИРОВАТЬ = () -> {
            функция_анимации()
            ЕСЛИ this.isRunning:
                this.animationId = requestAnimationFrame(АНИМИРОВАТЬ)
            КОНЕЦ ЕСЛИ
        }
        this.animationId = requestAnimationFrame(АНИМИРОВАТЬ)
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ stop():
        ЕСЛИ this.animationId:
            cancelAnimationFrame(this.animationId)
            this.isRunning = ЛОЖЬ
        КОНЕЦ ЕСЛИ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class OptimizedAnimation {
    constructor() {
        this.animationId = null;
        this.isRunning = false;
    }

    start(animationFunction) {
        if (this.isRunning) return;

        this.isRunning = true;
        const animate = () => {
            animationFunction();
            if (this.isRunning) {
                this.animationId = requestAnimationFrame(animate);
            }
        };
        this.animationId = requestAnimationFrame(animate);
    }

    stop() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.isRunning = false;
        }
    }
}
```

### 2. Оптимизация CSS-свойств для анимаций

**Псевдокод:**
```
// Оптимальные свойства для анимаций (используют GPU)
СТИЛИ .optimized-animation:
    НАЧАЛО
        // Эти свойства оптимизированы браузером
        transform: translateX(100px)
        opacity: 0.5
        will-change: transform, opacity
    КОНЕЦ

// Избегайте анимации свойств, вызывающих layout
СТИЛИ .avoid-animation:
    НАЧАЛО
        // width, height, top, left, margin, padding - плохо для анимации
    КОНЕЦ
```

```css
/* Оптимальные свойства для анимаций (используют GPU) */
.optimized-animation {
    /* Эти свойства оптимизированы браузером */
    transform: translateX(100px);
    opacity: 0.5;
    will-change: transform, opacity;
}

/* Избегайте анимации свойств, вызывающих layout */
.avoid-animation {
    /* width, height, top, left, margin, padding - плохо для анимации */
}
```

### 3. Использование CSS-анимаций для простых случаев

**Псевдокод:**
```
КЛАСС CSSAnimationHelper:
    СТАТИЧЕСКАЯ ФУНКЦИЯ fadeOut(элемент, длительность = 300):
        элемент.style.transition = `opacity ${длительность}ms ease-in-out`
        элемент.style.opacity = '0'

    СТАТИЧЕСКАЯ ФУНКЦИЯ slideIn(элемент, направление = 'left', длительность = 300):
        translateValue = ЕСЛИ направление === 'left' ТОГДА '-100%' ИНАЧЕ '100%'
        элемент.style.transform = `translateX(${translateValue})`
        элемент.style.transition = `transform ${длительность}ms ease-out`

        // Принудительно вызываем reflow
        элемент.offsetHeight

        элемент.style.transform = 'translateX(0)'

    СТАТИЧЕСКАЯ ФУНКЦИЯ pulse(элемент, длительность = 600):
        элемент.style.animation = `pulse ${длительность}ms ease-in-out`
КОНЕЦ КЛАССА
```

```javascript
// Простые анимации лучше реализовывать через CSS
class CSSAnimationHelper {
    static fadeOut(element, duration = 300) {
        element.style.transition = `opacity ${duration}ms ease-in-out`;
        element.style.opacity = '0';
    }

    static slideIn(element, direction = 'left', duration = 300) {
        const translateValue = direction === 'left' ? '-100%' : '100%';
        element.style.transform = `translateX(${translateValue})`;
        element.style.transition = `transform ${duration}ms ease-out`;

        // Принудительно вызываем reflow
        element.offsetHeight;

        element.style.transform = 'translateX(0)';
    }

    static pulse(element, duration = 600) {
        element.style.animation = `pulse ${duration}ms ease-in-out`;
    }
}
```

## Практические рекомендации

### 1. Измерение производительности анимаций

**Псевдокод:**
```
КЛАСС AnimationProfiler:
    КОНСТРУКТОР():
        this.frameCount = 0
        this.startTime = 0
        this.lastFrameTime = 0
        this.fps = 0
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ startProfiling():
        this.startTime = performance.now()
        this.lastFrameTime = this.startTime
        this.frameCount = 0

    ФУНКЦИЯ measureFrame():
        this.frameCount++
        currentTime = performance.now()
        frameTime = currentTime - this.lastFrameTime

        // Обновляем FPS каждые 10 кадров
        ЕСЛИ this.frameCount % 10 === 0:
            this.fps = 1000 / (currentTime - this.startTime) * this.frameCount
            ВЫВЕСТИ_В_КОНСОЛЬ(`FPS: ${округлить(this.fps)}`)
        КОНЕЦ ЕСЛИ

        this.lastFrameTime = currentTime

    ФУНКЦИЯ getStats():
        totalTime = performance.now() - this.startTime
        ВОЗВРАТ {
            fps: this.fps,
            frameCount: this.frameCount,
            totalTime: totalTime,
            averageFrameTime: totalTime / this.frameCount
        }
КОНЕЦ КЛАССА
```

```javascript
class AnimationProfiler {
    constructor() {
        this.frameCount = 0;
        this.startTime = 0;
        this.lastFrameTime = 0;
        this.fps = 0;
    }

    startProfiling() {
        this.startTime = performance.now();
        this.lastFrameTime = this.startTime;
        this.frameCount = 0;
    }

    measureFrame() {
        this.frameCount++;
        const currentTime = performance.now();
        const frameTime = currentTime - this.lastFrameTime;

        // Обновляем FPS каждые 10 кадров
        if (this.frameCount % 10 === 0) {
            this.fps = 1000 / (currentTime - this.startTime) * this.frameCount;
            console.log(`FPS: ${Math.round(this.fps)}`);
        }

        this.lastFrameTime = currentTime;
    }

    getStats() {
        const totalTime = performance.now() - this.startTime;
        return {
            fps: this.fps,
            frameCount: this.frameCount,
            totalTime: totalTime,
            averageFrameTime: totalTime / this.frameCount
        };
    }
}
```

### 2. Обработка прерываний анимаций

**Псевдокод:**
```
КЛАСС InterruptibleAnimation:
    КОНСТРУКТОР(элемент):
        this.element = элемент
        this.isInterrupted = ЛОЖЬ
        this.interruptCallbacks = []
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ interrupt():
        this.isInterrupted = ИСТИНА
        this.interruptCallbacks.каждый(функция -> функция())

    ФУНКЦИЯ addInterruptListener(функция):
        this.interruptCallbacks.добавить(функция)

    ФУНКЦИЯ animate(начало, конец, длительность, onProgress, onComplete):
        this.isInterrupted = ЛОЖЬ
        startTime = performance.now()

        ФУНКЦИЯ step(currentTime):
            ЕСЛИ this.isInterrupted:
                ВОЗВРАТ
            КОНЕЦ ЕСЛИ

            elapsed = currentTime - startTime
            progress = min(elapsed / длительность, 1)
            currentValue = linearInterpolation(начало, конец, progress)

            onProgress(currentValue)

            ЕСЛИ progress < 1:
                requestAnimationFrame(step)
            ИНАЧЕ ЕСЛИ !this.isInterrupted:
                onComplete()
            КОНЕЦ ЕСЛИ
        КОНЕЦ ФУНКЦИИ

        requestAnimationFrame(step)
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class InterruptibleAnimation {
    constructor(element) {
        this.element = element;
        this.isInterrupted = false;
        this.interruptCallbacks = [];
    }

    interrupt() {
        this.isInterrupted = true;
        this.interruptCallbacks.forEach(callback => callback());
    }

    addInterruptListener(callback) {
        this.interruptCallbacks.push(callback);
    }

    animate(start, end, duration, onProgress, onComplete) {
        this.isInterrupted = false;
        const startTime = performance.now();

        const step = (currentTime) => {
            if (this.isInterrupted) return;

            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const currentValue = linearInterpolation(start, end, progress);

            onProgress(currentValue);

            if (progress < 1) {
                requestAnimationFrame(step);
            } else if (!this.isInterrupted) {
                onComplete();
            }
        };

        requestAnimationFrame(step);
    }
}
```

### 3. Адаптация к производительности устройства

**Псевдокод:**
```
КЛАСС PerformanceAwareAnimation:
    КОНСТРУКТОР():
        this.performanceLevel = detectPerformanceLevel()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ detectPerformanceLevel():
        // Простая оценка производительности
        memoryInfo = performance.memory
        ЕСЛИ memoryInfo И memoryInfo.totalJSHeapSize:
            usage = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize
            ЕСЛИ usage > 0.8:
                ВОЗВРАТ 'low' // Высокое использование памяти
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

        // Проверка количества ядер процессора
        hardwareConcurrency = navigator.hardwareConcurrency ИЛИ 4
        ЕСЛИ hardwareConcurrency < 4:
            ВОЗВРАТ 'low'
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ 'high'

    ФУНКЦИЯ getAnimationSettings():
        ВОЗВРАТ ВЫБОР:
            СЛУЧАЙ 'low':
                {
                    durationMultiplier: 0.5, // Более быстрые анимации
                    complexity: 'simple',    // Простые анимации
                    quality: 'low'
                }
            ИНАЧЕ:
                {
                    durationMultiplier: 1,
                    complexity: 'complex',
                    quality: 'high'
                }
КОНЕЦ КЛАССА
```

```javascript
class PerformanceAwareAnimation {
    constructor() {
        this.performanceLevel = this.detectPerformanceLevel();
    }

    detectPerformanceLevel() {
        // Простая оценка производительности
        const memoryInfo = performance.memory;
        if (memoryInfo && memoryInfo.totalJSHeapSize) {
            const usage = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize;
            if (usage > 0.8) return 'low'; // Высокое использование памяти
        }

        // Проверка количества ядер процессора
        const hardwareConcurrency = navigator.hardwareConcurrency || 4;
        if (hardwareConcurrency < 4) return 'low';

        return 'high';
    }

    getAnimationSettings() {
        switch (this.performanceLevel) {
            case 'low':
                return {
                    durationMultiplier: 0.5, // Более быстрые анимации
                    complexity: 'simple',    // Простые анимации
                    quality: 'low'
                };
            default:
                return {
                    durationMultiplier: 1,
                    complexity: 'complex',
                    quality: 'high'
                };
        }
    }
}
```

## Заключение

Алгоритмы анимаций играют ключевую роль в создании современных и интерактивных веб-приложений. Важно не только создавать визуально привлекательные анимации, но и обеспечивать их производительность, доступность и адаптивность к различным условиям использования. Правильное применение алгоритмов анимаций позволяет улучшить пользовательский опыт и создать более интуитивно понятный интерфейс.

## См. также

- [[Алгоритмы-оптимизации-рендеринга]]
- [[Алгоритмы-анимаций]]
- [[Алгоритмы-для-работы-с-DOM]]
- [[Фреймворки-фронтенда]]

## Теги

#frontend #algorithms #animations #css #javascript #performance #ui #ux #easing