---
aliases: [Validation Algorithms, Алгоритмы валидации]
tags: [frontend, algorithms, validation, forms, javascript, security]
---

# Алгоритмы для валидации

## Введение

Алгоритмы валидации являются критически важной частью фронтенд-разработки, обеспечивая целостность данных, безопасность приложений и улучшенный пользовательский опыт. С увеличением сложности веб-приложений и ростом требований к безопасности, эффективные алгоритмы валидации становятся особенно важными. Они помогают предотвратить ввод некорректных данных, защищают от атак и обеспечивают согласованность информации в приложении.

## Основные понятия валидации

### Что такое валидация данных?

Валидация данных - это процесс проверки корректности, полноты и соответствия данных заданным правилам или ограничениям. В контексте фронтенд-разработки валидация обычно применяется к пользовательским вводам в формах, API-запросам и другим источникам данных.

### Типы валидации

1. **Клиентская валидация** - выполняется на стороне клиента (браузера)
2. **Серверная валидация** - выполняется на сервере (обязательна для безопасности)
3. **Синтаксическая валидация** - проверка формата данных
4. **Семантическая валидация** - проверка смысла и логики данных
5. **Бизнес-валидация** - проверка соответствия бизнес-правилам

## Базовые алгоритмы валидации

### 1. Алгоритм проверки обязательных полей

Самый простой алгоритм проверки на заполненность:

**Псевдокод:**
```
ФУНКЦИЯ validateRequired(значение):
    НАЧАЛО
        ЕСЛИ значение === null ИЛИ значение === undefined:
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ

        ЕСЛИ тип значения === 'строка':
            ВОЗВРАТ длина(значение.обрезать()) > 0
        КОНЕЦ ЕСЛИ

        ЕСЛИ массив(значение):
            ВОЗВРАТ длина(значение) > 0
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ Boolean(значение)
    КОНЕЦ

ФУНКЦИЯ validateForm(данные_формы):
    ОБЯЗАТЕЛЬНЫЕ_ПОЛЯ = ['name', 'email', 'password']
    ОШИБКИ = {}

    ДЛЯ каждого поля в ОБЯЗАТЕЛЬНЫЕ_ПОЛЯ:
        ЕСЛИ !validateRequired(данные_формы[поле]):
            ОШИБКИ[поле] = 'Это поле обязательно для заполнения'
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ ОШИБКИ
КОНЕЦ ФУНКЦИИ
```

**Псевдокод:**
```
ФУНКЦИЯ validateRequired(значение):
    НАЧАЛО
        ЕСЛИ значение === null ИЛИ значение === undefined:
            ВОЗВРАТ ЛОЖЬ
        КОНЕЦ ЕСЛИ

        ЕСЛИ тип значения === 'строка':
            ВОЗВРАТ длина(значение.обрезать()) > 0
        КОНЕЦ ЕСЛИ

        ЕСЛИ массив(значение):
            ВОЗВРАТ длина(значение) > 0
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ Boolean(значение)
    КОНЕЦ

ФУНКЦИЯ validateForm(данные_формы):
    ОБЯЗАТЕЛЬНЫЕ_ПОЛЯ = ['name', 'email', 'password']
    ОШИБКИ = {}

    ДЛЯ каждого поля в ОБЯЗАТЕЛЬНЫЕ_ПОЛЯ:
        ЕСЛИ !validateRequired(данные_формы[поле]):
            ОШИБКИ[поле] = 'Это поле обязательно для заполнения'
        КОНЕЦ ЕСЛИ
    КОНЕЦ ДЛЯ

    ВОЗВРАТ ОШИБКИ
КОНЕЦ ФУНКЦИИ
```

```javascript
function validateRequired(value) {
    if (value === null || value === undefined) {
        return false;
    }

    if (typeof value === 'string') {
        return value.trim().length > 0;
    }

    if (Array.isArray(value)) {
        return value.length > 0;
    }

    return Boolean(value);
}

// Пример использования
function validateForm(formData) {
    const requiredFields = ['name', 'email', 'password'];
    const errors = {};

    requiredFields.forEach(field => {
        if (!validateRequired(formData[field])) {
            errors[field] = 'Это поле обязательно для заполнения';
        }
    });

    return errors;
}
```


### 2. Алгоритм проверки формата email

**Псевдокод:**
```
ФУНКЦИЯ validateEmail(email):
    // Регулярное выражение для проверки email
    РЕГУЛЯРНОЕ_ВЫРАЖЕНИЕ = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    ВОЗВРАТ РЕГУЛЯРНОЕ_ВЫРАЖЕНИЕ.проверить(email)

ФУНКЦИЯ validateEmailStrict(email):
    ЕСЛИ !email ИЛИ тип email ≠ 'строка':
        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ ЕСЛИ

    // Проверка длины
    ЕСЛИ длина(email) > 254:
        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ ЕСЛИ

    // Проверка формата
    ЕСЛИ !validateEmail(email):
        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ ЕСЛИ

    // Проверка длины локальной части (до @)
    [локальная_часть, домен] = email.разделить('@')
    ЕСЛИ длина(локальная_часть) > 64:
        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ ЕСЛИ

    // Проверка на двойные точки
    ЕСЛИ email.содержит('..'):
        ВОЗВРАТ ЛОЖЬ
    КОНЕЦ ЕСЛИ

    ВОЗВРАТ ИСТИНА
КОНЕЦ ФУНКЦИИ
```

```javascript
function validateEmail(email) {
    // Регулярное выражение для проверки email
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return emailRegex.test(email);
}

// Более строгая проверка с дополнительными условиями
function validateEmailStrict(email) {
    if (!email || typeof email !== 'string') return false;

    // Проверка длины
    if (email.length > 254) return false;

    // Проверка формата
    if (!validateEmail(email)) return false;

    // Проверка длины локальной части (до @)
    const [localPart, domain] = email.split('@');
    if (localPart.length > 64) return false;

    // Проверка на двойные точки
    if (email.includes('..')) return false;

    return true;
}
```

### 3. Алгоритм проверки формата телефона

**Псевдокод:**
```
КЛАСС PhoneValidator:
    СТАТИЧЕСКАЯ ФУНКЦИЯ validate(телефон, код_страны = 'RU'):
        // Удаляем все нецифровые символы
        цифры = телефон.заменить(/\D/g, '')

        ВОЗВРАТ ВЫБОР:
            СЛУЧАЙ 'RU':
                // Российский формат: 10 или 11 цифр
                длина(цифры) === 10 ИЛИ (длина(цифры) === 11 И цифры[0] === '7')
            СЛУЧАЙ 'US':
                // Американский формат: 10 цифр
                длина(цифры) === 10
            СЛУЧАЙ 'DE':
                // Немецкий формат: 10-11 цифр
                длина(цифры) >= 10 И длина(цифры) <= 11
            ИНАЧЕ:
                // Общий случай: 7-15 цифр
                длина(цифры) >= 7 И длина(цифры) <= 15

    СТАТИЧЕСКАЯ ФУНКЦИЯ format(телефон, код_страны = 'RU'):
        цифры = телефон.заменить(/\D/g, '')

        ВОЗВРАТ ВЫБОР:
            СЛУЧАЙ 'RU':
                ЕСЛИ длина(цифры) === 11 И цифры[0] === '7':
                    `+7 (${цифры.подстрока(1, 4)}) ${цифры.подстрока(4, 7)}-${цифры.подстрока(7, 9)}-${цифры.подстрока(9, 11)}`
                ИНАЧЕ ЕСЛИ длина(цифры) === 10:
                    `+7 (${цифры.подстрока(0, 3)}) ${цифры.подстрока(3, 6)}-${цифры.подстрока(6, 8)}-${цифры.подстрока(8, 10)}`
                ИНАЧЕ:
                    телефон
            ИНАЧЕ:
                телефон
КОНЕЦ КЛАССА
```

```javascript
class PhoneValidator {
    static validate(phone, countryCode = 'RU') {
        // Удаляем все нецифровые символы
        const digits = phone.replace(/\D/g, '');

        switch (countryCode) {
            case 'RU':
                // Российский формат: 10 или 11 цифр
                return digits.length === 10 || (digits.length === 11 && digits[0] === '7');
            case 'US':
                // Американский формат: 10 цифр
                return digits.length === 10;
            case 'DE':
                // Немецкий формат: 10-11 цифр
                return digits.length >= 10 && digits.length <= 11;
            default:
                // Общий случай: 7-15 цифр
                return digits.length >= 7 && digits.length <= 15;
        }
    }

    static format(phone, countryCode = 'RU') {
        const digits = phone.replace(/\D/g, '');

        switch (countryCode) {
            case 'RU':
                if (digits.length === 11 && digits[0] === '7') {
                    return `+7 (${digits.substring(1, 4)}) ${digits.substring(4, 7)}-${digits.substring(7, 9)}-${digits.substring(9, 11)}`;
                } else if (digits.length === 10) {
                    return `+7 (${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6, 8)}-${digits.substring(8, 10)}`;
                }
                break;
            // Добавить другие форматы по необходимости
        }

        return phone;
    }
}
```

### 4. Алгоритм проверки сложности пароля

**Псевдокод:**
```
КЛАСС PasswordValidator:
    СТАТИЧЕСКАЯ ФУНКЦИЯ validate(пароль, опции = {}):
        СТАНДАРТНЫЕ_ОПЦИИ = {
            minLength: 8,
            requireUppercase: ИСТИНА,
            requireLowercase: ИСТИНА,
            requireNumbers: ИСТИНА,
            requireSpecialChars: ИСТИНА,
            minStrength: 0 // 0-4: very weak, weak, medium, strong, very strong
        }

        конфиг = объединить(СТАНДАРТНЫЕ_ОПЦИИ, опции)
        ОШИБКИ = []

        // Проверка минимальной длины
        ЕСЛИ длина(пароль) < конфиг.minLength:
            ОШИБКИ.добавить(`Пароль должен содержать не менее ${конфиг.minLength} символов`)
        КОНЕЦ ЕСЛИ

        // Проверка наличия заглавных букв
        ЕСЛИ конфиг.requireUppercase И !/[A-Z]/.проверить(пароль):
            ОШИБКИ.добавить('Пароль должен содержать хотя бы одну заглавную букву')
        КОНЕЦ ЕСЛИ

        // Проверка наличия строчных букв
        ЕСЛИ конфиг.requireLowercase И !/[a-z]/.проверить(пароль):
            ОШИБКИ.добавить('Пароль должен содержать хотя бы одну строчную букву')
        КОНЕЦ ЕСЛИ

        // Проверка наличия цифр
        ЕСЛИ конфиг.requireNumbers И !/\d/.проверить(пароль):
            ОШИБКИ.добавить('Пароль должен содержать хотя бы одну цифру')
        КОНЕЦ ЕСЛИ

        // Проверка наличия специальных символов
        ЕСЛИ конфиг.requireSpecialChars И !/[!@#$%^&*(),.?":{}|<>]/.проверить(пароль):
            ОШИБКИ.добавить('Пароль должен содержать хотя бы один специальный символ')
        КОНЕЦ ЕСЛИ

        // Проверка общеупотребительных паролей
        ЕСЛИ isCommonPassword(пароль):
            ОШИБКИ.добавить('Слишком простой пароль')
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ {
            isValid: длина(ОШИБКИ) === 0,
            ОШИБКИ,
            strength: calculateStrength(пароль)
        }
    КОНЕЦ ФУНКЦИИ

    СТАТИЧЕСКАЯ ФУНКЦИЯ calculateStrength(пароль):
        сила = 0

        // Длина
        ЕСЛИ длина(пароль) >= 8:
            сила++
        ЕСЛИ длина(пароль) >= 12:
            сила++

        // Разнообразие символов
        ЕСЛИ /[a-z]/.проверить(пароль):
            сила++
        ЕСЛИ /[A-Z]/.проверить(пароль):
            сила++
        ЕСЛИ /\d/.проверить(пароль):
            сила++
        ЕСЛИ /[!@#$%^&*(),.?":{}|<>]/.проверить(пароль):
            сила++

        // Уникальность
        уникальные_символы = новый Set(пароль)
        ЕСЛИ длина(уникальные_символы) / длина(пароль) > 0.7:
            сила++

        ВОЗВРАТ min(сила, 4)

    СТАТИЧЕСКАЯ ФУНКЦИЯ isCommonPassword(пароль):
        общеупотребительные_пароли = [
            'password', '123456', 'qwerty', 'admin', 'letmein',
            'welcome', 'monkey', '1234567890', 'abc123', 'password1'
        ]

        ВОЗВРАТ общеупотребительные_пароли.содержит(пароль.в_нижнем_регистре())
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class PasswordValidator {
    static validate(password, options = {}) {
        const defaultOptions = {
            minLength: 8,
            requireUppercase: true,
            requireLowercase: true,
            requireNumbers: true,
            requireSpecialChars: true,
            minStrength: 0 // 0-4: very weak, weak, medium, strong, very strong
        };

        const config = { ...defaultOptions, ...options };
        const errors = [];

        // Проверка минимальной длины
        if (password.length < config.minLength) {
            errors.push(`Пароль должен содержать не менее ${config.minLength} символов`);
        }

        // Проверка наличия заглавных букв
        if (config.requireUppercase && !/[A-Z]/.test(password)) {
            errors.push('Пароль должен содержать хотя бы одну заглавную букву');
        }

        // Проверка наличия строчных букв
        if (config.requireLowercase && !/[a-z]/.test(password)) {
            errors.push('Пароль должен содержать хотя бы одну строчную букву');
        }

        // Проверка наличия цифр
        if (config.requireNumbers && !/\d/.test(password)) {
            errors.push('Пароль должен содержать хотя бы одну цифру');
        }

        // Проверка наличия специальных символов
        if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
            errors.push('Пароль должен содержать хотя бы один специальный символ');
        }

        // Проверка общеупотребительных паролей
        if (this.isCommonPassword(password)) {
            errors.push('Слишком простой пароль');
        }

        return {
            isValid: errors.length === 0,
            errors,
            strength: this.calculateStrength(password)
        };
    }

    static calculateStrength(password) {
        let strength = 0;

        // Длина
        if (password.length >= 8) strength++;
        if (password.length >= 12) strength++;

        // Разнообразие символов
        if (/[a-z]/.test(password)) strength++;
        if (/[A-Z]/.test(password)) strength++;
        if (/\d/.test(password)) strength++;
        if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;

        // Уникальность
        const uniqueChars = new Set(password).size;
        if (uniqueChars / password.length > 0.7) strength++;

        return Math.min(strength, 4);
    }

    static isCommonPassword(password) {
        const commonPasswords = [
            'password', '123456', 'qwerty', 'admin', 'letmein',
            'welcome', 'monkey', '1234567890', 'abc123', 'password1'
        ];

        return commonPasswords.includes(password.toLowerCase());
    }
}
```

## Продвинутые алгоритмы валидации

### 1. Алгоритм валидации с использованием схем (Schema Validation)

**Псевдокод:**
```
КЛАСС SchemaValidator:
    КОНСТРУКТОР(схема):
        this.schema = схема
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ validate(данные):
        ОШИБКИ = {}

        ДЛЯ каждой (поле, правила) в entries(this.schema):
            значение = данные[поле]
            ОШИБКИ_ПОЛЯ = validateField(значение, правила, поле)

            ЕСЛИ длина(ОШИБКИ_ПОЛЯ) > 0:
                ОШИБКИ[поле] = ОШИБКИ_ПОЛЯ
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ {
            isValid: длина(keys(ОШИБКИ)) === 0,
            ОШИБКИ
        }
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ validateField(значение, правила, имя_поля):
        ОШИБКИ = []

        // Проверка на обязательность
        ЕСЛИ правила.required И !validateRequired(значение):
            ОШИБКИ.добавить(`${имя_поля} обязательно для заполнения`)
            ВОЗВРАТ ОШИБКИ // Если поле обязательно и не заполнено, дальше не проверяем
        КОНЕЦ ЕСЛИ

        // Пропускаем проверки, если поле не обязательно и пустое
        ЕСЛИ !правила.required И !validateRequired(значение):
            ВОЗВРАТ ОШИБКИ
        КОНЕЦ ЕСЛИ

        // Проверка типа
        ЕСЛИ правила.type:
            ЕСЛИ !validateType(значение, правила.type):
                ОШИБКИ.добавить(`${имя_поля} должно быть типа ${правила.type}`)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

        // Проверка длины для строк
        ЕСЛИ правила.minLength И тип значения === 'строка' И длина(значение) < правила.minLength:
            ОШИБКИ.добавить(`${имя_поля} должно содержать не менее ${правила.minLength} символов`)
        КОНЕЦ ЕСЛИ

        ЕСЛИ правила.maxLength И тип значения === 'строка' И длина(значение) > правила.maxLength:
            ОШИБКИ.добавить(`${имя_поля} должно содержать не более ${правила.maxLength} символов`)
        КОНЕЦ ЕСЛИ

        // Проверка числовых значений
        ЕСЛИ тип значения === 'число':
            ЕСЛИ правила.min ≠ undefined И значение < правила.min:
                ОШИБКИ.добавить(`${имя_поля} должно быть не менее ${правила.min}`)
            КОНЕЦ ЕСЛИ

            ЕСЛИ правила.max ≠ undefined И значение > правила.max:
                ОШИБКИ.добавить(`${имя_поля} должно быть не более ${правила.max}`)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

        // Пользовательская валидация
        ЕСЛИ правила.validator И тип правила.validator === 'функция':
            результат_проверки = правила.validator(значение)
            ЕСЛИ результат_проверки ≠ ИСТИНА:
                ОШИБКИ.добавить(результат_проверки ИЛИ `${имя_поля} содержит ошибку`)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ ОШИБКИ
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ validateType(значение, ожидаемый_тип):
        ВОЗВРАТ ВЫБОР:
            СЛУЧАЙ 'string':
                тип значения === 'строка'
            СЛУЧАЙ 'number':
                тип значения === 'число' И !isNaN(значение)
            СЛУЧАЙ 'boolean':
                тип значения === 'булево'
            СЛУЧАЙ 'array':
                массив(значение)
            СЛУЧАЙ 'object':
                тип значения === 'объект' И значение ≠ null И !массив(значение)
            СЛУЧАЙ 'email':
                validateEmail(значение)
            СЛУЧАЙ 'url':
                ПОПЫТКА:
                    новый URL(значение)
                    ИСТИНА
                ИСКЛЮЧЕНИЕ:
                    ЛОЖЬ
            ИНАЧЕ:
                ИСТИНА
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class SchemaValidator {
    constructor(schema) {
        this.schema = schema;
    }

    validate(data) {
        const errors = {};

        for (const [field, rules] of Object.entries(this.schema)) {
            const value = data[field];
            const fieldErrors = this.validateField(value, rules, field);

            if (fieldErrors.length > 0) {
                errors[field] = fieldErrors;
            }
        }

        return {
            isValid: Object.keys(errors).length === 0,
            errors
        };
    }

    validateField(value, rules, fieldName) {
        const errors = [];

        // Проверка на обязательность
        if (rules.required && !validateRequired(value)) {
            errors.push(`${fieldName} обязательно для заполнения`);
            return errors; // Если поле обязательно и не заполнено, дальше не проверяем
        }

        // Пропускаем проверки, если поле не обязательно и пустое
        if (!rules.required && !validateRequired(value)) {
            return errors;
        }

        // Проверка типа
        if (rules.type) {
            if (!this.validateType(value, rules.type)) {
                errors.push(`${fieldName} должно быть типа ${rules.type}`);
            }
        }

        // Проверка длины для строк
        if (rules.minLength && typeof value === 'string' && value.length < rules.minLength) {
            errors.push(`${fieldName} должно содержать не менее ${rules.minLength} символов`);
        }

        if (rules.maxLength && typeof value === 'string' && value.length > rules.maxLength) {
            errors.push(`${fieldName} должно содержать не более ${rules.maxLength} символов`);
        }

        // Проверка числовых значений
        if (typeof value === 'number') {
            if (rules.min !== undefined && value < rules.min) {
                errors.push(`${fieldName} должно быть не менее ${rules.min}`);
            }

            if (rules.max !== undefined && value > rules.max) {
                errors.push(`${fieldName} должно быть не более ${rules.max}`);
            }
        }

        // Пользовательская валидация
        if (rules.validator && typeof rules.validator === 'function') {
            const customResult = rules.validator(value);
            if (customResult !== true) {
                errors.push(customResult || `${fieldName} содержит ошибку`);
            }
        }

        return errors;
    }

    validateType(value, expectedType) {
        switch (expectedType) {
            case 'string':
                return typeof value === 'string';
            case 'number':
                return typeof value === 'number' && !isNaN(value);
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && value !== null && !Array.isArray(value);
            case 'email':
                return validateEmail(value);
            case 'url':
                try {
                    new URL(value);
                    return true;
                } catch {
                    return false;
                }
            default:
                return true;
        }
    }
}

// Пример использования
const userSchema = new SchemaValidator({
    name: {
        type: 'string',
        required: true,
        minLength: 2,
        maxLength: 50
    },
    email: {
        type: 'string',
        required: true,
        validator: (value) => validateEmail(value) || 'Некорректный email'
    },
    age: {
        type: 'number',
        min: 18,
        max: 120
    },
    password: {
        type: 'string',
        required: true,
        validator: (value) => {
            const result = PasswordValidator.validate(value);
            return result.isValid || result.errors.join(', ');
        }
    }
});
```

### 2. Алгоритм валидации с асинхронными проверками

**Псевдокод:**
```
КЛАСС AsyncValidator:
    КОНСТРУКТОР():
        this.asyncRules = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ addAsyncRule(имя, функция_валидации):
        this.asyncRules.установить(имя, функция_валидации)

    АСИНХРОННАЯ ФУНКЦИЯ validate(данные, правила):
        ОШИБКИ = {}
        asyncResults = []

        ДЛЯ каждой (поле, правила_поля) в entries(правила):
            значение = данные[поле]

            // Синхронные проверки
            syncErrors = validateSync(значение, правила_поля, поле)
            ЕСЛИ длина(syncErrors) > 0:
                ОШИБКИ[поле] = syncErrors
                ПРОДОЛЖИТЬ // Если есть синхронные ошибки, не запускаем асинхронные
            КОНЕЦ ЕСЛИ

            // Асинхронные проверки
            ДЛЯ каждой правила в правила_поля.async ИЛИ []:
                ЕСЛИ this.asyncRules.содержит(правило):
                    asyncResults.добавить(
                        this.asyncRules.получить(правило)(значение, данные)
                            .then(результат -> { поле: поле, результат: результат, правило: правило })
                    )
                КОНЕЦ ЕСЛИ
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ

        // Ждем завершения всех асинхронных проверок
        asyncValidationResults = ЖДАТЬ Promise.all(asyncResults)

        ДЛЯ каждой { поле, результат, правило } в asyncValidationResults:
            ЕСЛИ результат ≠ ИСТИНА:
                ЕСЛИ !ОШИБКИ[поле]:
                    ОШИБКИ[поле] = []
                КОНЕЦ ЕСЛИ
                ОШИБКИ[поле].добавить(результат ИЛИ `Ошибка проверки ${правило}`)
            КОНЕЦ ЕСЛИ
        КОНЕЦ ДЛЯ

        ВОЗВРАТ {
            isValid: длина(keys(ОШИБКИ)) === 0,
            ОШИБКИ
        }
    КОНЕЦ ФУНКЦИИ

    ФУНКЦИЯ validateSync(значение, правила, имя_поля):
        ОШИБКИ = []

        ЕСЛИ правила.required И !validateRequired(значение):
            ОШИБКИ.добавить(`${имя_поля} обязательно для заполнения`)
            ВОЗВРАТ ОШИБКИ
        КОНЕЦ ЕСЛИ

        ЕСЛИ !правила.required И !validateRequired(значение):
            ВОЗВРАТ ОШИБКИ
        КОНЕЦ ЕСЛИ

        // Добавить другие синхронные проверки по необходимости
        ВОЗВРАТ ОШИБКИ
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class AsyncValidator {
    constructor() {
        this.asyncRules = new Map();
    }

    addAsyncRule(name, validatorFunction) {
        this.asyncRules.set(name, validatorFunction);
    }

    async validate(data, rules) {
        const errors = {};
        const asyncResults = [];

        for (const [field, fieldRules] of Object.entries(rules)) {
            const value = data[field];

            // Синхронные проверки
            const syncErrors = this.validateSync(value, fieldRules, field);
            if (syncErrors.length > 0) {
                errors[field] = syncErrors;
                continue; // Если есть синхронные ошибки, не запускаем асинхронные
            }

            // Асинхронные проверки
            for (const rule of fieldRules.async || []) {
                if (this.asyncRules.has(rule)) {
                    asyncResults.push(
                        this.asyncRules.get(rule)(value, data)
                            .then(result => ({ field, result, rule }))
                    );
                }
            }
        }

        // Ждем завершения всех асинхронных проверок
        const asyncValidationResults = await Promise.all(asyncResults);

        for (const { field, result, rule } of asyncValidationResults) {
            if (result !== true) {
                if (!errors[field]) {
                    errors[field] = [];
                }
                errors[field].push(result || `Ошибка проверки ${rule}`);
            }
        }

        return {
            isValid: Object.keys(errors).length === 0,
            errors
        };
    }

    validateSync(value, rules, fieldName) {
        const errors = [];

        if (rules.required && !validateRequired(value)) {
            errors.push(`${fieldName} обязательно для заполнения`);
            return errors;
        }

        if (!rules.required && !validateRequired(value)) {
            return errors;
        }

        // Добавить другие синхронные проверки по необходимости
        return errors;
    }
}

// Пример асинхронного правила
const asyncValidator = new AsyncValidator();

asyncValidator.addAsyncRule('uniqueEmail', async (email) => {
    // Имитация API-запроса для проверки уникальности email
    const response = await fetch(`/api/check-email?email=${encodeURIComponent(email)}`);
    const result = await response.json();

    return result.isUnique || 'Email уже используется';
});

asyncValidator.addAsyncRule('validDomain', async (email) => {
    const domain = email.split('@')[1];

    // Проверка существования домена
    const response = await fetch(`/api/check-domain?domain=${encodeURIComponent(domain)}`);
    const result = await response.json();

    return result.exists || 'Домен не существует';
});
```

### 3. Алгоритм валидации с использованием регулярных выражений

**Псевдокод:**
```
КЛАСС RegexValidator:
    СТАТИЧЕСКОЕ СВОЙСТВО patterns = {
        // Надежный паттерн для email (RFC 5322 compliant)
        email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
        // Паттерн для URL
        url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
        // Паттерн для номера кредитной карты (без пробелов)
        creditCard: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})$/,
        // Паттерн для даты в формате YYYY-MM-DD
        date: /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/,
        // Паттерн для IP-адреса (IPv4)
        ip: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
        // Паттерн для номера телефона (международный формат)
        phone: /^\+[1-9]\d{1,14}$/,
        // Паттерн для ИНН (российский)
        inn: /^\d{10}$|^\d{12}$/
    }

    СТАТИЧЕСКАЯ ФУНКЦИЯ validate(значение, имя_паттерна):
        ЕСЛИ !this.patterns[имя_паттерна]:
            ВОЗВРАТ ОШИБКА(`Паттерн ${имя_паттерна} не найден`)
        КОНЕЦ ЕСЛИ

        ВОЗВРАТ this.patterns[имя_паттерна].проверить(значение)

    // Расширенная валидация с кастомными паттернами
    СТАТИЧЕСКАЯ ФУНКЦИЯ addPattern(имя, паттерн):
        this.patterns[имя] = паттерн

    СТАТИЧЕСКАЯ ФУНКЦИЯ validateWithCustom(значение, customPattern):
        регулярное_выражение = новое RegExp(customPattern)
        ВОЗВРАТ регулярное_выражение.проверить(значение)
КОНЕЦ КЛАССА
```

```javascript
class RegexValidator {
    static patterns = {
        // Надежный паттерн для email (RFC 5322 compliant)
        email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,

        // Паттерн для URL
        url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,

        // Паттерн для номера кредитной карты (без пробелов)
        creditCard: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})$/,

        // Паттерн для даты в формате YYYY-MM-DD
        date: /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/,

        // Паттерн для IP-адреса (IPv4)
        ip: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,

        // Паттерн для номера телефона (международный формат)
        phone: /^\+[1-9]\d{1,14}$/,

        // Паттерн для ИНН (российский)
        inn: /^\d{10}$|^\d{12}$/
    };

    static validate(value, patternName) {
        if (!this.patterns[patternName]) {
            throw new Error(`Паттерн ${patternName} не найден`);
        }

        return this.patterns[patternName].test(value);
    }

    // Расширенная валидация с кастомными паттернами
    static addPattern(name, pattern) {
        this.patterns[name] = pattern;
    }

    static validateWithCustom(value, customPattern) {
        const regex = new RegExp(customPattern);
        return regex.test(value);
    }
}
```

## Алгоритмы безопасности валидации

### 1. Алгоритм защиты от XSS

**Псевдокод:**
```
КЛАСС XSSValidator:
    СТАТИЧЕСКАЯ ФУНКЦИЯ sanitize(ввод):
        ЕСЛИ тип ввод ≠ 'строка':
            ВОЗВРАТ ввод
        КОНЕЦ ЕСЛИ

        // Базовая очистка от потенциально опасных символов
        ВОЗВРАТ ввод
            .заменить(/&/g, '&amp;')
            .заменить(/</g, '&lt;')
            .заменить(/>/g, '&gt;')
            .заменить(/"/g, '&quot;')
            .заменить(/'/g, '&#x27;')
            .заменить(/\//g, '&#x2F;')

    СТАТИЧЕСКАЯ ФУНКЦИЯ validate(ввод):
        // Проверка на наличие потенциально опасных паттернов
        опасные_паттерны = [
            /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            /javascript:/gi,
            /vbscript:/gi,
            /on\w+\s*=/gi,
            /<iframe/gi,
            /<object/gi,
            /<embed/gi
        ]

        ВОЗВРАТ !опасные_паттерны.некоторые(паттерн -> паттерн.проверить(ввод))

    СТАТИЧЕСКАЯ ФУНКЦИЯ stripTags(ввод):
        ЕСЛИ тип ввод ≠ 'строка':
            ВОЗВРАТ ввод
        КОНЕЦ ЕСЛИ

        // Удаление HTML-тегов
        ВОЗВРАТ ввод.заменить(/<[^>]*>/g, '')
КОНЕЦ КЛАССА
```

```javascript
class XSSValidator {
    static sanitize(input) {
        if (typeof input !== 'string') return input;

        // Базовая очистка от потенциально опасных символов
        return input
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/\//g, '&#x2F;');
    }

    static validate(input) {
        // Проверка на наличие потенциально опасных паттернов
        const dangerousPatterns = [
            /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            /javascript:/gi,
            /vbscript:/gi,
            /on\w+\s*=/gi,
            /<iframe/gi,
            /<object/gi,
            /<embed/gi
        ];

        return !dangerousPatterns.some(pattern => pattern.test(input));
    }

    static stripTags(input) {
        if (typeof input !== 'string') return input;

        // Удаление HTML-тегов
        return input.replace(/<[^>]*>/g, '');
    }
}
```

### 2. Алгоритм защиты от SQL-инъекций

**Псевдокод:**
```
КЛАСС SQLInjectionValidator:
    СТАТИЧЕСКАЯ ФУНКЦИЯ validate(ввод):
        ЕСЛИ тип ввод ≠ 'строка':
            ВОЗВРАТ ИСТИНА
        КОНЕЦ ЕСЛИ

        // Проверка на потенциально опасные SQL-паттерны
        опасные_паттерны = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|OR|AND)\b)/gi,
            /(;|--|\/\*|\*\/|xp_|sp_|exec|execute)/gi,
            /('|")\s*(OR|AND)\s*=\s*('|")/gi
        ]

        ВОЗВРАТ !опасные_паттерны.некоторые(паттерн -> паттерн.проверить(ввод))

    СТАТИЧЕСКАЯ ФУНКЦИЯ escape(ввод):
        ЕСЛИ тип ввод ≠ 'строка':
            ВОЗВРАТ ввод
        КОНЕЦ ЕСЛИ

        // Экранирование специальных символов
        ВОЗВРАТ ввод
            .заменить(/'/g, "''")
            .заменить(/\\/g, "\\\\")
            .заменить(/\0/g, "\\0")
            .заменить(/\n/g, "\\n")
            .заменить(/\r/g, "\\r")
            .заменить(/\x1a/g, "\\Z")
КОНЕЦ КЛАССА
```

```javascript
class SQLInjectionValidator {
    static validate(input) {
        if (typeof input !== 'string') return true;

        // Проверка на потенциально опасные SQL-паттерны
        const dangerousPatterns = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|OR|AND)\b)/gi,
            /(;|--|\/\*|\*\/|xp_|sp_|exec|execute)/gi,
            /('|")\s*(OR|AND)\s*=\s*('|")/gi
        ];

        return !dangerousPatterns.some(pattern => pattern.test(input));
    }

    static escape(input) {
        if (typeof input !== 'string') return input;

        // Экранирование специальных символов
        return input
            .replace(/'/g, "''")
            .replace(/\\/g, "\\\\")
            .replace(/\0/g, "\\0")
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r")
            .replace(/\x1a/g, "\\Z");
    }
}
```

## Современные подходы в 2025 году

### 1. Валидация с использованием WebAssembly

**Псевдокод:**
```
// Заготовка для WASM-валидации (гипотетический пример)
КЛАСС WASMValidator:
    КОНСТРУКТОР():
        this.wasmModule = НЕОПРЕДЕЛЕНО
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ initialize():
        // Загрузка и инициализация WASM-модуля
        // В реальности это будет компилированная Rust/С++ библиотека
        ПОПЫТКА:
            wasmModule = ЖДАТЬ WebAssembly.instantiateStreaming(
                fetch('/validation.wasm')
            )
            this.wasmModule = wasmModule.instance
        ИСКЛЮЧЕНИЕ (ошибка):
            ВЫВЕСТИ_ПРЕДУПРЕЖДЕНИЕ('WASM валидация недоступна, используется JS-валидация')

    ФУНКЦИЯ validateWithWASM(данные, схема):
        ЕСЛИ !this.wasmModule:
            ВОЗВРАТ fallbackValidation(данные, схема)
        КОНЕЦ ЕСЛИ

        // Вызов WASM-функции валидации
        dataPtr = this.wasmModule.exports.malloc(длина(данные))
        schemaPtr = this.wasmModule.exports.malloc(длина(схема))

        // Копирование данных в WASM память
        новый Uint8Array(this.wasmModule.exports.memory.buffer, dataPtr, длина(данные))
            .установить(новый TextEncoder().кодировать(данные))
        новый Uint8Array(this.wasmModule.exports.memory.buffer, schemaPtr, длина(схема))
            .установить(новый TextEncoder().кодировать(схема))

        // Вызов функции валидации
        результат = this.wasmModule.exports.validate(dataPtr, schemaPtr)

        // Освобождение памяти
        this.wasmModule.exports.free(dataPtr)
        this.wasmModule.exports.free(schemaPtr)

        ВОЗВРАТ результат

    ФУНКЦИЯ fallbackValidation(данные, схема):
        // Резервная валидация на JavaScript
        ВОЗВРАТ новый SchemaValidator(схема).validate(данные)
КОНЕЦ КЛАССА
```

```javascript
// Заготовка для WASM-валидации (гипотетический пример)
class WASMValidator {
    constructor() {
        this.wasmModule = null;
    }

    async initialize() {
        // Загрузка и инициализация WASM-модуля
        // В реальности это будет компилированная Rust/С++ библиотека
        try {
            const wasmModule = await WebAssembly.instantiateStreaming(
                fetch('/validation.wasm')
            );
            this.wasmModule = wasmModule.instance;
        } catch (error) {
            console.warn('WASM валидация недоступна, используется JS-валидация');
        }
    }

    validateWithWASM(data, schema) {
        if (!this.wasmModule) {
            return this.fallbackValidation(data, schema);
        }

        // Вызов WASM-функции валидации
        const dataPtr = this.wasmModule.exports.malloc(data.length);
        const schemaPtr = this.wasmModule.exports.malloc(schema.length);

        // Копирование данных в WASM память
        new Uint8Array(this.wasmModule.exports.memory.buffer, dataPtr, data.length)
            .set(new TextEncoder().encode(data));
        new Uint8Array(this.wasmModule.exports.memory.buffer, schemaPtr, schema.length)
            .set(new TextEncoder().encode(schema));

        // Вызов функции валидации
        const result = this.wasmModule.exports.validate(dataPtr, schemaPtr);

        // Освобождение памяти
        this.wasmModule.exports.free(dataPtr);
        this.wasmModule.exports.free(schemaPtr);

        return result;
    }

    fallbackValidation(data, schema) {
        // Резервная валидация на JavaScript
        return new SchemaValidator(schema).validate(data);
    }
}
```

### 2. Валидация с машинным обучением (анализ аномалий)

**Псевдокод:**
```
КЛАСС MLValidator:
    КОНСТРУКТОР():
        this.anomalyThreshold = 0.7 // Порог для определения аномалий
        this.userPatterns = новый Map() // Паттерны поведения пользователя
    КОНЕЦ КОНСТРУКТОРА

    // Обучение на основе исторических данных
    ФУНКЦИЯ trainOnUserInput(userId, input, isValid):
        ЕСЛИ !this.userPatterns.содержит(userId):
            this.userPatterns.установить(userId, {
                validInputs: [],
                invalidInputs: [],
                avgLength: 0,
                commonPatterns: []
            })
        КОНЕЦ ЕСЛИ

        пользовательский_паттерн = this.userPatterns.получить(userId)

        ЕСЛИ isValid:
            пользовательский_паттерн.validInputs.добавить(input)
        ИНАЧЕ:
            пользовательский_паттерн.invalidInputs.добавить(input)
        КОНЕЦ ЕСЛИ

        // Обновление статистики
        updateUserStats(userId)

    ФУНКЦИЯ updateUserStats(userId):
        паттерн = this.userPatterns.получить(userId)
        все_вводы = [...паттерн.validInputs, ...паттерн.invalidInputs]

        ЕСЛИ длина(все_вводы) > 0:
            паттерн.avgLength = сумма(карта(все_вводы, input -> длина(input))) / длина(все_вводы)

    АСИНХРОННАЯ ФУНКЦИЯ validateWithAnomalyDetection(userId, input):
        пользовательский_паттерн = this.userPatterns.получить(userId)
        ЕСЛИ !пользовательский_паттерн:
            // Если нет исторических данных, используем стандартную валидацию
            ВОЗВРАТ { isValid: ИСТИНА, confidence: 0.5, isAnomaly: ЛОЖЬ }

        // Проверка на аномальное поведение
        lengthAnomaly = модуль(длина(input) - пользовательский_паттерн.avgLength) > пользовательский_паттерн.avgLength * 0.5
        patternAnomaly = checkPatternAnomaly(userId, input)

        isAnomaly = lengthAnomaly ИЛИ patternAnomaly
        confidence = ЕСЛИ isAnomaly ТОГДА 0.2 ИНАЧЕ 0.9

        ВОЗВРАТ {
            isValid: !isAnomaly,
            confidence,
            isAnomaly,
            reasons: [
                ...(lengthAnomaly ? ['anomalous_length'] : []),
                ...(patternAnomaly ? ['anomalous_pattern'] : [])
            ]
        }

    ФУНКЦИЯ checkPatternAnomaly(userId, input):
        // Простой алгоритм: проверяем, насколько ввод отличается от обычных паттернов
        пользовательский_паттерн = this.userPatterns.получить(userId)
        validInputs = пользовательский_паттерн.validInputs

        ЕСЛИ длина(validInputs) === 0:
            ВОЗВРАТ ЛОЖЬ

        // Сравниваем схожесть с валидными вводами (упрощенный алгоритм)
        similarityScores = карта(validInputs, validInput ->
            calculateSimilarity(input, validInput)
        )

        avgSimilarity = сумма(similarityScores) / длина(similarityScores)

        ВОЗВРАТ avgSimilarity < 0.3 // Если схожесть меньше 30%, считаем аномалией

    ФУНКЦИЯ calculateSimilarity(str1, str2):
        // Алгоритм Левенштейна для оценки схожести строк
        матрица = Array(длина(str2) + 1).заполнить().карта(() ->
            Array(длина(str1) + 1).заполнить(0)
        )

        ДЛЯ i ОТ 0 ДО длина(str1):
            матрица[0][i] = i
        ДЛЯ j ОТ 0 ДО длина(str2):
            матрица[j][0] = j

        ДЛЯ j ОТ 1 ДО длина(str2):
            ДЛЯ i ОТ 1 ДО длина(str1):
                стоимость = ЕСЛИ str1[i - 1] === str2[j - 1] ТОГДА 0 ИНАЧЕ 1
                матрица[j][i] = min(
                    матрица[j][i - 1] + 1,
                    матрица[j - 1][i] + 1,
                    матрица[j - 1][i - 1] + стоимость
                )
            КОНЕЦ ДЛЯ
        КОНЕЦ ДЛЯ

        maxLen = max(длина(str1), длина(str2))
        ВОЗВРАТ ЕСЛИ maxLen === 0 ТОГДА 1 ИНАЧЕ 1 - матрица[длина(str2)][длина(str1)] / maxLen
КОНЕЦ КЛАССА
```

```javascript
class MLValidator {
    constructor() {
        this.anomalyThreshold = 0.7; // Порог для определения аномалий
        this.userPatterns = new Map(); // Паттерны поведения пользователя
    }

    // Обучение на основе исторических данных
    trainOnUserInput(userId, input, isValid) {
        if (!this.userPatterns.has(userId)) {
            this.userPatterns.set(userId, {
                validInputs: [],
                invalidInputs: [],
                avgLength: 0,
                commonPatterns: []
            });
        }

        const userPattern = this.userPatterns.get(userId);

        if (isValid) {
            userPattern.validInputs.push(input);
        } else {
            userPattern.invalidInputs.push(input);
        }

        // Обновление статистики
        this.updateUserStats(userId);
    }

    updateUserStats(userId) {
        const pattern = this.userPatterns.get(userId);
        const allInputs = [...pattern.validInputs, ...pattern.invalidInputs];

        if (allInputs.length > 0) {
            pattern.avgLength = allInputs.reduce((sum, input) => sum + input.length, 0) / allInputs.length;
        }
    }

    validateWithAnomalyDetection(userId, input) {
        const userPattern = this.userPatterns.get(userId);
        if (!userPattern) {
            // Если нет исторических данных, используем стандартную валидацию
            return { isValid: true, confidence: 0.5, isAnomaly: false };
        }

        // Проверка на аномальное поведение
        const lengthAnomaly = Math.abs(input.length - userPattern.avgLength) > userPattern.avgLength * 0.5;
        const patternAnomaly = this.checkPatternAnomaly(userId, input);

        const isAnomaly = lengthAnomaly || patternAnomaly;
        const confidence = isAnomaly ? 0.2 : 0.9;

        return {
            isValid: !isAnomaly,
            confidence,
            isAnomaly,
            reasons: [
                ...(lengthAnomaly ? ['anomalous_length'] : []),
                ...(patternAnomaly ? ['anomalous_pattern'] : [])
            ]
        };
    }

    checkPatternAnomaly(userId, input) {
        // Простой алгоритм: проверяем, насколько ввод отличается от обычных паттернов
        const userPattern = this.userPatterns.get(userId);
        const validInputs = userPattern.validInputs;

        if (validInputs.length === 0) return false;

        // Сравниваем схожесть с валидными вводами (упрощенный алгоритм)
        const similarityScores = validInputs.map(validInput =>
            this.calculateSimilarity(input, validInput)
        );

        const avgSimilarity = similarityScores.reduce((a, b) => a + b, 0) / similarityScores.length;

        return avgSimilarity < 0.3; // Если схожесть меньше 30%, считаем аномалией
    }

    calculateSimilarity(str1, str2) {
        // Алгоритм Левенштейна для оценки схожести строк
        const matrix = Array(str2.length + 1).fill().map(() =>
            Array(str1.length + 1).fill(0)
        );

        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

        for (let j = 1; j <= str2.length; j++) {
            for (let i = 1; i <= str1.length; i++) {
                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                matrix[j][i] = Math.min(
                    matrix[j][i - 1] + 1,
                    matrix[j - 1][i] + 1,
                    matrix[j - 1][i - 1] + cost
                );
            }
        }

        const maxLen = Math.max(str1.length, str2.length);
        return maxLen === 0 ? 1 : 1 - matrix[str2.length][str1.length] / maxLen;
    }
}
```

## Практические рекомендации

### 1. Валидация в реальном времени

**Псевдокод:**
```
КЛАСС RealTimeValidator:
    КОНСТРУКТОР(элемент_формы, правила_валидации):
        this.form = элемент_формы
        this.rules = правила_валидации
        this.debounceTimers = новый Map()
        this.errorDisplays = новый Map()

        initializeValidation()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ initializeValidation():
        keys(this.rules).каждый(имя_поля -> {
            поле = this.form.querySelector(`[name="${имя_поля}"]`)
            ЕСЛИ поле:
                поле.addEventListener('input', (e) -> {
                    validateFieldWithDebounce(имя_поля, e.target.value)
                })

                поле.addEventListener('blur', (e) -> {
                    validateField(имя_поля, e.target.value, ИСТИНА)
                })
            КОНЕЦ ЕСЛИ
        })

    ФУНКЦИЯ validateFieldWithDebounce(имя_поля, значение):
        // Отменяем предыдущий таймер
        ЕСЛИ this.debounceTimers.содержит(имя_поля):
            очиститьТаймаут(this.debounceTimers.получить(имя_поля))
        КОНЕЦ ЕСЛИ

        // Устанавливаем новый таймер
        таймер = установитьТаймаут(() -> {
            validateField(имя_поля, значение)
        }, 500) // Задержка 500мс

        this.debounceTimers.установить(имя_поля, таймер)

    ФУНКЦИЯ validateField(имя_поля, значение, показывать_ошибки = ЛОЖЬ):
        правила = this.rules[имя_поля]
        ЕСЛИ !правила:
            ВОЗВРАТ ИСТИНА

        ОШИБКИ = []

        // Проверка обязательных полей
        ЕСЛИ правила.required И !validateRequired(значение):
            ОШИБКИ.добавить('Обязательное поле')
        КОНЕЦ ЕСЛИ

        // Другие проверки
        ЕСЛИ validateRequired(значение):
            ЕСЛИ правила.email И !validateEmail(значение):
                ОШИБКИ.добавить('Некорректный email')
            КОНЕЦ ЕСЛИ

            ЕСЛИ правила.minLength И длина(значение) < правила.minLength:
                ОШИБКИ.добавить(`Минимум ${правила.minLength} символов`)
            КОНЕЦ ЕСЛИ

            // Добавить другие проверки по необходимости
        КОНЕЦ ЕСЛИ

        // Показ ошибок
        ЕСЛИ показывать_ошибки ИЛИ длина(ОШИБКИ) > 0:
            отобразитьОшибки(имя_поля, ОШИБКИ)

        ВОЗВРАТ длина(ОШИБКИ) === 0
    КОНЕЦ ФУНКЦИИ
КОНЕЦ КЛАССА
```

```javascript
class RealTimeValidator {
    constructor(formElement, validationRules) {
        this.form = formElement;
        this.rules = validationRules;
        this.debounceTimers = new Map();
        this.errorDisplays = new Map();

        this.initializeValidation();
    }

    initializeValidation() {
        Object.keys(this.rules).forEach(fieldName => {
            const field = this.form.querySelector(`[name="${fieldName}"]`);
            if (field) {
                field.addEventListener('input', (e) => {
                    this.validateFieldWithDebounce(fieldName, e.target.value);
                });

                field.addEventListener('blur', (e) => {
                    this.validateField(fieldName, e.target.value, true);
                });
            }
        });
    }

    validateFieldWithDebounce(fieldName, value) {
        // Отменяем предыдущий таймер
        if (this.debounceTimers.has(fieldName)) {
            clearTimeout(this.debounceTimers.get(fieldName));
        }

        // Устанавливаем новый таймер
        const timer = setTimeout(() => {
            this.validateField(fieldName, value);
        }, 500); // Задержка 500мс

        this.debounceTimers.set(fieldName, timer);
    }

    validateField(fieldName, value, showErrors = false) {
        const rules = this.rules[fieldName];
        if (!rules) return true;

        const errors = [];

        // Проверка обязательных полей
        if (rules.required && !validateRequired(value)) {
            errors.push('Обязательное поле');
        }

        // Другие проверки
        if (validateRequired(value)) {
            if (rules.email && !validateEmail(value)) {
                errors.push('Некорректный email');
            }

            if (rules.minLength && value.length < rules.minLength) {
                errors.push(`Минимум ${rules.minLength} символов`);
            }

            // Добавить другие проверки по необходимости
        }

        // Показ ошибок
        if (showErrors || errors.length > 0) {
            this.displayErrors(fieldName, errors);
        }

        return errors.length === 0;
    }

    displayErrors(fieldName, errors) {
        const errorDisplay = this.form.querySelector(`[data-error-for="${fieldName}"]`) ||
                           this.createErrorDisplay(fieldName);

        errorDisplay.textContent = errors.join(', ');
        errorDisplay.style.display = errors.length > 0 ? 'block' : 'none';
    }

    createErrorDisplay(fieldName) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.setAttribute('data-error-for', fieldName);
        errorDiv.style.color = 'red';
        errorDiv.style.display = 'none';

        const field = this.form.querySelector(`[name="${fieldName}"]`);
        field.parentNode.insertBefore(errorDiv, field.nextSibling);

        return errorDiv;
    }
}
```

### 2. Валидация с отложенной загрузкой правил

**Псевдокод:**
```
КЛАСС LazyValidationManager:
    КОНСТРУКТОР():
        this.validationRules = {}
        this.loadedSchemas = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ validate(данные, схема_имя):
        ЕСЛИ !this.loadedSchemas.содержит(схема_имя):
            ЖДАТЬ loadSchema(схема_имя)

        валидатор = this.loadedSchemas.получить(схема_имя)
        ВОЗВРАТ валидатор.validate(данные)

    АСИНХРОННАЯ ФУНКЦИЯ loadSchema(схема_имя):
        ЕСЛИ this.validationRules.содержит(схема_имя):
            схема = this.validationRules[схема_имя]
        ИНАЧЕ:
            // Загрузка схемы с сервера
            ответ = ЖДАТЬ fetch(`/api/validation-schemas/${схема_имя}`)
            схема = ЖДАТЬ ответ.json()

        this.loadedSchemas.установить(схема_имя, новый SchemaValidator(схема))
```

```javascript
class LazyValidationManager {
    constructor() {
        this.validationRules = {};
        this.loadedSchemas = new Map();
    }

    async validate(data, schemaName) {
        if (!this.loadedSchemas.has(schemaName)) {
            await this.loadSchema(schemaName);
        }

        const validator = this.loadedSchemas.get(schemaName);
        return validator.validate(data);
    }

    async loadSchema(schemaName) {
        let schema;
        if (this.validationRules[schemaName]) {
            schema = this.validationRules[schemaName];
        } else {
            // Загрузка схемы с сервера
            const response = await fetch(`/api/validation-schemas/${schemaName}`);
            schema = await response.json();
        }

        this.loadedSchemas.set(schemaName, new SchemaValidator(schema));
    }

    registerSchema(schemaName, schema) {
        this.validationRules[schemaName] = schema;
    }
}
```

## Заключение

Алгоритмы валидации играют ключевую роль в обеспечении безопасности, целостности данных и улучшения пользовательского опыта веб-приложений. С развитием новых технологий и подходов к валидации, такие как машинное обучение и WebAssembly, разработчики получают все больше возможностей для создания более умных и эффективных систем проверки данных.

## См. также

- [[Алгоритмы-обработки-событий]]
- [[Алгоритмы-оптимизации-рендеринга]]
- [[Безопасность-фронтенда]]
- [[Формы-и-валидация-в-современных-приложениях]]

## Теги

#frontend #algorithms #validation #forms #javascript #security #web-security #input-validation