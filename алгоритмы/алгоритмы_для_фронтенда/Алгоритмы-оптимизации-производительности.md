---
aliases: [Performance Optimization Algorithms, Алгоритмы оптимизации производительности]
tags: [frontend, algorithms, performance, optimization, javascript, memory]
---

# Алгоритмы оптимизации производительности

## Введение

Алгоритмы оптимизации производительности являются критически важными для создания быстрых, отзывчивых и эффективных веб-приложений. С ростом сложности фронтенд-приложений и увеличением требований к пользовательскому опыту, знание и применение эффективных алгоритмов оптимизации становится обязательным навыком для разработчиков. Эти алгоритмы помогают уменьшить время загрузки, улучшить плавность анимаций и обеспечить стабильную работу приложений на различных устройствах.

## Основные метрики производительности

### Веб-метрики (Core Web Vitals)

1. **LCP (Largest Contentful Paint)** - время отображения самого большого элемента контента
2. **FID (First Input Delay)** - задержка первого взаимодействия
3. **CLS (Cumulative Layout Shift)** - кумулятивное смещение макета

### Дополнительные метрики

- **FCP (First Contentful Paint)** - первая отрисовка контента
- **TTFB (Time to First Byte)** - время до первого байта
- **TBT (Total Blocking Time)** - общее время блокировки
- **INP (Interaction to Next Paint)** - новая метрика взаимодействия

## Алгоритмы оптимизации загрузки

### 1. Алгоритм ленивой загрузки (Lazy Loading)

Для отложенной загрузки ресурсов:

**Псевдокод:**
```
КЛАСС LazyLoader:
    КОНСТРУКТОР():
        this.imageObserver = НЕОПРЕДЕЛЕНО
        this.resourceQueue = []
        this.loadingPromises = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ init():
        // Инициализация Intersection Observer для изображений
        this.imageObserver = новый IntersectionObserver((записи) -> {
            записи.каждый(запись -> {
                ЕСЛИ запись.isIntersecting:
                    loadImage(запись.target)
                    this.imageObserver.unobserve(запись.target)
                КОНЕЦ ЕСЛИ
            })
        }, {
            rootMargin: '50px' // Начинаем загрузку за 50px до появления
        })

    АСИНХРОННАЯ ФУНКЦИЯ loadImage(img):
        src = img.dataset.src
        ЕСЛИ !src:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        // Проверяем, не загружается ли уже этот ресурс
        ЕСЛИ this.loadingPromises.содержит(src):
            ВОЗВРАТ this.loadingPromises.получить(src)
        КОНЕЦ ЕСЛИ

        loadPromise = НОВОЕ_ОБЕЩАНИЕ((разрешить, отклонить) -> {
            изображение = новый Image()

            изображение.onload = () -> {
                img.src = src
                img.classList.удалить('lazy')
                img.classList.добавить('loaded')
                this.loadingPromises.удалить(src)
                разрешить(изображение)
            }

            изображение.onerror = () -> {
                img.classList.добавить('error')
                this.loadingPromises.удалить(src)
                отклонить(НОВАЯ_ОШИБКА(`Failed to load image: ${src}`))
            }

            изображение.src = src
        })

        this.loadingPromises.установить(src, loadPromise)
        ВОЗВРАТ loadPromise

    АСИНХРОННАЯ ФУНКЦИЯ loadResource(url, тип = 'script'):
        ЕСЛИ this.loadingPromises.содержит(url):
            ВОЗВРАТ this.loadingPromises.получить(url)
        КОНЕЦ ЕСЛИ

        loadPromise = ВЫБОР:
            СЛУЧАЙ 'script':
                loadScript(url)
            СЛУЧАЙ 'stylesheet':
                loadStylesheet(url)
            ИНАЧЕ:
                fetch(url)

        this.loadingPromises.установить(url, loadPromise)
        ВОЗВРАТ loadPromise
КОНЕЦ КЛАССА
```

**Псевдокод:**
```
КЛАСС LazyLoader:
    КОНСТРУКТОР():
        this.imageObserver = НЕОПРЕДЕЛЕНО
        this.resourceQueue = []
        this.loadingPromises = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ init():
        // Инициализация Intersection Observer для изображений
        this.imageObserver = новый IntersectionObserver((записи) -> {
            записи.каждый(запись -> {
                ЕСЛИ запись.isIntersecting:
                    loadImage(запись.target)
                    this.imageObserver.unobserve(запись.target)
                КОНЕЦ ЕСЛИ
            })
        }, {
            rootMargin: '50px' // Начинаем загрузку за 50px до появления
        })

    АСИНХРОННАЯ ФУНКЦИЯ loadImage(img):
        src = img.dataset.src
        ЕСЛИ !src:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        // Проверяем, не загружается ли уже этот ресурс
        ЕСЛИ this.loadingPromises.содержит(src):
            ВОЗВРАТ this.loadingPromises.получить(src)
        КОНЕЦ ЕСЛИ

        loadPromise = НОВОЕ_ОБЕЩАНИЕ((разрешить, отклонить) -> {
            изображение = новый Image()

            изображение.onload = () -> {
                img.src = src
                img.classList.удалить('lazy')
                img.classList.добавить('loaded')
                this.loadingPromises.удалить(src)
                разрешить(изображение)
            }

            изображение.onerror = () -> {
                img.classList.добавить('error')
                this.loadingPromises.удалить(src)
                отклонить(НОВАЯ_ОШИБКА(`Failed to load image: ${src}`))
            }

            изображение.src = src
        })

        this.loadingPromises.установить(src, loadPromise)
        ВОЗВРАТ loadPromise

    АСИНХРОННАЯ ФУНКЦИЯ loadResource(url, тип = 'script'):
        ЕСЛИ this.loadingPromises.содержит(url):
            ВОЗВРАТ this.loadingPromises.получить(url)
        КОНЕЦ ЕСЛИ

        loadPromise = ВЫБОР:
            СЛУЧАЙ 'script':
                loadScript(url)
            СЛУЧАЙ 'stylesheet':
                loadStylesheet(url)
            ИНАЧЕ:
                fetch(url)

        this.loadingPromises.установить(url, loadPromise)
        ВОЗВРАТ loadPromise
КОНЕЦ КЛАССА
```

```javascript
class LazyLoader {
    constructor() {
        this.imageObserver = null;
        this.resourceQueue = [];
        this.loadingPromises = new Map();
    }

    init() {
        // Инициализация Intersection Observer для изображений
        this.imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.loadImage(entry.target);
                    this.imageObserver.unobserve(entry.target);
                }
            });
        }, {
            rootMargin: '50px' // Начинаем загрузку за 50px до появления
        });
    }

    observeImage(img) {
        this.imageObserver.observe(img);
    }

    async loadImage(img) {
        const src = img.dataset.src;
        if (!src) return;

        // Проверяем, не загружается ли уже этот ресурс
        if (this.loadingPromises.has(src)) {
            return this.loadingPromises.get(src);
        }

        const loadPromise = new Promise((resolve, reject) => {
            const image = new Image();

            image.onload = () => {
                img.src = src;
                img.classList.remove('lazy');
                img.classList.add('loaded');
                this.loadingPromises.delete(src);
                resolve(image);
            };

            image.onerror = () => {
                img.classList.add('error');
                this.loadingPromises.delete(src);
                reject(new Error(`Failed to load image: ${src}`));
            };

            image.src = src;
        });

        this.loadingPromises.set(src, loadPromise);
        return loadPromise;
    }

    // Ленивая загрузка других ресурсов
    async loadResource(url, type = 'script') {
        if (this.loadingPromises.has(url)) {
            return this.loadingPromises.get(url);
        }

        let loadPromise;

        switch (type) {
            case 'script':
                loadPromise = this.loadScript(url);
                break;
            case 'stylesheet':
                loadPromise = this.loadStylesheet(url);
                break;
            default:
                loadPromise = fetch(url);
        }

        this.loadingPromises.set(url, loadPromise);
        return loadPromise;
    }

    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    loadStylesheet(href) {
        return new Promise((resolve, reject) => {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = href;
            link.onload = resolve;
            link.onerror = reject;
            document.head.appendChild(link);
        });
    }
}
```


### 2. Алгоритм приоритезации загрузки ресурсов

**Псевдокод:**
```
КЛАСС ResourcePrioritizer:
    КОНСТРУКТОР():
        this.criticalResources = новый Set()
        this.preloadQueue = []
        this.currentPriority = 'high'
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ addCriticalResource(url, тип):
        this.criticalResources.добавить({ url, тип })
        preloadResource(url, тип)

    ФУНКЦИЯ preloadResource(url, тип):
        link = новый Element('link')
        link.rel = 'preload'
        link.href = url

        ВЫБОР:
            СЛУЧАЙ 'script':
                link.as = 'script'
            СЛУЧАЙ 'style':
                link.as = 'style'
            СЛУЧАЙ 'font':
                link.as = 'font'
                link.type = 'font/woff2'
                link.crossOrigin = 'anonymous'
            СЛУЧАЙ 'image':
                link.as = 'image'
            ИНАЧЕ:
                link.as = тип

        document.head.appendChild(link)

    ФУНКЦИЯ prioritizeResources(ресурсы):
        // Классификация ресурсов по приоритетам
        приоритеты = {
            high: [],    // Критические ресурсы для текущей страницы
            medium: [],  // Важные, но не критические
            low: []      // Не срочные ресурсы
        }

        ресурсы.каждый(ресурс -> {
            ЕСЛИ isCriticalResource(ресурс.url):
                приоритеты.high.добавить(ресурс)
            ИНАЧЕ ЕСЛИ isLikelyNeeded(ресурс):
                приоритеты.medium.добавить(ресурс)
            ИНАЧЕ:
                приоритеты.low.добавить(ресурс)
        })

        // Загрузка по приоритетам
        loadByPriority(приоритеты)

    ФУНКЦИЯ isCriticalResource(url):
        ВОЗВРАТ this.criticalResources.содержит(url) ИЛИ
               url.содержит('critical') ИЛИ
               url.содержит('main') ИЛИ
               url.заканчиваетсяНаСуффикс('.woff2') ИЛИ // Шрифты
               url.заканчиваетсяНаСуффикс('.css')       // Стили

    ФУНКЦИЯ isLikelyNeeded(ресурс):
        // Простая эвристика для определения вероятности использования
        pathname = window.location.pathname
        ВОЗВРАТ ресурс.url.содержит(pathname) ИЛИ
               ресурс.preloadHint === 'likely'

    ФУНКЦИЯ loadByPriority(приоритеты):
        // Загрузка критических ресурсов
        приоритеты.high.каждый(ресурс -> {
            preloadResource(ресурс.url, ресурс.type)
        })

        // Отложенная загрузка менее критичных ресурсов
        установитьТаймаут(() -> {
            приоритеты.medium.каждый(ресурс -> {
                preloadResource(ресурс.url, ресурс.type)
            })
        }, 1000)

        // Загрузка низкоприоритетных ресурсов
        установитьТаймаут(() -> {
            приоритеты.low.каждый(ресурс -> {
                preloadResource(ресурс.url, ресурс.type)
            })
        }, 3000)
КОНЕЦ КЛАССА
```

```javascript
class ResourcePrioritizer {
    constructor() {
        this.criticalResources = new Set();
        this.preloadQueue = [];
        this.currentPriority = 'high';
    }

    addCriticalResource(url, type) {
        this.criticalResources.add({ url, type });
        this.preloadResource(url, type);
    }

    preloadResource(url, type) {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = url;

        switch (type) {
            case 'script':
                link.as = 'script';
                break;
            case 'style':
                link.as = 'style';
                break;
            case 'font':
                link.as = 'font';
                link.type = 'font/woff2';
                link.crossOrigin = 'anonymous';
                break;
            case 'image':
                link.as = 'image';
                break;
            default:
                link.as = type;
        }

        document.head.appendChild(link);
    }

    prioritizeResources(resources) {
        // Классификация ресурсов по приоритетам
        const priorities = {
            high: [],    // Критические ресурсы для текущей страницы
            medium: [],  // Важные, но не критические
            low: []      // Не срочные ресурсы
        };

        resources.forEach(resource => {
            if (this.isCriticalResource(resource.url)) {
                priorities.high.push(resource);
            } else if (this.isLikelyNeeded(resource)) {
                priorities.medium.push(resource);
            } else {
                priorities.low.push(resource);
            }
        });

        // Загрузка по приоритетам
        this.loadByPriority(priorities);
    }

    isCriticalResource(url) {
        return this.criticalResources.has(url) ||
               url.includes('critical') ||
               url.includes('main') ||
               url.endsWith('.woff2') || // Шрифты
               url.endsWith('.css');     // Стили
    }

    isLikelyNeeded(resource) {
        // Простая эвристика для определения вероятности использования
        const pathname = window.location.pathname;
        return resource.url.includes(pathname) ||
               resource.preloadHint === 'likely';
    }

    loadByPriority(priorities) {
        // Загрузка критических ресурсов
        priorities.high.forEach(resource => {
            this.preloadResource(resource.url, resource.type);
        });

        // Отложенная загрузка менее критичных ресурсов
        setTimeout(() => {
            priorities.medium.forEach(resource => {
                this.preloadResource(resource.url, resource.type);
            });
        }, 1000);

        // Загрузка низкоприоритетных ресурсов
        setTimeout(() => {
            priorities.low.forEach(resource => {
                this.preloadResource(resource.url, resource.type);
            });
        }, 3000);
    }
}
```

## Алгоритмы оптимизации памяти

### 1. Алгоритм управления памятью (Memory Management)

**Псевдокод:**
```
КЛАСС MemoryManager:
    КОНСТРУКТОР():
        this.objectPool = новый Map() // Пул переиспользуемых объектов
        this.weakRefs = новый Set() // Слабые ссылки для предотвращения утечек
        this.garbageCollectionThreshold = 1000 // Порог для очистки
        this.monitoringEnabled = ИСТИНА
    КОНЕЦ КОНСТРУКТОРА

    // Получение объекта из пула или создание нового
    ФУНКЦИЯ acquireObject(тип, инициализатор):
        ЕСЛИ !this.objectPool.содержит(тип):
            this.objectPool.установить(тип, [])
        КОНЕЦ ЕСЛИ

        пул = this.objectPool.получить(тип)
        ЕСЛИ длина(пул) > 0:
            ВОЗВРАТ пул.поп() // Возвращаем из пула
        КОНЕЦ ЕСЛИ

        // Создаем новый объект
        ВОЗВРАТ ЕСЛИ тип(инициализатор) === 'функция' ТОГДА инициализатор() ИНАЧЕ {}

    // Возврат объекта в пул
    ФУНКЦИЯ releaseObject(тип, obj):
        ЕСЛИ !this.objectPool.содержит(тип):
            this.objectPool.установить(тип, [])
        КОНЕЦ ЕСЛИ

        // Сброс состояния объекта перед возвратом в пул
        resetObject(obj)

        пул = this.objectPool.получить(тип)
        ЕСЛИ длина(пул) < 50: // Ограничение размера пула
            пул.добавить(obj)
        // Если пул переполнен, объект будет собран сборщиком мусора
        КОНЕЦ ЕСЛИ

    ФУНКЦИЯ resetObject(obj):
        // Сброс свойств объекта к начальному состоянию
        keys(obj).каждый(ключ -> {
            ЕСЛИ тип(obj[ключ]) === 'объект' И obj[ключ] ≠ null:
                obj[ключ] = НЕОПРЕДЕЛЕНО
            ИНАЧЕ ЕСЛИ тип(obj[ключ]) ≠ 'функция':
                obj[ключ] = НЕОПРЕДЕЛЕНО
            КОНЕЦ ЕСЛИ
        })

    // Мониторинг использования памяти
    ФУНКЦИЯ monitorMemory():
        ЕСЛИ !this.monitoringEnabled:
            ВОЗВРАТ
        КОНЕЦ ЕСЛИ

        ЕСЛИ performance.memory:
            memoryInfo = performance.memory
            usageRatio = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize

            ЕСЛИ usageRatio > 0.8:
                // Высокое использование памяти - запускаем очистку
                cleanup()
            КОНЕЦ ЕСЛИ
        КОНЕЦ ЕСЛИ

    // Очистка пулов и слабых ссылок
    ФУНКЦИЯ cleanup():
        // Очистка пулов объектов
        ДЛЯ каждой (тип, пул) в this.objectPool:
            // Оставляем только 10% объектов в пуле
            keepCount = floor(длина(пул) * 0.1)
            this.objectPool.установить(тип, пул.взять(0, keepCount))

        // Проверка слабых ссылок
        this.weakRefs.каждый(weakRef -> {
            ЕСЛИ weakRef.deref() === НЕОПРЕДЕЛЕНО:
                this.weakRefs.удалить(weakRef)
        })

    // Создание слабой ссылки
    ФУНКЦИЯ createWeakRef(цель):
        weakRef = новый WeakRef(цель)
        this.weakRefs.добавить(weakRef)
        ВОЗВРАТ weakRef

    // Создание слабого мапа
    ФУНКЦИЯ createWeakMap():
        ВОЗВРАТ новый WeakMap()

    // Создание слабого сета
    ФУНКЦИЯ createWeakSet():
        ВОЗВРАТ новый WeakSet()
КОНЕЦ КЛАССА
```

```javascript
class MemoryManager {
    constructor() {
        this.objectPool = new Map(); // Пул переиспользуемых объектов
        this.weakRefs = new Set(); // Слабые ссылки для предотвращения утечек
        this.garbageCollectionThreshold = 1000; // Порог для очистки
        this.monitoringEnabled = true;
    }

    // Получение объекта из пула или создание нового
    acquireObject(type, initializer) {
        if (!this.objectPool.has(type)) {
            this.objectPool.set(type, []);
        }

        const pool = this.objectPool.get(type);
        if (pool.length > 0) {
            return pool.pop(); // Возвращаем из пула
        }

        // Создаем новый объект
        return typeof initializer === 'function' ? initializer() : {};
    }

    // Возврат объекта в пул
    releaseObject(type, obj) {
        if (!this.objectPool.has(type)) {
            this.objectPool.set(type, []);
        }

        // Сброс состояния объекта перед возвратом в пул
        this.resetObject(obj);

        const pool = this.objectPool.get(type);
        if (pool.length < 50) { // Ограничение размера пула
            pool.push(obj);
        }
        // Если пул переполнен, объект будет собран сборщиком мусора
    }

    resetObject(obj) {
        // Сброс свойств объекта к начальному состоянию
        Object.keys(obj).forEach(key => {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                obj[key] = null;
            } else if (typeof obj[key] !== 'function') {
                obj[key] = undefined;
            }
        });
    }

    // Мониторинг использования памяти
    monitorMemory() {
        if (!this.monitoringEnabled) return;

        if (performance.memory) {
            const memoryInfo = performance.memory;
            const usageRatio = memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize;

            if (usageRatio > 0.8) {
                // Высокое использование памяти - запускаем очистку
                this.cleanup();
            }
        }
    }

    // Очистка пулов и слабых ссылок
    cleanup() {
        // Очистка пулов объектов
        for (const [type, pool] of this.objectPool) {
            // Оставляем только 10% объектов в пуле
            const keepCount = Math.floor(pool.length * 0.1);
            this.objectPool.set(type, pool.slice(0, keepCount));
        }

        // Проверка слабых ссылок
        this.weakRefs.forEach(weakRef => {
            if (weakRef.deref() === undefined) {
                this.weakRefs.delete(weakRef);
            }
        });
    }

    // Создание слабой ссылки
    createWeakRef(target) {
        const weakRef = new WeakRef(target);
        this.weakRefs.add(weakRef);
        return weakRef;
    }

    // Создание слабого мапа
    createWeakMap() {
        return new WeakMap();
    }

    // Создание слабого сета
    createWeakSet() {
        return new WeakSet();
    }
}
```

### 2. Алгоритм кэширования с ограничением по размеру (LRU Cache)

**Псевдокод:**
```
КЛАСС LRUCache:
    КОНСТРУКТОР(емкость):
        this.capacity = емкость
        this.cache = новый Map()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ get(ключ):
        ЕСЛИ !this.cache.содержит(ключ):
            ВОЗВРАТ НЕОПРЕДЕЛЕНО
        КОНЕЦ ЕСЛИ

        значение = this.cache.получить(ключ)
        // Перемещаем элемент в конец (самый недавно используемый)
        this.cache.удалить(ключ)
        this.cache.установить(ключ, значение)

        ВОЗВРАТ значение

    ФУНКЦИЯ set(ключ, значение):
        // Если ключ уже существует, удаляем его
        ЕСЛИ this.cache.содержит(ключ):
            this.cache.удалить(ключ)
        КОНЕЦ ЕСЛИ

        // Если кэш переполнен, удаляем самый старый элемент
        ЕСЛИ this.cache.размер >= this.capacity:
            firstKey = this.cache.keys().первый().значение
            this.cache.удалить(firstKey)
        КОНЕЦ ЕСЛИ

        this.cache.установить(ключ, значение)

    ФУНКЦИЯ has(ключ):
        ВОЗВРАТ this.cache.содержит(ключ)

    ФУНКЦИЯ delete(ключ):
        ВОЗВРАТ this.cache.удалить(ключ)

    ФУНКЦИЯ clear():
        this.cache.очистить()

    СВОЙСТВО размер():
        ВОЗВРАТ this.cache.размер

    СВОЙСТВО ключи():
        ВОЗВРАТ массив(this.cache.keys())
КОНЕЦ КЛАССА
```

```javascript
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) {
            return undefined;
        }

        const value = this.cache.get(key);
        // Перемещаем элемент в конец (самый недавно используемый)
        this.cache.delete(key);
        this.cache.set(key, value);

        return value;
    }

    set(key, value) {
        // Если ключ уже существует, удаляем его
        if (this.cache.has(key)) {
            this.cache.delete(key);
        }

        // Если кэш переполнен, удаляем самый старый элемент
        if (this.cache.size >= this.capacity) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.set(key, value);
    }

    has(key) {
        return this.cache.has(key);
    }

    delete(key) {
        return this.cache.delete(key);
    }

    clear() {
        this.cache.clear();
    }

    get size() {
        return this.cache.size;
    }

    get keys() {
        return Array.from(this.cache.keys());
    }
}

// Применение LRU кэша для оптимизации производительности
class OptimizedDataManager {
    constructor() {
        this.cache = new LRUCache(100); // Кэш на 100 элементов
        this.pendingRequests = new Map(); // Отслеживание ожидающих запросов
    }

    async getData(id) {
        // Проверка в кэше
        if (this.cache.has(id)) {
            return this.cache.get(id);
        }

        // Проверка на ожидающий запрос
        if (this.pendingRequests.has(id)) {
            return this.pendingRequests.get(id);
        }

        // Создание нового запроса
        const requestPromise = this.fetchData(id)
            .then(data => {
                this.cache.set(id, data);
                this.pendingRequests.delete(id);
                return data;
            })
            .catch(error => {
                this.pendingRequests.delete(id);
                throw error;
            });

        this.pendingRequests.set(id, requestPromise);
        return requestPromise;
    }

    async fetchData(id) {
        // Имитация API-запроса
        const response = await fetch(`/api/data/${id}`);
        return response.json();
    }
}
```

## Алгоритмы оптимизации рендеринга

### 1. Алгоритм виртуального скроллинга

**Псевдокод:**
```
КЛАСС VirtualScroll:
    КОНСТРУКТОР(контейнер, высота_элемента, всего_элементов, функция_рендера):
        this.container = контейнер
        this.itemHeight = высота_элемента
        this.totalItems = всего_элементов
        this.renderItem = функция_рендера
        this.visibleItems = ceil(контейнер.clientHeight / высота_элемента) + 2
        this.startIndex = 0
        this.offset = 0

        setup()
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ setup():
        // Установка высоты контейнера для правильного скроллинга
        this.container.style.height = this.totalItems * this.itemHeight + 'px'
        this.container.style.position = 'relative'
        this.container.style.overflow = 'auto'

        // Создание контейнера для видимых элементов
        this.content = новый Element('div')
        this.content.style.position = 'absolute'
        this.content.style.top = '0'
        this.content.style.width = '100%'
        this.container.appendChild(this.content)

        // Обработчик скролла
        this.container.addEventListener('scroll', onScroll.привязать(this))

        // Инициальная отрисовка
        render()

    ФУНКЦИЯ onScroll():
        // Вычисление начального индекса на основе позиции скролла
        новыйStartIndex = floor(this.container.scrollTop / this.itemHeight)

        ЕСЛИ новыйStartIndex ≠ this.startIndex:
            this.startIndex = новыйStartIndex
            render()

    ФУНКЦИЯ render():
        // Очистка текущего содержимого
        this.content.innerHTML = ''

        // Вычисление смещения для правильного позиционирования
        this.offset = this.startIndex * this.itemHeight
        this.content.style.transform = `translateY(${this.offset}px)`

        // Рендер видимых элементов
        endIndex = min(this.startIndex + this.visibleItems, this.totalItems)

        ДЛЯ i ОТ this.startIndex ДО endIndex:
            элемент = renderItem(i)
            элемент.style.position = 'absolute'
            элемент.style.top = ((i - this.startIndex) * this.itemHeight) + 'px'
            элемент.style.width = '100%'
            this.content.appendChild(элемент)
КОНЕЦ КЛАССА
```

```javascript
class VirtualScroll {
    constructor(container, itemHeight, totalItems, renderItem) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalItems = totalItems;
        this.renderItem = renderItem;
        this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;
        this.startIndex = 0;
        this.offset = 0;

        this.setup();
    }

    setup() {
        // Установка высоты контейнера для правильного скроллинга
        this.container.style.height = this.totalItems * this.itemHeight + 'px';
        this.container.style.position = 'relative';
        this.container.style.overflow = 'auto';

        // Создание контейнера для видимых элементов
        this.content = document.createElement('div');
        this.content.style.position = 'absolute';
        this.content.style.top = '0';
        this.content.style.width = '100%';
        this.container.appendChild(this.content);

        // Обработчик скролла
        this.container.addEventListener('scroll', this.onScroll.bind(this));

        // Инициальная отрисовка
        this.render();
    }

    onScroll() {
        // Вычисление начального индекса на основе позиции скролла
        const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);

        if (newStartIndex !== this.startIndex) {
            this.startIndex = newStartIndex;
            this.render();
        }
    }

    render() {
        // Очистка текущего содержимого
        this.content.innerHTML = '';

        // Вычисление смещения для правильного позиционирования
        this.offset = this.startIndex * this.itemHeight;
        this.content.style.transform = `translateY(${this.offset}px)`;

        // Рендер видимых элементов
        const endIndex = Math.min(this.startIndex + this.visibleItems, this.totalItems);

        for (let i = this.startIndex; i < endIndex; i++) {
            const item = this.renderItem(i);
            item.style.position = 'absolute';
            item.style.top = ((i - this.startIndex) * this.itemHeight) + 'px';
            item.style.width = '100%';
            this.content.appendChild(item);
        }
    }

    updateData(newTotalItems) {
        this.totalItems = newTotalItems;
        this.container.style.height = newTotalItems * this.itemHeight + 'px';
        this.render();
    }
}

// Пример использования
const virtualScroll = new VirtualScroll(
    document.getElementById('scroll-container'),
    50, // высота элемента
    10000, // общее количество элементов
    (index) => {
        // Функция рендеринга элемента
        const div = document.createElement('div');
        div.textContent = `Item ${index}`;
        div.style.height = '50px';
        div.style.borderBottom = '1px solid #eee';
        return div;
    }
);
```

### 2. Алгоритм оптимизации перерисовок (Batch Updates)

**Псевдокод:**
```
КЛАСС BatchRenderer:
    КОНСТРУКТОР():
        this.pendingUpdates = []
        this.isBatching = ЛОЖЬ
        this.frameCallbacks = []
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ scheduleUpdate(элемент, updateFn):
        this.pendingUpdates.добавить({ элемент, updateFn })

        ЕСЛИ !this.isBatching:
            this.isBatching = ИСТИНА
            requestAnimationFrame(() -> processUpdates())

    ФУНКЦИЯ processUpdates():
        // Сортировка обновлений для минимизации Reflow
        layoutReads = []
        layoutWrites = []

        this.pendingUpdates.каждый(update -> {
            // Определение типа обновления (чтение или запись)
            ЕСЛИ involvesLayoutReading(update):
                layoutReads.добавить(update)
            ИНАЧЕ:
                layoutWrites.добавить(update)
        })

        // Сначала все чтения
        layoutReads.каждый(update -> {
            update.updateFn()
        })

        // Затем все записи
        layoutWrites.каждый(update -> {
            update.updateFn()
        })

        this.pendingUpdates = []
        this.isBatching = ЛОЖЬ

        // Выполнение отложенных коллбэков
        executeFrameCallbacks()

    ФУНКЦИЯ involvesLayoutReading(update):
        // Простая эвристика для определения чтения макета
        readingProps = ['offsetTop', 'offsetLeft', 'offsetWidth', 'offsetHeight',
                        'clientWidth', 'clientHeight', 'scrollWidth', 'scrollHeight',
                        'getBoundingClientRect']

        updateStr = update.updateFn.toString()
        ВОЗВРАТ readingProps.некоторые(prop -> updateStr.содержит(prop))

    ФУНКЦИЯ addFrameCallback(callback):
        this.frameCallbacks.добавить(callback)

    ФУНКЦИЯ executeFrameCallbacks():
        callbacks = this.frameCallbacks.взять(0)
        callbacks.каждый(callback -> {
            ПОПЫТКА:
                callback()
            ИСКЛЮЧЕНИЕ (ошибка):
                вывести_ошибку('Ошибка в frame callback:', ошибка)
        })
КОНЕЦ КЛАССА
```

```javascript
class BatchRenderer {
    constructor() {
        this.pendingUpdates = [];
        this.isBatching = false;
        this.frameCallbacks = [];
    }

    scheduleUpdate(element, updateFn) {
        this.pendingUpdates.push({ element, updateFn });

        if (!this.isBatching) {
            this.isBatching = true;
            requestAnimationFrame(() => this.processUpdates());
        }
    }

    processUpdates() {
        // Сортировка обновлений для минимизации Reflow
        const layoutReads = [];
        const layoutWrites = [];

        this.pendingUpdates.forEach(update => {
            // Определение типа обновления (чтение или запись)
            if (this.involvesLayoutReading(update)) {
                layoutReads.push(update);
            } else {
                layoutWrites.push(update);
            }
        });

        // Сначала все чтения
        layoutReads.forEach(update => {
            update.updateFn();
        });

        // Затем все записи
        layoutWrites.forEach(update => {
            update.updateFn();
        });

        this.pendingUpdates = [];
        this.isBatching = false;

        // Выполнение отложенных коллбэков
        this.executeFrameCallbacks();
    }

    involvesLayoutReading(update) {
        // Простая эвристика для определения чтения макета
        const readingProps = ['offsetTop', 'offsetLeft', 'offsetWidth', 'offsetHeight',
                             'clientWidth', 'clientHeight', 'scrollWidth', 'scrollHeight',
                             'getBoundingClientRect'];

        const updateStr = update.updateFn.toString();
        return readingProps.some(prop => updateStr.includes(prop));
    }

    addFrameCallback(callback) {
        this.frameCallbacks.push(callback);
    }

    executeFrameCallbacks() {
        const callbacks = this.frameCallbacks.splice(0);
        callbacks.forEach(callback => {
            try {
                callback();
            } catch (error) {
                console.error('Ошибка в frame callback:', error);
            }
        });
    }

    // Метод для группировки обновлений
    batch(updates) {
        updates.forEach(update => {
            this.scheduleUpdate(update.element, update.updateFn);
        });
    }
}

// Пример использования
const batchRenderer = new BatchRenderer();

// Несколько обновлений, которые будут сгруппированы
batchRenderer.scheduleUpdate(element1, () => {
    element1.style.left = '100px';
});

batchRenderer.scheduleUpdate(element2, () => {
    element2.textContent = 'Updated';
});

batchRenderer.scheduleUpdate(element3, () => {
    element3.style.backgroundColor = 'blue';
});
```

## Алгоритмы оптимизации вычислений

### 1. Алгоритм мемоизации

**Псевдокод:**
```
КЛАСС Memoizer:
    КОНСТРУКТОР():
        this.cache = новый Map()
        this.stats = {
            hits: 0,
            misses: 0
        }
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ memoize(fn, cacheKeyFn = НЕОПРЕДЕЛЕНО):
        ВОЗВРАТ (...аргументы) -> {
            // Генерация ключа для кэша
            ключ = ЕСЛИ cacheKeyFn ТОГДА cacheKeyFn(...аргументы) ИНАЧЕ generateKey(аргументы)

            ЕСЛИ this.cache.содержит(ключ):
                this.stats.hits++
                ВОЗВРАТ this.cache.получить(ключ)
            КОНЕЦ ЕСЛИ

            this.stats.misses++
            результат = fn.применить(ЭТО, аргументы)
            this.cache.установить(ключ, результат)

            // Очистка кэша при достижении лимита
            ЕСЛИ this.cache.размер > 1000:
                первый_ключ = this.cache.keys().первый().значение
                this.cache.удалить(первый_ключ)

            ВОЗВРАТ результат
        }

    ФУНКЦИЯ generateKey(аргументы):
        ВОЗВРАТ JSON.stringify(аргументы, (ключ, значение) -> {
            // Обработка функций и символов
            ЕСЛИ тип(значение) === 'функция':
                ВОЗВРАТ значение.toString()
            ИНАЧЕ ЕСЛИ тип(значение) === 'символ':
                ВОЗВРАТ значение.toString()
            КОНЕЦ ЕСЛИ
            ВОЗВРАТ значение
        })

    ФУНКЦИЯ clear():
        this.cache.очистить()
        this.stats = { hits: 0, misses: 0 }

    ФУНКЦИЯ getStats():
        всего = this.stats.hits + this.stats.misses
        hitRate = ЕСЛИ всего > 0 ТОГДА (this.stats.hits / всего) * 100 ИНАЧЕ 0

        ВОЗВРАТ {
            ...this.stats,
            hitRate: hitRate.округлить(2) + '%',
            cacheSize: this.cache.размер
        }
КОНЕЦ КЛАССА
```

```javascript
class Memoizer {
    constructor() {
        this.cache = new Map();
        this.stats = {
            hits: 0,
            misses: 0
        };
    }

    memoize(fn, cacheKeyFn = null) {
        return (...args) => {
            // Генерация ключа для кэша
            const key = cacheKeyFn ? cacheKeyFn(...args) : this.generateKey(args);

            if (this.cache.has(key)) {
                this.stats.hits++;
                return this.cache.get(key);
            }

            this.stats.misses++;
            const result = fn.apply(this, args);
            this.cache.set(key, result);

            // Очистка кэша при достижении лимита
            if (this.cache.size > 1000) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }

            return result;
        };
    }

    generateKey(args) {
        return JSON.stringify(args, (key, value) => {
            // Обработка функций и символов
            if (typeof value === 'function') return value.toString();
            if (typeof value === 'symbol') return value.toString();
            return value;
        });
    }

    clear() {
        this.cache.clear();
        this.stats = { hits: 0, misses: 0 };
    }

    getStats() {
        const total = this.stats.hits + this.stats.misses;
        const hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;

        return {
            ...this.stats,
            hitRate: hitRate.toFixed(2) + '%',
            cacheSize: this.cache.size
        };
    }
}

// Пример использования
const memoizer = new Memoizer();

const expensiveCalculation = (a, b, operation) => {
    // Имитация дорогостоящего вычисления
    switch (operation) {
        case 'add':
            return a + b;
        case 'multiply':
            return a * b;
        case 'complex':
            let result = 0;
            for (let i = 0; i < 1000000; i++) {
                result += Math.sqrt(i * a * b);
            }
            return result;
        default:
            return 0;
    }
};

const memoizedCalculation = memoizer.memoize(expensiveCalculation, (a, b, operation) => {
    return `${operation}_${a}_${b}`;
});

// Первый вызов - выполнение вычисления
console.log(memoizedCalculation(5, 10, 'add')); // Вычисление

// Повторный вызов - из кэша
console.log(memoizedCalculation(5, 10, 'add')); // Из кэша
```

### 2. Алгоритм оптимизации рекурсии (Tail Call Optimization simulation)

**Псевдокод:**
```
КЛАСС RecursiveOptimizer:
    // Оптимизация хвостовой рекурсии
    ФУНКЦИЯ tailRecursionOptimize(fn):
        ВОЗВРАТ (...аргументы) -> {
            текущиеАргументы = аргументы

            ПОКА ИСТИНА:
                результат = fn.применить(ЭТО, текущиеАргументы)

                // Если результат - объект с индикатором продолжения
                ЕСЛИ результат И результат.continue И массив(результат.args):
                    текущиеАргументы = результат.args
                    ПРОДОЛЖИТЬ
                КОНЕЦ ЕСЛИ

                ВОЗВРАТ результат
        }

    // Оптимизация вычислений с аккумулятором
    ФУНКЦИЯ accumulate(итерируемый, операция, начальное_значение = 0):
        результат = начальное_значение

        ДЛЯ каждого элемента в итерируемый:
            результат = операция(результат, элемент)

            // Периодическая проверка прерывания для предотвращения блокировки
            ЕСЛИ shouldYield():
                // В реальном приложении здесь может быть yield для Web Workers
                // или передача управления обратно в event loop
            КОНЕЦ ЕСЛИ

        ВОЗВРАТ результат

    ФУНКЦИЯ shouldYield():
        // Простая проверка для определения необходимости "yield"
        ВОЗВРАТ performance.now() % 10 < 0.5 // Имитация периодического yield

    // Оптимизация рекурсивного обхода DOM
    АСИНХРОННАЯ ФУНКЦИЯ traverseDOMOptimized(node, callback):
        стек = [node]
        обработано = 0

        ПОКА длина(стек) > 0:
            текущий_узел = стек.поп()
            callback(текущий_узел)
            обработано++

            // Добавляем детей в стек (в обратном порядке для сохранения порядка)
            ДЛЯ i ОТ длина(текущий_узел.children) - 1 ДО 0:
                стек.добавить(текущий_узел.children[i])

            // Периодическая передача управления для предотвращения блокировки
            ЕСЛИ обработано % 1000 === 0:
                // В реальном приложении: передача управления через setTimeout или requestIdleCallback
                ЖДАТЬ НОВОЕ_ОБЕЩАНИЕ(разрешить -> setTimeout(разрешить, 0))
        КОНЕЦ ПОКА
КОНЕЦ КЛАССА
```

```javascript
class RecursiveOptimizer {
    // Оптимизация хвостовой рекурсии
    tailRecursionOptimize(fn) {
        return (...args) => {
            let currentArgs = args;

            while (true) {
                const result = fn.apply(this, currentArgs);

                // Если результат - объект с индикатором продолжения
                if (result && result.continue && Array.isArray(result.args)) {
                    currentArgs = result.args;
                    continue;
                }

                return result;
            }
        };
    }

    // Оптимизация вычислений с аккумулятором
    accumulate(iterable, operation, initial = 0) {
        let result = initial;

        for (const item of iterable) {
            result = operation(result, item);

            // Периодическая проверка прерывания для предотвращения блокировки
            if (this.shouldYield()) {
                // В реальном приложении здесь может быть yield для Web Workers
                // или передача управления обратно в event loop
            }
        }

        return result;
    }

    shouldYield() {
        // Простая проверка для определения необходимости "yield"
        return performance.now() % 10 < 0.5; // Имитация периодического yield
    }

    // Оптимизация рекурсивного обхода DOM
    traverseDOMOptimized(node, callback) {
        const stack = [node];
        let processed = 0;

        while (stack.length > 0) {
            const currentNode = stack.pop();
            callback(currentNode);
            processed++;

            // Добавляем детей в стек (в обратном порядке для сохранения порядка)
            for (let i = currentNode.children.length - 1; i >= 0; i--) {
                stack.push(currentNode.children[i]);
            }

            // Периодическая передача управления для предотвращения блокировки
            if (processed % 1000 === 0) {
                // В реальном приложении: передача управления через setTimeout или requestIdleCallback
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
    }
}

// Пример оптимизированной рекурсивной функции
const optimizer = new RecursiveOptimizer();

// Факториал с хвостовой рекурсией
const factorialTailRecursive = optimizer.tailRecursionOptimize((n, accumulator = 1) => {
    if (n <= 1) {
        return accumulator;
    }

    // Возвращаем объект с инструкцией продолжения
    return {
        continue: true,
        args: [n - 1, n * accumulator]
    };
});

// Использование
const optimizedFactorial = optimizer.tailRecursionOptimize(factorialTailRecursive);
console.log(optimizedFactorial(5)); // 120
```

## Современные алгоритмы оптимизации в 2025 году

### 1. Алгоритм адаптивной оптимизации (Adaptive Optimization)

**Псевдокод:**
```
КЛАСС AdaptiveOptimizer:
    КОНСТРУКТОР():
        this.performanceMonitor = новый PerformanceMonitor()
        this.optimizationStrategies = новый Map()
        this.currentStrategy = 'balanced'
        this.performanceHistory = []
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ adaptToEnvironment():
        // Оценка текущей производительности
        performanceMetrics = ЖДАТЬ this.performanceMonitor.getMetrics()

        // Анализ производительности и выбор стратегии
        ЕСЛИ performanceMetrics.cpuUsage > 80:
            this.currentStrategy = 'efficiency' // Приоритет эффективности
        ИНАЧЕ ЕСЛИ performanceMetrics.memoryUsage > 80:
            this.currentStrategy = 'memory' // Приоритет экономии памяти
        ИНАЧЕ ЕСЛИ performanceMetrics.responseTime > 100:
            this.currentStrategy = 'responsiveness' // Приоритет отзывчивости
        ИНАЧЕ:
            this.currentStrategy = 'balanced' // Сбалансированная стратегия

        // Применение выбранной стратегии
        applyOptimizationStrategy(this.currentStrategy, performanceMetrics)

        // Сохранение метрик для исторического анализа
        this.performanceHistory.добавить({
            ...performanceMetrics,
            strategy: this.currentStrategy,
            timestamp: текущее_время()
        })

        // Очистка истории, если она слишком длинная
        ЕСЛИ длина(this.performanceHistory) > 100:
            this.performanceHistory = this.performanceHistory.взять(-50) // Оставляем последние 50 записей

    ФУНКЦИЯ applyOptimizationStrategy(стратегия, метрики):
        ВЫБОР:
            СЛУЧАЙ 'efficiency':
                // Уменьшаем частоту обновлений, используем более простые алгоритмы
                setUpdateFrequency(50) // 50мс между обновлениями
                useSimpleAlgorithms()
            СЛУЧАЙ 'memory':
                // Активируем агрессивное кэширование, уменьшаем размер буферов
                enableAggressiveCaching()
                reduceBufferSizes()
            СЛУЧАЙ 'responsiveness':
                // Увеличиваем частоту обновлений, используем оптимизированные алгоритмы
                setUpdateFrequency(16) // ~60fps
                useOptimizedAlgorithms()
            ИНАЧЕ: // balanced
                // Используем стандартные настройки
                setUpdateFrequency(30) // 30мс между обновлениями
                useStandardAlgorithms()

    ФУНКЦИЯ getOptimalStrategy():
        ВОЗВРАТ this.currentStrategy
КОНЕЦ КЛАССА
```

```javascript
class AdaptiveOptimizer {
    constructor() {
        this.performanceMonitor = new PerformanceMonitor();
        this.optimizationStrategies = new Map();
        this.currentStrategy = 'balanced';
        this.performanceHistory = [];
    }

    async adaptToEnvironment() {
        // Оценка текущей производительности
        const performanceMetrics = await this.performanceMonitor.getMetrics();

        // Анализ производительности и выбор стратегии
        if (performanceMetrics.cpuUsage > 80) {
            this.currentStrategy = 'efficiency'; // Приоритет эффективности
        } else if (performanceMetrics.memoryUsage > 80) {
            this.currentStrategy = 'memory'; // Приоритет экономии памяти
        } else if (performanceMetrics.responseTime > 100) {
            this.currentStrategy = 'responsiveness'; // Приоритет отзывчивости
        } else {
            this.currentStrategy = 'balanced'; // Сбалансированная стратегия
        }

        // Применение выбранной стратегии
        this.applyOptimizationStrategy(this.currentStrategy, performanceMetrics);

        // Сохранение метрик для исторического анализа
        this.performanceHistory.push({
            ...performanceMetrics,
            strategy: this.currentStrategy,
            timestamp: Date.now()
        });

        // Очистка истории, если она слишком длинная
        if (this.performanceHistory.length > 100) {
            this.performanceHistory = this.performanceHistory.slice(-50); // Оставляем последние 50 записей
        }
    }

    applyOptimizationStrategy(strategy, metrics) {
        switch (strategy) {
            case 'efficiency':
                // Уменьшаем частоту обновлений, используем более простые алгоритмы
                this.setUpdateFrequency(50); // 50мс между обновлениями
                this.useSimpleAlgorithms();
                break;
            case 'memory':
                // Активируем агрессивное кэширование, уменьшаем размер буферов
                this.enableAggressiveCaching();
                this.reduceBufferSizes();
                break;
            case 'responsiveness':
                // Увеличиваем частоту обновлений, используем оптимизированные алгоритмы
                this.setUpdateFrequency(16); // ~60fps
                this.useOptimizedAlgorithms();
                break;
            default: // balanced
                // Используем стандартные настройки
                this.setUpdateFrequency(30); // 30мс между обновлениями
                this.useStandardAlgorithms();
        }
    }

    setUpdateFrequency(interval) {
        // Установка частоты обновлений
        this.updateInterval = interval;
    }

    useSimpleAlgorithms() {
        // Использование менее ресурсоемких алгоритмов
        this.currentAlgorithms = 'simple';
    }

    useOptimizedAlgorithms() {
        // Использование высокопроизводительных алгоритмов
        this.currentAlgorithms = 'optimized';
    }

    useStandardAlgorithms() {
        // Использование стандартных алгоритмов
        this.currentAlgorithms = 'standard';
    }

    enableAggressiveCaching() {
        // Включение агрессивного кэширования
        this.aggressiveCaching = true;
    }

    reduceBufferSizes() {
        // Уменьшение размеров буферов
        this.bufferSizeMultiplier = 0.5;
    }

    getOptimalStrategy() {
        return this.currentStrategy;
    }
}
```

### 2. Алгоритм предсказательной оптимизации (Predictive Optimization)

**Псевдокод:**
```
КЛАСС PredictiveOptimizer:
    КОНСТРУКТОР():
        this.usagePatterns = {}
        this.predictionModel = {}
        this.prefetchQueue = []
    КОНЕЦ КОНСТРУКТОРА

    ФУНКЦИЯ recordUsage(путь, параметры, время):
        ключ = `${путь}_${JSON.stringify(параметры)}`
        
        ЕСЛИ !this.usagePatterns.содержит(ключ):
            this.usagePatterns[ключ] = {
                count: 0,
                totalTime: 0,
                avgTime: 0,
                lastAccess: время
            }
        КОНЕЦ ЕСЛИ

        запись = this.usagePatterns[ключ]
        запись.count++
        запись.totalTime += время
        запись.avgTime = запись.totalTime / запись.count
        запись.lastAccess = время

    ФУНКЦИЯ predictNextActions(текущий_путь, текущие_параметры):
        // Простая эвристика: предсказываем действия на основе исторических данных
        возможные_действия = []
        
        // Поиск паттернов в исторических данных
        ДЛЯ каждой (путь, данные) в entries(this.usagePatterns):
            ЕСЛИ данные.count > 5: // Минимум 5 использований
                вероятность = данные.count / 100 // Нормализованная вероятность
                возможные_действия.добавить({
                    путь,
                    вероятность,
                    ожидаемое_время: данные.avgTime
                })
        КОНЕЦ ДЛЯ

        // Сортировка по вероятности
        возможные_действия.сортировать((a, b) -> b.вероятность - a.вероятность)

        // Возвращаем топ 5 предсказанных действий
        ВОЗВРАТ возможные_действия.взять(5)

    АСИНХРОННАЯ ФУНКЦИЯ prefetchResources(предсказанные_действия):
        // Предварительная загрузка ресурсов для предсказанных действий
        ДЛЯ каждого действия в предсказанные_действия:
            ЕСЛИ действие.вероятность > 0.3: // Порог для предзагрузки
                добавитьВОчередьПредзагрузки(действие.путь)

    ФУНКЦИЯ добавитьВОчередьПредзагрузки(путь):
        ЕСЛИ !this.prefetchQueue.содержит(путь):
            this.prefetchQueue.добавить(путь)
            // Асинхронная предзагрузка с низким приоритетом
            установитьТаймаут(() -> выполнитьПредзагрузку(путь), 1000)
КОНЕЦ КЛАССА
```

```javascript
class PredictiveOptimizer {
    constructor() {
        this.usagePatterns = {};
        this.predictionModel = {};
        this.prefetchQueue = [];
    }

    recordUsage(path, parameters, time) {
        const key = `${path}_${JSON.stringify(parameters)}`;
        
        if (!this.usagePatterns[key]) {
            this.usagePatterns[key] = {
                count: 0,
                totalTime: 0,
                avgTime: 0,
                lastAccess: time
            };
        }

        const record = this.usagePatterns[key];
        record.count++;
        record.totalTime += time;
        record.avgTime = record.totalTime / record.count;
        record.lastAccess = time;
    }

    predictNextActions(currentPath, currentParams) {
        // Простая эвристика: предсказываем действия на основе исторических данных
        const possibleActions = [];
        
        // Поиск паттернов в исторических данных
        for (const [path, data] of Object.entries(this.usagePatterns)) {
            if (data.count > 5) { // Минимум 5 использований
                const probability = data.count / 100; // Нормализованная вероятность
                possibleActions.push({
                    path,
                    probability,
                    expectedTime: data.avgTime
                });
            }
        }

        // Сортировка по вероятности
        possibleActions.sort((a, b) => b.probability - a.probability);

        // Возвращаем топ 5 предсказанных действий
        return possibleActions.slice(0, 5);
    }

    async prefetchResources(predictedActions) {
        // Предварительная загрузка ресурсов для предсказанных действий
        for (const action of predictedActions) {
            if (action.probability > 0.3) { // Порог для предзагрузки
                this.addToPrefetchQueue(action.path);
            }
        }
    }

    addToPrefetchQueue(path) {
        if (!this.prefetchQueue.includes(path)) {
            this.prefetchQueue.push(path);
            // Асинхронная предзагрузка с низким приоритетом
            setTimeout(() => this.performPrefetch(path), 1000);
        }
    }

    async performPrefetch(path) {
        try {
            // Предварительная загрузка ресурсов
            const response = await fetch(path, {
                priority: 'low' // Низкий приоритет для предзагрузки
            });
            
            // Кэширование результата
            if (response.ok) {
                const data = await response.text();
                // Сохраняем в кэше для будущего использования
                this.cachePrefetchedData(path, data);
            }
        } catch (error) {
            console.warn(`Предзагрузка не удалась для ${path}:`, error);
        }
    }

    cachePrefetchedData(path, data) {
        // Реализация кэширования предзагруженных данных
        if (!this.prefetchCache) {
            this.prefetchCache = new Map();
        }
        this.prefetchCache.set(path, {
            data,
            timestamp: Date.now(),
            ttl: 5 * 60 * 1000 // 5 минут
        });
    }

    getCachedPrefetch(path) {
        if (!this.prefetchCache || !this.prefetchCache.has(path)) {
            return null;
        }

        const cached = this.prefetchCache.get(path);
        if (Date.now() - cached.timestamp > cached.ttl) {
            // Удаление устаревшего кэша
            this.prefetchCache.delete(path);
            return null;
        }

        return cached.data;
    }
}
```

## Практические рекомендации

### 1. Мониторинг производительности

**Псевдокод:**
```
КЛАСС PerformanceMonitor:
    КОНСТРУКТОР():
        this.metrics = {}
        this.observers = []
    КОНЕЦ КОНСТРУКТОРА

    АСИНХРОННАЯ ФУНКЦИЯ getMetrics():
        // Сбор метрик производительности
        метрики = {
            cpuUsage: измеритьCPUUsage(),
            memoryUsage: измеритьMemoryUsage(),
            responseTime: измеритьResponseTime(),
            fps: измеритьFPS(),
            layoutShifts: измеритьLayoutShifts()
        }
        
        ВОЗВРАТ метрики

    ФУНКЦИЯ измеритьCPUUsage():
        // Оценка использования CPU (упрощенная версия)
        startTime = performance.now()
        выполнитьВычисления()
        endTime = performance.now()
        ВОЗВРАТ ((endTime - startTime) / 100) * 100 // Процент от 100мс

    ФУНКЦИЯ измеритьMemoryUsage():
        ЕСЛИ performance.memory:
            ВОЗВРАТ (performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100
        ИНАЧЕ:
            ВОЗВРАТ 0 // Не поддерживается в некоторых браузерах

    АСИНХРОННАЯ ФУНКЦИЯ измеритьResponseTime():
        startTime = performance.now()
        ЖДАТЬ new Promise(resolve -> setTimeout(resolve, 0))
        ВОЗВРАТ performance.now() - startTime

    ФУНКЦИЯ измеритьFPS():
        кадры = 0
        startTime = performance.now()
        
        измерить = () -> {
            кадры++
            currentTime = performance.now()
            ЕСЛИ currentTime - startTime >= 1000: // 1 секунда
                fps = кадры
                кадры = 0
                startTime = currentTime
                ВОЗВРАТ fps
            ИНАЧЕ:
                requestAnimationFrame(измерить)
        }
        
        requestAnimationFrame(измерить)
КОНЕЦ КЛАССА
```

```javascript
class PerformanceMonitor {
    constructor() {
        this.metrics = {};
        this.observers = [];
    }

    async getMetrics() {
        // Сбор метрик производительности
        const metrics = {
            cpuUsage: this.measureCPUUsage(),
            memoryUsage: this.measureMemoryUsage(),
            responseTime: await this.measureResponseTime(),
            fps: this.measureFPS(),
            layoutShifts: this.measureLayoutShifts()
        };
        
        return metrics;
    }

    measureCPUUsage() {
        // Оценка использования CPU (упрощенная версия)
        const startTime = performance.now();
        this.performCalculations();
        const endTime = performance.now();
        return ((endTime - startTime) / 100) * 100; // Процент от 100мс
    }

    performCalculations() {
        // Выполнение вычислений для измерения CPU
        let result = 0;
        for (let i = 0; i < 100000; i++) {
            result += Math.sqrt(i);
        }
        return result;
    }

    measureMemoryUsage() {
        if (performance.memory) {
            return (performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100;
        } else {
            return 0; // Не поддерживается в некоторых браузерах
        }
    }

    async measureResponseTime() {
        const startTime = performance.now();
        await new Promise(resolve => setTimeout(resolve, 0));
        return performance.now() - startTime;
    }

    measureFPS() {
        let frames = 0;
        const startTime = performance.now();
        let fps = 0;

        const measure = () => {
            frames++;
            const currentTime = performance.now();
            if (currentTime - startTime >= 1000) { // 1 секунда
                fps = frames;
                frames = 0;
                // В реальном приложении можно вернуть значение
            } else {
                requestAnimationFrame(measure);
            }
        };

        requestAnimationFrame(measure);
        return fps;
    }

    measureLayoutShifts() {
        // Подсчет сдвигов макета
        let cumulativeShift = 0;
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'layout-shift') {
                    cumulativeShift += entry.value;
                }
            }
        });

        observer.observe({ entryTypes: ['layout-shift'] });
        return cumulativeShift;
    }
}
```

### 2. Оптимизация при загрузке страницы

**Псевдокод:**
```
ФУНКЦИЯ optimizePageLoad():
    // Оптимизация критического пути рендеринга
    встроитьКритическиеСтили()
    отложитьНеиспользуемыеCSS()
    предзагрузитьКритическиеШрифты()
    установитьПравильныеПриоритетыРесурсов()

ФУНКЦИЯ встроитьКритическиеСтили():
    // Извлечение и встраивание критических CSS-правил
    критические_стили = извлечьКритическиеСтили()
    создатьStyleElement(критические_стили)

ФУНКЦИЯ отложитьНеиспользуемыеCSS():
    // Отложенная загрузка неиспользуемых стилей
    неиспользуемые_стили = найтиНеиспользуемыеСтили()
    для каждого файла в неиспользуемые_стили:
        загрузитьОтложеноСтили(файл)

ФУНКЦИЯ предзагрузитьКритическиеШрифты():
    // Предзагрузка критических шрифтов
    критические_шрифты = получитьКритическиеШрифты()
    для каждого шрифта в критические_шрифты:
        создатьLinkElement('preload', шрифт, 'font', 'anonymous')
```

```javascript
function optimizePageLoad() {
    // Оптимизация критического пути рендеринга
    embedCriticalStyles();
    deferUnusedCSS();
    preloadCriticalFonts();
    setResourcePriorities();
}

function embedCriticalStyles() {
    // Извлечение и встраивание критических CSS-правил
    const criticalStyles = extractCriticalStyles();
    const styleElement = document.createElement('style');
    styleElement.textContent = criticalStyles;
    document.head.appendChild(styleElement);
}

function deferUnusedCSS() {
    // Отложенная загрузка неиспользуемых стилей
    const unusedStyles = findUnusedStyles();
    unusedStyles.forEach(file => {
        loadDeferredStyles(file);
    });
}

function loadDeferredStyles(href) {
    // Асинхронная загрузка стилей с низким приоритетом
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'style';
    link.href = href;
    link.onload = () => {
        link.rel = 'stylesheet';
    };
    document.head.appendChild(link);
}

function preloadCriticalFonts() {
    // Предзагрузка критических шрифтов
    const criticalFonts = getCriticalFonts();
    criticalFonts.forEach(font => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'font';
        link.href = font;
        link.type = 'font/woff2';
        link.crossOrigin = 'anonymous';
        document.head.appendChild(link);
    });
}

function setResourcePriorities() {
    // Установка правильных приоритетов ресурсов
    const resources = [
        { url: '/critical-script.js', priority: 'high' },
        { url: '/analytics.js', priority: 'low' },
        { url: '/background-image.jpg', priority: 'low' }
    ];

    resources.forEach(resource => {
        if (resource.priority === 'low') {
            // Отложенная загрузка низкоприоритетных ресурсов
            setTimeout(() => {
                if (resource.url.endsWith('.js')) {
                    loadScript(resource.url);
                } else if (resource.url.endsWith('.jpg')) {
                    preloadImage(resource.url);
                }
            }, 3000);
        }
    });
}
```

## Заключение

Алгоритмы оптимизации производительности являются ключевыми для создания высококачественных веб-приложений. Важны как традиционные методы оптимизации (оптимизация DOM, кэширование, ленивая загрузка), так и современные подходы (адаптивная оптимизация, предсказательная загрузка, машинное обучение для оптимизации). Понимание этих алгоритмов позволяет создавать быстрые, отзывчивые и эффективные веб-приложения.

## См. также

- [[Алгоритмы-для-работы-с-DOM]]
- [[Алгоритмы-оптимизации-рендеринга]]
- [[Алгоритмы-анимаций]]
- [[Структуры-данных-для-фронтенда]]

## Теги

#frontend #algorithms #performance #optimization #javascript #memory #rendering #web-performance