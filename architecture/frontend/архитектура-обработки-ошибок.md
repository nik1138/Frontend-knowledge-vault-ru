---
aliases: ["Error Handling Architecture", "Error Management", "Error Handling", "Обработка ошибок", "Архитектура обработки ошибок", "Error Architecture"]
tags: ["#architecture", "#error-handling", "#monitoring", "#observability", "#frontend", "#backend", "#microservices", "#ci-cd", "#testing", "#api-integration", "#feature-flags", "#rum"]
---

# Unified Error Handling Architecture: Комплексное руководство по архитектуре обработки ошибок

## Введение в Error Handling Architecture

Error Handling Architecture - это архитектурный подход, фокусирующийся на создании систем, которые эффективно обрабатывают, регистрируют и восстанавливаются после ошибок. Архитектура обработки ошибок охватывает все аспекты приложения: от фронтенд-компонентов до бэкенд-сервисов, включая микросервисы, API-интеграции, фича-флаги и мониторинг.

Эффективная архитектура обработки ошибок:
- Обеспечивает стабильность и надежность систем
- Повышает пользовательский опыт
- Упрощает диагностику и отладку
- Уменьшает время простоя
- Обеспечивает прозрачность для разработчиков

## Основные компоненты Error Handling Architecture

### 1. Иерархия ошибок

```javascript
// Иерархия ошибок для приложения
class AppError extends Error {
  constructor(message, code = 'APP_ERROR', status = 500, metadata = {}) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.status = status;
    this.metadata = metadata;
    this.timestamp = new Date().toISOString();
    
    // Поддержка стека вызовов
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

class ValidationError extends AppError {
  constructor(message, field = null, value = null) {
    super(message, 'VALIDATION_ERROR', 400, { field, value });
  }
}

class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
  }
}

class AuthorizationError extends AppError {
  constructor(message = 'Access denied') {
    super(message, 'AUTHORIZATION_ERROR', 403);
  }
}

class NotFoundError extends AppError {
  constructor(resource, id = null) {
    const message = id ? `Resource ${resource} with id ${id} not found` : `Resource ${resource} not found`;
    super(message, 'NOT_FOUND_ERROR', 404, { resource, id });
  }
}

class NetworkError extends AppError {
  constructor(message, url, method) {
    super(message, 'NETWORK_ERROR', 0, { url, method }); // 0 означает сетевую ошибку
  }
}

class ServiceError extends AppError {
  constructor(service, originalError) {
    super(
      `Service ${service} unavailable: ${originalError.message}`, 
      'SERVICE_ERROR', 
      503, 
      { service, originalError: originalError.message }
    );
  }
}

class RateLimitError extends AppError {
  constructor(message = 'Rate limit exceeded', retryAfter = null) {
    super(message, 'RATE_LIMIT_ERROR', 429, { retryAfter });
  }
}
```

### 2. Централизованная обработка ошибок

```javascript
// Центральный обработчик ошибок
class ErrorHandler {
  constructor(config = {}) {
    this.errorHandlers = new Map();
    this.fallbackHandler = this.defaultHandler.bind(this);
    this.logger = config.logger || console;
    this.metrics = config.metrics;
    this.alerting = config.alerting;
    this.errorReporting = config.errorReporting;
    this.rateLimiting = new Map(); // Для трекинга частоты ошибок
  }

  // Регистрация специфических обработчиков ошибок
  registerHandler(errorType, handler) {
    this.errorHandlers.set(errorType, handler);
  }

  // Обработка ошибки
  async handle(error, context = {}) {
    // Увеличение счетчика ошибок
    this.incrementErrorCount(error);
    
    // Логирование ошибки
    this.logError(error, context);
    
    // Отправка метрик
    this.sendMetrics(error, context);
    
    // Проверка необходимости алертинга
    await this.checkAlerting(error, context);
    
    // Определение подходящего обработчика
    let handler = this.errorHandlers.get(error.constructor.name) || this.fallbackHandler;
    
    try {
      return await handler(error, context);
    } catch (handlerError) {
      // Если обработчик ошибок сам завершается с ошибкой, используем fallback
      return await this.fallbackHandler(handlerError, context);
    }
  }

  async defaultHandler(error, context) {
    // Стандартная обработка ошибки
    const response = {
      error: {
        code: error.code || 'INTERNAL_ERROR',
        message: error.message,
        timestamp: error.timestamp || new Date().toISOString(),
        correlationId: context.correlationId || this.generateCorrelationId(),
        ...(error.metadata || {})
      }
    };

    // Возвращаем 500 для серверных ошибок, иначе используем статус ошибки
    const statusCode = error.status || 500;
    
    return { response, statusCode };
  }

  logError(error, context) {
    const logEntry = {
      level: 'error',
      timestamp: new Date().toISOString(),
      error: {
        name: error.constructor.name,
        message: error.message,
        stack: error.stack,
        code: error.code,
        status: error.status,
        metadata: error.metadata
      },
      context: context,
      correlationId: context.correlationId || this.generateCorrelationId()
    };

    this.logger.error(logEntry);
  }

  sendMetrics(error, context) {
    if (this.metrics) {
      this.metrics.increment('errors_total', {
        error_type: error.constructor.name,
        error_code: error.code,
        status_code: error.status
      });
      
      // Измерение времени обработки ошибки
      this.metrics.histogram('error_handling_duration', Date.now() - (context.startTime || Date.now()));
    }
  }

  async checkAlerting(error, context) {
    if (!this.alerting) return;

    // Проверка частоты ошибок для алертинга
    const errorKey = `${error.constructor.name}_${context.service || 'unknown'}`;
    const now = Date.now();
    const window = 60000; // 1 минута
    const threshold = 10; // порог для алертинга

    if (!this.rateLimiting.has(errorKey)) {
      this.rateLimiting.set(errorKey, []);
    }

    const errors = this.rateLimiting.get(errorKey);
    errors.push(now);
    
    // Удаление ошибок за пределами окна
    const recentErrors = errors.filter(time => now - time <= window);
    this.rateLimiting.set(errorKey, recentErrors);

    if (recentErrors.length >= threshold) {
      await this.alerting.sendAlert({
        type: 'ERROR_RATE_EXCEEDED',
        message: `High error rate: ${recentErrors.length} ${error.constructor.name} errors in last minute`,
        error: error,
        context: context
      });
    }
  }

  incrementErrorCount(error) {
    if (this.metrics) {
      this.metrics.increment('error_count', {
        error_type: error.constructor.name,
        error_code: error.code
      });
    }
  }

  generateCorrelationId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
}

// Инициализация глобального обработчика ошибок
const globalErrorHandler = new ErrorHandler({
  logger: console,
  metrics: null, // будет внедрен позже
  alerting: null  // будет внедрен позже
});
```

### 3. Обработка ошибок в Express.js

```javascript
// Middleware для обработки ошибок в Express.js
class ExpressErrorHandler {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
  }

  // Middleware для обработки ошибок
  middleware() {
    return (error, req, res, next) => {
      // Преобразование обычной ошибки в прикладную ошибку
      let appError = error;
      if (!(error instanceof AppError)) {
        appError = new AppError(
          error.message || 'Internal server error',
          'INTERNAL_ERROR',
          error.status || 500,
          { originalError: error }
        );
      }

      // Контекст для обработки ошибки
      const context = {
        service: 'express-api',
        method: req.method,
        url: req.url,
        userId: req.user?.id,
        correlationId: req.headers['x-correlation-id'] || this.generateCorrelationId(),
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        startTime: req.startTime || Date.now()
      };

      // Обработка ошибки
      this.errorHandler.handle(appError, context)
        .then(result => {
          res.status(result.statusCode).json(result.response);
        })
        .catch(handlerError => {
          // Если обработка ошибки завершается неудачей, отправляем базовую ошибку
          console.error('Error in error handler:', handlerError);
          res.status(500).json({
            error: {
              code: 'INTERNAL_ERROR',
              message: 'Internal server error'
            }
          });
        });
    };
  }

  // Middleware для логирования запросов
  loggingMiddleware() {
    return (req, res, next) => {
      req.startTime = Date.now();
      req.correlationId = req.headers['x-correlation-id'] || this.generateCorrelationId();
      
      res.on('finish', () => {
        const duration = Date.now() - req.startTime;
        console.log(`[${req.correlationId}] ${req.method} ${req.url} - ${res.statusCode} - ${duration}ms`);
      });
      
      next();
    };
  }

  generateCorrelationId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
}
```

## Error Handling в микросервисной архитектуре

### 1. Обработка ошибок между сервисами

```javascript
// Клиент для взаимодействия между микросервисами с обработкой ошибок
class MicroserviceClient {
  constructor(options = {}) {
    this.timeout = options.timeout || 5000;
    this.retryAttempts = options.retryAttempts || 3;
    this.retryDelay = options.retryDelay || 1000;
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      timeout: 60000,
      resetTimeout: 30000
    });
    this.errorHandler = options.errorHandler;
    this.metrics = options.metrics;
  }

  async call(service, endpoint, data = null, options = {}) {
    const context = {
      service,
      endpoint,
      method: options.method || 'POST',
      data,
      startTime: Date.now()
    };

    try {
      // Проверка circuit breaker
      if (!this.circuitBreaker.canExecute()) {
        throw new ServiceError(service, new Error('Service temporarily unavailable due to circuit breaker'));
      }

      // Выполнение запроса с повторными попытками
      const response = await this.executeWithRetry(service, endpoint, data, options);
      
      // Сброс счетчика ошибок при успешном выполнении
      this.circuitBreaker.onSuccess();
      
      return response;
    } catch (error) {
      // Обработка ошибки
      this.circuitBreaker.onFailure();
      
      // Преобразование ошибки в доменную
      const serviceError = this.mapToDomainError(error, service, endpoint);
      
      // Обработка ошибки через центральный обработчик
      if (this.errorHandler) {
        await this.errorHandler.handle(serviceError, context);
      }
      
      // Отправка метрики
      if (this.metrics) {
        this.metrics.increment('service_call_error', {
          service,
          endpoint,
          error_type: serviceError.constructor.name
        });
      }
      
      throw serviceError;
    }
  }

  async executeWithRetry(service, endpoint, data, options) {
    let lastError;

    for (let attempt = 0; attempt <= this.retryAttempts; attempt++) {
      try {
        return await this.makeRequest(service, endpoint, data, options);
      } catch (error) {
        lastError = error;
        
        if (attempt < this.retryAttempts) {
          // Проверка, стоит ли повторять попытку
          if (this.shouldRetry(error)) {
            await this.delay(this.retryDelay * Math.pow(2, attempt)); // exponential backoff
          } else {
            // Если ошибка не подлежит повтору, прерываем цикл
            break;
          }
        }
      }
    }

    throw lastError;
  }

  async makeRequest(service, endpoint, data, options) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const url = `${this.getServiceUrl(service)}${endpoint}`;
      const response = await fetch(url, {
        method: options.method || 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Service-Call': 'true',
          'X-Service-Source': 'main-service'
        },
        body: data ? JSON.stringify(data) : undefined,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new NetworkError('Request timeout', `${this.getServiceUrl(service)}${endpoint}`, options.method);
      }
      
      throw error;
    }
  }

  shouldRetry(error) {
    // Повторять попытки только для определенных типов ошибок
    return error instanceof NetworkError || 
           (error.status && error.status >= 500) || 
           error.message.includes('ECONNREFUSED') ||
           error.message.includes('ETIMEDOUT');
  }

  mapToDomainError(error, service, endpoint) {
    if (error instanceof NetworkError) {
      return new ServiceError(service, error);
    }
    
    if (error.status === 404) {
      return new NotFoundError(`${service} service endpoint`, endpoint);
    }
    
    if (error.status === 401 || error.status === 403) {
      return new AuthorizationError(`Access denied to ${service} service`);
    }
    
    return new ServiceError(service, error);
  }

  getServiceUrl(service) {
    // В реальности URL сервиса будет браться из service discovery
    const serviceUrls = {
      'user-service': process.env.USER_SERVICE_URL || 'http://localhost:3001',
      'order-service': process.env.ORDER_SERVICE_URL || 'http://localhost:3002',
      'payment-service': process.env.PAYMENT_SERVICE_URL || 'http://localhost:3003'
    };
    
    return serviceUrls[service] || `http://${service}:3000`;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 2. Circuit Breaker Pattern

```javascript
// Реализация Circuit Breaker для защиты от каскадных сбоев
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.resetTimeout = options.resetTimeout || 30000;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.nextAttemptTime = null;
    this.successCount = 0;
    this.halfOpenSuccessThreshold = options.halfOpenSuccessThreshold || 3;
  }

  canExecute() {
    if (this.state === 'OPEN') {
      if (Date.now() >= this.nextAttemptTime) {
        this.state = 'HALF_OPEN';
        this.successCount = 0;
        return true;
      }
      return false;
    }
    return true;
  }

  onSuccess() {
    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      if (this.successCount >= this.halfOpenSuccessThreshold) {
        this.state = 'CLOSED';
        this.failureCount = 0;
      }
    } else {
      this.failureCount = 0;
    }
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttemptTime = Date.now() + this.resetTimeout;
    }
  }

  getStatus() {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      lastFailureTime: this.lastFailureTime,
      nextAttemptTime: this.nextAttemptTime
    };
  }

  reset() {
    this.state = 'CLOSED';
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
    this.nextAttemptTime = null;
  }
}
```

## Error Handling в API интеграциях

### 1. Обработка ошибок API

```javascript
// Клиент для внешних API с обработкой ошибок
class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.timeout = options.timeout || 10000;
    this.retryAttempts = options.retryAttempts || 3;
    this.retryDelay = options.retryDelay || 1000;
    this.rateLimiter = new TokenBucketLimiter(options.rateLimit || 100);
    this.errorHandler = options.errorHandler;
    this.metrics = options.metrics;
    this.cache = options.cache;
  }

  async request(endpoint, options = {}) {
    // Проверка рейт-лимита
    if (!this.rateLimiter.consume()) {
      const rateLimitError = new RateLimitError();
      if (this.errorHandler) {
        await this.errorHandler.handle(rateLimitError, {
          service: 'api-client',
          endpoint,
          method: options.method || 'GET'
        });
      }
      throw rateLimitError;
    }

    const context = {
      service: 'external-api',
      endpoint,
      method: options.method || 'GET',
      startTime: Date.now()
    };

    try {
      const response = await this.executeWithRetry(endpoint, options);
      return response;
    } catch (error) {
      // Обработка ошибки
      const apiError = this.mapToAPIError(error, endpoint, options.method);
      
      if (this.errorHandler) {
        await this.errorHandler.handle(apiError, context);
      }
      
      if (this.metrics) {
        this.metrics.increment('api_error', {
          endpoint,
          method: options.method || 'GET',
          error_type: apiError.constructor.name
        });
      }
      
      throw apiError;
    }
  }

  async executeWithRetry(endpoint, options) {
    let lastError;

    for (let attempt = 0; attempt <= this.retryAttempts; attempt++) {
      try {
        const cacheKey = this.getCacheKey(endpoint, options);
        
        // Проверка кэша для GET-запросов
        if (options.method === 'GET' && this.cache && this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }

        const response = await this.makeRequest(endpoint, options);
        
        // Кэширование ответа для GET-запросов
        if (options.method === 'GET' && this.cache) {
          this.cache.set(cacheKey, response);
        }
        
        return response;
      } catch (error) {
        lastError = error;
        
        if (attempt < this.retryAttempts && this.shouldRetry(error)) {
          await this.delay(this.retryDelay * Math.pow(2, attempt)); // exponential backoff
        } else {
          break;
        }
      }
    }

    throw lastError;
  }

  async makeRequest(endpoint, options) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new NetworkError('Request timeout', `${this.baseURL}${endpoint}`, options.method);
      }
      
      throw error;
    }
  }

  shouldRetry(error) {
    // Повторять попытки для сетевых ошибок и 5xx статусов
    return error instanceof NetworkError || 
           (error.status && error.status >= 500) ||
           error.message.includes('ECONNRESET') ||
           error.message.includes('ECONNREFUSED') ||
           error.message.includes('ETIMEDOUT');
  }

  mapToAPIError(error, endpoint, method) {
    if (error instanceof NetworkError) {
      return error;
    }
    
    if (error.status === 400) {
      return new ValidationError('Bad request', endpoint);
    }
    
    if (error.status === 401) {
      return new AuthenticationError('Authentication required');
    }
    
    if (error.status === 403) {
      return new AuthorizationError('Access denied');
    }
    
    if (error.status === 404) {
      return new NotFoundError('API endpoint', endpoint);
    }
    
    if (error.status === 429) {
      return new RateLimitError('Rate limit exceeded');
    }
    
    if (error.status >= 500) {
      return new AppError(`API service error: ${error.message}`, 'API_ERROR', error.status);
    }
    
    return new AppError(`API request failed: ${error.message}`, 'API_ERROR', error.status);
  }

  getCacheKey(endpoint, options) {
    return `${endpoint}_${options.method || 'GET'}_${JSON.stringify(options)}`;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Error Handling в фронтенд-приложениях

### 1. Обработка ошибок в React

```javascript
// Компонент для обработки ошибок в React
import React, { Component, createContext } from 'react';

// Контекст для обработки ошибок
const ErrorContext = createContext();

// Провайдер ошибок
export class ErrorProvider extends Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null,
      errorInfo: null,
      hasError: false
    };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo,
      hasError: true
    });

    // Отправка ошибки в сервис мониторинга
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Что-то пошло не так.</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
        </div>
      );
    }

    return (
      <ErrorContext.Provider value={{
        ...this.state,
        clearError: () => this.setState({ error: null, errorInfo: null, hasError: false })
      }}>
        {this.props.children}
      </ErrorContext.Provider>
    );
  }
}

// Хук для использования контекста ошибок
export const useError = () => {
  const context = React.useContext(ErrorContext);
  if (!context) {
    throw new Error('useError must be used within an ErrorProvider');
  }
  return context;
};

// Компонент отображения ошибки
export const ErrorMessage = ({ error, onRetry = null }) => {
  if (!error) return null;

  return (
    <div className="error-message">
      <div className="error-header">
        <h3>Произошла ошибка</h3>
        <button onClick={() => window.location.reload()}>Перезагрузить страницу</button>
        {onRetry && <button onClick={onRetry}>Повторить попытку</button>}
      </div>
      <div className="error-details">
        <p>{error.message}</p>
        {error.stack && (
          <details>
            <summary>Детали ошибки</summary>
            <pre>{error.stack}</pre>
          </details>
        )}
      </div>
    </div>
  );
};
```

### 2. Обработка ошибок в асинхронных операциях

```javascript
// Утилита для безопасного выполнения асинхронных операций
class AsyncOperationHandler {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
  }

  async safeExecute(operation, context = {}) {
    try {
      return await operation();
    } catch (error) {
      if (this.errorHandler) {
        await this.errorHandler.handle(error, {
          ...context,
          operation: operation.name || 'anonymous'
        });
      }
      
      // Возвращаем null или значение по умолчанию вместо выброса ошибки
      return null;
    }
  }

  // Выполнение нескольких операций с обработкой ошибок
  async safeAll(operations, context = {}) {
    const results = [];
    
    for (const [index, operation] of operations.entries()) {
      try {
        const result = await operation();
        results.push({ success: true, data: result, index });
      } catch (error) {
        if (this.errorHandler) {
          await this.errorHandler.handle(error, {
            ...context,
            operation: `operation_${index}`,
            index
          });
        }
        
        results.push({ success: false, error, index });
      }
    }
    
    return results;
  }

  // Выполнение нескольких операций параллельно с обработкой ошибок
  async safeAllSettled(operations, context = {}) {
    const promises = operations.map((operation, index) => 
      operation()
        .then(data => ({ success: true, data, index }))
        .catch(async error => {
          if (this.errorHandler) {
            await this.errorHandler.handle(error, {
              ...context,
              operation: `operation_${index}`,
              index
            });
          }
          return { success: false, error, index };
        })
    );
    
    return await Promise.all(promises);
  }
}
```

## Error Handling в фича-флагах

### 1. Обработка ошибок фича-флагов

```javascript
// Обработка ошибок в системе фича-флагов
class FeatureFlagErrorHandler {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
    this.fallbackValues = new Map(); // Значения по умолчанию для флагов
    this.errorCounts = new Map(); // Счетчик ошибок для каждого флага
  }

  async safeEvaluateFlag(flagService, flagName, context = {}) {
    try {
      // Проверяем, не превышен ли лимит ошибок для этого флага
      if (this.isFlagErrorRateExceeded(flagName)) {
        console.warn(`Flag ${flagName} temporarily disabled due to high error rate`);
        return this.getFallbackValue(flagName);
      }

      const result = await flagService.isEnabled(flagName, context);
      this.resetErrorCount(flagName);
      return result;
    } catch (error) {
      // Увеличиваем счетчик ошибок
      this.incrementErrorCount(flagName);
      
      // Логируем ошибку
      if (this.errorHandler) {
        await this.errorHandler.handle(
          new AppError(
            `Feature flag evaluation failed: ${error.message}`,
            'FEATURE_FLAG_ERROR',
            500,
            { flagName, error: error.message }
          ),
          { flagName, context }
        );
      }

      // Возвращаем значение по умолчанию
      return this.getFallbackValue(flagName);
    }
  }

  setFallbackValue(flagName, value) {
    this.fallbackValues.set(flagName, value);
  }

  getFallbackValue(flagName) {
    return this.fallbackValues.get(flagName) || false; // По умолчанию флаг отключен
  }

  incrementErrorCount(flagName) {
    const count = this.errorCounts.get(flagName) || 0;
    this.errorCounts.set(flagName, count + 1);
  }

  resetErrorCount(flagName) {
    this.errorCounts.set(flagName, 0);
  }

  isFlagErrorRateExceeded(flagName) {
    const count = this.errorCounts.get(flagName) || 0;
    return count >= 5; // Если 5 и более ошибок подряд, считаем флаг проблемным
  }

  // Метод для сброса всех счетчиков ошибок (например, по расписанию)
  resetAllErrorCounts() {
    this.errorCounts.clear();
  }
}

// Пример использования в сервисе фича-флагов
class FeatureFlagService {
  constructor(config = {}) {
    this.config = config;
    this.errorHandler = config.errorHandler;
    this.flagErrorHandler = new FeatureFlagErrorHandler(this.errorHandler);
  }

  async isEnabled(flagName, context = {}) {
    return await this.flagErrorHandler.safeEvaluateFlag(this, flagName, context);
  }

  // Установка значений по умолчанию для флагов
  setDefaultFlags(defaultFlags) {
    for (const [flagName, defaultValue] of Object.entries(defaultFlags)) {
      this.flagErrorHandler.setFallbackValue(flagName, defaultValue);
    }
  }
}
```

## Real User Monitoring и Error Tracking

### 1. Система мониторинга ошибок пользователей

```javascript
// Система мониторинга ошибок для реальных пользователей
class RUMErrorTracker {
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/api/errors';
    this.sampleRate = options.sampleRate || 1.0; // 100% ошибок по умолчанию
    this.maxBatchSize = options.maxBatchSize || 10;
    this.flushInterval = options.flushInterval || 30000; // 30 секунд
    this.errorBuffer = [];
    this.metrics = options.metrics;
    this.sessionId = this.generateSessionId();
    this.userId = options.userId || null;
    
    this.startFlushing();
  }

  // Отправка ошибки
  async trackError(error, context = {}) {
    // Пропускаем ошибку с вероятностью в зависимости от sampleRate
    if (Math.random() > this.sampleRate) {
      return;
    }

    const errorData = {
      id: this.generateErrorId(),
      sessionId: this.sessionId,
      userId: this.userId,
      timestamp: new Date().toISOString(),
      message: error.message,
      stack: error.stack,
      name: error.name,
      type: 'javascript_error',
      url: typeof window !== 'undefined' ? window.location.href : context.url,
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : context.userAgent,
      context: context,
      performance: this.getPerformanceMetrics()
    };

    this.errorBuffer.push(errorData);

    // Отправка батча если достигли лимита
    if (this.errorBuffer.length >= this.maxBatchSize) {
      await this.flush();
    }

    // Отправка метрики
    if (this.metrics) {
      this.metrics.increment('errors_tracked');
    }
  }

  // Отправка батча ошибок
  async flush() {
    if (this.errorBuffer.length === 0) {
      return;
    }

    const batch = this.errorBuffer.splice(0, this.maxBatchSize);
    
    try {
      if (typeof fetch !== 'undefined') {
        await fetch(this.apiEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ errors: batch })
        });
      }
    } catch (flushError) {
      console.error('Failed to send error batch:', flushError);
      // Возвращаем ошибки в буфер для следующей попытки
      this.errorBuffer.unshift(...batch);
    }
  }

  // Запуск регулярной отправки
  startFlushing() {
    setInterval(() => {
      this.flush();
    }, this.flushInterval);
  }

  // Получение метрик производительности
  getPerformanceMetrics() {
    if (typeof performance === 'undefined') {
      return {};
    }

    const timing = performance.timing;
    return {
      pageLoadTime: timing.loadEventEnd - timing.navigationStart,
      domContentLoadedTime: timing.domContentLoadedEventEnd - timing.navigationStart,
      firstPaintTime: performance.getEntriesByType('paint')[0]?.startTime,
      firstContentfulPaintTime: performance.getEntriesByType('paint')[1]?.startTime
    };
  }

  generateErrorId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }

  generateSessionId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
}

// Глобальный обработчик ошибок JavaScript
class GlobalErrorHandler {
  constructor(rumTracker, errorHandler) {
    this.rumTracker = rumTracker;
    this.errorHandler = errorHandler;
    this.setupGlobalHandlers();
  }

  setupGlobalHandlers() {
    // Обработчик ошибок JavaScript
    window.addEventListener('error', (event) => {
      this.handleError(event.error || new Error(event.message), {
        type: 'javascript_error',
        source: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });

    // Обработчик необработанных промисов
    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(event.reason, {
        type: 'unhandled_promise_rejection'
      });
    });

    // Обработчик ошибок ресурсов
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.handleResourceError(event.target, event);
      }
    }, true);
  }

  async handleError(error, context = {}) {
    // Отправка в RUM трекер
    if (this.rumTracker) {
      await this.rumTracker.trackError(error, context);
    }

    // Обработка через центральный обработчик
    if (this.errorHandler) {
      await this.errorHandler.handle(error, {
        ...context,
        source: 'frontend'
      });
    }
  }

  handleResourceError(target, event) {
    const error = new Error(`Resource loading error: ${target.src || target.href}`);
    this.handleError(error, {
      type: 'resource_error',
      resource: target.src || target.href,
      tagName: target.tagName
    });
  }
}
```

## Error Handling в тестировании

### 1. Тестирование обработки ошибок

```javascript
// Утилиты для тестирования обработки ошибок
class ErrorTestingUtils {
  // Ожидание ошибки с определенным типом
  static async expectError(operation, expectedErrorType, expectedMessage = null) {
    let error = null;
    
    try {
      await operation();
    } catch (err) {
      error = err;
    }
    
    if (!error) {
      throw new Error('Expected error was not thrown');
    }
    
    if (!(error instanceof expectedErrorType)) {
      throw new Error(`Expected error of type ${expectedErrorType.name}, got ${error.constructor.name}`);
    }
    
    if (expectedMessage && !error.message.includes(expectedMessage)) {
      throw new Error(`Expected error message to include "${expectedMessage}", got "${error.message}"`);
    }
    
    return error;
  }

  // Создание мока для сервиса с ошибками
  static createErrorMock(errorType, errorMessage = 'Test error') {
    return {
      method: jest.fn().mockImplementation(() => {
        throw new errorType(errorMessage);
      })
    };
  }

  // Создание мока для асинхронного сервиса с ошибками
  static createAsyncErrorMock(errorType, errorMessage = 'Test error') {
    return {
      method: jest.fn().mockImplementation(() => {
        return Promise.reject(new errorType(errorMessage));
      })
    };
  }

  // Проверка, что обработчик ошибок вызывается
  static async expectErrorHandlerCalled(errorHandler, operation, expectedErrorType) {
    const handleSpy = jest.spyOn(errorHandler, 'handle');
    
    await operation().catch(() => {}); // Игнорируем ошибку
    
    expect(handleSpy).toHaveBeenCalledTimes(1);
    const [error] = handleSpy.mock.calls[0];
    expect(error).toBeInstanceOf(expectedErrorType);
    
    handleSpy.mockRestore();
  }
}

// Пример теста для обработки ошибок
describe('Error Handling', () => {
  let errorHandler;
  let mockService;

  beforeEach(() => {
    errorHandler = new ErrorHandler();
    mockService = {
      getData: jest.fn()
    };
  });

  test('should handle validation error correctly', async () => {
    const validationError = new ValidationError('Invalid email format', 'email', 'invalid-email');
    
    mockService.getData.mockRejectedValue(validationError);
    
    await expect(mockService.getData()).rejects.toThrow(ValidationError);
    
    // Проверяем, что ошибка была обработана
    await ErrorTestingUtils.expectErrorHandlerCalled(
      errorHandler,
      () => mockService.getData(),
      ValidationError
    );
  });

  test('should handle network error with retry', async () => {
    const networkError = new NetworkError('Connection timeout', '/api/data', 'GET');
    
    mockService.getData
      .mockRejectedValueOnce(networkError)
      .mockResolvedValueOnce({ data: 'success' });
    
    const result = await mockService.getData();
    
    expect(result).toEqual({ data: 'success' });
    expect(mockService.getData).toHaveBeenCalledTimes(2); // Один провальный, один успешный
  });
});
```

## Error Handling в CI/CD

### 1. Мониторинг ошибок в CI/CD

```javascript
// Мониторинг ошибок в CI/CD системах
class CICDErrorMonitor {
  constructor(options = {}) {
    this.metricsEndpoint = options.metricsEndpoint;
    this.alertingService = options.alertingService;
    this.logger = options.logger || console;
    this.errorThreshold = options.errorThreshold || 0.05; // 5% порог ошибок
    this.buildErrors = new Map(); // Ошибки по сборкам
    this.serviceErrors = new Map(); // Ошибки по сервисам
  }

  // Регистрация ошибки сборки
  async recordBuildError(buildId, error, service = 'unknown') {
    const errorData = {
      buildId,
      service,
      error: {
        name: error.constructor.name,
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      },
      recordedAt: new Date().toISOString()
    };

    // Сохранение ошибки
    if (!this.buildErrors.has(buildId)) {
      this.buildErrors.set(buildId, []);
    }
    this.buildErrors.get(buildId).push(errorData);

    // Отправка в метрики
    await this.sendToMetrics(errorData);

    // Проверка необходимости алертинга
    await this.checkAlerting(buildId, service);
  }

  // Отправка метрик
  async sendToMetrics(errorData) {
    if (this.metricsEndpoint) {
      try {
        await fetch(this.metricsEndpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: 'build_error',
            data: errorData
          })
        });
      } catch (error) {
        this.logger.error('Failed to send error metrics:', error);
      }
    }
  }

  // Проверка необходимости алертинга
  async checkAlerting(buildId, service) {
    // Подсчет ошибок для сервиса за последний период
    const recentErrors = this.getRecentErrors(service, 3600000); // Последний час
    
    if (recentErrors.length > 10) { // Если больше 10 ошибок в час
      if (this.alertingService) {
        await this.alertingService.sendAlert({
          type: 'HIGH_ERROR_RATE',
          message: `High error rate detected for service ${service}: ${recentErrors.length} errors in last hour`,
          service,
          errorCount: recentErrors.length
        });
      }
    }
  }

  // Получение недавних ошибок для сервиса
  getRecentErrors(service, timeWindowMs) {
    const now = Date.now();
    const errors = this.serviceErrors.get(service) || [];
    return errors.filter(error => now - new Date(error.recordedAt).getTime() <= timeWindowMs);
  }

  // Анализ ошибок сборки
  async analyzeBuildErrors(buildId) {
    const errors = this.buildErrors.get(buildId) || [];
    
    const analysis = {
      buildId,
      totalErrors: errors.length,
      errorTypes: {},
      errorServices: {},
      criticalErrors: [],
      recommendations: []
    };

    for (const error of errors) {
      // Подсчет типов ошибок
      const errorType = error.error.name;
      analysis.errorTypes[errorType] = (analysis.errorTypes[errorType] || 0) + 1;
      
      // Подсчет ошибок по сервисам
      analysis.errorServices[error.service] = (analysis.errorServices[error.service] || 0) + 1;
      
      // Определение критических ошибок
      if (this.isCriticalError(error.error.name)) {
        analysis.criticalErrors.push(error);
      }
    }

    // Генерация рекомендаций
    analysis.recommendations = this.generateRecommendations(analysis);

    return analysis;
  }

  isCriticalError(errorType) {
    return [
      'BuildError',
      'DeployError',
      'TestError',
      'IntegrationError',
      'ServiceError'
    ].includes(errorType);
  }

  generateRecommendations(analysis) {
    const recommendations = [];

    if (analysis.criticalErrors.length > 0) {
      recommendations.push('Immediate investigation required for critical errors');
    }

    if (analysis.totalErrors > 5) {
      recommendations.push('Review build configuration and dependencies');
    }

    if (analysis.errorServices['database'] > 0) {
      recommendations.push('Check database connectivity and configuration');
    }

    return recommendations;
  }
}
```

## Лучшие практики Error Handling

### 1. Структура логирования ошибок

```javascript
// Структурированное логирование ошибок
class StructuredErrorLogger {
  constructor(options = {}) {
    this.format = options.format || 'json'; // 'json' или 'text'
    this.includeStack = options.includeStack !== false;
    this.redactFields = options.redactFields || ['password', 'token', 'secret'];
    this.logger = options.logger || console;
  }

  log(error, context = {}) {
    const logEntry = {
      level: 'error',
      timestamp: new Date().toISOString(),
      error: {
        name: error.constructor.name,
        message: error.message,
        code: error.code,
        status: error.status,
        stack: this.includeStack ? error.stack : undefined
      },
      context: this.redactSensitiveData(context),
      correlationId: context.correlationId || this.generateCorrelationId()
    };

    if (this.format === 'json') {
      this.logger.error(JSON.stringify(logEntry));
    } else {
      this.logger.error(this.formatAsText(logEntry));
    }
  }

  redactSensitiveData(obj) {
    const redacted = { ...obj };
    
    for (const [key, value] of Object.entries(redacted)) {
      if (typeof value === 'object' && value !== null) {
        redacted[key] = this.redactSensitiveData(value);
      } else if (this.redactFields.some(field => 
        key.toLowerCase().includes(field)
      )) {
        redacted[key] = '[REDACTED]';
      }
    }
    
    return redacted;
  }

  formatAsText(logEntry) {
    return `[ERROR] ${logEntry.timestamp} - ${logEntry.error.name}: ${logEntry.error.message}
Context: ${JSON.stringify(logEntry.context, null, 2)}
Stack: ${logEntry.error.stack || 'N/A'}
Correlation ID: ${logEntry.correlationId}`;
  }

  generateCorrelationId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
}
```

### 2. Система оповещений об ошибках

```javascript
// Система оповещений об ошибках
class AlertingSystem {
  constructor(options = {}) {
    this.alertChannels = options.alertChannels || [];
    this.errorThresholds = options.errorThresholds || {
      'low': 5,    // 5 ошибок за 5 минут
      'medium': 10, // 10 ошибок за 5 минут
      'high': 20    // 20 ошибок за 5 минут
    };
    this.errorCounts = new Map();
    this.alertCooldowns = new Map(); // Время до следующего алерта
    this.cooldownPeriod = options.cooldownPeriod || 300000; // 5 минут
  }

  async sendAlert(alert) {
    const now = Date.now();
    const alertKey = `${alert.type}_${alert.service || 'global'}`;
    
    // Проверка кулдауна
    const lastAlertTime = this.alertCooldowns.get(alertKey);
    if (lastAlertTime && (now - lastAlertTime) < this.cooldownPeriod) {
      return; // Пропускаем алерт из-за кулдауна
    }

    // Отправка алерта во все каналы
    const promises = this.alertChannels.map(channel => 
      channel.send(alert).catch(err => {
        console.error(`Failed to send alert to ${channel.name}:`, err);
      })
    );

    await Promise.all(promises);
    
    // Установка времени последнего алерта
    this.alertCooldowns.set(alertKey, now);
  }

  // Проверка частоты ошибок
  async checkErrorRate(error, context) {
    const errorKey = `${error.constructor.name}_${context.service || 'unknown'}`;
    const now = Date.now();
    const window = 300000; // 5 минут
    
    if (!this.errorCounts.has(errorKey)) {
      this.errorCounts.set(errorKey, []);
    }

    const errors = this.errorCounts.get(errorKey);
    errors.push(now);
    
    // Удаление ошибок за пределами окна
    const recentErrors = errors.filter(time => now - time <= window);
    this.errorCounts.set(errorKey, recentErrors);

    // Определение уровня важности
    let severity = 'low';
    if (recentErrors.length >= this.errorThresholds.high) {
      severity = 'high';
    } else if (recentErrors.length >= this.errorThresholds.medium) {
      severity = 'medium';
    }

    if (severity !== 'low') {
      await this.sendAlert({
        type: 'ERROR_RATE_EXCEEDED',
        severity,
        message: `High error rate: ${recentErrors.length} ${error.constructor.name} errors in last 5 minutes`,
        error,
        context,
        count: recentErrors.length
      });
    }
  }
}
```

## Заключение

Архитектура обработки ошибок - критически важный компонент надежных и устойчивых систем. Эффективная архитектура обработки ошибок обеспечивает:

- Стабильность и надежность систем
- Улучшенный пользовательский опыт
- Быструю диагностику и устранение проблем
- Прозрачность для разработчиков и операционных команд

Ключевые принципы эффективной архитектуры обработки ошибок:
- Централизованная обработка ошибок
- Структурированное логирование
- Мониторинг и алертинг
- Автоматическое восстановление
- Изоляция сбоев
- Сохранение данных пользователей

[[API интеграция]] - архитектура интеграции с внешними API
[[Микросервисы]] - микросервисная архитектура
[[Событийный шин]] - шина событий
[[Event Sourcing]] - событийное хранение
[[CQRS]] - разделение команд и запросов
[[Publish Subscribe Pattern]] - паттерн паблишер-сабскрайбер
[[WebSocket]] - вебсокеты для событийного взаимодействия
[[Frontend Architecture]] - общая архитектура фронтенда
[[Component Architecture]] - компонентная архитектура
[[State Management]] - управление состоянием
[[API Gateway]] - шлюзы API
[[Message Queue]] - очереди сообщений
[[Kafka]] - Apache Kafka
[[RabbitMQ]] - RabbitMQ
[[Asynchronous Processing]] - асинхронная обработка
[[Event Handling]] - обработка событий
[[Event Monitoring]] - мониторинг событий
[[Pub/Sub Systems]] - системы публикации/подписки
[[Reactive Programming]] - реактивное программирование
[[Event Architecture Patterns]] - архитектурные паттерны событий
[[Event Scalability]] - масштабируемость событий
[[Event Security]] - безопасность событий
[[Real-time Communication]] - коммуникация в реальном времени
[[Architecture Decision Records]] - архитектурные решения
[[EventBridge]] - AWS EventBridge
[[Event Consistency]] - согласованность событий
[[Event Patterns]] - паттерны событий
[[Event Performance]] - производительность событий
[[Event Ordering]] - порядок событий
[[Clean Architecture]] - чистая архитектура
[[Microservices Architecture]] - архитектура микросервисов
[[Service Mesh Architecture]] - архитектура сервис-меша
[[Cloud Native Architecture]] - облачная нативная архитектура
[[Vue Architecture]] - архитектура Vue
[[Security Architecture]] - архитектура безопасности
[[Testing Architecture]] - архитектура тестирования
[[Message Queues]] - очереди сообщений
[[Event Sourcing]] - событийное хранение
[[CQRS]] - разделение команд и запросов
[[Reactive Programming]] - реактивное программирование
[[Microservices]] - микросервисы
[[API Gateway]] - API шлюз
[[Service Mesh]] - сервис-меш
[[Data Streaming]] - потоковая передача данных
[[Performance Architecture]] - архитектура производительности
[[Feature Flags]] - фича-флаги
[[Real User Monitoring]] - мониторинг реальных пользователей
[[API Testing]] - тестирование API
[[Performance Testing]] - тестирование производительности
[[Monitoring]] - мониторинг
[[Observability]] - наблюдаемость
[[Error Tracking]] - отслеживание ошибок
[[User Experience]] - пользовательский опыт
[[Frontend Monitoring]] - мониторинг фронтенда
[[Application Performance Monitoring]] - мониторинг производительности приложений
[[Session Replay]] - воспроизведение сессий
[[User Behavior Analytics]] - аналитика поведения пользователей
[[Conversion Optimization]] - оптимизация конверсии
[[A/B Testing]] - A/B тестирование
[[Data Privacy]] - защита данных
[[GDPR Compliance]] - соответствие GDPR
[[Analytics Platforms]] - аналитические платформы
[[API Documentation]] - документация API
[[OpenAPI]] - спецификации OpenAPI
[[GraphQL]] - архитектура GraphQL
[[REST API]] - архитектура REST API
[[WebSocket]] - веб-сокеты
[[CORS]] - политики CORS
[[HTTP-протокол]] - протокол HTTP
[[Тестирование производительности]] - производительность и тестирование
[[Тестирование безопасности]] - безопасность и тестирование
[[Тестирование ошибок]] - обработка ошибок и тестирование
[[Кеширование данных]] - кэширование и тестирование
[[Тестирование аутентификации]] - аутентификация и тестирование
[[Тестирование авторизации]] - авторизация и тестирование
[[Оптимистичные обновления]] - оптимистичные обновления и тестирование
[[Повторные попытки запросов]] - retry-логика и тестирование
[[Обработка таймаутов]] - таймауты и тестирование
[[Тестирование API Gateway]] - шлюзы API и тестирование
[[Service Workers]] - сервис-воркеры и тестирование
[[Offline-режим]] - автономный режим и тестирование
[[Синхронизация данных]] - синхронизация данных и тестирование
[[Тестирование в разных сетях]] - сетевые условия и тестирование
[[Тестирование разных браузеров]] - кроссбраузерность и тестирование
[[Тестирование мобильных устройств]] - мобильные устройства и тестирование
[[Тестирование пользовательского опыта]] - UX и тестирование
[[Тестирование приватности]] - приватность и тестирование
[[Тестирование соответствия]] - compliance и тестирование
[[Тестирование архитектурных паттернов]] - паттерны и тестирование
[[Тестирование архитектурных ограничений]] - ограничения и тестирование