---
aliases: [Architecture Patterns, Design Patterns, Frontend Architecture Patterns, Unified Architecture Patterns, Architectural Patterns]
tags: [architecture, patterns, design-patterns, frontend, components, state-management, microservices, event-driven, api-integration, performance, security]
---

# Единая архитектура паттернов проектирования

## Обзор

Unified Architecture Patterns - это комплексный подход к использованию архитектурных паттернов в контексте фронтенд-разработки. Включает в себя паттерны для компонентной архитектуры, управления состоянием, API-интеграций, безопасности, производительности и других аспектов разработки. Архитектурные паттерны обеспечивают согласованность, поддерживаемость и масштабируемость приложений.

## Категории паттернов

### 1. Порождающие (Creational) паттерны

Относятся к процессу создания объектов и обеспечивают гибкость в определении того, какие объекты создаются, как и когда.

#### Фабричный метод (Factory Method)

Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта.

```javascript
// Пример фабричного метода для компонентов
class ComponentFactory {
  static createComponent(type, props) {
    switch (type) {
      case 'button':
        return new ButtonComponent(props);
      case 'input':
        return new InputComponent(props);
      case 'card':
        return new CardComponent(props);
      default:
        throw new Error(`Unknown component type: ${type}`);
    }
  }
}

class ButtonComponent {
  constructor(props) {
    this.text = props.text || '';
    this.variant = props.variant || 'primary';
    this.onClick = props.onClick || (() => {});
  }
  
  render() {
    return `<button class="btn btn-${this.variant}" onclick="${this.onClick}">${this.text}</button>`;
  }
}

class InputComponent {
  constructor(props) {
    this.label = props.label || '';
    this.placeholder = props.placeholder || '';
    this.type = props.type || 'text';
  }
  
  render() {
    return `
      <div class="input-group">
        <label>${this.label}</label>
        <input type="${this.type}" placeholder="${this.placeholder}">
      </div>
    `;
  }
}
```

#### Абстрактная фабрика (Abstract Factory)

Предоставляет интерфейс для создания семейств связанных или взаимосвязанных объектов без указания их конкретных типов.

```javascript
// Пример абстрактной фабрики для UI компонентов
class UIFactory {
  static getFactory(theme) {
    switch (theme) {
      case 'material':
        return new MaterialUIFactory();
      case 'bootstrap':
        return new BootstrapUIFactory();
      case 'tailwind':
        return new TailwindUIFactory();
      default:
        throw new Error(`Unknown theme: ${theme}`);
    }
  }
}

class MaterialUIFactory {
  createButton(props) {
    return new MaterialButton(props);
  }
  
  createInput(props) {
    return new MaterialInput(props);
  }
}

class BootstrapUIFactory {
  createButton(props) {
    return new BootstrapButton(props);
  }
  
  createInput(props) {
    return new BootstrapInput(props);
  }
}

class MaterialButton {
  constructor(props) {
    this.text = props.text;
  }
  
  render() {
    return `<button class="mat-button">${this.text}</button>`;
  }
}

class BootstrapButton {
  constructor(props) {
    this.text = props.text;
  }
  
  render() {
    return `<button class="btn btn-primary">${this.text}</button>`;
  }
}
```

#### Строитель (Builder)

Разделяет создание сложного объекта от его представления, так что в результате одного и того же процесса могут быть получены различные представления.

```javascript
// Пример паттерна Строитель для API клиента
class APIClientBuilder {
  constructor() {
    this.config = {
      baseURL: '',
      timeout: 5000,
      headers: {},
      interceptors: {
        request: [],
        response: []
      }
    };
  }
  
  setBaseURL(baseURL) {
    this.config.baseURL = baseURL;
    return this;
  }
  
  setTimeout(timeout) {
    this.config.timeout = timeout;
    return this;
  }
  
  addHeader(key, value) {
    this.config.headers[key] = value;
    return this;
  }
  
  addRequestInterceptor(interceptor) {
    this.config.interceptors.request.push(interceptor);
    return this;
  }
  
  addResponseInterceptor(interceptor) {
    this.config.interceptors.response.push(interceptor);
    return this;
  }
  
  build() {
    return new APIClient(this.config);
  }
}

class APIClient {
  constructor(config) {
    this.config = config;
  }
  
  async request(options) {
    // Применение перехватчиков запросов
    let processedOptions = { ...options };
    for (const interceptor of this.config.interceptors.request) {
      processedOptions = await interceptor(processedOptions);
    }
    
    // Выполнение запроса
    const response = await fetch(`${this.config.baseURL}${options.url}`, {
      ...processedOptions,
      headers: { ...this.config.headers, ...options.headers },
      timeout: this.config.timeout
    });
    
    // Применение перехватчиков ответов
    let processedResponse = response;
    for (const interceptor of this.config.interceptors.response) {
      processedResponse = await interceptor(processedResponse);
    }
    
    return processedResponse;
  }
}

// Использование
const apiClient = new APIClientBuilder()
  .setBaseURL('https://api.example.com')
  .setTimeout(10000)
  .addHeader('Content-Type', 'application/json')
  .addHeader('Authorization', `Bearer ${token}`)
  .addRequestInterceptor(authInterceptor)
  .addResponseInterceptor(errorHandler)
  .build();
```

#### Прототип (Prototype)

Определяет интерфейс для клонирования существующих объектов, а не создания новых экземпляров.

```javascript
// Пример паттерна Прототип для конфигурации
class Configuration {
  constructor(settings) {
    this.settings = settings || {};
  }
  
  clone() {
    return new Configuration({ ...this.settings });
  }
  
  set(key, value) {
    this.settings[key] = value;
    return this;
  }
  
  get(key) {
    return this.settings[key];
  }
}

// Создание конфигурации для разных окружений
const baseConfig = new Configuration({
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retryCount: 3
});

const devConfig = baseConfig.clone()
  .set('apiUrl', 'https://dev-api.example.com')
  .set('timeout', 10000);

const prodConfig = baseConfig.clone()
  .set('retryCount', 5);
```

#### Одиночка (Singleton)

Гарантирует, что у класса есть только один экземпляр, и обеспечивает к нему глобальную точку доступа.

```javascript
// Пример паттерна Одиночка для управления состоянием
class StateManager {
  constructor() {
    if (StateManager.instance) {
      return StateManager.instance;
    }
    
    this.state = {};
    this.listeners = [];
    
    StateManager.instance = this;
    return this;
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach(listener => listener(this.state));
  }
  
  getState() {
    return this.state;
  }
  
  reset() {
    this.state = {};
    this.listeners.forEach(listener => listener(this.state));
  }
}

// Использование
const stateManager = new StateManager();
const anotherStateManager = new StateManager(); // То же самое
console.log(stateManager === anotherStateManager); // true
```

### 2. Структурные (Structural) паттерны

Решают проблемы объединения объектов и классов в более крупные структуры.

#### Адаптер (Adapter)

Преобразует интерфейс одного класса в другой интерфейс, который ожидают клиенты.

```javascript
// Пример паттерна Адаптер для API
class OldAPI {
  getData() {
    return { oldData: 'some data' };
  }
}

class NewAPI {
  fetchData() {
    return [{ newData: 'some data' }];
  }
}

class APIAdapter {
  constructor(oldAPI) {
    this.oldAPI = oldAPI;
  }
  
  fetchData() {
    const oldData = this.oldAPI.getData();
    // Адаптируем старый формат к новому
    return [oldData];
  }
}

// Использование
const oldAPI = new OldAPI();
const adapter = new APIAdapter(oldAPI);
const newData = adapter.fetchData(); // [{ oldData: 'some data' }]
```

#### Мост (Bridge)

Разделяет абстракцию и реализацию, позволяя изменять их независимо друг от друга.

```javascript
// Пример паттерна Мост для рендеринга компонентов
class Renderer {
  render(element) {
    throw new Error('Must implement render method');
  }
}

class HTMLRenderer extends Renderer {
  render(element) {
    return `<div>${element.content}</div>`;
  }
}

class CanvasRenderer extends Renderer {
  render(element) {
    // Рендеринг на canvas
    return `Canvas rendering: ${element.content}`;
  }
}

class UIElement {
  constructor(renderer) {
    this.renderer = renderer;
  }
  
  draw() {
    return this.renderer.render(this);
  }
}

class Button extends UIElement {
  constructor(renderer, text) {
    super(renderer);
    this.content = text;
  }
}

// Использование
const htmlButton = new Button(new HTMLRenderer(), 'Click me');
const canvasButton = new Button(new CanvasRenderer(), 'Click me');
```

#### Компоновщик (Composite)

Композирует объекты в древовидные структуры для представления иерархий "часть-целое".

```javascript
// Пример паттерна Компоновщик для UI компонентов
class UIComponent {
  constructor(name) {
    this.name = name;
    this.children = [];
  }
  
  add(child) {
    this.children.push(child);
  }
  
  remove(child) {
    this.children = this.children.filter(c => c !== child);
  }
  
  render() {
    let result = `<div class="component" data-name="${this.name}">`;
    
    for (const child of this.children) {
      result += child.render();
    }
    
    result += '</div>';
    return result;
  }
}

class TextComponent extends UIComponent {
  constructor(name, text) {
    super(name);
    this.text = text;
  }
  
  render() {
    return `<span class="text">${this.text}</span>`;
  }
}

class ButtonComponent extends UIComponent {
  constructor(name, text) {
    super(name);
    this.text = text;
  }
  
  render() {
    return `<button class="button">${this.text}</button>`;
  }
}

// Использование
const layout = new UIComponent('layout');
const header = new UIComponent('header');
const title = new TextComponent('title', 'My App');
const button = new ButtonComponent('button', 'Click Me');

header.add(title);
layout.add(header);
layout.add(button);

console.log(layout.render());
```

#### Декоратор (Decorator)

Динамически добавляет новую функциональность объекту, не влияя на другие объекты того же класса.

```javascript
// Пример паттерна Декоратор для компонентов
class Component {
  render() {
    return '<div>Base component</div>';
  }
}

class Decorator {
  constructor(component) {
    this.component = component;
  }
  
  render() {
    return this.component.render();
  }
}

class BorderDecorator extends Decorator {
  render() {
    return `<div style="border: 1px solid black;">${super.render()}</div>`;
  }
}

class PaddingDecorator extends Decorator {
  render() {
    return `<div style="padding: 10px;">${super.render()}</div>`;
  }
}

class ColorDecorator extends Decorator {
  constructor(component, color) {
    super(component);
    this.color = color;
  }
  
  render() {
    return `<div style="color: ${this.color};">${super.render()}</div>`;
  }
}

// Использование
const component = new Component();
const bordered = new BorderDecorator(component);
const padded = new PaddingDecorator(bordered);
const colored = new ColorDecorator(padded, 'red');

console.log(colored.render());
```

#### Фасад (Facade)

Предоставляет унифицированный интерфейс к группе интерфейсов в подсистеме.

```javascript
// Пример паттерна Фасад для API сервиса
class UserService {
  getUser(id) {
    return fetch(`/api/users/${id}`).then(r => r.json());
  }
  
  updateUser(id, data) {
    return fetch(`/api/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data)
    }).then(r => r.json());
  }
}

class NotificationService {
  sendNotification(userId, message) {
    return fetch('/api/notifications', {
      method: 'POST',
      body: JSON.stringify({ userId, message })
    });
  }
}

class LoggingService {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class UserFacade {
  constructor() {
    this.userService = new UserService();
    this.notificationService = new NotificationService();
    this.loggingService = new LoggingService();
  }
  
  async updateUserProfile(userId, profileData) {
    try {
      this.loggingService.log(`Updating profile for user ${userId}`);
      
      const updatedUser = await this.userService.updateUser(userId, profileData);
      
      await this.notificationService.sendNotification(
        userId, 
        'Your profile has been updated successfully'
      );
      
      this.loggingService.log(`Profile updated for user ${userId}`);
      
      return updatedUser;
    } catch (error) {
      this.loggingService.log(`Error updating profile for user ${userId}: ${error.message}`);
      throw error;
    }
  }
}

// Использование
const userFacade = new UserFacade();
userFacade.updateUserProfile(1, { name: 'John Doe', email: 'john@example.com' });
```

#### Легковес (Flyweight)

Использует разделяемые объекты для эффективной поддержки большого количества мелких объектов.

```javascript
// Пример паттерна Легковес для компонентов
class ComponentFlyweight {
  constructor(sharedState) {
    this.sharedState = sharedState;
  }
  
  render(uniqueState) {
    return `
      <div class="${this.sharedState.className}" 
           style="${this.sharedState.styles}">
        ${uniqueState.content}
      </div>
    `;
  }
}

class ComponentFlyweightFactory {
  constructor() {
    this.flyweights = {};
  }
  
  getFlyweight(sharedState) {
    const key = this.getKey(sharedState);
    
    if (!this.flyweights[key]) {
      this.flyweights[key] = new ComponentFlyweight(sharedState);
    }
    
    return this.flyweights[key];
  }
  
  getKey(state) {
    return Object.values(state).join('_');
  }
}

// Использование
const factory = new ComponentFlyweightFactory();

const buttonFlyweight = factory.getFlyweight({
  className: 'btn btn-primary',
  styles: 'padding: 10px; margin: 5px;'
});

const cardFlyweight = factory.getFlyweight({
  className: 'card',
  styles: 'width: 300px; padding: 15px;'
});

// Один и тот же flyweight может использоваться для разных уникальных состояний
console.log(buttonFlyweight.render({ content: 'Save' }));
console.log(buttonFlyweight.render({ content: 'Cancel' }));
```

#### Заместитель (Proxy)

Предоставляет заместителя или заполнитель другого объекта для контроля доступа к нему.

```javascript
// Пример паттерна Заместитель для API клиента
class RealAPIClient {
  async getData(url) {
    const response = await fetch(url);
    return response.json();
  }
}

class APIClientProxy {
  constructor(realClient) {
    this.realClient = realClient;
    this.cache = new Map();
    this.rateLimit = new RateLimiter(10, 60000); // 10 запросов в минуту
  }
  
  async getData(url) {
    // Проверка кэша
    if (this.cache.has(url)) {
      const cached = this.cache.get(url);
      if (Date.now() - cached.timestamp < 300000) { // 5 минут
        return cached.data;
      }
    }
    
    // Проверка ограничения частоты
    if (!this.rateLimit.allow()) {
      throw new Error('Rate limit exceeded');
    }
    
    // Выполнение запроса
    const data = await this.realClient.getData(url);
    
    // Кэширование результата
    this.cache.set(url, {
      data,
      timestamp: Date.now()
    });
    
    return data;
  }
}

class RateLimiter {
  constructor(maxRequests, windowMs) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
    this.requests = [];
  }
  
  allow() {
    const now = Date.now();
    // Удаление старых запросов
    this.requests = this.requests.filter(timestamp => now - timestamp < this.windowMs);
    
    if (this.requests.length >= this.maxRequests) {
      return false;
    }
    
    this.requests.push(now);
    return true;
  }
}

// Использование
const realClient = new RealAPIClient();
const proxyClient = new APIClientProxy(realClient);
```

### 3. Поведенческие (Behavioral) паттерны

Относятся к взаимодействию между объектами и распределению ответственности.

#### Цепочка обязанностей (Chain of Responsibility)

Передает запрос по цепочке обработчиков. При получении запроса каждый обработчик решает, будет ли он его обрабатывать или передавать следующему обработчику в цепочке.

```javascript
// Пример паттерна Цепочка обязанностей для middleware
class MiddlewareHandler {
  constructor() {
    this.nextHandler = null;
  }
  
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  
  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return request;
  }
}

class AuthMiddleware extends MiddlewareHandler {
  handle(request) {
    if (!request.headers.authorization) {
      throw new Error('Unauthorized');
    }
    console.log('Authentication passed');
    return super.handle(request);
  }
}

class ValidationMiddleware extends MiddlewareHandler {
  handle(request) {
    if (!request.body || !request.body.email) {
      throw new Error('Email is required');
    }
    console.log('Validation passed');
    return super.handle(request);
  }
}

class LoggingMiddleware extends MiddlewareHandler {
  handle(request) {
    console.log('Request logged');
    return super.handle(request);
  }
}

// Использование
const auth = new AuthMiddleware();
const validation = new ValidationMiddleware();
const logging = new LoggingMiddleware();

auth.setNext(validation).setNext(logging);

const request = {
  headers: { authorization: 'Bearer token' },
  body: { email: 'user@example.com' }
};

try {
  auth.handle(request);
  console.log('Request processed successfully');
} catch (error) {
  console.error('Request failed:', error.message);
}
```

#### Команда (Command)

Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь или протоколировать их.

```javascript
// Пример паттерна Команда для UI действий
class Command {
  execute() {
    throw new Error('Must implement execute method');
  }
  
  undo() {
    throw new Error('Must implement undo method');
  }
}

class AddItemCommand extends Command {
  constructor(itemList, item) {
    super();
    this.itemList = itemList;
    this.item = item;
  }
  
  execute() {
    this.itemList.addItem(this.item);
  }
  
  undo() {
    this.itemList.removeItem(this.item);
  }
}

class RemoveItemCommand extends Command {
  constructor(itemList, item) {
    super();
    this.itemList = itemList;
    this.item = item;
    this.previousState = [...itemList.items]; // Сохраняем состояние для отката
  }
  
  execute() {
    this.itemList.removeItem(this.item);
  }
  
  undo() {
    this.itemList.setItems(this.previousState);
  }
}

class ItemList {
  constructor() {
    this.items = [];
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  removeItem(item) {
    this.items = this.items.filter(i => i !== item);
  }
  
  setItems(items) {
    this.items = [...items];
  }
}

class CommandInvoker {
  constructor() {
    this.history = [];
  }
  
  executeCommand(command) {
    command.execute();
    this.history.push(command);
  }
  
  undoLastCommand() {
    if (this.history.length > 0) {
      const command = this.history.pop();
      command.undo();
    }
  }
}

// Использование
const itemList = new ItemList();
const invoker = new CommandInvoker();

const addItemCommand = new AddItemCommand(itemList, 'Apple');
invoker.executeCommand(addItemCommand);

const removeItemCommand = new RemoveItemCommand(itemList, 'Apple');
invoker.executeCommand(removeItemCommand);

invoker.undoLastCommand(); // Откатываем удаление
```

#### Итератор (Iterator)

Предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления.

```javascript
// Пример паттерна Итератор
class ListIterator {
  constructor(items) {
    this.items = items;
    this.index = 0;
  }
  
  hasNext() {
    return this.index < this.items.length;
  }
  
  next() {
    if (this.hasNext()) {
      return this.items[this.index++];
    }
    throw new Error('No more items');
  }
  
  reset() {
    this.index = 0;
  }
}

class DataCollection {
  constructor(items = []) {
    this.items = items;
  }
  
  createIterator() {
    return new ListIterator(this.items);
  }
  
  addItem(item) {
    this.items.push(item);
  }
}

// Использование
const collection = new DataCollection(['A', 'B', 'C']);
const iterator = collection.createIterator();

while (iterator.hasNext()) {
  console.log(iterator.next()); // A, B, C
}
```

#### Посредник (Mediator)

Определяет объект, который инкапсулирует способ взаимодействия множества объектов.

```javascript
// Пример паттерна Посредник для компонентов
class Mediator {
  constructor() {
    this.components = {};
  }
  
  register(name, component) {
    this.components[name] = component;
    component.setMediator(this);
  }
  
  notify(sender, event, data) {
    for (const [name, component] of Object.entries(this.components)) {
      if (component !== sender) {
        component.handleEvent(event, data);
      }
    }
  }
}

class Component {
  setMediator(mediator) {
    this.mediator = mediator;
  }
  
  handleEvent(event, data) {
    // Может быть переопределен в подклассах
  }
}

class Button extends Component {
  constructor(name) {
    super();
    this.name = name;
  }
  
  click() {
    this.mediator.notify(this, 'button-clicked', { button: this.name });
  }
}

class TextField extends Component {
  constructor(name) {
    super();
    this.name = name;
    this.value = '';
  }
  
  handleEvent(event, data) {
    if (event === 'button-clicked') {
      this.value = `Button ${data.button} was clicked`;
      console.log(`TextField ${this.name} updated: ${this.value}`);
    }
  }
}

class Label extends Component {
  constructor(name) {
    super();
    this.name = name;
    this.text = '';
  }
  
  handleEvent(event, data) {
    if (event === 'button-clicked') {
      this.text = `Action performed by ${data.button}`;
      console.log(`Label ${this.name} updated: ${this.text}`);
    }
  }
}

// Использование
const mediator = new Mediator();
const button = new Button('submit');
const textField = new TextField('input');
const label = new Label('status');

mediator.register('button', button);
mediator.register('textField', textField);
mediator.register('label', label);

button.click(); // Уведомляет другие компоненты
```

#### Хранитель (Memento)

Позволяет зафиксировать и восстановить внутреннее состояние объекта без нарушения инкапсуляции.

```javascript
// Пример паттерна Хранитель для редактора
class EditorState {
  constructor(content) {
    this.content = content;
    this.createdAt = new Date();
  }
  
  getContent() {
    return this.content;
  }
  
  getCreatedAt() {
    return this.createdAt;
  }
}

class Editor {
  constructor() {
    this.content = '';
    this.history = [];
  }
  
  write(text) {
    this.content += text;
  }
  
  save() {
    return new EditorState(this.content);
  }
  
  restore(memento) {
    this.content = memento.getContent();
  }
  
  getContent() {
    return this.content;
  }
  
  addStateToHistory() {
    this.history.push(this.save());
  }
  
  undo() {
    if (this.history.length > 0) {
      const previousState = this.history.pop();
      this.restore(previousState);
    }
  }
}

// Использование
const editor = new Editor();
editor.write('Hello ');
editor.addStateToHistory();

editor.write('World!');
console.log(editor.getContent()); // "Hello World!"

editor.undo();
console.log(editor.getContent()); // "Hello "
```

#### Наблюдатель (Observer)

Определяет зависимость "один ко многим" между объектами, чтобы при изменении состояния одного объекта все зависящие от него объекты автоматически обновлялись.

```javascript
// Пример паттерна Наблюдатель для управления состоянием
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class StateManager extends Subject {
  constructor() {
    super();
    this.state = {};
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify(this.state);
  }
  
  getState() {
    return this.state;
  }
}

class Observer {
  update(data) {
    throw new Error('Must implement update method');
  }
}

class UserView extends Observer {
  constructor(stateManager) {
    super();
    this.stateManager = stateManager;
    this.unsubscribe = this.stateManager.subscribe(this);
  }
  
  update(state) {
    console.log('User view updated:', state.user);
  }
  
  destroy() {
    this.unsubscribe();
  }
}

// Использование
const stateManager = new StateManager();
const userView = new UserView(stateManager);

stateManager.setState({ user: { name: 'John', email: 'john@example.com' } });
// Вывод: "User view updated: { name: 'John', email: 'john@example.com' }"
```

#### Состояние (State)

Позволяет объекту изменять свое поведение при изменении внутреннего состояния.

```javascript
// Пример паттерна Состояние для компонента кнопки
class ButtonState {
  click() {
    throw new Error('Must implement click method');
  }
  
  render() {
    throw new Error('Must implement render method');
  }
}

class EnabledState extends ButtonState {
  click() {
    console.log('Button clicked!');
    return new DisabledState();
  }
  
  render() {
    return '<button class="enabled">Click me</button>';
  }
}

class DisabledState extends ButtonState {
  click() {
    console.log('Button is disabled');
    return this;
  }
  
  render() {
    return '<button class="disabled" disabled>Disabled</button>';
  }
}

class LoadingState extends ButtonState {
  click() {
    console.log('Button is loading');
    return this;
  }
  
  render() {
    return '<button class="loading">Loading...</button>';
  }
}

class Button {
  constructor() {
    this.state = new EnabledState();
  }
  
  click() {
    this.state = this.state.click();
  }
  
  render() {
    return this.state.render();
  }
  
  setState(state) {
    this.state = state;
  }
}

// Использование
const button = new Button();
console.log(button.render()); // Enabled button
button.click(); // State changes to disabled
console.log(button.render()); // Disabled button
```

#### Стратегия (Strategy)

Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

```javascript
// Пример паттерна Стратегия для сортировки данных
class SortStrategy {
  sort(data) {
    throw new Error('Must implement sort method');
  }
}

class BubbleSortStrategy extends SortStrategy {
  sort(data) {
    console.log('Sorting using bubble sort');
    // Реализация пузырьковой сортировки
    const arr = [...data];
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
    }
    return arr;
  }
}

class QuickSortStrategy extends SortStrategy {
  sort(data) {
    console.log('Sorting using quick sort');
    // Реализация быстрой сортировки
    if (data.length <= 1) return data;
    
    const pivot = data[Math.floor(data.length / 2)];
    const left = data.filter(x => x < pivot);
    const right = data.filter(x => x > pivot);
    const middle = data.filter(x => x === pivot);
    
    return [
      ...this.sort(left),
      ...middle,
      ...this.sort(right)
    ];
  }
}

class MergeSortStrategy extends SortStrategy {
  sort(data) {
    console.log('Sorting using merge sort');
    // Реализация сортировки слиянием
    if (data.length <= 1) return data;
    
    const mid = Math.floor(data.length / 2);
    const left = data.slice(0, mid);
    const right = data.slice(mid);
    
    return this.merge(
      this.sort(left),
      this.sort(right)
    );
  }
  
  merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    while (leftIndex < left.length && rightIndex < right.length) {
      if (left[leftIndex] < right[rightIndex]) {
        result.push(left[leftIndex]);
        leftIndex++;
      } else {
        result.push(right[rightIndex]);
        rightIndex++;
      }
    }
    
    return result
      .concat(left.slice(leftIndex))
      .concat(right.slice(rightIndex));
  }
}

class DataProcessor {
  constructor(sortStrategy) {
    this.sortStrategy = sortStrategy;
  }
  
  setSortStrategy(strategy) {
    this.sortStrategy = strategy;
  }
  
  processData(data) {
    return this.sortStrategy.sort(data);
  }
}

// Использование
const processor = new DataProcessor(new BubbleSortStrategy());
let sortedData = processor.processData([64, 34, 25, 12, 22, 11, 90]);
console.log(sortedData);

processor.setSortStrategy(new QuickSortStrategy());
sortedData = processor.processData([64, 34, 25, 12, 22, 11, 90]);
console.log(sortedData);
```

#### Шаблонный метод (Template Method)

Определяет skeleton алгоритма в операции, откладывая некоторые шаги на подклассы.

```javascript
// Пример паттерна Шаблонный метод для API сервисов
class APIService {
  async executeRequest(url, options = {}) {
    // Шаг 1: Валидация параметров
    this.validateParams(url, options);
    
    // Шаг 2: Подготовка запроса
    const preparedOptions = await this.prepareRequest(url, options);
    
    // Шаг 3: Выполнение запроса
    const response = await this.makeRequest(preparedOptions);
    
    // Шаг 4: Обработка ответа
    const processedResponse = await this.processResponse(response);
    
    // Шаблонный метод может содержать hook методы
    await this.onComplete(processedResponse);
    
    return processedResponse;
  }
  
  validateParams(url, options) {
    if (!url) {
      throw new Error('URL is required');
    }
  }
  
  async prepareRequest(url, options) {
    // Общая логика подготовки запроса
    return {
      url,
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    };
  }
  
  async makeRequest(options) {
    const response = await fetch(options.url, options);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response;
  }
  
  async processResponse(response) {
    return await response.json();
  }
  
  async onComplete(result) {
    // Hook метод для переопределения в подклассах
  }
}

class UserService extends APIService {
  async prepareRequest(url, options) {
    const baseOptions = await super.prepareRequest(url, options);
    // Добавляем специфичные для сервиса заголовки
    return {
      ...baseOptions,
      headers: {
        ...baseOptions.headers,
        'X-User-Token': this.getUserToken()
      }
    };
  }
  
  async processResponse(response) {
    const data = await super.processResponse(response);
    // Дополнительная обработка специфичных данных
    return {
      ...data,
      processedAt: new Date().toISOString()
    };
  }
  
  getUserToken() {
    return localStorage.getItem('userToken');
  }
  
  async onComplete(result) {
    // Логика, специфичная для UserService
    console.log('User data fetched:', result);
  }
}

// Использование
const userService = new UserService();
// userService.executeRequest('/api/users/123');
```

#### Посетитель (Visitor)

Позволяет добавить новую операцию в существующую иерархию классов без изменения самих классов.

```javascript
// Пример паттерна Посетитель для анализа компонентов
class Component {
  accept(visitor) {
    visitor.visit(this);
  }
}

class ButtonComponent extends Component {
  constructor(text) {
    super();
    this.text = text;
  }
}

class InputComponent extends Component {
  constructor(placeholder) {
    super();
    this.placeholder = placeholder;
  }
}

class CardComponent extends Component {
  constructor(title, content) {
    super();
    this.title = title;
    this.content = content;
  }
}

class ComponentVisitor {
  visit(component) {
    const methodName = `visit${component.constructor.name}`;
    if (typeof this[methodName] === 'function') {
      this[methodName](component);
    } else {
      this.visitDefault(component);
    }
  }
  
  visitDefault(component) {
    console.log(`Visiting default component: ${component.constructor.name}`);
  }
}

class ComponentAnalyzer extends ComponentVisitor {
  constructor() {
    super();
    this.stats = {
      totalComponents: 0,
      buttons: 0,
      inputs: 0,
      cards: 0
    };
  }
  
  visitButtonComponent(button) {
    this.stats.totalComponents++;
    this.stats.buttons++;
    console.log(`Analyzing button: ${button.text}`);
  }
  
  visitInputComponent(input) {
    this.stats.totalComponents++;
    this.stats.inputs++;
    console.log(`Analyzing input: ${input.placeholder}`);
  }
  
  visitCardComponent(card) {
    this.stats.totalComponents++;
    this.stats.cards++;
    console.log(`Analyzing card: ${card.title}`);
  }
  
  getStats() {
    return this.stats;
  }
}

class ComponentRenderer extends ComponentVisitor {
  constructor() {
    super();
    this.html = '';
  }
  
  visitButtonComponent(button) {
    this.html += `<button>${button.text}</button>`;
  }
  
  visitInputComponent(input) {
    this.html += `<input placeholder="${input.placeholder}">`;
  }
  
  visitCardComponent(card) {
    this.html += `<div class="card"><h3>${card.title}</h3><p>${card.content}</p></div>`;
  }
  
  getHTML() {
    return this.html;
  }
}

// Использование
const components = [
  new ButtonComponent('Submit'),
  new InputComponent('Enter text'),
  new CardComponent('Title', 'Content'),
  new ButtonComponent('Cancel')
];

const analyzer = new ComponentAnalyzer();
const renderer = new ComponentRenderer();

for (const component of components) {
  component.accept(analyzer);
  component.accept(renderer);
}

console.log('Analysis stats:', analyzer.getStats());
console.log('Rendered HTML:', renderer.getHTML());
```

## Фронтенд-специфичные паттерны

### Паттерны управления компонентами

#### Container/Presentational (Умные/Глупые компоненты)

Разделяет компоненты, отвечающие за логику (контейнеры), и компоненты, отвечающие за отображение (презентационные).

```javascript
// Пример Container/Presentational паттерна
// Presentational компонент (глупый)
const UserProfileView = ({ user, isLoading, error }) => {
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <div className="user-profile">
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      <p>Role: {user.role}</p>
    </div>
  );
};

// Container компонент (умный)
class UserProfileContainer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      isLoading: true,
      error: null
    };
  }
  
  async componentDidMount() {
    try {
      const user = await this.fetchUser(this.props.userId);
      this.setState({ user, isLoading: false });
    } catch (error) {
      this.setState({ error, isLoading: false });
    }
  }
  
  fetchUser = async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch user');
    }
    return await response.json();
  };
  
  render() {
    return (
      <UserProfileView 
        {...this.state}
      />
    );
  }
}
```

#### Higher-Order Components (HOC)

Функции, которые принимают компонент и возвращают новый компонент с дополнительной функциональностью.

```javascript
// Пример HOC для аутентификации
const withAuth = (WrappedComponent) => {
  return class extends React.Component {
    state = {
      isAuthenticated: false,
      user: null,
      loading: true
    };
    
    async componentDidMount() {
      try {
        const { isAuthenticated, user } = await this.checkAuth();
        this.setState({ isAuthenticated, user, loading: false });
      } catch (error) {
        this.setState({ loading: false });
      }
    }
    
    checkAuth = async () => {
      const token = localStorage.getItem('token');
      if (!token) {
        return { isAuthenticated: false };
      }
      
      try {
        const response = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (response.ok) {
          const user = await response.json();
          return { isAuthenticated: true, user };
        }
      } catch (error) {
        // Handle error
      }
      
      return { isAuthenticated: false };
    };
    
    render() {
      if (this.state.loading) {
        return <div>Loading...</div>;
      }
      
      if (!this.state.isAuthenticated) {
        return <div>Please log in</div>;
      }
      
      return (
        <WrappedComponent
          {...this.props}
          user={this.state.user}
        />
      );
    }
  };
};

// Использование
const ProtectedProfile = withAuth(UserProfileView);
```

#### Render Props

Паттерн, при котором компонент использует функцию в качестве значения пропа для управления тем, что рендерится.

```javascript
// Пример Render Props для состояния
class DataFetcher extends React.Component {
  state = {
    data: null,
    loading: true,
    error: null
  };
  
  async componentDidMount() {
    try {
      const data = await this.props.fetchData();
      this.setState({ data, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  }
  
  render() {
    return this.props.children({
      data: this.state.data,
      loading: this.state.loading,
      error: this.state.error,
      refetch: this.componentDidMount.bind(this)
    });
  }
}

// Использование
const MyComponent = () => (
  <DataFetcher fetchData={() => fetch('/api/data').then(r => r.json())}>
    {({ data, loading, error, refetch }) => (
      <div>
        {loading && <div>Loading...</div>}
        {error && <div>Error: {error.message}</div>}
        {data && <div>Data: {JSON.stringify(data)}</div>}
        <button onClick={refetch}>Refetch</button>
      </div>
    )}
  </DataFetcher>
);
```

#### Hooks

Паттерн, который позволяет использовать состояние и другие функции React без написания классов.

```javascript
// Кастомный хук для управления формой
function useForm(initialValues, validationRules = {}) {
  const [values, setValues] = React.useState(initialValues);
  const [errors, setErrors] = React.useState({});
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  
  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Валидация при изменении
    if (validationRules[name]) {
      const error = validationRules[name](value);
      setErrors(prev => ({ ...prev, [name]: error || '' }));
    }
  };
  
  const validate = () => {
    const newErrors = {};
    
    Object.keys(validationRules).forEach(field => {
      const error = validationRules[field](values[field]);
      if (error) newErrors[field] = error;
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (onSubmit) => {
    if (!validate()) return;
    
    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } catch (error) {
      // Обработка ошибок
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit
  };
}

// Использование
function LoginForm() {
  const { values, errors, isSubmitting, handleChange, handleSubmit } = useForm(
    { email: '', password: '' },
    {
      email: (value) => !value.includes('@') ? 'Invalid email' : '',
      password: (value) => value.length < 6 ? 'Password too short' : ''
    }
  );
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit(async (formData) => {
        // Отправка данных
        const response = await fetch('/api/login', {
          method: 'POST',
          body: JSON.stringify(formData)
        });
      });
    }}>
      <input
        value={values.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder="Email"
      />
      {errors.email && <span>{errors.email}</span>}
      
      <input
        type="password"
        value={values.password}
        onChange={(e) => handleChange('password', e.target.value)}
        placeholder="Password"
      />
      {errors.password && <span>{errors.password}</span>}
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

### Паттерны управления состоянием

#### Flux

Односторонний поток данных, при котором данные проходят через несколько слоев: action → dispatcher → store → view.

```javascript
// Пример Flux архитектуры
class Dispatcher {
  constructor() {
    this.callbacks = [];
    this.isDispatching = false;
    this.pendingPayload = null;
  }
  
  register(callback) {
    this.callbacks.push(callback);
    return this.callbacks.length - 1;
  }
  
  unregister(id) {
    this.callbacks[id] = null;
  }
  
  dispatch(payload) {
    if (this.isDispatching) {
      throw new Error('Cannot dispatch in the middle of a dispatch');
    }
    
    this.isDispatching = true;
    this.pendingPayload = payload;
    
    try {
      this.callbacks.forEach(callback => {
        if (callback) {
          callback(payload);
        }
      });
    } finally {
      this.isDispatching = false;
      this.pendingPayload = null;
    }
  }
}

class Store {
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this.data = {};
    this.listeners = [];
    
    this.dispatcher.register(this.handleAction.bind(this));
  }
  
  handleAction(payload) {
    // Должен быть переопределен в подклассах
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  emitChange() {
    this.listeners.forEach(listener => listener());
  }
  
  getState() {
    return this.data;
  }
}

class UserStore extends Store {
  constructor(dispatcher) {
    super(dispatcher);
    this.data = { users: [], currentUser: null };
  }
  
  handleAction(payload) {
    switch (payload.type) {
      case 'USER_LOGIN':
        this.data.currentUser = payload.user;
        this.emitChange();
        break;
      case 'USER_LOGOUT':
        this.data.currentUser = null;
        this.emitChange();
        break;
      case 'USERS_LOADED':
        this.data.users = payload.users;
        this.emitChange();
        break;
    }
  }
}

// Использование
const dispatcher = new Dispatcher();
const userStore = new UserStore(dispatcher);

userStore.subscribe(() => {
  console.log('User store changed:', userStore.getState());
});

// Диспетчеризация действия
dispatcher.dispatch({
  type: 'USER_LOGIN',
  user: { id: 1, name: 'John Doe' }
});
```

#### Redux

Расширение концепции Flux с единым хранилищем состояния, неизменяемыми обновлениями и чистыми редьюсерами.

```javascript
// Пример Redux архитектуры
// Actions
const LOGIN_REQUEST = 'LOGIN_REQUEST';
const LOGIN_SUCCESS = 'LOGIN_SUCCESS';
const LOGIN_FAILURE = 'LOGIN_FAILURE';
const LOGOUT = 'LOGOUT';

// Action creators
const loginRequest = (credentials) => ({
  type: LOGIN_REQUEST,
  payload: credentials
});

const loginSuccess = (user) => ({
  type: LOGIN_SUCCESS,
  payload: user
});

const loginFailure = (error) => ({
  type: LOGIN_FAILURE,
  payload: error
});

const logout = () => ({
  type: LOGOUT
});

// Reducer
const initialState = {
  user: null,
  isAuthenticated: false,
  loading: false,
  error: null
};

const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case LOGIN_REQUEST:
      return {
        ...state,
        loading: true,
        error: null
      };
    case LOGIN_SUCCESS:
      return {
        ...state,
        loading: false,
        isAuthenticated: true,
        user: action.payload,
        error: null
      };
    case LOGIN_FAILURE:
      return {
        ...state,
        loading: false,
        isAuthenticated: false,
        user: null,
        error: action.payload
      };
    case LOGOUT:
      return {
        ...state,
        loading: false,
        isAuthenticated: false,
        user: null,
        error: null
      };
    default:
      return state;
  }
};

// Store
const createStore = (reducer) => {
  let state = reducer(undefined, { type: '@@INIT' });
  const listeners = [];
  
  const getState = () => state;
  
  const dispatch = (action) => {
    const newState = reducer(state, action);
    state = newState;
    
    listeners.forEach(listener => listener());
  };
  
  const subscribe = (listener) => {
    listeners.push(listener);
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  };
  
  return { getState, dispatch, subscribe };
};

// Использование
const store = createStore(authReducer);

store.subscribe(() => {
  console.log('State changed:', store.getState());
});

// Диспетчеризация действий
store.dispatch(loginRequest({ email: 'user@example.com', password: 'password' }));
store.dispatch(loginSuccess({ id: 1, name: 'John Doe' }));
```

#### Context API

Позволяет передавать данные через дерево компонентов без необходимости передавать props на каждом уровне.

```javascript
// Пример использования Context API
import React, { createContext, useContext, useReducer } from 'react';

// Создание контекста
const AppContext = createContext();

// Редьюсер для управления состоянием
const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload, isAuthenticated: true };
    case 'LOGOUT':
      return { ...state, user: null, isAuthenticated: false };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    default:
      return state;
  }
};

// Провайдер контекста
export const AppProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    isAuthenticated: false,
    theme: 'light'
  });
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};

// Хук для использования контекста
export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
};

// Использование в компоненте
const UserProfile = () => {
  const { state, dispatch } = useAppContext();
  
  const handleLogout = () => {
    dispatch({ type: 'LOGOUT' });
  };
  
  if (!state.isAuthenticated) {
    return <div>Please log in</div>;
  }
  
  return (
    <div>
      <h1>Welcome, {state.user.name}</h1>
      <button onClick={handleLogout}>Logout</button>
    </div>
  );
};
```

#### State Machine

Паттерн для моделирования поведения компонентов как конечного автомата.

```javascript
// Пример State Machine для компонента загрузки файла
const fileUploadStates = {
  IDLE: 'idle',
  UPLOADING: 'uploading',
  SUCCESS: 'success',
  ERROR: 'error'
};

const fileUploadTransitions = {
  [fileUploadStates.IDLE]: [fileUploadStates.UPLOADING],
  [fileUploadStates.UPLOADING]: [fileUploadStates.SUCCESS, fileUploadStates.ERROR],
  [fileUploadStates.SUCCESS]: [fileUploadStates.IDLE],
  [fileUploadStates.ERROR]: [fileUploadStates.IDLE]
};

class FileUploadStateMachine {
  constructor() {
    this.state = fileUploadStates.IDLE;
    this.file = null;
    this.progress = 0;
    this.error = null;
  }
  
  canTransition(toState) {
    return fileUploadTransitions[this.state].includes(toState);
  }
  
  transition(toState, data = {}) {
    if (!this.canTransition(toState)) {
      throw new Error(`Cannot transition from ${this.state} to ${toState}`);
    }
    
    this.state = toState;
    
    switch (toState) {
      case fileUploadStates.UPLOADING:
        this.file = data.file;
        this.progress = 0;
        break;
      case fileUploadStates.SUCCESS:
        this.progress = 100;
        break;
      case fileUploadStates.ERROR:
        this.error = data.error;
        break;
      case fileUploadStates.IDLE:
        this.file = null;
        this.progress = 0;
        this.error = null;
        break;
    }
  }
  
  upload(file) {
    this.transition(fileUploadStates.UPLOADING, { file });
    
    // Имитация загрузки
    const interval = setInterval(() => {
      this.progress += 10;
      if (this.progress >= 100) {
        clearInterval(interval);
        // Имитация случайной ошибки
        if (Math.random() > 0.8) {
          this.transition(fileUploadStates.ERROR, { error: 'Upload failed' });
        } else {
          this.transition(fileUploadStates.SUCCESS);
        }
      }
    }, 200);
  }
  
  reset() {
    this.transition(fileUploadStates.IDLE);
  }
}

// Использование в React компоненте
function FileUploadComponent() {
  const [machine, setMachine] = React.useState(new FileUploadStateMachine());
  
  const handleFileSelect = (event) => {
    const file = event.target.files[0];
    machine.upload(file);
    setMachine(machine); // Принудительный ререндер
  };
  
  const handleReset = () => {
    machine.reset();
    setMachine(machine);
  };
  
  return (
    <div>
      {machine.state === fileUploadStates.IDLE && (
        <input type="file" onChange={handleFileSelect} />
      )}
      
      {machine.state === fileUploadStates.UPLOADING && (
        <div>
          <p>Uploading: {machine.file.name}</p>
          <progress value={machine.progress} max="100" />
        </div>
      )}
      
      {machine.state === fileUploadStates.SUCCESS && (
        <div>
          <p>Upload successful!</p>
          <button onClick={handleReset}>Upload another</button>
        </div>
      )}
      
      {machine.state === fileUploadStates.ERROR && (
        <div>
          <p>Error: {machine.error}</p>
          <button onClick={handleReset}>Try again</button>
        </div>
      )}
    </div>
  );
}
```

### Паттерны общения между компонентами

#### Publish/Subscribe (Pub/Sub)

Позволяет компонентам отправлять и получать сообщения через центральный брокер.

```javascript
// Пример Pub/Sub системы
class EventBus {
  constructor() {
    this.subscribers = {};
  }
  
  subscribe(event, callback) {
    if (!this.subscribers[event]) {
      this.subscribers[event] = [];
    }
    this.subscribers[event].push(callback);
    
    // Возвращаем функцию отписки
    return () => {
      this.subscribers[event] = this.subscribers[event].filter(cb => cb !== callback);
    };
  }
  
  publish(event, data) {
    if (this.subscribers[event]) {
      this.subscribers[event].forEach(callback => callback(data));
    }
  }
  
  once(event, callback) {
    const unsubscribe = this.subscribe(event, (data) => {
      callback(data);
      unsubscribe();
    });
  }
}

// Использование
const eventBus = new EventBus();

// Подписка на события
const unsubscribe = eventBus.subscribe('user:login', (user) => {
  console.log('User logged in:', user);
});

eventBus.subscribe('user:logout', () => {
  console.log('User logged out');
});

// Публикация событий
eventBus.publish('user:login', { id: 1, name: 'John' });
eventBus.publish('user:logout');

// Отписка
unsubscribe();
```

#### Event Bus

Централизованный механизм для передачи событий между компонентами.

```javascript
// Пример Event Bus с middleware
class EventSystem {
  constructor() {
    this.listeners = new Map();
    this.middlewares = [];
  }
  
  use(middleware) {
    this.middlewares.push(middleware);
  }
  
  async emit(event, data) {
    // Применение middleware
    let processedData = data;
    for (const middleware of this.middlewares) {
      processedData = await middleware(event, processedData);
    }
    
    // Уведомление слушателей
    const listeners = this.listeners.get(event) || [];
    for (const listener of listeners) {
      try {
        await listener(processedData);
      } catch (error) {
        console.error(`Error in listener for event ${event}:`, error);
      }
    }
  }
  
  on(event, listener) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(listener);
    
    // Возвращаем функцию отписки
    return () => {
      const listeners = this.listeners.get(event);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }
  
  once(event, listener) {
    const unsubscribe = this.on(event, async (data) => {
      await listener(data);
      unsubscribe();
    });
  }
}

// Пример middleware для логирования
const loggingMiddleware = async (event, data) => {
  console.log(`Event: ${event}`, data);
  return data;
};

// Пример middleware для валидации
const validationMiddleware = async (event, data) => {
  if (event === 'user:create' && (!data.email || !data.name)) {
    throw new Error('Email and name are required');
  }
  return data;
};

// Использование
const eventSystem = new EventSystem();
eventSystem.use(loggingMiddleware);
eventSystem.use(validationMiddleware);

eventSystem.on('user:create', async (userData) => {
  console.log('Creating user:', userData);
  // Логика создания пользователя
});

try {
  await eventSystem.emit('user:create', { name: 'John', email: 'john@example.com' });
} catch (error) {
  console.error('Event emission failed:', error.message);
}
```

#### Global State

Общий доступ к состоянию между компонентами приложения.

```javascript
// Пример глобального состояния с реактивностью
class GlobalState {
  constructor(initialState = {}) {
    this.state = { ...initialState };
    this.listeners = new Map();
    this.computedValues = new Map();
  }
  
  // Установка значения
  set(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    // Уведомление слушателей
    if (this.listeners.has(key)) {
      this.listeners.get(key).forEach(callback => {
        try {
          callback(value, oldValue);
        } catch (error) {
          console.error(`Error in listener for ${key}:`, error);
        }
      });
    }
    
    // Обновление вычисляемых значений
    this.updateComputedValues();
  }
  
  // Получение значения
  get(key) {
    return this.state[key];
  }
  
  // Подписка на изменение
  subscribe(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key).add(callback);
    
    // Возвращаем функцию отписки
    return () => {
      this.listeners.get(key)?.delete(callback);
    };
  }
  
  // Создание вычисляемого значения
  computed(key, dependencies, computeFn) {
    this.computedValues.set(key, {
      dependencies,
      computeFn,
      lastValue: undefined
    });
    
    // Подписка на зависимости
    dependencies.forEach(dep => {
      this.subscribe(dep, () => {
        this.updateComputedValues();
      });
    });
    
    // Вычисляем начальное значение
    this.updateComputedValues();
  }
  
  // Обновление вычисляемых значений
  updateComputedValues() {
    for (const [key, config] of this.computedValues) {
      const newValue = config.computeFn(this.state);
      if (newValue !== config.lastValue) {
        config.lastValue = newValue;
        this.state[key] = newValue;
        
        // Уведомление слушателей
        if (this.listeners.has(key)) {
          this.listeners.get(key).forEach(callback => {
            try {
              callback(newValue, this.state[key]);
            } catch (error) {
              console.error(`Error in listener for computed ${key}:`, error);
            }
          });
        }
      }
    }
  }
}

// Использование
const globalState = new GlobalState({
  user: null,
  theme: 'light',
  notifications: []
});

// Подписка на изменение пользователя
const unsubscribe = globalState.subscribe('user', (newUser, oldUser) => {
  console.log('User changed:', { newUser, oldUser });
});

// Создание вычисляемого значения
globalState.computed(
  'isLoggedIn',
  ['user'],
  (state) => !!state.user
);

// Установка значения
globalState.set('user', { id: 1, name: 'John' });
// Вывод: "User changed: { newUser: { id: 1, name: 'John' }, oldUser: null }"

console.log(globalState.get('isLoggedIn')); // true
```

## Архитектурные паттерны

### Чистая архитектура (Clean Architecture)

Архитектурный подход, при котором бизнес-логика изолирована от внешних факторов.

```javascript
// Пример чистой архитектуры
// Domain entities
class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  updateEmail(newEmail) {
    if (!newEmail.includes('@')) {
      throw new Error('Invalid email format');
    }
    this.email = newEmail;
  }
}

// Use cases (application business rules)
class GetUserUseCase {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }
  
  async execute(userId) {
    if (!userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(userId);
    
    if (!user) {
      throw new Error('User not found');
    }
    
    return user;
  }
}

class CreateUserUseCase {
  constructor(userRepository, emailValidator) {
    this.userRepository = userRepository;
    this.emailValidator = emailValidator;
  }
  
  async execute(userData) {
    if (!this.emailValidator.isValid(userData.email)) {
      throw new Error('Invalid email');
    }
    
    const existingUser = await this.userRepository.findByEmail(userData.email);
    
    if (existingUser) {
      throw new Error('User with this email already exists');
    }
    
    const user = new User(
      this.generateId(),
      userData.name,
      userData.email
    );
    
    await this.userRepository.save(user);
    
    return user;
  }
  
  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
}

// Interface adapters
class UserPresenter {
  presentUser(user) {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      formattedDate: new Date().toISOString()
    };
  }
  
  presentError(error) {
    return {
      error: true,
      message: error.message
    };
  }
}

// Frameworks & Drivers (controllers)
class UserController {
  constructor(getUserUseCase, createUserUseCase, presenter) {
    this.getUserUseCase = getUserUseCase;
    this.createUserUseCase = createUserUseCase;
    this.presenter = presenter;
  }
  
  async getUser(req, res) {
    try {
      const user = await this.getUserUseCase.execute(req.params.id);
      const presentedUser = this.presenter.presentUser(user);
      res.json(presentedUser);
    } catch (error) {
      const errorResponse = this.presenter.presentError(error);
      res.status(404).json(errorResponse);
    }
  }
  
  async createUser(req, res) {
    try {
      const user = await this.createUserUseCase.execute(req.body);
      const presentedUser = this.presenter.presentUser(user);
      res.status(201).json(presentedUser);
    } catch (error) {
      const errorResponse = this.presenter.presentError(error);
      res.status(400).json(errorResponse);
    }
  }
}

// Repository interface
class UserRepository {
  async findById(id) {
    throw new Error('Method not implemented');
  }
  
  async findByEmail(email) {
    throw new Error('Method not implemented');
  }
  
  async save(user) {
    throw new Error('Method not implemented');
  }
}

// Implementation
class InMemoryUserRepository extends UserRepository {
  constructor() {
    super();
    this.users = new Map();
  }
  
  async findById(id) {
    return this.users.get(id) || null;
  }
  
  async findByEmail(email) {
    for (const user of this.users.values()) {
      if (user.email === email) {
        return user;
      }
    }
    return null;
  }
  
  async save(user) {
    this.users.set(user.id, user);
  }
}

// Validator interface
class EmailValidator {
  isValid(email) {
    throw new Error('Method not implemented');
  }
}

class DefaultEmailValidator extends EmailValidator {
  isValid(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

// Использование
const userRepository = new InMemoryUserRepository();
const emailValidator = new DefaultEmailValidator();

const getUserUseCase = new GetUserUseCase(userRepository);
const createUserUseCase = new CreateUserUseCase(userRepository, emailValidator);
const presenter = new UserPresenter();
const userController = new UserController(getUserUseCase, createUserUseCase, presenter);
```

### Архитектура слоев (Layered Architecture)

Организация приложения в горизонтальные слои, каждый из которых отвечает за свою область ответственности.

```
┌─────────────────┐
│   Presentation  │ ← UI слой (React/Vue/Angular компоненты)
├─────────────────┤
│   Application   │ ← Слой приложения (Use Cases, Services)
├─────────────────┤
│     Domain      │ ← Слой домена (Entities, Business Logic)
├─────────────────┤
│  Infrastructure │ ← Слой инфраструктуры (DB, API, Storage)
└─────────────────┘
```

### Микрослойная архитектура (Microkernel Architecture)

Централизованное ядро с возможностью расширения функциональности через дополнительные модули.

```javascript
// Пример микроядерной архитектуры
class MicroKernel {
  constructor() {
    this.coreServices = new Map();
    this.plugins = new Map();
    this.eventBus = new EventBus();
  }
  
  registerService(name, service) {
    this.coreServices.set(name, service);
  }
  
  getService(name) {
    return this.coreServices.get(name);
  }
  
  registerPlugin(plugin) {
    plugin.init(this);
    this.plugins.set(plugin.getName(), plugin);
  }
  
  getPlugin(name) {
    return this.plugins.get(name);
  }
  
  // Методы для взаимодействия с плагинами
  broadcastEvent(event, data) {
    for (const plugin of this.plugins.values()) {
      plugin.handleEvent && plugin.handleEvent(event, data);
    }
  }
  
  executeCommand(command, ...args) {
    for (const plugin of this.plugins.values()) {
      if (plugin.canHandleCommand && plugin.canHandleCommand(command)) {
        return plugin.executeCommand(command, ...args);
      }
    }
    throw new Error(`No plugin can handle command: ${command}`);
  }
}

// Пример плагина
class LoggerPlugin {
  getName() {
    return 'logger';
  }
  
  init(kernel) {
    this.kernel = kernel;
    this.logs = [];
  }
  
  handleEvent(event, data) {
    this.logs.push({
      event,
      data,
      timestamp: new Date().toISOString()
    });
  }
  
  getLogs() {
    return this.logs;
  }
  
  clearLogs() {
    this.logs = [];
  }
}

// Пример плагина для кэширования
class CachePlugin {
  getName() {
    return 'cache';
  }
  
  init(kernel) {
    this.kernel = kernel;
    this.cache = new Map();
  }
  
  canHandleCommand(command) {
    return ['cache:get', 'cache:set', 'cache:clear'].includes(command);
  }
  
  executeCommand(command, key, value) {
    switch (command) {
      case 'cache:set':
        this.cache.set(key, value);
        return true;
      case 'cache:get':
        return this.cache.get(key);
      case 'cache:clear':
        this.cache.clear();
        return true;
      default:
        return null;
    }
  }
}

// Использование
const kernel = new MicroKernel();
kernel.registerPlugin(new LoggerPlugin());
kernel.registerPlugin(new CachePlugin());

// Использование плагинов
kernel.broadcastEvent('user:login', { userId: 1 });
console.log(kernel.getPlugin('logger').getLogs());

kernel.executeCommand('cache:set', 'user:1', { id: 1, name: 'John' });
console.log(kernel.executeCommand('cache:get', 'user:1'));
```

### Микросервисная архитектура (Microservices Architecture)

Разделение приложения на независимые сервисы, каждый из которых отвечает за определенную функцию.

```javascript
// Пример микросервисной архитектуры
class Microservice {
  constructor(name, dependencies = []) {
    this.name = name;
    this.dependencies = dependencies;
    this.eventBus = new EventBus();
    this.apiClient = new APIClient();
  }
  
  async initialize() {
    // Проверка зависимостей
    await this.checkDependencies();
    
    // Подписка на события
    this.subscribeToEvents();
    
    // Регистрация маршрутов API
    this.registerAPIRoutes();
  }
  
  async checkDependencies() {
    for (const dependency of this.dependencies) {
      try {
        await this.apiClient.get(`${dependency}/health`);
      } catch (error) {
        throw new Error(`Dependency ${dependency} is not available: ${error.message}`);
      }
    }
  }
  
  subscribeToEvents() {
    // Переопределяется в подклассах
  }
  
  registerAPIRoutes() {
    // Переопределяется в подклассах
  }
  
  emitEvent(event, data) {
    this.eventBus.publish(`${this.name}:${event}`, data);
  }
  
  async callService(service, endpoint, data) {
    return await this.apiClient.post(`http://${service}:3000${endpoint}`, data);
  }
}

// Пример сервиса пользователей
class UserService extends Microservice {
  constructor() {
    super('user-service', ['database-service']);
    this.users = new Map();
  }
  
  subscribeToEvents() {
    // Подписка на события из других сервисов
    this.eventBus.subscribe('order-service:order-created', async (data) => {
      // Обработка события создания заказа
      console.log(`User ${data.userId} created order ${data.orderId}`);
    });
  }
  
  registerAPIRoutes() {
    // Регистрация маршрутов API
    this.api = {
      async getUser(req) {
        const user = await this.findById(req.params.id);
        return user ? { success: true, data: user } : { success: false, error: 'User not found' };
      },
      
      async createUser(req) {
        const user = new User(req.body.id, req.body.name, req.body.email);
        this.users.set(user.id, user);
        
        // Эмит события о создании пользователя
        this.emitEvent('user-created', { userId: user.id, name: user.name });
        
        return { success: true, data: user };
      }
    };
  }
  
  async findById(id) {
    return this.users.get(id);
  }
}

// Пример сервиса заказов
class OrderService extends Microservice {
  constructor() {
    super('order-service', ['user-service', 'payment-service']);
    this.orders = new Map();
  }
  
  subscribeToEvents() {
    // Подписка на события создания пользователей
    this.eventBus.subscribe('user-service:user-created', async (data) => {
      console.log(`New user created: ${data.name}`);
      // Могут быть дополнительные действия
    });
  }
  
  async createOrder(orderData) {
    // Проверка пользователя через сервис пользователей
    const userResponse = await this.callService('user-service', '/users/' + orderData.userId, {});
    
    if (!userResponse.success) {
      throw new Error('User not found');
    }
    
    const order = {
      id: Math.random().toString(36).substr(2, 9),
      ...orderData,
      createdAt: new Date().toISOString()
    };
    
    this.orders.set(order.id, order);
    
    // Эмит события о создании заказа
    this.emitEvent('order-created', { 
      orderId: order.id, 
      userId: order.userId,
      total: order.total 
    });
    
    return order;
  }
}

// Использование
const userService = new UserService();
const orderService = new OrderService();

await userService.initialize();
await orderService.initialize();
```

### Событийно-ориентированная архитектура (Event-Driven Architecture)

Архитектура, в которой компоненты взаимодействуют через события.

```javascript
// Пример событийно-ориентированной архитектуры
class EventDrivenSystem {
  constructor() {
    this.eventBus = new EventBus();
    this.eventStore = new EventStore();
    this.projections = new Map();
  }
  
  registerProjection(name, projection) {
    this.projections.set(name, projection);
    // Подписка проекции на соответствующие события
    projection.subscribe(this.eventBus);
  }
  
  async emitEvent(event) {
    // Сохранение события в хранилище событий
    await this.eventStore.save(event);
    
    // Обновление всех проекций
    for (const projection of this.projections.values()) {
      await projection.update(event);
    }
    
    // Публикация события в шину событий
    this.eventBus.publish(event.type, event);
  }
}

// Хранилище событий
class EventStore {
  constructor() {
    this.events = [];
  }
  
  async save(event) {
    this.events.push({
      ...event,
      timestamp: new Date().toISOString(),
      sequenceNumber: this.events.length
    });
  }
  
  async getEventsByType(type) {
    return this.events.filter(e => e.type === type);
  }
  
  async getEventsByAggregateId(aggregateId) {
    return this.events.filter(e => e.aggregateId === aggregateId);
  }
}

// Пример проекции
class UserViewProjection {
  constructor() {
    this.users = new Map();
  }
  
  subscribe(eventBus) {
    eventBus.subscribe('UserRegistered', (event) => {
      this.users.set(event.aggregateId, {
        id: event.aggregateId,
        email: event.data.email,
        name: event.data.name,
        createdAt: event.timestamp
      });
    });
    
    eventBus.subscribe('UserProfileUpdated', (event) => {
      const user = this.users.get(event.aggregateId);
      if (user) {
        Object.assign(user, event.data);
        user.updatedAt = event.timestamp;
      }
    });
  }
  
  async update(event) {
    // Обновление проекции на основе события
    // Реализация зависит от типа события
  }
  
  getUser(id) {
    return this.users.get(id);
  }
}

// Пример доменного события
class DomainEvent {
  constructor(type, aggregateId, data, metadata = {}) {
    this.type = type;
    this.aggregateId = aggregateId;
    this.data = data;
    this.metadata = {
      timestamp: new Date().toISOString(),
      ...metadata
    };
  }
}

// Использование
const system = new EventDrivenSystem();
const userProjection = new UserViewProjection();

system.registerProjection('user-view', userProjection);

// Эмит события
await system.emitEvent(new DomainEvent(
  'UserRegistered',
  'user-123',
  { email: 'john@example.com', name: 'John Doe' }
));

console.log(userProjection.getUser('user-123'));
```

## Паттерны в контексте фронтенд-архитектуры

### Компонентная архитектура

Использование паттернов для организации компонентов:
- Модульность
- Повторное использование
- Изоляция
- Интерфейсные контракты

### Архитектура управления состоянием

Использование паттернов для эффективного управления состоянием приложения:
- Централизация
- Неизменяемость
- Очистка и нормализация
- Повторное использование и масштабируемость

### API-интеграция

Паттерны для взаимодействия с внешними API:
- Repository Pattern
- Service Layer
- Event Sourcing
- CQRS

## Интеграция паттернов в архитектуру

### Выбор паттернов

При выборе паттернов необходимо учитывать:
- Сложность приложения
- Ожидаемый срок службы
- Размер команды разработчиков
- Требования к производительности
- Требования к сопровождаемости

### Документирование паттернов

Важно документировать:
- Какие паттерны используются
- Почему был выбран тот или иной паттерн
- Как использовать паттерн корректно
- Где и как реализуется паттерн

### Обучение паттернам

- Регулярные тренинги и сессии
- Код-ревью с акцентом на паттерны
- Менторство и наставничество
- Примеры использования паттернов

## Паттерны и тестирование

### Тестируемость паттернов

Некоторые паттерны улучшают тестируемость:
- Использование интерфейсов и зависимостей
- Изоляция логики
- Упрощение мокирования

### Паттерны тестирования

- Arrange, Act, Assert
- Given, When, Then
- AAA (Assemble, Activate, Assert)
- BDD (Behavior Driven Development)
- TDD (Test Driven Development)

## Паттерны и производительность

### Производительные паттерны

- Использование memoization
- Lazy evaluation
- Virtual DOM
- Optimistic updates
- Caching strategies

### Паттерны, потенциально снижающие производительность

- Неправильное использование Observer
- Чрезмерное усложнение через паттерны
- Неправильная вложенность паттернов

## Паттерны и безопасность

### Безопасные паттерны

- Правильное управление авторизацией
- Защита от XSS и CSRF
- Санитизация данных
- Защита информации в состоянии

### Потенциально опасные паттерны

- Неправильное хранение чувствительных данных
- Недостаточная проверка авторизации
- Неправильная обработка данных из внешних источников

## Паттерны в фреймворках

### React паттерны

- Compound Components
- Render Props
- Higher-Order Components
- Custom Hooks
- Provider Pattern

### Vue паттерны

- Mixins
- Composables
- Provide/Inject Pattern
- Event Bus Pattern
- Vuex/Pinia Patterns

### Angular паттерны

- Dependency Injection
- Services
- Pipes
- Directives
- Guards

## Паттерны и масштабируемость

### Паттерны масштабирования

- Модульность и композиция
- Слабая связанность
- Единая точка ответственности
- Инверсия зависимостей

### Паттерны для больших команд

- Feature Slices
- Module Federation
- Micro-Frontends
- Decentralized State Management

## Современные тенденции

### Функциональные паттерны

- Чистые функции
- Иммутабельность данных
- Композиция функций
- Обработка ошибок через Either/Maybe монады

### Паттерны для событийно-ориентированной архитектуры

- Event Sourcing
- CQRS
- Saga Pattern
- Command/Query Separation

## Анти-паттерны

### Распространенные анти-паттерны

- God Objects (объекты с избыточной ответственностью)
- Spaghetti Code (непонятная структура кода)
- Prop Drilling (передача пропсов через несколько уровней)
- Premature Optimization (оптимизация слишком рано)
- Over-Engineering (чрезмерно сложные решения)

### Как избегать анти-паттернов

- Регулярные рецензии кода
- Обучение команды
- Внедрение стандартов разработки
- Использование статических анализаторов

## Выбор паттернов

### Критерии выбора

- Сложность задачи
- Взаимодействие с командой
- Поддержка в используемых инструментах
- Ожидаемое изменение функциональности
- Требования к производительности
- Обязательства по времени и ресурсам

### Баланс между сложностью и пользой

Важно найти баланс между:
- Упрощением разработки
- Уменьшением сложности
- Повышением производительности
- Увеличением требований к памяти и вычислениям

## Паттерны и архитектура компонентов

### Компонентные паттерны

- Compound Components
- Control Props
- State Reducer
- Props Getters
- Render Props
- Hooks

### Паттерны композиции компонентов

- Композиция через children
- Композиция через слоты
- Композиция через хуки
- Композиция через контекст

## Паттерны и архитектура управления состоянием

### Паттерны управления состоянием

- Flux
- Redux
- Context API
- Zustand
- Jotai
- Recoil

### Паттерны нормализации состояния

- Entity normalization
- Relational data structures
- Optimistic updates
- State synchronization

## Паттерны и архитектура API интеграций

### Паттерны интеграции с API

- Repository Pattern
- Service Layer
- API Gateway
- Circuit Breaker
- Retry Pattern
- Cache Pattern

## Паттерны и архитектура тестирования

### Паттерны тестирования

- Arrange-Act-Assert
- Given-When-Then
- AAA (Assemble-Activate-Assert)
- BDD (Behavior Driven Development)
- TDD (Test Driven Development)

### Паттерны мокирования

- Mock objects
- Stub functions
- Fake services
- Test doubles

## Паттерны и архитектура безопасности

### Паттерны безопасности

- Authentication patterns
- Authorization patterns
- Input validation patterns
- Sanitization patterns

## Паттерны и архитектура производительности

### Паттерны производительности

- Memoization
- Lazy loading
- Code splitting
- Virtualization
- Debouncing
- Throttling

## Паттерны и архитектура международизации

### Паттерны i18n

- Centralized i18n
- Modular i18n
- Context-based translations
- Pluralization patterns

## Заключение

Архитектурные паттерны проектирования - это важный инструмент в создании качественных и сопровождаемых фронтенд-приложений. Выбор правильных паттернов, их правильная реализация и последовательное использование в команде обеспечивает:
- Повышение сопровождаемости кода
- Улучшение производительности
- Повышение безопасности
- Легкость масштабирования
- Упрощение обучения новых членов команды

Архитекторы должны тщательно взвешивать выбор паттернов, учитывая специфику проекта, команды и требований к приложению.

## Связанные концепции

- [[../frontend/архитектура-фронтенда]] - общая архитектура фронтенда
- [[../frontend/компонентная-архитектура]] - компонентная архитектура
- [[../frontend/архитектура-управления-состоянием]] - архитектура управления состоянием
- [[../api/архитектура-интеграции-api]] - архитектура API интеграций
- [[../performance/архитектура-производительности]] - архитектура производительности
- [[../testing/архитектура-тестирования]] - архитектура тестирования
- [[../security/архитектура-безопасности]] - архитектура безопасности
- [[../observability/архитектура-наблюдаемости]] - архитектура наблюдаемости
- [[../microservices/архитектура-микросервисов]] - микросервисная архитектура
- [[../microservices/архитектура-событийно-ориентированных-систем]] - событийно-ориентированная архитектура
- [[../frontend/модульная-архитектура]] - модульная архитектура
- [[../frontend/архитектура-интернационализации]] - архитектура интернационализации
- [[../documentation/архитектура-документации]] - архитектура документации
- [[../devops/архитектура-непрерывной-интеграции-и-доставки]] - архитектура CI/CD
- [[../frontend/архитектура-фронтенда]] - архитектура доступности
- [[../frontend/архитектура-обработки-ошибок]] - архитектура обработки ошибок

## Теги

#дизайн-паттерны #архитектурные-паттерны #frontend-архитектура #компонентные-паттерны #управление-состоянием #структурные-паттерны #поведенческие-паттерны #порождающие-паттерны #react-паттерны #vue-паттерны #angular-паттерны #arhitecture #programming-patterns #software-design #clean-code #solid-principles #grasp-patterns #oop #functional-programming #reactive-programming #architectural-decisions #code-quality #maintainability #scalability #testability #reusability #modularity #separation-of-concerns #dependency-injection #pattern-selection #pattern-implementation #pattern-documentation #pattern-training #pattern-anti-patterns #архитектурные-решения #шаблоны-проектирования #frontend-patterns #component-patterns #state-patterns #api-patterns #event-patterns #microservice-patterns #layered-architecture #flux-pattern #mvc-pattern #mvp-pattern #mvvm-pattern #ddd-patterns #cqrs-patterns #event-sourcing-patterns #react-patterns #vue-patterns #angular-patterns #pattern-architecture #pattern-architecture-design #pattern-architecture-principles #pattern-architecture-components #pattern-architecture-layers #pattern-architecture-styles #pattern-architecture-methodologies #pattern-architecture-frameworks #pattern-architecture-tools #pattern-architecture-processes #pattern-architecture-teams #pattern-architecture-governance #pattern-architecture-compliance #pattern-architecture-quality #pattern-architecture-metrics #pattern-architecture-monitoring #pattern-architecture-observability #pattern-architecture-testing #pattern-architecture-security #pattern-architecture-performance #pattern-architecture-scalability #pattern-architecture-maintainability #pattern-architecture-usability #pattern-architecture-reliability #pattern-architecture-efficiency #pattern-architecture-portability #pattern-architecture-interoperability #pattern-architecture-optimization #pattern-architecture-caching #pattern-architecture-normalization #pattern-architecture-immutable #pattern-architecture-seriali... [truncated]