# Единая Архитектура Интернационализации и Локализации

## Введение

Архитектура интернационализации и локализации — это совокупность принципов, паттернов и практик, определяющих эффективную реализацию поддержки нескольких языков и региональных стандартов в веб-приложениях. Хорошо спроектированная архитектура i18n/l10n обеспечивает глобальную доступность приложения и улучшает пользовательский опыт для международной аудитории.

Интернационализация (i18n) — это процесс проектирования и разработки приложения таким образом, чтобы оно могло быть адаптировано для различных языков и регионов без необходимости внесения инженерных изменений.

Локализация (l10n) — это процесс адаптации интернационализированного приложения для конкретного региона или языка, включая перевод текстов, адаптацию форматов дат, чисел, валют и других региональных особенностей.

## Архитектурные подходы

### 1. Централизованная Архитектура

Все ресурсы локализации хранятся в одном месте и управляются централизованно.

```javascript
// Централизованная система i18n
class I18nManager {
  constructor() {
    this.translations = {};
    this.currentLocale = 'en';
    this.fallbackLocale = 'en';
    this.formatters = {};
  }
  
  // Загрузка переводов
  async loadTranslations(locale) {
    try {
      const translations = await import(`../locales/${locale}.json`);
      this.translations[locale] = translations.default;
      return translations.default;
    } catch (error) {
      console.error(`Failed to load translations for ${locale}:`, error);
      return {};
    }
  }
  
  // Установка локали
  async setLocale(locale) {
    if (!this.translations[locale]) {
      await this.loadTranslations(locale);
    }
    
    this.currentLocale = locale;
    this.initializeFormatters(locale);
    this.notifyLocaleChange(locale);
  }
  
  // Получение перевода
  t(key, params = {}) {
    const translation = this.getTranslation(key);
    
    if (!translation) {
      console.warn(`Missing translation for key: ${key}`);
      return key; // Возвращаем ключ как fallback
    }
    
    return this.interpolate(translation, params);
  }
  
  // Получение перевода с учетом локали
  getTranslation(key) {
    // Пытаемся получить перевод для текущей локали
    let translation = this.getNestedValue(this.translations[this.currentLocale], key);
    
    // Если нет перевода, используем fallback локаль
    if (!translation && this.currentLocale !== this.fallbackLocale) {
      translation = this.getNestedValue(this.translations[this.fallbackLocale], key);
    }
    
    return translation;
  }
  
  // Интерполяция параметров в строке
  interpolate(template, params) {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== undefined ? params[key] : match;
    });
  }
  
  // Получение вложенного значения по ключу
  getNestedValue(obj, key) {
    return key.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : null, obj);
  }
  
  // Инициализация форматтеров для локали
  initializeFormatters(locale) {
    // Форматирование дат
    this.formatters.date = new Intl.DateTimeFormat(locale);
    
    // Форматирование чисел
    this.formatters.number = new Intl.NumberFormat(locale);
    
    // Форматирование валют
    this.formatters.currency = (currency) => 
      new Intl.NumberFormat(locale, { style: 'currency', currency });
    
    // Форматирование относительного времени
    this.formatters.relativeTime = new Intl.RelativeTimeFormat(locale);
  }
  
  // Уведомление об изменении локали
  notifyLocaleChange(locale) {
    // Отправляем событие об изменении локали
    window.dispatchEvent(new CustomEvent('localechange', { detail: { locale } }));
  }
}

// Использование
const i18n = new I18nManager();
await i18n.setLocale('ru');

// Простой перевод
console.log(i18n.t('welcome.message')); // "Добро пожаловать!"

// Перевод с параметрами
console.log(i18n.t('user.greeting', { name: 'Иван' })); // "Привет, Иван!"
```

### 2. Модульная Архитектура

Ресурсы локализации распределены по модулям приложения.

```javascript
// Модульная система i18n
class ModularI18n {
  constructor() {
    this.modules = new Map();
    this.currentLocale = 'en';
  }
  
  // Регистрация модуля локализации
  registerModule(moduleName, translations) {
    if (!this.modules.has(moduleName)) {
      this.modules.set(moduleName, {});
    }
    
    Object.keys(translations).forEach(locale => {
      if (!this.modules.get(moduleName)[locale]) {
        this.modules.get(moduleName)[locale] = {};
      }
      
      Object.assign(
        this.modules.get(moduleName)[locale],
        translations[locale]
      );
    });
  }
  
  // Получение перевода из модуля
  t(moduleName, key, params = {}) {
    const module = this.modules.get(moduleName);
    if (!module) {
      console.warn(`Module ${moduleName} not found`);
      return key;
    }
    
    const translations = module[this.currentLocale] || 
                         module[Object.keys(module)[0]] || {};
    
    const translation = this.getNestedValue(translations, key);
    if (!translation) {
      console.warn(`Translation for ${key} not found in module ${moduleName}`);
      return key;
    }
    
    return this.interpolate(translation, params);
  }
  
  // Получение вложенного значения
  getNestedValue(obj, key) {
    return key.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : null, obj);
  }
  
  // Интерполяция параметров
  interpolate(template, params) {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== undefined ? params[key] : match;
    });
  }
}

// Использование
const i18n = new ModularI18n();

// Регистрация переводов для модуля auth
i18n.registerModule('auth', {
  en: {
    'login.title': 'Login',
    'login.button': 'Sign In',
    'register.title': 'Register',
    'register.button': 'Create Account'
  },
  ru: {
    'login.title': 'Вход',
    'login.button': 'Войти',
    'register.title': 'Регистрация',
    'register.button': 'Создать аккаунт'
  }
});

// Использование в компоненте
console.log(i18n.t('auth', 'login.title')); // "Вход" (если текущая локаль ru)
```

## Структура файлов локализации

### 1. Плоская структура

```json
// locales/en.json
{
  "welcome": "Welcome",
  "login": "Login",
  "logout": "Logout",
  "user": {
    "profile": "Profile",
    "settings": "Settings"
  }
}

// locales/ru.json
{
  "welcome": "Добро пожаловать",
  "login": "Вход",
  "logout": "Выход",
  "user": {
    "profile": "Профиль",
    "settings": "Настройки"
  }
}
```

### 2. Модульная структура

```
locales/
├── en/
│   ├── common.json
│   ├── auth.json
│   ├── dashboard.json
│   └── profile.json
└── ru/
    ├── common.json
    ├── auth.json
    ├── dashboard.json
    └── profile.json
```

```json
// locales/en/auth.json
{
  "login": {
    "title": "Login",
    "email": "Email",
    "password": "Password",
    "button": "Sign In",
    "forgotPassword": "Forgot password?",
    "errors": {
      "invalidCredentials": "Invalid email or password",
      "accountLocked": "Account is locked"
    }
  },
  "register": {
    "title": "Register",
    "name": "Full Name",
    "email": "Email",
    "password": "Password",
    "confirmPassword": "Confirm Password",
    "button": "Create Account"
  }
}

// locales/ru/auth.json
{
  "login": {
    "title": "Вход",
    "email": "Email",
    "password": "Пароль",
    "button": "Войти",
    "forgotPassword": "Забыли пароль?",
    "errors": {
      "invalidCredentials": "Неверный email или пароль",
      "accountLocked": "Аккаунт заблокирован"
    }
  },
  "register": {
    "title": "Регистрация",
    "name": "Полное имя",
    "email": "Email",
    "password": "Пароль",
    "confirmPassword": "Подтвердите пароль",
    "button": "Создать аккаунт"
  }
}
```

## Форматирование и региональные особенности

### 1. Форматирование дат

```javascript
// Система форматирования дат
class DateFormatter {
  constructor(locale) {
    this.locale = locale;
    this.formatters = new Map();
    this.initializeFormatters();
  }
  
  initializeFormatters() {
    // Различные форматы дат
    this.formatters.set('short', new Intl.DateTimeFormat(this.locale, {
      day: 'numeric',
      month: 'short',
      year: 'numeric'
    }));
    
    this.formatters.set('long', new Intl.DateTimeFormat(this.locale, {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }));
    
    this.formatters.set('time', new Intl.DateTimeFormat(this.locale, {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }));
    
    this.formatters.set('datetime', new Intl.DateTimeFormat(this.locale, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }));
  }
  
  format(date, formatType = 'short') {
    const formatter = this.formatters.get(formatType);
    if (!formatter) {
      console.warn(`Unknown date format: ${formatType}`);
      return date.toString();
    }
    
    return formatter.format(new Date(date));
  }
  
  formatRelative(date) {
    const now = new Date();
    const diffMs = now - new Date(date);
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    const rtf = new Intl.RelativeTimeFormat(this.locale, { numeric: 'auto' });
    
    if (Math.abs(diffDays) < 1) {
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      if (Math.abs(diffHours) < 1) {
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        return rtf.format(diffMinutes, 'minute');
      }
      return rtf.format(diffHours, 'hour');
    }
    
    return rtf.format(diffDays, 'day');
  }
}

// Использование
const dateFormatter = new DateFormatter('ru');
console.log(dateFormatter.format(new Date(), 'long')); // "суббота, 15 июля 2023 г."
console.log(dateFormatter.formatRelative('2023-07-14')); // "вчера"
```

### 2. Форматирование чисел и валют

```javascript
// Система форматирования чисел и валют
class NumberFormatter {
  constructor(locale) {
    this.locale = locale;
  }
  
  formatNumber(number, options = {}) {
    return new Intl.NumberFormat(this.locale, options).format(number);
  }
  
  formatCurrency(amount, currency = 'USD', options = {}) {
    return new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency,
      ...options
    }).format(amount);
  }
  
  formatPercent(value, options = {}) {
    return new Intl.NumberFormat(this.locale, {
      style: 'percent',
      ...options
    }).format(value);
  }
  
  formatUnit(value, unit, options = {}) {
    return new Intl.NumberFormat(this.locale, {
      style: 'unit',
      unit,
      ...options
    }).format(value);
  }
}

// Использование
const numberFormatter = new NumberFormatter('ru');

console.log(numberFormatter.formatNumber(1234567.89)); // "1 234 567,89"
console.log(numberFormatter.formatCurrency(1234.56, 'RUB')); // "1 234,56 ₽"
console.log(numberFormatter.formatPercent(0.15)); // "15%"
console.log(numberFormatter.formatUnit(5, 'kilogram')); // "5 кг"
```

### 3. Плюрализация

```javascript
// Система плюрализации
class Pluralization {
  constructor(locale) {
    this.locale = locale;
    this.pluralRules = new Intl.PluralRules(locale);
  }
  
  // Простая плюрализация
  pluralize(count, forms) {
    const rule = this.pluralRules.select(count);
    
    // forms должен быть объектом с ключами: zero, one, two, few, many, other
    return forms[rule] || forms.other || forms.one;
  }
  
  // Плюрализация с переводами
  tPlural(key, count, params = {}) {
    const baseTranslation = i18n.t(key);
    
    // Если перевод содержит формы, разделяем их
    if (typeof baseTranslation === 'object') {
      const rule = this.pluralRules.select(count);
      const translation = baseTranslation[rule] || baseTranslation.other;
      
      return i18n.interpolate(translation, { ...params, count });
    }
    
    // Если простой перевод, используем его
    return i18n.interpolate(baseTranslation, { ...params, count });
  }
}

// Файлы переводов с плюрализацией
// locales/en.json
{
  "items": {
    "one": "{count} item",
    "other": "{count} items"
  },
  "messages": {
    "one": "You have {count} new message",
    "other": "You have {count} new messages"
  }
}

// locales/ru.json
{
  "items": {
    "one": "{count} элемент",
    "few": "{count} элемента",
    "many": "{count} элементов",
    "other": "{count} элемента"
  },
  "messages": {
    "one": "У вас {count} новое сообщение",
    "few": "У вас {count} новых сообщения",
    "many": "У вас {count} новых сообщений",
    "other": "У вас {count} нового сообщения"
  }
}

// Использование
const plural = new Pluralization('ru');

console.log(plural.tPlural('items', 1, { count: 1 })); // "1 элемент"
console.log(plural.tPlural('items', 3, { count: 3 })); // "3 элемента"
console.log(plural.tPlural('items', 5, { count: 5 })); // "5 элементов"
```

## Интеграция с фреймворками

### 1. React i18n

```javascript
// React Context для i18n
import React, { createContext, useContext, useState, useEffect } from 'react';

const I18nContext = createContext();

export function I18nProvider({ children, defaultLocale = 'en' }) {
  const [locale, setLocale] = useState(defaultLocale);
  const [translations, setTranslations] = useState({});
  
  useEffect(() => {
    loadTranslations(locale);
  }, [locale]);
  
  const loadTranslations = async (locale) => {
    try {
      const module = await import(`../locales/${locale}.json`);
      setTranslations(module.default);
    } catch (error) {
      console.error(`Failed to load translations for ${locale}:`, error);
    }
  };
  
  const t = (key, params = {}) => {
    const translation = getNestedValue(translations, key);
    if (!translation) {
      console.warn(`Missing translation for key: ${key}`);
      return key;
    }
    
    return interpolate(translation, params);
  };
  
  const getNestedValue = (obj, key) => {
    return key.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : null, obj);
  };
  
  const interpolate = (template, params) => {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== undefined ? params[key] : match;
    });
  };
  
  return (
    <I18nContext.Provider value={{ locale, setLocale, t }}>
      {children}
    </I18nContext.Provider>
  );
}

export function useI18n() {
  const context = useContext(I18nContext);
  if (!context) {
    throw new Error('useI18n must be used within an I18nProvider');
  }
  return context;
}

// Компонент для перевода
export function Trans({ id, params = {}, children }) {
  const { t } = useI18n();
  return t(id, params) || children;
}

// Компонент выбора языка
export function LanguageSwitcher() {
  const { locale, setLocale } = useI18n();
  
  const languages = [
    { code: 'en', name: 'English' },
    { code: 'ru', name: 'Русский' },
    { code: 'es', name: 'Español' }
  ];
  
  return (
    <select value={locale} onChange={(e) => setLocale(e.target.value)}>
      {languages.map(lang => (
        <option key={lang.code} value={lang.code}>
          {lang.name}
        </option>
      ))}
    </select>
  );
}

// Использование в компоненте
function UserProfile({ user }) {
  const { t } = useI18n();
  
  return (
    <div>
      <h1>{t('user.profile.title')}</h1>
      <p>{t('user.profile.welcome', { name: user.name })}</p>
      <LanguageSwitcher />
    </div>
  );
}
```

### 2. Vue i18n

```javascript
// Vue 3 Composition API для i18n
import { ref, computed, provide, inject } from 'vue';

// Создание i18n composable
export function createI18n(defaultLocale = 'en') {
  const locale = ref(defaultLocale);
  const translations = ref({});
  
  const loadTranslations = async (localeCode) => {
    try {
      const module = await import(`../locales/${localeCode}.json`);
      translations.value[localeCode] = module.default;
    } catch (error) {
      console.error(`Failed to load translations for ${localeCode}:`, error);
    }
  };
  
  const setLocale = async (localeCode) => {
    if (!translations.value[localeCode]) {
      await loadTranslations(localeCode);
    }
    locale.value = localeCode;
  };
  
  const t = (key, params = {}) => {
    const translation = getNestedValue(
      translations.value[locale.value] || {}, 
      key
    );
    
    if (!translation) {
      console.warn(`Missing translation for key: ${key}`);
      return key;
    }
    
    return interpolate(translation, params);
  };
  
  const getNestedValue = (obj, key) => {
    return key.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : null, obj);
  };
  
  const interpolate = (template, params) => {
    return template.replace(/\{(\w+)\}/g, (match, key) => {
      return params[key] !== undefined ? params[key] : match;
    });
  };
  
  // Загрузка начальных переводов
  loadTranslations(defaultLocale);
  
  return {
    locale: computed(() => locale.value),
    setLocale,
    t
  };
}

// Плагин для Vue
export const i18nPlugin = {
  install(app, options = {}) {
    const i18n = createI18n(options.locale || 'en');
    app.config.globalProperties.$t = i18n.t;
    app.provide('i18n', i18n);
  }
};

// Composable для использования в компонентах
export function useI18n() {
  const i18n = inject('i18n');
  if (!i18n) {
    throw new Error('useI18n must be used within i18n plugin');
  }
  return i18n;
}

// Использование в компоненте
export default {
  setup() {
    const { t, locale, setLocale } = useI18n();
    
    const languages = [
      { code: 'en', name: 'English' },
      { code: 'ru', name: 'Русский' }
    ];
    
    return {
      t,
      locale,
      setLocale,
      languages
    };
  },
  
  template: `
    <div>
      <h1>{{ t('welcome.message') }}</h1>
      <select :value="locale" @change="setLocale($event.target.value)">
        <option v-for="lang in languages" :key="lang.code" :value="lang.code">
          {{ lang.name }}
        </option>
      </select>
    </div>
  `
};
```

## Управление переводами

### 1. Система управления переводами

```javascript
// Система управления переводами
class TranslationManager {
  constructor() {
    this.translations = {};
    this.missingKeys = new Set();
    this.unusedKeys = new Set();
  }
  
  // Загрузка переводов из файлов
  async loadFromFiles(localesDir) {
    const fs = require('fs').promises;
    const path = require('path');
    
    try {
      const files = await fs.readdir(localesDir);
      for (const file of files) {
        if (file.endsWith('.json')) {
          const locale = path.basename(file, '.json');
          const content = await fs.readFile(path.join(localesDir, file), 'utf8');
          this.translations[locale] = JSON.parse(content);
        }
      }
    } catch (error) {
      console.error('Failed to load translations:', error);
    }
  }
  
  // Поиск отсутствующих ключей
  findMissingKeys() {
    const locales = Object.keys(this.translations);
    if (locales.length < 2) return [];
    
    const referenceLocale = locales[0];
    const referenceKeys = this.getAllKeys(this.translations[referenceLocale]);
    
    const missing = [];
    
    for (let i = 1; i < locales.length; i++) {
      const locale = locales[i];
      const localeKeys = this.getAllKeys(this.translations[locale]);
      
      for (const key of referenceKeys) {
        if (!localeKeys.includes(key)) {
          missing.push({ locale, key });
        }
      }
    }
    
    return missing;
  }
  
  // Получение всех ключей из объекта
  getAllKeys(obj, prefix = '') {
    const keys = [];
    
    for (const [key, value] of Object.entries(obj)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      
      if (typeof value === 'object' && value !== null) {
        keys.push(...this.getAllKeys(value, fullKey));
      } else {
        keys.push(fullKey);
      }
    }
    
    return keys;
  }
  
  // Экспорт для переводчиков
  exportForTranslation(locale, format = 'json') {
    const translations = this.translations[locale] || {};
    
    switch (format) {
      case 'json':
        return JSON.stringify(translations, null, 2);
      
      case 'csv':
        return this.toCSV(translations);
      
      case 'xliff':
        return this.toXLIFF(translations, locale);
      
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  
  // Преобразование в CSV
  toCSV(translations) {
    const keys = this.getAllKeys(translations);
    let csv = 'Key,Source,Translation\n';
    
    for (const key of keys) {
      const value = this.getNestedValue(translations, key);
      csv += `"${key}","${value}",""\n`;
    }
    
    return csv;
  }
  
  // Преобразование в XLIFF
  toXLIFF(translations, locale) {
    const keys = this.getAllKeys(translations);
    let xliff = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    xliff += `<xliff version="1.2">\n`;
    xliff += `  <file source-language="en" target-language="${locale}">\n`;
    xliff += `    <body>\n`;
    
    for (const key of keys) {
      const value = this.getNestedValue(translations, key);
      xliff += `      <trans-unit id="${key}">\n`;
      xliff += `        <source>${value}</source>\n`;
      xliff += `        <target></target>\n`;
      xliff += `      </trans-unit>\n`;
    }
    
    xliff += `    </body>\n`;
    xliff += `  </file>\n`;
    xliff += `</xliff>`;
    
    return xliff;
  }
  
  // Импорт переводов
  importTranslations(locale, data, format = 'json') {
    switch (format) {
      case 'json':
        this.translations[locale] = JSON.parse(data);
        break;
      
      case 'csv':
        this.translations[locale] = this.fromCSV(data);
        break;
      
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  
  // Преобразование из CSV
  fromCSV(csv) {
    const lines = csv.trim().split('\n');
    const translations = {};
    
    // Пропускаем заголовок
    for (let i = 1; i < lines.length; i++) {
      const [key, source, translation] = lines[i].split(',');
      if (key && translation) {
        this.setNestedValue(translations, key, translation.replace(/"/g, ''));
      }
    }
    
    return translations;
  }
  
  // Установка вложенного значения
  setNestedValue(obj, key, value) {
    const keys = key.split('.');
    let current = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      if (!current[keys[i]]) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }
    
    current[keys[keys.length - 1]] = value;
  }
  
  // Получение вложенного значения
  getNestedValue(obj, key) {
    return key.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : null, obj);
  }
}

// Использование
const translationManager = new TranslationManager();
await translationManager.loadFromFiles('./locales');

// Поиск отсутствующих переводов
const missing = translationManager.findMissingKeys();
console.log('Missing translations:', missing);

// Экспорт для переводчиков
const csv = translationManager.exportForTranslation('ru', 'csv');
// Сохраняем в файл для переводчиков
```

## Тестирование интернационализации

### 1. Модульные тесты

```javascript
// Тесты для i18n системы
import { I18nManager } from './i18n';

describe('I18nManager', () => {
  let i18n;
  
  beforeEach(() => {
    i18n = new I18nManager();
    i18n.translations = {
      en: {
        'welcome': 'Welcome',
        'user.greeting': 'Hello, {name}!',
        'items.count': '{count} items'
      },
      ru: {
        'welcome': 'Добро пожаловать',
        'user.greeting': 'Привет, {name}!',
        'items.count': '{count} элементов'
      }
    };
    i18n.currentLocale = 'en';
  });
  
  test('should translate simple keys', () => {
    expect(i18n.t('welcome')).toBe('Welcome');
  });
  
  test('should translate with parameters', () => {
    expect(i18n.t('user.greeting', { name: 'John' })).toBe('Hello, John!');
  });
  
  test('should handle missing translations', () => {
    expect(i18n.t('missing.key')).toBe('missing.key');
  });
  
  test('should switch locales', async () => {
    await i18n.setLocale('ru');
    expect(i18n.t('welcome')).toBe('Добро пожаловать');
  });
  
  test('should use fallback locale', async () => {
    i18n.fallbackLocale = 'en';
    await i18n.setLocale('fr'); // Локаль без переводов
    expect(i18n.t('welcome')).toBe('Welcome'); // Используем fallback
  });
});
```

### 2. Тесты плюрализации

```javascript
// Тесты плюрализации
import { Pluralization } from './pluralization';

describe('Pluralization', () => {
  test('should handle English pluralization', () => {
    const plural = new Pluralization('en');
    
    const forms = {
      one: 'item',
      other: 'items'
    };
    
    expect(plural.pluralize(1, forms)).toBe('item');
    expect(plural.pluralize(2, forms)).toBe('items');
    expect(plural.pluralize(0, forms)).toBe('items');
  });
  
  test('should handle Russian pluralization', () => {
    const plural = new Pluralization('ru');
    
    const forms = {
      one: 'элемент',
      few: 'элемента',
      many: 'элементов',
      other: 'элемента'
    };
    
    expect(plural.pluralize(1, forms)).toBe('элемент');
    expect(plural.pluralize(2, forms)).toBe('элемента');
    expect(plural.pluralize(5, forms)).toBe('элементов');
    expect(plural.pluralize(21, forms)).toBe('элемент');
  });
});
```

## Лучшие практики

### 1. Структурирование ключей

```javascript
// Хорошая структура ключей
const goodKeys = {
  // По модулям
  'auth.login.title': 'Login',
  'auth.login.button': 'Sign In',
  'auth.register.title': 'Register',
  
  // По компонентам
  'components.button.submit': 'Submit',
  'components.modal.close': 'Close',
  
  // По функциональности
  'validation.required': 'This field is required',
  'validation.email': 'Please enter a valid email',
  
  // С параметрами
  'user.welcome': 'Welcome, {name}!',
  'items.selected': '{count} items selected'
};

// Плохая структура ключей
const badKeys = {
  'login': 'Login',
  'register': 'Register',
  'button1': 'Submit',
  'button2': 'Close',
  'error1': 'This field is required'
};
```

### 2. Обработка контекста

```javascript
// Учет контекста в переводах
const contextTranslations = {
  en: {
    // Разные значения для разных контекстов
    'file': {
      'one': 'file',
      'other': 'files'
    },
    'noun.file': 'file',      // Существительное
    'verb.file': 'to file',   // Глагол
    'button.file': 'File',    // Кнопка
    
    // Пол и возраст
    'user.profile': {
      'male': 'His profile',
      'female': 'Her profile',
      'other': 'Their profile'
    }
  },
  ru: {
    'file': {
      'one': 'файл',
      'few': 'файла',
      'many': 'файлов',
      'other': 'файла'
    },
    'noun.file': 'файл',
    'verb.file': 'отправить',
    'button.file': 'Файл',
    
    'user.profile': {
      'male': 'Его профиль',
      'female': 'Ее профиль',
      'other': 'Их профиль'
    }
  }
};
```

### 3. Производительность

```javascript
// Оптимизация производительности i18n
class OptimizedI18n {
  constructor() {
    this.translations = {};
    this.cache = new Map(); // Кэш скомпилированных шаблонов
    this.currentLocale = 'en';
  }
  
  // Компиляция шаблона для быстрого выполнения
  compileTemplate(template) {
    if (this.cache.has(template)) {
      return this.cache.get(template);
    }
    
    // Компиляция шаблона в функцию
    const fn = new Function('params', `
      let result = \`${template.replace(/\{(\w+)\}/g, '${params.$1 || "$&"}')}\`;
      return result;
    `);
    
    this.cache.set(template, fn);
    return fn;
  }
  
  // Быстрый перевод
  t(key, params = {}) {
    const translation = this.getTranslation(key);
    if (!translation) return key;
    
    // Используем скомпилированный шаблон
    const templateFn = this.compileTemplate(translation);
    return templateFn(params);
  }
  
  // Предзагрузка переводов
  async preloadLocales(locales) {
    const promises = locales.map(locale => this.loadTranslations(locale));
    await Promise.all(promises);
  }
  
  // Ленивая загрузка
  async loadTranslations(locale) {
    // Используем динамический импорт для code splitting
    const module = await import(`../locales/${locale}.json`);
    this.translations[locale] = module.default;
  }
}
```

## Архитектура интернационализации и компоненты

### Интеграция с компонентной архитектурой
- Использование хуков для получения переводов
- Поддержка динамических переводов
- Обработка изменений локали в компонентах

## Архитектура интернационализации и API

### Локализованные API
- Поддержка разных языков в API
- Форматирование данных по локали
- Трансляция интерфейса в зависимости от языка API

## Архитектура интернационализации и тестирование

### Тестирование i18n
- Тестирование разных локалей
- Проверка плюрализации
- Тестирование форматирования данных
- Проверка контекстных переводов

## Архитектура интернационализации и безопасность

### Безопасность в i18n
- Санитизация переводов
- Защита от XSS в переводах
- Права доступа к переводам
- Защита конфиденциальных данных в переводах

## Архитектура интернационализации и производительность

### Производительность i18n
- Оптимизация загрузки переводов
- Кэширование переводов
- Ленивая загрузка переводов
- Эффективное форматирование данных

## Связанные концепции

- [[../frontend/unified-frontend-architecture]] - общая архитектура фронтенда
- [[../frontend/unified-component-architecture]] - компонентная архитектура
- [[../api/unified-api-integration-architecture]] - архитектура API интеграций
- [[../performance/unified-performance-architecture]] - архитектура производительности
- [[../testing/unified-testing-architecture]] - архитектура тестирования
- [[../security/unified-security-architecture]] - архитектура безопасности
- [[../observability/unified-observability-architecture]] - архитектура наблюдаемости
- [[../documentation/unified-documentation-architecture]] - архитектура документации
- [[../devops/unified-cicd-architecture]] - архитектура CI/CD
- [[unified-accessibility-architecture]] - архитектура доступности

## Теги

#i18n #l10n #internationalization #localization #frontend #architecture #globalization #accessibility #user-experience #translation #locales #pluralization #date-formatting #number-formatting #currency-formatting #react-i18n #vue-i18n #angular-i18n #internationalization-architecture #localization-architecture #internationalization-patterns #localization-patterns #internationalization-best-practices #localization-best-practices #internationalization-tools #localization-tools #internationalization-processes #localization-processes #internationalization-standards #localization-standards #internationalization-quality #localization-quality #internationalization-metrics #localization-metrics #internationalization-monitoring #localization-monitoring #internationalization-observability #localization-observability #internationalization-testing #localization-testing #internationalization-security #localization-security #internationalization-performance #localization-performance #internationalization-scalability #localization-scalability #internationalization-maintainability #localization-maintainability #internationalization-usability #localization-usability #internationalization-reliability #localization-reliability #internationalization-efficiency #localization-efficiency #internationalization-portability #localization-portability #internationalization-interoperability #localization-interoperability #internationalization-architecture-patterns #localization-architecture-design #internationalization-architecture-principles #localization-architecture-components #internationalization-architecture-layers #localization-architecture-styles #internationalization-architecture-methodologies #localization-architecture-frameworks #internationalization-architecture-tools #localization-architecture-processes #internationalization-architecture-teams #localization-architecture-governance #internationalization-architecture-compliance #localization-architecture-quality #internationalization-architecture-metrics #localization-architecture-monitoring #internationalization-architecture-observability #localization-architecture-testing #internationalization-architecture-security #localization-architecture-performance #internationalization-architecture-scalability #localization-architecture-maintainability #internationalization-architecture-usability #localization-architecture-reliability #internationalization-architecture-efficiency #localization-architecture-portability #internationalization-architecture-interoperability