# Архитектура Кэширования

Архитектура кэширования — это совокупность принципов, паттернов и практик, определяющих эффективное использование кэширования в веб-приложениях для повышения производительности, уменьшения нагрузки на серверы и улучшения пользовательского опыта. Хорошо спроектированная архитектура кэширования является критическим фактором для создания быстрых и масштабируемых приложений.

## Что такое Кэширование

Кэширование — это процесс временного хранения данных в быстродоступном хранилище для ускорения последующего доступа к этим данным. В контексте frontend разработки кэширование позволяет избежать повторных запросов к серверу и повторных вычислений, что значительно улучшает производительность приложения.

## Типы Кэширования

### 1. Кэширование на Стороне Клиента

Хранение данных в браузере пользователя.

#### HTTP Кэширование
```javascript
// Настройка заголовков для HTTP кэширования
app.get('/api/data', (req, res) => {
  // Установка заголовков кэширования
  res.set({
    'Cache-Control': 'public, max-age=3600', // Кэшировать на 1 час
    'ETag': generateETag(data), // Генерация ETag
    'Last-Modified': new Date().toUTCString()
  });
  
  res.json(data);
});

// Проверка ETag
app.get('/api/data', (req, res) => {
  const etag = generateETag(data);
  
  if (req.headers['if-none-match'] === etag) {
    // Данные не изменились
    return res.status(304).end();
  }
  
  res.set({
    'ETag': etag,
    'Cache-Control': 'public, max-age=3600'
  });
  
  res.json(data);
});
```

#### Browser Storage Кэширование
```javascript
// Кэширование в localStorage
class LocalStorageCache {
  static set(key, value, ttl = 3600000) { // TTL по умолчанию 1 час
    const item = {
      value: value,
      expiry: Date.now() + ttl,
    };
    localStorage.setItem(key, JSON.stringify(item));
  }
  
  static get(key) {
    const itemStr = localStorage.getItem(key);
    if (!itemStr) {
      return null;
    }
    
    const item = JSON.parse(itemStr);
    if (Date.now() > item.expiry) {
      // Истекло время жизни
      localStorage.removeItem(key);
      return null;
    }
    
    return item.value;
  }
  
  static remove(key) {
    localStorage.removeItem(key);
  }
  
  static clear() {
    localStorage.clear();
  }
}

// Использование
LocalStorageCache.set('userData', userData, 1800000); // 30 минут
const cachedData = LocalStorageCache.get('userData');
```

#### SessionStorage Кэширование
```javascript
// Кэширование в sessionStorage (данные живут до закрытия вкладки)
class SessionCache {
  static set(key, value) {
    sessionStorage.setItem(key, JSON.stringify(value));
  }
  
  static get(key) {
    const item = sessionStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }
  
  static remove(key) {
    sessionStorage.removeItem(key);
  }
}

// Использование
SessionCache.set('formDraft', formData);
const draft = SessionCache.get('formDraft');
```

### 2. Кэширование в Памяти

Хранение данных в оперативной памяти браузера.

#### In-Memory Cache
```javascript
// Простой кэш в памяти
class MemoryCache {
  constructor() {
    this.cache = new Map();
    this.timeouts = new Map();
  }
  
  set(key, value, ttl = 300000) { // TTL по умолчанию 5 минут
    this.cache.set(key, value);
    
    // Очистка предыдущего таймера
    if (this.timeouts.has(key)) {
      clearTimeout(this.timeouts.get(key));
    }
    
    // Установка нового таймера для автоматической очистки
    const timeout = setTimeout(() => {
      this.cache.delete(key);
      this.timeouts.delete(key);
    }, ttl);
    
    this.timeouts.set(key, timeout);
  }
  
  get(key) {
    return this.cache.get(key);
  }
  
  has(key) {
    return this.cache.has(key);
  }
  
  delete(key) {
    if (this.timeouts.has(key)) {
      clearTimeout(this.timeouts.get(key));
      this.timeouts.delete(key);
    }
    return this.cache.delete(key);
  }
  
  clear() {
    // Очистка всех таймеров
    for (const timeout of this.timeouts.values()) {
      clearTimeout(timeout);
    }
    this.timeouts.clear();
    this.cache.clear();
  }
}

// Использование
const cache = new MemoryCache();
cache.set('apiResponse', data, 600000); // 10 минут
const cachedData = cache.get('apiResponse');
```

### 3. Кэширование на Стороне Сервера

Хранение данных на сервере для уменьшения нагрузки на базу данных.

#### Redis-like Cache
```javascript
// Имитация Redis-подобного кэша
class RedisCache {
  constructor() {
    this.store = new Map();
  }
  
  async set(key, value, options = {}) {
    const item = {
      value,
      createdAt: Date.now(),
      ttl: options.EX ? options.EX * 1000 : null // EX в секундах
    };
    
    this.store.set(key, item);
    
    // Автоматическое удаление по истечении TTL
    if (item.ttl) {
      setTimeout(() => {
        if (this.store.get(key)?.createdAt === item.createdAt) {
          this.store.delete(key);
        }
      }, item.ttl);
    }
  }
  
  async get(key) {
    const item = this.store.get(key);
    if (!item) return null;
    
    // Проверка истечения TTL
    if (item.ttl && Date.now() - item.createdAt > item.ttl) {
      this.store.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  async del(key) {
    return this.store.delete(key);
  }
  
  async exists(key) {
    return this.store.has(key);
  }
  
  async expire(key, seconds) {
    const item = this.store.get(key);
    if (item) {
      item.ttl = seconds * 1000;
      setTimeout(() => {
        this.store.delete(key);
      }, item.ttl);
      return 1;
    }
    return 0;
  }
}

// Использование
const cache = new RedisCache();
await cache.set('user:123', userData, { EX: 3600 }); // 1 час
const user = await cache.get('user:123');
```

## Стратегии Кэширования

### 1. Write-Through Caching

Данные записываются одновременно в кэш и в основное хранилище.

```javascript
// Write-Through кэширование
class WriteThroughCache {
  constructor(mainStorage, cache) {
    this.mainStorage = mainStorage;
    this.cache = cache;
  }
  
  async set(key, value) {
    // Сначала записываем в основное хранилище
    await this.mainStorage.set(key, value);
    
    // Затем в кэш
    await this.cache.set(key, value);
  }
  
  async get(key) {
    // Проверяем кэш
    let value = await this.cache.get(key);
    
    if (value === null) {
      // Если нет в кэше, берем из основного хранилища
      value = await this.mainStorage.get(key);
      
      // И сохраняем в кэш для следующих запросов
      if (value !== null) {
        await this.cache.set(key, value);
      }
    }
    
    return value;
  }
}
```

### 2. Write-Behind Caching

Данные сначала записываются в кэш, а затем асинхронно в основное хранилище.

```javascript
// Write-Behind кэширование
class WriteBehindCache {
  constructor(mainStorage, cache) {
    this.mainStorage = mainStorage;
    this.cache = cache;
    this.writeQueue = new Map();
    this.flushInterval = setInterval(() => this.flush(), 5000); // Флаш каждые 5 секунд
  }
  
  async set(key, value) {
    // Записываем в кэш немедленно
    await this.cache.set(key, value);
    
    // Добавляем в очередь для отложенной записи
    this.writeQueue.set(key, value);
  }
  
  async get(key) {
    return await this.cache.get(key);
  }
  
  async flush() {
    // Асинхронная запись из очереди в основное хранилище
    for (const [key, value] of this.writeQueue.entries()) {
      try {
        await this.mainStorage.set(key, value);
        this.writeQueue.delete(key);
      } catch (error) {
        console.error(`Failed to flush ${key}:`, error);
        // Оставляем в очереди для повторной попытки
      }
    }
  }
  
  stop() {
    clearInterval(this.flushInterval);
    this.flush(); // Финальный флаш
  }
}
```

### 3. Read-Through Caching

Если данные отсутствуют в кэше, они автоматически загружаются из основного хранилища.

```javascript
// Read-Through кэширование
class ReadThroughCache {
  constructor(loader, cache) {
    this.loader = loader;
    this.cache = cache;
  }
  
  async get(key) {
    // Проверяем кэш
    let value = await this.cache.get(key);
    
    if (value === null) {
      // Если нет в кэше, загружаем из источника
      value = await this.loader(key);
      
      // Сохраняем в кэш
      if (value !== null) {
        await this.cache.set(key, value);
      }
    }
    
    return value;
  }
}

// Использование
const userLoader = async (userId) => {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
};

const cache = new MemoryCache();
const readThroughCache = new ReadThroughCache(userLoader, cache);

const user = await readThroughCache.get('user:123');
```

## Паттерны Кэширования

### 1. Cache-Aside Pattern

Приложение отвечает за загрузку данных в кэш и удаление устаревших данных.

```javascript
// Cache-Aside паттерн
class CacheAsidePattern {
  constructor(apiClient, cache) {
    this.apiClient = apiClient;
    this.cache = cache;
  }
  
  async getData(key) {
    // Сначала проверяем кэш
    let data = this.cache.get(key);
    
    if (!data) {
      // Если нет в кэше, загружаем из API
      data = await this.apiClient.get(key);
      
      // Сохраняем в кэш
      this.cache.set(key, data);
    }
    
    return data;
  }
  
  async updateData(key, newData) {
    // Обновляем данные в API
    await this.apiClient.put(key, newData);
    
    // Обновляем кэш
    this.cache.set(key, newData);
  }
  
  async deleteData(key) {
    // Удаляем данные из API
    await this.apiClient.delete(key);
    
    // Удаляем из кэша
    this.cache.delete(key);
  }
}
```

### 2. Refresh-Ahead Pattern

Предварительное обновление данных в кэше до их истечения.

```javascript
// Refresh-Ahead паттерн
class RefreshAheadCache {
  constructor(loader, cache, ttl = 300000) { // 5 минут по умолчанию
    this.loader = loader;
    this.cache = cache;
    this.ttl = ttl;
    this.refreshThreshold = ttl * 0.2; // Обновлять за 20% до истечения
    this.refreshTimers = new Map();
  }
  
  async get(key) {
    let item = this.cache.get(key);
    
    if (!item) {
      // Загружаем данные, если их нет
      const value = await this.loader(key);
      item = {
        value,
        loadedAt: Date.now()
      };
      this.cache.set(key, item, this.ttl);
      this.scheduleRefresh(key);
    }
    
    return item.value;
  }
  
  scheduleRefresh(key) {
    // Отменяем предыдущий таймер
    if (this.refreshTimers.has(key)) {
      clearTimeout(this.refreshTimers.get(key));
    }
    
    // Планируем обновление
    const timer = setTimeout(async () => {
      try {
        const value = await this.loader(key);
        const item = {
          value,
          loadedAt: Date.now()
        };
        this.cache.set(key, item, this.ttl);
        this.scheduleRefresh(key); // Планируем следующее обновление
      } catch (error) {
        console.error(`Failed to refresh ${key}:`, error);
      }
    }, this.ttl - this.refreshThreshold);
    
    this.refreshTimers.set(key, timer);
  }
  
  clear() {
    for (const timer of this.refreshTimers.values()) {
      clearTimeout(timer);
    }
    this.refreshTimers.clear();
    this.cache.clear();
  }
}
```

### 3. Multi-Level Caching

Использование нескольких уровней кэширования для оптимизации доступа.

```javascript
// Многоуровневое кэширование
class MultiLevelCache {
  constructor(levels) {
    // levels - массив кэшей в порядке приоритета (от быстрого к медленному)
    this.levels = levels;
  }
  
  async get(key) {
    // Проверяем каждый уровень кэша
    for (let i = 0; i < this.levels.length; i++) {
      const value = await this.levels[i].get(key);
      if (value !== null) {
        // Если найдено, поднимаем значение в более быстрые кэши
        for (let j = 0; j < i; j++) {
          await this.levels[j].set(key, value);
        }
        return value;
      }
    }
    
    return null;
  }
  
  async set(key, value, ttl) {
    // Записываем во все уровни кэша
    for (const level of this.levels) {
      await level.set(key, value, ttl);
    }
  }
  
  async delete(key) {
    // Удаляем из всех уровней кэша
    for (const level of this.levels) {
      await level.delete(key);
    }
  }
}

// Использование
const memoryCache = new MemoryCache(); // Быстрый, но маленький
const localStorageCache = new LocalStorageCache(); // Медленнее, но больше места

const multiCache = new MultiLevelCache([
  memoryCache,
  localStorageCache
]);
```

## Инвалидация Кэша

### 1. По Времени (TTL)

```javascript
// TTL-базированная инвалидация
class TTLCache {
  constructor(defaultTTL = 300000) { // 5 минут по умолчанию
    this.cache = new Map();
    this.defaultTTL = defaultTTL;
  }
  
  set(key, value, ttl = this.defaultTTL) {
    const expiry = Date.now() + ttl;
    this.cache.set(key, { value, expiry });
    
    // Автоматическое удаление по истечении TTL
    setTimeout(() => {
      const item = this.cache.get(key);
      if (item && item.expiry <= Date.now()) {
        this.cache.delete(key);
      }
    }, ttl);
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
}
```

### 2. По Событиям

```javascript
// Событийная инвалидация
class EventBasedCache {
  constructor() {
    this.cache = new Map();
    this.eventListeners = new Map();
  }
  
  set(key, value, tags = []) {
    this.cache.set(key, {
      value,
      tags: new Set(tags),
      createdAt: Date.now()
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    return item ? item.value : null;
  }
  
  // Инвалидация по тегам
  invalidateByTag(tag) {
    for (const [key, item] of this.cache.entries()) {
      if (item.tags.has(tag)) {
        this.cache.delete(key);
      }
    }
  }
  
  // Инвалидация по ключу
  invalidate(key) {
    this.cache.delete(key);
  }
  
  // Инвалидация по шаблону
  invalidateByPattern(pattern) {
    const regex = new RegExp(pattern);
    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key);
      }
    }
  }
}

// Использование
const cache = new EventBasedCache();
cache.set('user:123', userData, ['user', 'profile']);
cache.set('user:123:posts', userPosts, ['user', 'posts']);

// При обновлении профиля пользователя
// Инвалидируем все данные, связанные с пользователем
cache.invalidateByTag('user');
```

### 3. По Зависимостям

```javascript
// Инвалидация по зависимостям
class DependencyBasedCache {
  constructor() {
    this.cache = new Map();
    this.dependencies = new Map(); // key -> Set of dependent keys
  }
  
  set(key, value, dependencies = []) {
    this.cache.set(key, value);
    
    // Регистрируем зависимости
    for (const dep of dependencies) {
      if (!this.dependencies.has(dep)) {
        this.dependencies.set(dep, new Set());
      }
      this.dependencies.get(dep).add(key);
    }
  }
  
  get(key) {
    return this.cache.get(key);
  }
  
  // Инвалидация ключа и всех зависимых ключей
  invalidate(key) {
    // Удаляем сам ключ
    this.cache.delete(key);
    
    // Удаляем все зависимые ключи
    const dependents = this.dependencies.get(key);
    if (dependents) {
      for (const dependent of dependents) {
        this.invalidate(dependent);
      }
      this.dependencies.delete(key);
    }
  }
}

// Использование
const cache = new DependencyBasedCache();
cache.set('user:123', userData);
cache.set('user:123:profile', userProfile, ['user:123']);
cache.set('user:123:posts', userPosts, ['user:123']);

// При обновлении пользователя инвалидируем все зависимые данные
cache.invalidate('user:123'); // Удаляет и user:123:profile, и user:123:posts
```

## Кэширование в Современных Фреймворках

### 1. React Кэширование

```javascript
// React Query для кэширования данных
import { useQuery, useQueryClient } from 'react-query';

function UserProfile({ userId }) {
  const queryClient = useQueryClient();
  
  const { data, isLoading, error } = useQuery(
    ['user', userId], // Ключ кэша
    () => fetchUser(userId),
    {
      staleTime: 5 * 60 * 1000, // 5 минут
      cacheTime: 10 * 60 * 1000, // 10 минут
    }
  );
  
  const updateUser = (newData) => {
    // Обновляем данные на сервере
    updateUserOnServer(userId, newData).then(() => {
      // Инвалидируем кэш
      queryClient.invalidateQueries(['user', userId]);
      
      // Или обновляем напрямую
      // queryClient.setQueryData(['user', userId], newData);
    });
  };
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>{data.name}</div>;
}
```

### 2. Vue Кэширование

```javascript
// Vuex с кэшированием
import { createStore } from 'vuex';

const store = createStore({
  state: {
    users: {},
    usersCache: {}
  },
  
  mutations: {
    SET_USER(state, { id, user }) {
      state.users[id] = user;
      state.usersCache[id] = Date.now();
    },
    
    CLEAR_USER_CACHE(state, id) {
      delete state.users[id];
      delete state.usersCache[id];
    }
  },
  
  actions: {
    async fetchUser({ state, commit }, id) {
      // Проверяем кэш
      const cachedAt = state.usersCache[id];
      if (cachedAt && Date.now() - cachedAt < 5 * 60 * 1000) { // 5 минут
        return state.users[id];
      }
      
      // Загружаем данные
      const user = await api.getUser(id);
      commit('SET_USER', { id, user });
      return user;
    }
  },
  
  getters: {
    getUser: (state) => (id) => {
      return state.users[id];
    }
  }
});
```

## Мониторинг и Оптимизация

### 1. Метрики Кэширования

```javascript
// Сбор метрик кэширования
class CacheMetrics {
  constructor() {
    this.hits = 0;
    this.misses = 0;
    this.hitRate = 0;
  }
  
  recordHit() {
    this.hits++;
    this.updateHitRate();
  }
  
  recordMiss() {
    this.misses++;
    this.updateHitRate();
  }
  
  updateHitRate() {
    const total = this.hits + this.misses;
    this.hitRate = total > 0 ? this.hits / total : 0;
  }
  
  getMetrics() {
    return {
      hits: this.hits,
      misses: this.misses,
      hitRate: this.hitRate,
      totalRequests: this.hits + this.misses
    };
  }
  
  reset() {
    this.hits = 0;
    this.misses = 0;
    this.hitRate = 0;
  }
}

// Использование
const metrics = new CacheMetrics();

class MonitoredCache {
  constructor(cache) {
    this.cache = cache;
    this.metrics = new CacheMetrics();
  }
  
  get(key) {
    const value = this.cache.get(key);
    if (value !== null) {
      this.metrics.recordHit();
    } else {
      this.metrics.recordMiss();
    }
    return value;
  }
  
  set(key, value) {
    return this.cache.set(key, value);
  }
  
  getHitRate() {
    return this.metrics.hitRate;
  }
  
  getMetrics() {
    return this.metrics.getMetrics();
  }
}
```

### 2. Оптимизация Размера Кэша

```javascript
// LRU (Least Recently Used) кэш
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (item) {
      // Перемещаем элемент в конец (самый свежий)
      this.cache.delete(key);
      this.cache.set(key, item);
      return item.value;
    }
    return null;
  }
  
  set(key, value) {
    // Если элемент уже существует, удаляем его
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Если кэш полон, удаляем самый старый элемент (первый в Map)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    // Добавляем новый элемент в конец
    this.cache.set(key, { value, timestamp: Date.now() });
  }
  
  delete(key) {
    return this.cache.delete(key);
  }
  
  clear() {
    this.cache.clear();
  }
  
  size() {
    return this.cache.size;
  }
}
```

## Лучшие Практики

### 1. Выбор Правильного TTL

```javascript
// Адаптивный TTL на основе типа данных
const CACHE_TTL = {
  'user-profile': 5 * 60 * 1000,      // 5 минут
  'static-content': 60 * 60 * 1000,   // 1 час
  'configuration': 30 * 60 * 1000,    // 30 минут
  'search-results': 10 * 60 * 1000,   // 10 минут
  'realtime-data': 30 * 1000          // 30 секунд
};

class AdaptiveCache {
  getTTL(key) {
    // Определяем TTL на основе ключа или типа данных
    for (const [pattern, ttl] of Object.entries(CACHE_TTL)) {
      if (key.includes(pattern)) {
        return ttl;
      }
    }
    return 5 * 60 * 1000; // Значение по умолчанию - 5 минут
  }
  
  set(key, value) {
    const ttl = this.getTTL(key);
    // Устанавливаем значение с соответствующим TTL
    super.set(key, value, ttl);
  }
}
```

### 2. Обработка Ошибок Кэширования

```javascript
// Устойчивое кэширование с обработкой ошибок
class ResilientCache {
  constructor(cache, fallbackStorage) {
    this.cache = cache;
    this.fallbackStorage = fallbackStorage; // Например, localStorage как fallback
  }
  
  async get(key) {
    try {
      // Пытаемся получить из основного кэша
      let value = await this.cache.get(key);
      
      if (value === null) {
        // Если нет в основном кэше, пробуем fallback
        value = this.getFromFallback(key);
      }
      
      return value;
    } catch (error) {
      console.warn('Cache get error, using fallback:', error);
      return this.getFromFallback(key);
    }
  }
  
  async set(key, value) {
    try {
      await this.cache.set(key, value);
      // Также сохраняем в fallback для надежности
      this.saveToFallback(key, value);
    } catch (error) {
      console.warn('Cache set error, using fallback:', error);
      this.saveToFallback(key, value);
    }
  }
  
  getFromFallback(key) {
    try {
      const item = localStorage.getItem(`cache_${key}`);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.warn('Fallback cache get error:', error);
      return null;
    }
  }
  
  saveToFallback(key, value) {
    try {
      localStorage.setItem(`cache_${key}`, JSON.stringify(value));
    } catch (error) {
      console.warn('Fallback cache set error:', error);
      // Очищаем старые данные, если localStorage переполнен
      if (error.name === 'QuotaExceededError') {
        this.clearFallback();
      }
    }
  }
  
  clearFallback() {
    try {
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('cache_')) {
          localStorage.removeItem(key);
        }
      });
    } catch (error) {
      console.warn('Failed to clear fallback cache:', error);
    }
  }
}
```

### 3. Тестирование Кэширования

```javascript
// Тесты для кэширования
describe('Cache', () => {
  let cache;
  
  beforeEach(() => {
    cache = new MemoryCache();
  });
  
  test('should cache and retrieve values', async () => {
    const key = 'test-key';
    const value = { data: 'test' };
    
    cache.set(key, value);
    const cachedValue = cache.get(key);
    
    expect(cachedValue).toEqual(value);
  });
  
  test('should expire cached values after TTL', async () => {
    const key = 'expiring-key';
    const value = 'test-value';
    
    cache.set(key, value, 100); // TTL 100ms
    
    // Значение должно быть доступно сразу
    expect(cache.get(key)).toEqual(value);
    
    // Ждем истечения TTL
    await new Promise(resolve => setTimeout(resolve, 150));
    
    // Значение должно быть недоступно
    expect(cache.get(key)).toBeNull();
  });
  
  test('should handle cache misses', async () => {
    const value = cache.get('non-existent-key');
    expect(value).toBeNull();
  });
});
```

## Связанные Концепции

- [[Архитектура]]
- [[Архитектура Производительности и Оптимизации]]
- [[Архитектура API и Интеграций]]
- [[State Management Архитектура]]
- [[Микро-фронтенды]]

## Теги

#caching #architecture #performance #frontend #optimization #memory-management #data-structures #web-performance