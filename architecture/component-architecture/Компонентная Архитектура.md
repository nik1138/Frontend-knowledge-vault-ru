# Компонентная Архитектура

Компонентная архитектура — это фундаментальный подход к построению пользовательских интерфейсов, при котором приложение разбивается на независимые, переиспользуемые блоки (компоненты), каждый из которых отвечает за определенную часть интерфейса и связанную с ней логику.

## Что такое Компонент

Компонент — это автономная единица пользовательского интерфейса, которая инкапсулирует:
- Визуальное представление (разметку)
- Состояние (данные)
- Поведение (логику)
- Стили

Компоненты могут быть простыми (например, кнопка) или сложными (например, форма с множеством полей и валидацией).

## Принципы Компонентной Архитектуры

### 1. Переиспользуемость

Компоненты должны быть спроектированы так, чтобы их можно было использовать в разных частях приложения или даже в разных приложениях. Это достигается через:
- Параметризацию (props)
- Гибкую настройку через слоты/children
- Четкое разделение внешнего API и внутренней реализации

### 2. Композиция

Сложные интерфейсы строятся путем комбинирования более простых компонентов. Это позволяет:
- Создавать иерархическую структуру приложения
- Управлять сложностью путем разбиения на более мелкие части
- Обеспечивать гибкость в изменении структуры интерфейса

### 3. Изолированность

Каждый компонент должен иметь четко определенные границы и минимальные зависимости от других компонентов. Это достигается через:
- Локальное состояние
- Четко определенные входные параметры (props)
- События для коммуникации с родительскими компонентами

### 4. Единообразие

Компоненты одного типа должны следовать общим паттернам и конвенциям, что облегчает их использование и понимание другими разработчиками.

## Типы Компонентов

### Презентационные Компоненты (Dumb/Presentational Components)

Эти компоненты отвечают только за отображение данных и не содержат бизнес-логики. Они получают данные через props и генерируют события для взаимодействия с пользователем.

Пример:
```javascript
// Button component
const Button = ({ text, onClick, disabled }) => (
  <button onClick={onClick} disabled={disabled}>
    {text}
  </button>
);
```

### Контейнерные Компоненты (Smart/Container Components)

Эти компоненты управляют состоянием и бизнес-логикой. Они могут содержать презентационные компоненты и передавать им данные через props.

Пример:
```javascript
// UserProfile component
const UserProfile = () => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser().then(setUser);
  }, []);
  
  return user ? <UserView user={user} /> : <Loading />;
};
```

### Higher-Order Components (HOC)

Функции, которые принимают компонент и возвращают новый компонент с дополнительной функциональностью.

Пример:
```javascript
const withAuth = (WrappedComponent) => {
  return (props) => {
    const isAuthenticated = useAuth();
    return isAuthenticated ? <WrappedComponent {...props} /> : <Login />;
  };
};
```

### Render Props

Паттерн, при котором компонент получает функцию в качестве props, которая определяет, что рендерить.

Пример:
```javascript
const DataProvider = ({ render }) => {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    fetchData().then(setData);
  }, []);
  
  return render(data);
};
```

## Лучшие Практики

### 1. Единая Ответственность

Каждый компонент должен иметь одну четко определенную ответственность. Если компонент делает слишком много, его следует разбить на более мелкие.

### 2. Четкое Именование

Имена компонентов должны ясно отражать их назначение и функциональность.

### 3. Типизация

Использование TypeScript или PropTypes для определения типов props помогает предотвратить ошибки и улучшает документацию.

### 4. Тестирование

Компоненты должны быть легко тестируемыми. Презентационные компоненты особенно хорошо подходят для unit-тестирования.

### 5. Документация

Каждый компонент должен иметь документацию, описывающую его API, примеры использования и возможные варианты.

## Паттерны Компонентной Архитектуры

### Compound Components

Паттерн, позволяющий компонентам работать вместе, разделяя общее состояние.

Пример:
```javascript
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState(0);
  
  return Children.map(children, child => 
    cloneElement(child, { activeTab, setActiveTab })
  );
};

const TabList = ({ children, activeTab, setActiveTab }) => (
  <div>
    {Children.map(children, (child, index) => 
      cloneElement(child, { 
        isActive: index === activeTab, 
        onClick: () => setActiveTab(index) 
      })
    )}
  </div>
);
```

### Render Callbacks

Паттерн, при котором компонент передает часть своего состояния обратно родительскому компоненту через функцию.

### State Reducer

Паттерн, позволяющий пользователю компонента переопределять поведение по умолчанию.

## Связанные Концепции

- [[Управление Состоянием]]
- [[Паттерны Проектирования]]
- [[React Архитектура]]
- [[Vue Компоненты]]

## Теги

#component-architecture #frontend #design-patterns #react #vue