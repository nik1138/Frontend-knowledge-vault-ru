---
aliases: [Управление состоянием, Состояние микрофронтендов]
tags: [state-management, frontend, micro-frontend, architecture]
---

# Управление состоянием в микро-фронтендах

## Общие принципы управления состоянием

Управление состоянием в архитектуре микро-фронтендов представляет собой сложную задачу, поскольку каждый микро-фронтенд может иметь собственное состояние, а также необходимость обмениваться данными между компонентами. Правильная архитектура состояния обеспечивает согласованность данных и предсказуемое поведение приложения.

## Типы состояния в микро-фронтендах

### 1. Локальное состояние

Локальное состояние принадлежит конкретному микро-фронтенду и не используется другими компонентами.

```javascript
// cart-mf.js
class CartMicroFrontend {
  constructor() {
    // Локальное состояние корзины
    this.localState = {
      items: [],
      isExpanded: false,
      discountApplied: false
    };
  }

  addItem(item) {
    this.localState.items.push(item);
    this.render();
  }

  toggleExpansion() {
    this.localState.isExpanded = !this.localState.isExpanded;
    this.render();
  }

  render() {
    // Обновление UI на основе локального состояния
    const container = document.getElementById('cart-container');
    container.innerHTML = `
      <div class="cart">
        <h3>Корзина (${this.localState.items.length})</h3>
        <button onclick="toggleExpansion">
          ${this.localState.isExpanded ? 'Свернуть' : 'Развернуть'}
        </button>
        ${this.localState.isExpanded ? this.renderItems() : ''}
      </div>
    `;
  }
}
```

### 2. Общее состояние

Общее состояние используется несколькими микро-фронтендами и должно быть синхронизировано между ними.

```javascript
// shared-state.js
class GlobalState {
  constructor() {
    this.state = {
      user: null,
      cart: { items: [], total: 0 },
      theme: 'light',
      notifications: []
    };
    this.listeners = {};
  }

  getState(path) {
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }

  setState(path, value) {
    const keys = path.split('.');
    let current = this.state;
    
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    
    const lastKey = keys[keys.length - 1];
    const oldValue = current[lastKey];
    current[lastKey] = value;
    
    // Уведомление подписчиков об изменении
    this.notifyListeners(path, value, oldValue);
  }

  subscribe(path, callback) {
    if (!this.listeners[path]) {
      this.listeners[path] = [];
    }
    this.listeners[path].push(callback);
  }

  notifyListeners(path, newValue, oldValue) {
    if (this.listeners[path]) {
      this.listeners[path].forEach(callback => 
        callback(newValue, oldValue)
      );
    }
  }
}

// Глобальный экземпляр состояния
window.globalState = new GlobalState();
```

### 3. Состояние сессии

Состояние, которое должно сохраняться в течение сессии пользователя.

```javascript
// session-state.js
class SessionState {
  constructor() {
    this.storage = window.sessionStorage;
  }

  set(key, value) {
    this.storage.setItem(key, JSON.stringify(value));
  }

  get(key) {
    const item = this.storage.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  remove(key) {
    this.storage.removeItem(key);
  }

  clear() {
    this.storage.clear();
  }
}

window.sessionState = new SessionState();
```

## Паттерны управления состоянием

### 1. Event-Driven State Management

```javascript
// event-state-manager.js
class EventDrivenStateManager {
  constructor() {
    this.state = {};
    this.eventQueue = [];
    this.subscribers = {};
  }

  dispatch(action) {
    // Логирование действий
    console.log('Действие:', action);
    
    // Обновление состояния
    this.state = this.reduce(this.state, action);
    
    // Уведомление подписчиков
    this.notifySubscribers(action.type, this.state);
  }

  reduce(state, action) {
    switch (action.type) {
      case 'USER_LOGIN':
        return { ...state, user: action.payload };
      case 'ADD_TO_CART':
        const cart = state.cart || { items: [], total: 0 };
        const newItems = [...cart.items, action.payload];
        const newTotal = newItems.reduce((sum, item) => sum + item.price, 0);
        return { ...state, cart: { items: newItems, total: newTotal } };
      case 'REMOVE_FROM_CART':
        const updatedCart = state.cart ? { ...state.cart } : { items: [], total: 0 };
        updatedCart.items = updatedCart.items.filter(item => item.id !== action.payload);
        updatedCart.total = updatedCart.items.reduce((sum, item) => sum + item.price, 0);
        return { ...state, cart: updatedCart };
      default:
        return state;
    }
  }

  subscribe(eventType, callback) {
    if (!this.subscribers[eventType]) {
      this.subscribers[eventType] = [];
    }
    this.subscribers[eventType].push(callback);
  }

  notifySubscribers(eventType, state) {
    if (this.subscribers[eventType]) {
      this.subscribers[eventType].forEach(callback => 
        callback(state)
      );
    }
  }
}

// Использование в микро-фронтенде
class UserMicroFrontend {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.stateManager.subscribe('USER_LOGIN', this.handleUserLogin.bind(this));
  }

  handleUserLogin(state) {
    this.renderUserInfo(state.user);
  }

  login(username, password) {
    // Логика аутентификации
    this.stateManager.dispatch({
      type: 'USER_LOGIN',
      payload: { username, email: 'user@example.com' }
    });
  }
}
```

### 2. Flux-подобная архитектура

```javascript
// flux-architecture.js
class FluxStore {
  constructor(reducer) {
    this.reducer = reducer;
    this.state = reducer(undefined, { type: '@@INIT' });
    this.listeners = [];
  }

  getState() {
    return this.state;
  }

  dispatch(action) {
    const newState = this.reducer(this.state, action);
    if (newState !== this.state) {
      this.state = newState;
      this.notifyListeners();
    }
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notifyListeners() {
    this.listeners.forEach(listener => listener());
  }
}

// Определение редьюсера
const rootReducer = (state = {}, action) => {
  return {
    user: userReducer(state.user, action),
    cart: cartReducer(state.cart, action),
    ui: uiReducer(state.ui, action)
  };
};

const userReducer = (state = null, action) => {
  switch (action.type) {
    case 'USER_LOGIN':
      return action.payload;
    case 'USER_LOGOUT':
      return null;
    default:
      return state;
  }
};

const cartReducer = (state = { items: [], total: 0 }, action) => {
  switch (action.type) {
    case 'ADD_TO_CART':
      const newItems = [...state.items, action.payload];
      const newTotal = newItems.reduce((sum, item) => sum + item.price, 0);
      return { items: newItems, total: newTotal };
    case 'REMOVE_FROM_CART':
      const filteredItems = state.items.filter(item => item.id !== action.payload);
      const updatedTotal = filteredItems.reduce((sum, item) => sum + item.price, 0);
      return { items: filteredItems, total: updatedTotal };
    default:
      return state;
  }
};

// Создание глобального стора
window.fluxStore = new FluxStore(rootReducer);
```

### 3. Reactive State Management

```javascript
// reactive-state.js
class ReactiveState {
  constructor(initialState = {}) {
    this.state = this.makeReactive(initialState);
    this.reactions = [];
  }

  makeReactive(obj) {
    return new Proxy(obj, {
      set: (target, property, value) => {
        const oldValue = target[property];
        target[property] = value;
        
        // Запуск реакций при изменении
        this.runReactions(property, value, oldValue);
        
        return true;
      }
    });
  }

  observe(property, reaction) {
    this.reactions.push({ property, reaction });
  }

  runReactions(property, newValue, oldValue) {
    this.reactions
      .filter(r => r.property === property)
      .forEach(r => r.reaction(newValue, oldValue));
  }

  get(path) {
    return path.split('.').reduce((obj, key) => obj?.[key], this.state);
  }

  set(path, value) {
    const keys = path.split('.');
    let current = this.state;
    
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    
    current[keys[keys.length - 1]] = value;
  }
}

// Использование реактивного состояния
const reactiveState = new ReactiveState({
  user: { name: '', email: '' },
  cart: { items: [], total: 0 }
});

// Подписка на изменения
reactiveState.observe('cart.total', (newTotal) => {
  console.log('Обновлена общая сумма корзины:', newTotal);
  updateCartBadge(newTotal);
});

reactiveState.observe('user.name', (newName) => {
  console.log('Обновлено имя пользователя:', newName);
  updateUserNameDisplay(newName);
});
```

## Изоляция состояния

Для предотвращения конфликтов между микро-фронтендами важно обеспечить изоляцию состояния:

```javascript
// state-isolation.js
class MicroFrontendStateIsolation {
  constructor(microFrontendId) {
    this.microFrontendId = microFrontendId;
    this.privateState = new Map();
  }

  setState(key, value) {
    this.privateState.set(key, value);
  }

  getState(key) {
    return this.privateState.get(key);
  }

  // Публичный интерфейс для доступа к состоянию
  getPublicState() {
    return {
      id: this.microFrontendId,
      data: Object.fromEntries(this.privateState)
    };
  }
}

// Использование в микро-фронтенде
class ProductMicroFrontend {
  constructor() {
    this.state = new MicroFrontendStateIsolation('product-mf');
    this.state.setState('products', []);
    this.state.setState('selectedProduct', null);
  }
}
```

## Персистентное состояние

Сохранение состояния между сессиями пользователя:

```javascript
// persistent-state.js
class PersistentState {
  constructor(namespace) {
    this.namespace = namespace;
  }

  set(key, value) {
    const fullKey = `${this.namespace}:${key}`;
    localStorage.setItem(fullKey, JSON.stringify(value));
  }

  get(key) {
    const fullKey = `${this.namespace}:${key}`;
    const item = localStorage.getItem(fullKey);
    return item ? JSON.parse(item) : null;
  }

  remove(key) {
    const fullKey = `${this.namespace}:${key}`;
    localStorage.removeItem(fullKey);
  }

  clear() {
    Object.keys(localStorage)
      .filter(key => key.startsWith(this.namespace + ':'))
      .forEach(key => localStorage.removeItem(key));
  }
}

// Использование в приложении
const appState = new PersistentState('myapp');
appState.set('theme', 'dark');
appState.set('language', 'ru');

const savedTheme = appState.get('theme'); // 'dark'
```

## Практические рекомендации

> [!tip] Рекомендации по управлению состоянием
> - Используйте локальное состояние для данных, специфичных для микро-фронтенда
> - Централизуйте общее состояние с помощью глобального стора
> - Обеспечьте согласованность данных между микро-фронтендами
> - Реализуйте надежные механизмы подписки на изменения состояния

> [!warning] Потенциальные проблемы
> - Утечки памяти при неправильной очистке подписок
> - Конфликты при одновременном обновлении общего состояния
> - Сложности с отладкой распределенного состояния

## Заключение

Управление состоянием в архитектуре микро-фронтендов требует тщательного подхода к проектированию. Необходимо балансировать между изоляцией компонентов и необходимостью обмена данными. Выбор подходящего паттерна управления состоянием зависит от сложности приложения и требований к производительности.

См. также: [[Введение-в-микро-фронтенды]], [[Архитектурные-подходы]], [[Интеграция]], [[Тестирование]]