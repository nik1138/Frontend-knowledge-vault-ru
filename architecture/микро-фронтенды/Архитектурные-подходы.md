---
aliases: [Архитектурные подходы, Подходы к микрофронтендам]
tags: [architecture, frontend, micro-frontend, patterns]
---

# Архитектурные подходы к микро-фронтендам

## Обзор архитектурных подходов

Существует несколько основных архитектурных подходов к реализации микро-фронтендов. Каждый из них имеет свои преимущества и недостатки, и выбор зависит от конкретных требований проекта, размера команды и инфраструктуры.

## 1. Runtime Integration (Интеграция во время выполнения)

Этот подход предполагает, что микро-фронтенды интегрируются на стороне клиента во время выполнения приложения.

### Пример реализации

```javascript
// main-app.js
class MainApp {
  constructor() {
    this.microFrontends = new Map();
    this.loadMicroFrontends();
  }

  async loadMicroFrontends() {
    // Загрузка микро-фронтендов динамически
    const headerModule = await import('./micro-frontends/header/index.js');
    const navigationModule = await import('./micro-frontends/navigation/index.js');
    const contentModule = await import('./micro-frontends/content/index.js');
    
    this.microFrontends.set('header', headerModule.default);
    this.microFrontends.set('navigation', navigationModule.default);
    this.microFrontends.set('content', contentModule.default);
    
    this.render();
  }

  render() {
    document.getElementById('app').innerHTML = `
      <div id="header-container"></div>
      <div id="navigation-container"></div>
      <div id="content-container"></div>
    `;
    
    // Инициализация каждого микро-фронтенда
    new (this.microFrontends.get('header'))('header-container');
    new (this.microFrontends.get('navigation'))('navigation-container');
    new (this.microFrontends.get('content'))('content-container');
  }
}

new MainApp();
```

### Преимущества
- Гибкость в развертывании
- Возможность использования разных фреймворков
- Простота добавления новых микро-фронтендов

### Недостатки
- Увеличенное время загрузки
- Сложности с совместимостью версий библиотек
- Проблемы с производительностью

## 2. Build-Time Integration (Интеграция на этапе сборки)

При этом подходе микро-фронтенды интегрируются на этапе сборки приложения.

### Пример конфигурации Webpack

```javascript
// webpack.config.js
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        'header-app': 'header@http://localhost:3001/remoteEntry.js',
        'navigation-app': 'navigation@http://localhost:3002/remoteEntry.js',
        'content-app': 'content@http://localhost:3003/remoteEntry.js',
      },
      shared: ['react', 'react-dom'],
    }),
  ],
};
```

### Преимущества
- Лучшая производительность
- Оптимизированный размер бандла
- Упрощенная отладка

### Недостатки
- Зависимость от других микро-фронтендов на этапе сборки
- Сложности с независимым развертыванием
- Повышенная сложность конфигурации

## 3. Server-Side Integration (Серверная интеграция)

Этот подход предполагает интеграцию микро-фронтендов на сервере с последующей отправкой готовой страницы клиенту.

### Пример с использованием Node.js

```javascript
// server.js
const express = require('express');
const axios = require('axios');
const app = express();

app.get('/', async (req, res) => {
  try {
    // Получение HTML от каждого микро-фронтенда
    const [headerHtml, navHtml, contentHtml] = await Promise.all([
      axios.get('http://localhost:3001/header'),
      axios.get('http://localhost:3002/navigation'),
      axios.get('http://localhost:3003/content')
    ]);

    const fullHtml = `
      <!DOCTYPE html>
      <html>
        <head><title>Микро-фронтенд приложение</title></head>
        <body>
          ${headerHtml.data}
          ${navHtml.data}
          ${contentHtml.data}
        </body>
      </html>
    `;

    res.send(fullHtml);
  } catch (error) {
    console.error('Ошибка при интеграции микро-фронтендов:', error);
    res.status(500).send('Внутренняя ошибка сервера');
  }
});
```

### Преимущества
- Лучшая производительность (первый рендер)
- SEO-friendly
- Упрощенное управление состоянием

### Недостатки
- Зависимость от других сервисов
- Сложности с кешированием
- Увеличенное время ответа

## 4. Edge-Side Integration (Интеграция на уровне CDN)

Интеграция микро-фронтендов происходит на уровне краевых серверов (CDN), что позволяет объединять фрагменты на ближайшем к пользователю сервере.

### Пример с использование Edge Side Includes (ESI)

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head><title>Микро-фронтенд приложение</title></head>
<body>
  <esi:include src="/header" />
  <esi:include src="/navigation" />
  <esi:include src="/content" />
  <esi:include src="/footer" />
</body>
</html>
```

## Сравнение подходов

| Критерий | Runtime | Build-Time | Server-Side | Edge-Side |
|----------|---------|------------|-------------|----------|
| Производительность | Низкая | Высокая | Средняя | Высокая |
| Независимость команд | Высокая | Низкая | Средняя | Высокая |
| SEO | Низкая | Высокая | Высокая | Высокая |
| Сложность | Средняя | Высокая | Средняя | Высокая |
| Гибкость развертывания | Высокая | Низкая | Средняя | Высокая |

## Выбор подхода

> [!tip] Рекомендации по выбору подхода
> - **Runtime Integration**: для высокой независимости команд и гибкости
> - **Build-Time Integration**: когда важна производительность и оптимизация
> - **Server-Side Integration**: для SEO-чувствительных приложений
> - **Edge-Side Integration**: для глобальных приложений с низкой задержкой

## Практические рекомендации

1. **Начинайте с Runtime Integration** — это самый гибкий подход для начала
2. **Оцените требования к производительности** — может потребоваться переход к Build-Time или Server-Side
3. **Рассмотрите гибридный подход** — комбинация нескольких подходов для разных частей приложения
4. **Обеспечьте единообразие UX** — независимо от архитектурного подхода

## Заключение

Выбор архитектурного подхода к микро-фронтендам — это компромисс между производительностью, независимостью команд и сложностью реализации. Важно учитывать не только технические требования, но и организационные факторы, такие как размер команды, частота развертываний и культура разработки.

См. также: [[Введение-в-микро-фронтенды]], [[Интеграция]], [[Управление-состоянием]], [[Тестирование]]