---
aliases: [Тестирование микрофронтендов, Тесты для микрофронтендов]
tags: [testing, frontend, micro-frontend, quality-assurance]
---

# Тестирование микро-фронтендов

## Общие принципы тестирования

Тестирование микро-фронтендов представляет собой комплексную задачу, требующую подхода, отличного от традиционного тестирования монолитных приложений. Из-за распределенной природы микро-фронтендов необходимо тестировать как отдельные компоненты, так и их взаимодействие друг с другом.

## Уровни тестирования

### 1. Модульное тестирование (Unit Testing)

Тестирование отдельных компонентов и функций внутри микро-фронтенда.

```javascript
// cart.test.js
import { CartMicroFrontend } from './cart.js';

describe('CartMicroFrontend', () => {
  let cart;
  let container;

  beforeEach(() => {
    container = document.createElement('div');
    container.id = 'cart-container';
    document.body.appendChild(container);
    cart = new CartMicroFrontend();
  });

  afterEach(() => {
    document.body.removeChild(container);
  });

  test('should initialize with empty cart', () => {
    expect(cart.getItems()).toEqual([]);
    expect(cart.getTotal()).toBe(0);
  });

  test('should add item to cart', () => {
    const item = { id: 1, name: 'Product', price: 100 };
    cart.addItem(item);
    
    expect(cart.getItems()).toHaveLength(1);
    expect(cart.getItems()[0]).toEqual(item);
    expect(cart.getTotal()).toBe(100);
  });

  test('should remove item from cart', () => {
    const item = { id: 1, name: 'Product', price: 100 };
    cart.addItem(item);
    cart.removeItem(1);
    
    expect(cart.getItems()).toEqual([]);
    expect(cart.getTotal()).toBe(0);
  });
});
```

### 2. Интеграционное тестирование

Тестирование взаимодействия между микро-фронтендами и внешними сервисами.

```javascript
// integration.test.js
import { MicroFrontendIntegration } from './integration.js';

describe('MicroFrontendIntegration', () => {
  let integration;
  let mockEventBus;

  beforeEach(() => {
    mockEventBus = {
      subscribe: jest.fn(),
      publish: jest.fn()
    };
    
    integration = new MicroFrontendIntegration(mockEventBus);
  });

  test('should handle user login event', async () => {
    const userData = { id: 1, name: 'John Doe' };
    
    await integration.handleEvent('user-logged-in', userData);
    
    expect(mockEventBus.publish).toHaveBeenCalledWith('user-updated', userData);
    expect(integration.getCurrentUser()).toEqual(userData);
  });

  test('should synchronize state between micro frontends', () => {
    const cartData = { items: [{ id: 1, name: 'Item' }], total: 100 };
    
    integration.updateSharedState('cart', cartData);
    
    expect(integration.getSharedState('cart')).toEqual(cartData);
  });
});
```

### 3. E2E тестирование

Тестирование полного пользовательского сценария с участием нескольких микро-фронтендов.

```javascript
// e2e.test.js
describe('Shopping Flow', () => {
  beforeAll(async () => {
    await page.goto('http://localhost:3000');
  });

  test('user can add product to cart and see updated cart count', async () => {
    // Найти и кликнуть по продукту в каталоге (каталог-mf)
    await page.click('#product-1');
    
    // Добавить в корзину
    await page.click('#add-to-cart');
    
    // Проверить, что счетчик корзины обновился (cart-mf)
    const cartCount = await page.textContent('#cart-count');
    expect(cartCount).toBe('1');
    
    // Перейти на страницу корзины
    await page.click('#go-to-cart');
    
    // Проверить, что товар отображается в корзине
    const cartItems = await page.$$('.cart-item');
    expect(cartItems).toHaveLength(1);
  });

  test('user can navigate between micro frontends', async () => {
    // Проверить навигацию (navigation-mf)
    await page.click('nav a[href="#/catalog"]');
    await page.waitForSelector('#catalog-container');
    
    await page.click('nav a[href="#/profile"]');
    await page.waitForSelector('#profile-container');
  });
});
```

## Специфические стратегии тестирования

### 1. Тестирование изоляции

Проверка, что микро-фронтенд работает независимо от других компонентов.

```javascript
// isolation.test.js
describe('MicroFrontend Isolation', () => {
  test('should not affect global scope', () => {
    const globalBefore = Object.keys(window);
    
    // Загрузка микро-фронтенда
    new HeaderMicroFrontend('header-container');
    
    const globalAfter = Object.keys(window);
    
    // Проверка, что не добавлены нежелательные глобальные переменные
    const newGlobals = globalAfter.filter(key => !globalBefore.includes(key));
    expect(newGlobals).toEqual([]);
  });

  test('should not interfere with other micro frontends', () => {
    // Создание двух микро-фронтендов
    const header = new HeaderMicroFrontend('header-container');
    const footer = new FooterMicroFrontend('footer-container');
    
    // Проверка, что они не мешают друг другу
    expect(header.getState()).not.toEqual(footer.getState());
  });
});
```

### 2. Тестирование интеграции

Проверка взаимодействия между микро-фронтендами.

```javascript
// integration.test.js
describe('Cross-MicroFrontend Communication', () => {
  let headerMF, cartMF, eventBus;

  beforeEach(() => {
    eventBus = new EventBus();
    
    headerMF = new HeaderMicroFrontend(eventBus);
    cartMF = new CartMicroFrontend(eventBus);
  });

  test('should update cart count when item is added', () => {
    const cartCountBefore = cartMF.getItemCount();
    
    // Симуляция добавления товара через событие
    eventBus.publish('item-added-to-cart', { id: 1, name: 'Product', price: 100 });
    
    const cartCountAfter = cartMF.getItemCount();
    expect(cartCountAfter).toBe(cartCountBefore + 1);
  });

  test('should handle error when communication fails', () => {
    // Симуляция ошибки в коммуникации
    eventBus.publish('error', { type: 'communication-error', message: 'Connection failed' });
    
    expect(headerMF.getErrorState()).toBe('communication-error');
  });
});
```

### 3. Тестирование производительности

```javascript
// performance.test.js
describe('Performance Testing', () => {
  test('micro frontend should load within 2 seconds', async () => {
    const startTime = Date.now();
    
    await new Promise(resolve => {
      const mf = new ProductMicroFrontend();
      mf.mount('#container', {}).then(resolve);
    });
    
    const loadTime = Date.now() - startTime;
    expect(loadTime).toBeLessThan(2000);
  });

  test('memory usage should not exceed limit', () => {
    const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
    
    // Создание нескольких экземпляров микро-фронтенда
    const instances = [];
    for (let i = 0; i < 10; i++) {
      instances.push(new ProductMicroFrontend());
    }
    
    // Удаление экземпляров
    instances.forEach(instance => instance.destroy());
    
    const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
    
    // Проверка, что память освобождена
    expect(finalMemory - initialMemory).toBeLessThan(10 * 1024 * 1024); // 10MB
  });
});
```

## Mock-стратегии

### 1. Mock внешних зависимостей

```javascript
// mocks.js
export const createMockAPI = () => ({
  getUser: jest.fn().mockResolvedValue({ id: 1, name: 'John' }),
  getProducts: jest.fn().mockResolvedValue([
    { id: 1, name: 'Product 1', price: 100 },
    { id: 2, name: 'Product 2', price: 200 }
  ]),
  addToCart: jest.fn().mockResolvedValue({ success: true }),
  removeFromCart: jest.fn().mockResolvedValue({ success: true })
});

export const createMockEventBus = () => ({
  subscribe: jest.fn(),
  publish: jest.fn(),
  unsubscribe: jest.fn()
});
```

### 2. Mock других микро-фронтендов

```javascript
// micro-frontend-mocks.js
export class MockHeaderMF {
  constructor() {
    this.rendered = false;
  }
  
  mount(container) {
    document.querySelector(container).innerHTML = '<header>Mock Header</header>';
    this.rendered = true;
  }
  
  update(props) {
    // Mock обновления
  }
  
  unmount() {
    this.rendered = false;
  }
}

export class MockCartMF {
  constructor() {
    this.items = [];
  }
  
  getItems() {
    return this.items;
  }
  
  setItems(items) {
    this.items = items;
  }
}
```

## Инструменты тестирования

### 1. Jest для модульного тестирования

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/**/*.stories.js',
    '!src/index.js',
  ],
};
```

### 2. Cypress для E2E тестирования

```javascript
// cypress.config.js
import { defineConfig } from 'cypress'

export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
    baseUrl: 'http://localhost:3000',
    viewportWidth: 1280,
    viewportHeight: 720,
  },
})
```

### 3. Puppeteer для автоматизированного тестирования

```javascript
// puppeteer.test.js
import puppeteer from 'puppeteer';

describe('Micro Frontend Browser Tests', () => {
  let browser;
  let page;

  beforeAll(async () => {
    browser = await puppeteer.launch();
    page = await browser.newPage();
  });

  afterAll(async () => {
    await browser.close();
  });

  test('should render all micro frontends', async () => {
    await page.goto('http://localhost:3000');
    
    // Проверка наличия контейнеров для каждого микро-фронтенда
    const headerVisible = await page.$eval('#header-container', el => el.offsetHeight > 0);
    const navVisible = await page.$eval('#navigation-container', el => el.offsetHeight > 0);
    const contentVisible = await page.$eval('#content-container', el => el.offsetHeight > 0);
    
    expect(headerVisible).toBe(true);
    expect(navVisible).toBe(true);
    expect(contentVisible).toBe(true);
  });
});
```

## Практические рекомендации

> [!tip] Рекомендации по тестированию
> - Пишите тесты для каждого микро-фронтенда отдельно
> - Используйте mock-объекты для изоляции компонентов
> - Тестируйте сценарии интеграции между микро-фронтендами
> - Автоматизируйте тестирование в CI/CD pipeline

> [!warning] Потенциальные проблемы
> - Сложность отладки распределенных тестов
> - Зависимость от внешних сервисов в тестах
> - Проблемы с синхронизацией состояния между тестами

## Заключение

Тестирование микро-фронтендов требует комплексного подхода, включающего модульное, интеграционное и E2E тестирование. Важно обеспечить покрытие всех уровней и протестировать как изолированную работу каждого компонента, так и их взаимодействие друг с другом. Правильная тестовая стратегия помогает обеспечить стабильность и надежность распределенного фронтенд-приложения.

См. также: [[Введение-в-микро-фронтенды]], [[Архитектурные-подходы]], [[Интеграция]], [[Управление-состоянием]]