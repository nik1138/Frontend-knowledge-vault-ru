---
aliases: [Интеграция микрофронтендов, Способы интеграции]
tags: [integration, frontend, micro-frontend, architecture]
---

# Интеграция микро-фронтендов

## Общие принципы интеграции

Интеграция микро-фронтендов — это ключевой аспект архитектуры, определяющий, как отдельные части приложения объединяются в единое целое. Правильная интеграция обеспечивает согласованную работу всех компонентов без нарушения принципов изоляции и независимости.

## Способы интеграции

### 1. Императивная интеграция

В этом подходе основное приложение явно управляет жизненным циклом микро-фронтендов.

```javascript
// shell-app.js
class ShellApp {
  constructor() {
    this.microFrontends = [];
  }

  async loadMicroFrontend(name, url) {
    const module = await import(url);
    const microFrontend = new module.default();
    
    // Управление жизненным циклом
    microFrontend.mount(`#${name}-container`);
    this.microFrontends.push(microFrontend);
  }

  async initialize() {
    await Promise.all([
      this.loadMicroFrontend('header', './micro-frontends/header.js'),
      this.loadMicroFrontend('navigation', './micro-frontends/navigation.js'),
      this.loadMicroFrontend('content', './micro-frontends/content.js'),
    ]);
  }

  unmountAll() {
    this.microFrontends.forEach(mf => mf.unmount());
  }
}

// Определение интерфейса микро-фронтенда
class MicroFrontendInterface {
  mount(container) {
    throw new Error('Метод mount должен быть реализован');
  }

  unmount() {
    throw new Error('Метод unmount должен быть реализован');
  }

  update(props) {
    throw new Error('Метод update должен быть реализован');
  }
}
```

### 2. Декларативная интеграция

При декларативном подходе структура приложения описывается в конфигурации, а интеграция происходит автоматически.

```javascript
// config.js
export const microFrontendConfig = {
  header: {
    name: 'header-mf',
    url: 'https://cdn.example.com/header-mf.js',
    container: '#header-container',
    props: { theme: 'dark' }
  },
  navigation: {
    name: 'navigation-mf',
    url: 'https://cdn.example.com/navigation-mf.js',
    container: '#navigation-container',
    props: { menuItems: [] }
  },
  content: {
    name: 'content-mf',
    url: 'https://cdn.example.com/content-mf.js',
    container: '#content-container',
    props: { page: 'home' }
  }
};

// integration-engine.js
class IntegrationEngine {
  constructor(config) {
    this.config = config;
  }

  async loadMicroFrontends() {
    const promises = Object.entries(this.config).map(async ([name, config]) => {
      const module = await import(config.url);
      const microFrontend = new module.default();
      
      microFrontend.mount(config.container, config.props);
      return { name, instance: microFrontend };
    });

    return Promise.all(promises);
  }
}
```

### 3. Интеграция через веб-компоненты

Использование веб-компонентов для инкапсуляции микро-фронтендов и их интеграции.

```javascript
// header-mf.js (веб-компонент)
class HeaderMicroFrontend extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          background-color: #333;
          color: white;
          padding: 1rem;
        }
        
        nav a {
          margin-right: 1rem;
          color: white;
          text-decoration: none;
        }
      </style>
      
      <header>
        <h1>Навигация</h1>
        <nav>
          <a href="#/">Главная</a>
          <a href="#/catalog">Каталог</a>
          <a href="#/cart">Корзина</a>
        </nav>
      </header>
    `;
  }
}

customElements.define('header-mf', HeaderMicroFrontend);

// Использование в основном приложении
// index.html
/*
<div id="app">
  <header-mf></header-mf>
  <navigation-mf></navigation-mf>
  <content-mf></content-mf>
</div>
*/
```

## Управление жизненным циклом

> [!note] Жизненный цикл микро-фронтенда
> 1. **Загрузка** — получение кода микро-фронтенда
> 2. **Инициализация** — создание экземпляра и настройка
> 3. **Монтирование** — отображение в DOM
> 4. **Обновление** — реакция на изменения состояния
> 5. **Демонтирование** — очистка ресурсов

```javascript
// lifecycle-manager.js
class MicroFrontendLifecycleManager {
  constructor() {
    this.instances = new Map();
  }

  async mount(name, MicroFrontendClass, container, props = {}) {
    if (this.instances.has(name)) {
      await this.unmount(name);
    }

    const instance = new MicroFrontendClass(props);
    await instance.mount(container);
    this.instances.set(name, instance);

    return instance;
  }

  async unmount(name) {
    const instance = this.instances.get(name);
    if (instance && typeof instance.unmount === 'function') {
      await instance.unmount();
      this.instances.delete(name);
    }
  }

  async update(name, props) {
    const instance = this.instances.get(name);
    if (instance && typeof instance.update === 'function') {
      await instance.update(props);
    }
  }

  async destroyAll() {
    for (const [name, instance] of this.instances) {
      await this.unmount(name);
    }
  }
}
```

## Коммуникация между микро-фронтендами

### 1. Через глобальный EventBus

```javascript
// event-bus.js
class EventBus {
  constructor() {
    this.events = {};
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  publish(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  unsubscribe(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

// Глобальный экземпляр
window.eventBus = new EventBus();

// В микро-фронтенде
class ContentMicroFrontend {
  constructor() {
    this.eventBus = window.eventBus;
    this.eventBus.subscribe('user-logged-in', this.handleLogin.bind(this));
  }

  handleLogin(userData) {
    console.log('Пользователь вошел:', userData);
    // Обновить состояние компонента
  }
}
```

### 2. Через Shared State Management

```javascript
// shared-state.js
class SharedState {
  constructor() {
    this.state = {};
    this.listeners = {};
  }

  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    if (this.listeners[key]) {
      this.listeners[key].forEach(callback => 
        callback(value, oldValue)
      );
    }
  }

  getState(key) {
    return this.state[key];
  }

  subscribe(key, callback) {
    if (!this.listeners[key]) {
      this.listeners[key] = [];
    }
    this.listeners[key].push(callback);
  }

  unsubscribe(key, callback) {
    if (this.listeners[key]) {
      this.listeners[key] = this.listeners[key].filter(cb => cb !== callback);
    }
  }
}

// Глобальное состояние
window.sharedState = new SharedState();

// В микро-фронтенде
class CartMicroFrontend {
  constructor() {
    this.sharedState = window.sharedState;
    this.sharedState.subscribe('cart-items', this.updateCart.bind(this));
  }

  updateCart(items) {
    this.render(items);
  }
}
```

## Обработка ошибок

```javascript
// error-boundary.js
class MicroFrontendErrorBoundary {
  constructor(microFrontendName) {
    this.microFrontendName = microFrontendName;
  }

  async executeWithErrorHandling(operation) {
    try {
      return await operation();
    } catch (error) {
      console.error(`Ошибка в микро-фронтенде ${this.microFrontendName}:`, error);
      
      // Логирование ошибки
      this.logError(error);
      
      // Отображение резервного UI
      this.showFallbackUI();
      
      // Попытка восстановления
      await this.attemptRecovery();
      
      throw error;
    }
  }

  logError(error) {
    // Отправка ошибки в систему мониторинга
    console.log('Отправка ошибки в систему мониторинга:', {
      microFrontend: this.microFrontendName,
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }

  showFallbackUI() {
    // Показать резервный интерфейс
    const container = document.getElementById(`${this.microFrontendName}-container`);
    if (container) {
      container.innerHTML = `<div class="error-fallback">Ошибка загрузки компонента</div>`;
    }
  }

  async attemptRecovery() {
    // Попытка повторной загрузки микро-фронтенда
    console.log(`Попытка восстановления микро-фронтенда: ${this.microFrontendName}`);
  }
}
```

## Практические рекомендации

> [!tip] Рекомендации по интеграции
> - Используйте единый интерфейс для всех микро-фронтендов
> - Обеспечьте изоляцию стилей с помощью CSS-модулей или Shadow DOM
> - Реализуйте централизованное управление ошибками
> - Обеспечьте согласованность UX-дизайна

> [!warning] Потенциальные проблемы
> - Утечки памяти при неправильной очистке
> - Конфликты зависимостей между микро-фронтендами
> - Проблемы с производительностью при загрузке множества компонентов

## Заключение

Успешная интеграция микро-фронтендов требует тщательного планирования архитектуры и реализации надежных механизмов взаимодействия. Ключевыми факторами являются изоляция, управление жизненным циклом и согласованная коммуникация между компонентами.

См. также: [[Введение-в-микро-фронтенды]], [[Архитектурные-подходы]], [[Управление-состоянием]], [[Тестирование]]