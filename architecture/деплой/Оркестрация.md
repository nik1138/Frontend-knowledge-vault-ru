---
aliases: [Оркестрация фронтенд-приложений, Frontend Orchestration, Оркестрация]
tags: [frontend, deployment, architecture, kubernetes, docker-swarm, orchestration, best-practices]
---

# Оркестрация

## Обзор

Оркестрация - это автоматизация процесса развертывания, масштабирования и управления контейнеризированными приложениями. Для фронтенд-приложений оркестрация обеспечивает высокую доступность, автоматическое масштабирование и упрощенное управление инфраструктурой.

## Основы оркестрации фронтенд-приложений

### Зачем нужна оркестрация?

- **Масштабируемость**: Автоматическое масштабирование в зависимости от нагрузки
- **Высокая доступность**: Резервирование и автоматическое восстановление после сбоев
- **Управление конфигурациями**: Централизованное управление переменными окружения
- **Безопасность**: Управление секретами и сетевыми политиками
- **Мониторинг**: Интеграция с системами мониторинга и логирования
- **Обновления**: Автоматические обновления с нулевым временем простоя

### Архитектура оркестрированного фронтенд-приложения

Типичная архитектура включает:

1. **Контроллеры приложений** (Deployments, StatefulSets)
2. **Службы** (Services) для внутренней коммуникации
3. **Входы** (Ingress) для маршрутизации внешнего трафика
4. **Конфигурационные карты** (ConfigMaps) для настроек
5. **Секреты** (Secrets) для чувствительных данных
6. **Нагрузки** (HPA) для автоматического масштабирования

## Kubernetes для фронтенд-приложений

### Основные компоненты

#### Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  labels:
    app: frontend
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
        version: v1.0.0
    spec:
      containers:
      - name: frontend
        image: my-frontend:latest
        ports:
        - containerPort: 80
        env:
        - name: API_URL
          valueFrom:
            configMapKeyRef:
              name: frontend-config
              key: api_url
        - name: NODE_ENV
          value: production
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

#### Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: frontend
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
```

#### Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - myapp.com
    secretName: myapp-tls
  rules:
  - host: myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

### ConfigMap и Secret

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
data:
  api_url: "https://api.myapp.com"
  app_name: "My Frontend App"
  version: "1.0.0"
---
apiVersion: v1
kind: Secret
metadata:
  name: frontend-secrets
type: Opaque
data:
  google_analytics_id: <base64_encoded_value>
  sentry_dsn: <base64_encoded_value>
```

## Продвинутые паттерны оркестрации

### Horizontal Pod Autoscaler (HPA)

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: frontend-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

### Network Policies

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-network-policy
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
  egress:
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80
```

### Service Account и RBAC

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: frontend-sa
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: frontend-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: frontend-rolebinding
subjects:
- kind: ServiceAccount
  name: frontend-sa
  namespace: default
roleRef:
  kind: Role
  name: frontend-role
  apiGroup: rbac.authorization.k8s.io
```

## Helm Charts для фронтенд-приложений

### Chart.yaml

```yaml
apiVersion: v2
name: frontend-app
description: A Helm chart for deploying frontend applications
type: application
version: 0.1.0
appVersion: "1.0.0"
```

### values.yaml

```yaml
replicaCount: 3

image:
  repository: my-frontend
  pullPolicy: IfNotPresent
  tag: ""

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: myapp.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.com

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
```

### templates/deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "frontend-app.fullname" . }}
  labels:
    {{- include "frontend-app.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "frontend-app.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "frontend-app.selectorLabels" . | nindent 8 }}
    spec:
      serviceAccountName: {{ include "frontend-app.serviceAccountName" . }}
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          {{- with .Values.probes }}
          {{- toYaml . | nindent 10 }}
          {{- end }}
```

## Docker Swarm для фронтенд-приложений

### docker-compose.yml для Swarm

```yaml
version: '3.8'

services:
  frontend:
    image: my-frontend:latest
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
      rollback_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.25'
          memory: 128M
    ports:
      - "80:80"
    environment:
      - NODE_ENV=production
    networks:
      - frontend-network
    configs:
      - source: nginx_config
        target: /etc/nginx/nginx.conf

configs:
  nginx_config:
    file: ./nginx.conf

networks:
  frontend-network:
    driver: overlay
    attachable: true
```

## Практические рекомендации

### 1. Используйте namespaces для изоляции

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: frontend-staging
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  namespace: frontend-staging  # Изолированное окружение
spec:
  # ... спецификация деплоймента
```

### 2. Мониторинг и логирование

```yaml
# Добавление аннотаций для Prometheus
metadata:
  annotations:
    prometheus.io/scrape: 'true'
    prometheus.io/port: '80'
    prometheus.io/path: '/metrics'
```

### 3. Безопасность

- Используйте минимальные привилегии для Service Accounts
- Внедряйте сетевые политики
- Используйте безопасные образы контейнеров
- Регулярно обновляйте зависимости

```yaml
# Security Context для Pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
  containers:
  - name: frontend
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1000
      capabilities:
        drop:
        - ALL
```

## Связанные темы

- [[Стратергии-деплоя]]
- [[Контейнеризация]]
- [[CI-CD]]
- [[Мониторинг-после-деплоя]]

## Теги

#frontend #deployment #architecture #kubernetes #docker-swarm #orchestration #helm #ingress #services #best-practices