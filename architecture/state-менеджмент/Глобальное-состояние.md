---
aliases: [Глобальное состояние, Управление глобальным состоянием]
tags: [frontend, state-management, architecture]
---

# Глобальное состояние

## Определение

Глобальное состояние (global state) - это данные, которые доступны и управляются на уровне всего приложения. В отличие от локального состояния, глобальное состояние может быть изменено и прочитано из любой части приложения, что делает его идеальным для хранения информации, которая должна быть доступна для множества компонентов.

## Примеры глобального состояния

- Данные аутентификации пользователя (токены, профиль)
- Настройки приложения (язык, тема, предпочтения)
- Данные, полученные с сервера (например, список пользователей, товары в магазине)
- Состояние UI приложения (например, открытые модальные окна, уведомления)
- Кэш данных для избежания повторных запросов

## Реализация глобального состояния

### Redux

Redux - один из самых популярных инструментов для управления глобальным состоянием в React-приложениях. Он обеспечивает предсказуемое изменение состояния через строгую архитектуру.

```javascript
// store.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './slices/userSlice';
import cartReducer from './slices/cartSlice';

export const store = configureStore({
  reducer: {
    user: userReducer,
    cart: cartReducer,
  },
});

// slices/userSlice.js
import { createSlice } from '@reduxjs/toolkit';

const userSlice = createSlice({
  name: 'user',
  initialState: {
    profile: null,
    isAuthenticated: false,
    loading: false,
    error: null,
  },
  reducers: {
    loginStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action) => {
      state.loading = false;
      state.isAuthenticated = true;
      state.profile = action.payload;
    },
    loginFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    },
    logout: (state) => {
      state.isAuthenticated = false;
      state.profile = null;
    },
  },
});

export const { loginStart, loginSuccess, loginFailure, logout } = userSlice.actions;
export default userSlice.reducer;

// components/UserProfile.jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { loginStart, logout } from '../slices/userSlice';

function UserProfile() {
  const { profile, isAuthenticated, loading } = useSelector(state => state.user);
  const dispatch = useDispatch();

  const handleLogin = () => {
    dispatch(loginStart());
    // Логика аутентификации
  };

  const handleLogout = () => {
    dispatch(logout());
  };

  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div>
      {isAuthenticated ? (
        <div>
          <p>Привет, {profile?.name}!</p>
          <button onClick={handleLogout}>Выйти</button>
        </div>
      ) : (
        <button onClick={handleLogin}>Войти</button>
      )}
    </div>
  );
}
```

### Zustand

Zustand - легковесная альтернатива Redux с более простым API, но без лишней сложности.

```javascript
// stores/userStore.js
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

const useUserStore = create(
  devtools(
    persist(
      (set, get) => ({
        user: null,
        isAuthenticated: false,
        loading: false,
        error: null,
        
        login: async (credentials) => {
          set({ loading: true, error: null });
          try {
            // Имитация аутентификации
            const response = await mockLogin(credentials);
            set({ 
              user: response.user, 
              isAuthenticated: true, 
              loading: false 
            });
          } catch (error) {
            set({ error: error.message, loading: false });
          }
        },
        
        logout: () => {
          set({ user: null, isAuthenticated: false });
        },
        
        updateUser: (userData) => {
          set((state) => ({ 
            user: { ...state.user, ...userData } 
          }));
        },
      }),
      {
        name: 'user-storage', // ключ для localStorage
      }
    )
  )
);

// components/UserDashboard.jsx
import React from 'react';
import { useUserStore } from '../stores/userStore';

function UserDashboard() {
  const { user, isAuthenticated, loading, login, logout } = useUserStore();
  
  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div>
      {isAuthenticated ? (
        <div>
          <h2>Добро пожаловать, {user?.name}!</h2>
          <p>Email: {user?.email}</p>
          <button onClick={logout}>Выйти</button>
        </div>
      ) : (
        <button onClick={() => login({ email: 'user@example.com', password: 'password' })}>
          Войти
        </button>
      )}
    </div>
  );
}
```

### Context API

Context API в React предоставляет встроенный способ передачи данных через дерево компонентов без необходимости передавать пропсы на каждом уровне.

```jsx
// contexts/AppContext.js
import React, { createContext, useContext, useReducer } from 'react';

const AppContext = createContext();

const initialState = {
  theme: 'light',
  language: 'ru',
  notifications: [],
  sidebarOpen: false,
};

function appReducer(state, action) {
  switch (action.type) {
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    case 'ADD_NOTIFICATION':
      return { 
        ...state, 
        notifications: [...state.notifications, { ...action.payload, id: Date.now() }] 
      };
    case 'REMOVE_NOTIFICATION':
      return { 
        ...state, 
        notifications: state.notifications.filter(n => n.id !== action.payload) 
      };
    case 'TOGGLE_SIDEBAR':
      return { ...state, sidebarOpen: !state.sidebarOpen };
    default:
      return state;
  }
}

export function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
}

// components/Header.jsx
import React from 'react';
import { useAppContext } from '../contexts/AppContext';

function Header() {
  const { state, dispatch } = useAppContext();

  const toggleTheme = () => {
    dispatch({ type: 'TOGGLE_THEME' });
  };

  const setLanguage = (lang) => {
    dispatch({ type: 'SET_LANGUAGE', payload: lang });
  };

  return (
    <header className={`header ${state.theme}`}>
      <button onClick={toggleTheme}>
        Переключить тему ({state.theme})
      </button>
      <button onClick={() => setLanguage('en')}>EN</button>
      <button onClick={() => setLanguage('ru')}>RU</button>
    </header>
  );
}
```

### Vuex (для Vue.js)

Vuex - официальная библиотека управления состоянием для Vue.js, обеспечивающая централизованное хранение данных.

```javascript
// store/index.js
import { createStore } from 'vuex';
import createPersistedState from 'vuex-persistedstate';

export default createStore({
  state: {
    user: null,
    isAuthenticated: false,
    cart: [],
    wishlist: [],
  },
  mutations: {
    SET_USER(state, user) {
      state.user = user;
      state.isAuthenticated = !!user;
    },
    ADD_TO_CART(state, item) {
      const existingItem = state.cart.find(i => i.id === item.id);
      if (existingItem) {
        existingItem.quantity += item.quantity || 1;
      } else {
        state.cart.push({ ...item, quantity: item.quantity || 1 });
      }
    },
    REMOVE_FROM_CART(state, itemId) {
      state.cart = state.cart.filter(item => item.id !== itemId);
    },
    TOGGLE_WISHLIST(state, item) {
      const index = state.wishlist.findIndex(i => i.id === item.id);
      if (index > -1) {
        state.wishlist.splice(index, 1);
      } else {
        state.wishlist.push(item);
      }
    }
  },
  actions: {
    async login({ commit }, credentials) {
      try {
        // Имитация аутентификации
        const user = await mockLogin(credentials);
        commit('SET_USER', user);
        return user;
      } catch (error) {
        throw error;
      }
    },
    addToCart({ commit }, item) {
      commit('ADD_TO_CART', item);
    },
    removeFromCart({ commit }, itemId) {
      commit('REMOVE_FROM_CART', itemId);
    }
  },
  getters: {
    cartTotal: state => {
      return state.cart.reduce((total, item) => total + (item.price * item.quantity), 0);
    },
    cartItemCount: state => {
      return state.cart.reduce((count, item) => count + item.quantity, 0);
    }
  },
  plugins: [createPersistedState()]
});

// components/CartSummary.vue
<template>
  <div class="cart-summary">
    <h3>Корзина</h3>
    <p>Товаров: {{ cartItemCount }}</p>
    <p>Итого: {{ cartTotal }} руб.</p>
    <button @click="checkout" :disabled="cartItemCount === 0">Оформить заказ</button>
  </div>
</template>

<script>
import { mapGetters, mapActions } from 'vuex';

export default {
  name: 'CartSummary',
  computed: {
    ...mapGetters(['cartTotal', 'cartItemCount'])
  },
  methods: {
    ...mapActions(['addToCart']),
    checkout() {
      // Логика оформления заказа
      console.log('Оформление заказа...');
    }
  }
};
</script>
```

## Преимущества глобального состояния

- **Централизованность**: Все данные хранятся в одном месте
- **Предсказуемость**: Четко определенные правила изменения состояния
- **Тестируемость**: Легче тестировать логику изменения состояния
- **Отладка**: Возможность отслеживания изменений состояния
- **Совместное использование**: Данные доступны всем компонентам

## Недостатки глобального состояния

- **Сложность**: Дополнительная архитектура и конфигурация
- **Переизбыток**: Может быть избыточным для простых приложений
- **Производительность**: Возможные проблемы с производительностью при неправильном использовании
- **Избыточные обновления**: Компоненты могут перерисовываться при изменениях, не относящихся к ним

## Когда использовать глобальное состояние

- Для данных, используемых в нескольких компонентах
- Для управления аутентификацией и сессией
- Для хранения данных, полученных с сервера
- Для настроек приложения
- Для состояния UI, влияющего на всю систему

## Лучшие практики

- Используйте глобальное состояние только для данных, действительно нуждающихся в глобальном доступе
- Разделяйте состояние на логические модули/слайсы
- Используйте типизацию (TypeScript) для предотвращения ошибок
- Обеспечьте сохранение состояния между сессиями при необходимости
- Оптимизируйте подписки для избежания лишних перерисовок

## Связанные концепции

- [[Локальное-состояние]] - для понимания разницы с локальным управлением
- [[Паттерны-управления-состоянием]] - для изучения различных архитектурных подходов
- [[Оптимизация-состояния]] - для улучшения производительности
- [[Тестирование-состояния]] - для проверки корректности работы состояния