---
aliases: [Паттерны управления состоянием, Архитектурные паттерны состояния]
tags: [frontend, state-management, architecture, patterns]
---

# Паттерны управления состоянием

## Введение

Паттерны управления состоянием - это архитектурные решения, которые определяют, как состояние приложения должно создаваться, изменяться и использоваться. Выбор правильного паттерна управления состоянием критически важен для производительности, масштабируемости и поддержки приложения.

## Основные паттерны

### 1. Локальное состояние (Local State)

Локальное состояние используется внутри отдельных компонентов и не доступно другим частям приложения. Это наиболее простой паттерн, подходящий для UI-состояний и простых данных.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

#### Когда использовать:
- Для UI-состояний (открыт/закрыт, загрузка и т.д.)
- Для форм с ограниченной сложностью
- Для временных данных, не требующих глобального доступа

#### Преимущества:
- Простота реализации
- Изолированность
- Низкая сложность

#### Недостатки:
- Невозможность доступа из других компонентов
- Повторение кода при необходимости общего состояния

### 2. Подъем состояния (Lifting State Up)

Паттерн, при котором состояние поднимается до общего родительского компонента, чтобы обеспечить доступ к нему дочерним компонентам.

```jsx
import React, { useState } from 'react';

function ParentComponent() {
  const [sharedValue, setSharedValue] = useState('');

  return (
    <div>
      <ChildA value={sharedValue} setValue={setSharedValue} />
      <ChildB value={sharedValue} />
    </div>
  );
}

function ChildA({ value, setValue }) {
  return (
    <input 
      value={value} 
      onChange={(e) => setValue(e.target.value)} 
      placeholder="Введите значение"
    />
  );
}

function ChildB({ value }) {
  return <p>Значение: {value}</p>;
}
```

#### Когда использовать:
- Когда несколько компонентов нуждаются в доступе к одному состоянию
- Для простых случаев, когда не нужен сложный менеджер состояния

#### Преимущества:
- Централизованное управление состоянием
- Четкая иерархия данных

#### Недостатки:
- Проп-дриллинг при глубокой иерархии
- Сложность при увеличении количества компонентов

### 3. Контекст (Context)

Паттерн, который позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на каждом уровне.

```jsx
import React, { createContext, useContext, useReducer } from 'react';

const ThemeContext = createContext();

function themeReducer(state, action) {
  switch (action.type) {
    case 'TOGGLE_THEME':
      return { ...state, theme: state.theme === 'light' ? 'dark' : 'light' };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    default:
      return state;
  }
}

function ThemeProvider({ children }) {
  const [state, dispatch] = useReducer(themeReducer, { 
    theme: 'light', 
    language: 'ru' 
  });

  return (
    <ThemeContext.Provider value={{ state, dispatch }}>
      {children}
    </ThemeContext.Provider>
  );
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// Использование
function Header() {
  const { state, dispatch } = useTheme();
  
  return (
    <header className={state.theme}>
      <button onClick={() => dispatch({ type: 'TOGGLE_THEME' })}>
        Переключить тему
      </button>
    </header>
  );
}
```

#### Когда использовать:
- Для данных, которые нужны во многих компонентах
- Для настроек приложения
- Для темизации и локализации

#### Преимущества:
- Избегает проп-дриллинга
- Простота реализации
- Интеграция с React

#### Недостатки:
- Все компоненты, использующие контекст, будут перерисовываться при изменении
- Сложность тестирования
- Ограниченные возможности отладки

### 4. Flux/Redux

Архитектурный паттерн, основанный на одностороннем потоке данных, с централизованным хранилищем состояния.

```javascript
// Redux Toolkit
import { createSlice, configureStore } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
  },
});

// Использование в компоненте
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

#### Когда использовать:
- Для сложных приложений с множеством состояний
- Когда нужен детальный контроль над изменениями состояния
- Для командной разработки с единым подходом

#### Преимущества:
- Предсказуемость изменений
- Отличные возможности отладки
- Возможность отката изменений
- Богатая экосистема инструментов

#### Недостатки:
- Высокая сложность для простых приложений
- Много шаблонного кода
- Кривая обучения

### 5. Flux с использованием MobX

Паттерн, основанный на реактивном программировании, где состояние автоматически отслеживается и обновляется.

```javascript
import { makeObservable, observable, action, computed } from 'mobx';
import { observer } from 'mobx-react-lite';

class TodoStore {
  todos = [];
  
  constructor() {
    makeObservable(this, {
      todos: observable,
      completedTodosCount: computed,
      addTodo: action,
      removeTodo: action,
    });
  }
  
  get completedTodosCount() {
    return this.todos.filter(todo => todo.completed).length;
  }
  
  addTodo(title) {
    this.todos.push({
      id: Date.now(),
      title,
      completed: false,
    });
  }
  
  removeTodo(id) {
    this.todos = this.todos.filter(todo => todo.id !== id);
  }
}

const todoStore = new TodoStore();

const TodoList = observer(() => {
  return (
    <div>
      <p>Выполнено: {todoStore.completedTodosCount}</p>
      <button onClick={() => todoStore.addTodo('Новое дело')}>
        Добавить
      </button>
      {todoStore.todos.map(todo => (
        <div key={todo.id}>
          <span>{todo.title}</span>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => todo.completed = !todo.completed}
          />
        </div>
      ))}
    </div>
  );
});
```

#### Когда использовать:
- Для сложных реактивных приложений
- Когда нужна максимальная производительность
- Для приложений с частыми изменениями состояния

#### Преимущества:
- Автоматическое отслеживание изменений
- Высокая производительность
- Меньше шаблонного кода
- Гибкость

#### Недостатки:
- Более сложная модель мышления
- Сложнее отладка
- Меньше предсказуемости

### 6. Zustand

Современный, легковесный паттерн управления состоянием с минимальным API.

```javascript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

const useStore = create(
  devtools((set, get) => ({
    bears: 0,
    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
    removeAllBears: () => set({ bears: 0 }),
    updateBears: (newBears) => set({ bears: newBears }),
  }))
);

function BearCounter() {
  const bears = useStore((state) => state.bears);
  const increasePopulation = useStore((state) => state.increasePopulation);

  return (
    <div>
      <p>Медведей: {bears}</p>
      <button onClick={increasePopulation}>Добавить медведя</button>
    </div>
  );
}
```

#### Когда использовать:
- Для приложений средней сложности
- Когда нужен простой, но мощный менеджер состояния
- Для быстрой разработки

#### Преимущества:
- Простота и легковесность
- Меньше шаблонного кода
- Хорошая интеграция с TypeScript
- Поддержка middleware

#### Недостатки:
- Меньше инструментов отладки по сравнению с Redux
- Меньше зрелой экосистемы

## Выбор подходящего паттерна

При выборе паттерна управления состоянием необходимо учитывать:

### 1. Размер и сложность приложения
- **Маленькие приложения**: Локальное состояние, подъем состояния
- **Средние приложения**: Context API, Zustand
- **Крупные приложения**: Redux, MobX

### 2. Команда разработчиков
- **Маленькая команда/один разработчик**: Zustand, Context
- **Крупная команда**: Redux (для единообразия)

### 3. Тип данных
- **UI-состояния**: Локальное состояние
- **Бизнес-данные**: Глобальное состояние (Redux, Zustand)
- **Конфигурация приложения**: Context API

### 4. Производительность
- **Частые обновления**: MobX
- **Редкие обновления**: Redux, Zustand

## Архитектурные соображения

### 1. Изолированность
Состояние должно быть изолировано настолько, насколько это возможно. Локальное состояние не должно влиять на глобальное и наоборот.

### 2. Предсказуемость
Изменения состояния должны быть предсказуемыми и отслеживаемыми. Это особенно важно для отладки.

### 3. Тестируемость
Паттерн управления состоянием должен обеспечивать легкость тестирования. Функции изменения состояния должны быть чистыми и изолированными.

### 4. Производительность
Выбранный паттерн не должен создавать избыточные перерисовки компонентов или замедлять приложение.

## Современные тенденции

### 1. Композиция паттернов
Современные приложения часто используют комбинацию паттернов:
- Локальное состояние для UI
- Context для настроек приложения
- Redux/Zustand для бизнес-логики

### 2. Состояние как услуга (State as a Service)
Использование внешних сервисов для управления состоянием, особенно в распределенных приложениях.

### 3. Функциональные подходы
Все больше приложений используют функциональные подходы к управлению состоянием, такие как Redux Toolkit с createSlice.

## Заключение

Выбор правильного паттерна управления состоянием - критический архитектурный выбор, который влияет на всю разработку приложения. Не существует универсального решения, и паттерн должен выбираться в зависимости от конкретных требований проекта, размера команды и сложности приложения.

## Связанные концепции

- [[Локальное-состояние]] - для понимания базового управления состоянием
- [[Глобальное-состояние]] - для понимания централизованного подхода
- [[Оптимизация-состояния]] - для улучшения производительности
- [[Тестирование-состояния]] - для проверки корректности работы