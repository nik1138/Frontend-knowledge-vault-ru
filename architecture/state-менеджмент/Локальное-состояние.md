---
aliases: [Локальное состояние, Управление локальным состоянием]
tags: [frontend, state-management, architecture]
---

# Локальное состояние

## Определение

Локальное состояние (local state) - это данные, которые принадлежат и управляются конкретным компонентом в приложении. Оно не влияет на другие компоненты и не требует глобального доступа. Локальное состояние идеально подходит для управления небольшими объемами данных, которые не должны быть доступны за пределами компонента.

## Примеры использования локального состояния

- Формы и элементы управления (input, checkbox, radio)
- Открытые/закрытые состояния для модальных окон и аккордеонов
- Временные данные, такие как фильтры, сортировка или пагинация
- Анимации и UI-состояния (например, загрузка, ошибка)

## Реализация в различных фреймворках

### React

В React локальное состояние можно реализовать с помощью хука `useState`:

```jsx
import React, { useState } from 'react';

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const handleSearch = async (term) => {
    setIsLoading(true);
    try {
      // Имитация поиска
      const searchResults = await mockSearch(term);
      setResults(searchResults);
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Поиск..."
        onKeyPress={(e) => e.key === 'Enter' && handleSearch(searchTerm)}
      />
      {isLoading ? (
        <div>Загрузка...</div>
      ) : (
        <ul>
          {results.map((result, index) => (
            <li key={index}>{result}</li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

Также можно использовать `useReducer` для более сложной логики управления состоянием:

```jsx
import React, { useReducer } from 'react';

const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        [action.field]: action.value,
        errors: { ...state.errors, [action.field]: '' }
      };
    case 'SET_ERROR':
      return {
        ...state,
        errors: { ...state.errors, [action.field]: action.message }
      };
    case 'RESET_FORM':
      return { email: '', password: '', errors: {} };
    default:
      return state;
  }
};

function LoginForm() {
  const [state, dispatch] = useReducer(formReducer, {
    email: '',
    password: '',
    errors: {}
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!state.email) {
      dispatch({ type: 'SET_ERROR', field: 'email', message: 'Email обязателен' });
      return;
    }
    // Логика отправки формы
    console.log('Form submitted:', state);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={state.email}
        onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'email', value: e.target.value })}
        placeholder="Email"
      />
      {state.errors.email && <span className="error">{state.errors.email}</span>}
      
      <input
        type="password"
        value={state.password}
        onChange={(e) => dispatch({ type: 'SET_FIELD', field: 'password', value: e.target.value })}
        placeholder="Password"
      />
      
      <button type="submit">Войти</button>
    </form>
  );
}
```

### Vue.js

В Vue.js локальное состояние реализуется через `data` в Options API или `ref`/`reactive` в Composition API:

```vue
<template>
  <div>
    <h2>Форма обратной связи</h2>
    <form @submit.prevent="submitForm">
      <input
        v-model="formData.name"
        type="text"
        placeholder="Имя"
      />
      <textarea
        v-model="formData.message"
        placeholder="Сообщение"
      ></textarea>
      <button type="submit" :disabled="isSubmitting">
        {{ isSubmitting ? 'Отправка...' : 'Отправить' }}
      </button>
    </form>
    <div v-if="submitSuccess" class="success">
      Сообщение отправлено успешно!
    </div>
  </div>
</template>

<script>
import { ref, reactive } from 'vue';

export default {
  name: 'FeedbackForm',
  setup() {
    const formData = reactive({
      name: '',
      message: ''
    });
    
    const isSubmitting = ref(false);
    const submitSuccess = ref(false);

    const submitForm = async () => {
      isSubmitting.value = true;
      try {
        // Имитация отправки формы
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log('Форма отправлена:', formData);
        submitSuccess.value = true;
        formData.name = '';
        formData.message = '';
      } catch (error) {
        console.error('Ошибка отправки:', error);
      } finally {
        isSubmitting.value = false;
      }
    };

    return {
      formData,
      isSubmitting,
      submitSuccess,
      submitForm
    };
  }
};
</script>
```

### Angular

В Angular локальное состояние управляется через свойства компонента:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `
    <div>
      <h2>Профиль пользователя</h2>
      <div *ngIf="loading">Загрузка...</div>
      <div *ngIf="!loading && user">
        <p>Имя: {{ user.name }}</p>
        <p>Email: {{ user.email }}</p>
        <button (click)="toggleEdit()">Редактировать</button>
      </div>
      
      <div *ngIf="editing" class="edit-form">
        <input [(ngModel)]="editForm.name" placeholder="Имя" />
        <input [(ngModel)]="editForm.email" placeholder="Email" />
        <button (click)="saveChanges()">Сохранить</button>
        <button (click)="cancelEdit()">Отмена</button>
      </div>
    </div>
  `
})
export class UserProfileComponent {
  user: any = null;
  loading = true;
  editing = false;
  
  editForm = {
    name: '',
    email: ''
  };

  ngOnInit() {
    this.loadUser();
  }

  async loadUser() {
    try {
      // Имитация загрузки данных
      this.user = await this.mockLoadUser();
      this.editForm = { ...this.user };
    } catch (error) {
      console.error('Ошибка загрузки пользователя:', error);
    } finally {
      this.loading = false;
    }
  }

  toggleEdit() {
    this.editing = !this.editing;
    if (this.editing) {
      this.editForm = { ...this.user };
    }
  }

  async saveChanges() {
    try {
      // Имитация сохранения
      this.user = { ...this.user, ...this.editForm };
      this.toggleEdit();
    } catch (error) {
      console.error('Ошибка сохранения:', error);
    }
  }

  cancelEdit() {
    this.editForm = { ...this.user };
    this.toggleEdit();
  }

  mockLoadUser() {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({ id: 1, name: 'Иван Иванов', email: 'ivan@example.com' });
      }, 1000);
    });
  }
}
```

## Преимущества локального состояния

- **Изолированность**: Состояние компонента не влияет на другие компоненты
- **Простота**: Простая логика управления без дополнительных зависимостей
- **Производительность**: Обновления происходят только в конкретном компоненте
- **Предсказуемость**: Легче отлаживать, так как состояние локализовано

## Когда использовать локальное состояние

- Для UI-состояний (открыт/закрыт, загрузка и т.д.)
- Для форм с ограниченной сложностью
- Для временных данных, не требующих глобального доступа
- При разработке независимых компонентов

## Когда избегать локального состояния

- Если состояние должно быть доступно в нескольких компонентах
- Если состояние нужно сохранять между переходами по приложению
- Если состояние влияет на работу всего приложения

## Лучшие практики

- Используйте локальное состояние для UI-логики и простых данных
- Не храните в локальном состоянии данные, которые нужны другим компонентам
- Используйте callback-функции для передачи данных родительским компонентам
- Разделяйте состояние на локальное и пропсы для лучшей читаемости

## Связанные концепции

- [[Глобальное-состояние]] - для управления состоянием на уровне приложения
- [[Паттерны-управления-состоянием]] - для понимания различных подходов
- [[Оптимизация-состояния]] - для улучшения производительности
- [[Тестирование-состояния]] - для проверки корректности работы состояния