---
aliases: [Тестирование состояния, Тестирование управления состоянием]
tags: [frontend, state-management, testing, architecture]
---

# Тестирование состояния

## Введение

Тестирование состояния - это критический аспект разработки приложений, который обеспечивает корректную работу системы управления состоянием. Поскольку состояние влияет на поведение всего приложения, его тестирование требует особого внимания к деталям и понимания архитектурных паттернов.

## Типы тестов для состояния

### 1. Модульные тесты (Unit Tests)

Модульные тесты проверяют отдельные компоненты системы управления состоянием: редьюсеры, селекторы, действия (actions) и хуки.

```javascript
// Тестирование редьюсера
import counterReducer, { increment, decrement, incrementByAmount } from './counterSlice';

describe('counter reducer', () => {
  const initialState = {
    value: 3,
    loading: false
  };

  it('should handle initial state', () => {
    expect(counterReducer(undefined, { type: 'unknown' })).toEqual({
      value: 0,
      loading: false
    });
  });

  it('should handle increment', () => {
    const actual = counterReducer(initialState, increment());
    expect(actual.value).toEqual(4);
  });

  it('should handle decrement', () => {
    const actual = counterReducer(initialState, decrement());
    expect(actual.value).toEqual(2);
  });

  it('should handle incrementByAmount', () => {
    const actual = counterReducer(initialState, incrementByAmount(2));
    expect(actual.value).toEqual(5);
  });
});

// Тестирование селектора
import { selectCurrentUser, selectUserPermissions } from './userSelectors';

describe('user selectors', () => {
  const mockState = {
    user: {
      profile: { id: 1, name: 'John', role: 'admin' },
      permissions: ['read', 'write', 'delete']
    }
  };

  it('should select current user', () => {
    expect(selectCurrentUser(mockState)).toEqual(mockState.user.profile);
  });

  it('should select user permissions', () => {
    expect(selectUserPermissions(mockState)).toEqual(mockState.user.permissions);
  });
});
```

### 2. Интеграционные тесты (Integration Tests)

Интеграционные тесты проверяют взаимодействие между различными частями системы управления состоянием, например, между компонентами и хранилищем.

```javascript
// Тестирование компонента с Redux
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import Counter from './Counter';
import counterReducer from './counterSlice';

describe('Counter component', () => {
  let store;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        counter: counterReducer,
      },
    });
  });

  test('should render initial count', () => {
    render(
      <Provider store={store}>
        <Counter />
      </Provider>
    );
    
    expect(screen.getByText('0')).toBeInTheDocument();
  });

  test('should increment value when button is clicked', async () => {
    render(
      <Provider store={store}>
        <Counter />
      </Provider>
    );
    
    fireEvent.click(screen.getByText('+'));
    
    await waitFor(() => {
      expect(screen.getByText('1')).toBeInTheDocument();
    });
  });
});

// Тестирование с Zustand
import { renderHook, act } from '@testing-library/react-hooks';
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

const useStore = create(
  devtools((set, get) => ({
    bears: 0,
    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
    removeAllBears: () => set({ bears: 0 }),
  }))
);

test('should increase bear count', () => {
  act(() => {
    useStore.getState().increasePopulation();
  });
  
  expect(useStore.getState().bears).toBe(1);
});

test('should reset bear count', () => {
  act(() => {
    useStore.getState().increasePopulation();
    useStore.getState().increasePopulation();
    useStore.getState().removeAllBears();
  });
  
  expect(useStore.getState().bears).toBe(0);
});
```

### 3. Тесты поведения (Behavioral Tests)

Тесты поведения проверяют, как приложение реагирует на различные действия пользователя и изменения состояния.

```javascript
// Тестирование сложного взаимодействия
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from './App';

describe('Shopping Cart Behavior', () => {
  test('should add item to cart and update count', async () => {
    render(<App />);
    
    // Добавляем товар в корзину
    const addToCartButton = screen.getByText('Add to Cart');
    fireEvent.click(addToCartButton);
    
    // Проверяем, что количество в корзине увеличилось
    await waitFor(() => {
      expect(screen.getByTestId('cart-count')).toHaveTextContent('1');
    });
  });

  test('should persist cart state after page reload', async () => {
    render(<App />);
    
    // Добавляем товар в корзину
    fireEvent.click(screen.getByText('Add to Cart'));
    
    // Симулируем перезагрузку страницы
    render(<App />);
    
    // Проверяем, что состояние сохранилось
    await waitFor(() => {
      expect(screen.getByTestId('cart-count')).toHaveTextContent('1');
    });
  });
});
```

## Тестирование различных паттернов состояния

### Redux

```javascript
// Тестирование асинхронных действий
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import { fetchUserById } from './userActions';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe('async actions', () => {
  it('should create FETCH_USER_SUCCESS when fetching user has been done', async () => {
    const userId = 1;
    const expectedActions = [
      { type: 'FETCH_USER_REQUEST' },
      { type: 'FETCH_USER_SUCCESS', payload: { id: userId, name: 'John' } }
    ];
    
    const store = mockStore({ user: {} });
    
    await store.dispatch(fetchUserById(userId));
    
    expect(store.getActions()).toEqual(expectedActions);
  });
});

// Тестирование сложного редьюсера
import { combineReducers } from 'redux';
import { userReducer, postsReducer } from './reducers';

const rootReducer = combineReducers({
  user: userReducer,
  posts: postsReducer
});

describe('root reducer', () => {
  it('should handle combined state changes', () => {
    const action = { type: 'USER_LOGIN', payload: { id: 1, name: 'John' } };
    const newState = rootReducer({}, action);
    
    expect(newState.user).toEqual({ id: 1, name: 'John' });
  });
});
```

### Context API

```javascript
// Тестирование компонентов с Context
import { render, screen } from '@testing-library/react';
import ThemeProvider, { useTheme } from '../contexts/ThemeContext';

const TestComponent = () => {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <div data-testid="theme-display">
      {theme}
      <button onClick={toggleTheme}>Toggle</button>
    </div>
  );
};

const renderWithProvider = (component) => {
  return render(
    <ThemeProvider>
      {component}
    </ThemeProvider>
  );
};

describe('Theme Context', () => {
  test('should toggle theme', () => {
    renderWithProvider(<TestComponent />);
    
    expect(screen.getByTestId('theme-display')).toHaveTextContent('light');
    
    fireEvent.click(screen.getByText('Toggle'));
    
    expect(screen.getByTestId('theme-display')).toHaveTextContent('dark');
  });
});
```

### Zustand

```javascript
// Тестирование Zustand store
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useUserStore = create(
  persist(
    (set, get) => ({
      user: null,
      login: (userData) => set({ user: userData }),
      logout: () => set({ user: null }),
      updateUser: (newData) => set((state) => ({ 
        user: { ...state.user, ...newData } 
      })),
    }),
    { name: 'user-storage' }
  )
);

describe('User Store', () => {
  beforeEach(() => {
    // Сброс состояния перед каждым тестом
    useUserStore.setState({ user: null });
  });

  test('should login user', () => {
    const userData = { id: 1, name: 'John', email: 'john@example.com' };
    
    useUserStore.getState().login(userData);
    
    expect(useUserStore.getState().user).toEqual(userData);
    expect(useUserStore.getState().isAuthenticated).toBe(true);
  });

  test('should update user data', () => {
    const initialData = { id: 1, name: 'John', email: 'john@example.com' };
    const updateData = { name: 'Jane' };
    
    useUserStore.getState().login(initialData);
    useUserStore.getState().updateUser(updateData);
    
    expect(useUserStore.getState().user.name).toBe('Jane');
    expect(useUserStore.getState().user.email).toBe('john@example.com');
  });

  test('should logout user', () => {
    useUserStore.getState().login({ id: 1, name: 'John' });
    useUserStore.getState().logout();
    
    expect(useUserStore.getState().user).toBeNull();
    expect(useUserStore.getState().isAuthenticated).toBe(false);
  });
});
```

## Тестирование сложных сценариев

### Тестирование сайд-эффектов

```javascript
// Тестирование с использованием Redux-Saga
import { runSaga } from 'redux-saga-test-plan';
import { fetchUserSaga, fetchUserRequest } from './userSaga';

describe('User Saga', () => {
  test('should fetch user successfully', async () => {
    const dispatchedActions = [];
    
    await runSaga({
      dispatch: (action) => dispatchedActions.push(action),
      getState: () => ({}),
    }, fetchUserSaga, fetchUserRequest(1)).toPromise();
    
    const successAction = dispatchedActions.find(action => action.type === 'FETCH_USER_SUCCESS');
    expect(successAction).toBeDefined();
    expect(successAction.payload).toEqual({ id: 1, name: 'John' });
  });
});

// Тестирование с RTK Query
import { setupServer } from 'msw/node';
import { rest } from 'msw';
import { api } from './api';

const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(
      ctx.json({ id: 1, name: 'John', email: 'john@example.com' })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

test('should fetch user with RTK Query', async () => {
  const store = configureStore({
    reducer: {
      [api.reducerPath]: api.reducer,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware().concat(api.middleware),
  });
  
  const result = await store.dispatch(api.endpoints.getUser.initiate(1));
  
  expect(result.data).toEqual({ id: 1, name: 'John', email: 'john@example.com' });
});
```

### Тестирование оптимистичных обновлений

```javascript
// Тестирование оптимистичных обновлений
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

const updateUser = createAsyncThunk(
  'users/updateUser',
  async ({ id, userData }, { rejectWithValue }) => {
    try {
      const response = await api.put(`/users/${id}`, userData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState: { entities: {}, loading: false, error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(updateUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateUser.fulfilled, (state, action) => {
        state.loading = false;
        state.entities[action.payload.id] = action.payload;
      })
      .addCase(updateUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  }
});

// Тест оптимистичного обновления
test('should handle optimistic update', async () => {
  const store = configureStore({
    reducer: {
      users: usersSlice.reducer,
    },
  });
  
  // Оптимистично обновляем состояние
  const optimisticUpdate = { id: 1, name: 'Updated Name' };
  store.dispatch({ type: 'users/optimisticUpdate', payload: optimisticUpdate });
  
  expect(store.getState().users.entities[1].name).toBe('Updated Name');
  
  // Выполняем асинхронное действие
  await store.dispatch(updateUser({ id: 1, userData: { name: 'Updated Name' } }));
  
  // Проверяем, что состояние обновилось окончательно
  expect(store.getState().users.entities[1].name).toBe('Updated Name');
});
```

## Лучшие практики тестирования состояния

### 1. Изолированное тестирование

```javascript
// Тестирование селекторов изолированно
import { createSelector } from 'reselect';

export const selectUserIds = state => state.users.ids;
export const selectUserEntities = state => state.users.entities;

export const selectAllUsers = createSelector(
  [selectUserIds, selectUserEntities],
  (ids, entities) => ids.map(id => entities[id])
);

// Тест изолированного селектора
describe('selectAllUsers selector', () => {
  const mockState = {
    users: {
      ids: [1, 2, 3],
      entities: {
        1: { id: 1, name: 'John' },
        2: { id: 2, name: 'Jane' },
        3: { id: 3, name: 'Bob' }
      }
    }
  };
  
  it('should return all users', () => {
    const result = selectAllUsers(mockState);
    expect(result).toEqual([
      { id: 1, name: 'John' },
      { id: 2, name: 'Jane' },
      { id: 3, name: 'Bob' }
    ]);
  });
});
```

### 2. Тестирование граничных условий

```javascript
// Тестирование граничных условий
describe('Cart reducer', () => {
  it('should handle empty cart', () => {
    const initialState = { items: [], total: 0 };
    const newState = cartReducer(initialState, { type: 'UNKNOWN_ACTION' });
    expect(newState).toEqual(initialState);
  });
  
  it('should handle adding first item', () => {
    const initialState = { items: [], total: 0 };
    const action = { type: 'ADD_ITEM', payload: { id: 1, price: 10 } };
    const newState = cartReducer(initialState, action);
    
    expect(newState.items).toHaveLength(1);
    expect(newState.total).toBe(10);
  });
  
  it('should handle removing last item', () => {
    const initialState = { items: [{ id: 1, price: 10 }], total: 10 };
    const action = { type: 'REMOVE_ITEM', payload: 1 };
    const newState = cartReducer(initialState, action);
    
    expect(newState.items).toHaveLength(0);
    expect(newState.total).toBe(0);
  });
});
```

### 3. Тестирование производительности

```javascript
// Тестирование производительности селекторов
describe('Performance tests', () => {
  test('selector should be memoized', () => {
    const largeState = {
      items: Array.from({ length: 10000 }, (_, i) => ({ id: i, name: `Item ${i}` }))
    };
    
    // Первый вызов
    const start = performance.now();
    selectAllItems(largeState);
    const firstCallTime = performance.now() - start;
    
    // Второй вызов с теми же данными
    const start2 = performance.now();
    selectAllItems(largeState);
    const secondCallTime = performance.now() - start2;
    
    // Второй вызов должен быть значительно быстрее благодаря мемоизации
    expect(secondCallTime).toBeLessThan(firstCallTime / 2);
  });
});
```

## Инструменты для тестирования состояния

### 1. Redux DevTools для тестирования
```javascript
// Использование Redux DevTools для отладки тестов
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Отключаем проверку сериализации в тестах
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    }),
});
```

### 2. Mock-объекты и тестовые утилиты
```javascript
// Создание тестового хранилища
export const createTestStore = (initialState = {}) => {
  return configureStore({
    reducer: rootReducer,
    preloadedState: initialState,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware().concat(logger), // добавляем логгер для отладки
  });
};

// Тестовый компонент для проверки состояния
export const TestComponent = ({ selector, children }) => {
  const value = useSelector(selector);
  return children(value);
};
```

## Заключение

Тестирование состояния - это многоуровневый процесс, который требует понимания архитектуры приложения и различных паттернов управления состоянием. Эффективные тесты состояния обеспечивают стабильность, надежность и предсказуемость поведения приложения.

Ключевые принципы тестирования состояния:
- Тестирование на всех уровнях (модульном, интеграционном, функциональном)
- Изолированное тестирование компонентов системы управления состоянием
- Проверка граничных условий и ошибочных сценариев
- Тестирование производительности и мемоизации
- Использование соответствующих инструментов и библиотек

## Связанные концепции

- [[Локальное-состояние]] - для понимания тестирования изолированных состояний
- [[Глобальное-состояние]] - для понимания тестирования централизованных данных
- [[Паттерны-управления-состоянием]] - для выбора подходящего архитектурного решения
- [[Оптимизация-состояния]] - для обеспечения производительности тестируемого кода