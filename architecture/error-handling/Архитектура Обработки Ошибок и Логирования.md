# Архитектура Обработки Ошибок и Логирования

Архитектура обработки ошибок и логирования — это фундаментальный аспект разработки надежных и поддерживаемых веб-приложений. Хорошо спроектированная система обработки ошибок и логирования позволяет быстро выявлять, диагностировать и устранять проблемы, а также собирать ценную информацию о поведении пользователей и производительности приложения.

## Что такое Обработка Ошибок и Логирование

Обработка ошибок — это процесс перехвата, анализа и корректного реагирования на исключительные ситуации, возникающие во время выполнения приложения. Логирование — это процесс записи информации о событиях, происходящих в приложении, для последующего анализа и отладки.

## Типы Ошибок в Frontend Приложениях

### 1. Синтаксические Ошибки (Syntax Errors)

Ошибки, возникающие при парсинге кода JavaScript.

Пример:
```javascript
// Ошибка синтаксиса - отсутствует закрывающая скобка
function calculateSum(a, b {
  return a + b;
}
```

### 2. Ошибки Времени Выполнения (Runtime Errors)

Ошибки, возникающие во время выполнения кода.

Пример:
```javascript
// TypeError - попытка вызвать метод у undefined
const user = undefined;
console.log(user.getName()); // TypeError: Cannot read property 'getName' of undefined
```

### 3. Логические Ошибки (Logic Errors)

Ошибки в логике программы, которые не вызывают исключений, но приводят к неправильному результату.

Пример:
```javascript
// Логическая ошибка - неправильное условие
function isAdult(age) {
  return age > 18; // Должно быть age >= 18
}
```

### 4. Асинхронные Ошибки

Ошибки, возникающие в асинхронном коде.

Пример:
```javascript
// Ошибка в Promise
fetch('/api/data')
  .then(response => response.json())
  .then(data => {
    // Обработка данных
  })
  .catch(error => {
    // Обработка ошибки
    console.error('Fetch error:', error);
  });
```

## Архитектурные Подходы к Обработке Ошибок

### 1. Централизованная Обработка Ошибок

Подход, при котором все ошибки обрабатываются в одном месте.

Пример:
```javascript
// Глобальный обработчик ошибок
class ErrorHandler {
  static handle(error, context = '') {
    // Логирование ошибки
    this.logError(error, context);
    
    // Отправка в систему мониторинга
    this.reportError(error, context);
    
    // Отображение пользователю
    this.displayError(error);
  }
  
  static logError(error, context) {
    console.error(`Error in ${context}:`, error);
    
    // Запись в локальное хранилище
    const errorLog = {
      timestamp: new Date().toISOString(),
      message: error.message,
      stack: error.stack,
      context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // Сохранение в localStorage
    const logs = JSON.parse(localStorage.getItem('errorLogs') || '[]');
    logs.push(errorLog);
    localStorage.setItem('errorLogs', JSON.stringify(logs));
  }
  
  static reportError(error, context) {
    // Отправка в систему мониторинга (например, Sentry, LogRocket)
    if (window.Sentry) {
      Sentry.captureException(error, {
        contexts: {
          context: { value: context }
        }
      });
    }
  }
  
  static displayError(error) {
    // Отображение пользовательского сообщения
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
      errorElement.textContent = 'Произошла ошибка. Мы работаем над ее устранением.';
      errorElement.style.display = 'block';
      
      // Автоматическое скрытие через 5 секунд
      setTimeout(() => {
        errorElement.style.display = 'none';
      }, 5000);
    }
  }
}

// Глобальный обработчик необработанных ошибок
window.addEventListener('error', (event) => {
  ErrorHandler.handle(event.error, 'Global Error Handler');
});

// Глобальный обработчик необработанных Promise ошибок
window.addEventListener('unhandledrejection', (event) => {
  ErrorHandler.handle(event.reason, 'Unhandled Promise Rejection');
});
```

### 2. Обработка Ошибок на Уровне Компонентов

Подход, при котором каждый компонент отвечает за обработку своих ошибок.

Пример (React):
```javascript
// Error Boundary в React
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // Логирование ошибки
    ErrorHandler.logError(error, 'React Component Error Boundary');
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Что-то пошло не так.</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
          <button onClick={() => window.location.reload()}>
            Перезагрузить страницу
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Использование
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

### 3. Обработка Ошибок в Асинхронных Операциях

Пример обработки ошибок в API вызовах:
```javascript
// Универсальный API клиент с обработкой ошибок
class ApiClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = {
      headers: {
        'Content-Type': 'application/json',
      },
      ...options
    };
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...this.defaultOptions,
      ...options
    };
    
    try {
      const response = await fetch(url, config);
      
      // Обработка HTTP ошибок
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new ApiError(
          response.status,
          response.statusText,
          errorData.message || 'API request failed'
        );
      }
      
      return await response.json();
    } catch (error) {
      // Обработка сетевых ошибок и других исключений
      if (error instanceof ApiError) {
        // Это ошибка API, обрабатываем специфично
        this.handleApiError(error, endpoint);
        throw error;
      } else {
        // Это сетевая ошибка или другая проблема
        const networkError = new NetworkError(
          error.message || 'Network error occurred'
        );
        this.handleNetworkError(networkError, endpoint);
        throw networkError;
      }
    }
  }
  
  handleApiError(error, endpoint) {
    // Логирование ошибки API
    ErrorHandler.logError(error, `API Error: ${endpoint}`);
    
    // Специфичная обработка в зависимости от кода ошибки
    switch (error.status) {
      case 401:
        // Неавторизован - перенаправить на страницу входа
        this.redirectToLogin();
        break;
      case 403:
        // Запрещено - показать сообщение о доступе
        this.showAccessDeniedMessage();
        break;
      case 404:
        // Не найдено - показать сообщение 404
        this.showNotFoundMessage();
        break;
      case 500:
        // Внутренняя ошибка сервера - показать общее сообщение
        this.showServerError();
        break;
      default:
        // Другие ошибки - показать общее сообщение
        this.showGenericError();
    }
  }
  
  handleNetworkError(error, endpoint) {
    // Логирование сетевой ошибки
    ErrorHandler.logError(error, `Network Error: ${endpoint}`);
    
    // Показать сообщение о проблемах с сетью
    this.showNetworkErrorMessage();
  }
}

// Пользовательские классы ошибок
class ApiError extends Error {
  constructor(status, statusText, message) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.statusText = statusText;
  }
}

class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}
```

## Логирование в Frontend Приложениях

### 1. Уровни Логирования

```javascript
// Система логирования с уровнями
class Logger {
  constructor(level = 'info') {
    this.level = level;
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };
  }
  
  error(message, ...args) {
    if (this.levels[this.level] >= this.levels.error) {
      console.error(`[ERROR] ${new Date().toISOString()}: ${message}`, ...args);
      this.sendToServer('error', message, args);
    }
  }
  
  warn(message, ...args) {
    if (this.levels[this.level] >= this.levels.warn) {
      console.warn(`[WARN] ${new Date().toISOString()}: ${message}`, ...args);
      this.sendToServer('warn', message, args);
    }
  }
  
  info(message, ...args) {
    if (this.levels[this.level] >= this.levels.info) {
      console.info(`[INFO] ${new Date().toISOString()}: ${message}`, ...args);
      this.sendToServer('info', message, args);
    }
  }
  
  debug(message, ...args) {
    if (this.levels[this.level] >= this.levels.debug) {
      console.debug(`[DEBUG] ${new Date().toISOString()}: ${message}`, ...args);
      this.sendToServer('debug', message, args);
    }
  }
  
  sendToServer(level, message, args) {
    // Отправка логов на сервер для анализа
    if (navigator.sendBeacon) {
      const logData = {
        level,
        message,
        args,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent
      };
      
      navigator.sendBeacon('/api/logs', JSON.stringify(logData));
    }
  }
}

// Использование
const logger = new Logger(process.env.NODE_ENV === 'production' ? 'warn' : 'debug');

logger.info('Application started');
logger.debug('User data loaded', userData);
logger.warn('Deprecated API used', { endpoint: '/api/old-endpoint' });
logger.error('Failed to load user data', error);
```

### 2. Структурированное Логирование

```javascript
// Структурированное логирование с контекстом
class StructuredLogger {
  constructor() {
    this.context = {};
  }
  
  setContext(key, value) {
    this.context[key] = value;
  }
  
  log(level, message, data = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: this.context,
      data,
      url: window.location.href,
      userAgent: navigator.userAgent,
      sessionId: this.getSessionId()
    };
    
    console.log(JSON.stringify(logEntry));
    
    // Отправка в систему аналитики
    this.sendToAnalytics(logEntry);
  }
  
  getSessionId() {
    let sessionId = sessionStorage.getItem('sessionId');
    if (!sessionId) {
      sessionId = this.generateSessionId();
      sessionStorage.setItem('sessionId', sessionId);
    }
    return sessionId;
  }
  
  generateSessionId() {
    return 'session_' + Math.random().toString(36).substr(2, 9);
  }
  
  sendToAnalytics(logEntry) {
    // Отправка в систему аналитики (например, Google Analytics, Mixpanel)
    if (window.gtag) {
      gtag('event', 'log', {
        level: logEntry.level,
        message: logEntry.message,
        context: JSON.stringify(logEntry.context),
        data: JSON.stringify(logEntry.data)
      });
    }
  }
}

// Использование
const logger = new StructuredLogger();
logger.setContext('userId', 'user123');
logger.setContext('page', 'dashboard');

logger.log('info', 'User performed action', { action: 'click', element: 'button' });
```

## Мониторинг и Алертинг

### 1. Интеграция с Системами Мониторинга

```javascript
// Интеграция с Sentry
import * as Sentry from '@sentry/browser';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN',
  integrations: [
    new Sentry.Integrations.Breadcrumbs({
      console: false, // Отключить логирование консоли
    }),
  ],
  beforeSend(event, hint) {
    // Фильтрация ошибок перед отправкой
    const error = hint.originalException;
    
    // Игнорировать ошибки от расширений браузера
    if (error && error.message && 
        (error.message.includes('extension') || error.message.includes('chrome-extension'))) {
      return null;
    }
    
    return event;
  }
});

// Интеграция с LogRocket
import LogRocket from 'logrocket';

LogRocket.init('your-app-id');

// Идентификация пользователя
LogRocket.identify('user123', {
  name: 'John Doe',
  email: 'john@example.com'
});
```

### 2. Пользовательские Алерты

```javascript
// Система пользовательских алертов
class AlertManager {
  static showSuccess(message, duration = 3000) {
    this.showAlert('success', message, duration);
  }
  
  static showError(message, duration = 5000) {
    this.showAlert('error', message, duration);
  }
  
  static showWarning(message, duration = 4000) {
    this.showAlert('warning', message, duration);
  }
  
  static showInfo(message, duration = 3000) {
    this.showAlert('info', message, duration);
  }
  
  static showAlert(type, message, duration) {
    // Создание элемента алерта
    const alertElement = document.createElement('div');
    alertElement.className = `alert alert-${type}`;
    alertElement.textContent = message;
    
    // Добавление в DOM
    document.body.appendChild(alertElement);
    
    // Анимация появления
    setTimeout(() => {
      alertElement.classList.add('show');
    }, 10);
    
    // Автоматическое скрытие
    setTimeout(() => {
      alertElement.classList.remove('show');
      setTimeout(() => {
        document.body.removeChild(alertElement);
      }, 300);
    }, duration);
  }
}

// Использование
AlertManager.showSuccess('Данные успешно сохранены');
AlertManager.showError('Произошла ошибка при сохранении данных');
```

## Практики и Рекомендации

### 1. Не Игнорируйте Ошибки

```javascript
// Плохо - игнорирование ошибок
fetch('/api/data')
  .then(response => response.json())
  .then(data => {
    // Обработка данных
  });
  // Нет обработки ошибок!

// Хорошо - обработка ошибок
fetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    // Обработка данных
  })
  .catch(error => {
    console.error('Error fetching data:', error);
    // Показать пользователю сообщение об ошибке
    AlertManager.showError('Не удалось загрузить данные');
  });
```

### 2. Используйте Пользовательские Классы Ошибок

```javascript
// Базовый класс ошибки
class AppError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'AppError';
    this.code = code;
    this.details = details;
    this.timestamp = new Date().toISOString();
  }
}

// Специфичные классы ошибок
class ValidationError extends AppError {
  constructor(field, message) {
    super(`Validation error for field ${field}: ${message}`, 'VALIDATION_ERROR', { field });
    this.name = 'ValidationError';
  }
}

class NetworkError extends AppError {
  constructor(message, status) {
    super(message, 'NETWORK_ERROR', { status });
    this.name = 'NetworkError';
  }
}

// Использование
function validateUser(user) {
  if (!user.email) {
    throw new ValidationError('email', 'Email is required');
  }
  
  if (!isValidEmail(user.email)) {
    throw new ValidationError('email', 'Invalid email format');
  }
}
```

### 3. Логируйте Контекст

```javascript
// Хорошее логирование с контекстом
function processPayment(paymentData) {
  const context = {
    userId: getCurrentUserId(),
    paymentId: paymentData.id,
    amount: paymentData.amount
  };
  
  try {
    logger.info('Starting payment processing', context);
    
    const result = paymentService.process(paymentData);
    
    logger.info('Payment processed successfully', {
      ...context,
      result: result.id
    });
    
    return result;
  } catch (error) {
    logger.error('Payment processing failed', {
      ...context,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}
```

## Тестирование Обработки Ошибок

### 1. Модульные Тесты

```javascript
// Тестирование обработки ошибок
describe('ApiClient', () => {
  beforeEach(() => {
    fetch.resetMocks();
  });
  
  test('should handle network errors', async () => {
    fetch.mockReject(new Error('Network error'));
    
    const client = new ApiClient('http://api.example.com');
    
    await expect(client.request('/users'))
      .rejects
      .toThrow(NetworkError);
  });
  
  test('should handle HTTP errors', async () => {
    fetch.mockResponseOnce(JSON.stringify({ message: 'Not Found' }), {
      status: 404,
      statusText: 'Not Found'
    });
    
    const client = new ApiClient('http://api.example.com');
    
    await expect(client.request('/users'))
      .rejects
      .toThrow(ApiError);
  });
});
```

### 2. Тестирование Error Boundaries

```javascript
// Тестирование Error Boundary в React
import { render, screen } from '@testing-library/react';
import ErrorBoundary from './ErrorBoundary';

describe('ErrorBoundary', () => {
  test('should render error message when child component throws', () => {
    const BadComponent = () => {
      throw new Error('Test error');
    };
    
    render(
      <ErrorBoundary>
        <BadComponent />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Что-то пошло не так.')).toBeInTheDocument();
  });
});
```

## Связанные Концепции

- [[Архитектура]]
- [[Компонентная Архитектура]]
- [[Архитектура Тестирования]]
- [[Безопасность Frontend]]
- [[Архитектура Производительности и Оптимизации]]

## Теги

#error-handling #logging #frontend #architecture #monitoring #debugging #reliability #user-experience