---
aliases: [UI компоненты, Дизайн компоненты, Компонентный подход]
tags: [design-system, components, frontend, ui]
---

# Компоненты-дизайна

## Обзор

Компоненты-дизайна являются основой каждой дизайн-системы. Они представляют собой переиспользуемые элементы пользовательского интерфейса, созданные на основе [[Токены-дизайна]] и следующие общим принципам и стандартам. Компоненты позволяют обеспечить консистентность пользовательского интерфейса, ускорить процесс разработки и упростить поддержку проектов.

Этот документ описывает архитектуру компонентов, подходы к их созданию, структуру и лучшие практики для фронтенд-разработчиков.

## Архитектура компонентов

### Классификация компонентов

Компоненты в дизайн-системе обычно классифицируются по атомарному подходу:

#### 1. Атомы (Atoms)
Атомы - это базовые элементы интерфейса, такие как кнопки, поля ввода, чекбоксы и т.д. Они не могут быть разделены на более мелкие компоненты.

```tsx
// atoms/Button/Button.tsx
import React from 'react';
import { ButtonProps } from './Button.types';
import { getButtonStyles } from './Button.styles';

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  children,
  loading,
  icon,
  ...props
}) => {
  const styles = getButtonStyles({ variant, size, loading });
  
  return (
    <button 
      className={styles} 
      disabled={loading || props.disabled}
      {...props}
    >
      {loading && <span className="loading-spinner" />}
      {icon && <span className="button-icon">{icon}</span>}
      {children}
    </button>
  );
};
```

#### 2. Молекулы (Molecules)
Молекулы - это комбинации атомов, создающие более сложные элементы, такие как форма поиска (поле ввода + кнопка).

```tsx
// molecules/SearchForm/SearchForm.tsx
import React, { useState } from 'react';
import { Input } from '../../atoms/Input/Input';
import { Button } from '../../atoms/Button/Button';

interface SearchFormProps {
  onSearch: (query: string) => void;
}

export const SearchForm: React.FC<SearchFormProps> = ({ onSearch }) => {
  const [query, setQuery] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(query);
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Поиск..."
      />
      <Button type="submit">Найти</Button>
    </form>
  );
};
```

#### 3. Организмы (Organisms)
Организмы - это сложные структуры, состоящие из молекул и атомов, такие как навигационная панель или карточка продукта.

```tsx
// organisms/Header/Header.tsx
import React from 'react';
import { Logo } from '../../atoms/Logo/Logo';
import { Navigation } from '../Navigation/Navigation';
import { SearchForm } from '../SearchForm/SearchForm';

export const Header: React.FC = () => {
  return (
    <header className="header">
      <div className="header-container">
        <Logo />
        <Navigation />
        <SearchForm onSearch={(query) => console.log(query)} />
      </div>
    </header>
  );
};
```

#### 4. Шаблоны (Templates) и Страницы (Pages)
Шаблоны и страницы используют все вышеперечисленные компоненты для создания полноценных интерфейсов.

### Структура компонента

Каждый компонент в дизайн-системе должен следовать определенной структуре файлов:

```
components/
├── Button/
│   ├── Button.tsx          # Реализация компонента
│   ├── Button.types.ts     # Типы и интерфейсы
│   ├── Button.styles.ts    # Стили компонента
│   ├── Button.stories.tsx  # Storybook истории
│   ├── Button.test.tsx     # Тесты
│   └── index.ts            # Экспорт компонента
```

## Принципы создания компонентов

### 1. Консистентность

Все компоненты должны следовать единым принципам:

- Использование [[Токены-дизайна]] для значений цветов, размеров и т.д.
- Единый подход к именованию пропсов
- Согласованные паттерны обработки событий

```tsx
// Пример консистентного API компонента
export interface CommonComponentProps {
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
  onClick?: (event: React.MouseEvent) => void;
  onMouseEnter?: (event: React.MouseEvent) => void;
  onMouseLeave?: (event: React.MouseEvent) => void;
}
```

### 2. Гибкость

Компоненты должны быть гибкими и настраиваемыми:

```tsx
// components/Alert/Alert.types.ts
export type AlertVariant = 'success' | 'error' | 'warning' | 'info';
export type AlertSize = 'small' | 'medium' | 'large';

export interface AlertProps {
  variant: AlertVariant;
  size?: AlertSize;
  title: string;
  description?: string;
  closable?: boolean;
  onClose?: () => void;
  actions?: React.ReactNode[];
}
```

### 3. Доступность

Каждый компонент должен быть доступным:

```tsx
// components/Modal/Modal.tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

export const Modal: React.FC<ModalProps> = ({ 
  isOpen, 
  onClose, 
  title, 
  children 
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const firstFocusableRef = useRef<HTMLElement>(null);

  // Фокусировка при открытии модального окна
  useEffect(() => {
    if (isOpen && modalRef.current) {
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      firstFocusableRef.current = focusableElements[0] as HTMLElement;
      firstFocusableRef.current?.focus();
    }
  }, [isOpen]);

  // Захватываем фокус внутри модального окна
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return createPortal(
    <div 
      className="modal-overlay" 
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div 
        ref={modalRef}
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        role="document"
      >
        <button 
          className="modal-close-button" 
          onClick={onClose}
          aria-label="Закрыть модальное окно"
        >
          ×
        </button>
        <h2 id="modal-title">{title}</h2>
        {children}
      </div>
    </div>,
    document.body
  );
};
```

## Стилизация компонентов

### Использование дизайн-токенов

Компоненты должны использовать [[Токены-дизайна]] для всех стилевых значений:

```tsx
// components/Card/Card.styles.ts
import { css } from '@emotion/react';
import { DesignTokens } from '../../../tokens';

export const getCardStyles = (props: CardProps) => {
  return css`
    background-color: ${DesignTokens.color.surface.primary};
    border: 1px solid ${DesignTokens.color.border.default};
    border-radius: ${DesignTokens.borderRadius.medium};
    padding: ${DesignTokens.spacing.large};
    box-shadow: ${props.elevated 
      ? DesignTokens.elevation.medium 
      : DesignTokens.elevation.none
    };
    max-width: ${DesignTokens.maxWidth.card};
    
    ${props.variant === 'featured' && css`
      border-color: ${DesignTokens.color.primary[500]};
      border-width: 2px;
    `}
  `;
};
```

### Темизация

Компоненты должны поддерживать темы:

```tsx
// themes/dark.ts
import { DesignTokens } from '../tokens';

export const DarkTheme = {
  ...DesignTokens,
  color: {
    ...DesignTokens.color,
    primary: {
      ...DesignTokens.color.primary,
      500: '#60a5fa',
      600: '#3b82f6',
    },
    surface: {
      primary: '#1f2937',
      secondary: '#111827',
    },
    text: {
      primary: '#f9fafb',
      secondary: '#d1d5db',
    }
  }
};
```

```tsx
// ThemeProvider.tsx
import React, { createContext, useContext } from 'react';
import { DesignTokens } from '../tokens';

const ThemeContext = createContext(DesignTokens);

export const ThemeProvider: React.FC<{ 
  theme?: typeof DesignTokens, 
  children: React.ReactNode 
}> = ({ theme = DesignTokens, children }) => {
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => useContext(ThemeContext);
```

## Тестирование компонентов

### Unit-тесты

Каждый компонент должен иметь unit-тесты:

```tsx
// __tests__/Button.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '../atoms/Button/Button';

describe('Button', () => {
  it('renders correctly with default props', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button')).toBeInTheDocument();
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('applies correct variant styles', () => {
    render(<Button variant="secondary">Secondary</Button>);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('button-secondary');
  });

  it('handles click events', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when loading prop is true', () => {
    render(<Button loading={true}>Loading</Button>);
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
  });
});
```

### Визуальные тесты

Для контроля визуального соответствия рекомендуется использовать визуальные тесты:

```tsx
// __tests__/Button.visual.test.ts
import { check } from 'argos';

describe('Button visual tests', () => {
  it('matches snapshot for all variants', async () => {
    // Рендер компонента в браузере
    await page.goto('http://localhost:6006/iframe.html?id=button--primary');
    await check(page, 'Button Primary');
    
    await page.goto('http://localhost:6006/iframe.html?id=button--secondary');
    await check(page, 'Button Secondary');
  });
});
```

## Документация компонентов

### Storybook

Для документирования компонентов рекомендуется использовать Storybook:

```tsx
// components/Button/Button.stories.tsx
import React from 'react';
import { Story, Meta } from '@storybook/react';
import { Button, ButtonProps } from './Button';

export default {
  title: 'Components/Atoms/Button',
  component: Button,
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'tertiary'],
    },
    size: {
      control: { type: 'select' },
      options: ['small', 'medium', 'large'],
    },
  },
} as Meta;

const Template: Story<ButtonProps> = (args) => <Button {...args}>Button</Button>;

export const Primary = Template.bind({});
Primary.args = {
  variant: 'primary',
};

export const Secondary = Template.bind({});
Secondary.args = {
  variant: 'secondary',
};

export const WithIcon = Template.bind({});
WithIcon.args = {
  variant: 'primary',
  icon: <span>✉️</span>,
  children: 'Send Message',
};

export const Loading = Template.bind({});
Loading.args = {
  variant: 'primary',
  loading: true,
  children: 'Loading...',
};
```

### Документация API

Каждый компонент должен иметь документацию API:

```
# Button

Интерактивный элемент управления, который позволяет пользователю выполнить действие или выбрать опцию.

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| variant | 'primary' \| 'secondary' \| 'tertiary' | 'primary' | Вариант стиля кнопки |
| size | 'small' \| 'medium' \| 'large' | 'medium' | Размер кнопки |
| loading | boolean | false | Состояние загрузки |
| icon | ReactNode | - | Иконка слева от текста |
| onClick | function | - | Обработчик клика |
| disabled | boolean | false | Отключить кнопку |
```

## Лучшие практики

### 1. Минимизация пропсов

Старайтесь минимизировать количество пропсов, чтобы упростить использование компонентов:

```tsx
// Плохо - слишком много пропсов
<Button 
  backgroundColor="#3b82f6"
  textColor="white"
  fontSize="16px"
  padding="10px 20px"
  borderRadius="4px"
  hoverBackgroundColor="#2563eb"
  activeBackgroundColor="#1d4ed8"
/>

// Хорошо - использование вариантов
<Button variant="primary" size="medium" />
```

### 2. Семантическая разметка

Используйте семантически правильные HTML-элементы:

```tsx
// components/Link/Link.tsx
import React from 'react';

interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  external?: boolean;
  variant?: 'primary' | 'secondary';
}

export const Link: React.FC<LinkProps> = ({ 
  external, 
  children, 
  href, 
  ...props 
}) => {
  return (
    <a 
      href={href} 
      target={external ? '_blank' : undefined}
      rel={external ? 'noopener noreferrer' : undefined}
      {...props}
    >
      {children}
      {external && <span className="external-link-icon">↗</span>}
    </a>
  );
};
```

### 3. Обработка состояний

Обязательно учитывайте все возможные состояния компонентов:

```tsx
// components/Input/Input.tsx
import React from 'react';
import { InputProps } from './Input.types';
import { getInputStyles } from './Input.styles';

export const Input: React.FC<InputProps> = ({
  error,
  success,
  disabled,
  ...props
}) => {
  const [isFocused, setIsFocused] = React.useState(false);

  return (
    <div className="input-wrapper">
      <input
        className={getInputStyles({ error, success, disabled, isFocused })}
        disabled={disabled}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
        {...props}
      />
      {error && <span className="input-error">{error}</span>}
      {success && <span className="input-success">{success}</span>}
    </div>
  );
};
```

## Расширяемость компонентов

Для обеспечения расширяемости компонентов можно использовать следующие подходы:

### 1. Композиция компонентов

```tsx
// components/FormField/FormField.tsx
import React from 'react';
import { Label } from '../Label/Label';
import { Input } from '../Input/Input';
import { HelperText } from '../HelperText/HelperText';

interface FormFieldProps {
  label: string;
  id: string;
  error?: string;
  helperText?: string;
  children: React.ReactNode;
}

export const FormField: React.FC<FormFieldProps> = ({
  label,
  id,
  error,
  helperText,
  children
}) => {
  return (
    <div className="form-field">
      <Label htmlFor={id}>{label}</Label>
      {children}
      {error ? (
        <HelperText variant="error">{error}</HelperText>
      ) : helperText ? (
        <HelperText>{helperText}</HelperText>
      ) : null}
    </div>
  );
};

// Использование
<FormField label="Email" id="email" error={emailError}>
  <Input id="email" type="email" value={email} onChange={handleEmailChange} />
</FormField>
```

### 2. HOC и хуки для расширения функциональности

```tsx
// hocs/withTooltip.tsx
import React from 'react';
import { Tooltip } from '../Tooltip/Tooltip';

export const withTooltip = <P extends object>(
  Component: React.ComponentType<P>,
  tooltipText: string
) => {
  return (props: P & { tooltip?: string }) => {
    const { tooltip = tooltipText, ...componentProps } = props;
    
    return (
      <Tooltip content={tooltip}>
        <Component {...componentProps as P} />
      </Tooltip>
    );
  };
};

// Использование
const ButtonWithTooltip = withTooltip(Button, 'Нажмите для продолжения');
```

## Заключение

Компоненты-дизайна являются фундаментом любой дизайн-системы. Правильно спроектированные и реализованные компоненты обеспечивают консистентность, доступность и эффективность разработки. Следование описанным принципам и подходам поможет создать надежную и масштабируемую систему компонентов.

Для более глубокого понимания архитектуры дизайн-системы рекомендуется ознакомиться с [[Создание-дизайн-системы]] и [[Токены-дизайна]].