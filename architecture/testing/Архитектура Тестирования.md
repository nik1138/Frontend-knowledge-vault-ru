# Архитектура Тестирования

Архитектура тестирования — это структурированный подход к организации и реализации тестов в веб-приложениях, обеспечивающий надежность, поддерживаемость и эффективность тестирования на всех уровнях. Хорошая архитектура тестирования является фундаментом для создания качественного и стабильного программного обеспечения.

## Что такое Архитектура Тестирования

Архитектура тестирования — это совокупность принципов, паттернов и практик, определяющих структуру, организацию и выполнение тестов в программной системе. Она включает в себя:

- Стратегию тестирования
- Структуру тестового кода
- Организацию тестовых данных
- Инфраструктуру тестирования
- Процессы и практики тестирования

## Пирамида Тестирования

Пирамида тестирования — это концептуальная модель, которая определяет пропорции различных типов тестов в приложении.

### 1. Модульные Тесты (Unit Tests)

Модульные тесты проверяют отдельные функции, методы или компоненты в изоляции.

Преимущества:
- Быстрые в выполнении
- Простые в написании и поддержке
- Помогают находить ошибки на ранних этапах
- Обеспечивают документацию кода

Пример:
```javascript
// Тест для функции сложения
describe('add function', () => {
  test('should add two positive numbers correctly', () => {
    expect(add(2, 3)).toBe(5);
  });
  
  test('should handle negative numbers', () => {
    expect(add(-1, 1)).toBe(0);
  });
});
```

### 2. Интеграционные Тесты (Integration Tests)

Интеграционные тесты проверяют взаимодействие между несколькими компонентами или модулями.

Преимущества:
- Проверяют корректность взаимодействия компонентов
- Выявляют проблемы интеграции
- Менее хрупкие, чем end-to-end тесты

Пример:
```javascript
// Тест интеграции компонента с API
describe('UserList component', () => {
  test('should fetch and display users', async () => {
    // Мокируем API
    mockApi.getUsers.mockResolvedValue(mockUsers);
    
    // Рендерим компонент
    render(<UserList />);
    
    // Проверяем результат
    expect(await screen.findByText('John Doe')).toBeInTheDocument();
  });
});
```

### 3. End-to-End Тесты (E2E Tests)

End-to-end тесты проверяют приложение в целом, имитируя реальные сценарии использования.

Преимущества:
- Проверяют приложение с точки зрения пользователя
- Выявляют проблемы в полном сценарии работы
- Обеспечивают высокую уверенность в стабильности

Недостатки:
- Медленные в выполнении
- Хрупкие и требуют частого обновления
- Сложные в отладке

Пример:
```javascript
// E2E тест с использованием Cypress
describe('Login Flow', () => {
  it('should allow a user to log in', () => {
    cy.visit('/login');
    cy.get('[data-testid="email"]').type('user@example.com');
    cy.get('[data-testid="password"]').type('password123');
    cy.get('[data-testid="submit"]').click();
    cy.url().should('include', '/dashboard');
    cy.get('[data-testid="welcome-message"]').should('contain', 'Welcome');
  });
});
```

## Типы Тестов

### 1. Функциональное Тестирование

Проверяет, соответствует ли система спецификациям и требованиям.

#### Тестирование Компонентов
```javascript
// Тест React компонента
import { render, screen } from '@testing-library/react';
import Button from './Button';

test('renders button with correct text', () => {
  render(<Button>Click me</Button>);
  expect(screen.getByText('Click me')).toBeInTheDocument();
});

test('calls onClick when clicked', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);
  screen.getByText('Click me').click();
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

#### Тестирование API
```javascript
// Тест API endpoint
describe('GET /api/users', () => {
  test('should return list of users', async () => {
    const response = await request(app).get('/api/users');
    expect(response.status).toBe(200);
    expect(response.body).toBeInstanceOf(Array);
    expect(response.body[0]).toHaveProperty('id');
    expect(response.body[0]).toHaveProperty('name');
  });
});
```

### 2. Нефункциональное Тестирование

Проверяет характеристики системы, не связанные с конкретной функциональностью.

#### Тестирование Производительности
```javascript
// Тест производительности с использованием Lighthouse
describe('Performance', () => {
  test('should have good performance metrics', async () => {
    const results = await lighthouse.audit('http://localhost:3000');
    expect(results.lcp).toBeLessThan(2500); // LCP < 2.5s
    expect(results.fid).toBeLessThan(100);  // FID < 100ms
    expect(results.cls).toBeLessThan(0.1);  // CLS < 0.1
  });
});
```

#### Тестирование Безопасности
```javascript
// Тест на уязвимости XSS
describe('XSS Protection', () => {
  test('should sanitize user input', () => {
    const maliciousInput = '<script>alert("XSS")</script>';
    const sanitized = sanitizeInput(maliciousInput);
    expect(sanitized).not.toContain('<script>');
  });
});
```

## Архитектурные Паттерны Тестирования

### 1. Page Object Model (POM)

Паттерн, который инкапсулирует взаимодействие с веб-страницами в отдельные классы.

Пример:
```javascript
// Page Object для страницы логина
class LoginPage {
  constructor() {
    this.emailInput = '[data-testid="email"]';
    this.passwordInput = '[data-testid="password"]';
    this.submitButton = '[data-testid="submit"]';
  }
  
  visit() {
    cy.visit('/login');
  }
  
  fillEmail(email) {
    cy.get(this.emailInput).type(email);
  }
  
  fillPassword(password) {
    cy.get(this.passwordInput).type(password);
  }
  
  submit() {
    cy.get(this.submitButton).click();
  }
  
  login(email, password) {
    this.visit();
    this.fillEmail(email);
    this.fillPassword(password);
    this.submit();
  }
}

// Использование в тесте
describe('Login Flow', () => {
  it('should allow a user to log in', () => {
    const loginPage = new LoginPage();
    loginPage.login('user@example.com', 'password123');
    cy.url().should('include', '/dashboard');
  });
});
```

### 2. Arrange-Act-Assert (AAA)

Структура тестов, разделяющая тест на три части:
- Arrange: Подготовка данных и условий
- Act: Выполнение тестируемого действия
- Assert: Проверка результата

Пример:
```javascript
test('should calculate total price correctly', () => {
  // Arrange
  const items = [
    { name: 'Item 1', price: 10 },
    { name: 'Item 2', price: 20 }
  ];
  
  // Act
  const total = calculateTotal(items);
  
  // Assert
  expect(total).toBe(30);
});
```

### 3. Given-When-Then (GWT)

Поведенческий подход к написанию тестов, используемый в BDD.

Пример:
```gherkin
Feature: User Login
  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter valid email and password
    And I click the login button
    Then I should be redirected to the dashboard
```

## Инфраструктура Тестирования

### 1. Тестовое Окружение

#### Локальное Окружение
```javascript
// Конфигурация для локального тестирования
const localConfig = {
  baseUrl: 'http://localhost:3000',
  apiEndpoint: 'http://localhost:3001/api',
  database: 'test_db_local',
  timeout: 10000
};
```

#### CI/CD Окружение
```javascript
// Конфигурация для CI/CD
const ciConfig = {
  baseUrl: 'http://test-server:3000',
  apiEndpoint: 'http://test-server:3001/api',
  database: 'test_db_ci',
  timeout: 30000,
  headless: true
};
```

### 2. Мокирование и Стабы

#### Мокирование API
```javascript
// Мокирование HTTP запросов
import nock from 'nock';

beforeEach(() => {
  nock('http://api.example.com')
    .get('/users')
    .reply(200, [
      { id: 1, name: 'John Doe' },
      { id: 2, name: 'Jane Smith' }
    ]);
});

afterEach(() => {
  nock.cleanAll();
});
```

#### Мокирование Компонентов
```javascript
// Мокирование дочерних компонентов
jest.mock('./ExpensiveChart', () => {
  return function MockExpensiveChart() {
    return <div data-testid="mock-chart">Chart Placeholder</div>;
  };
});
```

## Практики и Рекомендации

### 1. Независимость Тестов

Каждый тест должен быть независимым и не полагаться на состояние других тестов.

```javascript
// Плохо - тесты зависят друг от друга
describe('Counter', () => {
  let counter;
  
  beforeEach(() => {
    counter = new Counter();
  });
  
  test('should increment by 1', () => {
    counter.increment(); // Изменяет состояние
    expect(counter.value).toBe(1);
  });
  
  test('should have value 1', () => {
    // Зависит от предыдущего теста
    expect(counter.value).toBe(1);
  });
});

// Хорошо - каждый тест независим
describe('Counter', () => {
  test('should increment by 1', () => {
    const counter = new Counter();
    counter.increment();
    expect(counter.value).toBe(1);
  });
  
  test('should have initial value 0', () => {
    const counter = new Counter();
    expect(counter.value).toBe(0);
  });
});
```

### 2. Читаемость Тестов

Тесты должны быть легко читаемыми и понятными.

```javascript
// Плохо - непонятные названия
test('test1', () => {
  const result = calculate(2, 3, 'add');
  expect(result).toBe(5);
});

// Хорошо - описательные названия
test('should add two positive numbers correctly', () => {
  const result = add(2, 3);
  expect(result).toBe(5);
});
```

### 3. Покрытие Кода

Целенаправленное тестирование критических путей приложения.

```javascript
// Измерение покрытия кода
// package.json
{
  "scripts": {
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{js,jsx,ts,tsx}",
      "!src/**/*.d.ts"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

## Инструменты Тестирования

### 1. Фреймворки для Модульного Тестирования

#### Jest
```javascript
// Конфигурация Jest
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapping: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
  ],
};
```

#### Vitest
```javascript
// Конфигурация Vitest
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/setupTests.ts'],
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html'],
    },
  },
});
```

### 2. Инструменты для E2E Тестирования

#### Cypress
```javascript
// Конфигурация Cypress
module.exports = {
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    supportFile: 'cypress/support/e2e.js',
    viewportWidth: 1280,
    viewportHeight: 720,
  },
};
```

#### Playwright
```javascript
// Конфигурация Playwright
import { defineConfig } from '@playwright/test';

export default defineConfig({
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { browserName: 'chromium' },
    },
    {
      name: 'firefox',
      use: { browserName: 'firefox' },
    },
  ],
});
```

## Тестирование в CI/CD

### 1. Пайплайн Тестирования

```yaml
# GitHub Actions workflow
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
      - name: Run unit tests
        run: npm run test:unit
      - name: Run integration tests
        run: npm run test:integration
      - name: Run E2E tests
        run: npm run test:e2e
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v1
```

### 2. Параллельное Выполнение Тестов

```javascript
// Конфигурация для параллельного выполнения
// jest.config.js
module.exports = {
  // ... другие настройки
  maxWorkers: '50%',
  testMatch: [
    '**/__tests__/**/*.js',
    '**/?(*.)+(spec|test).js'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/'
  ]
};
```

## Мониторинг и Отчетность

### 1. Отчеты о Тестировании

```javascript
// Генерация отчетов
// jest.config.js
module.exports = {
  reporters: [
    'default',
    ['jest-junit', {
      outputDirectory: 'reports',
      outputName: 'junit.xml'
    }],
    ['jest-html-reporter', {
      pageTitle: 'Test Report',
      outputPath: 'reports/test-report.html'
    }]
  ]
};
```

### 2. Интеграция с Системами Мониторинга

```javascript
// Отправка метрик тестирования
class TestMetricsReporter {
  static report(metrics) {
    // Отправка в систему мониторинга (например, Datadog, New Relic)
    fetch('https://monitoring.example.com/api/metrics', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.MONITORING_TOKEN}`
      },
      body: JSON.stringify(metrics)
    });
  }
}
```

## Связанные Концепции

- [[Архитектура]]
- [[Компонентная Архитектура]]
- [[Управление Состоянием]]
- [[Безопасность Frontend]]
- [[Архитектура Производительности и Оптимизации]]

## Теги

#testing #architecture #unit-testing #integration-testing #e2e-testing #test-automation #quality-assurance #frontend #ci-cd
