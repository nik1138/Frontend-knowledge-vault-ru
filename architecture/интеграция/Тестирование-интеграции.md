---
aliases: ["Integration Testing", "Тестирование интеграции", "Интеграционные тесты"]
tags: [architecture, frontend, testing, integration, quality]
---

# Тестирование интеграции

## Обзор

Тестирование интеграции - это уровень тестирования программного обеспечения, который проверяет взаимодействие между различными компонентами или системами приложения. В контексте фронтенд-разработки, интеграционное тестирование проверяет, как различные модули приложения (API-клиенты, сервисы, компоненты) взаимодействуют друг с другом и с внешними системами.

## Типы интеграционного тестирования

### Тестирование компонентов
Проверка взаимодействия между различными компонентами приложения.

### Тестирование API
Проверка взаимодействия с внутренними и внешними API.

### Тестирование сервисов
Проверка взаимодействия между различными сервисами приложения.

### Тестирование с внешними системами
Проверка интеграции с устаревшими системами, сторонними библиотеками и микросервисами.

## Практические рекомендации

### 1. Настройка тестовой среды

```javascript
// __tests__/setup.js
import { configure } from '@testing-library/react';
import '@testing-library/jest-dom';

// Настройка Testing Library
configure({ testIdAttribute: 'data-testid' });

// Mock для API-клиента
global.fetch = jest.fn();

// Mock для localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});
```

### 2. Тестирование API-интеграции

```javascript
// __tests__/api/apiClient.test.js
import ApiClient from '../../src/api/apiClient';

describe('ApiClient Integration Tests', () => {
  let apiClient;

  beforeEach(() => {
    apiClient = new ApiClient('https://api.example.com');
    fetch.mockClear();
  });

  it('should successfully fetch data from API', async () => {
    // Подготовка mock-ответа
    const mockResponse = { id: 1, name: 'Test User' };
    fetch.mockResolvedValue({
      ok: true,
      json: async () => mockResponse,
    });

    // Выполнение
    const result = await apiClient.get('/users/1');

    // Проверка
    expect(fetch).toHaveBeenCalledWith(
      'https://api.example.com/users/1',
      expect.objectContaining({
        method: 'GET',
        headers: expect.objectContaining({
          'Content-Type': 'application/json',
        }),
      })
    );
    expect(result).toEqual(mockResponse);
  });

  it('should handle API errors', async () => {
    // Подготовка mock-ошибки
    fetch.mockResolvedValue({
      ok: false,
      status: 404,
    });

    // Выполнение и проверка
    await expect(apiClient.get('/users/999')).rejects.toThrow('HTTP error! status: 404');
  });

  it('should send POST request with correct data', async () => {
    const testData = { name: 'New User', email: 'newuser@example.com' };
    const mockResponse = { id: 2, ...testData };
    
    fetch.mockResolvedValue({
      ok: true,
      json: async () => mockResponse,
    });

    const result = await apiClient.post('/users', testData);

    expect(fetch).toHaveBeenCalledWith(
      'https://api.example.com/users',
      expect.objectContaining({
        method: 'POST',
        headers: expect.objectContaining({
          'Content-Type': 'application/json',
        }),
        body: JSON.stringify(testData),
      })
    );
    expect(result).toEqual(mockResponse);
  });
});
```

### 3. Тестирование интеграции с микросервисами

```javascript
// __tests__/services/apiGatewayService.test.js
import ApiGatewayService from '../../src/services/apiGatewayService';

describe('ApiGatewayService Integration Tests', () => {
  let apiGateway;

  beforeEach(() => {
    apiGateway = new ApiGatewayService('https://gateway.example.com');
    global.fetch = jest.fn();
  });

  it('should aggregate data from multiple services', async () => {
    // Подготовка mock-данных для разных сервисов
    const mockUser = { id: 1, name: 'John Doe' };
    const mockOrders = [{ id: 1, total: 100 }, { id: 2, total: 200 }];
    const mockNotifications = [{ id: 1, message: 'Welcome!' }];
    
    global.fetch
      .mockResolvedValueOnce({ ok: true, json: async () => mockUser }) // user service
      .mockResolvedValueOnce({ ok: true, json: async () => mockOrders }) // order service
      .mockResolvedValueOnce({ ok: true, json: async () => mockNotifications }); // notification service

    // Имитация метода из MicroservicesOperations
    const getUserDashboardData = async (userId) => {
      const [user, orders, notifications] = await Promise.all([
        apiGateway.request('user', `/${userId}`),
        apiGateway.request('order', `/user/${userId}`),
        apiGateway.request('notification', `/user/${userId}`)
      ]);

      return {
        user,
        orders,
        notifications,
        lastUpdated: new Date().toISOString()
      };
    };

    const result = await getUserDashboardData(1);

    expect(result.user).toEqual(mockUser);
    expect(result.orders).toEqual(mockOrders);
    expect(result.notifications).toEqual(mockNotifications);
  });

  it('should handle service errors gracefully', async () => {
    global.fetch
      .mockResolvedValueOnce({ ok: true, json: async () => ({ id: 1, name: 'John' }) }) // user service - success
      .mockResolvedValueOnce({ ok: false, status: 500 }) // order service - error
      .mockResolvedValueOnce({ ok: true, json: async () => [] }); // notification service - success

    await expect(() => 
      Promise.all([
        apiGateway.request('user', '/1'),
        apiGateway.request('order', '/user/1'),
        apiGateway.request('notification', '/user/1')
      ])
    ).rejects.toThrow();
  });
});
```

### 4. Тестирование интеграции со сторонними библиотеками

```javascript
// __tests__/services/analyticsService.test.js
import AnalyticsService from '../../src/services/analyticsService';

describe('AnalyticsService Integration Tests', () => {
  let analyticsService;
  let mockGtag;

  beforeEach(() => {
    // Создаем mock для gtag
    mockGtag = jest.fn();
    window.gtag = mockGtag;
    
    analyticsService = new AnalyticsService();
  });

  afterEach(() => {
    delete window.gtag;
  });

  it('should track events when analytics is enabled', () => {
    // В production mode analytics будет включен
    process.env.NODE_ENV = 'production';
    const newAnalyticsService = new AnalyticsService();
    
    newAnalyticsService.trackEvent('button_click', { button_id: 'submit' });
    
    expect(mockGtag).toHaveBeenCalledWith('event', 'button_click', { button_id: 'submit' });
  });

  it('should not track events when analytics is disabled', () => {
    // В test mode analytics отключен
    process.env.NODE_ENV = 'test';
    const testAnalyticsService = new AnalyticsService();
    
    testAnalyticsService.trackEvent('button_click', { button_id: 'submit' });
    
    expect(mockGtag).not.toHaveBeenCalled();
  });

  it('should track page views correctly', () => {
    process.env.NODE_ENV = 'production';
    const newAnalyticsService = new AnalyticsService();
    
    newAnalyticsService.trackPageView('/home');
    
    expect(mockGtag).toHaveBeenCalledWith(
      'config', 
      process.env.REACT_APP_GA_MEASUREMENT_ID, 
      { page_path: '/home' }
    );
  });
});
```

### 5. Тестирование компонентной интеграции

```jsx
// __tests__/components/UserProfile.test.jsx
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import UserProfile from '../../src/components/UserProfile';
import ApiClient from '../../src/api/apiClient';

// Mock для ApiClient
jest.mock('../../src/api/apiClient');

describe('UserProfile Component Integration Tests', () => {
  const mockApiClient = {
    get: jest.fn(),
  };

  beforeEach(() => {
    ApiClient.mockImplementation(() => mockApiClient);
  });

  it('should display user data when API call is successful', async () => {
    const mockUserData = { id: 1, name: 'John Doe', email: 'john@example.com' };
    mockApiClient.get.mockResolvedValue(mockUserData);

    render(<UserProfile userId={1} />);

    // Проверяем, что отображается индикатор загрузки
    expect(screen.getByText('Загрузка...')).toBeInTheDocument();

    // Ждем завершения загрузки
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });

    // Проверяем, что индикатор загрузки исчез
    expect(screen.queryByText('Загрузка...')).not.toBeInTheDocument();
  });

  it('should display error message when API call fails', async () => {
    mockApiClient.get.mockRejectedValue(new Error('Network error'));

    render(<UserProfile userId={999} />);

    await waitFor(() => {
      expect(screen.getByText(/ошибка/i)).toBeInTheDocument();
    });
  });

  it('should not make API call when userId is not provided', () => {
    render(<UserProfile userId={null} />);

    expect(mockApiClient.get).not.toHaveBeenCalled();
    expect(screen.queryByText('Загрузка...')).not.toBeInTheDocument();
  });
});
```

### 6. Тестирование интеграции с устаревшими системами

```javascript
// __tests__/adapters/legacyApiAdapter.test.js
import LegacyApiAdapter from '../../src/adapters/legacyApiAdapter';

describe('LegacyApiAdapter Integration Tests', () => {
  let legacyAdapter;

  beforeEach(() => {
    legacyAdapter = new LegacyApiAdapter('https://legacy.example.com');
    global.fetch = jest.fn();
  });

  it('should convert legacy XML response to modern format', async () => {
    const legacyXml = `
      <user>
        <id>123</id>
        <name>John Doe</name>
        <email>john@example.com</email>
        <phone>555-1234</phone>
        <address>
          <street>123 Main St</street>
          <city>Anytown</city>
          <zip>12345</zip>
        </address>
      </user>
    `;

    global.fetch.mockResolvedValue({
      ok: true,
      text: async () => legacyXml,
    });

    const result = await legacyAdapter.getUser(123);

    expect(result).toEqual({
      id: '123',
      name: 'John Doe',
      email: 'john@example.com',
      phone: '555-1234',
      address: {
        street: '123 Main St',
        city: 'Anytown',
        zipCode: '12345'
      },
      createdAt: expect.any(String) // ISO string
    });
  });

  it('should convert modern data to legacy format for updates', async () => {
    const modernData = {
      id: '123',
      name: 'John Doe',
      email: 'john@example.com',
      phone: '555-1234',
      address: {
        street: '123 Main St',
        city: 'Anytown',
        zipCode: '12345'
      }
    };

    global.fetch.mockResolvedValue({
      ok: true,
      json: async () => ({ success: true }),
    });

    // Тестируем метод, который использует convertToLegacyFormat
    await legacyAdapter.updateUser(123, modernData);

    // Проверяем, что отправленные данные соответствуют устаревшему формату
    const callArgs = global.fetch.mock.calls[0];
    const body = callArgs[1].body;
    
    // Проверяем, что тело запроса содержит данные в устаревшем формате
    expect(body).toContain('user_id=123');
    expect(body).toContain('user_name=John Doe');
    expect(body).toContain('address_zip=12345');
  });
});
```

### 7. Использование инструментов для тестирования интеграции

```javascript
// __tests__/utils/testHelpers.js
import { rest } from 'msw';
import { setupServer } from 'msw/node';

// Mock server для тестирования API-интеграции
export const server = setupServer(
  rest.get('https://api.example.com/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    if (id === '1') {
      return res(
        ctx.json({ id: 1, name: 'Test User', email: 'test@example.com' }),
        ctx.status(200)
      );
    }
    return res(ctx.status(404));
  }),
  
  rest.post('https://api.example.com/users', (req, res, ctx) => {
    return res(
      ctx.json({ id: 2, ...req.body }),
      ctx.status(201)
    );
  }),
  
  rest.get('https://legacy.example.com/get_user_info', (req, res, ctx) => {
    return res(
      ctx.text(`
        <user>
          <id>${req.body.get('user_id')}</id>
          <name>Legacy User</name>
          <email>legacy@example.com</email>
        </user>
      `),
      ctx.status(200)
    );
  })
);

// Вспомогательные функции для тестов
export const waitForAsyncOperations = () => new Promise(resolve => setTimeout(resolve, 0));

// Установка и очистка сервера для каждого теста
export const setupTestServer = () => {
  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());
};
```

## Лучшие практики

1. **Изолируйте внешние зависимости** - используйте mock-объекты для API и сторонних сервисов
2. **Тестируйте сценарии ошибок** - проверяйте, как приложение реагирует на сбои
3. **Используйте инструменты для мокирования** - MSW, Jest mocks, etc.
4. **Тестируйте граничные условия** - пустые ответы, большие объемы данных
5. **Автоматизируйте тесты** - включите интеграционные тесты в CI/CD
6. **Покрывайте критические пути** - фокусируйтесь на основных сценариях использования

## Безопасность в тестировании

- Не используйте реальные учетные данные в тестах
- Изолируйте тестовые данные от продакшн-данных
- Используйте тестовые окружения для интеграции с внешними системами
- Ограничивайте доступ к тестовым API-ключам

## Связанные темы

- [[Интеграция с API]]
- [[Интеграция с микросервисами]]
- [[Интеграция со сторонними библиотеками]]
- [[Интеграция с устаревшими системами]]
- [[Архитектура фронтенд-приложений]]

#frontend #testing #integration #architecture