---
aliases: ["Legacy Systems Integration", "Интеграция с устаревшими системами", "Работа со старыми системами"]
tags: [architecture, frontend, legacy, integration, migration]
---

# Интеграция с устаревшими системами

## Обзор

Интеграция с устаревшими системами (legacy systems) - это процесс подключения современных фронтенд-приложений к существующим старым системам, которые часто не соответствуют современным стандартам разработки. Эти системы могут использовать устаревшие протоколы, форматы данных и архитектурные подходы.

## Типы устаревших систем

### Устаревшие API
- SOAP-сервисы
- XML-RPC
- Устаревшие REST API с нестандартными форматами

### Устаревшие базы данных
- Системы, к которым нужен прямой доступ
- Использование старых протоколов доступа

### Устаревшие веб-интерфейсы
- Старые веб-приложения, которые нужно интегрировать
- Использование iframe для встраивания

## Практические рекомендации

### 1. Создание адаптеров для устаревших API

```javascript
// adapters/legacyApiAdapter.js
class LegacyApiAdapter {
  constructor(legacyApiUrl) {
    this.legacyApiUrl = legacyApiUrl;
  }

  // Адаптация устаревшего формата ответа
  async getUser(userId) {
    try {
      const response = await fetch(`${this.legacyApiUrl}/get_user_info`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `user_id=${encodeURIComponent(userId)}`
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const legacyData = await response.text();
      const parsedData = this.parseLegacyXml(legacyData);
      
      // Преобразование в современный формат
      return this.transformUserData(parsedData);
    } catch (error) {
      console.error('Error fetching user from legacy system:', error);
      throw error;
    }
  }

  parseLegacyXml(xmlString) {
    // Парсинг устаревшего XML-формата
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    
    const userNode = xmlDoc.querySelector('user');
    if (!userNode) {
      throw new Error('Invalid XML format: user node not found');
    }

    return {
      id: userNode.querySelector('id')?.textContent,
      name: userNode.querySelector('name')?.textContent,
      email: userNode.querySelector('email')?.textContent,
      phone: userNode.querySelector('phone')?.textContent,
      address: {
        street: userNode.querySelector('address')?.querySelector('street')?.textContent,
        city: userNode.querySelector('address')?.querySelector('city')?.textContent,
        zip: userNode.querySelector('address')?.querySelector('zip')?.textContent
      }
    };
  }

  transformUserData(legacyData) {
    // Преобразование в современный формат
    return {
      id: legacyData.id,
      name: legacyData.name,
      email: legacyData.email,
      phone: legacyData.phone,
      address: {
        street: legacyData.address?.street || '',
        city: legacyData.address?.city || '',
        zipCode: legacyData.address?.zip || ''
      },
      createdAt: new Date().toISOString() // Добавляем современное поле
    };
  }

  // Адаптация для отправки данных в устаревший формат
  async updateUser(userId, userData) {
    try {
      const legacyFormat = this.convertToLegacyFormat(userData);
      
      const response = await fetch(`${this.legacyApiUrl}/update_user`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: legacyFormat
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error updating user in legacy system:', error);
      throw error;
    }
  }

  convertToLegacyFormat(userData) {
    // Преобразование современных данных в устаревший формат
    const params = new URLSearchParams();
    params.append('user_id', userData.id);
    params.append('user_name', userData.name);
    params.append('user_email', userData.email);
    params.append('user_phone', userData.phone);
    params.append('address_street', userData.address.street);
    params.append('address_city', userData.address.city);
    params.append('address_zip', userData.address.zipCode);
    
    return params.toString();
  }
}

export default LegacyApiAdapter;
```

### 2. Создание сервиса интеграции

```javascript
// services/legacyIntegrationService.js
import LegacyApiAdapter from '../adapters/legacyApiAdapter';
import ModernApiService from './modernApiService';

class LegacyIntegrationService {
  constructor() {
    this.legacyAdapter = new LegacyApiAdapter(process.env.REACT_APP_LEGACY_API_URL);
    this.modernService = new ModernApiService();
  }

  // Интеграция данных из устаревшей системы с современными данными
  async getCompleteUser(userId) {
    try {
      // Получаем данные из устаревшей системы
      const legacyUser = await this.legacyAdapter.getUser(userId);
      
      // Получаем дополнительные данные из современной системы
      const modernUser = await this.modernService.getUser(userId);
      
      // Объединяем данные
      return {
        ...legacyUser,
        preferences: modernUser.preferences || {},
        lastLogin: modernUser.lastLogin,
        permissions: modernUser.permissions || []
      };
    } catch (error) {
      console.error('Error getting complete user data:', error);
      throw error;
    }
  }

  // Обновление данных в обеих системах
  async updateUserData(userId, userData) {
    try {
      // Сначала обновляем в устаревшей системе
      await this.legacyAdapter.updateUser(userId, userData);
      
      // Затем в современной системе
      await this.modernService.updateUser(userId, userData);
      
      return { success: true };
    } catch (error) {
      console.error('Error updating user data in both systems:', error);
      
      // Логика восстановления согласованности данных
      await this.handleUpdateError(userId, userData, error);
      
      throw error;
    }
  }

  async handleUpdateError(userId, originalData, error) {
    console.error('Handling update error - attempting data consistency:', error);
    
    // Попытка восстановить согласованность данных
    try {
      const legacyUser = await this.legacyAdapter.getUser(userId);
      await this.modernService.updateUser(userId, legacyUser);
    } catch (restoreError) {
      console.error('Failed to restore data consistency:', restoreError);
      // Логирование для дальнейшего ручного восстановления
      this.logDataInconsistency(userId, originalData, error, restoreError);
    }
  }

  logDataInconsistency(userId, originalData, updateError, restoreError) {
    // Логирование несогласованных данных для последующего разрешения
    console.error('Data inconsistency detected:', {
      userId,
      originalData,
      updateError: updateError.message,
      restoreError: restoreError?.message
    });
  }
}

export default LegacyIntegrationService;
```

### 3. Работа с устаревшими форматами данных

```javascript
// utils/legacyDataConverter.js
export class LegacyDataConverter {
  // Конвертация из устаревшего формата в современный
  static convertLegacyToModern(legacyData) {
    if (Array.isArray(legacyData)) {
      return legacyData.map(item => this.convertLegacyItemToModern(item));
    }
    
    return this.convertLegacyItemToModern(legacyData);
  }

  static convertLegacyItemToModern(item) {
    // Пример преобразования устаревшего формата
    const modernItem = {
      id: item.id || item.ID || item.user_id,
      name: item.name || item.full_name || item.userName,
      email: item.email || item.e_mail || item.userEmail,
      createdAt: this.parseLegacyDate(item.created_date || item.create_date),
      status: this.convertLegacyStatus(item.status || item.user_status),
      metadata: this.extractLegacyMetadata(item)
    };

    // Удаление устаревших полей
    delete modernItem.ID;
    delete modernItem.user_id;
    delete modernItem.full_name;
    
    return modernItem;
  }

  static parseLegacyDate(dateString) {
    // Поддержка различных устаревших форматов даты
    if (!dateString) return null;
    
    // Попытка различных форматов
    const dateFormats = [
      'YYYY-MM-DD HH:mm:ss',
      'MM/DD/YYYY HH:mm:ss',
      'DD/MM/YYYY HH:mm:ss',
      'YYYYMMDD',
      'YYYY-MM-DD'
    ];
    
    for (const format of dateFormats) {
      const date = new Date(dateString);
      if (!isNaN(date.getTime())) {
        return date.toISOString();
      }
    }
    
    return new Date().toISOString(); // Значение по умолчанию
  }

  static convertLegacyStatus(legacyStatus) {
    // Преобразование устаревших статусов
    const statusMap = {
      'A': 'active',
      'I': 'inactive',
      'P': 'pending',
      'S': 'suspended',
      '1': 'active',
      '0': 'inactive',
      'active': 'active',
      'inactive': 'inactive'
    };
    
    return statusMap[legacyStatus] || 'unknown';
  }

  static extractLegacyMetadata(item) {
    // Извлечение дополнительных метаданных из устаревших полей
    const metadata = {};
    
    Object.keys(item).forEach(key => {
      if (key.startsWith('meta_') || key.startsWith('ext_')) {
        metadata[key] = item[key];
      }
    });
    
    return metadata;
  }

  // Конвертация из современного формата в устаревший
  static convertModernToLegacy(modernData) {
    if (Array.isArray(modernData)) {
      return modernData.map(item => this.convertModernItemToLegacy(item));
    }
    
    return this.convertModernItemToLegacy(modernData);
  }

  static convertModernItemToLegacy(item) {
    // Обратное преобразование в устаревший формат
    return {
      id: item.id,
      name: item.name,
      email: item.email,
      created_date: this.formatLegacyDate(item.createdAt),
      status: this.convertModernStatus(item.status),
      ...item.metadata
    };
  }

  static formatLegacyDate(dateString) {
    // Форматирование даты в устаревший формат
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toISOString().split('T')[0]; // YYYY-MM-DD
  }

  static convertModernStatus(modernStatus) {
    // Преобразование современных статусов в устаревшие
    const statusMap = {
      'active': 'A',
      'inactive': 'I',
      'pending': 'P',
      'suspended': 'S'
    };
    
    return statusMap[modernStatus] || 'U'; // U = unknown
  }
}
```

### 4. Интеграция с устаревшими веб-интерфейсами

```jsx
// components/LegacyIframeWrapper.jsx
import React, { useState, useEffect, useRef } from 'react';

const LegacyIframeWrapper = ({ 
  src, 
  onLoad, 
  onError, 
  allowCredentials = false,
  className = '' 
}) => {
  const iframeRef = useRef(null);
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  useEffect(() => {
    const handleLoad = () => {
      setIsLoading(false);
      if (onLoad) onLoad();
    };

    const handleError = () => {
      setIsLoading(false);
      setHasError(true);
      if (onError) onError();
    };

    const iframe = iframeRef.current;
    if (iframe) {
      iframe.addEventListener('load', handleLoad);
      iframe.addEventListener('error', handleError);
    }

    return () => {
      if (iframe) {
        iframe.removeEventListener('load', handleLoad);
        iframe.removeEventListener('error', handleError);
      }
    };
  }, [onLoad, onError]);

  // Обработка сообщений из iframe
  useEffect(() => {
    const handleMessage = (event) => {
      // Проверка источника для безопасности
      if (event.origin !== new URL(src).origin) return;
      
      // Обработка сообщений от устаревшего интерфейса
      console.log('Message from legacy system:', event.data);
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [src]);

  if (hasError) {
    return (
      <div className="legacy-iframe-error">
        <p>Ошибка загрузки устаревшего интерфейса</p>
        <button onClick={() => window.location.reload()}>Повторить попытку</button>
      </div>
    );
  }

  return (
    <div className={`legacy-iframe-container ${className}`}>
      {isLoading && <div className="loading-spinner">Загрузка...</div>}
      <iframe
        ref={iframeRef}
        src={src}
        title="Legacy System Interface"
        style={{ 
          width: '100%', 
          height: '600px',
          border: 'none',
          display: isLoading ? 'none' : 'block'
        }}
        // Для доступа к credentials (только при необходимости и с осторожностью)
        allow={allowCredentials ? 'credentials' : ''}
        // Ограничение возможностей iframe для безопасности
        sandbox="allow-same-origin allow-scripts allow-forms"
      />
    </div>
  );
};

export default LegacyIframeWrapper;
```

### 5. Обработка ошибок и резервные стратегии

```javascript
// utils/legacyFallbackHandler.js
export class LegacyFallbackHandler {
  constructor(legacyService, modernService) {
    this.legacyService = legacyService;
    this.modernService = modernService;
    this.fallbackStrategies = new Map();
  }

  // Резервная стратегия для получения данных
  async getDataWithFallback(userId, strategies = ['modern', 'legacy', 'cache']) {
    let lastError;

    for (const strategy of strategies) {
      try {
        switch (strategy) {
          case 'modern':
            return await this.modernService.getUser(userId);
          case 'legacy':
            return await this.legacyService.getUser(userId);
          case 'cache':
            return await this.getCachedData(userId);
          default:
            throw new Error(`Unknown strategy: ${strategy}`);
        }
      } catch (error) {
        console.warn(`Strategy ${strategy} failed:`, error);
        lastError = error;
        continue; // Пробуем следующую стратегию
      }
    }

    throw new Error(`All strategies failed: ${lastError?.message}`);
  }

  async getCachedData(userId) {
    // Получение данных из кэша как резервный вариант
    const cached = localStorage.getItem(`user_${userId}`);
    if (cached) {
      try {
        return JSON.parse(cached);
      } catch (error) {
        console.error('Failed to parse cached data:', error);
        localStorage.removeItem(`user_${userId}`);
      }
    }
    throw new Error('No cached data available');
  }

  // Обновление данных с резервными стратегиями
  async updateDataWithFallback(userId, data, strategies = ['modern', 'legacy']) {
    let lastError;
    const results = [];

    for (const strategy of strategies) {
      try {
        let result;
        switch (strategy) {
          case 'modern':
            result = await this.modernService.updateUser(userId, data);
            break;
          case 'legacy':
            result = await this.legacyService.updateUser(userId, data);
            break;
          default:
            throw new Error(`Unknown strategy: ${strategy}`);
        }
        
        results.push({ strategy, success: true, result });
      } catch (error) {
        console.error(`Update failed for ${strategy}:`, error);
        results.push({ strategy, success: false, error: error.message });
        lastError = error;
      }
    }

    // Проверяем, были ли успешные обновления
    const successfulUpdates = results.filter(r => r.success);
    
    if (successfulUpdates.length === 0) {
      throw new Error(`All update strategies failed: ${lastError?.message}`);
    }

    // Возвращаем результаты всех попыток
    return results;
  }
}
```

## Лучшие практики

1. **Создавайте адаптеры** - изолируйте логику работы с устаревшими системами
2. **Реализуйте резервные стратегии** - обеспечьте доступность данных при сбоях
3. **Используйте прокси-серверы** - для преобразования форматов и протоколов
4. **Документируйте преобразования** - четко описывайте, как данные конвертируются
5. **Тестируйте интеграцию** - обеспечьте надежность работы с устаревшими системами
6. **Планируйте миграцию** - постепенно переходите к современным решениям

## Безопасность

- Используйте прокси-серверы для изоляции устаревших систем
- Ограничивайте доступ к устаревшим интерфейсам
- Проверяйте и валидируйте все данные из устаревших систем
- Шифруйте соединения с устаревшими системами

## Связанные темы

- [[Интеграция с API]]
- [[Интеграция с микросервисами]]
- [[Архитектура фронтенд-приложений]]
- [[Тестирование интеграции]]

#frontend #legacy #integration #architecture