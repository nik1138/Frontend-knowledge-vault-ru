# Архитектура Производительности и Оптимизации

Архитектура производительности и оптимизации — это совокупность принципов, паттернов и практик, направленных на создание высокопроизводительных, быстрых и эффективных веб-приложений. Производительность является критическим фактором пользовательского опыта и напрямую влияет на вовлеченность, конверсию и удовлетворенность пользователей.

## Что такое Производительность в Контексте Frontend

Производительность frontend приложения охватывает несколько аспектов:

1. **Время загрузки** — как быстро приложение загружается и становится интерактивным
2. **Отзывчивость** — как быстро приложение реагирует на действия пользователя
3. **Плавность** — отсутствие задержек и фризов в интерфейсе
4. **Эффективность использования ресурсов** — оптимальное использование CPU, памяти и сети

## Ключевые Метрики Производительности

### 1. Core Web Vitals

Набор метрик, определенных Google как критически важные для пользовательского опыта:

#### Largest Contentful Paint (LCP)
Время от начала загрузки страницы до отображения самого большого элемента содержимого.
- **Хорошо**: менее 2.5 секунд
- **Удовлетворительно**: 2.5-4 секунды
- **Плохо**: более 4 секунд

#### First Input Delay (FID)
Время от первого взаимодействия пользователя с страницей до момента, когда браузер может начать обрабатывать это взаимодействие.
- **Хорошо**: менее 100 мс
- **Удовлетворительно**: 100-300 мс
- **Плохо**: более 300 мс

#### Cumulative Layout Shift (CLS)
Сумма всех неожиданных сдвигов макета, произошедших в течение всего срока жизни страницы.
- **Хорошо**: менее 0.1
- **Удовлетворительно**: 0.1-0.25
- **Плохо**: более 0.25

### 2. Дополнительные Метрики

#### First Contentful Paint (FCP)
Время от начала загрузки страницы до отображения первого элемента содержимого.

#### Time to Interactive (TTI)
Время, необходимое для того, чтобы страница стала полностью интерактивной.

#### Total Blocking Time (TBT)
Сумма всех периодов между FCP и TTI, когда задача блокировала основной поток на более чем 50 мс.

## Архитектурные Принципы Оптимизации

### 1. Проактивная Оптимизация

Оптимизация, реализованная на этапе проектирования и разработки:

#### Архитектура Компонентов
- Ленивая загрузка компонентов
- Оптимизация рендеринга
- Использование мемоизации

Пример:
```javascript
// Lazy loading компонента
const LazyComponent = lazy(() => import('./HeavyComponent'));

// Мемоизация компонента
const MemoizedComponent = memo(ExpensiveComponent, (prevProps, nextProps) => {
  return prevProps.value === nextProps.value;
});
```

#### Управление Состоянием
- Минимизация перерисовок
- Оптимизация селекторов
- Использование структур данных, оптимизированных для производительности

Пример:
```javascript
// Оптимизированный селектор
const selectUserPosts = createSelector(
  [selectUsers, selectPosts, (state, userId) => userId],
  (users, posts, userId) => posts.filter(post => post.userId === userId)
);

// Использование производных данных
const useDerivedState = (data) => {
  return useMemo(() => {
    return data.map(item => ({
      ...item,
      fullName: `${item.firstName} ${item.lastName}`,
      isAdult: item.age >= 18
    }));
  }, [data]);
};
```

### 2. Оптимизация Загрузки

#### Code Splitting
Разделение кода на более мелкие чанки для уменьшения размера начальной загрузки.

Пример:
```javascript
// Route-based code splitting
const Home = lazy(() => import('./pages/Home'));
const Profile = lazy(() => import('./pages/Profile'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

// Component-based code splitting
const HeavyChart = lazy(() => import('./components/HeavyChart'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Suspense>
  );
}
```

#### Tree Shaking
Удаление неиспользуемого кода из бандла.

Пример:
```javascript
// Вместо импорта всего модуля
import * as lodash from 'lodash';
// Используйте только необходимые функции
import { debounce, throttle } from 'lodash';

// Или используйте пути к конкретным модулям
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
```

#### Предзагрузка Ресурсов
Загрузка критических ресурсов заранее.

Пример:
```html
<!-- Предзагрузка критических ресурсов -->
<link rel="preload" href="/critical-styles.css" as="style">
<link rel="preload" href="/main-font.woff2" as="font" type="font/woff2" crossorigin>

<!-- Предзагрузка модулей -->
<link rel="modulepreload" href="/critical-module.js">
```

### 3. Оптимизация Рендеринга

#### Virtualization
Рендеринг только видимых элементов в больших списках.

Пример:
```javascript
// Использование react-window для виртуализации списков
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

#### Мемоизация
Кэширование результатов вычислений для избежания повторных вычислений.

Пример:
```javascript
// Мемоизация сложных вычислений
const useExpensiveCalculation = (data) => {
  return useMemo(() => {
    // Сложные вычисления
    return data.reduce((acc, item) => {
      // Тяжелые операции
      return acc + complexOperation(item);
    }, 0);
  }, [data]);
};

// Мемоизация компонентов
const ExpensiveComponent = memo(({ data }) => {
  const result = useExpensiveCalculation(data);
  return <div>{result}</div>;
});
```

## Техники Оптимизации

### 1. Оптимизация Изображений

#### Форматы Изображений
- **WebP** — современный формат с лучшим сжатием
- **AVIF** — еще более эффективный формат
- **SVG** — для векторной графики

Пример:
```html
<!-- Адаптивные изображения с современными форматами -->
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="Description" loading="lazy">
</picture>
```

#### Lazy Loading
Отложенная загрузка изображений.

Пример:
```html
<!-- Встроенный lazy loading -->
<img src="image.jpg" alt="Description" loading="lazy">

<!-- С помощью JavaScript -->
<img data-src="image.jpg" alt="Description" class="lazy">
```

```javascript
// Intersection Observer для lazy loading
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.classList.remove('lazy');
      imageObserver.unobserve(img);
    }
  });
});

document.querySelectorAll('img.lazy').forEach(img => {
  imageObserver.observe(img);
});
```

### 2. Оптимизация CSS

#### Critical CSS
Встраивание критических стилей в HTML для ускорения первого рендера.

Пример:
```html
<head>
  <style>
    /* Critical CSS */
    body { margin: 0; font-family: Arial; }
    .header { background: #333; color: white; }
    .main { padding: 20px; }
  </style>
  <link rel="preload" href="/styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>
```

#### CSS Modules и Изоляция
Предотвращение конфликтов стилей и уменьшение размера бандла.

Пример:
```css
/* Button.module.css */
.button {
  padding: 10px 20px;
  background: #007bff;
  border: none;
  border-radius: 4px;
}

.button:hover {
  background: #0056b3;
}
```

```javascript
import styles from './Button.module.css';

const Button = ({ children }) => (
  <button className={styles.button}>
    {children}
  </button>
);
```

### 3. Оптимизация JavaScript

#### Debouncing и Throttling
Ограничение частоты выполнения функций.

Пример:
```javascript
// Debouncing для поиска
const debouncedSearch = debounce((query) => {
  performSearch(query);
}, 300);

// Throttling для scroll обработчиков
const throttledScrollHandler = throttle(() => {
  updateScrollPosition();
}, 16); // ~60fps

window.addEventListener('scroll', throttledScrollHandler);
```

#### Web Workers
Выполнение тяжелых операций в фоновом потоке.

Пример:
```javascript
// main.js
const worker = new Worker('/worker.js');

worker.postMessage({ data: largeDataSet });

worker.onmessage = (event) => {
  console.log('Результат обработки:', event.data);
};

// worker.js
self.onmessage = (event) => {
  const { data } = event.data;
  const result = performHeavyCalculation(data);
  self.postMessage(result);
};
```

## Инструменты для Измерения Производительности

### 1. Lighthouse

Инструмент от Google для аудита качества веб-страниц.

Пример использования:
```bash
# Запуск Lighthouse из командной строки
npx lighthouse https://example.com --output html --output-path ./report.html
```

### 2. Web Vitals Extension

Браузерное расширение для мониторинга Core Web Vitals в реальном времени.

### 3. Performance API

Встроенный API браузера для измерения производительности.

Пример:
```javascript
// Измерение времени выполнения
const start = performance.now();
performTask();
const end = performance.now();
console.log(`Task took ${end - start} milliseconds`);

// Навигационные метрики
const navigationEntries = performance.getEntriesByType('navigation');
console.log(navigationEntries[0]);
```

## Практики Производительности

### 1. Progressive Enhancement

Постепенное улучшение функциональности от базового к расширенному.

Пример:
```html
<!-- Базовая функциональность -->
<button id="like-button">Like</button>

<script>
  // Улучшение с JavaScript
  document.getElementById('like-button').addEventListener('click', () => {
    // Асинхронное обновление
    fetch('/api/like', { method: 'POST' })
      .then(() => {
        // Обновление UI
        this.classList.add('liked');
      });
  });
</script>
```

### 2. Graceful Degradation

Обеспечение базовой функциональности при отсутствии определенных возможностей.

Пример:
```javascript
// Проверка поддержки функций
if ('serviceWorker' in navigator) {
  // Регистрация Service Worker
  navigator.serviceWorker.register('/sw.js');
} else {
  // Альтернативная реализация
  console.log('Service Workers not supported');
}
```

### 3. Resource Prioritization

Правильное определение приоритетов загрузки ресурсов.

Пример:
```html
<!-- Высокий приоритет для критических ресурсов -->
<link rel="stylesheet" href="/critical.css" media="all">

<!-- Низкий приоритет для не критических ресурсов -->
<link rel="stylesheet" href="/print.css" media="print" onload="this.media='all'">

<!-- Предзагрузка шрифтов -->
<link rel="preload" href="/font.woff2" as="font" type="font/woff2" crossorigin>
```

## Мониторинг Производительности

### 1. Real User Monitoring (RUM)

Сбор данных о производительности от реальных пользователей.

Пример:
```javascript
// Отправка метрик производительности
const sendPerformanceMetrics = () => {
  const navigation = performance.getEntriesByType('navigation')[0];
  const metrics = {
    lcp: getLCP(),
    fid: getFID(),
    cls: getCLS(),
    pageLoadTime: navigation.loadEventEnd - navigation.fetchStart
  };
  
  // Отправка в аналитику
  analytics.track('Performance Metrics', metrics);
};
```

### 2. Synthetic Monitoring

Регулярное тестирование производительности с фиксированных точек.

Пример:
```javascript
// Планирование регулярных тестов
setInterval(() => {
  runPerformanceTest()
    .then(results => sendToMonitoring(results))
    .catch(error => logError(error));
}, 300000); // Каждые 5 минут
```

## Связанные Концепции

- [[Архитектура]]
- [[Компонентная Архитектура]]
- [[Архитектура API и Интеграций]]
- [[Масштабируемость Приложений]]
- [[PWA Архитектура]]

## Теги

#performance #optimization #frontend #architecture #web-vitals #loading #rendering #javascript #css