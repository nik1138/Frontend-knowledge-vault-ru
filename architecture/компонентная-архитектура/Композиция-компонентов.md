---
aliases: [Композиция компонентов, Композиционная архитектура]
tags: [frontend, architecture, component-composition, react-patterns]
---

# Композиция компонентов

## Обзор

Композиция компонентов - это фундаментальный принцип компонентной архитектуры, при котором сложные компоненты создаются путем объединения более простых. В 2025 году композиция остается ключевым подходом к построению масштабируемых и поддерживаемых фронтенд-приложений, особенно в российском контексте, где важна эффективность командной разработки.

## Принципы композиции

### 1. Композиция вместо наследования
В отличие от классических объектно-ориентированных подходов, в компонентной архитектуре предпочтение отдается композиции вместо наследования. Это позволяет создавать более гибкие и легко поддерживаемые системы.

```jsx
// Плохо - использование наследования
class SpecialButton extends BaseButton {
  render() {
    return <button className="special">{super.render()}</button>;
  }
}

// Хорошо - композиция
const SpecialButton = ({ children, ...props }) => (
  <BaseButton className="special" {...props}>
    {children}
  </BaseButton>
);
```

### 2. Контейнеры и презентационные компоненты
Разделение компонентов на контейнеры (отвечающие за логику и состояние) и презентационные (отвечающие за визуализацию) позволяет лучше структурировать код.

```jsx
// Презентационный компонент
const UserCard = ({ user, onEdit }) => (
  <div className="user-card">
    <h3>{user.name}</h3>
    <p>{user.email}</p>
    <button onClick={onEdit}>Редактировать</button>
  </div>
);

// Контейнерный компонент
const UserCardContainer = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);
  
  const handleEdit = () => {
    // Логика редактирования
  };
  
  if (loading) return <LoadingSpinner />;
  
  return <UserCard user={user} onEdit={handleEdit} />;
};
```

## Паттерны композиции

### 1. Паттерн "Дети" (Children)
Использование `children` пропа позволяет создавать гибкие компоненты, которые могут содержать другие компоненты.

```jsx
const Card = ({ children, title }) => (
  <div className="card">
    <h2>{title}</h2>
    <div className="card-content">
      {children}
    </div>
  </div>
);

// Использование
const UserProfile = ({ user }) => (
  <Card title="Профиль пользователя">
    <Avatar src={user.avatar} />
    <UserInfo user={user} />
    <UserActions userId={user.id} />
  </Card>
);
```

### 2. Паттерн "Контекст" (Context)
Контекст позволяет передавать данные глубоко в дереве компонентов без необходимости прокидывать пропсы на каждом уровне.

```jsx
// Создание контекста темы
const ThemeContext = createContext();

// Провайдер темы
const ThemeProvider = ({ children, initialTheme = 'light' }) => {
  const [theme, setTheme] = useState(initialTheme);
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Компонент, использующий контекст
const ThemedButton = ({ children, ...props }) => {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <button 
      className={`btn btn--${theme}`}
      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
      {...props}
    >
      {children}
    </button>
  );
};
```

### 3. Паттерн "Render Props"
Паттерн Render Props позволяет передавать функцию, которая возвращает JSX, позволяя компоненту контролировать, что и как рендерить.

```jsx
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);
  
  return children({ data, loading, error });
};

// Использование
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error }) => {
      if (loading) return <LoadingSpinner />;
      if (error) return <ErrorMessage error={error} />;
      return (
        <ul>
          {data.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      );
    }}
  </DataFetcher>
);
```

### 4. Паттерн "Higher-Order Components" (HOC)
HOC - это функции, которые принимают компонент и возвращают новый компонент с дополнительной функциональностью.

```jsx
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <LoadingSpinner />;
    }
    return <WrappedComponent {...props} />;
  };
};

const EnhancedUserCard = withLoading(UserCard);
```

## Композиция в российских реалиях 2025 года

В условиях российского рынка композиция компонентов особенно важна по следующим причинам:

### 1. Работа с legacy-кодом
Многие компании сталкиваются с необходимостью интеграции новых компонентов в существующие системы. Композиция позволяет постепенно обновлять архитектуру без полной переписки.

### 2. Многонациональные команды
Композиция позволяет разным командам работать над разными частями приложения, используя общий набор компонентов.

### 3. Адаптивность под регулирование
В условиях меняющегося регулирования компонентная архитектура позволяет быстро адаптировать интерфейсы под новые требования.

## Практические рекомендации

### 1. Используйте композицию для создания универсальных компонентов
```jsx
// Универсальный компонент формы
const Form = ({ 
  children, 
  onSubmit, 
  validationSchema,
  initialValues 
}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  
  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await validationSchema.validate(values);
      onSubmit(values);
    } catch (error) {
      setErrors(error.inner.reduce((acc, err) => {
        acc[err.path] = err.message;
        return acc;
      }, {}));
    }
  };
  
  const contextValue = { values, errors, handleChange };
  
  return (
    <form onSubmit={handleSubmit}>
      <FormContext.Provider value={contextValue}>
        {children}
      </FormContext.Provider>
      <button type="submit">Отправить</button>
    </form>
  );
};

// Использование
const UserForm = () => (
  <Form 
    initialValues={{ name: '', email: '' }} 
    onSubmit={handleSubmit}
    validationSchema={userValidationSchema}
  >
    <InputField name="name" label="Имя" />
    <InputField name="email" label="Email" />
  </Form>
);
```

### 2. Создавайте композиционные слои для бизнес-логики
```jsx
// Компонент, объединяющий UI и бизнес-логику
const UserProfileManager = ({ userId }) => {
  const { data: user, loading, error } = useUser(userId);
  const { updateProfile, updating } = useUpdateProfile();
  
  if (loading) return <Loading />;
  if (error) return <ErrorDisplay error={error} />;
  
  return (
    <Form
      initialValues={user}
      onSubmit={updateProfile}
      disabled={updating}
    >
      <ProfileEditor user={user} />
    </Form>
  );
};
```

## Заключение

Композиция компонентов - это ключ к созданию гибкой, масштабируемой и поддерживаемой архитектуры. В 2025 году этот подход остается актуальным как в глобальном контексте, так и в условиях российского рынка, где важна адаптивность и эффективность разработки.

## См. также
- [[Атомарный дизайн]]
- [[Иерархия компонентов]]
- [[Переиспользование компонентов]]
- [[Состояние компонентов]]