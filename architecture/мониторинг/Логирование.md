---
aliases: ["Логирование приложений", "Frontend Logging", "Client-side Logging"]
tags: 
  - monitoring
  - logging
  - frontend
  - debugging
---

# Логирование фронтенд-приложений

## Обзор

Логирование фронтенд-приложений - это процесс сбора, хранения и анализа событий, происходящих в клиентской части веб-приложений. Эффективное логирование позволяет разработчикам отслеживать поведение приложения, выявлять ошибки и проблемы, а также понимать, как пользователи взаимодействуют с интерфейсом.

## Типы логов

### 1. Логи ошибок (Error Logs)

```javascript
// Структурированные логи ошибок
function logError(error, context = {}) {
  const errorLog = {
    level: 'error',
    message: error.message,
    stack: error.stack,
    timestamp: new Date().toISOString(),
    url: window.location.href,
    userAgent: navigator.userAgent,
    context: context
  };
  
  // Отправляем лог на сервер
  sendLog(errorLog);
}
```

### 2. Логи отладки (Debug Logs)

```javascript
// Условное логирование для отладки
function debugLog(message, data = null) {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[DEBUG] ${message}`, data);
  }
  
  // В production можно отправлять только критические отладочные логи
  if (shouldLogInProduction(message)) {
    sendLog({
      level: 'debug',
      message: message,
      data: data,
      timestamp: new Date().toISOString()
    });
  }
}
```

### 3. Логи пользовательских действий (User Action Logs)

```javascript
// Логирование пользовательских действий
function logUserAction(action, payload = {}) {
  const actionLog = {
    level: 'info',
    type: 'user_action',
    action: action,
    payload: payload,
    timestamp: new Date().toISOString(),
    sessionId: getSessionId(),
    userId: getCurrentUserId()
  };
  
  sendLog(actionLog);
}

// Пример использования
document.getElementById('submit-button').addEventListener('click', () => {
  logUserAction('form_submit', {
    formId: 'registration-form',
    fields: ['name', 'email', 'password']
  });
});
```

### 4. Логи производительности (Performance Logs)

```javascript
// Логирование метрик производительности
function logPerformance(metric, value) {
  const perfLog = {
    level: 'info',
    type: 'performance',
    metric: metric,
    value: value,
    timestamp: new Date().toISOString()
  };
  
  sendLog(perfLog);
}
```

## Системы логирования

### 1. Встроенные консольные методы

```javascript
// Использование встроенных методов консоли
console.log('Информационное сообщение');
console.warn('Предупреждение');
console.error('Сообщение об ошибке');
console.table(data); // Для табличного вывода
console.group('Группа логов');
console.log('Вложенное сообщение');
console.groupEnd();
```

### 2. Кастомная система логирования

```javascript
class Logger {
  constructor(options = {}) {
    this.level = options.level || 'info';
    this.transport = options.transport || console;
    this.prefix = options.prefix || '';
    this.enabled = options.enabled !== false;
  }
  
  log(level, message, data = null) {
    if (!this.enabled || !this.shouldLog(level)) {
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level,
      message: message,
      data: data,
      prefix: this.prefix
    };
    
    this.transport[level](logEntry);
    this.sendToServer(logEntry);
  }
  
  shouldLog(level) {
    const levels = { error: 0, warn: 1, info: 2, debug: 3 };
    return levels[level] <= levels[this.level];
  }
  
  sendToServer(logEntry) {
    // Отправка логов на сервер асинхронно
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/logs', JSON.stringify(logEntry));
    } else {
      fetch('/logs', {
        method: 'POST',
        body: JSON.stringify(logEntry),
        headers: { 'Content-Type': 'application/json' }
      }).catch(() => {
        // Игнорируем ошибки отправки логов
      });
    }
  }
  
  error(message, data) { this.log('error', message, data); }
  warn(message, data) { this.log('warn', message, data); }
  info(message, data) { this.log('info', message, data); }
  debug(message, data) { this.log('debug', message, data); }
}

// Использование кастомного логгера
const logger = new Logger({ level: 'info', prefix: 'App' });
logger.info('Приложение запущено');
```

## Управление объемом логов

### 1. Фильтрация логов

```javascript
// Фильтрация логов по типу и важности
class LogFilter {
  constructor(config) {
    this.config = config;
    this.rateLimit = new Map(); // Для ограничения частоты
  }
  
  shouldSend(logEntry) {
    // Фильтрация по уровню важности
    if (!this.isLevelAllowed(logEntry.level)) {
      return false;
    }
    
    // Ограничение частоты отправки для одного типа ошибок
    const key = `${logEntry.level}_${logEntry.message}`;
    const now = Date.now();
    
    if (this.rateLimit.has(key)) {
      const lastTime = this.rateLimit.get(key);
      if (now - lastTime < this.config.rateLimitMs) {
        return false; // Пропускаем слишком частые логи
      }
    }
    
    this.rateLimit.set(key, now);
    return true;
  }
  
  isLevelAllowed(level) {
    const allowedLevels = this.config.levels || ['error', 'warn'];
    return allowedLevels.includes(level);
  }
}
```

### 2. Анонимизация данных

```javascript
// Анонимизация чувствительных данных в логах
function anonymizeLogData(data) {
  if (typeof data !== 'object' || data === null) {
    return data;
  }
  
  const anonymized = { ...data };
  
  // Удаление чувствительных полей
  const sensitiveFields = ['password', 'token', 'creditCard', 'ssn'];
  sensitiveFields.forEach(field => {
    if (anonymized.hasOwnProperty(field)) {
      anonymized[field] = '[REDACTED]';
    }
  });
  
  // Анонимизация email
  if (anonymized.email) {
    anonymized.email = anonymized.email.replace(/(.).*(@.*)/, '$1***$2');
  }
  
  return anonymized;
}
```

## Асинхронная отправка логов

```javascript
// Асинхронная очередь для отправки логов
class LogQueue {
  constructor(options = {}) {
    this.maxQueueSize = options.maxQueueSize || 100;
    this.batchSize = options.batchSize || 10;
    this.flushInterval = options.flushInterval || 5000;
    this.queue = [];
    this.timer = null;
  }
  
  add(logEntry) {
    if (this.queue.length >= this.maxQueueSize) {
      // Удаляем старые логи, если очередь переполнена
      this.queue.shift();
    }
    
    this.queue.push(logEntry);
    
    if (this.queue.length >= this.batchSize) {
      this.flush();
    } else if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), this.flushInterval);
    }
  }
  
  flush() {
    if (this.queue.length === 0) return;
    
    const batch = this.queue.splice(0, this.batchSize);
    this.sendBatch(batch);
    
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  
  sendBatch(batch) {
    // Анонимизируем данные перед отправкой
    const anonymizedBatch = batch.map(entry => ({
      ...entry,
      data: anonymizeLogData(entry.data)
    }));
    
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/logs', JSON.stringify(anonymizedBatch));
    } else {
      fetch('/logs', {
        method: 'POST',
        body: JSON.stringify(anonymizedBatch),
        headers: { 'Content-Type': 'application/json' }
      }).catch(() => {
        // Возвращаем логи в очередь при ошибке
        this.queue.unshift(...batch);
      });
    }
  }
}

const logQueue = new LogQueue();
```

## Обработка ошибок логирования

```javascript
// Обертка для безопасного логирования
function safeLog(level, message, data) {
  try {
    const logEntry = {
      level: level,
      message: message,
      data: data,
      timestamp: new Date().toISOString(),
      url: window.location.href
    };
    
    // Отправляем в консоль для разработки
    if (typeof console !== 'undefined' && console[level]) {
      console[level](logEntry);
    }
    
    // Отправляем на сервер
    logQueue.add(logEntry);
  } catch (error) {
    // Используем более простой метод отправки при ошибках в логировании
    try {
      fetch('/logs', {
        method: 'POST',
        body: JSON.stringify({ error: 'Logging failed', originalError: error.message }),
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (e) {
      // Если и это не работает, просто игнорируем
      console.warn('Failed to log error', e);
    }
  }
}
```

## Логирование асинхронных операций

```javascript
// Логирование асинхронных операций с корреляцией
function logAsyncOperation(operationName, asyncFn) {
  const operationId = generateId();
  const startTime = Date.now();
  
  safeLog('info', `Starting operation: ${operationName}`, { operationId });
  
  return asyncFn().then(result => {
    const duration = Date.now() - startTime;
    safeLog('info', `Operation completed: ${operationName}`, { 
      operationId, 
      duration,
      status: 'success'
    });
    return result;
  }).catch(error => {
    const duration = Date.now() - startTime;
    safeLog('error', `Operation failed: ${operationName}`, { 
      operationId, 
      duration,
      status: 'error',
      error: error.message
    });
    throw error;
  });
}

// Пример использования
logAsyncOperation('API call', () => fetch('/api/data'));
```

## Заключение

Эффективное логирование фронтенд-приложений требует баланса между информативностью и производительностью. Правильная система логирования должна быть надежной, не мешать работе основного приложения и обеспечивать анонимизацию чувствительных данных.

## См. также

- [[Архитектура-мониторинга]]
- [[Сбор-метрик]]
- [[Алертинг]]
- [[Аналитика]]