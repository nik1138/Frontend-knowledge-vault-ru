---
aliases: [Monitoring and Observability, Observability Architecture, Metrics Collection, Alerting Systems]
tags: [architecture, monitoring, observability, metrics, logging, tracing, alerting, dashboard]
---

# Единая архитектура мониторинга и наблюдаемости

## Обзор

Архитектура мониторинга и наблюдаемости обеспечивает видимость состояния приложения, его производительности и пользовательского опыта. Она включает в себя сбор, хранение, визуализацию и анализ метрик, логов и трейсов для обеспечения надежности и эффективности систем.

## Основные компоненты архитектуры

### 1. Сбор метрик

Система сбора метрик позволяет отслеживать ключевые показатели производительности (KPI) и технические метрики приложения:

```javascript
// Пример системы сбора метрик
class MetricsCollector {
  constructor(exporter) {
    this.metrics = new Map();
    this.exporter = exporter;
  }

  createCounter(name, description = '') {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, {
        type: 'counter',
        value: 0,
        description
      });
    }
    return {
      increment: (amount = 1) => {
        const metric = this.metrics.get(name);
        metric.value += amount;
      }
    };
  }

  createGauge(name, description = '') {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, {
        type: 'gauge',
        value: 0,
        description
      });
    }
    return {
      set: (value) => {
        const metric = this.metrics.get(name);
        metric.value = value;
      },
      increment: (amount = 1) => {
        const metric = this.metrics.get(name);
        metric.value += amount;
      },
      decrement: (amount = 1) => {
        const metric = this.metrics.get(name);
        metric.value -= amount;
      }
    };
  }

  createHistogram(name, description = '', buckets = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, {
        type: 'histogram',
        values: [],
        buckets: buckets.map(b => ({ upperBound: b, count: 0 })),
        description
      });
    }
    return {
      observe: (value) => {
        const metric = this.metrics.get(name);
        metric.values.push(value);
        
        // Обновление бакетов
        for (const bucket of metric.buckets) {
          if (value <= bucket.upperBound) {
            bucket.count++;
          }
        }
      }
    };
  }

  async export() {
    const metricsData = {};
    for (const [name, metric] of this.metrics) {
      metricsData[name] = metric;
    }
    return await this.exporter.export(metricsData);
  }
}

// Пример использования метрик
const metricsCollector = new MetricsCollector(new PrometheusExporter());

const httpRequestCounter = metricsCollector.createCounter('http_requests_total', 'Total HTTP requests');
const httpRequestDuration = metricsCollector.createHistogram('http_request_duration_seconds', 'HTTP request duration');
const activeUsersGauge = metricsCollector.createGauge('active_users', 'Number of active users');

// В middleware для HTTP запросов
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestCounter.increment();
    httpRequestDuration.observe(duration);
  });
  
  next();
});
```

### 2. Система логирования

Система логирования обеспечивает структурированное хранение информации о событиях в приложении:

```javascript
// Пример структурированного логирования
class StructuredLogger {
  constructor(config) {
    this.level = config.level || 'info';
    this.transports = config.transports || [];
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3
    };
  }

  log(level, message, metadata = {}) {
    if (this.levels[level] > this.levels[this.level]) {
      return; // Уровень логирования не требует записи
    }

    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...metadata
    };

    // Отправка лога во все транспорты
    for (const transport of this.transports) {
      transport.write(logEntry);
    }
  }

  error(message, metadata = {}) {
    this.log('error', message, metadata);
  }

  warn(message, metadata = {}) {
    this.log('warn', message, metadata);
  }

  info(message, metadata = {}) {
    this.log('info', message, metadata);
  }

  debug(message, metadata = {}) {
    this.log('debug', message, metadata);
  }
}

// Пример транспорта для отправки логов в удаленную систему
class HTTPTransport {
  constructor(url) {
    this.url = url;
  }

  async write(logEntry) {
    try {
      await fetch(this.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(logEntry)
      });
    } catch (error) {
      console.error('Failed to send log:', error);
    }
  }
}

// Использование структурированного логирования
const logger = new StructuredLogger({
  level: 'info',
  transports: [
    new HTTPTransport('https://logs.example.com/api/logs'),
    new ConsoleTransport()
  ]
});

logger.info('User logged in', {
  userId: '12345',
  sessionId: 'abcde',
  ip: '192.168.1.1',
  userAgent: 'Mozilla/5.0...'
});
```

### 3. Система трейсинга

Система трейсинга позволяет отслеживать путь запроса через распределенную систему:

```javascript
// Пример системы трейсинга
class Tracer {
  constructor(exporter) {
    this.exporter = exporter;
    this.activeSpans = new Map();
  }

  startSpan(name, parentSpan = null) {
    const spanId = this.generateId();
    const traceId = parentSpan ? parentSpan.traceId : this.generateId();
    const span = {
      spanId,
      traceId,
      name,
      startTime: Date.now(),
      endTime: null,
      parentSpanId: parentSpan ? parentSpan.spanId : null,
      attributes: {},
      events: []
    };

    this.activeSpans.set(spanId, span);
    return span;
  }

  endSpan(span) {
    span.endTime = Date.now();
    this.exporter.exportSpan(span);
    this.activeSpans.delete(span.spanId);
  }

  addEvent(span, name, attributes = {}) {
    span.events.push({
      name,
      timestamp: Date.now(),
      attributes
    });
  }

  setAttribute(span, key, value) {
    span.attributes[key] = value;
  }

  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
}

// Пример использования трейсинга в HTTP сервисе
class HTTPServiceTracer {
  constructor(tracer) {
    this.tracer = tracer;
  }

  traceMiddleware(req, res, next) {
    const span = this.tracer.startSpan(`${req.method} ${req.path}`);
    
    this.tracer.setAttribute(span, 'http.method', req.method);
    this.tracer.setAttribute(span, 'http.url', req.url);
    this.tracer.setAttribute(span, 'http.client_ip', req.ip);
    
    // Продолжение выполнения запроса
    const originalEnd = res.end;
    res.end = (chunk, encoding, callback) => {
      this.tracer.setAttribute(span, 'http.status_code', res.statusCode);
      this.tracer.endSpan(span);
      originalEnd.call(res, chunk, encoding, callback);
    };
    
    next();
  }
}
```

## Системы оповещения

### 1. Настройка правил оповещения

```javascript
// Пример системы оповещения
class AlertManager {
  constructor(notificationService) {
    this.notificationService = notificationService;
    this.rules = [];
    this.activeAlerts = new Map();
  }

  addRule(rule) {
    this.rules.push(rule);
  }

  async evaluate(metrics) {
    for (const rule of this.rules) {
      const alerts = await rule.evaluate(metrics);
      
      for (const alert of alerts) {
        if (this.shouldTriggerAlert(alert)) {
          await this.triggerAlert(alert);
        } else if (this.shouldResolveAlert(alert)) {
          await this.resolveAlert(alert);
        }
      }
    }
  }

  shouldTriggerAlert(alert) {
    // Проверка, нужно ли сработать алерту
    const existingAlert = this.activeAlerts.get(alert.fingerprint);
    
    if (!existingAlert) {
      return true; // Новый алерт
    }
    
    // Если алерт уже сработал, но статус изменился на проблему
    return existingAlert.status !== 'firing' && alert.status === 'firing';
  }

  async triggerAlert(alert) {
    alert.status = 'firing';
    alert.startsAt = new Date().toISOString();
    this.activeAlerts.set(alert.fingerprint, alert);
    
    await this.notificationService.send(alert);
  }

  async resolveAlert(alert) {
    const existingAlert = this.activeAlerts.get(alert.fingerprint);
    if (existingAlert) {
      existingAlert.status = 'resolved';
      existingAlert.endsAt = new Date().toISOString();
      
      await this.notificationService.send(existingAlert);
      this.activeAlerts.delete(alert.fingerprint);
    }
  }

  shouldResolveAlert(alert) {
    // Проверка, нужно ли снять алерт
    const existingAlert = this.activeAlerts.get(alert.fingerprint);
    return existingAlert && existingAlert.status === 'firing' && alert.status === 'resolved';
  }
}

// Пример правила оповещения
class HighErrorRateRule {
  constructor(threshold = 0.05, window = 300000) { // 5% ошибок за 5 минут
    this.threshold = threshold;
    this.window = window;
  }

  async evaluate(metrics) {
    const errorCount = metrics['http_requests_total']?.filter(m => m.labels.status >= 500) || [];
    const totalCount = metrics['http_requests_total'] || [];
    
    if (totalCount.length === 0) return [];
    
    const errorRate = errorCount.length / totalCount.length;
    
    if (errorRate > this.threshold) {
      return [{
        labels: {
          alertname: 'HighErrorRate',
          severity: 'critical',
          service: 'frontend'
        },
        annotations: {
          summary: 'High error rate detected',
          description: `Error rate is ${Math.round(errorRate * 100)}%, above threshold of ${this.threshold * 100}%`
        },
        status: 'firing',
        fingerprint: 'high_error_rate_' + Date.now()
      }];
    }
    
    return [{
      labels: { alertname: 'HighErrorRate' },
      status: 'resolved',
      fingerprint: 'high_error_rate_resolved'
    }];
  }
}
```

### 2. Дашборды мониторинга

```javascript
// Пример конфигурации дашборда
const dashboardConfig = {
  title: 'Frontend Application Dashboard',
  refresh: '30s',
  tags: ['frontend', 'performance', 'user-experience'],
  panels: [
    {
      id: 1,
      title: 'Requests per Second',
      type: 'graph',
      targets: [
        {
          expr: 'rate(http_requests_total[1m])',
          legendFormat: '{{method}} {{path}}'
        }
      ],
      yAxes: [
        {
          label: 'Requests/sec',
          format: 'reqps'
        }
      ]
    },
    {
      id: 2,
      title: 'Average Response Time',
      type: 'graph',
      targets: [
        {
          expr: 'histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))',
          legendFormat: 'P95 Response Time'
        }
      ],
      yAxes: [
        {
          label: 'Response Time',
          format: 's'
        }
      ]
    },
    {
      id: 3,
      title: 'Error Rate',
      type: 'graph',
      targets: [
        {
          expr: 'rate(http_requests_total{status=~"5.."}[1m]) / rate(http_requests_total[1m]) * 100',
          legendFormat: 'Error Rate (%)'
        }
      ],
      yAxes: [
        {
          label: 'Error Rate',
          format: 'percent'
        }
      ]
    },
    {
      id: 4,
      title: 'Active Users',
      type: 'singlestat',
      targets: [
        {
          expr: 'active_users',
          legendFormat: 'Active Users'
        }
      ]
    }
  ]
};
```

## Архитектурные паттерны наблюдаемости

### 1. Observability-Driven Development

```javascript
// Пример архитектуры, ориентированной на наблюдаемость
class ObservabilityDrivenComponent {
  constructor(metricsCollector, logger, tracer) {
    this.metrics = metricsCollector;
    this.logger = logger;
    this.tracer = tracer;
    
    // Создание метрик для компонента
    this.processingCounter = metricsCollector.createCounter(
      'component_processing_total', 
      'Total processing operations'
    );
    this.processingDuration = metricsCollector.createHistogram(
      'component_processing_duration_seconds',
      'Component processing duration'
    );
  }

  async process(data) {
    const span = this.tracer.startSpan('component_process');
    
    try {
      this.processingCounter.increment();
      const start = Date.now();
      
      this.logger.info('Starting processing', {
        dataId: data.id,
        dataSize: data.size
      });
      
      // Основная логика обработки
      const result = await this.doProcessing(data);
      
      const duration = (Date.now() - start) / 1000;
      this.processingDuration.observe(duration);
      
      this.logger.info('Processing completed', {
        dataId: data.id,
        duration,
        resultSize: result.size
      });
      
      return result;
    } catch (error) {
      this.logger.error('Processing failed', {
        dataId: data.id,
        error: error.message,
        stack: error.stack
      });
      
      throw error;
    } finally {
      this.tracer.endSpan(span);
    }
  }
  
  async doProcessing(data) {
    // Реализация основной логики
    return { processed: true, size: data.size };
  }
}
```

### 2. Health Checks

```javascript
// Пример системы проверки работоспособности
class HealthCheckSystem {
  constructor() {
    this.checks = new Map();
  }

  registerCheck(name, checkFunction, interval = 30000) {
    this.checks.set(name, {
      checkFunction,
      interval,
      lastResult: null,
      lastChecked: null
    });
    
    // Запуск периодической проверки
    setInterval(async () => {
      try {
        const result = await checkFunction();
        this.checks.get(name).lastResult = result;
        this.checks.get(name).lastChecked = new Date();
      } catch (error) {
        this.checks.get(name).lastResult = { status: 'error', error: error.message };
        this.checks.get(name).lastChecked = new Date();
      }
    }, interval);
  }

  async getHealthStatus() {
    const status = {
      overall: 'healthy',
      checks: {},
      timestamp: new Date().toISOString()
    };

    for (const [name, check] of this.checks) {
      status.checks[name] = {
        status: check.lastResult?.status || 'unknown',
        lastChecked: check.lastChecked,
        details: check.lastResult
      };

      if (check.lastResult?.status === 'error') {
        status.overall = 'unhealthy';
      } else if (check.lastResult?.status === 'warning' && status.overall === 'healthy') {
        status.overall = 'degraded';
      }
    }

    return status;
  }
}

// Примеры конкретных проверок
const healthCheckSystem = new HealthCheckSystem();

// Проверка базы данных
healthCheckSystem.registerCheck('database', async () => {
  try {
    // Проверка соединения с базой данных
    await db.ping();
    return { status: 'healthy', details: { ping: 'ok' } };
  } catch (error) {
    return { status: 'error', details: { error: error.message } };
  }
});

// Проверка внешнего API
healthCheckSystem.registerCheck('external-api', async () => {
  try {
    const response = await fetch('https://api.example.com/health');
    if (response.ok) {
      return { status: 'healthy', details: { response: response.status } };
    } else {
      return { status: 'error', details: { response: response.status } };
    }
  } catch (error) {
    return { status: 'error', details: { error: error.message } };
  }
});
```

## Интеграция с CI/CD

### 1. Мониторинг в процессе развертывания

```yaml
# Пример GitHub Actions с мониторингом после развертывания
name: Deploy with Observability
on:
  push:
    branches: [main]

jobs:
  deploy-and-monitor:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to production
      run: |
        kubectl set image deployment/myapp myapp=myregistry/myapp:${{ github.sha }}
        kubectl rollout status deployment/myapp --timeout=5m
    
    - name: Run smoke tests
      run: npm run smoke-tests
    
    - name: Check metrics after deployment
      run: |
        # Проверка метрик после развертывания
        ./scripts/check-post-deploy-metrics.sh --duration 5m --threshold 95
    
    - name: Rollback if metrics are bad
      if: ${{ failure() }}
      run: |
        echo "Rolling back deployment due to poor metrics"
        kubectl rollout undo deployment/myapp
```

### 2. Система метрик CI/CD

```javascript
// Пример системы сбора метрик CI/CD
class CIMetricsCollector {
  constructor(exporter) {
    this.exporter = exporter;
  }

  collectBuildMetrics(buildInfo) {
    const metrics = {
      build_duration_seconds: {
        value: buildInfo.duration / 1000,
        labels: {
          repository: buildInfo.repository,
          branch: buildInfo.branch,
          result: buildInfo.success ? 'success' : 'failure'
        }
      },
      build_count_total: {
        value: 1,
        labels: {
          repository: buildInfo.repository,
          branch: buildInfo.branch,
          result: buildInfo.success ? 'success' : 'failure'
        }
      },
      build_failure_count_total: {
        value: buildInfo.success ? 0 : 1,
        labels: {
          repository: buildInfo.repository,
          branch: buildInfo.branch
        }
      }
    };

    return this.exporter.export(metrics);
  }

  collectTestMetrics(testResults) {
    const metrics = {
      test_execution_time_seconds: {
        value: testResults.duration / 1000,
        labels: {
          repository: testResults.repository,
          branch: testResults.branch
        }
      },
      test_count_total: {
        value: testResults.total,
        labels: {
          repository: testResults.repository,
          branch: testResults.branch
        }
      },
      test_failure_count_total: {
        value: testResults.failed,
        labels: {
          repository: testResults.repository,
          branch: testResults.branch
        }
      },
      test_success_rate: {
        value: testResults.total > 0 ? (testResults.passed / testResults.total) : 0,
        labels: {
          repository: testResults.repository,
          branch: testResults.branch
        }
      }
    };

    return this.exporter.export(metrics);
  }
}
```

## Связанные архитектурные концепции

- [[../performance/unified-performance-architecture]] - архитектура производительности
- [[../devops/unified-cicd-architecture]] - архитектура CI/CD
- [[../security/unified-security-architecture]] - архитектура безопасности
- [[../testing/unified-testing-architecture]] - архитектура тестирования

## Заключение

Архитектура мониторинга и наблюдаемости является критически важной для обеспечения надежности, производительности и безопасности приложений. Правильная реализация этой архитектуры позволяет быстро выявлять и устранять проблемы, а также принимать обоснованные решения на основе данных о работе системы.

#observability #monitoring #frontend #architecture #logging #metrics #tracing #performance #error-handling #user-experience #analytics #telemetry #opentelemetry #prometheus #grafana #datadog #new-relic #sentry #logging-architecture #metrics-architecture #tracing-architecture #observability-patterns #observability-best-practices #observability-tools #observability-processes #observability-standards #observability-quality #observability-metrics #observability-monitoring #observability-observability #observability-testing #observability-security #observability-performance #observability-scalability #observability-maintainability #observability-usability #observability-reliability #observability-efficiency #observability-portability #observability-interoperability #observability-architecture-patterns #observability-architecture-design #observability-architecture-principles #observability-architecture-components #observability-architecture-layers #observability-architecture-styles #observability-architecture-methodologies #observability-architecture-frameworks #observability-architecture-tools #observability-architecture-processes #observability-architecture-teams #observability-architecture-governance #observability-architecture-compliance #observability-architecture-quality #observability-architecture-metrics #observability-architecture-monitoring #observability-architecture-observability #observability-architecture-testing #observability-architecture-security #observability-architecture-performance #observability-architecture-scalability #observability-architecture-maintainability #observability-architecture-usability #observability-architecture-reliability #observability-architecture-efficiency #observability-architecture-portability #observability-architecture-interoperability #observability-architecture-optimization #observability-architecture-caching #observability-architecture-normalization #observability-architecture-immutable #observability-architecture-serialization #observability-architecture-hydration #observability-architecture-selectors #observability-architecture-actions #observability-architecture-reducers #observability-architecture-middleware #observability-architecture-persistence #observability-architecture-offline #observability-architecture-realtime #observability-architecture-optimistic-updates #observability-architecture-error-handling #observability-architecture-debugging #observability-architecture-ssr #observability-architecture-ssg #observability-architecture-microfrontends #observability-architecture-accessibility #observability-architecture-security #observability-architecture-performance #observability-architecture-scalability #observability-architecture-maintainability