# Паттерны Проектирования в Frontend Разработке

Паттерны проектирования — это проверенные решения для типичных задач проектирования программного обеспечения. В контексте frontend разработки они помогают создавать более структурированный, поддерживаемый и масштабируемый код.

## Что такое Паттерн Проектирования

Паттерн проектирования — это повторяемое архитектурное решение для часто встречающейся проблемы проектирования. Он описывает проблему, решение и последствия применения этого решения.

## Классификация Паттернов

### Порождающие Паттерны (Creational Patterns)

Эти паттерны занимаются созданием объектов и скрывают логику их создания.

#### 1. Фабрика (Factory)

Паттерн, который определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемых объектов.

Пример:
```javascript
class NotificationFactory {
  static createNotification(type, message) {
    switch (type) {
      case 'email':
        return new EmailNotification(message);
      case 'sms':
        return new SMSNotification(message);
      case 'push':
        return new PushNotification(message);
      default:
        throw new Error('Unknown notification type');
    }
  }
}
```

#### 2. Синглтон (Singleton)

Паттерн, гарантирующий, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

Пример:
```javascript
class Logger {
  constructor() {
    if (Logger.instance) {
      return Logger.instance;
    }
    
    Logger.instance = this;
    this.logs = [];
  }
  
  log(message) {
    this.logs.push(message);
    console.log(message);
  }
}
```

#### 3. Модуль (Module)

Паттерн, который позволяет инкапсулировать код и предоставлять только публичный API.

Пример:
```javascript
const UserModule = (() => {
  // Private variables
  let users = [];
  
  // Private methods
  const validateUser = (user) => user.name && user.email;
  
  // Public API
  return {
    addUser(user) {
      if (validateUser(user)) {
        users.push(user);
        return true;
      }
      return false;
    },
    
    getUsers() {
      return [...users]; // Return copy to prevent mutation
    }
  };
})();
```

### Структурные Паттерны (Structural Patterns)

Эти паттерны занимаются компоновкой классов и объектов для формирования более крупных структур.

#### 1. Адаптер (Adapter)

Паттерн, который позволяет объектам с несовместимыми интерфейсами работать вместе.

Пример:
```javascript
class OldPaymentSystem {
  processPayment(amount) {
    return `Processing $${amount} through old system`;
  }
}

class NewPaymentSystem {
  pay(amount) {
    return `Paying $${amount} through new system`;
  }
}

class PaymentAdapter {
  constructor(paymentSystem) {
    this.paymentSystem = paymentSystem;
  }
  
  process(amount) {
    if (this.paymentSystem.processPayment) {
      return this.paymentSystem.processPayment(amount);
    } else {
      return this.paymentSystem.pay(amount);
    }
  }
}
```

#### 2. Декоратор (Decorator)

Паттерн, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

Пример:
```javascript
class Notification {
  send(message) {
    return `Sending: ${message}`;
  }
}

class EmailNotificationDecorator {
  constructor(notification) {
    this.notification = notification;
  }
  
  send(message) {
    return `Email: ${this.notification.send(message)}`;
  }
}

class SMSNotificationDecorator {
  constructor(notification) {
    this.notification = notification;
  }
  
  send(message) {
    return `SMS: ${this.notification.send(message)}`;
  }
}

// Usage
const notification = new Notification();
const emailNotification = new EmailNotificationDecorator(notification);
const smsEmailNotification = new SMSNotificationDecorator(emailNotification);
```

#### 3. Фасад (Facade)

Паттерн, который предоставляет простой интерфейс для сложной системы классов, библиотеки или фреймворка.

Пример:
```javascript
class CPU {
  freeze() { /* ... */ }
  jump(position) { /* ... */ }
  execute() { /* ... */ }
}

class Memory {
  load(position, data) { /* ... */ }
}

class HardDrive {
  read(lba, size) { /* ... */ }
}

class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    this.cpu.freeze();
    this.memory.load(BOOT_ADDRESS, this.hardDrive.read(BOOT_SECTOR, SECTOR_SIZE));
    this.cpu.jump(BOOT_ADDRESS);
    this.cpu.execute();
  }
}
```

### Поведенческие Паттерны (Behavioral Patterns)

Эти паттерны определяют способы взаимодействия между объектами и распределения между ними ответственностей.

#### 1. Наблюдатель (Observer)

Паттерн, который определяет зависимость «один ко многим» между объектами, при которой изменение состояния одного объекта влечёт за собой автоматическое оповещение и обновление всех зависимых объектов.

Пример:
```javascript
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log('Received data:', data);
  }
}
```

#### 2. Стратегия (Strategy)

Паттерн, который определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

Пример:
```javascript
class PaymentProcessor {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  process(amount) {
    return this.strategy.process(amount);
  }
}

class CreditCardStrategy {
  process(amount) {
    return `Processing $${amount} via Credit Card`;
  }
}

class PayPalStrategy {
  process(amount) {
    return `Processing $${amount} via PayPal`;
  }
}
```

#### 3. Команда (Command)

Паттерн, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

Пример:
```javascript
class Command {
  execute() {}
  undo() {}
}

class AddItemCommand extends Command {
  constructor(cart, item) {
    super();
    this.cart = cart;
    this.item = item;
  }
  
  execute() {
    this.cart.addItem(this.item);
  }
  
  undo() {
    this.cart.removeItem(this.item);
  }
}

class Cart {
  constructor() {
    this.items = [];
    this.history = [];
  }
  
  executeCommand(command) {
    command.execute();
    this.history.push(command);
  }
  
  undo() {
    const command = this.history.pop();
    if (command) {
      command.undo();
    }
  }
}
```

## Паттерны, Специфичные для Frontend

### 1. Компонент (Component)

Фундаментальный паттерн современных frontend фреймворков, позволяющий создавать переиспользуемые UI элементы.

### 2. Контейнер/Презентационный Компонент (Container/Presentational)

Разделение компонентов на те, которые управляют данными (контейнеры), и те, которые отвечают за отображение (презентационные).

### 3. Higher-Order Component (HOC)

Функция, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью.

### 4. Render Props

Паттерн, при котором компонент получает функцию в качестве props, которая определяет, что рендерить.

### 5. Хуки (Hooks)

Паттерн, позволяющий использовать состояние и другие возможности React без написания классов.

Пример:
```javascript
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
};
```

## Лучшие Практики

### 1. Не Используйте Паттерны Ради Паттернов

Паттерны должны решать реальные проблемы, а не усложнять код без необходимости.

### 2. Выбирайте Подходящий Паттерн

Разные паттерны решают разные задачи. Важно понимать, когда какой паттерн применять.

### 3. Документируйте Использование Паттернов

Четко документируйте, какие паттерны используются в вашем коде и почему.

### 4. Следуйте Принципам SOLID

Паттерны проектирования хорошо сочетаются с принципами SOLID:
- **S**ingle Responsibility Principle
- **O**pen/Closed Principle
- **L**iskov Substitution Principle
- **I**nterface Segregation Principle
- **D**ependency Inversion Principle

## Связанные Концепции

- [[Компонентная Архитектура]]
- [[Управление Состоянием]]
- [[React Паттерны]]
- [[Vue Паттерны]]

## Теги

#design-patterns #frontend #architecture #react #vue