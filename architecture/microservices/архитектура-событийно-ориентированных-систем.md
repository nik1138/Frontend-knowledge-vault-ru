---
aliases: ["EDA", "Event-Driven Design", "Event Architecture", "Event Driven Architecture", "Событийно-ориентированная архитектура", "Event Driven Architecture"]
tags: ["#eda", "#event-driven-architecture", "#архитектура", "#patterns", "#messaging", "#asynchronous", "#distributed-systems", "#reactive-programming", "#ci-cd", "#microservices", "#api-integration"]
---

# Unified Event-Driven Architecture: Комплексное руководство по архитектуре и реализации

## Введение в Event-Driven Architecture

Event-Driven Architecture (EDA) - это архитектурный подход, при котором элементы системы взаимодействуют друг с другом через события. События представляют собой уведомления о значимых изменениях состояния или действиях, произошедших в системе. EDA особенно важна для интеграции API и фронтенд-приложений, позволяя создавать гибкие, масштабируемые и отзывчивые системы.

Событийно-ориентированная архитектура (Event-Driven Architecture, EDA) - это архитектурный подход, в котором события инициируют и координируют взаимодействие между независимыми компонентами системы. EDA позволяет создавать гибкие, масштабируемые и слабосвязанные системы.

Event-Driven Architecture основана на принципе, что действия в системе инициируются событиями - значимыми изменениями состояния. Это позволяет создавать системы, которые реагируют на изменения в реальном времени, обеспечивают слабую связанность между компонентами и поддерживают асинхронное взаимодействие.

## Основные компоненты EDA

### События (Events)
События - это уведомления о значимых изменениях в системе. Они обычно содержат:
- Идентификатор события
- Тип события
- Данные события
- Время возникновения
- Источник события

### Издатели (Publishers/Producers)
Компоненты, которые создают и публикуют события в системе. Они не знают, кто будет обрабатывать события.

### Подписчики (Subscribers/Consumers)
Компоненты, которые получают и обрабатывают события. Они могут реагировать на события независимо от издателей.

### Брокеры событий (Event Brokers)
Промежуточные компоненты, которые принимают, маршрутизируют и доставляют события между издателями и подписчиками:
- Apache Kafka
- RabbitMQ
- AWS EventBridge
- Google Cloud Pub/Sub

## Типы событий

### События изменений состояния
Сообщают о произошедшем изменении в системе:
- Создание сущности
- Обновление данных
- Удаление ресурса

### Команды (Commands)
Запросы на выполнение определенного действия:
- Создать пользователя
- Оплатить заказ
- Обновить профиль

### Ответы (Responses/Results)
Ответ на команду или запрос:
- Подтверждение выполнения
- Результат операции
- Ошибка выполнения

## Архитектурные компоненты EDA

### Основная схема
```
┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
│   Event     │    │ Event Channel   │    │   Event     │
│   Source    │────│ (Message Bus)   │────│   Handler   │
│             │    │                 │    │             │
│ • UI Events │    │ • Topic/Queue   │    │ • Process   │
│ • Service   │    │ • Broker        │    │ • Business  │
│   Events    │    │ • Stream        │    │   Logic     │
│ • External  │    │ • Pub/Sub       │    │ • Store     │
│   Systems   │    │                 │    │   Results   │
└─────────────┘    └─────────────────┘    └─────────────┘
```

## Типы событий

### 1. Domain Events
```javascript
// Пример доменных событий
class DomainEvent {
  constructor(type, data, metadata = {}) {
    this.id = crypto.randomUUID();
    this.type = type;
    this.data = data;
    this.timestamp = new Date().toISOString();
    this.correlationId = metadata.correlationId || crypto.randomUUID();
    this.causationId = metadata.causationId;
    this.version = metadata.version || 1;
  }
}

// Примеры конкретных событий
class UserRegistered extends DomainEvent {
  constructor(userData) {
    super('UserRegistered', {
      userId: userData.id,
      email: userData.email,
      name: userData.name,
      registrationDate: new Date().toISOString()
    });
  }
}

class OrderCreated extends DomainEvent {
  constructor(orderData) {
    super('OrderCreated', {
      orderId: orderData.id,
      userId: orderData.userId,
      items: orderData.items,
      totalAmount: orderData.totalAmount,
      createdAt: new Date().toISOString()
    });
  }
}

class PaymentProcessed extends DomainEvent {
  constructor(paymentData) {
    super('PaymentProcessed', {
      paymentId: paymentData.id,
      orderId: paymentData.orderId,
      amount: paymentData.amount,
      status: paymentData.status,
      processedAt: new Date().toISOString()
    });
  }
}
```

### 2. Integration Events
```javascript
// События интеграции между сервисами
class IntegrationEvent {
  constructor(type, data, source, timestamp = new Date().toISOString()) {
    this.eventId = crypto.randomUUID();
    this.type = type;
    this.data = data;
    this.source = source;
    this.timestamp = timestamp;
    this.version = '1.0';
  }
}

class UserProfileUpdated extends IntegrationEvent {
  constructor(userData) {
    super('UserProfileUpdated', {
      userId: userData.id,
      name: userData.name,
      email: userData.email,
      updatedAt: new Date().toISOString()
    }, 'user-service');
  }
}

class InventoryReserved extends IntegrationEvent {
  constructor(reservationData) {
    super('InventoryReserved', {
      reservationId: reservationData.id,
      orderId: reservationData.orderId,
      productId: reservationData.productId,
      quantity: reservationData.quantity,
      reservedAt: new Date().toISOString()
    }, 'inventory-service');
  }
}
```

## Реализация Event Bus

### 1. In-Memory Event Bus
```javascript
// Простой in-memory event bus
class EventBus {
  constructor() {
    this.subscribers = new Map();
    this.middleware = [];
  }
  
  subscribe(eventType, handler) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    
    this.subscribers.get(eventType).push(handler);
  }
  
  unsubscribe(eventType, handler) {
    if (this.subscribers.has(eventType)) {
      const handlers = this.subscribers.get(eventType);
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
  
  async publish(event) {
    const eventType = event.constructor.name || event.type;
    const handlers = this.subscribers.get(eventType) || [];
    
    // Применение middleware
    for (const middleware of this.middleware) {
      await middleware(event);
    }
    
    // Асинхронная обработка событий
    const promises = handlers.map(handler => 
      this.executeHandler(handler, event)
    );
    
    await Promise.all(promises);
  }
  
  async executeHandler(handler, event) {
    try {
      await handler(event);
    } catch (error) {
      console.error(`Error in event handler for ${event.type}:`, error);
      // Логирование ошибки и возможно отправка в DLQ
      await this.handleError(event, error);
    }
  }
  
  async handleError(event, error) {
    // Логирование ошибки
    console.error('Event processing error:', {
      eventId: event.id,
      eventType: event.type,
      error: error.message,
      stack: error.stack
    });
    
    // Отправка в очередь ошибок
    await this.sendToErrorQueue(event, error);
  }
  
  use(middleware) {
    this.middleware.push(middleware);
  }
  
  async sendToErrorQueue(event, error) {
    // Реализация отправки в очередь ошибок
    // Может использовать Redis, RabbitMQ, Kafka и т.д.
    const errorEvent = {
      originalEvent: event,
      error: {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      },
      retryCount: 0
    };
    
    // Сохранение в очередь ошибок
    await this.storeErrorEvent(errorEvent);
  }
}

// Использование
const eventBus = new EventBus();

// Регистрация обработчиков
eventBus.subscribe('UserRegistered', async (event) => {
  console.log('Sending welcome email to:', event.data.email);
  // Отправка email
  await emailService.sendWelcomeEmail(event.data.email);
});

eventBus.subscribe('OrderCreated', async (event) => {
  console.log('Processing order:', event.data.orderId);
  // Обработка заказа
  await orderService.processOrder(event.data);
});

// Публикация события
const userRegisteredEvent = new UserRegistered({
  id: 'user-123',
  email: 'user@example.com',
  name: 'John Doe'
});

await eventBus.publish(userRegisteredEvent);
```

### 2. Message Queue Event Bus (RabbitMQ)
```javascript
// RabbitMQ Event Bus
const amqplib = require('amqplib');

class RabbitMQEventBus {
  constructor(connectionOptions) {
    this.connectionOptions = connectionOptions;
    this.connection = null;
    this.channel = null;
    this.subscribers = new Map();
  }
  
  async connect() {
    this.connection = await amqplib.connect(this.connectionOptions);
    this.channel = await this.connection.createChannel();
    
    // Объявление exchange
    await this.channel.assertExchange('events', 'topic', { durable: true });
    
    console.log('Connected to RabbitMQ Event Bus');
  }
  
  async subscribe(eventPattern, handler, queueName = null) {
    if (!this.channel) {
      throw new Error('Event bus not connected');
    }
    
    // Создание очереди для подписки
    const q = await this.channel.assertQueue(queueName || '', { exclusive: true });
    
    // Привязка очереди к паттерну события
    await this.channel.bindQueue(q.queue, 'events', eventPattern);
    
    // Настройка обработчика сообщений
    this.channel.consume(q.queue, async (msg) => {
      if (msg !== null) {
        try {
          const eventData = JSON.parse(msg.content.toString());
          await handler(eventData);
          this.channel.ack(msg);
        } catch (error) {
          console.error('Error processing message:', error);
          // Отправка в DLQ при превышении числа попыток
          if (this.getMessageRetryCount(msg) >= 3) {
            await this.sendToDLQ(msg, error);
            this.channel.ack(msg);
          } else {
            this.channel.nack(msg, false, true); // Повторная отправка
          }
        }
      }
    });
  }
  
  async publish(event, routingKey = null) {
    if (!this.channel) {
      throw new Error('Event bus not connected');
    }
    
    const routingKey = routingKey || event.type.toLowerCase().replace(/\s+/g, '.');
    
    this.channel.publish(
      'events',
      routingKey,
      Buffer.from(JSON.stringify(event)),
      { persistent: true }
    );
  }
  
  async sendToDLQ(message, error) {
    // Отправка сообщения в Dead Letter Queue
    await this.channel.assertExchange('dlq', 'topic', { durable: true });
    this.channel.publish(
      'dlq',
      'failed.events',
      message.content,
      {
        headers: {
          original_routing_key: message.fields.routingKey,
          error: error.message,
          timestamp: new Date().toISOString()
        }
      }
    );
  }
  
  getMessageRetryCount(msg) {
    const headers = msg.properties.headers || {};
    return headers['x-death'] ? headers['x-death'].length : 0;
  }
}

// Использование
const rabbitMQBus = new RabbitMQEventBus('amqp://localhost:5672');
await rabbitMQBus.connect();

// Подписка на события регистрации пользователей
await rabbitMQBus.subscribe('user.registered', async (event) => {
  console.log('User registered:', event.data.email);
  await sendWelcomeEmail(event.data.email);
});

// Подписка на события заказов
await rabbitMQBus.subscribe('order.*', async (event) => {
  console.log('Order event:', event.type, event.data.orderId);
  await processOrderEvent(event);
});
```

### 3. Kafka Event Stream
```javascript
// Apache Kafka Event Stream
const { Kafka } = require('kafkajs');

class KafkaEventStream {
  constructor(kafkaConfig) {
    this.kafka = new Kafka(kafkaConfig);
    this.producer = null;
    this.consumers = new Map();
  }
  
  async connect() {
    this.producer = this.kafka.producer();
    await this.producer.connect();
  }
  
  async subscribe(topic, groupId, handler) {
    const consumer = this.kafka.consumer({ groupId });
    await consumer.connect();
    
    await consumer.subscribe({ topic, fromBeginning: true });
    
    await consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        try {
          const event = JSON.parse(message.value.toString());
          await handler(event, {
            topic,
            partition,
            offset: message.offset
          });
        } catch (error) {
          console.error('Error processing message:', error);
          // Логирование ошибки
          await this.logError(topic, message, error);
        }
      }
    });
    
    this.consumers.set(groupId, consumer);
  }
  
  async publish(topic, event, key = null) {
    if (!this.producer) {
      throw new Error('Kafka producer not connected');
    }
    
    await this.producer.send({
      topic,
      messages: [
        {
          key: key || event.id || crypto.randomUUID(),
          value: JSON.stringify(event),
          headers: {
            'content-type': 'application/json',
            'timestamp': new Date().toISOString()
          }
        }
      ]
    });
  }
  
  async logError(topic, message, error) {
    await this.producer.send({
      topic: 'error-topic',
      messages: [
        {
          key: message.key,
          value: JSON.stringify({
            originalTopic: topic,
            originalMessage: message.value.toString(),
            error: error.message,
            timestamp: new Date().toISOString()
          })
        }
      ]
    });
  }
}

// Использование
const kafkaStream = new KafkaEventStream({
  clientId: 'event-driven-app',
  brokers: ['localhost:9092']
});

await kafkaStream.connect();

// Подписка на топик событий
await kafkaStream.subscribe('user-events', 'user-service-consumer', async (event) => {
  console.log('Received user event:', event.type);
  await handleUserEvent(event);
});
```

## EDA в контексте фронтенд-архитектуры

### Событийная архитектура в браузере
- EventEmitter паттерн
- Custom Events
- Redux с событийной архитектурой
- RxJS и Observable-паттерн
- События DOM и пользовательские события

### Интеграция с API
- WebSocket для реального времени
- Server-Sent Events
- Push-уведомления
- Long polling и другие механизмы

### Событийная архитектура компонентов
- Компоненты как издатели и подписчики
- Событийная коммуникация между компонентами
- Паттерны событийной связи компонентов

## Архитектурные преимущества EDA

### Расширяемость
- Легкое добавление новых подписчиков
- Поддержка новых сценариев без изменения издателей
- Возможность масштабирования отдельных компонентов

### Независимость
- Издатели не зависят от подписчиков
- Подписчики не зависят от издателей
- Модули могут разрабатываться и развертываться независимо

### Гибкость
- Асинхронная обработка
- Различные стратегии обработки событий
- Возможность обработки событий в разном порядке

### Отказоустойчивость
- Известия не зависят от немедленного ответа
- Возможность обработки проблем без остановки системы
- Изоляция сбоев между компонентами

## Архитектурные вызовы EDA

### Сложность отладки
- Сложность отслеживания потоков событий
- Проблемы с синхронизацией состояния
- Неочевидность последовательности обработки

### Управление согласованностью
- Обеспечение согласованности данных
- Обработка конфликтов
- Обновление агрегатов

### Управление порядком событий
- Обеспечение правильного порядка обработки
- Обработка дубликатов
- Обеспечение доставки

## EDA и производительность

### Асинхронная обработка
- Неблокирующая обработка событий
- Параллельная обработка
- Оптимизация производительности

### Масштабирование
- Независимое масштабирование издателей и подписчиков
- Оптимизация потребления ресурсов
- Балансировка нагрузки

### Кэширование событий
- Кэширование результатов обработки событий
- Снижение нагрузки на систему
- Быстрый доступ к часто запрашиваемым данным

## EDA и безопасность

### Аутентификация и авторизация
- Проверка прав доступа к событиям
- Управление безопасностью каналов событий
- Скрытие чувствительных данных в событиях

### Защита от атак
- Ограничение частоты событий (rate limiting)
- Валидация данных событий
- Защита от повторяющихся и вредоносных событий

### Шифрование и конфиденциальность
- Шифрование событий
- Управление чувствительными данными
- Соблюдение норм о конфиденциальности

## EDA и мониторинг

### Трассировка событий
- Отслеживание пути событий через систему
- Correlation IDs для установления связей
- Инструменты распределенной трассировки

### Метрики и логирование
- Сбор метрик обработки событий
- Мониторинг задержек
- Обнаружение аномалий

### Алертинг
- Уведомления о сбоях обработки
- Мониторинг производительности
- Предупреждения о задержках

## EDA и транзакции

### Управление транзакциями
- Обеспечение атомарности операций
- Компенсационные транзакции
- Обработка частичных сбоев

### Согласованность событий
- Управление согласованностью между компонентами
- Обработка конфликтов
- Обновление агрегатов

## EDA в микросервисной архитектуре

### Событийная коммуникация между сервисами
- Коммуникация без прямых зависимостей
- Асинхронная обработка запросов
- Изоляция сбоев между сервисами

### Управление данными
- Согласование данных через события
- Обновление реплицированных данных
- Обработка изменений схемы

## Практические примеры в фронтенд-архитектуре

### Событийная архитектура компонентов
```javascript
// Пример событийной архитектуры в React
const EventBus = {
  events: {},
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  },
  
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  },
  
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
};

// Использование в компонентах
function LoginForm() {
  const handleSubmit = (userData) => {
    // Логика обработки формы
    EventBus.emit('userLogin', userData);
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}

function NotificationBar() {
  const [notifications, setNotifications] = useState([]);
  
  useEffect(() => {
    const handleUserLogin = (data) => {
      setNotifications(prev => [...prev, `Добро пожаловать, ${data.name}!`]);
    };
    
    EventBus.on('userLogin', handleUserLogin);
    
    return () => {
      EventBus.off('userLogin', handleUserLogin);
    };
  }, []);
  
  return <div>{/* Отображение уведомлений */}</div>;
}
```

### Событийная архитектура состояния
- Использование событийного подхода вместо прямого изменения состояния
- Состояние обновляется через события
- Обработка событий в редьюсерах

## EDA и шаблоны интеграции API

### Событийные шины для API
- Использование систем событий для интеграции API
- Обработка асинхронных вызовов через события
- Интеграция нескольких API через события

### Вебхуки и EDA
- Использование вебхуков как источника событий
- Событийная обработка внешних уведомлений
- Интеграция с внешними системами через события

## Будущие тенденции

### Event Streaming
- Потоковая обработка событий
- Apache Kafka, Amazon Kinesis
- Настоящее время обработки

### Reactive Systems
- Событийные системы как часть реактивных архитектур
- Устойчивость и отзывчивость
- Системы, реагирующие на изменения в реальном времени

### Serverless и EDA
- Использование серверных функций для обработки событий
- Масштабирование по требованию
- Управление событиями в serverless-архитектурах

## Паттерны событийной архитектуры

### Publisher-Subscriber (Pub/Sub)
Паттерн, при котором издатели не отправляют сообщения напрямую подписчикам, а публикуют события в системе, где они могут быть получены всеми заинтересованными подписчиками.

```javascript
// Пример реализации Pub/Sub на JavaScript
class EventBus {
  constructor() {
    this.subscribers = {};
  }

  subscribe(eventType, callback) {
    if (!this.subscribers[eventType]) {
      this.subscribers[eventType] = [];
    }
    this.subscribers[eventType].push(callback);
  }

  publish(event) {
    const eventType = event.type || event.eventType;
    if (this.subscribers[eventType]) {
      this.subscribers[eventType].forEach(callback => {
        callback(event);
      });
    }
  }
}

// Использование
const eventBus = new EventBus();

eventBus.subscribe('UserRegistered', (event) => {
  console.log('Отправляем приветственное письмо:', event.data.email);
});

eventBus.subscribe('UserRegistered', (event) => {
  console.log('Создаем профиль пользователя:', event.userId);
});

// Публикация события
eventBus.publish({
  eventType: 'UserRegistered',
  userId: '12345',
  data: { email: 'user@example.com', name: 'John Doe' }
});
```

### Event Sourcing
Архитектурный паттерн, в котором изменения состояния системы сохраняются как последовательность событий. Состояние системы воссоздается путем воспроизведения всех событий.

```javascript
class EventSourcedAggregate {
  constructor() {
    this.state = {};
    this.events = [];
    this.version = 0;
  }

  // Применить событие к состоянию
  applyEvent(event) {
    this.state = this.applyToState(this.state, event);
    this.events.push(event);
    this.version++;
  }

  // Методы для изменения состояния
  createUser(userData) {
    const event = {
      type: 'UserCreated',
      data: userData,
      timestamp: new Date().toISOString(),
      version: this.version + 1
    };
    this.applyEvent(event);
    return event;
  }

  updateUser(userData) {
    const event = {
      type: 'UserUpdated',
      data: userData,
      timestamp: new Date().toISOString(),
      version: this.version + 1
    };
    this.applyEvent(event);
    return event;
  }

  // Применить событие к состоянию
  applyToState(state, event) {
    switch (event.type) {
      case 'UserCreated':
        return { ...state, ...event.data, createdAt: event.timestamp };
      case 'UserUpdated':
        return { ...state, ...event.data, updatedAt: event.timestamp };
      default:
        return state;
    }
  }
}
```

### Command Query Responsibility Segregation (CQRS)
Паттерн, который разделяет операции чтения и записи данных. Команды изменяют состояние системы, а запросы возвращают данные для чтения.

```javascript
// Пример CQRS
class UserService {
  constructor(commandHandler, queryHandler) {
    this.commandHandler = commandHandler;
    this.queryHandler = queryHandler;
  }

  // Команды (изменение состояния)
  async createUser(userData) {
    const command = {
      type: 'CreateUserCommand',
      data: userData,
      timestamp: new Date().toISOString()
    };
    return await this.commandHandler.handle(command);
  }

  async updateUser(userId, userData) {
    const command = {
      type: 'UpdateUserCommand',
      userId: userId,
      data: userData,
      timestamp: new Date().toISOString()
    };
    return await this.commandHandler.handle(command);
  }

  // Запросы (чтение данных)
  async getUser(userId) {
    const query = {
      type: 'GetUserQuery',
      userId: userId
    };
    return await this.queryHandler.handle(query);
  }

  async getAllUsers() {
    const query = {
      type: 'GetAllUsersQuery'
    };
    return await this.queryHandler.handle(query);
  }
}
```

## Системы обмена сообщениями

### Apache Kafka

Apache Kafka - это распределенная система потоковой передачи данных, которая позволяет публиковать и подписываться на потоки записей.

```java
// Пример Producer в Kafka
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

Producer<String, String> producer = new KafkaProducer<>(props);

String topic = "user-events";
UserEvent userEvent = new UserEvent("123", "John Doe", "john@example.com");

ProducerRecord<String, String> record = new ProducerRecord<>(
    topic,
    userEvent.getUserId(),
    userEvent.toJson()
);

producer.send(record);
producer.close();
```

```java
// Пример Consumer в Kafka
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("group.id", "user-event-group");
props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

Consumer<String, String> consumer = new KafkaConsumer<>(props);
consumer.subscribe(Arrays.asList("user-events"));

while (true) {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        System.out.printf("offset = %d, key = %s, value = %s%n", 
            record.offset(), record.key(), record.value());
        
        // Обработка события
        processUserEvent(record.value());
    }
}
```

### RabbitMQ

RabbitMQ - это брокер сообщений, реализующий протокол AMQP.

```python
# Пример Publisher в RabbitMQ (Python)
import pika
import json

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='user_events', durable=True)

user_event = {
    'event_type': 'UserRegistered',
    'user_id': '12345',
    'email': 'user@example.com',
    'timestamp': '2023-10-15T10:30:00Z'
}

channel.basic_publish(
    exchange='',
    routing_key='user_events',
    body=json.dumps(user_event),
    properties=pika.BasicProperties(
        delivery_mode=2,  # Сделать сообщение устойчивым
    ))

connection.close()
```

```python
# Пример Consumer в RabbitMQ (Python)
import pika
import json

def callback(ch, method, properties, body):
    event = json.loads(body)
    print(f"Получено событие: {event}")
    
    // Обработка события
    if event['event_type'] == 'UserRegistered':
        send_welcome_email(event['email'])
    
    ch.basic_ack(delivery_tag=method.delivery_tag)

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='user_events', durable=True)
channel.basic_qos(prefetch_count=1)
channel.basic_consume(queue='user_events', on_message_callback=callback)

print('Ожидание событий...')
channel.start_consuming()
```

### AWS SNS/SQS

Amazon SNS (Simple Notification Service) и SQS (Simple Queue Service) для облачных событийных систем.

```javascript
// Пример с AWS SNS
const AWS = require('aws-sdk');
const sns = new AWS.SNS({ region: 'us-east-1' });

async function publishEvent(event) {
  const params = {
    Message: JSON.stringify(event),
    TopicArn: process.env.SNS_TOPIC_ARN,
    MessageAttributes: {
      'EventType': {
        DataType: 'String',
        StringValue: event.eventType
      }
    }
  };

  try {
    const result = await sns.publish(params).promise();
    console.log('Событие опубликовано:', result.MessageId);
    return result;
  } catch (error) {
    console.error('Ошибка публикации события:', error);
    throw error;
  }
}

// Пример с AWS SQS
const sqs = new AWS.SQS({ region: 'us-east-1' });

async function receiveAndProcessEvents() {
  const params = {
    QueueUrl: process.env.SQS_QUEUE_URL,
    MaxNumberOfMessages: 10,
    WaitTimeSeconds: 20
  };

  try {
    const result = await sqs.receiveMessage(params).promise();
    
    if (result.Messages) {
      for (const message of result.Messages) {
        const event = JSON.parse(message.Body);
        
        // Обработка события
        await processEvent(event);
        
        // Удаление сообщения из очереди
        await sqs.deleteMessage({
          QueueUrl: process.env.SQS_QUEUE_URL,
          ReceiptHandle: message.ReceiptHandle
        }).promise();
      }
    }
  } catch (error) {
    console.error('Ошибка получения событий:', error);
  }
}
```

## Практические примеры реализации

### Микросервисная архитектура с EDA

```javascript
// Сервис аутентификации
class AuthService {
  constructor(eventBus) {
    this.eventBus = eventBus;
  }

  async registerUser(userData) {
    // Валидация и создание пользователя
    const user = await this.createUser(userData);
    
    // Публикация события
    const event = {
      eventType: 'UserRegistered',
      userId: user.id,
      data: {
        email: user.email,
        name: user.name
      },
      timestamp: new Date().toISOString()
    };
    
    this.eventBus.publish(event);
    return user;
  }
}

// Сервис уведомлений
class NotificationService {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this.eventBus.subscribe('UserRegistered', (event) => {
      this.sendWelcomeEmail(event.data.email, event.data.name);
    });

    this.eventBus.subscribe('OrderCreated', (event) => {
      this.sendOrderConfirmation(event.data.email, event.data.orderId);
    });
  }

  async sendWelcomeEmail(email, name) {
    // Логика отправки приветственного письма
    console.log(`Отправка приветствия для ${name} на ${email}`);
  }

  async sendOrderConfirmation(email, orderId) {
    // Логика отправки подтверждения заказа
    console.log(`Отправка подтверждения заказа ${orderId} на ${email}`);
  }
}

// Центральный Event Bus
class CentralEventBus {
  constructor() {
    this.subscribers = new Map();
  }

  subscribe(eventType, callback) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType).push(callback);
  }

  publish(event) {
    const eventType = event.eventType;
    if (this.subscribers.has(eventType)) {
      this.subscribers.get(eventType).forEach(callback => {
        // Обработка в отдельном потоке для асинхронности
        setImmediate(() => {
          try {
            callback(event);
          } catch (error) {
            console.error(`Ошибка обработки события ${eventType}:`, error);
          }
        });
      });
    }
  }
}

// Использование
const eventBus = new CentralEventBus();
const authService = new AuthService(eventBus);
const notificationService = new NotificationService(eventBus);

// Регистрация пользователя
authService.registerUser({
  email: 'user@example.com',
  name: 'John Doe'
});
```

### Событийно-ориентированная обработка заказов

```javascript
// Система обработки заказов
class OrderService {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.orders = new Map();
  }

  async createOrder(orderData) {
    const orderId = this.generateId();
    const order = {
      id: orderId,
      status: 'CREATED',
      ...orderData,
      createdAt: new Date().toISOString()
    };

    this.orders.set(orderId, order);

    // Публикация события создания заказа
    this.eventBus.publish({
      eventType: 'OrderCreated',
      orderId: orderId,
      data: order,
      timestamp: new Date().toISOString()
    });

    return order;
  }

  async processPayment(orderId) {
    const order = this.orders.get(orderId);
    if (!order) {
      throw new Error(`Заказ ${orderId} не найден`);
    }

    // Логика обработки платежа
    const paymentResult = await this.processPaymentExternal(order);

    if (paymentResult.success) {
      order.status = 'PAID';
      
      this.eventBus.publish({
        eventType: 'OrderPaid',
        orderId: orderId,
        data: { paymentId: paymentResult.paymentId },
        timestamp: new Date().toISOString()
      });
    } else {
      order.status = 'PAYMENT_FAILED';
      
      this.eventBus.publish({
        eventType: 'OrderPaymentFailed',
        orderId: orderId,
        data: { error: paymentResult.error },
        timestamp: new Date().toISOString()
      });
    }

    this.orders.set(orderId, order);
    return order;
  }

  async shipOrder(orderId) {
    const order = this.orders.get(orderId);
    if (!order) {
      throw new Error(`Заказ ${orderId} не найден`);
    }

    if (order.status !== 'PAID') {
      throw new Error('Заказ должен быть оплачен перед отправкой');
    }

    order.status = 'SHIPPED';
    
    this.eventBus.publish({
      eventType: 'OrderShipped',
      orderId: orderId,
      data: { trackingNumber: this.generateTrackingNumber() },
      timestamp: new Date().toISOString()
    });

    this.orders.set(orderId, order);
    return order;
  }

  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }

  async processPaymentExternal(order) {
    // Имитация внешнего платежного сервиса
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({ success: true, paymentId: this.generateId() });
      }, 1000);
    });
  }

  generateTrackingNumber() {
    return `TRK${Date.now()}`;
  }
}

// Сервис склада
class WarehouseService {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this.eventBus.subscribe('OrderPaid', (event) => {
      this.prepareOrder(event.orderId);
    });
  }

  async prepareOrder(orderId) {
    console.log(`Подготовка заказа ${orderId} к отправке`);
    // Логика подготовки заказа на складе
  }
}

// Сервис отслеживания
class TrackingService {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.subscribeToEvents();
  }

  subscribeToEvents() {
    this.eventBus.subscribe('OrderShipped', (event) => {
      this.startTracking(event.orderId, event.data.trackingNumber);
    });
  }

  async startTracking(orderId, trackingNumber) {
    console.log(`Начало отслеживания заказа ${orderId} с номером ${trackingNumber}`);
    // Логика отслеживания доставки
  }
}
```

## Преимущества и недостатки EDA

### Преимущества

1. **Масштабируемость**: компоненты могут масштабироваться независимо
2. **Гибкость**: легко добавлять новые компоненты и функции
3. **Слабая связанность**: компоненты не зависят друг от друга
4. **Асинхронность**: не блокирует выполнение основного потока
5. **Надежность**: отказ одного компонента не влияет на другие
6. **Реактивность**: быстрая реакция на изменения в системе

### Недостатки

1. **Сложность отладки**: сложно отследить путь выполнения
2. **Управление состоянием**: сложнее управлять согласованностью
3. **Дополнительная инфраструктура**: требует брокеров сообщений
4. **Задержки**: асинхронная обработка может увеличить время отклика
5. **Сложность тестирования**: труднее тестировать взаимодействие компонентов

## Лучшие практики

### 1. Дизайн событий

- Используйте понятные имена событий (например, `UserRegistered`, а не `userReg`)
- События должны быть в прошедшем времени (что уже произошло)
- Включайте достаточную информацию для обработки события
- Используйте версионирование событий

### 2. Обработка ошибок

```javascript
class ReliableEventHandler {
  constructor(maxRetries = 3) {
    this.maxRetries = maxRetries;
  }

  async handleWithRetry(event, handler) {
    let retries = 0;
    
    while (retries < this.maxRetries) {
      try {
        await handler(event);
        return true; // Успешно обработано
      } catch (error) {
        retries++;
        console.error(`Ошибка обработки события (попытка ${retries}):`, error);
        
        if (retries >= this.maxRetries) {
          // Отправить в очередь "мертвых писем" для ручной обработки
          await this.sendToDeadLetterQueue(event, error);
          break;
        }
        
        // Экспоненциальная задержка
        await this.delay(Math.pow(2, retries) * 1000);
      }
    }
    
    return false; // Не удалось обработать
  }

  async sendToDeadLetterQueue(event, error) {
    // Логика отправки события в очередь для ручной обработки
    console.error('Отправка события в очередь "мертвых писем":', event, error);
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 3. Мониторинг и логирование

```javascript
class MonitoredEventBus {
  constructor(metricsService, logger) {
    this.subscribers = new Map();
    this.metrics = metricsService;
    this.logger = logger;
  }

  subscribe(eventType, callback) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType).push(callback);
  }

  publish(event) {
    const eventType = event.eventType;
    const startTime = Date.now();
    
    this.logger.info(`Публикация события: ${eventType}`, { eventId: event.eventId });
    this.metrics.increment('events.published', { type: eventType });
    
    if (this.subscribers.has(eventType)) {
      this.subscribers.get(eventType).forEach(async (callback) => {
        try {
          await callback(event);
          const duration = Date.now() - startTime;
          this.metrics.histogram('event.processing.time', duration, { type: eventType });
        } catch (error) {
          this.logger.error(`Ошибка обработки события ${eventType}:`, error);
          this.metrics.increment('events.errors', { type: eventType });
        }
      });
    }
  }
}
```

## Event Sourcing Pattern

```javascript
// Реализация Event Sourcing
class EventSourcedAggregate {
  constructor(id) {
    this.id = id;
    this.version = 0;
    this.uncommittedEvents = [];
    this.state = this.getInitialState();
  }
  
  getInitialState() {
    return {};
  }
  
  apply(event) {
    this.state = this.applyStateTransition(this.state, event);
    this.version++;
  }
  
  applyStateTransition(state, event) {
    // Метод должен быть переопределен в дочерних классах
    return state;
  }
  
  evolve(events) {
    for (const event of events) {
      this.apply(event);
    }
  }
  
  raise(event) {
    this.apply(event);
    this.uncommittedEvents.push(event);
  }
  
  getUncommittedEvents() {
    return [...this.uncommittedEvents];
  }
  
  clearUncommittedEvents() {
    this.uncommittedEvents = [];
  }
}

// Пример агрегата пользователя
class UserAggregate extends EventSourcedAggregate {
  constructor(id) {
    super(id);
    this.email = null;
    this.name = null;
    this.status = 'inactive';
  }
  
  getInitialState() {
    return {
      email: null,
      name: null,
      status: 'inactive',
      createdAt: null,
      updatedAt: null
    };
  }
  
  applyStateTransition(state, event) {
    switch (event.type) {
      case 'UserRegistered':
        return {
          ...state,
          email: event.data.email,
          name: event.data.name,
          status: 'active',
          createdAt: event.timestamp,
          updatedAt: event.timestamp
        };
      
      case 'UserProfileUpdated':
        return {
          ...state,
          name: event.data.name || state.name,
          email: event.data.email || state.email,
          updatedAt: event.timestamp
        };
      
      case 'UserDeactivated':
        return {
          ...state,
          status: 'inactive',
          updatedAt: event.timestamp
        };
      
      default:
        return state;
    }
  }
  
  // Методы команд
  register(email, name) {
    if (this.state.email) {
      throw new Error('User already registered');
    }
    
    this.raise(new DomainEvent('UserRegistered', {
      userId: this.id,
      email,
      name
    }));
  }
  
  updateProfile(name, email) {
    if (this.state.status !== 'active') {
      throw new Error('User is not active');
    }
    
    this.raise(new DomainEvent('UserProfileUpdated', {
      userId: this.id,
      name,
      email
    }));
  }
  
  deactivate() {
    if (this.state.status !== 'active') {
      throw new Error('User is already inactive');
    }
    
    this.raise(new DomainEvent('UserDeactivated', {
      userId: this.id
    }));
  }
}

// Event Store
class EventStore {
  constructor() {
    this.events = new Map(); // В реальности это будет база данных
  }
  
  async saveEvents(aggregateId, events, expectedVersion) {
    const storedEvents = this.events.get(aggregateId) || [];
    
    if (expectedVersion !== -1 && storedEvents.length !== expectedVersion) {
      throw new Error('Concurrency conflict');
    }
    
    for (const event of events) {
      storedEvents.push({
        ...event,
        aggregateId,
        version: storedEvents.length + 1
      });
    }
    
    this.events.set(aggregateId, storedEvents);
  }
  
  async getEvents(aggregateId) {
    return this.events.get(aggregateId) || [];
  }
  
  async getEventsByType(eventType) {
    const allEvents = Array.from(this.events.values()).flat();
    return allEvents.filter(event => event.type === eventType);
  }
  
  async getEventsByAggregateType(aggregateType) {
    // В реальности фильтрация будет по типу агрегата
    const allEvents = Array.from(this.events.values()).flat();
    return allEvents.filter(event => 
      event.aggregateType === aggregateType
    );
  }
}

// Repository для агрегатов
class AggregateRepository {
  constructor(eventStore) {
    this.eventStore = eventStore;
  }
  
  async save(aggregate) {
    const events = aggregate.getUncommittedEvents();
    
    if (events.length === 0) {
      return;
    }
    
    await this.eventStore.saveEvents(
      aggregate.id,
      events,
      aggregate.version - events.length
    );
    
    aggregate.clearUncommittedEvents();
  }
  
  async load(aggregateClass, id) {
    const events = await this.eventStore.getEvents(id);
    
    if (events.length === 0) {
      return null;
    }
    
    const aggregate = new aggregateClass(id);
    aggregate.evolve(events);
    
    return aggregate;
  }
}

// Использование
const eventStore = new EventStore();
const userRepository = new AggregateRepository(eventStore);

// Создание и сохранение пользователя
const user = new UserAggregate('user-123');
user.register('john@example.com', 'John Doe');

await userRepository.save(user);

// Загрузка и обновление пользователя
const loadedUser = await userRepository.load(UserAggregate, 'user-123');
loadedUser.updateProfile('John Smith', 'john.smith@example.com');
await userRepository.save(loadedUser);
```

## CQRS (Command Query Responsibility Segregation)

```javascript
// CQRS Implementation
class Command {
  constructor(type, data, metadata = {}) {
    this.id = crypto.randomUUID();
    this.type = type;
    this.data = data;
    this.metadata = {
      timestamp: new Date().toISOString(),
      userId: metadata.userId,
      correlationId: metadata.correlationId || crypto.randomUUID(),
      ...metadata
    };
  }
}

class Query {
  constructor(type, criteria, metadata = {}) {
    this.type = type;
    this.criteria = criteria;
    this.metadata = {
      timestamp: new Date().toISOString(),
      ...metadata
    };
  }
}

// Command Handler
class CommandHandler {
  constructor(commandBus, eventBus) {
    this.commandBus = commandBus;
    this.eventBus = eventBus;
    this.handlers = new Map();
  }
  
  register(commandType, handler) {
    this.handlers.set(commandType, handler);
  }
  
  async handle(command) {
    const handler = this.handlers.get(command.type);
    
    if (!handler) {
      throw new Error(`No handler found for command: ${command.type}`);
    }
    
    try {
      const result = await handler(command);
      
      // Если команда генерирует события, публикуем их
      if (result && Array.isArray(result.events)) {
        for (const event of result.events) {
          await this.eventBus.publish(event);
        }
      }
      
      return result;
    } catch (error) {
      console.error(`Error handling command ${command.type}:`, error);
      throw error;
    }
  }
}

// Query Handler
class QueryHandler {
  constructor(readModelStore) {
    this.readModelStore = readModelStore;
    this.handlers = new Map();
  }
  
  register(queryType, handler) {
    this.handlers.set(queryType, handler);
  }
  
  async handle(query) {
    const handler = this.handlers.get(query.type);
    
    if (!handler) {
      throw new Error(`No handler found for query: ${query.type}`);
    }
    
    return await handler(query);
  }
}

// Пример использования CQRS
class CreateUserCommand extends Command {
  constructor(userData) {
    super('CreateUser', {
      email: userData.email,
      name: userData.name,
      role: userData.role
    });
  }
}

class GetUserQuery extends Query {
  constructor(userId) {
    super('GetUser', { userId });
  }
}

// Command Handler Implementation
class UserCommandHandler {
  constructor(userRepository, eventBus) {
    this.userRepository = userRepository;
    this.eventBus = eventBus;
  }
  
  async handle(command) {
    switch (command.type) {
      case 'CreateUser':
        return await this.handleCreateUser(command);
      case 'UpdateUser':
        return await this.handleUpdateUser(command);
      case 'DeleteUser':
        return await this.handleDeleteUser(command);
      default:
        throw new Error(`Unknown command type: ${command.type}`);
    }
  }
  
  async handleCreateUser(command) {
    const { email, name, role } = command.data;
    
    // Проверка уникальности email
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }
    
    // Создание агрегата
    const user = new UserAggregate(crypto.randomUUID());
    user.register(email, name, role);
    
    // Сохранение агрегата
    await this.userRepository.save(user);
    
    // Публикация события
    const userCreatedEvent = new DomainEvent('UserCreated', {
      userId: user.id,
      email: user.email,
      name: user.name,
      role: user.role
    });
    
    await this.eventBus.publish(userCreatedEvent);
    
    return {
      success: true,
      userId: user.id,
      events: [userCreatedEvent]
    };
  }
  
  async handleUpdateUser(command) {
    const { userId, updates } = command.data;
    
    const user = await this.userRepository.load(UserAggregate, userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    user.updateProfile(updates);
    await this.userRepository.save(user);
    
    const userUpdatedEvent = new DomainEvent('UserUpdated', {
      userId: user.id,
      updates
    });
    
    await this.eventBus.publish(userUpdatedEvent);
    
    return {
      success: true,
      events: [userUpdatedEvent]
    };
  }
}

// Query Handler Implementation
class UserQueryHandler {
  constructor(readModelStore) {
    this.readModelStore = readModelStore;
  }
  
  async handle(query) {
    switch (query.type) {
      case 'GetUser':
        return await this.handleGetUser(query);
      case 'GetUsers':
        return await this.handleGetUsers(query);
      case 'SearchUsers':
        return await this.handleSearchUsers(query);
      default:
        throw new Error(`Unknown query type: ${query.type}`);
    }
  }
  
  async handleGetUser(query) {
    const { userId } = query.criteria;
    return await this.readModelStore.getUserById(userId);
  }
  
  async handleGetUsers(query) {
    const { page = 1, limit = 10, sortBy = 'createdAt', sortOrder = 'desc' } = query.criteria;
    return await this.readModelStore.getUsers(page, limit, sortBy, sortOrder);
  }
  
  async handleSearchUsers(query) {
    const { search, filters = {} } = query.criteria;
    return await this.readModelStore.searchUsers(search, filters);
  }
}
```

## Event-Driven Messaging Patterns

### 1. Publisher-Subscriber Pattern
```javascript
// Publisher-Subscriber Implementation
class Publisher {
  constructor(eventBus) {
    this.eventBus = eventBus;
  }
  
  async publish(event) {
    await this.eventBus.publish(event);
  }
}

class Subscriber {
  constructor(eventBus, eventTypes) {
    this.eventBus = eventBus;
    this.eventTypes = Array.isArray(eventTypes) ? eventTypes : [eventTypes];
    this.handlers = new Map();
  }
  
  subscribe(eventType, handler) {
    this.handlers.set(eventType, handler);
    this.eventBus.subscribe(eventType, async (event) => {
      const handler = this.handlers.get(eventType);
      if (handler) {
        try {
          await handler(event);
        } catch (error) {
          console.error(`Error in subscriber handler for ${eventType}:`, error);
        }
      }
    });
  }
  
  async handleEvent(event) {
    const handler = this.handlers.get(event.type);
    if (handler) {
      await handler(event);
    }
  }
}

// Пример использования
const notificationSubscriber = new Subscriber(eventBus, [
  'UserRegistered',
  'OrderCreated',
  'PaymentProcessed'
]);

notificationSubscriber.subscribe('UserRegistered', async (event) => {
  await emailService.sendWelcomeEmail(event.data.email);
  await smsService.sendWelcomeSMS(event.data.phone);
});

notificationSubscriber.subscribe('OrderCreated', async (event) => {
  await emailService.sendOrderConfirmation(event.data.email, event.data.orderId);
  await pushService.sendPushNotification(event.data.userId, 'Order confirmed!');
});
```

### 2. Event Sourcing with Projections
```javascript
// Projections for Read Models
class Projection {
  constructor(store) {
    this.store = store;
    this.eventTypes = [];
  }
  
  async project(event) {
    if (this.eventTypes.includes(event.type)) {
      await this.handleEvent(event);
    }
  }
  
  async handleEvent(event) {
    // Should be overridden by subclasses
  }
}

class UserProjection extends Projection {
  constructor(store) {
    super(store);
    this.eventTypes = [
      'UserRegistered',
      'UserProfileUpdated',
      'UserDeactivated',
      'UserActivated'
    ];
  }
  
  async handleEvent(event) {
    const userId = event.data.userId || event.data.id;
    
    switch (event.type) {
      case 'UserRegistered':
        await this.store.upsert('users', userId, {
          id: userId,
          email: event.data.email,
          name: event.data.name,
          status: 'active',
          createdAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
      
      case 'UserProfileUpdated':
        const currentUser = await this.store.findById('users', userId);
        await this.store.update('users', userId, {
          ...currentUser,
          name: event.data.name || currentUser.name,
          email: event.data.email || currentUser.email,
          updatedAt: event.timestamp
        });
        break;
      
      case 'UserDeactivated':
        await this.store.update('users', userId, {
          status: 'inactive',
          updatedAt: event.timestamp
        });
        break;
      
      case 'UserActivated':
        await this.store.update('users', userId, {
          status: 'active',
          updatedAt: event.timestamp
        });
        break;
    }
  }
}

class OrderProjection extends Projection {
  constructor(store) {
    super(store);
    this.eventTypes = [
      'OrderCreated',
      'OrderConfirmed',
      'OrderShipped',
      'OrderDelivered',
      'OrderCancelled'
    ];
  }
  
  async handleEvent(event) {
    const orderId = event.data.orderId;
    
    switch (event.type) {
      case 'OrderCreated':
        await this.store.upsert('orders', orderId, {
          id: orderId,
          userId: event.data.userId,
          items: event.data.items,
          totalAmount: event.data.totalAmount,
          status: 'created',
          createdAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
      
      case 'OrderConfirmed':
        await this.store.update('orders', orderId, {
          status: 'confirmed',
          confirmedAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
      
      case 'OrderShipped':
        await this.store.update('orders', orderId, {
          status: 'shipped',
          shippedAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
      
      case 'OrderDelivered':
        await this.store.update('orders', orderId, {
          status: 'delivered',
          deliveredAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
      
      case 'OrderCancelled':
        await this.store.update('orders', orderId, {
          status: 'cancelled',
          cancelledAt: event.timestamp,
          updatedAt: event.timestamp
        });
        break;
    }
  }
}

// Event Processor
class EventProcessor {
  constructor(eventStore, projections) {
    this.eventStore = eventStore;
    this.projections = projections;
    this.lastProcessedEventId = null;
  }
  
  async processEvents() {
    const events = await this.eventStore.getEventsAfter(this.lastProcessedEventId);
    
    for (const event of events) {
      for (const projection of this.projections) {
        await projection.project(event);
      }
      
      this.lastProcessedEventId = event.id;
    }
  }
  
  async startProcessing() {
    // Запуск непрерывной обработки событий
    while (true) {
      try {
        await this.processEvents();
        await this.delay(1000); // Ожидание 1 секунду перед следующей проверкой
      } catch (error) {
        console.error('Error processing events:', error);
        await this.delay(5000); // Ожидание 5 секунд при ошибке
      }
    }
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Использование
const userProjection = new UserProjection(readModelStore);
const orderProjection = new OrderProjection(readModelStore);

const eventProcessor = new EventProcessor(eventStore, [
  userProjection,
  orderProjection
]);

// Запуск обработки событий
eventProcessor.startProcessing();
```

## Testing Event-Driven Systems

```javascript
// Тестирование Event-Driven систем
const { describe, it, beforeEach, afterEach } = require('mocha');
const { expect } = require('chai');

describe('Event-Driven System', () => {
  let eventBus;
  let eventStore;
  let commandHandler;
  let queryHandler;
  
  beforeEach(() => {
    eventBus = new EventBus();
    eventStore = new EventStore();
    commandHandler = new CommandHandler(eventBus);
    queryHandler = new QueryHandler(readModelStore);
  });
  
  describe('User Registration', () => {
    it('should create user and emit UserRegistered event', async () => {
      const command = new CreateUserCommand({
        email: 'test@example.com',
        name: 'Test User',
        role: 'user'
      });
      
      // Подписка на событие для проверки
      let receivedEvent = null;
      eventBus.subscribe('UserRegistered', (event) => {
        receivedEvent = event;
      });
      
      // Выполнение команды
      const result = await commandHandler.handle(command);
      
      // Проверка результата
      expect(result.success).to.be.true;
      expect(result.userId).to.exist;
      
      // Проверка события
      expect(receivedEvent).to.not.be.null;
      expect(receivedEvent.type).to.equal('UserRegistered');
      expect(receivedEvent.data.email).to.equal('test@example.com');
      expect(receivedEvent.data.name).to.equal('Test User');
    });
    
    it('should handle duplicate email error', async () => {
      // Сначала создаем пользователя
      const command1 = new CreateUserCommand({
        email: 'duplicate@example.com',
        name: 'First User',
        role: 'user'
      });
      
      await commandHandler.handle(command1);
      
      // Пытаемся создать пользователя с тем же email
      const command2 = new CreateUserCommand({
        email: 'duplicate@example.com',
        name: 'Second User',
        role: 'user'
      });
      
      await expect(commandHandler.handle(command2))
        .to.be.rejectedWith('User with this email already exists');
    });
  });
  
  describe('Event Processing', () => {
    it('should process events and update read models', async () => {
      const userProjection = new UserProjection(mockStore);
      
      const userRegisteredEvent = new DomainEvent('UserRegistered', {
        userId: 'user-123',
        email: 'test@example.com',
        name: 'Test User'
      });
      
      // Мокаем хранилище для проверки вызовов
      let upsertCalled = false;
      mockStore.upsert = async (collection, id, data) => {
        upsertCalled = true;
        expect(collection).to.equal('users');
        expect(id).to.equal('user-123');
        expect(data.email).to.equal('test@example.com');
      };
      
      await userProjection.handleEvent(userRegisteredEvent);
      
      expect(upsertCalled).to.be.true;
    });
  });
  
  describe('Integration Events', () => {
    it('should propagate events across services', async () => {
      const eventsReceived = [];
      
      // Подписка сервиса уведомлений на события пользователей
      eventBus.subscribe('UserRegistered', async (event) => {
        eventsReceived.push({
          type: 'notification',
          event: event.type,
          data: event.data
        });
      });
      
      // Подписка сервиса аналитики на события пользователей
      eventBus.subscribe('UserRegistered', async (event) => {
        eventsReceived.push({
          type: 'analytics',
          event: event.type,
          data: event.data
        });
      });
      
      // Публикация события
      const userRegisteredEvent = new UserRegistered({
        id: 'user-123',
        email: 'test@example.com',
        name: 'Test User'
      });
      
      await eventBus.publish(userRegisteredEvent);
      
      // Проверка, что оба сервиса получили событие
      expect(eventsReceived).to.have.length(2);
      expect(eventsReceived[0].type).to.be.oneOf(['notification', 'analytics']);
      expect(eventsReceived[1].type).to.be.oneOf(['notification', 'analytics']);
      expect(eventsReceived[0].event).to.equal('UserRegistered');
      expect(eventsReceived[1].event).to.equal('UserRegistered');
    });
  });
});
```

## Performance Optimization

```javascript
// Оптимизация производительности Event-Driven систем
class OptimizedEventBus {
  constructor() {
    this.subscribers = new Map();
    this.eventBuffer = [];
    this.bufferSize = 100;
    this.flushInterval = 1000; // 1 секунда
    this.isFlushing = false;
  }
  
  subscribe(eventType, handler) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    this.subscribers.get(eventType).push(handler);
  }
  
  async publish(event) {
    // Буферизация событий для пакетной обработки
    this.eventBuffer.push(event);
    
    if (this.eventBuffer.length >= this.bufferSize && !this.isFlushing) {
      await this.flushBuffer();
    }
  }
  
  async flushBuffer() {
    if (this.isFlushing || this.eventBuffer.length === 0) {
      return;
    }
    
    this.isFlushing = true;
    const eventsToProcess = [...this.eventBuffer];
    this.eventBuffer = [];
    
    try {
      await this.processEventsBatch(eventsToProcess);
    } finally {
      this.isFlushing = false;
    }
  }
  
  async processEventsBatch(events) {
    // Параллельная обработка событий
    const promises = events.map(event => this.processEvent(event));
    await Promise.all(promises);
  }
  
  async processEvent(event) {
    const eventType = event.constructor.name || event.type;
    const handlers = this.subscribers.get(eventType) || [];
    
    // Параллельная обработка событий разными обработчиками
    const handlerPromises = handlers.map(handler => 
      this.executeHandler(handler, event)
    );
    
    await Promise.all(handlerPromises);
  }
  
  startFlushTimer() {
    setInterval(async () => {
      if (this.eventBuffer.length > 0 && !this.isFlushing) {
        await this.flushBuffer();
      }
    }, this.flushInterval);
  }
}

// Async Event Processing
class AsyncEventProcessor {
  constructor(maxConcurrency = 10) {
    this.maxConcurrency = maxConcurrency;
    this.activeTasks = 0;
    this.taskQueue = [];
  }
  
  async processEvent(event, handler) {
    return new Promise((resolve, reject) => {
      const task = {
        event,
        handler,
        resolve,
        reject
      };
      
      this.taskQueue.push(task);
      this.processNext();
    });
  }
  
  async processNext() {
    if (this.activeTasks >= this.maxConcurrency || this.taskQueue.length === 0) {
      return;
    }
    
    const task = this.taskQueue.shift();
    this.activeTasks++;
    
    try {
      const result = await task.handler(task.event);
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      this.activeTasks--;
      this.processNext(); // Обработка следующей задачи
    }
  }
}

// Event Deduplication
class EventDeduplicator {
  constructor(ttl = 3600) { // 1 hour TTL
    this.seenEvents = new Map();
    this.ttl = ttl;
  }
  
  async isDuplicate(event) {
    const eventId = event.id || this.generateEventHash(event);
    
    if (this.seenEvents.has(eventId)) {
      return true;
    }
    
    // Добавляем событие в список просмотренных
    this.seenEvents.set(eventId, Date.now());
    
    // Удаляем старые события
    this.cleanupExpiredEvents();
    
    return false;
  }
  
  generateEventHash(event) {
    // Генерация хеша события для дедупликации
    const crypto = require('crypto');
    const eventString = JSON.stringify({
      type: event.type,
      data: event.data,
      timestamp: event.timestamp
    });
    return crypto.createHash('sha256').update(eventString).digest('hex');
  }
  
  cleanupExpiredEvents() {
    const now = Date.now();
    for (const [eventId, timestamp] of this.seenEvents.entries()) {
      if (now - timestamp > this.ttl * 1000) {
        this.seenEvents.delete(eventId);
      }
    }
  }
}
```

## Monitoring and Observability

```javascript
// Мониторинг Event-Driven систем
class EventMonitoring {
  constructor() {
    this.metrics = {
      eventsPublished: 0,
      eventsProcessed: 0,
      processingTime: [],
      errors: 0
    };
    this.eventHistogram = new Map();
  }
  
  recordEventPublished(eventType) {
    this.metrics.eventsPublished++;
    this.eventHistogram.set(eventType, (this.eventHistogram.get(eventType) || 0) + 1);
  }
  
  recordEventProcessed(eventType, processingTime) {
    this.metrics.eventsProcessed++;
    this.metrics.processingTime.push(processingTime);
    
    // Логирование для трассировки
    console.log('Event processed:', {
      type: eventType,
      processingTime: processingTime,
      timestamp: new Date().toISOString()
    });
  }
  
  recordError(error, eventType) {
    this.metrics.errors++;
    console.error('Event processing error:', {
      type: eventType,
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
  
  getMetrics() {
    const avgProcessingTime = this.metrics.processingTime.length > 0 
      ? this.metrics.processingTime.reduce((a, b) => a + b, 0) / this.metrics.processingTime.length
      : 0;
    
    return {
      ...this.metrics,
      avgProcessingTime,
      eventDistribution: Object.fromEntries(this.eventHistogram)
    };
  }
}

// Distributed Tracing
class EventTracer {
  constructor() {
    this.traceStore = new Map();
  }
  
  startTrace(eventId, eventName) {
    const traceId = crypto.randomUUID();
    this.traceStore.set(traceId, {
      eventId,
      eventName,
      startTime: Date.now(),
      spans: []
    });
    
    return traceId;
  }
  
  addSpan(traceId, operation, startTime, endTime) {
    const trace = this.traceStore.get(traceId);
    if (trace) {
      trace.spans.push({
        operation,
        startTime,
        endTime,
        duration: endTime - startTime
      });
    }
  }
  
  completeTrace(traceId) {
    const trace = this.traceStore.get(traceId);
    if (trace) {
      trace.endTime = Date.now();
      trace.duration = trace.endTime - trace.startTime;
      
      // Отправка трейса в систему мониторинга (Jaeger, Zipkin, etc.)
      this.exportTrace(trace);
      
      this.traceStore.delete(traceId);
    }
  }
  
  exportTrace(trace) {
    // Экспорт трейса в систему мониторинга
    console.log('Exporting trace:', trace);
  }
}

// Health Checks
class EventSystemHealthCheck {
  constructor(eventBus, eventStore, messageQueue) {
    this.eventBus = eventBus;
    this.eventStore = eventStore;
    this.messageQueue = messageQueue;
  }
  
  async checkHealth() {
    const checks = await Promise.allSettled([
      this.checkEventBusHealth(),
      this.checkEventStoreHealth(),
      this.checkMessageQueueHealth()
    ]);
    
    const results = {
      status: 'healthy',
      checks: {},
      timestamp: new Date().toISOString()
    };
    
    for (const check of checks) {
      if (check.status === 'rejected') {
        results.status = 'unhealthy';
      }
      results.checks[check.checkName] = {
        status: check.status,
        error: check.reason?.message
      };
    }
    
    return results;
  }
  
  async checkEventBusHealth() {
    // Проверка доступности event bus
    return true;
  }
  
  async checkEventStoreHealth() {
    // Проверка доступности хранилища событий
    return true;
  }
  
  async checkMessageQueueHealth() {
    // Проверка доступности очереди сообщений
    return true;
  }
}
```

## Best Practices

### 1. Event Design Guidelines
```javascript
// Рекомендации по дизайну событий
class EventDesignGuidelines {
  static validateEventStructure(event) {
    const requiredFields = ['id', 'type', 'timestamp', 'data'];
    const missingFields = requiredFields.filter(field => !event[field]);
    
    if (missingFields.length > 0) {
      throw new Error(`Event missing required fields: ${missingFields.join(', ')}`);
    }
    
    // Проверка типа события
    if (typeof event.type !== 'string' || !this.isValidEventType(event.type)) {
      throw new Error('Invalid event type format');
    }
    
    // Проверка формата времени
    if (isNaN(new Date(event.timestamp).getTime())) {
      throw new Error('Invalid timestamp format');
    }
    
    return true;
  }
  
  static isValidEventType(type) {
    // События должны быть в формате PascalCase
    // Пример: UserRegistered, OrderCreated, PaymentProcessed
    return /^[A-Z][a-zA-Z]*$/.test(type);
  }
  
  static normalizeEvent(event) {
    return {
      ...event,
      id: event.id || crypto.randomUUID(),
      timestamp: event.timestamp || new Date().toISOString(),
      version: event.version || '1.0',
      source: event.source || 'unknown'
    };
  }
}
```

### 2. Error Handling and Retry Strategies
```javascript
// Стратегии обработки ошибок и повторных попыток
class EventErrorHandling {
  constructor() {
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1000, // 1 second
      maxDelay: 60000, // 1 minute
      backoffMultiplier: 2
    };
    
    this.deadLetterQueue = [];
  }
  
  async processEventWithRetry(event, handler, attempt = 1) {
    try {
      return await handler(event);
    } catch (error) {
      if (attempt < this.retryConfig.maxRetries) {
        const delay = this.calculateDelay(attempt);
        console.log(`Retrying event ${event.id}, attempt ${attempt + 1}, delay ${delay}ms`);
        
        await this.delay(delay);
        return await this.processEventWithRetry(event, handler, attempt + 1);
      } else {
        console.error(`Event ${event.id} failed after ${this.retryConfig.maxRetries} attempts`);
        await this.moveToDeadLetterQueue(event, error);
        throw error;
      }
    }
  }
  
  calculateDelay(attempt) {
    const delay = this.retryConfig.baseDelay * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1);
    return Math.min(delay, this.retryConfig.maxDelay);
  }
  
  async moveToDeadLetterQueue(event, error) {
    const deadLetterEvent = {
      originalEvent: event,
      error: {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      },
      processedAt: new Date().toISOString(),
      retryCount: this.retryConfig.maxRetries
    };
    
    this.deadLetterQueue.push(deadLetterEvent);
    
    // Логирование в систему мониторинга
    console.error('Moved to dead letter queue:', deadLetterEvent);
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Заключение

Событийно-ориентированная архитектура - мощный подход к созданию гибких, масштабируемых и отзывчивых систем. При правильной архитектуре, она позволяет создавать слабосвязанные компоненты, которые могут эволюционировать независимо. Особенно важна в контексте фронтенд-архитектуры и интеграции API, позволяя создавать динамические, реагирующие на изменения приложения.

Event-Driven Architecture provides a powerful approach to building scalable, resilient, and responsive systems. By decoupling system components through events, EDA enables independent scaling, fault isolation, and flexible system composition. However, it also introduces complexity in terms of event ordering, consistency, and debugging. Success with EDA requires careful consideration of event design, proper monitoring, and robust error handling strategies.

The key benefits of EDA include:
- Loose coupling between services
- Scalability and resilience
- Real-time processing capabilities
- Flexible system architecture
- Better separation of concerns

[[API интеграция]] - архитектура интеграции с внешними API
[[Микросервисы]] - микросервисная архитектура
[[Событийный шин]] - шина событий
[[Event Sourcing]] - событийное хранение
[[CQRS]] - разделение команд и запросов
[[Publish Subscribe Pattern]] - паттерн паблишер-сабскрайбер
[[WebSocket]] - вебсокеты для событийного взаимодействия
[[Frontend Architecture]] - общая архитектура фронтенда
[[Component Architecture]] - компонентная архитектура
[[State Management]] - управление состоянием
[[API Gateway]] - шлюзы API
[[Message Queue]] - очереди сообщений
[[Kafka]] - Apache Kafka
[[RabbitMQ]] - RabbitMQ
[[Asynchronous Processing]] - асинхронная обработка
[[Event Handling]] - обработка событий
[[Event Monitoring]] - мониторинг событий
[[Pub/Sub Systems]] - системы публикации/подписки
[[Reactive Programming]] - реактивное программирование
[[Event Architecture Patterns]] - архитектурные паттерны событий
[[Event Scalability]] - масштабируемость событий
[[Event Security]] - безопасность событий
[[Real-time Communication]] - коммуникация в реальном времени
[[Architecture Decision Records]] - архитектурные решения
[[EventBridge]] - AWS EventBridge
[[Event Consistency]] - согласованность событий
[[Event Patterns]] - паттерны событий
[[Event Performance]] - производительность событий
[[Event Ordering]] - порядок событий
[[Clean Architecture]] - чистая архитектура
[[Microservices Architecture]] - архитектура микросервисов
[[Service Mesh Architecture]] - архитектура сервис-меша
[[Cloud Native Architecture]] - облачная нативная архитектура
[[Vue Architecture]] - архитектура Vue
[[Security Architecture]] - архитектура безопасности
[[Testing Architecture]] - архитектура тестирования
[[Message Queues]] - очереди сообщений
[[Event Sourcing]] - событийное хранение
[[CQRS]] - разделение команд и запросов
[[Reactive Programming]] - реактивное программирование
[[Microservices]] - микросервисы
[[API Gateway]] - API шлюз
[[Service Mesh]] - сервис-меш
[[Data Streaming]] - потоковая передача данных
[[Performance Optimization]] - оптимизация производительности
[[Feature Flags]] - фича-флаги
[[Real User Monitoring]] - мониторинг реальных пользователей
[[API Testing]] - тестирование API
[[Microservices Architecture]] - архитектура микросервисов
[[API Integration]] - интеграция API