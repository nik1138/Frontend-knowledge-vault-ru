---
aliases: ["Модульные паттерны JavaScript", "Паттерны модульности"]
tags: ["#javascript", "#patterns", "#modules", "#frontend", "#architecture"]
---

# Модульные-паттерны

Модульные паттерны в JavaScript - это шаблоны проектирования, которые позволяют организовать код в изолированные, переиспользуемые и управляемые блоки. Эти паттерны помогают разработчикам создавать более структурированный и поддерживаемый код, особенно в крупных приложениях.

## Обзор

Модульные паттерны появились задолго до появления официальных ES6-модулей как способ изолировать код и избежать загрязнения глобального пространства имен. Они обеспечивают инкапсуляцию, позволяя скрывать внутренние детали реализации и предоставлять только необходимый публичный интерфейс.

## Исторические паттерны

### 1. Объектный паттерн

Самый простой способ организации модуля - это создание объекта с методами и свойствами:

```javascript
const Calculator = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
  divide: (a, b) => {
    if (b === 0) {
      throw new Error("Division by zero");
    }
    return a / b;
  }
};

console.log(Calculator.add(5, 3)); // 8
```

**Преимущества:**
- Простота реализации
- Легко понимаемая структура

**Недостатки:**
- Все свойства и методы публичны
- Нет изоляции внутреннего состояния
- Не позволяет скрыть вспомогательные функции

### 2. Паттерн "Модуль" (Module Pattern)

Использует замыкания для создания приватных и публичных членов:

```javascript
const CalculatorModule = (function() {
  // Приватные переменные и функции
  let calculationHistory = [];
  
  const addToHistory = (operation, result) => {
    calculationHistory.push({
      operation,
      result,
      timestamp: new Date()
    });
  };
  
  // Публичный интерфейс
  return {
    add: function(a, b) {
      const result = a + b;
      addToHistory(`${a} + ${b}`, result);
      return result;
    },
    
    subtract: function(a, b) {
      const result = a - b;
      addToHistory(`${a} - ${b}`, result);
      return result;
    },
    
    multiply: function(a, b) {
      const result = a * b;
      addToHistory(`${a} * ${b}`, result);
      return result;
    },
    
    getHistory: function() {
      return [...calculationHistory]; // Возвращаем копию для безопасности
    },
    
    clearHistory: function() {
      calculationHistory = [];
    }
  };
})();

console.log(CalculatorModule.add(5, 3)); // 8
console.log(CalculatorModule.getHistory()); // [{ operation: "5 + 3", result: 8, timestamp: ... }]
// calculationHistory недоступна извне - защищена от прямого доступа
```

**Преимущества:**
- Возможность создания приватных переменных и функций
- Контроль над тем, что доступно извне
- Защита внутреннего состояния

**Недостатки:**
- Сложнее для понимания новичками
- Труднее тестировать изолированно

### 3. Revealing Module Pattern

Улучшенная версия Module Pattern, которая предоставляет более чистый интерфейс:

```javascript
const CalculatorRevealing = (function() {
  let calculationHistory = [];
  
  const addToHistory = (operation, result) => {
    calculationHistory.push({
      operation,
      result,
      timestamp: new Date()
    });
  };
  
  const add = function(a, b) {
    const result = a + b;
    addToHistory(`${a} + ${b}`, result);
    return result;
  };
  
  const subtract = function(a, b) {
    const result = a - b;
    addToHistory(`${a} - ${b}`, result);
    return result;
  };
  
  const getHistory = function() {
    return [...calculationHistory];
  };
  
  const clearHistory = function() {
    calculationHistory = [];
  };
  
  // Явно указываем, что экспортируем
  return {
    add: add,
    subtract: subtract,
    getHistory: getHistory,
    clearHistory: clearHistory
  };
})();
```

### 4. IIFE (Immediately Invoked Function Expression)

Паттерн, который создает изолированную область видимости:

```javascript
const UserModule = (function() {
  const users = [];
  
  return {
    addUser: function(name, email) {
      const user = {
        id: Date.now(),
        name: name,
        email: email
      };
      users.push(user);
      return user;
    },
    
    getUserById: function(id) {
      return users.find(user => user.id === id);
    },
    
    getAllUsers: function() {
      return [...users];
    }
  };
})();
```

## Современные паттерны

### 1. ES6-модули

Современный стандарт, встроенный в язык JavaScript:

```javascript
// mathUtils.js
const PI = 3.14159;

function calculateArea(radius) {
  return PI * radius * radius;
}

function calculateCircumference(radius) {
  return 2 * PI * radius;
}

export { calculateArea, calculateCircumference };
export default { calculateArea, calculateCircumference };
```

```javascript
// main.js
import { calculateArea, calculateCircumference } from './mathUtils.js';
// или
import mathUtils from './mathUtils.js';
```

### 2. Singleton Pattern в модулях

Паттерн, гарантирующий, что будет создан только один экземпляр модуля:

```javascript
// logger.js
let instance = null;

class Logger {
  constructor() {
    if (instance) {
      return instance;
    }
    
    this.logs = [];
    instance = this;
    return instance;
  }
  
  log(message) {
    this.logs.push({
      message,
      timestamp: new Date()
    });
  }
  
  getLogs() {
    return [...this.logs];
  }
}

export default new Logger(); // Создаем экземпляр при импорте
```

### 3. Factory Pattern для модулей

Позволяет создавать разные реализации модуля в зависимости от условий:

```javascript
// moduleFactory.js
const createAPIClient = (type) => {
  switch(type) {
    case 'development':
      return {
        baseURL: 'https://dev-api.example.com',
        timeout: 5000,
        debug: true
      };
    case 'production':
      return {
        baseURL: 'https://api.example.com',
        timeout: 3000,
        debug: false
      };
    default:
      throw new Error('Unknown environment');
  }
};

export { createAPIClient };
```

## Практические примеры

### Пример 1: Модуль управления состоянием

```javascript
// stateManager.js
const StateManager = (function() {
  let state = {};
  const listeners = [];
  
  const setState = (newState) => {
    const prevState = { ...state };
    state = { ...state, ...newState };
    
    // Уведомляем слушателей об изменении состояния
    listeners.forEach(callback => callback(state, prevState));
  };
  
  const getState = () => ({ ...state });
  
  const subscribe = (callback) => {
    listeners.push(callback);
    // Возвращаем функцию для отписки
    return () => {
      const index = listeners.indexOf(callback);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  };
  
  return {
    setState,
    getState,
    subscribe
  };
})();

export default StateManager;
```

### Пример 2: Модуль конфигурации

```javascript
// config.js
const ConfigModule = (function() {
  const defaultConfig = {
    apiUrl: 'https://api.example.com',
    timeout: 5000,
    retries: 3
  };
  
  let currentConfig = { ...defaultConfig };
  
  const initialize = (config = {}) => {
    currentConfig = { ...defaultConfig, ...config };
  };
  
  const get = (key) => {
    return currentConfig[key];
  };
  
  const getAll = () => {
    return { ...currentConfig };
  };
  
  return {
    initialize,
    get,
    getAll
  };
})();

export default ConfigModule;
```

### Пример 3: Модуль событий (Event Emitter)

```javascript
// eventEmitter.js
const EventEmitter = (function() {
  const events = {};
  
  const on = (event, callback) => {
    if (!events[event]) {
      events[event] = [];
    }
    events[event].push(callback);
  };
  
  const off = (event, callback) => {
    if (!events[event]) return;
    
    const index = events[event].indexOf(callback);
    if (index > -1) {
      events[event].splice(index, 1);
    }
  };
  
  const emit = (event, data) => {
    if (!events[event]) return;
    
    events[event].forEach(callback => callback(data));
  };
  
  const once = (event, callback) => {
    const onceCallback = (...args) => {
      callback(...args);
      off(event, onceCallback);
    };
    on(event, onceCallback);
  };
  
  return {
    on,
    off,
    emit,
    once
  };
})();

export default EventEmitter;
```

## Рекомендации по использованию

### Когда использовать модульные паттерны:

1. **Для изоляции кода**: Когда нужно избежать загрязнения глобального пространства имен
2. **Для управления состоянием**: Когда нужно централизованно управлять данными
3. **Для повторного использования**: Когда код нужно использовать в разных частях приложения
4. **Для тестирования**: Когда нужно изолировать функциональность для unit-тестов

### Рекомендации:

1. **Предпочитайте ES6-модули**: В современных приложениях используйте стандартные ES6-модули
2. **Избегайте слишком больших модулей**: Следуйте принципу единственной ответственности
3. **Документируйте публичный интерфейс**: Четко указывайте, какие функции/методы являются публичными
4. **Используйте осмысленные имена**: Называйте модули и их части понятно и по-существу

## Связанные концепции

- [[ES6-модули]] - современный стандарт модулей в JavaScript
- [[Зависимости-модулей]] - управление зависимостями между модулями
- [[Ленивая-загрузка]] - техники динамической загрузки модулей
- [[Code-splitting]] - разделение кода на отдельные бандлы
- [[CommonJS]] - модульная система для Node.js
- [[AMD]] - асинхронная модульная система

## Заключение

Модульные паттерны являются важным инструментом в арсенале фронтенд-разработчика. Они позволяют создавать более структурированный, читаемый и поддерживаемый код. Понимание различных паттернов и умение правильно их применять помогает создавать более надежные и масштабируемые приложения.