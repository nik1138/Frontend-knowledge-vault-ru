---
aliases: ["Компонентная архитектура", "Компонентный подход"]
tags: [architecture, frontend, components]
---

# Компонентная архитектура фронтенд-приложений

Компонентная архитектура представляет собой подход к построению пользовательского интерфейса, при котором интерфейс разбивается на независимые, переиспользуемые компоненты. Это основа современных фронтенд-фреймворков и библиотек.

## Основные концепции компонентной архитектуры

### Что такое компонент?

Компонент - это независимая, самодостаточная часть пользовательского интерфейса, которая может иметь собственное состояние, логику и представление. Компоненты могут быть объединены для создания более сложных интерфейсов.

```jsx
// Пример простого компонента
const Button = ({ children, onClick, variant = 'primary', disabled = false }) => {
  const baseClasses = 'btn';
  const variantClass = `btn-${variant}`;
  const disabledClass = disabled ? 'btn-disabled' : '';
  
  return (
    <button 
      className={`${baseClasses} ${variantClass} ${disabledClass}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};

// Использование компонента
const App = () => {
  const handleClick = () => console.log('Кнопка нажата');
  
  return (
    <div>
      <Button onClick={handleClick}>Нажми меня</Button>
      <Button variant="secondary" onClick={handleClick}>Второстепенная кнопка</Button>
    </div>
  );
};
```

### Типы компонентов

#### 1. Компоненты представления (Dumb/Presentational Components)

Эти компоненты отвечают только за отображение данных и не содержат бизнес-логики:

```jsx
// Пример компонента представления
const UserCard = ({ user, avatarSize = 'medium' }) => {
  return (
    <div className="user-card">
      <img 
        src={user.avatar} 
        alt={user.name}
        className={`avatar avatar-${avatarSize}`}
      />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
        <p>{user.role}</p>
      </div>
    </div>
  );
};
```

#### 2. Компоненты-контейнеры (Smart/Container Components)

Эти компоненты управляют состоянием и бизнес-логикой:

```jsx
// Пример компонента-контейнера
const UserListContainer = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await fetch('/api/users');
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error('Ошибка загрузки пользователей:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUsers();
  }, []);
  
  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

## Архитектура компонентов

### Структура компонентов

Компоненты обычно организуются в иерархию:

```
App
├── Layout
│   ├── Header
│   │   ├── Navigation
│   │   └── UserMenu
│   ├── Main
│   │   ├── Sidebar
│   │   └── Content
│   │       ├── PageHeader
│   │       └── PageContent
│   └── Footer
└── Modal
    └── ModalContent
```

### Паттерны организации компонентов

#### 1. Atomic Design

Методология, разработанная Брэдом Фростом, которая делит интерфейс на атомы, молекулы, организмы, шаблоны и страницы:

- **Атомы**: базовые элементы (кнопки, поля ввода)
- **Молекулы**: комбинации атомов (форма поиска)
- **Организмы**: комбинации молекул (шапка сайта)
- **Шаблоны**: структура страниц
- **Страницы**: конкретные реализации шаблонов

#### 2. Compound Components

Паттерн, при котором компоненты работают вместе как единое целое:

```jsx
// Пример компаунд компонента
const Tabs = ({ children, activeTab, onTabChange }) => {
  return (
    <div className="tabs">
      {React.Children.map(children, (child) =>
        React.cloneElement(child, { activeTab, onTabChange })
      )}
    </div>
  );
};

const TabList = ({ children, activeTab, onTabChange }) => {
  return (
    <div className="tab-list">
      {React.Children.map(children, (child) =>
        React.cloneElement(child, { activeTab, onTabChange })
      )}
    </div>
  );
};

const Tab = ({ id, title, activeTab, onTabChange }) => {
  return (
    <button
      className={`tab ${id === activeTab ? 'active' : ''}`}
      onClick={() => onTabChange(id)}
    >
      {title}
    </button>
  );
};

const TabPanel = ({ id, activeTab, children }) => {
  return id === activeTab ? <div className="tab-panel">{children}</div> : null;
};

// Использование
const App = () => {
  const [activeTab, setActiveTab] = useState('tab1');
  
  return (
    <Tabs activeTab={activeTab} onTabChange={setActiveTab}>
      <TabList>
        <Tab id="tab1" title="Профиль" />
        <Tab id="tab2" title="Настройки" />
      </TabList>
      <TabPanel id="tab1">
        <UserProfile />
      </TabPanel>
      <TabPanel id="tab2">
        <UserSettings />
      </TabPanel>
    </Tabs>
  );
};
```

#### 3. Render Props

Паттерн, позволяющий делиться кодом между компонентами с помощью функции, передаваемой через props:

```jsx
// Компонент, использующий render props
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return children({ data, loading, error });
};

// Использование
const UserProfile = ({ userId }) => {
  return (
    <DataFetcher url={`/api/users/${userId}`}>
      {({ data, loading, error }) => {
        if (loading) return <div>Загрузка...</div>;
        if (error) return <div>Ошибка: {error.message}</div>;
        
        return <UserCard user={data} />;
      }}
    </DataFetcher>
  );
};
```

## Лучшие практики компонентной архитектуры

### 1. Принцип единственной ответственности

Каждый компонент должен отвечать за одну конкретную задачу:

```jsx
// Плохо: компонент делает слишком много
const UserManagement = () => {
  const [users, setUsers] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  
  // Логика загрузки пользователей
  // Логика поиска
  // Логика фильтрации
  // Отображение списка
  // Отображение формы редактирования
};

// Хорошо: разделение ответственности
const UserManagement = () => {
  return (
    <div>
      <UserSearch onSearch={handleSearch} />
      <UserList users={filteredUsers} />
      <UserEditor />
    </div>
  );
};
```

### 2. Переиспользуемость

Компоненты должны быть спроектированы так, чтобы их можно было использовать в разных контекстах:

```jsx
// Высоко переиспользуемый компонент
const Card = ({ 
  title, 
  children, 
  actions, 
  variant = 'default',
  className = '' 
}) => {
  return (
    <div className={`card card-${variant} ${className}`}>
      {title && <h3 className="card-title">{title}</h3>}
      <div className="card-content">{children}</div>
      {actions && <div className="card-actions">{actions}</div>}
    </div>
  );
};

// Использование в разных контекстах
const UserProfileCard = ({ user }) => (
  <Card title={user.name} actions={<EditButton />}>
    <UserDetails user={user} />
  </Card>
);

const ProductCard = ({ product }) => (
  <Card title={product.name} actions={<AddToCartButton />}>
    <ProductInfo product={product} />
  </Card>
);
```

### 3. Композиция вместо наследования

Используйте композицию компонентов вместо наследования:

```jsx
// Плохо: наследование
class Modal extends Component { /* ... */ }
class UserModal extends Modal { /* ... */ }
class ProductModal extends Modal { /* ... */ }

// Хорошо: композиция
const Modal = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h2>{title}</h2>
          <button onClick={onClose}>×</button>
        </div>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>
  );
};

// Использование в разных контекстах
const UserModal = ({ user, isOpen, onClose }) => (
  <Modal isOpen={isOpen} onClose={onClose} title="Редактировать пользователя">
    <UserForm user={user} />
  </Modal>
);
```

## Организация файлов компонентов

### Подход 1: Компонент-ориентированная структура

```
components/
├── Button/
│   ├── Button.jsx
│   ├── Button.module.css
│   ├── Button.test.js
│   └── index.js
├── UserCard/
│   ├── UserCard.jsx
│   ├── UserCard.module.css
│   ├── UserCard.test.js
│   └── index.js
└── Modal/
    ├── Modal.jsx
    ├── Modal.module.css
    ├── Modal.test.js
    └── index.js
```

### Подход 2: Функциональная структура

```
components/
├── common/
│   ├── Button.jsx
│   └── Input.jsx
├── user/
│   ├── UserCard.jsx
│   └── UserProfile.jsx
└── layout/
    ├── Header.jsx
    └── Sidebar.jsx
```

## Ключевые выводы

- Компонентная архитектура улучшает переиспользуемость и поддерживаемость кода
- Важно правильно разделять компоненты на представления и контейнеры
- Следуйте принципу единственной ответственности для каждого компонента
- Используйте композицию вместо наследования
- Организуйте файлы компонентов логически понятным способом

## См. также

- [[Принципы-архитектуры]]
- [[Архитектурные-паттерны]]
- [[Модульность]]
- [[Тестируемость]]