---
aliases: ["Безопасная архитектура", "Фронтенд безопасность"]
tags: [architecture, frontend, security, security-best-practices]
---

# Безопасность в архитектуре фронтенд-приложений

Безопасность фронтенд-приложений - это критический аспект архитектуры, который включает в себя защиту пользовательских данных, предотвращение атак и обеспечение целостности приложения. Архитектурные решения должны учитывать потенциальные угрозы и реализовывать соответствующие меры защиты.

## Понимание безопасности во фронтенде

В отличие от бэкенда, фронтенд не может полностью контролировать среду исполнения, что создает уникальные вызовы безопасности:

- Код выполняется в браузере пользователя
- Пользователь может просматривать и изменять исходный код
- Все данные, хранящиеся на клиенте, потенциально доступны пользователю
- Взаимодействие с сервером происходит через незащищенные каналы (если не используется HTTPS)

## Архитектурные принципы безопасности

### 1. Принцип наименьших привилегий

Каждый компонент должен иметь минимально необходимые права доступа:

```javascript
// Плохо: компонент имеет доступ ко всем данным
const UserProfile = ({ user }) => {
  // Компонент может изменять любые данные пользователя
  return (
    <div>
      <input value={user.name} onChange={(e) => user.name = e.target.value} />
      <input value={user.email} onChange={(e) => user.email = e.target.value} />
      <input value={user.role} onChange={(e) => user.role = e.target.value} />
    </div>
  );
};

// Хорошо: ограниченные права на изменение
const UserProfile = ({ user, allowedFields, onFieldUpdate }) => {
  const canEditField = (field) => allowedFields.includes(field);
  
  return (
    <div>
      {canEditField('name') && (
        <input 
          value={user.name} 
          onChange={(e) => onFieldUpdate('name', e.target.value)} 
        />
      )}
      {canEditField('email') && (
        <input 
          value={user.email} 
          onChange={(e) => onFieldUpdate('email', e.target.value)} 
        />
      )}
      {/* Поле роли недоступно для редактирования пользователем */}
    </div>
  );
};
```

### 2. Защита от XSS (Cross-Site Scripting)

```jsx
// Плохо: прямое встраивание пользовательского ввода
const Comment = ({ content }) => {
  return <div dangerouslySetInnerHTML={{ __html: content }} />;
};

// Хорошо: экранирование и валидация
import DOMPurify from 'dompurify';

const SafeComment = ({ content }) => {
  // Очистка HTML от потенциально опасного содержимого
  const sanitizedContent = DOMPurify.sanitize(content, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: ['href', 'title']
  });
  
  return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />;
};

// Лучше: использование безопасного рендеринга
const SafeComment = ({ content }) => {
  // Предполагаем, что content - это простой текст
  return <div>{content}</div>;
};

// Для форматированного текста лучше использовать компоненты
const RichText = ({ content }) => {
  // Парсим и преобразуем в безопасные React элементы
  const elements = parseRichText(content);
  return <div>{elements}</div>;
};
```

### 3. Управление сессией и аутентификацией

```javascript
// Сервис управления аутентификацией
class AuthService {
  constructor() {
    this.tokenKey = 'auth_token';
    this.refreshTokenKey = 'refresh_token';
  }

  // Сохранение токенов в безопасном хранилище
  setTokens(accessToken, refreshToken) {
    // Сохраняем в httpOnly куки на бэкенде (не в localStorage!)
    // или в sessionStorage для SPA с дополнительной защитой
    
    // Для демонстрации используем localStorage с защитой
    const encryptedToken = this.encrypt(accessToken);
    localStorage.setItem(this.tokenKey, encryptedToken);
    
    const encryptedRefreshToken = this.encrypt(refreshToken);
    localStorage.setItem(this.refreshTokenKey, encryptedRefreshToken);
  }

  getAccessToken() {
    const encryptedToken = localStorage.getItem(this.tokenKey);
    return encryptedToken ? this.decrypt(encryptedToken) : null;
  }

  // Проверка валидности токена
  isTokenValid() {
    const token = this.getAccessToken();
    if (!token) return false;

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp > currentTime;
    } catch (e) {
      return false;
    }
  }

  // Обновление токена
  async refreshAccessToken() {
    const refreshToken = localStorage.getItem(this.refreshTokenKey);
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken: this.decrypt(refreshToken) }),
      });

      if (response.ok) {
        const { accessToken, refreshToken: newRefreshToken } = await response.json();
        this.setTokens(accessToken, newRefreshToken);
        return accessToken;
      } else {
        // Токен недействителен, очищаем сессию
        this.clearTokens();
        throw new Error('Failed to refresh token');
      }
    } catch (error) {
      this.clearTokens();
      throw error;
    }
  }

  clearTokens() {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.refreshTokenKey);
  }

  // Простое шифрование для демонстрации (в реальном приложении используйте криптографически стойкие методы)
  encrypt(text) {
    return btoa(text);
  }

  decrypt(encryptedText) {
    return atob(encryptedText);
  }
}

// Использование в хуке
const useAuth = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);
  const authService = useRef(new AuthService());

  useEffect(() => {
    const checkAuth = async () => {
      if (authService.current.isTokenValid()) {
        try {
          const userData = await fetchUserData();
          setUser(userData);
          setIsAuthenticated(true);
        } catch (error) {
          authService.current.clearTokens();
          setIsAuthenticated(false);
        }
      }
    };

    checkAuth();
  }, []);

  const login = async (credentials) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      });

      if (response.ok) {
        const { accessToken, refreshToken, user } = await response.json();
        authService.current.setTokens(accessToken, refreshToken);
        setUser(user);
        setIsAuthenticated(true);
        return { success: true };
      } else {
        return { success: false, error: 'Invalid credentials' };
      }
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const logout = () => {
    authService.current.clearTokens();
    setUser(null);
    setIsAuthenticated(false);
  };

  return { isAuthenticated, user, login, logout };
};
```

## Защита от распространенных угроз

### 1. CSRF (Cross-Site Request Forgery)

```javascript
// Сервис для работы с CSRF токенами
class CSRFTokenService {
  static async getCSRFToken() {
    // Получаем токен с сервера при инициализации приложения
    const response = await fetch('/api/csrf-token');
    const { token } = await response.json();
    
    // Сохраняем токен в сессионное хранилище
    sessionStorage.setItem('csrf_token', token);
    return token;
  }

  static getStoredToken() {
    return sessionStorage.getItem('csrf_token');
  }

  static async ensureToken() {
    let token = this.getStoredToken();
    if (!token) {
      token = await this.getCSRFToken();
    }
    return token;
  }
}

// Обертка для API вызовов с CSRF защитой
class SecureAPIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    // Добавляем CSRF токен к каждому запросу
    const csrfToken = await CSRFTokenService.ensureToken();
    
    const config = {
      ...options,
      headers: {
        'X-CSRF-Token': csrfToken,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    };

    const response = await fetch(url, config);
    
    // Если токен устарел, получаем новый
    if (response.status === 419) { // Laravel CSRF token mismatch
      await CSRFTokenService.getCSRFToken();
      // Повторяем запрос
      return this.request(endpoint, options);
    }
    
    return response;
  }

  async get(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = queryString ? `${endpoint}?${queryString}` : endpoint;
    return this.request(url, { method: 'GET' });
  }

  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put(endpoint, data) {
    return this.request(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }
}
```

### 2. Защита данных в локальном хранилище

```javascript
// Защищенное хранилище для чувствительных данных
class SecureStorage {
  constructor(encryptionKey) {
    this.encryptionKey = encryptionKey;
  }

  // Шифрование данных перед сохранением
  setItem(key, value) {
    const encryptedValue = this.encrypt(JSON.stringify(value));
    localStorage.setItem(key, encryptedValue);
  }

  // Расшифровка данных при извлечении
  getItem(key) {
    const encryptedValue = localStorage.getItem(key);
    if (!encryptedValue) return null;

    try {
      const decryptedValue = this.decrypt(encryptedValue);
      return JSON.parse(decryptedValue);
    } catch (e) {
      console.error('Failed to decrypt stored data:', e);
      return null;
    }
  }

  removeItem(key) {
    localStorage.removeItem(key);
  }

  // Простая реализация шифрования (в реальном приложении используйте Web Crypto API)
  encrypt(text) {
    // Это НЕ криптографически стойкий метод!
    // В реальном приложении используйте Web Crypto API
    return btoa(encodeURIComponent(text).replace(/%([0-9A-F]{2})/g, (match, p1) => {
      return String.fromCharCode('0x' + p1);
    }));
  }

  decrypt(encryptedText) {
    try {
      const decoded = decodeURIComponent(atob(encryptedText).split('').map(c => {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return decoded;
    } catch (e) {
      return encryptedText; // Возвращаем как есть, если расшифровка не удалась
    }
  }
}

// Использование безопасного хранилища
const secureStorage = new SecureStorage('your-encryption-key');

// Сохранение чувствительных данных
secureStorage.setItem('userPreferences', {
  theme: 'dark',
  language: 'ru',
  notifications: true
});

// Извлечение данных
const userPreferences = secureStorage.getItem('userPreferences');
```

### 3. Защита от clickjacking

```html
<!-- Добавление заголовков безопасности в index.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <!-- Защита от clickjacking -->
  <meta http-equiv="Content-Security-Policy" 
        content="frame-ancestors 'self' https://trusted-domain.com;">
  
  <title>Безопасное приложение</title>
</head>
<body>
  <div id="root"></div>
  
  <script>
    // Защита от фрейминга (альтернативный метод)
    if (window !== window.top) {
      window.top.location = window.location;
    }
  </script>
</body>
</html>
```

## Архитектурные паттерны безопасности

### 1. Content Security Policy (CSP)

```javascript
// Пример настройки CSP в приложении
const CSP_HEADER = {
  'Content-Security-Policy': [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' https://www.google-analytics.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "img-src 'self' data: https:",
    "font-src 'self' https://fonts.gstatic.com",
    "connect-src 'self' https://api.example.com",
    "frame-ancestors 'none'", // Защита от clickjacking
    "base-uri 'self'",
    "form-action 'self'"
  ].join('; ')
};

// Middleware для Express.js
const cspMiddleware = (req, res, next) => {
  Object.entries(CSP_HEADER).forEach(([key, value]) => {
    res.setHeader(key, value);
  });
  next();
};
```

### 2. Валидация и санитизация данных

```javascript
// Валидатор форм с защитой от XSS
class FormValidator {
  static sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    // Удаляем потенциально опасные символы
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }

  static validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  static validatePassword(password) {
    // Минимум 8 символов, хотя бы одна заглавная буква, одна строчная и одна цифра
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  }

  static validateUsername(username) {
    // Только буквы, цифры и подчеркивания, 3-30 символов
    const usernameRegex = /^[a-zA-Z0-9_]{3,30}$/;
    return usernameRegex.test(username);
  }

  static validateUserData(userData) {
    const errors = {};

    if (!this.validateEmail(userData.email)) {
      errors.email = 'Некорректный email';
    }

    if (!this.validatePassword(userData.password)) {
      errors.password = 'Пароль должен содержать минимум 8 символов, включая заглавные и строчные буквы и цифры';
    }

    if (!this.validateUsername(userData.username)) {
      errors.username = 'Имя пользователя должно содержать 3-30 символов, только буквы, цифры и подчеркивания';
    }

    // Санитизация текстовых полей
    const sanitizedData = {
      ...userData,
      username: this.sanitizeInput(userData.username),
      bio: this.sanitizeInput(userData.bio || ''),
      website: this.sanitizeInput(userData.website || '')
    };

    return {
      isValid: Object.keys(errors).length === 0,
      errors,
      sanitizedData
    };
  }
}

// Использование в компоненте формы
const UserRegistrationForm = () => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    bio: '',
    website: ''
  });
  
  const [errors, setErrors] = useState({});

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const validation = FormValidator.validateUserData(formData);
    
    if (!validation.isValid) {
      setErrors(validation.errors);
      return;
    }
    
    // Отправка санилизированных данных
    const result = await registerUser(validation.sanitizedData);
    
    if (result.success) {
      // Успешная регистрация
    } else {
      // Обработка ошибок
    }
  };

  const handleChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Очистка ошибки при изменении поля
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={formData.username}
        onChange={(e) => handleChange('username', e.target.value)}
        placeholder="Имя пользователя"
      />
      {errors.username && <span className="error">{errors.username}</span>}
      
      <input
        type="email"
        value={formData.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder="Email"
      />
      {errors.email && <span className="error">{errors.email}</span>}
      
      <input
        type="password"
        value={formData.password}
        onChange={(e) => handleChange('password', e.target.value)}
        placeholder="Пароль"
      />
      {errors.password && <span className="error">{errors.password}</span>}
      
      <textarea
        value={formData.bio}
        onChange={(e) => handleChange('bio', e.target.value)}
        placeholder="О себе"
      />
      
      <button type="submit">Зарегистрироваться</button>
    </form>
  );
};
```

## Безопасность API клиентов

### 1. Защита API вызовов

```javascript
// Безопасный API клиент с защитой от атак
class SecureAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.timeout = options.timeout || 10000;
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelay || 1000;
  }

  // Добавление общих заголовков безопасности
  getBaseHeaders() {
    return {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
      'X-Client-Version': process.env.REACT_APP_VERSION || '1.0.0',
      // Не добавляем чувствительные данные в заголовки
      // Авторизационные токены добавляются отдельно
    };
  }

  // Защита от чрезмерных запросов (Rate Limiting)
  async makeRequest(endpoint, options = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        headers: {
          ...this.getBaseHeaders(),
          ...options.headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      // Проверка статуса ответа
      if (!response.ok) {
        if (response.status >= 500) {
          // Ошибки сервера - повторяем запрос
          throw new Error(`Server error: ${response.status}`);
        } else if (response.status === 429) {
          // Слишком много запросов - ждем и повторяем
          throw new Error('Rate limit exceeded');
        } else {
          // Клиентские ошибки - не повторяем
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || `HTTP error: ${response.status}`);
        }
      }

      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      
      throw error;
    }
  }

  // Повтор запроса при необходимости
  async requestWithRetry(endpoint, options = {}, retryCount = 0) {
    try {
      return await this.makeRequest(endpoint, options);
    } catch (error) {
      if (retryCount < this.maxRetries && this.shouldRetry(error)) {
        await new Promise(resolve => setTimeout(resolve, this.retryDelay * (retryCount + 1)));
        return this.requestWithRetry(endpoint, options, retryCount + 1);
      }
      throw error;
    }
  }

  shouldRetry(error) {
    // Повторяем только для определенных типов ошибок
    return [
      'Server error',
      'Request timeout',
      'Network error',
      'Rate limit exceeded'
    ].some(msg => error.message.includes(msg));
  }

  async get(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = queryString ? `${endpoint}?${queryString}` : endpoint;
    return this.requestWithRetry(url, { method: 'GET' });
  }

  async post(endpoint, data) {
    return this.requestWithRetry(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put(endpoint, data) {
    return this.requestWithRetry(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete(endpoint) {
    return this.requestWithRetry(endpoint, { method: 'DELETE' });
  }
}
```

## Ключевые выводы

- Безопасность должна быть заложена в архитектуру с самого начала
- Используйте принцип наименьших привилегий для всех компонентов
- Защищайтесь от XSS, CSRF и других распространенных атак
- Правильно управляйте сессиями и аутентификацией
- Санитизируйте все пользовательские данные
- Используйте Content Security Policy для дополнительной защиты
- Регулярно обновляйте зависимости и следите за уязвимостями

## См. также

- [[Принципы-архитектуры]]
- [[Модульность]]
- [[Поддерживаемость]]
- [[Документирование-архитектуры]]