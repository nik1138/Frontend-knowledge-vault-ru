---
aliases: ["Архитектурные шаблоны", "Шаблоны проектирования"]
tags: [architecture, frontend, patterns]
---

# Архитектурные паттерны фронтенд-приложений

Архитектурные паттерны представляют собой проверенные временем решения для типичных проблем проектирования фронтенд-приложений. Они обеспечивают структурированный подход к организации кода и взаимодействию между компонентами.

## Популярные архитектурные паттерны

### 1. Model-View-Controller (MVC)

Хотя MVC традиционно используется в серверных приложениях, его концепции применимы и к фронтенду:

- **Model**: данные и бизнес-логика
- **View**: представление и пользовательский интерфейс
- **Controller**: логика обработки пользовательских действий

```javascript
// Пример MVC-архитектуры в React
// Model
class UserModel {
  constructor() {
    this.data = {};
  }
  
  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    this.data = await response.json();
    this.notifyObservers();
  }
  
  subscribe(observer) {
    this.observer = observer;
  }
  
  notifyObservers() {
    if (this.observer) {
      this.observer.update(this.data);
    }
  }
}

// Controller
class UserController {
  constructor(model, view) {
    this.model = model;
    this.view = view;
    this.model.subscribe(this);
  }
  
  async loadUser(id) {
    await this.model.fetchUser(id);
  }
  
  update(modelData) {
    this.view.render(modelData);
  }
}

// View
function UserView({ user }) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### 2. Model-View-ViewModel (MVVM)

MVVM особенно популярен в фреймворках с двусторонним связыванием данных:

- **Model**: бизнес-логика и данные
- **View**: пользовательский интерфейс
- **ViewModel**: прослойка между View и Model, обеспечивающая связывание данных

### 3. Flux

Архитектурный паттерн, разработанный Facebook, который обеспечивает односторонний поток данных:

```javascript
// Store
class UserStore {
  constructor() {
    this.users = [];
    this.currentUserId = null;
  }
  
  getUsers() {
    return this.users;
  }
  
  getCurrentUser() {
    return this.users.find(user => user.id === this.currentUserId);
  }
  
  dispatcherIndex = Dispatcher.register((action) => {
    switch(action.type) {
      case 'LOAD_USERS':
        this.users = action.data;
        this.emitChange();
        break;
      case 'SET_CURRENT_USER':
        this.currentUserId = action.id;
        this.emitChange();
        break;
    }
  });
}

// Action Creator
const UserActions = {
  loadUsers: async () => {
    const response = await fetch('/api/users');
    const users = await response.json();
    Dispatcher.dispatch({
      type: 'LOAD_USERS',
      data: users
    });
  }
};
```

### 4. Redux

Эволюция паттерна Flux, обеспечивающая предсказуемое состояние приложения:

```javascript
// Redux Store
import { createStore, combineReducers } from 'redux';

const userReducer = (state = { users: [], current: null }, action) => {
  switch(action.type) {
    case 'USERS_LOADED':
      return { ...state, users: action.payload };
    case 'USER_SELECTED':
      return { ...state, current: action.payload };
    default:
      return state;
  }
};

const store = createStore(combineReducers({
  users: userReducer
}));

// React компонент с использованием Redux
import { useSelector, useDispatch } from 'react-redux';

const UserList = () => {
  const users = useSelector(state => state.users.users);
  const dispatch = useDispatch();
  
  useEffect(() => {
    dispatch({ type: 'USERS_LOADED', payload: fetchUsers() });
  }, []);
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id} onClick={() => dispatch({ type: 'USER_SELECTED', payload: user.id })}>
          {user.name}
        </li>
      ))}
    </ul>
  );
};
```

### 5. Компонентная архитектура

В современном фронтенде доминирует компонентный подход, где приложение строится из переиспользуемых компонентов:

```jsx
// Пример компонентной архитектуры
const App = () => {
  return (
    <Layout>
      <Header />
      <Main>
        <Sidebar />
        <Content>
          <UserDashboard />
        </Content>
      </Main>
      <Footer />
    </Layout>
  );
};

// Компонент с бизнес-логикой
const UserDashboard = () => {
  const { data: user, loading, error } = useUserData();
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div className="dashboard">
      <UserProfile user={user} />
      <UserActions userId={user.id} />
    </div>
  );
};
```

### 6. Clean Architecture

Чистая архитектура разделяет приложение на слои с четкими границами:

- **Entities**: бизнес-сущности
- **Use Cases**: бизнес-логика
- **Interface Adapters**: адаптация между слоями
- **Frameworks & Drivers**: внешние зависимости

```javascript
// Пример структуры чистой архитектуры
// entities/User.js
export class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  validate() {
    return this.name && this.email;
  }
}

// usecases/UserService.js
export class UserService {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }
  
  async createUser(userData) {
    const user = new User(Date.now(), userData.name, userData.email);
    
    if (!user.validate()) {
      throw new Error('Invalid user data');
    }
    
    return await this.userRepository.save(user);
  }
}

// interface-adapters/UserPresenter.js
export class UserPresenter {
  presentUser(user) {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      formattedName: `${user.name} (${user.email})`
    };
  }
}
```

## Выбор подходящего паттерна

При выборе архитектурного паттерна учитывайте:

1. **Размер и сложность приложения**
2. **Команду разработчиков**
3. **Требования к масштабируемости**
4. **Временные ограничения**
5. **Технический стек**

## Практические рекомендации

- Не используйте сложные паттерны в простых приложениях
- Паттерны должны улучшать, а не усложнять код
- Всегда документируйте выбранную архитектуру
- Регулярно пересматривайте архитектурные решения

## Ключевые выводы

- Архитектурные паттерны предоставляют структурированные решения для типичных проблем
- Каждый паттерн имеет свои сценарии применения
- Важно понимать, когда и как применять каждый паттерн
- Архитектура должна быть гибкой и адаптируемой

## См. также

- [[Принципы-архитектуры]]
- [[Компонентная-архитектура]]
- [[Модульность]]
- [[Тестируемость]]