---
aliases: ["Тестируемая архитектура", "Тестирование фронтенда"]
tags: [architecture, frontend, testing, quality]
---

# Тестируемость в архитектуре фронтенд-приложений

Тестируемость - это способность приложения быть легко и эффективно тестируемым. Это критический аспект архитектуры фронтенд-приложений, который обеспечивает качество кода, снижает количество багов и упрощает внесение изменений с уверенностью в их безопасности.

## Понимание тестируемости

Тестируемость означает, что код написан так, что его можно легко протестировать различными методами:

- **Модульное тестирование**: тестирование отдельных компонентов и функций
- **Интеграционное тестирование**: тестирование взаимодействия между компонентами
- **Сквозное тестирование**: тестирование пользовательских сценариев
- **Тестирование производительности**: проверка производительности приложения

## Архитектурные принципы тестируемости

### 1. Разделение ответственности

Каждый компонент должен иметь одну четкую ответственность, что облегчает его тестирование:

```javascript
// Плохо: компонент делает слишком много
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Загрузка данных
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);
  
  const handleSave = async (userData) => {
    // Сохранение данных
    await fetch(`/api/users/${userId}`, {
      method: 'PUT',
      body: JSON.stringify(userData)
    });
  };
  
  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={() => handleSave({ name: 'New Name' })}>Сохранить</button>
    </div>
  );
};

// Хорошо: разделение ответственности
// hooks/useUser.js
export const useUser = (userId) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true;
    
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await userApi.fetchUser(userId);
        if (isMounted) setUser(userData);
      } catch (err) {
        if (isMounted) setError(err.message);
      } finally {
        if (isMounted) setLoading(false);
      }
    };

    fetchUser();
    
    return () => { isMounted = false; };
  }, [userId]);

  return { user, loading, error };
};

// components/UserProfile.jsx
export const UserProfile = ({ userId, onSave }) => {
  const { user, loading, error } = useUser(userId);
  
  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={() => onSave(user)}>Сохранить</button>
    </div>
  );
};
```

### 2. Инъекция зависимостей

Инъекция зависимостей позволяет легко заменять зависимости на моки во время тестирования:

```javascript
// services/UserService.js
export class UserService {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async fetchUser(id) {
    return await this.apiClient.get(`/users/${id}`);
  }
  
  async updateUser(id, data) {
    return await this.apiClient.put(`/users/${id}`, data);
  }
}

// hooks/useUser.js
export const useUser = (userId, userService) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const userData = await userService.fetchUser(userId);
        setUser(userData);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId, userService]);

  return { user, loading };
};

// Тестирование с моком
import { renderHook, waitFor } from '@testing-library/react';
import { useUser } from './useUser';

describe('useUser', () => {
  test('загружает пользователя', async () => {
    const mockUserService = {
      fetchUser: jest.fn().mockResolvedValue({ id: '1', name: 'Иван' })
    };
    
    const { result } = renderHook(() => useUser('1', mockUserService));
    
    await waitFor(() => expect(result.current.loading).toBe(false));
    
    expect(mockUserService.fetchUser).toHaveBeenCalledWith('1');
    expect(result.current.user).toEqual({ id: '1', name: 'Иван' });
  });
});
```

### 3. Чистые функции

Чистые функции не имеют побочных эффектов и всегда возвращают одинаковый результат для одних и тех же входных данных:

```javascript
// Плохо: функция с побочными эффектами
let globalCounter = 0;
const formatUser = (user) => {
  globalCounter++;
  user.formatted = true;
  user.id = `${user.id}-${globalCounter}`;
  return user;
};

// Хорошо: чистая функция
const formatUser = (user) => {
  return {
    ...user,
    fullName: `${user.firstName} ${user.lastName}`,
    displayName: user.displayName || user.firstName,
    formatted: true
  };
};

// Тестирование чистой функции
test('formatUser correctly formats user data', () => {
  const input = { firstName: 'Иван', lastName: 'Иванов', displayName: 'Ваня' };
  const expected = { 
    firstName: 'Иван', 
    lastName: 'Иванов', 
    displayName: 'Ваня',
    fullName: 'Иван Иванов',
    formatted: true
  };
  
  expect(formatUser(input)).toEqual(expected);
});
```

## Типы тестов и архитектурные подходы

### 1. Модульные тесты

Тестируют отдельные компоненты или функции изолированно:

```javascript
// components/UserCard.test.js
import { render, screen } from '@testing-library/react';
import { UserCard } from './UserCard';

const mockUser = {
  id: '1',
  name: 'Иван Иванов',
  email: 'ivan@example.com',
  avatar: 'avatar.jpg'
};

describe('UserCard', () => {
  beforeEach(() => {
    render(<UserCard user={mockUser} />);
  });

  test('отображает имя пользователя', () => {
    expect(screen.getByText('Иван Иванов')).toBeInTheDocument();
  });

  test('отображает email пользователя', () => {
    expect(screen.getByText('ivan@example.com')).toBeInTheDocument();
  });

  test('отображает аватар пользователя', () => {
    const avatar = screen.getByAltText('Иван Иванов');
    expect(avatar).toBeInTheDocument();
    expect(avatar).toHaveAttribute('src', 'avatar.jpg');
  });
});

// utils/formatters.test.js
import { formatDate, formatCurrency } from './formatters';

describe('formatters', () => {
  describe('formatDate', () => {
    test('formats date correctly', () => {
      const date = new Date('2023-01-15T10:30:00Z');
      expect(formatDate(date)).toBe('15.01.2023, 13:30'); // зависит от часового пояса
    });

    test('handles different input formats', () => {
      expect(formatDate('2023-01-15')).toMatch(/\d{2}\.\d{2}\.\d{4}/);
      expect(formatDate(1673768400000)).toMatch(/\d{2}\.\d{2}\.\d{4}/);
    });
  });

  describe('formatCurrency', () => {
    test('formats currency correctly', () => {
      expect(formatCurrency(1234.5)).toBe('1 234,50 ₽');
      expect(formatCurrency(0)).toBe('0,00 ₽');
    });
  });
});
```

### 2. Интеграционные тесты

Тестируют взаимодействие между несколькими компонентами:

```javascript
// components/UserProfileForm.test.js
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { UserProfileForm } from './UserProfileForm';
import { userApi } from '../services/userApi';

// Мокаем API
jest.mock('../services/userApi');

describe('UserProfileForm Integration', () => {
  const mockUser = {
    id: '1',
    name: 'Иван Иванов',
    email: 'ivan@example.com'
  };

  beforeEach(() => {
    userApi.fetchUser.mockResolvedValue(mockUser);
    userApi.updateUser.mockResolvedValue({ ...mockUser, name: 'Петр Петров' });
  });

  test('loads and updates user profile', async () => {
    render(<UserProfileForm userId="1" />);

    // Проверяем загрузку
    expect(screen.getByText('Загрузка...')).toBeInTheDocument();
    
    // Ждем завершения загрузки
    await waitFor(() => {
      expect(screen.queryByText('Загрузка...')).not.toBeInTheDocument();
    });

    // Проверяем отображение данных
    expect(screen.getByDisplayValue('Иван Иванов')).toBeInTheDocument();
    expect(screen.getByDisplayValue('ivan@example.com')).toBeInTheDocument();

    // Изменяем данные
    fireEvent.change(screen.getByLabelText(/имя/i), {
      target: { value: 'Петр Петров' }
    });

    // Сохраняем
    fireEvent.click(screen.getByRole('button', { name: /сохранить/i }));

    // Ждем сохранения
    await waitFor(() => {
      expect(userApi.updateUser).toHaveBeenCalledWith('1', {
        id: '1',
        name: 'Петр Петров',
        email: 'ivan@example.com'
      });
    });
  });
});
```

### 3. Тесты пользовательских сценариев

Тестируют полные пользовательские сценарии:

```javascript
// tests/userRegistration.test.js
import { test, expect } from '@playwright/test';

test.describe('User Registration', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/register');
  });

  test('should register new user successfully', async ({ page }) => {
    // Заполняем форму регистрации
    await page.fill('input[name="name"]', 'Иван Иванов');
    await page.fill('input[name="email"]', 'ivan@example.com');
    await page.fill('input[name="password"]', 'SecurePassword123');
    
    // Проверяем валидацию пароля
    await expect(page.locator('.password-strength')).toContainText('Надежный');
    
    // Отправляем форму
    await page.click('button[type="submit"]');
    
    // Проверяем перенаправление на страницу подтверждения
    await expect(page).toHaveURL(/\/confirm/);
    await expect(page.locator('h1')).toContainText('Подтвердите email');
    
    // Проверяем, что email отправлен
    await expect(page.locator('.confirmation-email')).toContainText('ivan@example.com');
  });

  test('should show validation errors for invalid input', async ({ page }) => {
    // Отправляем пустую форму
    await page.click('button[type="submit"]');
    
    // Проверяем сообщения об ошибках
    await expect(page.locator('.error-message')).toHaveCount(3);
    await expect(page.locator('.error-message')).toContainText([
      'Имя обязательно',
      'Email обязателен',
      'Пароль обязателен'
    ]);
  });
});
```

## Архитектурные паттерны для тестируемости

### 1. Repository Pattern

```javascript
// repositories/UserRepository.js
export class UserRepository {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async findById(id) {
    const response = await this.apiClient.get(`/users/${id}`);
    return this.mapToEntity(response.data);
  }
  
  async findAll(filters = {}) {
    const response = await this.apiClient.get('/users', { params: filters });
    return response.data.map(user => this.mapToEntity(user));
  }
  
  async save(user) {
    let response;
    if (user.id) {
      response = await this.apiClient.put(`/users/${user.id}`, user);
    } else {
      response = await this.apiClient.post('/users', user);
    }
    return this.mapToEntity(response.data);
  }
  
  mapToEntity(data) {
    return {
      ...data,
      createdAt: new Date(data.createdAt),
      updatedAt: data.updatedAt ? new Date(data.updatedAt) : null
    };
  }
}

// Тестирование с моком API
import { UserRepository } from './UserRepository';

describe('UserRepository', () => {
  let mockApiClient;
  let userRepository;

  beforeEach(() => {
    mockApiClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn()
    };
    userRepository = new UserRepository(mockApiClient);
  });

  test('findById makes correct API call', async () => {
    const mockUserData = { id: '1', name: 'Иван' };
    mockApiClient.get.mockResolvedValue({ data: mockUserData });

    const user = await userRepository.findById('1');

    expect(mockApiClient.get).toHaveBeenCalledWith('/users/1');
    expect(user).toEqual(expect.objectContaining({ id: '1', name: 'Иван' }));
  });
});
```

### 2. Use Case Pattern

```javascript
// usecases/RegisterUser.js
export class RegisterUser {
  constructor(userRepository, emailService) {
    this.userRepository = userRepository;
    this.emailService = emailService;
  }
  
  async execute(userData) {
    // Валидация данных
    this.validateUserData(userData);
    
    // Проверка уникальности email
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }
    
    // Создание пользователя
    const user = await this.userRepository.save({
      ...userData,
      createdAt: new Date(),
      isActive: false
    });
    
    // Отправка email подтверждения
    await this.emailService.sendConfirmationEmail(user.email, user.id);
    
    return user;
  }
  
  validateUserData(userData) {
    if (!userData.email || !userData.password) {
      throw new Error('Email и пароль обязательны');
    }
    
    if (userData.password.length < 8) {
      throw new Error('Пароль должен быть не менее 8 символов');
    }
  }
}

// Тестирование use case
describe('RegisterUser', () => {
  let mockUserRepository;
  let mockEmailService;
  let registerUser;

  beforeEach(() => {
    mockUserRepository = {
      findByEmail: jest.fn(),
      save: jest.fn()
    };
    
    mockEmailService = {
      sendConfirmationEmail: jest.fn()
    };
    
    registerUser = new RegisterUser(mockUserRepository, mockEmailService);
  });

  test('registers new user successfully', async () => {
    const userData = {
      name: 'Иван Иванов',
      email: 'ivan@example.com',
      password: 'SecurePassword123'
    };
    
    mockUserRepository.findByEmail.mockResolvedValue(null);
    mockUserRepository.save.mockResolvedValue({
      id: '1',
      ...userData,
      createdAt: new Date(),
      isActive: false
    });

    const result = await registerUser.execute(userData);

    expect(mockUserRepository.findByEmail).toHaveBeenCalledWith('ivan@example.com');
    expect(mockUserRepository.save).toHaveBeenCalled();
    expect(mockEmailService.sendConfirmationEmail).toHaveBeenCalledWith('ivan@example.com', '1');
    expect(result.name).toBe('Иван Иванов');
  });

  test('throws error when email already exists', async () => {
    mockUserRepository.findByEmail.mockResolvedValue({ id: 'existing', email: 'ivan@example.com' });

    await expect(registerUser.execute({
      name: 'Иван Иванов',
      email: 'ivan@example.com',
      password: 'SecurePassword123'
    })).rejects.toThrow('Пользователь с таким email уже существует');
  });
});
```

## Инструменты и практики тестирования

### 1. Testing Library

```javascript
// components/SearchInput.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { SearchInput } from './SearchInput';

describe('SearchInput', () => {
  test('calls onChange with input value', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    
    render(<SearchInput onChange={handleChange} />);
    
    const input = screen.getByRole('textbox', { name: /поиск/i });
    await user.type(input, 'React');
    
    expect(handleChange).toHaveBeenCalledTimes(4); // по одному на каждый символ
    expect(handleChange).toHaveBeenLastCalledWith('React');
  });

  test('clears input when clear button is clicked', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    
    render(<SearchInput onChange={handleChange} />);
    
    const input = screen.getByRole('textbox');
    await user.type(input, 'React');
    
    const clearButton = screen.getByLabelText(/очистить/i);
    await user.click(clearButton);
    
    expect(input.value).toBe('');
    expect(handleChange).toHaveBeenLastCalledWith('');
  });
});
```

### 2. Mock-объекты и тестовые дублеры

```javascript
// __mocks__/apiClient.js
export const createMockApiClient = () => ({
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn()
});

// __mocks__/localStorage.js
export const createMockLocalStorage = () => {
  const store = {};
  
  return {
    getItem: jest.fn((key) => store[key] || null),
    setItem: jest.fn((key, value) => {
      store[key] = value.toString();
    }),
    removeItem: jest.fn((key) => {
      delete store[key];
    }),
    clear: jest.fn(() => {
      Object.keys(store).forEach(key => delete store[key]);
    })
  };
};

// tests/setup.js
import { createMockApiClient } from '../__mocks__/apiClient';
import { createMockLocalStorage } from '../__mocks__/localStorage';

// Устанавливаем моки для всех тестов
global.apiClient = createMockApiClient();
global.localStorage = createMockLocalStorage();
```

## Лучшие практики тестируемости

### 1. Пирамида тестирования

- **Много модульных тестов** (70%)
- **Меньше интеграционных тестов** (20%)
- **Еще меньше сквозных тестов** (10%)

### 2. Именование тестов

```javascript
// Хорошие названия тестов
describe('UserProfile component', () => {
  test('renders user name and email', () => {
    // тест
  });
  
  test('shows loading state initially', () => {
    // тест
  });
  
  test('handles save button click', () => {
    // тест
  });
});

// Плохие названия тестов
test('test 1', () => {
  // тест
});

test('user component', () => {
  // тест
});
```

### 3. Тестовые данные

```javascript
// testData/users.js
export const createUser = (overrides = {}) => ({
  id: overrides.id || '1',
  name: overrides.name || 'Иван Иванов',
  email: overrides.email || 'ivan@example.com',
  age: overrides.age || 30,
  role: overrides.role || 'user',
  ...overrides
});

export const mockUsers = [
  createUser({ id: '1', name: 'Иван Иванов', email: 'ivan@example.com' }),
  createUser({ id: '2', name: 'Петр Петров', email: 'petr@example.com', role: 'admin' }),
  createUser({ id: '3', name: 'Сидор Сидоров', email: 'sidor@example.com', age: 25 })
];

// Использование в тестах
test('filters users by role', () => {
  const adminUsers = mockUsers.filter(user => user.role === 'admin');
  expect(adminUsers).toHaveLength(1);
  expect(adminUsers[0].name).toBe('Петр Петров');
});
```

## Ключевые выводы

- Тестируемость начинается с архитектурного проектирования
- Разделение ответственности облегчает тестирование
- Инъекция зависимостей позволяет легко мокать внешние зависимости
- Пирамида тестирования помогает поддерживать баланс между типами тестов
- Чистые функции и предсказуемое состояние упрощают тестирование

## См. также

- [[Поддерживаемость]]
- [[Принципы-архитектуры]]
- [[Компонентная-архитектура]]
- [[Документирование-архитектуры]]