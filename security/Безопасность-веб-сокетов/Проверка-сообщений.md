---
aliases: ["Проверка сообщений WebSocket", "Message Validation", "WebSocket Message Security"]
tags: [security, websocket, validation, messages]
created: 2025-11-18
updated: 2025-11-18
---

# Проверка сообщений

Проверка сообщений в WebSocket соединениях - это процесс валидации всех данных, полученных от клиентов, для обеспечения их целостности, безопасности и соответствия ожидаемому формату. Это критически важный компонент безопасности, предотвращающий различные виды атак и обеспечение корректной работы приложения.

## Введение

В отличие от HTTP, где каждый запрос может быть проверен отдельно, WebSocket обеспечивает постоянное соединение, через которое пользователь может отправлять неограниченное количество сообщений. Это делает проверку сообщений особенно важной для предотвращения атак и обеспечения стабильности системы.

## Принципы проверки сообщений

### Типы проверок

#### Структурная проверка

Проверка формата и структуры сообщения:

- Валидация JSON-структуры
- Проверка обязательных полей
- Проверка типов данных
- Проверка вложенных структур

#### Семантическая проверка

Проверка смысла и содержания сообщения:

- Проверка значений полей
- Проверка логических связей
- Проверка бизнес-правил
- Проверка на соответствие правам доступа

#### Безопасная проверка

Проверка на наличие угроз безопасности:

- Проверка на инъекции
- Проверка на XSS
- Проверка на CSRF
- Проверка на атаки переполнения

## Архитектура проверки

### Слои проверки

```
[Клиент] --> [Сообщение] --> [Проверка структуры] --> [Проверка безопасности] --> [Проверка бизнес-логики] --> [Обработка]
```

### Компоненты системы проверки

```javascript
class MessageValidator {
  constructor() {
    this.structureValidator = new StructureValidator();
    this.securityValidator = new SecurityValidator();
    this.businessValidator = new BusinessValidator();
  }
  
  async validate(message, context) {
    // Проверка структуры
    if (!this.structureValidator.validate(message)) {
      throw new ValidationError('Invalid message structure');
    }
    
    // Проверка безопасности
    if (!this.securityValidator.validate(message)) {
      throw new SecurityError('Security violation detected');
    }
    
    // Проверка бизнес-логики
    if (!this.businessValidator.validate(message, context)) {
      throw new BusinessError('Business rule violation');
    }
    
    return true;
  }
}
```

## Структурная проверка

### Проверка формата JSON

```javascript
class StructureValidator {
  validate(message) {
    // Проверка, что сообщение - валидный JSON
    if (typeof message !== 'object' || message === null) {
      return false;
    }
    
    // Проверка обязательных полей
    if (!message.hasOwnProperty('type') || typeof message.type !== 'string') {
      return false;
    }
    
    // Проверка необязательных полей
    if (message.hasOwnProperty('data') && typeof message.data !== 'object') {
      return false;
    }
    
    // Проверка вложенных структур
    if (message.data) {
      return this.validateDataStructure(message.data);
    }
    
    return true;
  }
  
  validateDataStructure(data) {
    // Рекурсивная проверка вложенных структур
    for (const key in data) {
      const value = data[key];
      
      if (typeof value === 'object' && value !== null) {
        if (!this.validateDataStructure(value)) {
          return false;
        }
      } else if (typeof value === 'string') {
        // Проверка длины строк
        if (value.length > MAX_STRING_LENGTH) {
          return false;
        }
      }
    }
    
    return true;
  }
}
```

### Использование схем валидации

```javascript
const Ajv = require('ajv');
const ajv = new Ajv();

// Определение схемы для различных типов сообщений
const messageSchemas = {
  chat: {
    type: 'object',
    properties: {
      type: { const: 'chat' },
      data: {
        type: 'object',
        properties: {
          message: { type: 'string', maxLength: 1000 },
          timestamp: { type: 'number' }
        },
        required: ['message']
      }
    },
    required: ['type', 'data']
  },
  
  command: {
    type: 'object',
    properties: {
      type: { const: 'command' },
      data: {
        type: 'object',
        properties: {
          command: { type: 'string', pattern: '^[a-zA-Z0-9_]+$' },
          params: { type: 'object' }
        },
        required: ['command']
      }
    },
    required: ['type', 'data']
  }
};

class SchemaValidator {
  validate(message) {
    const schema = messageSchemas[message.type];
    
    if (!schema) {
      return false;
    }
    
    const validate = ajv.compile(schema);
    return validate(message);
  }
}
```

## Безопасная проверка

### Проверка на инъекции

```javascript
class SecurityValidator {
  validate(message) {
    // Проверка на SQL-инъекции
    if (this.containsSqlInjection(message)) {
      return false;
    }
    
    // Проверка на командные инъекции
    if (this.containsCommandInjection(message)) {
      return false;
    }
    
    // Проверка на XSS
    if (this.containsXss(message)) {
      return false;
    }
    
    // Проверка на шаблонные инъекции
    if (this.containsTemplateInjection(message)) {
      return false;
    }
    
    return true;
  }
  
  containsSqlInjection(message) {
    const sqlPatterns = [
      /(\b(union|select|insert|delete|update|drop|create|alter|exec|execute)\b)/gi,
      /(;|--|\/\*|\*\/|xp_|sp_|0x)/gi
    ];
    
    return this.checkForPattern(message, sqlPatterns);
  }
  
  containsCommandInjection(message) {
    const commandPatterns = [
      /[;&|`$<>]/,
      /\$\(/,
      /`.*`/,
      /\\n/
    ];
    
    return this.checkForPattern(message, commandPatterns);
  }
  
  containsXss(message) {
    const xssPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+\s*=/i,
      /<iframe/i,
      /<object/i,
      /<embed/i
    ];
    
    return this.checkForPattern(message, xssPatterns);
  }
  
  containsTemplateInjection(message) {
    const templatePatterns = [
      /\{\{.*\}\}/,  // Jinja2, Handlebars
      /\$\{.*\}/,    // JavaScript template literals
      /<%.*%>/,     // ERB, ASP
      /#\{.*\}/     // Ruby
    ];
    
    return this.checkForPattern(message, templatePatterns);
  }
  
  checkForPattern(message, patterns) {
    // Рекурсивная проверка всех строковых значений в сообщении
    const messageStr = JSON.stringify(message);
    
    for (const pattern of patterns) {
      if (pattern.test(messageStr)) {
        return true;
      }
    }
    
    return false;
  }
}
```

### Санитизация данных

```javascript
class DataSanitizer {
  sanitize(message) {
    // Рекурсивная санитизация всех строк в сообщении
    return this.sanitizeValue(message);
  }
  
  sanitizeValue(value) {
    if (typeof value === 'string') {
      return this.sanitizeString(value);
    } else if (Array.isArray(value)) {
      return value.map(item => this.sanitizeValue(item));
    } else if (typeof value === 'object' && value !== null) {
      const sanitized = {};
      for (const key in value) {
        sanitized[key] = this.sanitizeValue(value[key]);
      }
      return sanitized;
    }
    
    return value;
  }
  
  sanitizeString(str) {
    // Экранирование HTML
    str = str.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#x27;');
    
    // Удаление потенциально опасных последовательностей
    str = str.replace(/javascript:/gi, '');
    str = str.replace(/vbscript:/gi, '');
    
    return str;
  }
}
```

## Бизнес-проверка

### Проверка прав доступа

```javascript
class BusinessValidator {
  constructor(permissionChecker) {
    this.permissionChecker = permissionChecker;
  }
  
  async validate(message, context) {
    const { userId, connection } = context;
    
    // Проверка прав на выполнение действия
    if (!await this.permissionChecker.hasPermission(userId, message.type)) {
      return false;
    }
    
    // Проверка прав на доступ к ресурсу
    if (message.data && message.data.resourceId) {
      if (!await this.permissionChecker.hasResourceAccess(userId, message.data.resourceId)) {
        return false;
      }
    }
    
    // Проверка бизнес-ограничений
    if (!this.validateBusinessRules(message, context)) {
      return false;
    }
    
    return true;
  }
  
  validateBusinessRules(message, context) {
    switch (message.type) {
      case 'chat':
        return this.validateChatMessage(message, context);
      case 'command':
        return this.validateCommand(message, context);
      case 'file_upload':
        return this.validateFileUpload(message, context);
      default:
        return true;
    }
  }
  
  validateChatMessage(message, context) {
    // Проверка длины сообщения
    if (message.data.message && message.data.message.length > 1000) {
      return false;
    }
    
    // Проверка частоты сообщений (антиспам)
    if (this.isSpamMessage(context)) {
      return false;
    }
    
    return true;
  }
  
  validateCommand(message, context) {
    // Проверка разрешенных команд
    const allowedCommands = ['ping', 'status', 'info'];
    if (!allowedCommands.includes(message.data.command)) {
      return false;
    }
    
    return true;
  }
  
  validateFileUpload(message, context) {
    // Проверка размера файла
    if (message.data.size > MAX_FILE_SIZE) {
      return false;
    }
    
    // Проверка типа файла
    const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
    if (!allowedTypes.includes(message.data.type)) {
      return false;
    }
    
    return true;
  }
  
  isSpamMessage(context) {
    // Проверка частоты сообщений пользователя
    const now = Date.now();
    const userMessages = context.userMessageHistory || [];
    
    // Если больше 5 сообщений за 10 секунд
    const recentMessages = userMessages.filter(time => now - time < 10000);
    return recentMessages.length > 5;
  }
}
```

## Практические примеры

### Комплексная проверка сообщений

```javascript
class SecureWebSocketHandler {
  constructor() {
    this.validator = new MessageValidator();
    this.sanitizer = new DataSanitizer();
    this.rateLimiter = new RateLimiter();
  }
  
  async handleMessage(ws, message) {
    try {
      // Проверка размера сообщения
      if (message.length > MAX_MESSAGE_SIZE) {
        ws.close(1009, 'Message too large');
        return;
      }
      
      // Парсинг JSON
      const parsedMessage = JSON.parse(message);
      
      // Проверка структуры
      if (!this.validateStructure(parsedMessage)) {
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Invalid message structure'
        }));
        return;
      }
      
      // Проверка частоты сообщений
      if (!await this.rateLimiter.check(ws.userId)) {
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Rate limit exceeded'
        }));
        return;
      }
      
      // Контекст проверки
      const context = {
        userId: ws.userId,
        connection: ws,
        timestamp: Date.now()
      };
      
      // Комплексная проверка
      try {
        await this.validator.validate(parsedMessage, context);
      } catch (validationError) {
        ws.send(JSON.stringify({
          type: 'error',
          message: validationError.message
        }));
        return;
      }
      
      // Санитизация данных
      const sanitizedMessage = this.sanitizer.sanitize(parsedMessage);
      
      // Обработка валидного сообщения
      await this.processValidMessage(ws, sanitizedMessage, context);
      
    } catch (error) {
      console.error('Message validation error:', error);
      ws.close(1003, 'Invalid message format');
    }
  }
  
  validateStructure(message) {
    // Проверка базовой структуры
    if (!message || typeof message !== 'object') {
      return false;
    }
    
    if (!message.hasOwnProperty('type') || typeof message.type !== 'string') {
      return false;
    }
    
    // Проверка длины типа сообщения
    if (message.type.length > 50) {
      return false;
    }
    
    return true;
  }
  
  async processValidMessage(ws, message, context) {
    // Обработка валидного и безопасного сообщения
    switch (message.type) {
      case 'chat':
        await this.handleChatMessage(ws, message, context);
        break;
      case 'notification':
        await this.handleNotification(ws, message, context);
        break;
      case 'command':
        await this.handleCommand(ws, message, context);
        break;
      default:
        console.error('Unknown message type:', message.type);
    }
  }
  
  async handleChatMessage(ws, message, context) {
    // Отправка сообщения другим пользователям
    const chatMessage = {
      type: 'chat',
      data: {
        userId: ws.userId,
        message: message.data.message,
        timestamp: Date.now()
      }
    };
    
    // Отправка всем подключенным пользователям
    ws.server.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN && client !== ws) {
        client.send(JSON.stringify(chatMessage));
      }
    });
    
    // Логирование сообщения
    this.logMessage(ws.userId, message.data.message);
  }
  
  logMessage(userId, message) {
    // Логирование сообщения для аудита
    console.log(`User ${userId} sent: ${message}`);
  }
}
```

### Проверка на основе схем данных

```javascript
// Определение схем для различных типов сообщений
const messageValidationSchemas = {
  user_profile_update: {
    validate: (message, context) => {
      // Проверка структуры
      if (!message.data || typeof message.data !== 'object') {
        return { valid: false, error: 'Data must be an object' };
      }
      
      // Проверка конкретных полей
      const { name, email, bio } = message.data;
      
      if (name && typeof name !== 'string') {
        return { valid: false, error: 'Name must be a string' };
      }
      
      if (name && name.length > 50) {
        return { valid: false, error: 'Name too long' };
      }
      
      if (email && typeof email !== 'string') {
        return { valid: false, error: 'Email must be a string' };
      }
      
      if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return { valid: false, error: 'Invalid email format' };
      }
      
      if (bio && typeof bio !== 'string') {
        return { valid: false, error: 'Bio must be a string' };
      }
      
      if (bio && bio.length > 500) {
        return { valid: false, error: 'Bio too long' };
      }
      
      return { valid: true };
    }
  },
  
  file_upload_request: {
    validate: (message, context) => {
      if (!message.data || typeof message.data !== 'object') {
        return { valid: false, error: 'Data must be an object' };
      }
      
      const { filename, size, type } = message.data;
      
      if (typeof filename !== 'string' || !filename) {
        return { valid: false, error: 'Filename is required' };
      }
      
      if (typeof size !== 'number' || size <= 0) {
        return { valid: false, error: 'Valid size is required' };
      }
      
      if (size > MAX_FILE_SIZE) {
        return { valid: false, error: 'File too large' };
      }
      
      if (typeof type !== 'string' || !ALLOWED_FILE_TYPES.includes(type)) {
        return { valid: false, error: 'Invalid file type' };
      }
      
      return { valid: true };
    }
  }
};

class SchemaBasedValidator {
  async validate(message, context) {
    const schema = messageValidationSchemas[message.type];
    
    if (!schema) {
      return { valid: false, error: `Unknown message type: ${message.type}` };
    }
    
    return schema.validate(message, context);
  }
}
```

## Мониторинг и логирование

### Журналирование проверок

```javascript
const winston = require('winston');

const validationLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'validation-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'validation-combined.log' })
  ]
});

class MonitoredValidator {
  async validateWithLogging(message, context) {
    const startTime = Date.now();
    
    try {
      const result = await this.validate(message, context);
      
      validationLogger.info('Message validation completed', {
        userId: context.userId,
        messageType: message.type,
        isValid: result.valid,
        processingTime: Date.now() - startTime,
        timestamp: new Date().toISOString()
      });
      
      return result;
    } catch (error) {
      validationLogger.error('Message validation error', {
        userId: context.userId,
        messageType: message.type,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      
      throw error;
    }
  }
}
```

### Интеграция с [[Сигнализация-безопасности]]

```javascript
class SecurityMonitoredValidator {
  constructor(securitySystem) {
    this.securitySystem = securitySystem;
  }
  
  async validate(message, context) {
    const result = await this.performValidation(message, context);
    
    // Проверка на подозрительные паттерны
    if (this.containsSuspiciousPatterns(message)) {
      this.securitySystem.sendAlert('suspicious_message', {
        userId: context.userId,
        message: message,
        pattern: this.detectPattern(message)
      });
    }
    
    // Проверка частоты подозрительных сообщений
    if (this.isHighRiskUser(context.userId)) {
      this.securitySystem.sendAlert('high_risk_activity', {
        userId: context.userId,
        messageCount: this.getUserMessageCount(context.userId)
      });
    }
    
    return result;
  }
  
  containsSuspiciousPatterns(message) {
    // Проверка на наличие подозрительных паттернов
    const messageStr = JSON.stringify(message);
    return /((union|select|drop|exec)\s+|<script|javascript:)/i.test(messageStr);
  }
  
  detectPattern(message) {
    const messageStr = JSON.stringify(message);
    
    if (/(union|select|drop|exec)\s+/i.test(messageStr)) {
      return 'sql_injection_attempt';
    } else if (/<script/i.test(messageStr)) {
      return 'xss_attempt';
    } else if (/javascript:/i.test(messageStr)) {
      return 'script_injection_attempt';
    }
    
    return 'unknown';
  }
  
  isHighRiskUser(userId) {
    // Проверка, является ли пользователь высокорисковым
    // Реализация зависит от системы анализа рисков
    return false; // Заглушка
  }
  
  getUserMessageCount(userId) {
    // Получение количества сообщений пользователя
    // Реализация зависит от системы мониторинга
    return 0; // Заглушка
  }
}
```

## Лучшие практики

### Эффективность проверок

- Использование быстрых проверок в начале
- Кэширование результатов проверок
- Асинхронная обработка при необходимости
- [[Анализ-логов]] для оптимизации производительности

### Безопасность

- Проверка всех входных данных
- Использование белых списков для разрешенных значений
- Санитизация данных перед обработкой
- [[Предотвращение-инъекций]] во всех формах

### Масштабируемость

- Модульная архитектура проверок
- Возможность добавления новых правил
- Интеграция с внешними системами
- [[Инструменты-мониторинга-безопасности]]

## Современные подходы

### Машинное обучение для обнаружения аномалий

```javascript
class MLBasedValidator {
  constructor(mlModel) {
    this.mlModel = mlModel;
  }
  
  async validate(message, context) {
    // Получение признаков из сообщения
    const features = this.extractFeatures(message, context);
    
    // Предсказание риска
    const riskScore = await this.mlModel.predict(features);
    
    if (riskScore > THRESHOLD) {
      return { valid: false, error: 'Anomalous message detected' };
    }
    
    // Традиционные проверки
    return await this.traditionalValidation(message, context);
  }
  
  extractFeatures(message, context) {
    // Извлечение признаков для ML модели
    return {
      messageLength: JSON.stringify(message).length,
      containsSpecialChars: this.countSpecialChars(message),
      messageFrequency: this.getMessageFrequency(context.userId),
      timeOfDay: new Date().getHours()
    };
  }
  
  countSpecialChars(message) {
    const str = JSON.stringify(message);
    return (str.match(/[^a-zA-Z0-9\s]/g) || []).length;
  }
  
  getMessageFrequency(userId) {
    // Подсчет частоты сообщений пользователя
    // Реализация зависит от системы мониторинга
    return 0; // Заглушка
  }
}
```

> [!tip] Совет
> Используйте комбинацию статических проверок и динамических правил для обеспечения максимальной безопасности.

> [!warning] Важно
> Проверяйте все сообщения, даже если соединение уже аутентифицировано, так как безопасность должна быть многоуровневой.

## Заключение

Проверка сообщений в WebSocket соединениях является критическим компонентом безопасности системы. Правильная реализация обеспечивает защиту от различных видов атак, гарантирует целостность данных и стабильность работы приложения.