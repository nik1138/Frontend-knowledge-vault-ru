---
aliases: [Клиентское безопасное хранилище, Защита данных в браузере]
tags: [security, storage, web-security, client-side-security, best-practices]
---

# Безопасное клиентское хранилище

## Введение в безопасное клиентское хранилище

Безопасное клиентское хранилище - это критически важный аспект веб-разработки, который обеспечивает защиту конфиденциальных данных пользователя в браузере. При правильной реализации оно позволяет сохранять информацию локально на стороне клиента, минимизируя риски утечки данных и обеспечивая соблюдение требований безопасности и конфиденциальности.

Клиентское хранилище предоставляет разработчикам возможность сохранять данные на устройстве пользователя, что может улучшить производительность приложения за счет снижения количества сетевых запросов и обеспечения автономной работы. Однако неправильное использование этих возможностей может привести к серьезным уязвимостям, включая утечку конфиденциальной информации, атаки межсайтового скриптинга (XSS) и другие формы компрометации данных.

## Типы клиентского хранилища

### localStorage

`localStorage` - это API Web Storage, который позволяет хранить данные в виде пар ключ-значение в браузере пользователя. Данные, сохраненные в `localStorage`, не имеют срока действия и остаются доступными до тех пор, пока не будут явно удалены пользователем или приложением.

```javascript
// Сохранение данных
localStorage.setItem('token', 'abc123');

// Получение данных
const token = localStorage.getItem('token');

// Удаление данных
localStorage.removeItem('token');
```

### sessionStorage

`sessionStorage` аналогичен `localStorage`, но данные в нем сохраняются только на время сеанса браузера. При закрытии вкладки или браузера данные удаляются.

```javascript
// Сохранение данных
sessionStorage.setItem('tempData', 'value');

// Получение данных
const tempData = sessionStorage.getItem('tempData');
```

### IndexedDB

IndexedDB - это низкоуровневое API для хранения значительных объемов структурированных данных, включая файлы и объекты Blob. Это мощная система хранения, подходящая для сложных приложений, требующих автономной работы.

```javascript
const request = indexedDB.open('MyDatabase', 1);

request.onsuccess = function(event) {
    const db = event.target.result;
    const transaction = db.transaction(['MyObjectStore'], 'readwrite');
    const objectStore = transaction.objectStore('MyObjectStore');
    objectStore.add({name: 'John', age: 30});
};
```

### Куки (Cookies)

Куки - это небольшие фрагменты данных, отправляемые веб-сервером и хранимые в браузере пользователя. Они автоматически отправляются обратно на сервер с каждым запросом к домену, который установил куки.

```javascript
// Установка куки
document.cookie = "username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";

// Чтение куки
const cookies = document.cookie.split(';');
```

### Другие типы хранилища

- **Cache API** - для кэширования ресурсов в сервис-воркерах
- **File System Access API** - для работы с файлами на устройстве пользователя
- **WebSQL** (устаревший) - для хранения данных в SQL-базе данных

## Угрозы безопасности при использовании клиентского хранилища

### Межсайтовый скриптинг (XSS)

XSS-атаки позволяют злоумышленникам внедрять вредоносный скрипт в веб-страницу, который затем может получить доступ к данным в клиентском хранилище. Это особенно опасно, когда в хранилище сохраняются чувствительные данные, такие как токены аутентификации.

### Межсайтовая подделка запроса (CSRF)

Хотя CSRF-атаки не напрямую связаны с хранилищем, они могут использовать данные, хранящиеся в куках, для выполнения несанкционированных действий от имени пользователя.

### Неправильная конфигурация безопасности куки

Небезопасные настройки куки, такие как отсутствие флагов `HttpOnly`, `Secure` или `SameSite`, могут привести к их утечке или несанкционированному использованию.

### Атаки на уровне браузера

Компрометация браузера или операционной системы может позволить злоумышленнику получить доступ к данным в клиентском хранилище, даже если приложение реализовано безопасно.

### Социальная инженерия

Злоумышленники могут использовать социальную инженерию для получения доступа к устройству пользователя и, соответственно, к данным в хранилище.

## Когда и что хранить в клиентском хранилище

### Рекомендуемые данные для хранения

- **Настройки пользователя** - языковые предпочтения, темы интерфейса, настройки уведомлений
- **Данные формы** - временные данные, введенные пользователем, для восстановления при непредвиденном завершении сеанса
- **Кэшированные данные** - результаты запросов к API, которые не изменяются часто
- **Идентификаторы сессии** - при правильной защите (см. раздел о защите чувствительных данных)

### Данные, которые НЕ следует хранить

- **Конфиденциальные учетные данные** - пароли, личные идентификаторы, финансовая информация
- **Конфиденциальные персональные данные** - без явного согласия пользователя и соответствующих мер безопасности
- **Чувствительные токены доступа** - без шифрования и дополнительных мер защиты

### Принципы безопасного хранения

- Минимизация объема хранимых данных
- Использование шифрования для чувствительной информации
- Регулярная очистка устаревших данных
- Проверка прав доступа к данным

## Шифрование данных в клиентском хранилище

### Использование Web Crypto API

Web Crypto API предоставляет набор криптографических функций, доступных в браузере, которые можно использовать для шифрования данных перед сохранением в хранилище.

```javascript
// Генерация ключа
const key = await window.crypto.subtle.generateKey(
    {
        name: "AES-GCM",
        length: 256,
    },
    true,
    ["encrypt", "decrypt"]
);

// Шифрование данных
async function encryptData(data, key) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);
    
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const encryptedData = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv,
        },
        key,
        encodedData
    );
    
    return {
        encrypted: Array.from(new Uint8Array(encryptedData)),
        iv: Array.from(iv)
    };
}

// Сохранение зашифрованных данных
const encrypted = await encryptData('sensitive data', key);
localStorage.setItem('encryptedData', JSON.stringify(encrypted));
```

### Библиотеки шифрования

- **crypto-js** - популярная библиотека для криптографических операций
- **TweetNaCl.js** - реализация криптографических примитивов
- **SJCL** - Stanford JavaScript Crypto Library

### Практические рекомендации по шифрованию

- Использовать сильные алгоритмы шифрования (AES-256)
- Генерировать уникальные векторы инициализации (IV) для каждого шифрования
- Хранить ключи шифрования отдельно от данных
- Регулярно обновлять ключи шифрования

## Защита чувствительных данных

### Токены аутентификации

Хранение токенов аутентификации требует особого внимания к безопасности. Рекомендуется:

- Использовать куки с флагами `HttpOnly`, `Secure` и `SameSite`
- Применять шифрование при хранении в `localStorage` или `sessionStorage`
- Реализовать механизм автоматического обновления токенов
- Ограничивать срок действия токенов

### Персональные данные

При хранении персональных данных необходимо:

- Соблюдать требования GDPR, CCPA и других нормативных актов
- Получать явное согласие пользователя
- Обеспечивать шифрование данных
- Реализовать механизмы удаления данных по запросу пользователя

### Финансовая информация

Финансовая информация НЕ должна храниться в клиентском хранилище. Вся обработка и хранение финансовой информации должно происходить на сервере с соответствующими мерами безопасности.

## Куки безопасности (HttpOnly, Secure, SameSite и др.)

### HttpOnly

Флаг `HttpOnly` предотвращает доступ к куки из JavaScript, что защищает от XSS-атак, направленных на кражу куки.

```
Set-Cookie: sessionId=abc123; HttpOnly
```

### Secure

Флаг `Secure` гарантирует, что куки будут передаваться только по защищенному HTTPS-соединению.

```
Set-Cookie: sessionId=abc123; Secure
```

### SameSite

Флаг `SameSite` помогает предотвратить CSRF-атаки, контролируя, когда куки отправляются с межсайтовых запросов.

- `SameSite=Strict` - куки отправляются только в рамках одного сайта
- `SameSite=Lax` - куки отправляются с навигационных запросов, но не с программных запросов
- `SameSite=None` - куки отправляются с любых запросов (требует флага `Secure`)

```
Set-Cookie: sessionId=abc123; SameSite=Strict
```

### Другие важные флаги

- `Max-Age` - определяет срок действия куки
- `Domain` - указывает домен, для которого действует куки
- `Path` - указывает путь, для которого действует куки

## Безопасность Web Storage

### Ограничения Web Storage

- Ограниченный объем хранения (обычно 5-10 МБ)
- Хранение в виде строк (необходимо сериализовать объекты)
- Отсутствие встроенной безопасности

### Рекомендации по безопасности

- Не хранить чувствительные данные в `localStorage` или `sessionStorage`
- Использовать шифрование для любых данных, требующих защиты
- Очищать данные при завершении сеанса
- Проверять данные при извлечении на наличие манипуляций

### Защита от XSS

- Экранировать данные при выводе в HTML
- Использовать Content Security Policy (CSP) для ограничения выполнения скриптов
- Валидировать и санитизировать ввод пользователя

## Безопасность IndexedDB

### Преимущества IndexedDB

- Возможность хранения больших объемов структурированных данных
- Поддержка транзакций
- Асинхронная работа (не блокирует UI)

### Риски безопасности

- Отсутствие встроенной системы аутентификации
- Возможность доступа из любого скрипта в том же происхождении
- Сложность шифрования данных

### Рекомендации по безопасности

- Шифровать чувствительные данные перед сохранением
- Использовать изоляцию баз данных для разных пользователей
- Реализовать проверки целостности данных
- Ограничивать права доступа к базе данных

## Практические примеры безопасного хранения

### Пример 1: Безопасное хранение токена доступа

```javascript
class SecureTokenStorage {
    constructor() {
        this.encryptionKey = null;
    }

    async initialize() {
        // Получение или генерация ключа шифрования
        this.encryptionKey = await this.getEncryptionKey();
    }

    async storeToken(token) {
        const encryptedToken = await this.encrypt(token);
        localStorage.setItem('secure_token', encryptedToken);
    }

    async retrieveToken() {
        const encryptedToken = localStorage.getItem('secure_token');
        if (!encryptedToken) return null;
        
        return await this.decrypt(encryptedToken);
    }

    async encrypt(data) {
        const encoder = new TextEncoder();
        const encodedData = encoder.encode(data);
        
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedData = await window.crypto.subtle.encrypt(
            {
                name: "AES-GCM",
                iv: iv,
            },
            this.encryptionKey,
            encodedData
        );

        return JSON.stringify({
            encrypted: Array.from(new Uint8Array(encryptedData)),
            iv: Array.from(iv)
        });
    }

    async decrypt(encryptedString) {
        const { encrypted, iv } = JSON.parse(encryptedString);
        
        const decryptedData = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: new Uint8Array(iv),
            },
            this.encryptionKey,
            new Uint8Array(encrypted)
        );

        const decoder = new TextDecoder();
        return decoder.decode(decryptedData);
    }

    async getEncryptionKey() {
        // В реальном приложении ключ должен храниться более безопасно
        // и возможно извлекаться с сервера
        const key = await window.crypto.subtle.generateKey(
            {
                name: "AES-GCM",
                length: 256,
            },
            true,
            ["encrypt", "decrypt"]
        );
        
        return key;
    }
}

// Использование
const secureStorage = new SecureTokenStorage();
await secureStorage.initialize();
await secureStorage.storeToken('your-jwt-token');
const token = await secureStorage.retrieveToken();
```

### Пример 2: Защита данных в IndexedDB

```javascript
class SecureIndexedDB {
    constructor(dbName, version) {
        this.dbName = dbName;
        this.version = version;
        this.encryptionKey = null;
    }

    async initialize() {
        this.encryptionKey = await this.getEncryptionKey();
        this.db = await this.openDB();
    }

    async openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Создание объектного хранилища
                if (!db.objectStoreNames.contains('secure_data')) {
                    const store = db.createObjectStore('secure_data', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    }

    async storeSecureData(id, data) {
        const encryptedData = await this.encrypt(JSON.stringify(data));
        const transaction = this.db.transaction(['secure_data'], 'readwrite');
        const store = transaction.objectStore('secure_data');

        return new Promise((resolve, reject) => {
            const request = store.put({
                id: id,
                encryptedData: encryptedData,
                timestamp: Date.now()
            });

            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async retrieveSecureData(id) {
        const transaction = this.db.transaction(['secure_data'], 'readonly');
        const store = transaction.objectStore('secure_data');
        const request = store.get(id);

        return new Promise((resolve, reject) => {
            request.onsuccess = async () => {
                const result = request.result;
                if (result) {
                    const decryptedData = await this.decrypt(result.encryptedData);
                    resolve(JSON.parse(decryptedData));
                } else {
                    resolve(null);
                }
            };
            request.onerror = () => reject(request.error);
        });
    }

    async encrypt(data) {
        const encoder = new TextEncoder();
        const encodedData = encoder.encode(data);
        
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedData = await window.crypto.subtle.encrypt(
            {
                name: "AES-GCM",
                iv: iv,
            },
            this.encryptionKey,
            encodedData
        );

        return {
            encrypted: Array.from(new Uint8Array(encryptedData)),
            iv: Array.from(iv)
        };
    }

    async decrypt(encryptedObj) {
        const { encrypted, iv } = encryptedObj;
        
        const decryptedData = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: new Uint8Array(iv),
            },
            this.encryptionKey,
            new Uint8Array(encrypted)
        );

        const decoder = new TextDecoder();
        return decoder.decode(decryptedData);
    }

    async getEncryptionKey() {
        // В реальном приложении ключ должен храниться более безопасно
        const key = await window.crypto.subtle.generateKey(
            {
                name: "AES-GCM",
                length: 256,
            },
            true,
            ["encrypt", "decrypt"]
        );
        
        return key;
    }
}
```

## Инструменты для анализа безопасности хранилища

### DevTools браузера

- **Application/Storage вкладка** - для просмотра и редактирования хранилища
- **Security вкладка** - для проверки настроек безопасности

### Browser Extensions

- **EditThisCookie** - для управления куки
- **Storage Area Explorer** - для просмотра данных в хранилище

### Сканирующие инструменты

- **OWASP ZAP** - для автоматического сканирования уязвимостей
- **Burp Suite** - для ручного тестирования безопасности
- **Snyk** - для проверки зависимостей на уязвимости

### Код-анализаторы

- **ESLint с плагинами безопасности** - для статического анализа кода
- **SonarQube** - для комплексного анализа качества и безопасности кода

## Лучшие практики

### Общие принципы

1. **Принцип минимальных привилегий** - хранить только минимально необходимые данные
2. **Шифрование чувствительных данных** - использовать криптографические методы для защиты
3. **Регулярная очистка** - удалять устаревшие и ненужные данные
4. **Мониторинг доступа** - отслеживать попытки несанкционированного доступа

### Практические рекомендации

- Использовать куки для хранения токенов аутентификации с флагами `HttpOnly`, `Secure`, `SameSite`
- Применять шифрование для любых чувствительных данных в `localStorage`/`sessionStorage`
- Использовать `sessionStorage` для временных данных, которые не должны сохраняться между сеансами
- Реализовать механизмы автоматического обновления и проверки сроков действия данных
- Валидировать и санитизировать все данные при извлечении из хранилища
- Использовать Content Security Policy для ограничения выполнения скриптов

### Проверки безопасности

- Регулярное тестирование на XSS-уязвимости
- Проверка правильности настройки куки
- Аудит хранимых данных на предмет конфиденциальной информации
- Тестирование механизмов шифрования

## Связанные материалы

- [[XSS-защита]] - защита от межсайтового скриптинга
- [[CSRF-защита]] - защита от межсайтовой подделки запроса
- [[HTTP-Security-Headers]] - безопасные заголовки HTTP
- [[Content-Security-Policy]] - политика безопасности контента
- [[Управление сессиями и аутентификацией]] - управление сессиями и аутентификацией
- [[Шифрование на клиенте]] - шифрование данных на клиенте
- [[Безопасность веб-сокетов]] - безопасность веб-сокетов
- [[Защита от инъекций]] - защита от различных видов инъекций
- [[Безопасность PWA]] - безопасность прогрессивных веб-приложений
- [[Безопасность в SPA]] - безопасность одностраничных приложений
- [[Обработка персональных данных]] - обработка персональных данных
- [[Управление доступом]] - управление доступом к ресурсам
- [[Ограничение доступа к API]] - ограничение доступа к API
- [[Контроль доступа к данным в браузере]] - контроль доступа к данным в браузере
- [[Снижение рисков при работе с cookies]] - снижение рисков при работе с куки
- [[Безопасность в системах с несколькими доменами]] - безопасность в системах с несколькими доменами
- [[Secure Coding Practices]] - безопасное программирование
- [[Тестирование безопасности]] - тестирование безопасности приложений
- [[Аудит безопасности]] - аудит безопасности систем
- [[Мониторинг безопасности]] - мониторинг безопасности в реальном времени
- [[Инцидент-менеджмент на фронтенде]] - управление инцидентами на фронтенде
- [[Dependency Security]] - безопасность зависимостей
- [[Обфускация и защита исходного кода]] - защита исходного кода от анализа
- [[Снижение влияния на производительность]] - сохранение производительности при реализации мер безопасности
- [[Политики безопасности для файлов]] - политики безопасности для работы с файлами
- [[Feature Policy]] - политики функций браузера
- [[Subresource Integrity]] - целостность подресурсов
- [[Безопасность в системах с высокой доступностью]] - особенности безопасности в высокодоступных системах
- [[Безопасность в облачных средах]] - безопасность в облачных средах
- [[Безопасность в микросервисной архитектуре]] - безопасность в микросервисах
- [[Безопасность в браузерных расширениях]] - безопасность браузерных расширений
- [[Безопасность в мобильных браузерах]] - особенности безопасности в мобильных браузерах
- [[Использование WebAssembly безопасно]] - безопасное использование WebAssembly
- [[Безопасность в системах с поддержкой плагинов]] - безопасность в системах с плагинами
- [[Безопасность в системах с push-уведомлениями]] - безопасность push-уведомлений
- [[Безопасность в системах с поддержкой камеры и микрофона]] - безопасность медиа-устройств
- [[Безопасность в системах с drag and drop файлов]] - безопасность при работе с файлами
- [[Безопасность в чатах]] - безопасность коммуникационных систем
- [[Безопасность в играх]] - безопасность игровых веб-приложений
- [[Безопасность в VR AR приложениях]] - безопасность виртуальной и дополненной реальности
- [[Безопасность веб-компонентов]] - безопасность пользовательских элементов
- [[Безопасность в системах с высокой интерактивностью]] - безопасность интерактивных систем
- [[Безопасность в системах с офлайн-режимом]] - безопасность автономных приложений
- [[Безопасность в системах с веб-платежами]] - безопасность платежных систем
- [[Безопасность в системах с веб-печатью]] - безопасность печати из браузера
- [[Безопасность в системах с не несколькими доменами]] - междоменная безопасность
- [[Безопасность в системах сборки]] - безопасность процессов сборки
- [[Безопасность в системах i18n]] - безопасность интернационализации
- [[Безопасность в CMS]] - безопасность систем управления контентом
- [[Безопасность в OIDC]] - безопасность протокола OpenID Connect
- [[Интеграция с OAuth]] - безопасная интеграция с OAuth
- [[Безопасность в third party integrations]] - безопасность интеграций с третьими сторонами
- [[Безопасность в веб-приложениях с AI ML]] - безопасность приложений с ИИ и машинным обучением
- [[Безопасность в веб-приложениях с P2P коммуникациями]] - безопасность пиринговых соединений
- [[Безопасность в веб-приложениях для детей]] - особенности безопасности для детской аудитории
- [[Безопасность в сервис-воркерах]] - безопасность сервис-воркеров
- [[Безопасность данных в реальном времени]] - безопасность потоковых данных
- [[Безопасность при работе с геолокацией]] - безопасность геолокационных данных
- [[Безопасность файлов конфигурации]] - безопасность конфигурационных файлов
- [[Безопасность форм]] - безопасность пользовательского ввода
- [[Безопасность платежных форм]] - безопасность обработки платежей
- [[Защита от атак на уровне браузера]] - комплексная защита браузера
- [[Защита от инъекций]] - предотвращение различных видов инъекций
- [[Защита от социальной инженерии]] - защита пользователей от манипуляций
- [[Защита от фишинга]] - предотвращение фишинговых атак
- [[Clickjacking защита]] - защита от кликджекинга
- [[Меры против ботов]] - защита от автоматизированных атак
- [[Обнаружение и предотвращение брутфорса]] - защита от перебора паролей
- [[Работа с уязвимыми пользователями]] - безопасность для уязвимых пользователей
- [[Снижение рисков в DevTools]] - безопасность при разработке
- [[Сниффинг и защита от него]] - защита от перехвата трафика
- [[Идентификация и отслеживание угроз]] - мониторинг и анализ угроз
- [[Этические аспекты безопасности]] - этические соображения в безопасности
- [[Безопасность в браузере]] - общие аспекты безопасности в браузере
- [[Безопасность в веб-приложениях]] - комплексная безопасность веб-приложений
- [[Основы веб-безопасности]] - фундаментальные принципы веб-безопасности
- [[Отладка безопасности]] - отладка и тестирование мер безопасности
- [[Безопасная работа с API]] - безопасное взаимодействие с API
- [[Безопасное кэширование]] - безопасное хранение данных в кэше
- [[Архитектурные паттерны безопасности]] - архитектурные решения для безопасности