---
aliases: ["Валидация файлов", "Проверка загружаемых файлов"]
tags: [security, file-validation, web-security, frontend-security]
---

# Проверка файлов

## Введение

Проверка файлов - это критический этап в обеспечении безопасности веб-приложений, особенно при реализации функций загрузки файлов. Неправильная или отсутствующая проверка может привести к серьезным уязвимостям, включая выполнение произвольного кода, межсайтовый скриптинг (XSS) и другие виды атак.

## Типы проверок файлов

### 1. Проверка по расширению файла

Самый простой, но не самый надежный метод проверки:

```javascript
function validateFileExtension(fileName, allowedExtensions) {
    const extension = '.' + fileName.split('.').pop().toLowerCase();
    return allowedExtensions.includes(extension);
}

// Пример использования
const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf'];
const fileName = 'document.pdf';
console.log(validateFileExtension(fileName, allowedExtensions)); // true
```

> [!warning] Важно
> Проверка только по расширению может быть легко обойдена злоумышленниками

### 2. Проверка по MIME-типу

Более надежный метод, основанный на типе содержимого файла:

```javascript
function validateMimeType(file, allowedMimeTypes) {
    return allowedMimeTypes.includes(file.type);
}

// Пример использования
const allowedMimeTypes = ['image/jpeg', 'image/png', 'application/pdf'];
const file = document.getElementById('fileInput').files[0];
console.log(validateMimeType(file, allowedMimeTypes));
```

### 3. Проверка сигнатуры файла (магического числа)

Наиболее надежный метод, основанный на анализе первых байтов файла:

```javascript
function validateFileSignature(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            const arr = new Uint8Array(event.target.result);
            let header = "";
            for (let i = 0; i < 4; i++) {
                header += arr[i].toString(16).padStart(2, '0');
            }
            
            // Проверяем сигнатуру для различных типов файлов
            if (header.startsWith('ffd8')) {
                resolve({ isValid: true, type: 'jpeg' });
            } else if (header === '89504e47') {
                resolve({ isValid: true, type: 'png' });
            } else if (header === '47494638') {
                resolve({ isValid: true, type: 'gif' });
            } else if (header.startsWith('25504446')) {
                resolve({ isValid: true, type: 'pdf' });
            } else {
                resolve({ isValid: false, type: 'unknown' });
            }
        };
        
        reader.onerror = () => reject(new Error('Ошибка чтения файла'));
        reader.readAsArrayBuffer(file.slice(0, 4));
    });
}
```

## Комплексная проверка файлов

### 1. Многоуровневая проверка

Совместное использование нескольких методов проверки:

```javascript
class FileValidator {
    constructor(config) {
        this.allowedExtensions = config.allowedExtensions || [];
        this.allowedMimeTypes = config.allowedMimeTypes || [];
        this.maxFileSize = config.maxFileSize || 5 * 1024 * 1024; // 5MB
        this.allowedSignatures = config.allowedSignatures || {};
    }
    
    async validate(file) {
        const errors = [];
        
        // Проверка размера
        if (!this.validateSize(file)) {
            errors.push('Файл слишком большой');
        }
        
        // Проверка расширения
        if (!this.validateExtension(file)) {
            errors.push('Неподдерживаемое расширение файла');
        }
        
        // Проверка MIME-типа
        if (!this.validateMimeType(file)) {
            errors.push('Неподдерживаемый MIME-тип');
        }
        
        // Проверка сигнатуры
        try {
            const signatureResult = await this.validateSignature(file);
            if (!signatureResult.isValid) {
                errors.push('Неверная сигнатура файла');
            }
        } catch (error) {
            errors.push('Ошибка проверки сигнатуры файла');
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }
    
    validateSize(file) {
        return file.size <= this.maxFileSize;
    }
    
    validateExtension(file) {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        return this.allowedExtensions.includes(ext);
    }
    
    validateMimeType(file) {
        return this.allowedMimeTypes.includes(file.type);
    }
    
    async validateSignature(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(event) {
                const arr = new Uint8Array(event.target.result);
                let header = "";
                for (let i = 0; i < Math.min(4, arr.length); i++) {
                    header += arr[i].toString(16).padStart(2, '0');
                }
                
                // Проверяем, начинается ли сигнатура с разрешенных значений
                const isValid = Object.keys(this.allowedSignatures).some(sig => 
                    header.startsWith(sig.toLowerCase())
                );
                
                resolve({ isValid, header });
            }.bind(this);
            
            reader.readAsArrayBuffer(file.slice(0, 4));
        });
    }
}

// Пример использования
const validator = new FileValidator({
    allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf'],
    allowedMimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'],
    maxFileSize: 10 * 1024 * 1024, // 10MB
    allowedSignatures: {
        'ffd8': 'JPEG',
        '89504e47': 'PNG', 
        '47494638': 'GIF',
        '25504446': 'PDF'
    }
});
```

### 2. Проверка изображений

Для изображений можно использовать дополнительные проверки:

```javascript
function validateImageFile(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const objectUrl = URL.createObjectURL(file);
        
        img.onload = () => {
            // Проверяем размеры изображения
            if (img.width > 0 && img.height > 0) {
                // Проверяем соотношение сторон (если нужно)
                const aspectRatio = img.width / img.height;
                if (aspectRatio < 0.1 || aspectRatio > 10) {
                    URL.revokeObjectURL(objectUrl);
                    reject(new Error('Подозрительное соотношение сторон изображения'));
                    return;
                }
                
                URL.revokeObjectURL(objectUrl);
                resolve({ isValid: true, width: img.width, height: img.height });
            } else {
                URL.revokeObjectURL(objectUrl);
                reject(new Error('Файл не является корректным изображением'));
            }
        };
        
        img.onerror = () => {
            URL.revokeObjectURL(objectUrl);
            reject(new Error('Файл не является корректным изображением'));
        };
        
        img.src = objectUrl;
    });
}
```

## Защита от обхода проверок

### 1. Проверка двойных расширений

Злоумышленники могут использовать двойные расширения для обхода фильтров:

```javascript
function checkDoubleExtensions(fileName) {
    // Проверяем наличие нескольких расширений
    const extensions = fileName.toLowerCase().split('.');
    if (extensions.length > 2) {
        // Проверяем, не является ли последнее расширение опасным
        const dangerousExtensions = ['.php', '.js', '.exe', '.bat', '.sh'];
        const lastExt = '.' + extensions[extensions.length - 1];
        const secondLastExt = '.' + extensions[extensions.length - 2];
        
        if (dangerousExtensions.includes(lastExt) || 
            dangerousExtensions.includes(secondLastExt)) {
            return false;
        }
    }
    return true;
}
```

### 2. Проверка на вшитый код

Для текстовых файлов и документов проверяйте наличие потенциально опасного кода:

```javascript
function scanForDangerousContent(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            const content = event.target.result;
            const dangerousPatterns = [
                /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,  // Скрипты
                /javascript:/gi,  // JavaScript URL
                /vbscript:/gi,    // VBScript URL
                /on\w+\s*=/gi,    // Обработчики событий
                /<iframe/gi,      // IFrame
                /<object/gi,      // Object
                /<embed/gi        // Embed
            ];
            
            const hasDangerousContent = dangerousPatterns.some(pattern => 
                pattern.test(content)
            );
            
            resolve(!hasDangerousContent);
        };
        
        reader.readAsText(file);
    });
}
```

## Современные подходы к проверке файлов

### 1. Использование машинного обучения

Для сложных сценариев можно использовать ML-модели для анализа файлов:

```javascript
// Псевдокод для ML-проверки
async function mlFileValidation(file) {
    try {
        // Загружаем файл в безопасную среду для анализа
        const analysisResult = await sendToMLService(file);
        
        // ML-сервис возвращает вероятность того, что файл вредоносный
        if (analysisResult.malwareProbability > 0.8) {
            throw new Error('Файл определен как потенциально вредоносный');
        }
        
        return analysisResult;
    } catch (error) {
        console.error('Ошибка ML-анализа файла:', error);
        throw error;
    }
}
```

### 2. Изоморфная проверка

Выполняйте одинаковые проверки как на клиенте, так и на сервере:

```javascript
// Общая библиотека проверки файлов
const FileValidationLibrary = {
    validateSize: (file, maxSize) => file.size <= maxSize,
    
    validateExtension: (fileName, allowedExtensions) => {
        const ext = '.' + fileName.split('.').pop().toLowerCase();
        return allowedExtensions.includes(ext);
    },
    
    validateMimeType: (file, allowedMimeTypes) => 
        allowedMimeTypes.includes(file.type),
    
    async validateSignature(file, allowedSignatures) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(event) {
                const arr = new Uint8Array(event.target.result);
                let header = "";
                for (let i = 0; i < Math.min(4, arr.length); i++) {
                    header += arr[i].toString(16).padStart(2, '0');
                }
                
                const isValid = Object.keys(allowedSignatures).some(sig => 
                    header.startsWith(sig.toLowerCase())
                );
                
                resolve({ isValid, header });
            };
            
            reader.readAsArrayBuffer(file.slice(0, 4));
        });
    }
};
```

## Заключение

Проверка файлов требует многоуровневого подхода с использованием различных методов валидации. Ключевые принципы:

1. Используйте несколько методов проверки одновременно
2. Проверяйте как на клиенте, так и на сервере
3. Обновляйте правила проверки регулярно
4. Тестируйте системы на устойчивость к обходу
5. Используйте современные методы, включая ML, при необходимости

[[Безопасность-загрузки-файлов]]
[[Проверка-типов-содержимого]]
[[Безопасность-хранилища-файлов]]
[[Secure-Storage]]