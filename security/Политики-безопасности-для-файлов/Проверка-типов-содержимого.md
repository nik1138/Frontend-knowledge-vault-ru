---
aliases: ["Валидация MIME-типов", "Проверка содержимого файлов"]
tags: [security, content-validation, web-security, frontend-security]
---

# Проверка типов содержимого

## Введение

Проверка типов содержимого - важный аспект безопасности веб-приложений, особенно при работе с загружаемыми файлами, API-ответами и пользовательским вводом. Правильная проверка типов содержимого помогает предотвратить инъекции, XSS-атаки и другие уязвимости.

## Основные понятия

### MIME-типы

MIME (Multipurpose Internet Mail Extensions) типы определяют тип содержимого, передаваемого по сети. Они состоят из типа и подтипа, разделенных косой чертой:

- `text/html` - HTML-документ
- `application/json` - JSON-данные
- `image/jpeg` - JPEG-изображение
- `application/pdf` - PDF-документ

### Типы содержимого в веб-приложениях

В веб-приложениях проверка типов содержимого особенно важна для:

1. Загружаемых файлов
2. API-ответов
3. Данных из localStorage/sessionStorage
4. Данных из форм

## Проверка типов содержимого в файлах

### 1. Проверка MIME-типов при загрузке файлов

```javascript
function validateFileMimeType(file, allowedTypes) {
    // Проверяем MIME-тип файла
    if (!allowedTypes.includes(file.type)) {
        throw new Error(`Неподдерживаемый тип файла: ${file.type}`);
    }
    
    return true;
}

// Пример использования
const allowedImageTypes = [
    'image/jpeg',
    'image/png', 
    'image/gif',
    'image/webp'
];

const allowedDocumentTypes = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
];
```

### 2. Проверка сигнатуры файла

Для более надежной проверки используем сигнатуру файла (магическое число):

```javascript
function validateFileBySignature(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(event) {
            const arr = new Uint8Array(event.target.result);
            let header = "";
            
            // Читаем первые 8 байт для определения сигнатуры
            for (let i = 0; i < Math.min(8, arr.length); i++) {
                header += arr[i].toString(16).padStart(2, '0');
            }
            
            // Определяем тип файла по сигнатуре
            const fileType = getFileTypeBySignature(header);
            
            if (fileType) {
                resolve({ isValid: true, type: fileType });
            } else {
                reject(new Error('Неизвестная сигнатура файла'));
            }
        };
        
        reader.onerror = () => reject(new Error('Ошибка чтения файла'));
        reader.readAsArrayBuffer(file.slice(0, 8));
    });
}

function getFileTypeBySignature(signature) {
    const signatures = {
        'ffd8ffe000104a464946': 'jpeg',
        '89504e470d0a1a0a': 'png',
        '474946383761': 'gif87a',
        '474946383961': 'gif89a',
        '25504446': 'pdf',
        '504b0304': 'zip',
        '52617221': 'rar',
        '25215053': 'ps'
    };
    
    // Проверяем, начинается ли сигнатура с известных значений
    for (const [sig, type] of Object.entries(signatures)) {
        if (signature.startsWith(sig)) {
            return type;
        }
    }
    
    return null;
}
```

### 3. Проверка изображений

Для изображений можно использовать дополнительные проверки:

```javascript
function validateImageContent(file) {
    return new Promise((resolve, reject) => {
        // Сначала проверяем сигнатуру
        validateFileBySignature(file)
            .then(result => {
                if (!['jpeg', 'png', 'gif', 'webp'].includes(result.type)) {
                    reject(new Error('Файл не является изображением'));
                    return;
                }
                
                // Затем проверяем содержимое как изображение
                const img = new Image();
                const objectUrl = URL.createObjectURL(file);
                
                img.onload = () => {
                    // Проверяем размеры
                    if (img.width > 0 && img.height > 0) {
                        // Проверяем соотношение сторон (для обнаружения подозрительных изображений)
                        const aspectRatio = img.width / img.height;
                        if (aspectRatio > 100 || aspectRatio < 0.01) {
                            URL.revokeObjectURL(objectUrl);
                            reject(new Error('Подозрительное соотношение сторон изображения'));
                            return;
                        }
                        
                        URL.revokeObjectURL(objectUrl);
                        resolve({
                            isValid: true,
                            width: img.width,
                            height: img.height,
                            type: result.type
                        });
                    } else {
                        URL.revokeObjectURL(objectUrl);
                        reject(new Error('Изображение имеет нулевые размеры'));
                    }
                };
                
                img.onerror = () => {
                    URL.revokeObjectURL(objectUrl);
                    reject(new Error('Файл не является корректным изображением'));
                };
                
                img.src = objectUrl;
            })
            .catch(error => reject(error));
    });
}
```

## Проверка типов содержимого в API-ответах

### 1. Проверка заголовков Content-Type

```javascript
async function validateApiResponse(response, expectedContentType) {
    const contentType = response.headers.get('Content-Type');
    
    if (!contentType) {
        throw new Error('Отсутствует заголовок Content-Type');
    }
    
    // Проверяем, соответствует ли тип ожидаемому
    if (!contentType.includes(expectedContentType)) {
        throw new Error(`Неправильный тип содержимого: ${contentType}, ожидается: ${expectedContentType}`);
    }
    
    return response;
}

// Пример использования
try {
    const response = await fetch('/api/data');
    await validateApiResponse(response, 'application/json');
    const data = await response.json();
    console.log(data);
} catch (error) {
    console.error('Ошибка проверки API-ответа:', error);
}
```

### 2. Проверка структуры данных

```javascript
function validateJsonStructure(data, schema) {
    // Простая проверка структуры JSON
    for (const [key, expectedType] of Object.entries(schema)) {
        if (!(key in data)) {
            throw new Error(`Отсутствует обязательное поле: ${key}`);
        }
        
        const actualType = typeof data[key];
        if (actualType !== expectedType) {
            throw new Error(`Неправильный тип для поля ${key}: ожидается ${expectedType}, получено ${actualType}`);
        }
    }
    
    return true;
}

// Пример использования
const userSchema = {
    id: 'number',
    name: 'string',
    email: 'string',
    isActive: 'boolean'
};

const userData = { id: 1, name: 'John', email: 'john@example.com', isActive: true };
validateJsonStructure(userData, userSchema);
```

## Проверка типов содержимого в хранилищах

### 1. Проверка данных в localStorage

```javascript
class SafeLocalStorage {
    static setItem(key, value, expectedType) {
        // Проверяем тип значения
        const actualType = typeof value;
        if (expectedType && actualType !== expectedType) {
            throw new Error(`Неправильный тип для ключа ${key}: ожидается ${expectedType}, получено ${actualType}`);
        }
        
        // Сохраняем тип вместе с данными
        const dataToStore = {
            value: value,
            type: actualType,
            timestamp: Date.now()
        };
        
        localStorage.setItem(key, JSON.stringify(dataToStore));
    }
    
    static getItem(key, expectedType) {
        const stored = localStorage.getItem(key);
        if (!stored) {
            return null;
        }
        
        try {
            const parsed = JSON.parse(stored);
            
            // Проверяем тип
            if (expectedType && parsed.type !== expectedType) {
                console.warn(`Неправильный тип для ключа ${key}: ожидается ${expectedType}, получено ${parsed.type}`);
                return null;
            }
            
            return parsed.value;
        } catch (error) {
            console.error('Ошибка при чтении из localStorage:', error);
            return null;
        }
    }
    
    static validateAndParse(key, validatorFn) {
        const value = this.getItem(key);
        if (value && validatorFn(value)) {
            return value;
        }
        return null;
    }
}

// Пример использования
try {
    SafeLocalStorage.setItem('userPreferences', { theme: 'dark', lang: 'ru' }, 'object');
    const preferences = SafeLocalStorage.getItem('userPreferences', 'object');
    console.log(preferences);
} catch (error) {
    console.error('Ошибка работы с localStorage:', error);
}
```

### 2. Проверка типов в IndexedDB

```javascript
class SafeIndexedDB {
    static async validateAndStore(dbName, storeName, key, value, validatorFn) {
        // Проверяем значение с помощью валидатора
        if (!validatorFn(value)) {
            throw new Error(`Значение не прошло валидацию для ключа: ${key}`);
        }
        
        const request = indexedDB.open(dbName, 1);
        
        return new Promise((resolve, reject) => {
            request.onerror = () => reject(request.error);
            
            request.onsuccess = () => {
                const db = request.result;
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                
                store.put({ key, value, timestamp: Date.now() });
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(storeName)) {
                    db.createObjectStore(storeName, { keyPath: 'key' });
                }
            };
        });
    }
    
    static async retrieveAndValidate(dbName, storeName, key, validatorFn) {
        const request = indexedDB.open(dbName, 1);
        
        return new Promise((resolve, reject) => {
            request.onerror = () => reject(request.error);
            
            request.onsuccess = () => {
                const db = request.result;
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const getRequest = store.get(key);
                
                getRequest.onsuccess = () => {
                    const result = getRequest.result;
                    if (result && result.value && validatorFn(result.value)) {
                        resolve(result.value);
                    } else {
                        resolve(null);
                    }
                };
                
                getRequest.onerror = () => reject(getRequest.error);
            };
        });
    }
}
```

## Современные подходы к проверке типов

### 1. Использование TypeScript и Zod

```javascript
import { z } from 'zod';

// Определяем схему для проверки
const UserSchema = z.object({
    id: z.number().positive(),
    name: z.string().min(1).max(100),
    email: z.string().email(),
    age: z.number().min(0).max(120),
    preferences: z.object({
        theme: z.enum(['light', 'dark']),
        lang: z.string().length(2)
    })
});

// Функция проверки данных
function validateUserData(data) {
    try {
        return UserSchema.parse(data);
    } catch (error) {
        if (error instanceof z.ZodError) {
            throw new Error(`Ошибка валидации: ${error.errors.map(e => e.message).join(', ')}`);
        }
        throw error;
    }
}

// Пример использования
try {
    const validData = validateUserData({
        id: 1,
        name: 'John Doe',
        email: 'john@example.com',
        age: 30,
        preferences: { theme: 'dark', lang: 'en' }
    });
    console.log('Данные прошли валидацию:', validData);
} catch (error) {
    console.error('Ошибка валидации:', error.message);
}
```

### 2. Проверка типов в потоковых данных

```javascript
class ContentTypeValidator {
    static validateStreamContentType(stream, expectedMimeType) {
        return new ReadableStream({
            start(controller) {
                const reader = stream.getReader();
                
                reader.read().then(function processChunk({ done, value }) {
                    if (done) {
                        controller.close();
                        return;
                    }
                    
                    // Проверяем начало потока на соответствие ожидаемому типу
                    if (value && value.length >= 4) {
                        const header = Array.from(value.slice(0, 4))
                            .map(byte => byte.toString(16).padStart(2, '0'))
                            .join('');
                        
                        const detectedType = this.detectTypeByHeader(header);
                        
                        if (detectedType && !expectedMimeType.includes(detectedType)) {
                            controller.error(new Error(`Неправильный тип содержимого: ${detectedType}`));
                            return;
                        }
                    }
                    
                    controller.enqueue(value);
                    return reader.read().then(processChunk);
                });
            }
        });
    }
    
    static detectTypeByHeader(header) {
        const types = {
            'ffd8': 'image/jpeg',
            '89504e47': 'image/png',
            '47494638': 'image/gif',
            '25504446': 'application/pdf'
        };
        
        for (const [sig, type] of Object.entries(types)) {
            if (header.startsWith(sig)) {
                return type;
            }
        }
        
        return null;
    }
}
```

## Заключение

Проверка типов содержимого - критически важный аспект безопасности веб-приложений. Ключевые принципы:

1. Проверяйте типы на всех уровнях: файлы, API, хранилища
2. Используйте несколько методов проверки (MIME-типы, сигнатуры, структура)
3. Применяйте современные инструменты валидации (Zod, Yup и др.)
4. Проверяйте как на клиенте, так и на сервере
5. Регулярно обновляйте правила валидации

[[Безопасность-загрузки-файлов]]
[[Проверка-файлов]]
[[Безопасность-хранилища-файлов]]
[[Secure-Storage]]
[[Content-Security-Policy]]