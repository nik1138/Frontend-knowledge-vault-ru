---
aliases: ["Безопасное хранение файлов", "Защита файлового хранилища"]
tags: [security, file-storage, web-security, frontend-security, storage-security]
---

# Безопасность хранилища файлов

## Введение

Безопасность хранилища файлов - важный аспект веб-безопасности, особенно в современных приложениях, где пользователи могут загружать, хранить и делиться различными типами файлов. Защита файлового хранилища включает в себя как клиентскую, так и серверную безопасность, а также защиту данных при передаче и хранении.

## Архитектура безопасного файлового хранилища

### 1. Логическая изоляция файлов

Файлы должны храниться в изолированной от публичного доступа директории:

```javascript
// Пример безопасной структуры хранения файлов
const secureFileStorage = {
    // Корневая директория для загруженных файлов (недоступна напрямую через HTTP)
    rootDir: '/var/www/uploads/secure/',
    
    // Временная директория для обработки файлов
    tempDir: '/var/www/uploads/temp/',
    
    // Директория для файлов, прошедших проверку
    validatedDir: '/var/www/uploads/validated/',
    
    // Директория для файлов, доступных для скачивания
    publicDir: '/var/www/uploads/public/'
};

function generateSecurePath(userId, fileName) {
    // Создаем уникальный путь на основе ID пользователя
    const userDir = crypto.createHash('sha256').update(userId.toString()).digest('hex').substring(0, 16);
    
    // Генерируем безопасное имя файла
    const fileExtension = fileName.split('.').pop();
    const secureFileName = crypto.randomUUID() + '.' + fileExtension;
    
    return path.join(secureFileStorage.rootDir, userDir, secureFileName);
}
```

### 2. Контроль доступа к файлам

Реализация системы контроля доступа:

```javascript
class FileAccessController {
    constructor() {
        this.accessTokens = new Map(); // Временные токены доступа
    }
    
    // Генерация временного токена доступа к файлу
    generateAccessToken(fileId, userId, permissions = ['read'], expirationMinutes = 60) {
        const token = crypto.randomUUID();
        const expiration = new Date(Date.now() + expirationMinutes * 60 * 1000);
        
        this.accessTokens.set(token, {
            fileId,
            userId,
            permissions,
            expiration
        });
        
        return token;
    }
    
    // Проверка токена доступа
    validateToken(token, requiredPermission = 'read') {
        const tokenData = this.accessTokens.get(token);
        
        if (!tokenData) {
            throw new Error('Неверный токен доступа');
        }
        
        if (tokenData.expiration < new Date()) {
            this.accessTokens.delete(token);
            throw new Error('Токен доступа истек');
        }
        
        if (!tokenData.permissions.includes(requiredPermission)) {
            throw new Error('Недостаточно прав для выполнения операции');
        }
        
        return tokenData;
    }
    
    // Получение защищенного URL файла
    getSecureFileUrl(fileId, userId) {
        const token = this.generateAccessToken(fileId, userId);
        return `/api/secure-files/${fileId}?token=${token}`;
    }
}
```

## Защита файлов на клиенте

### 1. Безопасное хранение файлов в браузере

Использование IndexedDB для безопасного хранения файлов на клиенте:

```javascript
class SecureFileStorage {
    constructor(dbName = 'SecureFileStorage', version = 1) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
    }
    
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Создаем хранилище для файлов
                if (!db.objectStoreNames.contains('files')) {
                    const store = db.createObjectStore('files', { keyPath: 'id' });
                    store.createIndex('userId', 'userId', { unique: false });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
                
                // Создаем хранилище для метаданных
                if (!db.objectStoreNames.contains('metadata')) {
                    const metaStore = db.createObjectStore('metadata', { keyPath: 'fileId' });
                    metaStore.createIndex('contentType', 'contentType', { unique: false });
                    metaStore.createIndex('size', 'size', { unique: false });
                }
            };
        });
    }
    
    async storeFile(userId, file, metadata = {}) {
        if (!this.db) {
            await this.init();
        }
        
        // Шифруем файл перед сохранением
        const encryptedFile = await this.encryptFile(file);
        
        const transaction = this.db.transaction(['files', 'metadata'], 'readwrite');
        const fileStore = transaction.objectStore('files');
        const metaStore = transaction.objectStore('metadata');
        
        const fileId = crypto.randomUUID();
        
        // Сохраняем зашифрованный файл
        const fileRecord = {
            id: fileId,
            userId: userId,
            data: encryptedFile,
            timestamp: Date.now()
        };
        
        // Сохраняем метаданные
        const metaRecord = {
            fileId: fileId,
            contentType: file.type,
            size: file.size,
            name: file.name,
            ...metadata
        };
        
        const fileRequest = fileStore.add(fileRecord);
        const metaRequest = metaStore.add(metaRecord);
        
        return Promise.all([fileRequest, metaRequest]).then(() => fileId);
    }
    
    async retrieveFile(fileId, userId) {
        if (!this.db) {
            await this.init();
        }
        
        const transaction = this.db.transaction(['files', 'metadata'], 'readonly');
        const fileStore = transaction.objectStore('files');
        const metaStore = transaction.objectStore('metadata');
        
        return new Promise((resolve, reject) => {
            const fileRequest = fileStore.get(fileId);
            const metaRequest = metaStore.get(fileId);
            
            fileRequest.onsuccess = () => {
                const fileRecord = fileRequest.result;
                
                if (!fileRecord || fileRecord.userId !== userId) {
                    reject(new Error('Файл не найден или доступ запрещен'));
                    return;
                }
                
                metaRequest.onsuccess = async () => {
                    const metaRecord = metaRequest.result;
                    
                    // Расшифровываем файл
                    const decryptedFile = await this.decryptFile(fileRecord.data);
                    
                    resolve({
                        file: decryptedFile,
                        metadata: metaRecord
                    });
                };
                
                metaRequest.onerror = () => reject(metaRequest.error);
            };
            
            fileRequest.onerror = () => reject(fileRequest.error);
        });
    }
    
    async encryptFile(file) {
        // Читаем содержимое файла
        const arrayBuffer = await file.arrayBuffer();
        
        // Генерируем случайный ключ шифрования
        const key = await crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
        
        // Генерируем случайный IV
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        // Шифруем данные
        const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            arrayBuffer
        );
        
        // Возвращаем зашифрованные данные вместе с IV
        return {
            data: new Uint8Array(encrypted),
            iv: iv,
            key: await crypto.subtle.exportKey('jwk', key)
        };
    }
    
    async decryptFile(encryptedFile) {
        // Импортируем ключ
        const key = await crypto.subtle.importKey(
            'jwk',
            encryptedFile.key,
            { name: 'AES-GCM' },
            false,
            ['decrypt']
        );
        
        // Расшифровываем данные
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: encryptedFile.iv },
            key,
            encryptedFile.data
        );
        
        // Создаем Blob из расшифрованных данных
        const blob = new Blob([decrypted], { type: 'application/octet-stream' });
        return new File([blob], 'decrypted_file');
    }
}
```

### 2. Защита файлов в localStorage/sessionStorage

```javascript
class SecureLocalStorage {
    constructor(encryptionKey) {
        this.encryptionKey = encryptionKey;
    }
    
    async setItem(key, value) {
        // Сериализуем значение
        const serializedValue = JSON.stringify(value);
        
        // Шифруем данные
        const encryptedValue = await this.encrypt(serializedValue);
        
        // Сохраняем в localStorage
        localStorage.setItem(key, encryptedValue);
    }
    
    async getItem(key) {
        // Получаем зашифрованное значение
        const encryptedValue = localStorage.getItem(key);
        
        if (!encryptedValue) {
            return null;
        }
        
        try {
            // Расшифровываем данные
            const decryptedValue = await this.decrypt(encryptedValue);
            
            // Десериализуем значение
            return JSON.parse(decryptedValue);
        } catch (error) {
            console.error('Ошибка при чтении зашифрованных данных:', error);
            return null;
        }
    }
    
    async encrypt(data) {
        // Генерируем случайный IV
        const iv = crypto.getRandomValues(new Uint8Array(16));
        
        // Получаем ключ шифрования из пароля
        const key = await this.getKeyFromPassword(this.encryptionKey);
        
        // Шифруем данные
        const encodedData = new TextEncoder().encode(data);
        const encrypted = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            encodedData
        );
        
        // Кодируем IV и зашифрованные данные в base64
        const ivBase64 = btoa(String.fromCharCode(...iv));
        const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        
        return `${ivBase64}:${encryptedBase64}`;
    }
    
    async decrypt(encryptedData) {
        // Разбираем строку на IV и зашифрованные данные
        const [ivBase64, encryptedBase64] = encryptedData.split(':');
        
        // Декодируем из base64
        const iv = new Uint8Array(atob(ivBase64).split('').map(c => c.charCodeAt(0)));
        const encrypted = new Uint8Array(atob(encryptedBase64).split('').map(c => c.charCodeAt(0)));
        
        // Получаем ключ шифрования
        const key = await this.getKeyFromPassword(this.encryptionKey);
        
        // Расшифровываем данные
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            encrypted
        );
        
        // Декодируем и возвращаем строку
        return new TextDecoder().decode(decrypted);
    }
    
    async getKeyFromPassword(password) {
        // Создаем буфер из пароля
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
        
        // Создаем хэш пароля
        const hash = await crypto.subtle.digest('SHA-256', data);
        
        // Создаем ключ шифрования
        return await crypto.subtle.importKey(
            'raw',
            hash,
            { name: 'AES-GCM' },
            false,
            ['encrypt', 'decrypt']
        );
    }
}
```

## Защита файлов при передаче

### 1. Использование HTTPS

Обязательное использование HTTPS для передачи файлов:

```javascript
// Пример безопасной загрузки файла
async function uploadSecureFile(file, endpoint) {
    // Проверяем, что используем HTTPS
    if (!endpoint.startsWith('https://')) {
        throw new Error('Файлы можно загружать только по безопасному соединению');
    }
    
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch(endpoint, {
        method: 'POST',
        body: formData,
        headers: {
            // Добавляем токен аутентификации
            'Authorization': `Bearer ${getAuthToken()}`
        }
    });
    
    if (!response.ok) {
        throw new Error(`Ошибка загрузки файла: ${response.status}`);
    }
    
    return response.json();
}
```

### 2. Проверка целостности файлов

```javascript
class FileIntegrityChecker {
    static async calculateChecksum(file) {
        const arrayBuffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    static async verifyFileIntegrity(file, expectedChecksum) {
        const actualChecksum = await this.calculateChecksum(file);
        return actualChecksum === expectedChecksum;
    }
    
    static async uploadWithIntegrityCheck(file, endpoint) {
        // Вычисляем контрольную сумму до загрузки
        const checksum = await this.calculateChecksum(file);
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('checksum', checksum); // Отправляем контрольную сумму
        
        const response = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error('Ошибка загрузки файла');
        }
        
        const result = await response.json();
        
        // Проверяем, что сервер подтвердил целостность
        if (!result.integrityVerified) {
            throw new Error('Целостность файла не подтверждена сервером');
        }
        
        return result;
    }
}
```

## Современные подходы к защите файлового хранилища

### 1. Использование Content Security Policy

Для защиты от XSS-атак при работе с файлами:

```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               script-src 'self' 'unsafe-inline' 'unsafe-eval';
               img-src 'self' data: blob: https:;
               media-src 'self' blob: https:;
               object-src 'none';
               frame-src 'none';
               base-uri 'self';
               form-action 'self';">
```

[[Content-Security-Policy]]

### 2. Проверка файлов в изолированной среде

```javascript
// Псевдокод для проверки файлов в песочнице
class SandboxFileValidator {
    static async validateInSandbox(file) {
        return new Promise((resolve, reject) => {
            // Создаем изолированную среду для проверки файла
            const worker = new Worker('file-validator-worker.js');
            
            worker.postMessage({ file: file });
            
            worker.onmessage = function(event) {
                const { isValid, issues, metadata } = event.data;
                
                if (isValid) {
                    resolve({ isValid, metadata });
                } else {
                    reject(new Error(`Файл содержит проблемы: ${issues.join(', ')}`));
                }
                
                worker.terminate();
            };
            
            worker.onerror = function(error) {
                worker.terminate();
                reject(error);
            };
            
            // Устанавливаем таймаут для проверки
            setTimeout(() => {
                worker.terminate();
                reject(new Error('Таймаут проверки файла'));
            }, 30000); // 30 секунд
        });
    }
}
```

### 3. Использование WebAssembly для безопасной обработки файлов

```javascript
// Псевдокод для обработки файлов с помощью WebAssembly
class WASMFileProcessor {
    static async initialize() {
        if (!this.wasmModule) {
            this.wasmModule = await WebAssembly.instantiateStreaming(
                fetch('/wasm/file-processor.wasm')
            );
        }
        return this.wasmModule;
    }
    
    static async processFileSafely(file) {
        const wasm = await this.initialize();
        const arrayBuffer = await file.arrayBuffer();
        
        // Выделяем память в WASM-модуле
        const ptr = wasm.instance.exports.allocate(arrayBuffer.byteLength);
        const memory = new Uint8Array(wasm.instance.exports.memory.buffer);
        
        // Копируем данные файла в WASM-память
        memory.set(new Uint8Array(arrayBuffer), ptr);
        
        // Вызываем безопасную обработку файла
        const resultPtr = wasm.instance.exports.process_file(ptr, arrayBuffer.byteLength);
        const resultLength = wasm.instance.exports.get_result_length();
        
        // Читаем результат
        const resultArray = memory.slice(resultPtr, resultPtr + resultLength);
        const resultString = new TextDecoder().decode(resultArray);
        
        // Освобождаем память
        wasm.instance.exports.deallocate(ptr);
        wasm.instance.exports.deallocate(resultPtr);
        
        return JSON.parse(resultString);
    }
}
```

## Заключение

Безопасность хранилища файлов требует комплексного подхода, включающего:

1. Физическую изоляцию файлов от публичного доступа
2. Контроль доступа к файлам
3. Шифрование данных при хранении и передаче
4. Проверку целостности файлов
5. Использование безопасных протоколов передачи
6. Регулярные проверки и обновления систем безопасности

[[Безопасность-загрузки-файлов]]
[[Проверка-файлов]]
[[Проверка-типов-содержимого]]
[[Secure-Storage]]
[[Шифрование-на-клиенте]]