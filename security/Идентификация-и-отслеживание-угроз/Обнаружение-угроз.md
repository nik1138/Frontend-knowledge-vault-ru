---
aliases: [Обнаружение угроз, Threat Detection, Threat Monitoring]
tags: [security, threat-detection, monitoring, security-analytics]
---

# Обнаружение угроз (Threat Detection)

## Обзор

Обнаружение угроз - это процесс идентификации, анализа и реагирования на потенциальные или активные атаки на веб-приложения. В контексте фронтенд-безопасности, это включает в себя мониторинг активности пользователей, анализ подозрительного поведения и своевременное реагирование на потенциальные угрозы.

## Определение и значение

Обнаружение угроз - это критический компонент безопасности, который позволяет:

- Выявлять атаки в реальном времени
- Анализировать поведение пользователей и систем
- Предотвращать компрометацию данных
- Обеспечивать непрерывную защиту приложений

Для фронтенд-приложений обнаружение угроз включает:

- Мониторинг пользовательской активности
- Анализ сетевого трафика
- Обнаружение аномалий в поведении
- Выявление подозрительных паттернов

## Методы обнаружения угроз

### 1. Signature-based Detection (Обнаружение по сигнатурам)

Сравнение активности с известными паттернами атак:

```javascript
// Пример: Обнаружение известных паттернов атак
const signaturePatterns = {
  xss: [
    /<script/i,
    /javascript:/i,
    /on\w+\s*=/i,
    /vbscript:/i
  ],
  sqlInjection: [
    /UNION.*SELECT/i,
    /'.*'/i,
    /OR\s+1\s*=\s*1/i,
    /DROP\s+TABLE/i
  ],
  pathTraversal: [
    /\.\.\/\.\./,
    /\.\.\\\.\\/
  ]
};

function detectThreats(input) {
  const threats = [];
  
  for (const [type, patterns] of Object.entries(signaturePatterns)) {
    for (const pattern of patterns) {
      if (pattern.test(input)) {
        threats.push({
          type,
          pattern: pattern.toString(),
          input: input.substring(0, 100)
        });
      }
    }
  }
  
  return threats;
}
```

### 2. Anomaly-based Detection (Обнаружение аномалий)

Выявление необычного поведения, которое отличается от нормы:

```javascript
// Пример: Обнаружение аномального поведения
class AnomalyDetector {
  constructor() {
    this.normalPatterns = {
      requestsPerMinute: 10,
      sessionDuration: 30 * 60, // 30 минут
      pageViewsPerSession: 15
    };
    
    this.thresholds = {
      requestsPerMinute: 50, // 5x от нормы
      rapidPageChanges: 100, // быстрые переходы
      unusualTime: 3 // необычное время активности
    };
  }
  
  detectAnomalies(userActivity) {
    const anomalies = [];
    
    if (userActivity.requestsPerMinute > this.thresholds.requestsPerMinute) {
      anomalies.push({
        type: 'high-request-rate',
        value: userActivity.requestsPerMinute,
        threshold: this.thresholds.requestsPerMinute
      });
    }
    
    if (userActivity.rapidPageChanges > this.thresholds.rapidPageChanges) {
      anomalies.push({
        type: 'rapid-page-changes',
        value: userActivity.rapidPageChanges,
        threshold: this.thresholds.rapidPageChanges
      });
    }
    
    return anomalies;
  }
}
```

### 3. Behavioral Analysis (Поведенческий анализ)

Анализ поведения пользователей для выявления отклонений:

```javascript
// Пример: Поведенческий анализ
class BehavioralAnalyzer {
  constructor() {
    this.userProfiles = new Map();
  }
  
  updateProfile(userId, activity) {
    if (!this.userProfiles.has(userId)) {
      this.userProfiles.set(userId, {
        normalBehavior: {
          pages: [],
          times: [],
          interactionPatterns: []
        },
        currentSession: {
          pages: [],
          times: [],
          interactions: []
        }
      });
    }
    
    const profile = this.userProfiles.get(userId);
    profile.currentSession.pages.push(activity.page);
    profile.currentSession.times.push(activity.time);
    profile.currentSession.interactions.push(activity.interaction);
  }
  
  detectBehavioralAnomalies(userId) {
    const profile = this.userProfiles.get(userId);
    if (!profile) return [];
    
    // Сравнение текущего поведения с нормальным
    const anomalies = [];
    
    // Проверка необычных страниц
    const unusualPages = profile.currentSession.pages.filter(
      page => !profile.normalBehavior.pages.includes(page)
    );
    
    if (unusualPages.length > 3) { // больше 3 необычных страниц
      anomalies.push({
        type: 'unusual-navigation',
        pages: unusualPages
      });
    }
    
    return anomalies;
  }
}
```

## Техники обнаружения угроз на фронтенде

### 1. Client-side Logging

Сбор информации о событиях на клиенте:

```javascript
// Пример: Безопасное логирование событий
class SecureLogger {
  constructor() {
    this.events = [];
    this.maxEvents = 1000;
    this.threatIndicators = [
      'console.open',
      'debugger.present',
      'devtools.opened',
      'multiple.errors',
      'suspicious.input'
    ];
  }
  
  logEvent(eventType, data) {
    // Очистка чувствительных данных перед логированием
    const sanitizedData = this.sanitizeData(data);
    
    const event = {
      timestamp: new Date(),
      type: eventType,
      data: sanitizedData,
      sessionId: this.getSessionId()
    };
    
    this.events.push(event);
    
    // Ограничение количества событий
    if (this.events.length > this.maxEvents) {
      this.events.shift();
    }
    
    // Проверка на наличие индикаторов угроз
    this.checkForThreats(event);
  }
  
  sanitizeData(data) {
    // Удаление потенциально чувствительных данных
    if (typeof data === 'object') {
      const sanitized = { ...data };
      delete sanitized.password;
      delete sanitized.token;
      delete sanitized.creditCard;
      return sanitized;
    }
    return data;
  }
  
  checkForThreats(event) {
    // Проверка на подозрительные паттерны
    if (event.type === 'error' && event.data.message.includes('eval')) {
      this.reportThreat('potential-code-injection', event);
    }
  }
  
  reportThreat(type, event) {
    console.warn('Обнаружена потенциальная угроза:', type, event);
    // Отправка в систему мониторинга
    this.sendToSecuritySystem({
      threatType: type,
      event,
      timestamp: new Date()
    });
  }
}
```

### 2. Input Monitoring

Мониторинг пользовательского ввода на наличие подозрительных паттернов:

```javascript
// Пример: Мониторинг ввода для обнаружения угроз
class InputMonitor {
  constructor() {
    this.suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+\s*=\s*["'][^"']*["']/i,
      /eval\s*\(/i,
      /setTimeout\s*\([^"]+/i
    ];
    
    this.monitoringElements = [];
  }
  
  startMonitoring(element) {
    element.addEventListener('input', (event) => {
      this.analyzeInput(event.target.value, event);
    });
    
    element.addEventListener('paste', (event) => {
      setTimeout(() => {
        this.analyzeInput(event.target.value, event);
      }, 0);
    });
    
    this.monitoringElements.push(element);
  }
  
  analyzeInput(value, event) {
    for (const pattern of this.suspiciousPatterns) {
      if (pattern.test(value)) {
        this.reportSuspiciousInput({
          pattern: pattern.toString(),
          value: value.substring(0, 100),
          element: event.target.tagName,
          timestamp: new Date()
        });
        return;
      }
    }
  }
  
  reportSuspiciousInput(threat) {
    console.warn('Обнаружен подозрительный ввод:', threat);
    // Здесь может быть отправка в систему безопасности
  }
}
```

### 3. Network Traffic Analysis

Анализ сетевого трафика на клиенте:

```javascript
// Пример: Мониторинг сетевых запросов
class NetworkMonitor {
  constructor() {
    this.originalFetch = window.fetch;
    this.originalXMLHttpRequest = window.XMLHttpRequest;
    this.suspiciousDomains = new Set();
    this.suspiciousEndpoints = new Set();
  }
  
  startMonitoring() {
    // Переопределение fetch для мониторинга
    window.fetch = async (...args) => {
      const [resource, options = {}] = args;
      this.analyzeRequest(resource, options);
      
      try {
        const response = await this.originalFetch(...args);
        this.analyzeResponse(response, resource);
        return response;
      } catch (error) {
        this.reportNetworkError(error, resource);
        throw error;
      }
    };
    
    // Переопределение XMLHttpRequest для мониторинга
    const self = this;
    const OriginalXHR = this.originalXMLHttpRequest;
    
    window.XMLHttpRequest = function() {
      const xhr = new OriginalXHR();
      const originalOpen = xhr.open;
      const originalSend = xhr.send;
      
      xhr.open = function(method, url) {
        self.analyzeRequest(url, { method });
        return originalOpen.apply(this, arguments);
      };
      
      xhr.send = function(body) {
        return originalSend.apply(this, arguments);
      };
      
      return xhr;
    };
  }
  
  analyzeRequest(url, options) {
    try {
      const parsedUrl = new URL(url);
      
      // Проверка на подозрительные домены
      if (this.isSuspiciousDomain(parsedUrl.hostname)) {
        this.reportThreat({
          type: 'suspicious-domain-request',
          url: parsedUrl.href,
          timestamp: new Date()
        });
      }
      
      // Проверка на подозрительные эндпоинты
      if (this.isSuspiciousEndpoint(parsedUrl.pathname)) {
        this.reportThreat({
          type: 'suspicious-endpoint-access',
          url: parsedUrl.href,
          timestamp: new Date()
        });
      }
    } catch (e) {
      // URL может быть относительным
    }
  }
  
  isSuspiciousDomain(domain) {
    // Логика определения подозрительных доменов
    return this.suspiciousDomains.has(domain);
  }
  
  isSuspiciousEndpoint(path) {
    // Логика определения подозрительных эндпоинтов
    return this.suspiciousEndpoints.has(path);
  }
  
  reportThreat(threat) {
    console.warn('Обнаружена сетевая угроза:', threat);
    // Отправка в систему безопасности
  }
}
```

## Инструменты обнаружения угроз

### 1. Application Security Monitoring (ASM)

Специализированные инструменты для мониторинга безопасности:

- Contrast Security
- Sqreen
- Imperva
- Akamai

### 2. User and Entity Behavior Analytics (UEBA)

Инструменты для анализа поведения пользователей:

- Exabeam
- Splunk User Behavior Analytics
- IBM QRadar UEBA

### 3. Client-Side Security Tools

Инструменты для обнаружения угроз на клиенте:

- Content Security Policy (CSP)
- Subresource Integrity (SRI)
- Client-side WAF
- Runtime Application Self-Protection (RASP)

## Практическая реализация

### 1. Создание системы обнаружения угроз

```javascript
// Пример: Комплексная система обнаружения угроз
class ThreatDetectionSystem {
  constructor() {
    this.detectors = {
      signature: new SignatureDetector(),
      anomaly: new AnomalyDetector(),
      behavioral: new BehavioralAnalyzer(),
      network: new NetworkMonitor(),
      input: new InputMonitor()
    };
    
    this.threats = [];
    this.callbacks = [];
  }
  
  start() {
    // Запуск всех детекторов
    this.detectors.network.startMonitoring();
    
    // Установка глобальных обработчиков ошибок
    window.addEventListener('error', (event) => {
      this.handleGlobalError(event);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.handleUnhandledRejection(event);
    });
  }
  
  handleGlobalError(event) {
    const threat = {
      type: 'unhandled-error',
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error?.stack,
      timestamp: new Date()
    };
    
    this.reportThreat(threat);
  }
  
  handleUnhandledRejection(event) {
    const threat = {
      type: 'unhandled-promise-rejection',
      reason: event.reason,
      timestamp: new Date()
    };
    
    this.reportThreat(threat);
  }
  
  reportThreat(threat) {
    this.threats.push(threat);
    
    // Вызов всех зарегистрированных callback'ов
    this.callbacks.forEach(callback => callback(threat));
    
    // Ограничение истории угроз
    if (this.threats.length > 1000) {
      this.threats.shift();
    }
  }
  
  onThreat(callback) {
    this.callbacks.push(callback);
  }
  
  getThreats() {
    return this.threats;
  }
  
  getThreatSummary() {
    const summary = {};
    for (const threat of this.threats) {
      summary[threat.type] = (summary[threat.type] || 0) + 1;
    }
    return summary;
  }
}

// Использование системы
const tds = new ThreatDetectionSystem();
tds.start();

// Регистрация callback для обработки угроз
tds.onThreat((threat) => {
  console.warn('Обнаружена угроза:', threat);
  // Отправка в систему безопасности
});
```

### 2. Интеграция с системами безопасности

```javascript
// Пример: Интеграция с внешней системой безопасности
class SecurityIntegration {
  constructor(apiEndpoint) {
    this.apiEndpoint = apiEndpoint;
  }
  
  async sendThreatReport(threat) {
    try {
      const response = await fetch(`${this.apiEndpoint}/threats`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.getSecurityToken()}`
        },
        body: JSON.stringify({
          ...threat,
          userAgent: navigator.userAgent,
          referrer: document.referrer,
          url: window.location.href
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Ошибка отправки отчета об угрозе:', error);
    }
  }
  
  getSecurityToken() {
    // Логика получения токена безопасности
    return localStorage.getItem('security-token');
  }
}
```

## Мониторинг и реагирование

### 1. Уровни угроз

Классификация угроз по уровню критичности:

```javascript
// Пример: Классификация угроз
const threatLevels = {
  LOW: {
    level: 1,
    description: 'Низкий риск, мониторинг',
    actions: ['log', 'monitor']
  },
  MEDIUM: {
    level: 2,
    description: 'Средний риск, расследование',
    actions: ['log', 'alert', 'investigate']
  },
  HIGH: {
    level: 3,
    description: 'Высокий риск, немедленное реагирование',
    actions: ['log', 'alert', 'block', 'notify']
  },
  CRITICAL: {
    level: 4,
    description: 'Критический риск, срочное реагирование',
    actions: ['log', 'alert', 'block', 'notify', 'escalate']
  }
};

function classifyThreat(threat) {
  // Логика классификации угрозы
  if (threat.type.includes('xss') || threat.type.includes('csrf')) {
    return threatLevels.HIGH;
  }
  
  if (threat.type.includes('brute-force')) {
    return threatLevels.MEDIUM;
  }
  
  return threatLevels.LOW;
}
```

### 2. Автоматическое реагирование

Системы автоматического реагирования на угрозы:

```javascript
// Пример: Система автоматического реагирования
class ThreatResponseSystem {
  constructor() {
    this.responseActions = {
      'xss-attempt': this.blockUserInput,
      'csrf-detected': this.invalidateSession,
      'brute-force': this.rateLimitUser,
      'suspicious-dom-access': this.sanitizeEnvironment
    };
  }
  
  async respondToThreat(threat) {
    const action = this.responseActions[threat.type];
    if (action) {
      try {
        await action.call(this, threat);
        console.log('Реагирование на угрозу выполнено:', threat.type);
      } catch (error) {
        console.error('Ошибка при реагировании на угрозу:', error);
      }
    } else {
      console.warn('Нет действия для угрозы:', threat.type);
    }
  }
  
  async blockUserInput(threat) {
    // Блокировка пользовательского ввода
    document.querySelectorAll('input, textarea, select').forEach(element => {
      element.disabled = true;
    });
  }
  
  async invalidateSession(threat) {
    // Инвалидация сессии
    localStorage.removeItem('authToken');
    sessionStorage.clear();
    window.location.href = '/login';
  }
  
  async rateLimitUser(threat) {
    // Ограничение скорости для пользователя
    localStorage.setItem('rateLimit', Date.now() + 300000); // 5 минут
  }
  
  async sanitizeEnvironment(threat) {
    // Санитизация окружения
    delete window.eval;
    delete window.Function;
  }
}
```

## Заключение

Обнаружение угроз является критически важным компонентом безопасности веб-приложений. Эффективная система обнаружения угроз должна:

- Использовать несколько методов обнаружения
- Быть интегрирована в архитектуру приложения
- Обеспечивать быстрое реагирование на угрозы
- Поддерживать актуальность данных об угрозах

Для фронтенд-приложений особенно важно реализовать клиентские механизмы обнаружения угроз, которые могут выявлять атаки в реальном времени и предотвращать компрометацию данных пользователей.

> [!tip] Совет
> Регулярно обновляйте сигнатуры угроз и алгоритмы обнаружения, чтобы оставаться актуальными с новыми методами атак.

> [!warning] Важно
> Система обнаружения угроз должна быть сбалансирована: слишком много ложных срабатываний может привести к игнорированию реальных угроз.

> [!note] Примечание
> Обнаружение угроз должно быть частью комплексного подхода к безопасности, включая предотвращение, обнаружение и реагирование.