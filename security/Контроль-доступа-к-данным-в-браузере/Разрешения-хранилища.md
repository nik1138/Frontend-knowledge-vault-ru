---
aliases: [Storage Permissions, Разрешения хранилища, Доступ к хранилищу]
tags: [security, storage, permissions, frontend-security, browser-storage]
---

# Разрешения-хранилища

## Введение

Разрешения хранилища - это механизм контроля доступа к различным типам хранилищ в браузере, включая localStorage, sessionStorage, IndexedDB, файловую систему и другие. Эти разрешения защищают конфиденциальные данные пользователя от несанкционированного доступа и использования.

## Типы хранилищ и соответствующие разрешения

### LocalStorage и SessionStorage

Эти API не требуют явных разрешений, но подвержены ограничениям безопасности:

```javascript
// Проверка доступности localStorage
function isLocalStorageAvailable() {
  try {
    const testKey = '__storage_test__';
    localStorage.setItem(testKey, testKey);
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    return false;
  }
}

// Безопасная работа с localStorage
class SecureLocalStorage {
  constructor() {
    this.isAvailable = isLocalStorageAvailable();
  }
  
  setItem(key, value) {
    if (!this.isAvailable) {
      throw new Error('LocalStorage недоступен');
    }
    
    try {
      // Сериализуем значение в JSON для безопасности
      const serializedValue = JSON.stringify(value);
      localStorage.setItem(key, serializedValue);
    } catch (error) {
      if (error.name === 'QuotaExceededError') {
        console.error('Превышена квота хранилища');
        // Обработка ситуации с превышением квоты
        this.handleQuotaExceeded();
      } else {
        console.error('Ошибка при сохранении в localStorage:', error);
      }
    }
  }
  
  getItem(key) {
    if (!this.isAvailable) {
      return null;
    }
    
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('Ошибка при чтении из localStorage:', error);
      return null;
    }
  }
  
  handleQuotaExceeded() {
    // Очистка старых данных или уведомление пользователя
    this.clearOldData();
  }
  
  clearOldData() {
    // Реализация очистки старых или ненужных данных
    const now = Date.now();
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('__temp__')) {
        const data = JSON.parse(localStorage.getItem(key));
        if (data && data.expiry && data.expiry < now) {
          localStorage.removeItem(key);
        }
      }
    }
  }
}

// Использование
const secureStorage = new SecureLocalStorage();
```

### IndexedDB

IndexedDB требует больше разрешений и имеет более сложную систему безопасности:

```javascript
// Безопасная работа с IndexedDB
class SecureIndexedDB {
  constructor(dbName, version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = (event) => {
        console.error('Ошибка при открытии IndexedDB:', event.target.error);
        reject(event.target.error);
      };

      request.onsuccess = (event) => {
        this.db = event.target.result;
        console.log('IndexedDB успешно открыта');
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Создаем безопасные хранилища
        if (!db.objectStoreNames.contains('secure_data')) {
          const store = db.createObjectStore('secure_data', { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('user_id', 'user_id', { unique: false });
        }
      };
    });
  }

  async addItem(storeName, data) {
    if (!this.db) {
      throw new Error('IndexedDB не инициализирована');
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);

      // Добавляем метаданные безопасности
      const secureData = {
        ...data,
        timestamp: Date.now(),
        id: this.generateId()
      };

      const request = store.add(secureData);

      request.onsuccess = () => resolve(request.result);
      request.onerror = (event) => reject(event.target.error);
    });
  }

  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  async getItem(storeName, key) {
    if (!this.db) {
      throw new Error('IndexedDB не инициализирована');
    }

    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.get(key);

      request.onsuccess = () => resolve(request.result);
      request.onerror = (event) => reject(event.target.error);
    });
  }
}

// Использование
const secureDB = new SecureIndexedDB('MySecureAppDB');
await secureDB.init();
```

### Storage Access API

Современный API для управления доступом к хранилищу в кросс-доменных контекстах:

```javascript
// Использование Storage Access API
class StorageAccessManager {
  constructor() {
    this.hasStorageAccess = false;
  }

  async checkStorageAccess() {
    if (typeof document.hasStorageAccess === 'function') {
      this.hasStorageAccess = await document.hasStorageAccess();
      return this.hasStorageAccess;
    }
    return true; // Для браузеров без поддержки Storage Access API
  }

  async requestStorageAccess() {
    if (typeof document.requestStorageAccess === 'function') {
      try {
        await document.requestStorageAccess();
        this.hasStorageAccess = true;
        console.log('Доступ к хранилищу предоставлен');
        return true;
      } catch (error) {
        console.error('Не удалось получить доступ к хранилищу:', error);
        this.hasStorageAccess = false;
        return false;
      }
    }
    return true;
  }

  async executeWithStorageAccess(callback) {
    const hasAccess = await this.checkStorageAccess();
    
    if (!hasAccess) {
      const granted = await this.requestStorageAccess();
      if (!granted) {
        console.error('Не удалось получить доступ к хранилищу');
        return;
      }
    }
    
    return callback();
  }
}

// Пример использования
const storageManager = new StorageAccessManager();

// Безопасное выполнение операций с хранилищем
await storageManager.executeWithStorageAccess(() => {
  localStorage.setItem('key', 'value');
  // Другие операции с хранилищем
});
```

## Безопасность хранилища

### Шифрование данных в хранилище

```javascript
// Класс для шифрования данных перед сохранением в хранилище
class EncryptedStorage {
  constructor(password) {
    this.password = password;
    this.algorithm = 'AES-GCM';
  }

  async encrypt(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const keyMaterial = await this.importKey(this.password);
    
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: this.algorithm, iv },
      keyMaterial,
      dataBuffer
    );

    // Возвращаем зашифрованные данные с IV
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...combined));
  }

  async decrypt(encryptedData) {
    const dataBuffer = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
    const iv = dataBuffer.slice(0, 12);
    const encrypted = dataBuffer.slice(12);
    
    const keyMaterial = await this.importKey(this.password);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: this.algorithm, iv },
      keyMaterial,
      encrypted
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  }

  async importKey(password) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(password),
      { name: 'PBKDF2' },
      false,
      ['deriveKey']
    );

    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: new Uint8Array(16), // В реальном приложении используйте стабильный солт
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: this.algorithm, length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  async setItem(key, value) {
    const encryptedValue = await this.encrypt(value);
    localStorage.setItem(key, encryptedValue);
  }

  async getItem(key) {
    const encryptedValue = localStorage.getItem(key);
    if (!encryptedValue) return null;
    
    return await this.decrypt(encryptedValue);
  }
}

// Использование
const encryptedStorage = new EncryptedStorage('my-secret-password');
await encryptedStorage.setItem('sensitive-data', { token: 'secret-token', user: 'john' });
const data = await encryptedStorage.getItem('sensitive-data');
```

### Ограничения и квоты хранилища

```javascript
// Класс для мониторинга и управления квотами хранилища
class StorageQuotaManager {
  constructor() {
    this.quota = null;
    this.usage = null;
  }

  async getStorageEstimate() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      this.quota = estimate.quota;
      this.usage = estimate.usage;
      
      console.log(`Использовано: ${this.usage} байт из ${this.quota} байт`);
      console.log(`Процент использования: ${((this.usage / this.quota) * 100).toFixed(2)}%`);
      
      return estimate;
    }
    
    // Резервная реализация для браузеров без поддержки Storage API
    return this.estimateLocalStorageUsage();
  }

  estimateLocalStorageUsage() {
    let total = 0;
    for (let key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        total += localStorage[key].length + key.length;
      }
    }
    
    // Приблизительная оценка квоты (обычно 5-10 МБ)
    const estimatedQuota = 5 * 1024 * 1024; // 5 МБ
    
    return {
      usage: total,
      quota: estimatedQuota,
      percentage: (total / estimatedQuota) * 100
    };
  }

  async isStorageAvailable(estimatedSize) {
    const estimate = await this.getStorageEstimate();
    return estimate.quota - estimate.usage > estimatedSize;
  }

  async cleanupStorage(threshold = 0.8) {
    const estimate = await this.getStorageEstimate();
    const usagePercentage = estimate.usage / estimate.quota;
    
    if (usagePercentage > threshold) {
      // Очистка устаревших данных
      this.clearExpiredData();
    }
  }

  clearExpiredData() {
    const now = Date.now();
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const key = localStorage.key(i);
      if (key && key.includes('expiry')) {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          if (data && data.expiry && data.expiry < now) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Пропускаем непарсинговые данные
        }
      }
    }
  }
}

// Использование
const quotaManager = new StorageQuotaManager();
await quotaManager.getStorageEstimate();
await quotaManager.cleanupStorage();
```

## Лучшие практики

### 1. Минимизация данных в хранилище

```javascript
// Правила минимизации данных
const StorageBestPractices = {
  // Используем только необходимые данные
  minimizeData: (data) => {
    const minimized = {};
    // Удаляем ненужные поля
    for (const [key, value] of Object.entries(data)) {
      if (StorageBestPractices.isRequired(key)) {
        minimized[key] = value;
      }
    }
    return minimized;
  },

  // Определяем, какие данные необходимы
  isRequired: (key) => {
    const requiredKeys = [
      'user_id', 'session_token', 'preferences'
    ];
    return requiredKeys.includes(key);
  },

  // Очистка данных перед сохранением
  sanitizeData: (data) => {
    // Удаляем потенциально опасные поля
    const sanitized = { ...data };
    delete sanitized.password;
    delete sanitized.credit_card;
    delete sanitized.ssn;
    return sanitized;
  }
};
```

### 2. Защита от XSS-атак

```javascript
// Класс для защиты данных от XSS
class XSSProtection {
  static sanitize(value) {
    if (typeof value === 'string') {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\//g, '&#x2F;');
    }
    return value;
  }

  static storeSafely(key, value) {
    const sanitizedValue = this.sanitize(JSON.stringify(value));
    localStorage.setItem(key, sanitizedValue);
  }

  static retrieveSafely(key) {
    const item = localStorage.getItem(key);
    if (item) {
      try {
        return JSON.parse(item);
      } catch (e) {
        console.error('Ошибка при парсинге данных из хранилища:', e);
        return null;
      }
    }
    return null;
  }
}
```

## Заключение

Разрешения хранилища играют важную роль в обеспечении безопасности веб-приложений. Правильная реализация управления доступом к хранилищу помогает защитить конфиденциальные данные пользователей и предотвратить их несанкционированное использование.

> [!tip] Совет
> Всегда шифруйте чувствительные данные перед сохранением в хранилище и регулярно проверяйте квоты использования.

> [!warning] Важно
> Никогда не храните в хранилище конфиденциальные данные, такие как пароли или токены доступа, в открытом виде.

> [!note] Примечание
> Современные браузеры продолжают улучшать механизмы безопасности хранилища, включая Storage Access API и улучшенные квоты.