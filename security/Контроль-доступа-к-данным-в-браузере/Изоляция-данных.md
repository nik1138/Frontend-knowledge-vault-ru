---
aliases: [Data Isolation, Изоляция данных, Защита данных в браузере]
tags: [security, data-isolation, frontend-security, browser-security]
---

# Изоляция-данных

## Введение

Изоляция данных в браузере - это фундаментальный принцип безопасности, который обеспечивает разделение данных и ресурсов между различными источниками (origin), вкладками, процессами и приложениями. Эта изоляция предотвращает несанкционированный доступ к конфиденциальным данным и защищает пользователей от межсайтовых атак.

## Принципы изоляции данных

### Same-Origin Policy (Политика одинакового источника)

Same-Origin Policy - это основной механизм изоляции данных в веб-браузерах. Он ограничивает возможность веб-страницы взаимодействовать с ресурсами из другого источника (origin), определяемого комбинацией протокола, домена и порта.

```javascript
// Примеры источников и их изоляции:
// https://example.com:443 - один источник
// https://example.com:80 - другой источник (другой порт)
// http://example.com:80 - другой источник (другой протокол)
// https://sub.example.com:443 - другой источник (другой домен)

// Пример проверки источника
function checkSameOrigin(url1, url2) {
  const parsed1 = new URL(url1);
  const parsed2 = new URL(url2);
  
  return parsed1.protocol === parsed2.protocol &&
         parsed1.hostname === parsed2.hostname &&
         parsed1.port === parsed2.port;
}

// Использование
const isSameOrigin = checkSameOrigin('https://example.com/page1', 'https://example.com/page2');
console.log(isSameOrigin); // true
```

### Cross-Origin Resource Sharing (CORS)

CORS - это механизм, который позволяет веб-страницам запрашивать ресурсы с другого источника, при этом сохраняя контроль над доступом:

```javascript
// Пример безопасного запроса с проверкой источника
class SecureCORSRequest {
  constructor(allowedOrigins = []) {
    this.allowedOrigins = allowedOrigins;
  }

  async fetch(url, options = {}) {
    const parsedUrl = new URL(url);
    const origin = `${parsedUrl.protocol}//${parsedUrl.hostname}`;
    
    if (!this.isOriginAllowed(origin)) {
      throw new Error(`Доступ к источнику ${origin} запрещен`);
    }

    // Добавляем заголовки безопасности
    const secureOptions = {
      ...options,
      headers: {
        ...options.headers,
        'Sec-Fetch-Site': 'same-site', // или 'cross-site' в зависимости от контекста
        'Sec-Fetch-Mode': 'cors',
        'Sec-Fetch-Dest': 'empty'
      }
    };

    return await fetch(url, secureOptions);
  }

  isOriginAllowed(origin) {
    return this.allowedOrigins.includes(origin) || 
           origin === window.location.origin;
  }
}

// Использование
const corsManager = new SecureCORSRequest(['https://api.example.com']);
try {
  const response = await corsManager.fetch('https://api.example.com/data');
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error('Ошибка CORS запроса:', error);
}
```

## Механизмы изоляции данных

### 1. Изоляция контекста выполнения

```javascript
// Пример изоляции контекста с использованием iframe
class SecureIframeIsolation {
  constructor() {
    this.iframes = new Map();
  }

  createSecureIframe(src, containerId, options = {}) {
    const iframe = document.createElement('iframe');
    
    // Устанавливаем безопасные атрибуты
    iframe.src = src;
    iframe.sandbox = options.sandbox || 'allow-scripts allow-same-origin';
    iframe.security = 'restricted';
    
    // Добавляем дополнительные меры безопасности
    iframe.setAttribute('csp', "default-src 'self'; script-src 'self'");
    iframe.setAttribute('referrerpolicy', 'no-referrer');
    
    // Устанавливаем атрибуты для изоляции
    iframe.setAttribute('allow', 'encrypted-media; picture-in-picture');
    iframe.setAttribute('loading', 'lazy');
    
    const container = document.getElementById(containerId);
    if (container) {
      container.appendChild(iframe);
      this.iframes.set(containerId, iframe);
    }
    
    return iframe;
  }

  destroyIframe(containerId) {
    const iframe = this.iframes.get(containerId);
    if (iframe && iframe.parentNode) {
      iframe.parentNode.removeChild(iframe);
      this.iframes.delete(containerId);
    }
  }
}

// Использование
const iframeManager = new SecureIframeIsolation();
iframeManager.createSecureIframe('https://trusted-site.com', 'content-container');
```

### 2. Изоляция хранилища данных

```javascript
// Пример изоляции данных в хранилище
class StorageIsolationManager {
  constructor(namespace) {
    this.namespace = namespace;
    this.prefix = `isolated_${namespace}_`;
  }

  setItem(key, value) {
    const prefixedKey = this.prefix + key;
    localStorage.setItem(prefixedKey, JSON.stringify(value));
  }

  getItem(key) {
    const prefixedKey = this.prefix + key;
    const item = localStorage.getItem(prefixedKey);
    return item ? JSON.parse(item) : null;
  }

  removeItem(key) {
    const prefixedKey = this.prefix + key;
    localStorage.removeItem(prefixedKey);
  }

  clear() {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.prefix)) {
        keysToRemove.push(key);
      }
    }
    
    keysToRemove.forEach(key => localStorage.removeItem(key));
  }

  // Метод для проверки изоляции
  isIsolatedFrom(otherNamespace) {
    const otherPrefix = `isolated_${otherNamespace}_`;
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(otherPrefix) && key.startsWith(this.prefix)) {
        // Если ключ начинается с обоих префиксов, есть потенциальная проблема
        return false;
      }
    }
    return true;
  }
}

// Использование
const appStorage = new StorageIsolationManager('myApp');
const userStorage = new StorageIsolationManager('userPreferences');

appStorage.setItem('config', { theme: 'dark', lang: 'ru' });
userStorage.setItem('settings', { notifications: true, autoSave: false });

console.log(appStorage.getItem('config')); // { theme: 'dark', lang: 'ru' }
console.log(userStorage.getItem('settings')); // { notifications: true, autoSave: false }
```

### 3. Изоляция процессов и вкладок

```javascript
// Пример изоляции данных между вкладками с использованием BroadcastChannel
class TabIsolationManager {
  constructor(channelName) {
    this.channel = new BroadcastChannel(channelName);
    this.tabId = this.generateTabId();
    this.isolatedData = new Map();
    
    this.setupMessageHandler();
  }

  generateTabId() {
    return `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  setupMessageHandler() {
    this.channel.addEventListener('message', (event) => {
      const { type, data, senderTabId } = event.data;
      
      // Игнорируем сообщения от этой же вкладки
      if (senderTabId === this.tabId) return;
      
      switch (type) {
        case 'REQUEST_DATA':
          this.handleDataRequest(data.requestId, senderTabId);
          break;
        case 'RESPONSE_DATA':
          this.handleDataResponse(data);
          break;
      }
    });
  }

  // Сохранение изолированных данных
  setLocalData(key, value) {
    this.isolatedData.set(key, value);
  }

  getLocalData(key) {
    return this.isolatedData.get(key);
  }

  // Запрос данных из другой вкладки с изоляцией
  requestDataFromTab(key, targetTabId) {
    const requestId = this.generateRequestId();
    
    return new Promise((resolve, reject) => {
      // Устанавливаем таймаут для запроса
      const timeout = setTimeout(() => {
        reject(new Error('Таймаут запроса данных'));
      }, 5000);

      // Обработчик ответа
      const responseHandler = (event) => {
        const { type, data, senderTabId, originalRequestId } = event.data;
        
        if (type === 'RESPONSE_DATA' && 
            originalRequestId === requestId && 
            senderTabId === targetTabId) {
          
          clearTimeout(timeout);
          this.channel.removeEventListener('message', responseHandler);
          resolve(data.value);
        }
      };

      this.channel.addEventListener('message', responseHandler);

      // Отправляем запрос
      this.channel.postMessage({
        type: 'REQUEST_DATA',
        data: { key, requestId },
        senderTabId: this.tabId,
        targetTabId
      });
    });
  }

  handleDataRequest(requestId, senderTabId) {
    // Здесь можно добавить проверки авторизации
    // В целях безопасности не все данные должны быть доступны другим вкладкам
    
    // Отправляем ответ
    this.channel.postMessage({
      type: 'RESPONSE_DATA',
      data: { 
        value: 'Данные защищены изоляцией', 
        requestId 
      },
      senderTabId: this.tabId,
      originalRequestId: requestId
    });
  }

  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  close() {
    this.channel.close();
  }
}

// Использование
const tabIsolation = new TabIsolationManager('my-app-channel');
tabIsolation.setLocalData('privateData', 'очень важная информация');
```

## Современные методы изоляции

### Site Isolation (Изоляция сайтов)

Site Isolation - это архитектурная особенность современных браузеров, которая изолирует содержимое разных сайтов в отдельных процессах:

```javascript
// Пример демонстрации изоляции с использованием Web Workers
class WorkerDataIsolation {
  constructor() {
    this.workers = new Map();
  }

  createIsolatedWorker(scriptUrl, name) {
    const worker = new Worker(scriptUrl);
    this.workers.set(name, worker);
    
    // Установка обработчиков сообщений для изоляции
    worker.onmessage = (event) => {
      const { type, data, source } = event.data;
      
      // Обработка сообщений с проверкой источника
      if (source === name) {
        this.handleWorkerMessage(type, data, name);
      }
    };
    
    worker.onerror = (error) => {
      console.error(`Ошибка в воркере ${name}:`, error);
    };
    
    return worker;
  }

  handleWorkerMessage(type, data, source) {
    // Обработка сообщений от изолированного воркера
    console.log(`Сообщение от ${source}:`, type, data);
  }

  terminateWorker(name) {
    const worker = this.workers.get(name);
    if (worker) {
      worker.terminate();
      this.workers.delete(name);
    }
  }
}

// Пример скрипта для воркера (должен быть в отдельном файле)
const workerScript = `
  // Это содержимое отдельного файла воркера
  self.onmessage = function(event) {
    const { type, data, source } = event.data;
    
    // Обработка данных в изолированном контексте
    const result = processIsolatedData(data);
    
    // Отправка результата обратно
    self.postMessage({
      type: 'RESULT',
      data: result,
      source: source
    });
  };
  
  function processIsolatedData(input) {
    // Обработка данных в изолированном контексте
    return {
      processed: true,
      data: input,
      timestamp: Date.now()
    };
  }
`;

// Для демонстрации сохраняем скрипт в файл
// В реальном приложении этот файл должен существовать отдельно
```

### Post-Spectre mitigations

После уязвимости Spectre браузеры усилили изоляцию данных:

```javascript
// Пример реализации защиты от утечки данных через сайд-каналы
class SpectreProtection {
  constructor() {
    this.timingSafeOperations = true;
  }

  // Тайминг-безопасное сравнение строк
  timingSafeEqual(a, b) {
    if (a.length !== b.length) {
      // Выполняем операции одинаковой сложности в любом случае
      this.constantTimeOperation(a.length + b.length);
      return false;
    }

    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }

    this.constantTimeOperation(result);
    return result === 0;
  }

  // Операция с постоянным временем выполнения
  constantTimeOperation(input) {
    // Выполняем фиксированное количество операций
    // для предотвращения утечки информации через тайминг
    let accumulator = 0;
    for (let i = 0; i < 1000; i++) {
      accumulator += (input ^ i) % 256;
    }
    return accumulator;
  }

  // Защита от утечки данных через кэш
  secureDataAccess(key, dataMap) {
    // Используем постоянное время доступа к данным
    const allKeys = Array.from(dataMap.keys());
    let result = null;

    // Всегда проходим по всем ключам для постоянного времени выполнения
    for (const mapKey of allKeys) {
      if (this.timingSafeEqual(mapKey, key)) {
        result = dataMap.get(mapKey);
      }
    }

    return result;
  }
}

// Использование
const spectreProtection = new SpectreProtection();
const sensitiveData = new Map();
sensitiveData.set('secret-key', 'очень важная информация');

const retrievedData = spectreProtection.secureDataAccess('secret-key', sensitiveData);
```

## Лучшие практики изоляции данных

### 1. Использование Content Security Policy

```javascript
// Пример CSP для усиления изоляции
const CSP_HEADERS = {
  'Content-Security-Policy': [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "connect-src 'self'",
    "frame-ancestors 'none'", // Предотвращает встраивание в iframe
    "base-uri 'self'"
  ].join('; ')
};
```

### 2. Изоляция критических данных

```javascript
// Пример изоляции критических данных с помощью Web Crypto API
class CriticalDataIsolation {
  constructor() {
    this.crypto = window.crypto;
  }

  async isolateCriticalData(data, isolationKey) {
    // Генерация ключа изоляции
    const isolationCryptoKey = await this.importKey(isolationKey);
    
    // Шифрование данных с использованием ключа изоляции
    const encryptedData = await this.encryptData(data, isolationCryptoKey);
    
    return encryptedData;
  }

  async importKey(keyMaterial) {
    const encoder = new TextEncoder();
    const keyBuffer = encoder.encode(keyMaterial);
    
    return await this.crypto.subtle.importKey(
      'raw',
      keyBuffer,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );
  }

  async encryptData(data, key) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const iv = this.crypto.getRandomValues(new Uint8Array(12));
    
    const encryptedBuffer = await this.crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      dataBuffer
    );

    // Возвращаем зашифрованные данные с IV для последующего расшифрования
    const combinedBuffer = new Uint8Array(iv.length + encryptedBuffer.byteLength);
    combinedBuffer.set(iv, 0);
    combinedBuffer.set(new Uint8Array(encryptedBuffer), iv.length);

    return btoa(String.fromCharCode(...combinedBuffer));
  }

  async decryptData(encryptedData, key) {
    const dataBuffer = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
    const iv = dataBuffer.slice(0, 12);
    const encrypted = dataBuffer.slice(12);
    
    const decryptedBuffer = await this.crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encrypted
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedBuffer));
  }
}

// Использование
const criticalDataIsolation = new CriticalDataIsolation();
const isolatedData = await criticalDataIsolation.isolateCriticalData(
  { token: 'secret-token', userId: 12345 },
  'user-specific-isolation-key'
);
```

## Заключение

Изоляция данных в браузере является критически важным аспектом веб-безопасности. Понимание и правильная реализация механизмов изоляции помогает защитить конфиденциальные данные пользователей и предотвратить межсайтовые атаки.

> [!tip] Совет
> Используйте комбинацию нескольких методов изоляции для максимальной защиты данных.

> [!warning] Важно
> Нарушение принципов изоляции данных может привести к серьезным уязвимостям и утечке конфиденциальной информации.

> [!note] Примечание
> Современные браузеры продолжают развивать механизмы изоляции данных, включая Site Isolation и другие методы защиты от сайд-канальных атак.