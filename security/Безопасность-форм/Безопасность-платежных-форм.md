---
aliases: ["Безопасность платежных форм", "Защита платежных данных", "PCI DSS", "Платежная безопасность"]
tags: [security, payments, pci-dss, web-security, data-protection]
---

# Безопасность платежных форм

## Введение в безопасность платежных форм

Безопасность платежных форм является критически важным аспектом веб-разработки, особенно при работе с финансовыми транзакциями. Платежные формы обрабатывают чувствительные данные, такие как номера кредитных карт, CVV-коды и персональную информацию пользователей. Неправильная реализация может привести к утечке данных, финансовым потерям и нарушению законодательства.

> [!warning] Важно
> Любое приложение, обрабатывающее платежи, должно строго следовать международным стандартам безопасности, особенно требованиям PCI DSS (Payment Card Industry Data Security Standard).

## Угрозы безопасности в платежных формах

Платежные формы подвержены различным угрозам, включая:

- **Кража данных** через XSS-атаки или SQL-инъекции
- **Фишинг** - поддельные формы, имитирующие легитимные
- **Манипуляции с данными** - изменение суммы транзакции
- **Перехват данных** при передаче по незащищенным каналам
- **Атаки типа "man-in-the-middle"**

> [!tip] Совет
> Постоянно проводите аудит безопасности и используйте автоматизированные инструменты сканирования уязвимостей.

## PCI DSS требования

PCI DSS (Payment Card Industry Data Security Standard) - это набор требований безопасности для организаций, обрабатывающих, хранящих или передающих данные платежных карт.

### Основные требования:

- Построение и поддержание безопасной сети
- Защита карточных данных
- Управление доступом к системе
- Мониторинг и тестирование сетей
- Поддержание политики информационной безопасности

Для получения полной информации о требованиях см. [[PCI DSS стандарт]].

## Защита карточных данных

Карточные данные включают:

- Номер кредитной карты
- Имя держателя карты
- Дату окончания действия
- CVV-код (Card Verification Value)

### Рекомендации по защите:

- **Не храните** CVV-коды и полные номера карт
- Используйте **токенизацию** для замены чувствительных данных
- Применяйте **шифрование** при передаче и хранении данных
- Ограничьте доступ к данным на основе принципа минимальных привилегий

## Безопасность ввода платежной информации

### Валидация на клиентской стороне

Хотя валидация на клиентской стороне улучшает UX, она **не должна** быть единственным уровнем защиты:

```html
<form id="payment-form">
  <input type="text" id="card-number" placeholder="Номер карты" maxlength="19" required>
  <input type="text" id="expiry-date" placeholder="MM/YY" maxlength="5" required>
  <input type="text" id="cvv" placeholder="CVV" maxlength="4" required>
  <input type="text" id="cardholder-name" placeholder="Имя держателя" required>
</form>
```

### Валидация на серверной стороне

Все проверки должны дублироваться на сервере:

```javascript
function validateCardNumber(cardNumber) {
  // Проверка на соответствие алгоритму Луна
  const sanitized = cardNumber.replace(/\D/g, '');
  if (sanitized.length < 13 || sanitized.length > 19) return false;
  
  let sum = 0;
  let isEven = false;
  for (let i = sanitized.length - 1; i >= 0; i--) {
    let digit = parseInt(sanitized[i]);
    if (isEven) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    sum += digit;
    isEven = !isEven;
  }
  return sum % 10 === 0;
}
```

## Хранение платежных данных

### Запрещенные практики

Согласно PCI DSS, запрещено хранение:

- Полных номеров карт
- CVV-кодов
- PIN-кодов
- Данных с магнитной полосы

### Рекомендованные практики

- Использование **токенизации** данных
- Хранение только последних 4-х цифр номера карты
- Применение **шифрования** для любых оставшихся данных
- Использование внешних платежных шлюзов (Stripe, PayPal и т.д.)

Для подробной информации о хранении данных см. [[Хранение конфиденциальных данных]].

## Шифрование на стороне клиента

Шифрование на стороне клиента добавляет дополнительный уровень защиты, особенно при передаче данных по сети.

### Пример реализации

```javascript
// Использование Web Crypto API для шифрования данных перед отправкой
async function encryptCardData(cardData) {
  const encoder = new TextEncoder();
  const data = encoder.encode(JSON.stringify(cardData));
  
  // Генерация ключа
  const key = await window.crypto.subtle.generateKey(
    {
      name: "RSA-OAEP",
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: "SHA-256",
    },
    true,
    ["encrypt", "decrypt"]
  );
  
  // Шифрование данных
  const encrypted = await window.crypto.subtle.encrypt(
    { name: "RSA-OAEP" },
    key.publicKey,
    data
  );
  
  return encrypted;
}
```

> [!note] Примечание
> Клиентское шифрование не заменяет другие меры безопасности, но может быть полезно в дополнение к HTTPS.

## Безопасность передачи данных

### Использование HTTPS

Все платежные данные должны передаваться исключительно по защищенным соединениям:

- Используйте **TLS 1.2** или выше
- Проверяйте сертификаты сервера
- Настройте HSTS для принудительного использования HTTPS

### Защита от CSRF-атак

```javascript
// Генерация CSRF-токена на сервере
function generateCSRFToken() {
  return crypto.randomBytes(32).toString('hex');
}

// Проверка токена при обработке платежа
app.post('/process-payment', (req, res) => {
  if (req.body.csrfToken !== req.session.csrfToken) {
    return res.status(403).send('CSRF token mismatch');
  }
  // Обработка платежа
});
```

Для более подробной информации о защите от CSRF см. [[CSRF защита]].

## Проверка валидности данных

### Проверка номера карты

```javascript
function validateCreditCard(cardNumber) {
  // Удаление пробелов и тире
  const sanitized = cardNumber.replace(/[\s-]/g, '');
  
  // Проверка длины и формата
  if (!/^\d{13,19}$/.test(sanitized)) {
    return false;
  }
  
  // Алгоритм Луна
  return luhnCheck(sanitized);
}

function luhnCheck(cardNumber) {
  let sum = 0;
  let isEven = false;
  for (let i = cardNumber.length - 1; i >= 0; i--) {
    let digit = parseInt(cardNumber[i]);
    if (isEven) {
      digit *= 2;
      if (digit > 9) digit -= 9;
    }
    sum += digit;
    isEven = !isEven;
  }
  return sum % 10 === 0;
}
```

### Проверка даты окончания действия

```javascript
function validateExpiryDate(expiryDate) {
  const [month, year] = expiryDate.split('/');
  const expiry = new Date(`20${year}`, month - 1, 1);
  const now = new Date();
  
  return expiry > now;
}
```

## Защита от атак на форму

### Rate Limiting

Ограничьте количество запросов к платежной форме:

```javascript
// Пример с использованием express-rate-limit
const rateLimit = require('express-rate-limit');

const paymentLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 5, // Максимум 5 попыток
  message: 'Слишком много попыток обработки платежа, попробуйте позже'
});
```

### Проверка реферала

Проверяйте, что форма отправляется с доверенного домена:

```javascript
app.post('/process-payment', (req, res) => {
  const allowedReferrers = ['https://yourdomain.com', 'https://www.yourdomain.com'];
  const referrer = req.get('Referrer');
  
  if (!referrer || !allowedReferrers.includes(new URL(referrer).origin)) {
    return res.status(403).send('Недопустимый реферал');
  }
  
  // Обработка платежа
});
```

## Безопасность SDK платежных систем

При использовании SDK от платежных систем (Stripe, PayPal, Яндекс.Касса и т.д.) необходимо:

- Использовать последние версии SDK
- Проверять цифровые подписи
- Не хранить секретные ключи в клиентском коде
- Использовать токены вместо передачи карточных данных

### Пример использования Stripe

```javascript
// На клиенте
const stripe = Stripe('pk_test_your_publishable_key');
const {token, error} = await stripe.createToken(cardElement);

if (error) {
  // Обработка ошибки
} else {
  // Отправка токена на сервер
  fetch('/process-payment', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({stripeToken: token.id})
  });
}
```

Для информации о конкретных SDK см. [[Stripe интеграция]] и [[Яндекс.Касса интеграция]].

## Лучшие практики

1. **Используйте внешние платежные шлюзы** - не обрабатывайте карточные данные напрямую
2. **Регулярные аудиты безопасности** - проверяйте код на уязвимости
3. **Обновление зависимостей** - поддерживайте актуальные версии библиотек
4. **Обучение команды** - обеспечьте знание принципов безопасности у всех разработчиков
5. **Логирование и мониторинг** - отслеживайте подозрительную активность
6. **Тестирование** - проводите регулярные тесты на проникновение

> [!important] Важно
> Соответствие PCI DSS - это не разовое действие, а непрерывный процесс, требующий регулярного пересмотра и обновления мер безопасности.

## Связанные файлы

- [[PCI DSS стандарт]]
- [[Хранение конфиденциальных данных]]
- [[CSRF защита]]
- [[XSS защита]]
- [[SQL инъекции]]
- [[Шифрование данных]]
- [[HTTPS и TLS]]
- [[Stripe интеграция]]
- [[Яндекс.Касса интеграция]]
- [[Сессии и аутентификация]]
- [[JWT токены]]
- [[CORS политики]]
- [[Content Security Policy]]
- [[OWASP Top 10]]
- [[Безопасность API]]
- [[Валидация пользовательского ввода]]
- [[Защита от ботов]]
- [[Мониторинг безопасности]]
- [[Логирование событий]]
- [[Резервное копирование]]