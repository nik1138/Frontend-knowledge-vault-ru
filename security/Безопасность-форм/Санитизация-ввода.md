---
aliases: ["Санитизация данных", "Валидация и санитизация", "Безопасность ввода"]
tags: 
  - security
  - input-validation
  - web-security
  - form-security
---

# Санитизация ввода

## Введение в санитизацию ввода

Санитизация ввода — это критический процесс очистки пользовательских данных перед их обработкой или сохранением в системе. Это один из фундаментальных принципов безопасности веб-приложений, направленный на предотвращение различных типов атак, таких как XSS (межсайтовый скриптинг), SQL-инъекции, командные инъекции и другие виды инъекционных атак.

> [!note] Важность санитизации
> Санитизация ввода должна выполняться на всех уровнях приложения: на клиенте, сервере и уровне базы данных, при этом основная защита должна быть реализована на сервере.

Санитизация включает в себя удаление или преобразование потенциально опасных символов, тегов, скриптов и других элементов, которые могут быть использованы для выполнения вредоносного кода. Процесс санитизации должен быть тщательно спланирован и реализован с учетом контекста использования данных.

## Отличие санитизации от валидации

Хотя санитизация и валидация часто используются вместе, они выполняют разные функции:

- **Валидация** — проверяет, соответствует ли ввод заданным критериям (например, формат email, длина строки, тип данных)
- **Санитизация** — очищает ввод от потенциально опасного контента

```javascript
// Пример валидации
function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

// Пример санитизации
function sanitizeInput(input) {
    // Удаление HTML-тегов
    return input.replace(/<[^>]*>/g, '');
}
```

Валидация помогает определить, является ли ввод допустимым, а санитизация — сделать его безопасным. Оба процесса важны и должны использоваться совместно для обеспечения полной безопасности.

## Методы санитизации

Существует несколько основных методов санитизации ввода:

### 1. Экранирование (Escaping)

Преобразование специальных символов в безопасные эквиваленты:

```javascript
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
```

### 2. Удаление небезопасного контента

Полное удаление потенциально опасных элементов:

```javascript
function removeScripts(html) {
    return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
}
```

### 3. Фильтрация по белому списку

Разрешение только безопасных тегов и атрибутов:

```javascript
function whitelistFilter(html) {
    // Разрешаем только безопасные HTML-теги
    const allowedTags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'];
    // Реализация фильтрации...
}
```

### 4. Кодирование данных

Преобразование данных в безопасный формат для конкретного контекста:

```javascript
// URL-кодирование
const encodedUrl = encodeURIComponent(userInput);

// Base64-кодирование
const encodedData = btoa(userInput);
```

## Белый список против черного списка

При реализации санитизации важно понимать разницу между подходами "белый список" и "черный список":

### Белый список (Whitelist)

- **Принцип**: Разрешить только известные безопасные элементы
- **Преимущества**: Высокий уровень безопасности, предсказуемость
- **Недостатки**: Может быть ограничительным для пользователей

```javascript
// Пример белого списка для HTML-содержимого
const allowedElements = {
    'p': [],
    'strong': [],
    'em': [],
    'a': ['href', 'title'],
    'img': ['src', 'alt']
};
```

### Черный список (Blacklist)

- **Принцип**: Запретить известные опасные элементы
- **Преимущества**: Меньше ограничений для пользователей
- **Недостатки**: Потенциальные уязвимости из-за пропущенных угроз

> [!warning] Рекомендация
> Всегда отдавайте предпочтение подходу белого списка, так как он более безопасен и надежен.

## Контекстно-зависимая санитизация

Санитизация должна учитывать контекст, в котором будут использоваться данные:

### 1. HTML-контекст

При вставке данных в HTML-документ необходимо экранировать специальные символы:

```javascript
// Небезопасно
element.innerHTML = userInput;

// Безопасно
element.textContent = userInput; // Автоматическое экранирование
```

### 2. URL-контекст

При построении URL-адресов:

```javascript
const safeUrl = new URL('/api/data', baseUrl);
safeUrl.searchParams.append('query', userInput);
```

### 3. SQL-контекст

При работе с базой данных:

```javascript
// Использование подготовленных выражений
const stmt = db.prepare('SELECT * FROM users WHERE id = ?');
stmt.run(userId);
```

### 4. JavaScript-контекст

При динамическом создании JavaScript-кода:

```javascript
// Небезопасно
eval('var data = ' + userInput);

// Безопасно - использование JSON.parse с проверкой
try {
    const parsed = JSON.parse(userInput);
} catch(e) {
    throw new Error('Invalid JSON');
}
```

## Санитизация HTML-контента

При работе с HTML-контентом, особенно при возможности пользовательского форматирования, требуется особая осторожность:

### Безопасные HTML-теги

Разрешенные теги должны быть тщательно отобраны:

```javascript
const safeTags = [
    'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'blockquote', 'code', 'pre'
];
```

### Безопасные атрибуты

Атрибуты также должны быть ограничены:

```javascript
const safeAttributes = {
    'a': ['href', 'title'],
    'img': ['src', 'alt', 'title'],
    'div': ['class'],
    'span': ['class']
};
```

### JavaScript-атрибуты

Все атрибуты, начинающиеся с "on", должны быть запрещены:

```javascript
// Удаление событийных атрибутов
function removeEventAttributes(html) {
    return html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '');
}
```

## Санитизация пользовательских данных

Различные типы пользовательских данных требуют разных подходов к санитизации:

### Текстовые поля

```javascript
function sanitizeText(text) {
    // Удаление или замена потенциально опасных символов
    return text
        .replace(/[<>]/g, '')  // Удаление угловых скобок
        .replace(/javascript:/gi, '')  // Удаление JS-протоколов
        .trim();
}
```

### Email-адреса

```javascript
function sanitizeEmail(email) {
    // Проверка формата и очистка
    const trimmed = email.trim().toLowerCase();
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed)) {
        throw new Error('Invalid email format');
    }
    return trimmed;
}
```

### URL-адреса

```javascript
function sanitizeUrl(url) {
    try {
        const parsed = new URL(url);
        // Проверка протокола
        if (!['http:', 'https:', 'ftp:'].includes(parsed.protocol)) {
            throw new Error('Invalid protocol');
        }
        return parsed.toString();
    } catch(e) {
        throw new Error('Invalid URL');
    }
}
```

### Файлы

```javascript
function sanitizeFileName(filename) {
    // Удаление потенциально опасных символов
    return filename
        .replace(/[\0-\x1f\x7f-\x9f]/g, '')  // Удаление управляющих символов
        .replace(/[#%&{}<>*? $!'":@+`|=/\\]/g, '_');  // Замена опасных символов
}
```

## Используемые библиотеки и инструменты

Для эффективной санитизации рекомендуется использовать проверенные библиотеки:

### JavaScript

- **DOMPurify** — для очистки HTML-контента
- **validator.js** — для валидации и санитизации строк
- **sanitize-html** — для фильтрации HTML

```javascript
// Пример использования DOMPurify
import DOMPurify from 'dompurify';

const clean = DOMPurify.sanitize(dirtyHTML);
```

### Python

- **Bleach** — для очистки HTML
- **WTForms** — для валидации форм
- **html5lib** — для парсинга HTML

### PHP

- **HTML Purifier** — для очистки HTML
- **filter_var()** — встроенная функция для фильтрации

### Java

- **OWASP Java HTML Sanitizer** — официальная библиотека OWASP
- **Apache Commons Validator** — для валидации

## Практические примеры санитизации

### Пример 1: Санитизация комментариев

```javascript
class CommentSanitizer {
    static sanitize(comment) {
        // Ограничение длины
        if (comment.length > 1000) {
            throw new Error('Comment too long');
        }
        
        // Очистка HTML
        const sanitized = DOMPurify.sanitize(comment, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
            ALLOWED_ATTR: []
        });
        
        return sanitized.trim();
    }
}
```

### Пример 2: Санитизация профиля пользователя

```javascript
class UserProfileSanitizer {
    static sanitize(profile) {
        return {
            name: this.sanitizeName(profile.name),
            bio: this.sanitizeBio(profile.bio),
            website: this.sanitizeUrl(profile.website),
            email: this.sanitizeEmail(profile.email)
        };
    }
    
    static sanitizeName(name) {
        return name
            .substring(0, 50)  // Ограничение длины
            .replace(/[<>]/g, '')  // Удаление HTML-тегов
            .trim();
    }
    
    static sanitizeBio(bio) {
        return bio
            .substring(0, 500)  // Ограничение длины
            .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')  // Удаление скриптов
            .trim();
    }
}
```

### Пример 3: Санитизация поискового запроса

```javascript
class SearchQuerySanitizer {
    static sanitize(query) {
        if (typeof query !== 'string') {
            throw new Error('Query must be a string');
        }
        
        // Удаление потенциально опасных символов
        return query
            .replace(/[<>{}[\];'"\\]/g, '')  // Удаление SQL-инъекционных символов
            .replace(/\s+/g, ' ')  // Нормализация пробелов
            .substring(0, 100)  // Ограничение длины
            .trim();
    }
}
```

## Ошибки при санитизации

Частые ошибки при реализации санитизации:

### 1. Неполная очистка

```javascript
// ОШИБКА: Неполная очистка скриптов
function badSanitize(html) {
    return html.replace(/<script>/gi, '').replace(/<\/script>/gi, '');
}

// ПРАВИЛЬНО: Использование полноценной библиотеки
import DOMPurify from 'dompurify';
const clean = DOMPurify.sanitize(dirtyHTML);
```

### 2. Санитизация уже санитизированного контента

```javascript
// ОШИБКА: Двойная санитизация может привести к непредсказуемым результатам
const doubleSanitized = sanitize(sanitize(userInput));
```

### 3. Использование регулярных выражений для сложных случаев

```javascript
// ОШИБКА: Регулярные выражения не подходят для парсинга HTML
const badResult = userInput.replace(/<.*?>/g, '');

// ПРАВИЛЬНО: Использование HTML-парсера
```

### 4. Санитизация на клиенте без серверной проверки

```javascript
// ОШИБКА: Полагаться только на клиентскую санитизацию
// ПРАВИЛЬНО: Санитизация должна быть на сервере
```

### 5. Игнорирование контекста

```javascript
// ОШИБКА: Использование одной функции санитизации для разных контекстов
const sanitized = escapeHtml(userInput);
db.query(`SELECT * FROM users WHERE name = '${sanitized}'`); // SQL-инъекция!
```

## Автоматизация процесса

Для эффективной санитизации рекомендуется автоматизировать процесс:

### Middleware для веб-приложений

```javascript
// Пример middleware для Express.js
function sanitizationMiddleware(req, res, next) {
    // Санитизация параметров запроса
    if (req.query) {
        req.query = sanitizeObject(req.query);
    }
    
    // Санитизация тела запроса
    if (req.body) {
        req.body = sanitizeObject(req.body);
    }
    
    next();
}

function sanitizeObject(obj) {
    if (typeof obj === 'string') {
        return DOMPurify.sanitize(obj);
    } else if (Array.isArray(obj)) {
        return obj.map(sanitizeObject);
    } else if (typeof obj === 'object' && obj !== null) {
        const sanitized = {};
        for (const [key, value] of Object.entries(obj)) {
            sanitized[key] = sanitizeObject(value);
        }
        return sanitized;
    }
    return obj;
}
```

### Автоматические проверки

```javascript
// Пример проверки валидации в CI/CD
function validateSanitization() {
    const testCases = [
        { input: '<script>alert(1)</script>', expected: 'alert(1)' },
        { input: 'javascript:alert(1)', expected: 'javascript:alert(1)' },
        { input: 'normal text', expected: 'normal text' }
    ];
    
    for (const testCase of testCases) {
        const result = sanitize(testCase.input);
        if (result !== testCase.expected) {
            throw new Error(`Sanitization failed for: ${testCase.input}`);
        }
    }
}
```

## Тестирование санитизации

Тестирование санитизации должно включать:

### 1. Модульное тестирование

```javascript
// Пример теста для функции санитизации
describe('sanitizeInput', () => {
    it('should remove script tags', () => {
        const input = '<script>alert("xss")</script>';
        const result = sanitizeInput(input);
        expect(result).not.toContain('<script>');
        expect(result).not.toContain('alert');
    });
    
    it('should preserve safe HTML', () => {
        const input = '<p>Safe paragraph</p>';
        const result = sanitizeInput(input);
        expect(result).toContain('<p>');
        expect(result).toContain('</p>');
    });
});
```

### 2. Интеграционное тестирование

```javascript
// Тестирование с реальными сценариями
describe('Form Sanitization', () => {
    it('should sanitize comment form', async () => {
        const maliciousComment = '<img src=x onerror=alert(1)>Hello World';
        const response = await submitComment(maliciousComment);
        expect(response.body.comment).not.toContain('onerror');
        expect(response.body.comment).not.toContain('alert');
    });
});
```

### 3. Пенетрационное тестирование

Регулярное тестирование на уязвимости XSS и другие инъекции:

- Использование инструментов типа OWASP ZAP
- Ручное тестирование с известными векторами атак
- Автоматизированные сканеры безопасности

## Совместимость с UX

Санитизация не должна ухудшать пользовательский опыт:

### 1. Сохранение полезного форматирования

```javascript
// Позволить безопасное форматирование
const allowedFormatting = ['strong', 'em', 'u', 'ol', 'ul', 'li'];
```

### 2. Информирование пользователей

```javascript
// Показывать, какие элементы разрешены
function showAllowedElements() {
    return 'Разрешены: жирный, курсив, список';
}
```

### 3. Гибкие правила

```javascript
// Разные правила для разных типов контента
const rules = {
    comments: { allowedTags: ['strong', 'em'], maxLength: 500 },
    posts: { allowedTags: ['p', 'strong', 'em', 'ul', 'ol'], maxLength: 10000 }
};
```

### 4. Обработка ошибок

```javascript
// Понятные сообщения об ошибках
function handleSanitizationError(error) {
    if (error.type === 'xss_detected') {
        return 'Ваше сообщение содержит запрещенный контент';
    }
    return 'Произошла ошибка при обработке сообщения';
}
```

## Рекомендации по эффективной санитизации

### 1. Используйте проверенные библиотеки

Не создавайте свои решения с нуля. Используйте проверенные библиотеки от известных организаций:

- OWASP рекомендует использовать официальные библиотеки
- Регулярные обновления и исправления уязвимостей

### 2. Принцип наименьших привилегий

Разрешайте только минимально необходимый набор функций:

```javascript
// Минималистичный белый список
const minimalWhitelist = {
    'p': [],
    'br': [],
    'strong': [],
    'em': []
};
```

### 3. Обработка на сервере

Всегда выполняйте санитизацию на сервере, независимо от клиентской обработки:

```javascript
// Серверная санитизация обязательна
app.post('/comment', (req, res) => {
    const sanitized = serverSanitize(req.body.comment);
    // Даже если клиент уже санировал, сервер делает это снова
    saveComment(sanitized);
});
```

### 4. Регулярные обновления

Следите за обновлениями библиотек безопасности и новых векторов атак:

- Подписка на уведомления о безопасности
- Регулярное тестирование приложения
- Обновление зависимостей

### 5. Аудит и мониторинг

Реализуйте логирование и мониторинг попыток инъекций:

```javascript
// Логирование подозрительных попыток
function logSuspiciousInput(input) {
    if (containsScriptTags(input) || containsEventHandlers(input)) {
        console.warn('Suspicious input detected:', input);
        securityLogger.log('potential_xss', { input, ip: req.ip });
    }
}
```

## Связанные файлы

- [[Валидация-ввода]] - основы валидации пользовательского ввода
- [[XSS-защита]] - защита от межсайтового скриптинга
- [[SQL-инъекции]] - защита от SQL-инъекций
- [[Формы-безопасности]] - общие принципы безопасности форм
- [[Контент-политика-безопасности]] - CSP для дополнительной защиты
- [[Сессии-аутентификация]] - безопасность аутентификации
- [[Хранение-данных]] - безопасное хранение пользовательских данных
- [[Криптография-база]] - основы криптографии в безопасности
- [[OWASP-Top-10]] - топ-10 веб-уязвимостей
- [[CSRF-защита]] - защита от подделки межсайтовых запросов

## Заключение

Санитизация ввода — это неотъемлемая часть безопасности веб-приложений. Правильная реализация санитизации требует понимания контекста использования данных, знания потенциальных угроз и использования проверенных методов и инструментов.

Ключевые принципы эффективной санитизации:

1. Использование белого списка вместо черного
2. Контекстно-зависимая обработка данных
3. Серверная обработка как основной уровень защиты
4. Комбинация с валидацией для полной безопасности
5. Регулярное тестирование и обновление методов

Следование этим принципам поможет создать безопасные и надежные веб-приложения, защищенные от большинства типов инъекционных атак.