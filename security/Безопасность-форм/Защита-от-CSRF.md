---
aliases: ["CSRF Protection", "Cross-Site Request Forgery"]
tags: 
  - security
  - web-security
  - csrf
  - forms
  - authentication
---

# Защита от CSRF-атак в веб-приложениях

## Введение в защиту от CSRF

Cross-Site Request Forgery (CSRF) — это тип атаки, при котором злонамеренный сайт заставляет браузер пользователя выполнить нежелательное действие на доверенном сайте, на котором пользователь аутентифицирован. CSRF-атаки могут привести к серьезным последствиям, включая изменение данных пользователя, выполнение нежелательных транзакций или даже компрометацию учетной записи.

Защита от CSRF является критически важной частью безопасности веб-приложений. Она предотвращает выполнение несанкционированных действий от имени аутентифицированных пользователей и обеспечивает целостность данных и операций.

## Как работает CSRF-атака

CSRF-атака эксплуатирует доверие, которое сайт оказывает браузеру пользователя. Вот как обычно происходит атака:

1. Пользователь аутентифицирован на доверенном сайте (например, интернет-банке)
2. Пользователь посещает злонамеренный сайт
3. Злонамеренный сайт содержит код, который отправляет запрос на доверенный сайт
4. Браузер автоматически включает куки аутентификации в этот запрос
5. Доверенный сайт обрабатывает запрос как легитимный, поскольку куки действительны

```html
<!-- Пример злонамеренного кода на другом сайте -->
<img src="https://bank.example.com/transfer?to=hacker&amount=1000" width="0" height="0" />
```

## Типы CSRF-атак

### GET-based CSRF
Атаки, использующие HTTP GET-запросы. Менее распространены, так как GET-запросы не должны изменять состояние сервера по спецификации.

### POST-based CSRF
Наиболее распространенный тип, использующий формы с методом POST. Атакующий создает форму на своем сайте и заставляет браузер пользователя отправить её.

### JSON CSRF
Атаки, использующие XMLHttpRequest или fetch для отправки JSON-данных. Требуют больше усилий для реализации, но также эффективны.

## Методы защиты от CSRF

### CSRF-токены
Самый распространенный и эффективный метод. Сервер генерирует уникальный токен для каждой сессии или формы и включает его в формы. При получении запроса сервер проверяет наличие и валидность токена.

### SameSite атрибуты куки
Позволяют ограничить отправку куки при межсайтовых запросах. Значения: `Strict`, `Lax`, `None`.

### Double Submit Cookie
Метод, при котором токен отправляется как в куки, так и в теле запроса. Сервер проверяет совпадение значений.

### Валидация Referer заголовка
Проверка заголовка Referer для убедительности, что запрос пришёл с доверенного домена. Менее надёжный метод из-за возможностей скрытия Referer.

## Реализация защиты в формах

Для защиты форм необходимо:

1. Генерировать уникальный CSRF-токен для каждой формы
2. Включать токен в скрытое поле формы
3. Проверять токен при обработке формы на сервере

```html
<form method="POST" action="/transfer">
  <input type="hidden" name="csrf_token" value="{{ csrf_token }}" />
  <input type="text" name="amount" />
  <input type="submit" value="Перевести" />
</form>
```

## CSRF-токены

CSRF-токены — это случайные значения, генерируемые сервером и включаемые в формы. Они обеспечивают:

- Уникальность для каждой сессии или запроса
- Невозможность предсказания для атакующего
- Проверку подлинности запроса

Токены должны быть:
- Криптографически безопасными
- Привязанными к сессии пользователя
- Ограниченными по времени действия

## SameSite атрибуты куки

Атрибут `SameSite` контролирует, когда куки отправляются с запросами:

- `Strict`: Куки отправляются только при навигации на тот же сайт
- `Lax`: Куки отправляются при навигации на тот же сайт и при GET-запросах с других сайтов
- `None`: Куки отправляются при всех запросах (требует Secure флага)

```http
Set-Cookie: sessionid=abc123; SameSite=Lax
```

## Double Submit Cookie

Метод, при котором токен отправляется дважды:
1. В куки
2. В теле запроса или заголовке

Сервер сравнивает оба значения. Преимущество метода в том, что он не требует хранения токенов на сервере.

## Валидация Referer заголовка

Проверка заголовка `Referer` может помочь определить источник запроса. Однако этот метод имеет ограничения:

- Заголовок может быть скрыт или изменен
- Не все браузеры отправляют Referer
- Может нарушать конфиденциальность

## Практические примеры реализации

### Пример на Node.js с Express
```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.get('/form', csrfProtection, (req, res) => {
  res.render('send', { csrfToken: req.csrfToken() });
});

app.post('/process', csrfProtection, (req, res) => {
  // Обработка формы
});
```

### Пример на Python с Flask
```python
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)

@app.route('/transfer', methods=['GET', 'POST'])
def transfer():
    form = TransferForm()
    if form.validate_on_submit():
        # Обработка формы
        pass
    return render_template('transfer.html', form=form)
```

## Подводные камни в реализации

### Неправильная генерация токенов
Слабые или предсказуемые токены делают защиту бесполезной.

### Игнорирование защиты для API
API-эндпоинты также подвержены CSRF-атакам и должны быть защищены.

### Неправильная обработка ошибок
Неправильная обработка неверных токенов может привести к блокировке легитимных пользователей.

## Тестирование защиты

### Ручное тестирование
- Попытка отправки форм без токенов
- Использование чужих токенов
- Проверка ограничений времени действия

### Автоматизированное тестирование
- Использование инструментов сканирования уязвимостей
- Интеграционные тесты с проверкой CSRF-защиты
- Пенетрационное тестирование

## Современные подходы

### SameSite по умолчанию
Установка `SameSite=Lax` для всех куки по умолчанию.

### Валидация Origin заголовка
Более надежная альтернатива проверке Referer.

### CORS с правильными заголовками
Комбинация CORS и CSRF-защиты для API.

## Сравнение методов защиты

| Метод | Безопасность | Сложность | Совместимость |
|-------|-------------|-----------|---------------|
| CSRF-токены | Высокая | Средняя | Высокая |
| SameSite куки | Высокая | Низкая | Современные браузеры |
| Double Submit | Средняя | Низкая | Высокая |
| Валидация Referer | Низкая | Низкая | Высокая |

## Связанные темы

Для более полного понимания безопасности веб-приложений рекомендуется ознакомиться с:

- [[XSS-защита]] - Защита от межсайтового скриптинга
- [[Аутентификация-и-авторизация]] - Основы аутентификации и авторизации
- [[HTTP-безопасность]] - Общие принципы HTTP-безопасности
- [[Сессии-и-куки]] - Управление сессиями и куки
- [[CORS-безопасность]] - Защита от междоменных запросов
- [[OWASP-Top-10]] - Топ-10 веб-уязвимостей по OWASP
- [[JSON-Web-Tokens]] - Безопасное использование JWT
- [[Шифрование-данных]] - Методы шифрования в веб-приложениях
- [[Валидация-ввода]] - Проверка пользовательского ввода
- [[Логирование-безопасности]] - Безопасное логирование событий
- [[Rate-Limiting]] - Ограничение частоты запросов
- [[Content-Security-Policy]] - Политика безопасности контента
- [[HTTPS-и-SSL]] - Шифрование трафика
- [[API-безопасность]] - Безопасность API-интерфейсов
- [[Фильтрация-данных]] - Очистка и фильтрация данных
- [[Сканеры-уязвимостей]] - Инструменты для поиска уязвимостей
- [[Безопасная-разработка]] - Принципы безопасной разработки
- [[Тестирование-безопасности]] - Методы тестирования безопасности
- [[Сертификаты-и-ключи]] - Управление криптографическими ключами
- [[Сетевая-безопасность]] - Защита на сетевом уровне

## Заключение

Защита от CSRF-атак является важной частью общей стратегии безопасности веб-приложений. Правильная реализация защитных механизмов, регулярное тестирование и следование лучшим практикам позволяют значительно снизить риски компрометации данных и нарушения целостности приложения.

> [!tip] Лучшая практика
> Используйте комбинацию методов защиты для достижения максимальной безопасности. Один из самых эффективных подходов — это использование CSRF-токенов в сочетании с атрибутами SameSite для куки.

> [!warning] Важно
> Не полагайтесь только на один метод защиты. Комбинирование нескольких подходов обеспечивает более надежную защиту от CSRF-атак.
