---
aliases: ["Form Validation", "Проверка форм", "Валидация форм безопасности"]
tags: [security, form-validation, input-validation, web-security]
---

# Проверка форм

## Обзор

Проверка форм - это критически важный аспект безопасности веб-приложений, который включает в себя валидацию и санитизацию данных, вводимых пользователями через веб-формы. Неправильная проверка форм может привести к различным уязвимостям, включая SQL-инъекции, межсайтовый скриптинг (XSS), внедрение команд и другие. Эффективная проверка форм требует как клиентской, так и серверной валидации для обеспечения максимальной безопасности.

## Почему важна проверка форм

### Основные угрозы

1. **SQL-инъекции**: Внедрение вредоносного SQL-кода через поля формы
2. **XSS-атаки**: Внедрение JavaScript-кода в поля формы
3. **Command injection**: Выполнение системных команд через формы
4. **Path traversal**: Доступ к файлам за пределами разрешенной директории
5. **CSRF**: Подделка межсайтовых запросов

### Принципы проверки форм

- **Проверка на границах**: Валидация всех входящих данных
- **Белый список**: Разрешение только известных безопасных значений
- **Санитизация**: Очистка данных от потенциально опасного содержимого
- **Контекстно-зависимое кодирование**: Правильное кодирование вывода

## Клиентская проверка форм

### HTML5 валидация

```html
<!-- Пример формы с HTML5 валидацией -->
<form id="userForm" novalidate>
  <div class="form-group">
    <label for="email">Email:</label>
    <input 
      type="email" 
      id="email" 
      name="email" 
      required 
      pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
      maxlength="254"
      title="Пожалуйста, введите действительный email адрес"
    >
    <span class="error-message" id="email-error"></span>
  </div>
  
  <div class="form-group">
    <label for="username">Имя пользователя:</label>
    <input 
      type="text" 
      id="username" 
      name="username" 
      required 
      pattern="[a-zA-Z0-9_]{3,20}"
      maxlength="20"
      title="Имя пользователя должно содержать 3-20 символов, только буквы, цифры и подчеркивание"
    >
    <span class="error-message" id="username-error"></span>
  </div>
  
  <div class="form-group">
    <label for="age">Возраст:</label>
    <input 
      type="number" 
      id="age" 
      name="age" 
      min="18" 
      max="120"
      required
    >
    <span class="error-message" id="age-error"></span>
  </div>
  
  <div class="form-group">
    <label for="website">Веб-сайт:</label>
    <input 
      type="url" 
      id="website" 
      name="website" 
      maxlength="2000"
    >
    <span class="error-message" id="website-error"></span>
  </div>
  
  <button type="submit">Отправить</button>
</form>
```

### JavaScript валидация на клиенте

```javascript
// Система клиентской валидации форм
class FormValidator {
  constructor(formId) {
    this.form = document.getElementById(formId);
    this.rules = {};
    this.errorMessages = {};
    this.init();
  }
  
  init() {
    this.form.addEventListener('submit', (e) => this.handleSubmit(e));
    
    // Добавляем валидацию в реальном времени
    const inputs = this.form.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
      input.addEventListener('blur', () => this.validateField(input));
      input.addEventListener('input', () => this.clearError(input));
    });
  }
  
  addRule(fieldName, rules, customMessages = {}) {
    this.rules[fieldName] = rules;
    this.errorMessages[fieldName] = customMessages;
  }
  
  validateField(input) {
    const fieldName = input.name;
    const value = input.value.trim();
    const rules = this.rules[fieldName];
    
    if (!rules) return true;
    
    for (const rule of rules) {
      const isValid = this.applyRule(value, rule);
      if (!isValid) {
        this.showError(input, this.getErrorMessage(fieldName, rule));
        return false;
      }
    }
    
    this.clearError(input);
    return true;
  }
  
  applyRule(value, rule) {
    switch (rule.type) {
      case 'required':
        return value !== '';
      case 'minLength':
        return value.length >= rule.value;
      case 'maxLength':
        return value.length <= rule.value;
      case 'pattern':
        return new RegExp(rule.value).test(value);
      case 'email':
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
      case 'number':
        return !isNaN(value) && isFinite(value);
      case 'min':
        return parseFloat(value) >= rule.value;
      case 'max':
        return parseFloat(value) <= rule.value;
      case 'custom':
        return rule.validator(value);
      default:
        return true;
    }
  }
  
  getErrorMessage(fieldName, rule) {
    const customMessage = this.errorMessages[fieldName]?.[rule.type];
    if (customMessage) return customMessage;
    
    const defaultMessages = {
      required: 'Это поле обязательно для заполнения',
      minLength: `Минимальная длина: ${rule.value} символов`,
      maxLength: `Максимальная длина: ${rule.value} символов`,
      pattern: 'Неверный формат данных',
      email: 'Пожалуйста, введите действительный email',
      number: 'Пожалуйста, введите число',
      min: `Значение должно быть не менее ${rule.value}`,
      max: `Значение должно быть не более ${rule.value}`
    };
    
    return defaultMessages[rule.type] || 'Неверное значение';
  }
  
  showError(input, message) {
    input.classList.add('error');
    const errorElement = document.getElementById(`${input.name}-error`);
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.style.display = 'block';
    }
  }
  
  clearError(input) {
    input.classList.remove('error');
    const errorElement = document.getElementById(`${input.name}-error`);
    if (errorElement) {
      errorElement.style.display = 'none';
      errorElement.textContent = '';
    }
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    let isFormValid = true;
    const inputs = this.form.querySelectorAll('input, textarea, select');
    
    inputs.forEach(input => {
      if (!this.validateField(input)) {
        isFormValid = false;
      }
    });
    
    if (isFormValid) {
      // Отправка данных на сервер
      await this.submitForm();
    } else {
      console.log('Форма содержит ошибки');
    }
  }
  
  async submitForm() {
    // Собираем данные формы
    const formData = new FormData(this.form);
    const data = Object.fromEntries(formData);
    
    try {
      const response = await fetch('/api/submit-form', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });
      
      if (response.ok) {
        console.log('Форма успешно отправлена');
        this.form.reset();
      } else {
        console.error('Ошибка при отправке формы');
      }
    } catch (error) {
      console.error('Ошибка сети:', error);
    }
  }
}

// Использование
const validator = new FormValidator('userForm');

// Добавление правил валидации
validator.addRule('email', [
  { type: 'required' },
  { type: 'email' },
  { type: 'maxLength', value: 254 }
], {
  required: 'Пожалуйста, введите email адрес',
  email: 'Пожалуйста, введите действительный email адрес'
});

validator.addRule('username', [
  { type: 'required' },
  { type: 'pattern', value: '^[a-zA-Z0-9_]{3,20}$' },
  { type: 'custom', validator: (value) => !value.includes('admin') }
], {
  pattern: 'Имя пользователя должно содержать 3-20 символов, только буквы, цифры и подчеркивание',
  custom: 'Имя пользователя не может содержать слово "admin"'
});
```

## Серверная проверка форм

### Пример на Node.js с Express

```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const validator = require('validator');
const app = express();

// Middleware для ограничения частоты запросов
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 100, // ограничение на 100 запросов за 15 минут
  message: 'Слишком много попыток отправки формы, попробуйте позже'
});

app.use('/api/', limiter);
app.use(express.json({ limit: '10mb' })); // Ограничение размера тела запроса

// Middleware для проверки форм
function formValidationMiddleware(req, res, next) {
  // Проверка размера данных
  if (req.body && JSON.stringify(req.body).length > 10000) { // 10KB
    return res.status(400).json({ error: 'Слишком большой размер данных формы' });
  }
  
  // Санитизация и проверка данных
  req.body = sanitizeFormData(req.body);
  
  // Проверка результатов санитизации
  if (req.body.errors && req.body.errors.length > 0) {
    return res.status(400).json({ 
      error: 'Некорректные данные формы', 
      details: req.body.errors 
    });
  }
  
  // Удаляем временные ошибки
  delete req.body.errors;
  
  next();
}

function sanitizeFormData(data) {
  const errors = [];
  
  // Рекурсивная санитизация
  function sanitizeValue(value, path = '') {
    if (typeof value === 'string') {
      // Проверка длины строки
      if (value.length > 1000) {
        errors.push(`Поле ${path} слишком длинное`);
        value = value.substring(0, 1000);
      }
      
      // Санитизация HTML и потенциально опасных символов
      value = validator.escape(value);
      value = validator.stripLow(value, true);
      
      // Проверка на потенциально опасные паттерны
      if (hasDangerousPattern(value)) {
        errors.push(`Поле ${path} содержит потенциально опасный контент`);
      }
      
      return value;
    } else if (Array.isArray(value)) {
      return value.map((item, index) => sanitizeValue(item, `${path}[${index}]`));
    } else if (typeof value === 'object' && value !== null) {
      const result = {};
      for (const [key, val] of Object.entries(value)) {
        // Проверка имени ключа
        if (key.length > 50) {
          errors.push(`Имя поля ${key} слишком длинное`);
          continue;
        }
        
        if (!/^[a-zA-Z0-9_-]+$/.test(key)) {
          errors.push(`Имя поля ${key} содержит недопустимые символы`);
          continue;
        }
        
        result[key] = sanitizeValue(val, path ? `${path}.${key}` : key);
      }
      return result;
    }
    return value;
  }
  
  const sanitizedData = sanitizeValue(data);
  sanitizedData.errors = errors;
  
  return sanitizedData;
}

function hasDangerousPattern(value) {
  // Проверка на потенциально опасные паттерны
  const dangerousPatterns = [
    /<script/i,
    /javascript:/i,
    /vbscript:/i,
    /on\w+\s*=/i,
    /<iframe/i,
    /<object/i,
    /<embed/i,
    /eval\(/i,
    /expression\(/i
  ];
  
  return dangerousPatterns.some(pattern => pattern.test(value));
}

// Валидация конкретной формы регистрации
function validateRegistrationForm(data) {
  const errors = [];
  
  // Проверка email
  if (!data.email) {
    errors.push('Email обязателен');
  } else if (!validator.isEmail(data.email)) {
    errors.push('Некорректный email');
  } else if (data.email.length > 254) {
    errors.push('Email слишком длинный');
  }
  
  // Проверка имени пользователя
  if (!data.username) {
    errors.push('Имя пользователя обязательно');
  } else if (!/^[a-zA-Z0-9_]{3,20}$/.test(data.username)) {
    errors.push('Имя пользователя должно содержать 3-20 символов, только буквы, цифры и подчеркивание');
  }
  
  // Проверка пароля
  if (!data.password) {
    errors.push('Пароль обязателен');
  } else if (data.password.length < 8) {
    errors.push('Пароль должен быть не менее 8 символов');
  } else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(data.password)) {
    errors.push('Пароль должен содержать заглавную букву, строчную букву и цифру');
  }
  
  // Проверка возраста
  if (data.age) {
    const age = parseInt(data.age);
    if (isNaN(age) || age < 18 || age > 120) {
      errors.push('Возраст должен быть от 18 до 120');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

// Обработчик формы регистрации
app.post('/api/register', formValidationMiddleware, (req, res) => {
  const validation = validateRegistrationForm(req.body);
  
  if (!validation.isValid) {
    return res.status(400).json({ 
      error: 'Ошибка валидации формы', 
      details: validation.errors 
    });
  }
  
  // Обработка валидных данных
  console.log('Данные регистрации:', req.body);
  
  // Здесь обычно происходит сохранение в базу данных
  res.json({ success: true, message: 'Регистрация успешна' });
});
```

## Защита от CSRF

### Реализация CSRF защиты

```javascript
const crypto = require('crypto');

// Middleware для генерации CSRF токенов
function csrfProtection(req, res, next) {
  if (!req.session.csrfToken) {
    req.session.csrfToken = crypto.randomBytes(32).toString('hex');
  }
  
  // Добавляем токен в локальные переменные для шаблонов
  res.locals.csrfToken = req.session.csrfToken;
  
  // Проверяем токен в POST запросах
  if (req.method === 'POST') {
    const tokenFromBody = req.body.csrfToken || req.headers['x-csrf-token'];
    
    if (!tokenFromBody || tokenFromBody !== req.session.csrfToken) {
      return res.status(403).json({ error: 'Неверный CSRF токен' });
    }
    
    // Обновляем токен после использования
    req.session.csrfToken = crypto.randomBytes(32).toString('hex');
  }
  
  next();
}

app.use(csrfProtection);

// Пример формы с CSRF токеном
app.get('/form', (req, res) => {
  res.send(`
    <form method="POST" action="/submit">
      <input type="hidden" name="csrfToken" value="${res.locals.csrfToken}">
      <input type="text" name="data" required>
      <button type="submit">Отправить</button>
    </form>
  `);
});
```

## Проверка файлов, загружаемых через формы

### Безопасная загрузка файлов

```javascript
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Настройка multer для загрузки файлов
const fileFilter = (req, file, cb) => {
  // Проверка MIME-типа файла
  const allowedMimeTypes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/pdf',
    'text/plain'
  ];
  
  if (!allowedMimeTypes.includes(file.mimetype)) {
    return cb(new Error('Тип файла не разрешен'), false);
  }
  
  // Проверка расширения файла
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt'];
  const ext = path.extname(file.originalname).toLowerCase();
  
  if (!allowedExtensions.includes(ext)) {
    return cb(new Error('Расширение файла не разрешено'), false);
  }
  
  cb(null, true);
};

const upload = multer({
  dest: 'uploads/',
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 5 // максимум 5 файлов
  },
  fileFilter: fileFilter
});

// Обработчик загрузки файлов
app.post('/api/upload', upload.array('files', 5), (req, res) => {
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ error: 'Файлы не загружены' });
  }
  
  const savedFiles = [];
  
  for (const file of req.files) {
    // Дополнительная проверка безопасности
    if (isDangerousFile(file.path)) {
      // Удаляем опасный файл
      fs.unlinkSync(file.path);
      return res.status(400).json({ error: 'Файл содержит вредоносный контент' });
    }
    
    savedFiles.push({
      originalName: file.originalname,
      filename: file.filename,
      size: file.size,
      mimetype: file.mimetype
    });
  }
  
  res.json({ success: true, files: savedFiles });
});

// Проверка файла на потенциальную опасность
function isDangerousFile(filePath) {
  // Простая проверка на основе содержимого файла
  const fileContent = fs.readFileSync(filePath, 'utf8');
  
  // Проверка на потенциально опасные паттерны
  const dangerousPatterns = [
    /<script/i,
    /javascript:/i,
    /eval\(/i,
    /expression\(/i,
    /vbscript:/i
  ];
  
  return dangerousPatterns.some(pattern => pattern.test(fileContent));
}
```

## Практические примеры проверки

### Комплексная проверка контактной формы

```javascript
// Класс для проверки контактной формы
class ContactFormValidator {
  static validate(data) {
    const errors = [];
    
    // Проверка имени
    if (!data.name || data.name.trim().length === 0) {
      errors.push('Имя обязательно для заполнения');
    } else if (data.name.trim().length > 100) {
      errors.push('Имя слишком длинное (максимум 100 символов)');
    } else if (!/^[a-zA-Zа-яА-ЯёЁ\s'-]+$/.test(data.name.trim())) {
      errors.push('Имя содержит недопустимые символы');
    }
    
    // Проверка email
    if (!data.email || data.email.trim().length === 0) {
      errors.push('Email обязателен');
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email.trim())) {
      errors.push('Некорректный email');
    } else if (data.email.trim().length > 254) {
      errors.push('Email слишком длинный');
    }
    
    // Проверка темы
    if (!data.subject || data.subject.trim().length === 0) {
      errors.push('Тема обязательна');
    } else if (data.subject.trim().length > 200) {
      errors.push('Тема слишком длинная (максимум 200 символов)');
    }
    
    // Проверка сообщения
    if (!data.message || data.message.trim().length === 0) {
      errors.push('Сообщение обязательно');
    } else if (data.message.trim().length > 5000) {
      errors.push('Сообщение слишком длинное (максимум 5000 символов)');
    }
    
    // Проверка на спам-паттерны
    if (this.containsSpamPatterns(data.message)) {
      errors.push('Сообщение содержит подозрительный контент');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  static containsSpamPatterns(message) {
    const spamPatterns = [
      /viagra|casino|loan|money|click here|free money/gi,
      /congratulations.*winner/gi,
      /urgent.*response/gi
    ];
    
    return spamPatterns.some(pattern => pattern.test(message));
  }
}

// Использование в обработчике формы
app.post('/api/contact', (req, res) => {
  const validation = ContactFormValidator.validate(req.body);
  
  if (!validation.isValid) {
    return res.status(400).json({ 
      error: 'Ошибка валидации контактной формы', 
      details: validation.errors 
    });
  }
  
  // Обработка валидного сообщения
  console.log('Сообщение от:', req.body.name, req.body.email);
  console.log('Тема:', req.body.subject);
  console.log('Сообщение:', req.body.message);
  
  res.json({ success: true, message: 'Сообщение отправлено' });
});
```

### Проверка формы комментариев

```javascript
// Класс для проверки формы комментариев
class CommentValidator {
  static validate(commentData, user) {
    const errors = [];
    
    // Проверка содержимого комментария
    if (!commentData.content || commentData.content.trim().length === 0) {
      errors.push('Комментарий не может быть пустым');
    } else if (commentData.content.trim().length > 1000) {
      errors.push('Комментарий слишком длинный (максимум 1000 символов)');
    }
    
    // Проверка на запрещенные слова (антиспам)
    if (this.containsBannedWords(commentData.content)) {
      errors.push('Комментарий содержит запрещенные слова');
    }
    
    // Проверка частоты комментариев (антиспам)
    if (user && !this.isRateLimitOk(user)) {
      errors.push('Слишком частые комментарии, подождите немного');
    }
    
    // Проверка на XSS
    if (this.containsXSSPatterns(commentData.content)) {
      errors.push('Комментарий содержит потенциально опасный код');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  static containsBannedWords(content) {
    const bannedWords = [
      'spam', 'advertisement', 'buy now', 'click here', 'free money'
    ];
    
    const lowerContent = content.toLowerCase();
    return bannedWords.some(word => lowerContent.includes(word.toLowerCase()));
  }
  
  static containsXSSPatterns(content) {
    const xssPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+\s*=/i,
      /<iframe/i,
      /eval\(/i
    ];
    
    return xssPatterns.some(pattern => pattern.test(content));
  }
  
  static isRateLimitOk(user) {
    // Простая проверка частоты (в реальном приложении использовать Redis или базу данных)
    const now = Date.now();
    const lastCommentTime = user.lastCommentTime || 0;
    
    // Минимум 30 секунд между комментариями
    return (now - lastCommentTime) > 30000;
  }
}

// Обработчик формы комментариев
app.post('/api/comment', (req, res) => {
  // Предполагаем, что пользователь аутентифицирован
  const user = req.user; // из middleware аутентификации
  
  const validation = CommentValidator.validate(req.body, user);
  
  if (!validation.isValid) {
    return res.status(400).json({ 
      error: 'Ошибка валидации комментария', 
      details: validation.errors 
    });
  }
  
  // Сохранение комментария (после санитизации)
  const sanitizedContent = sanitizeHtml(req.body.content);
  
  console.log('Новый комментарий:', sanitizedContent);
  
  res.json({ success: true, message: 'Комментарий добавлен' });
});

// Функция санитизации HTML
function sanitizeHtml(html) {
  // В реальном приложении использовать библиотеку вроде DOMPurify
  return html
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+\s*=/gi, '');
}
```

## Лучшие практики проверки форм

### 1. Комбинированная проверка

```javascript
// Система комплексной проверки форм
class ComprehensiveFormValidator {
  constructor() {
    this.clientRules = new Map();
    this.serverRules = new Map();
  }
  
  addClientRule(formName, fieldName, rules) {
    if (!this.clientRules.has(formName)) {
      this.clientRules.set(formName, new Map());
    }
    this.clientRules.get(formName).set(fieldName, rules);
  }
  
  addServerRule(formName, validationFunction) {
    this.serverRules.set(formName, validationFunction);
  }
  
  getClientRules(formName) {
    return this.clientRules.get(formName) || new Map();
  }
  
  async validateServerSide(formName, data) {
    const validator = this.serverRules.get(formName);
    if (!validator) {
      throw new Error(`Валидатор для формы ${formName} не найден`);
    }
    
    return await validator(data);
  }
}

// Регистрация правил
const formValidator = new ComprehensiveFormValidator();

formValidator.addServerRule('registration', async (data) => {
  const errors = [];
  
  // Проверка уникальности email
  const existingUser = await checkEmailExists(data.email);
  if (existingUser) {
    errors.push('Пользователь с таким email уже существует');
  }
  
  // Проверка сложности пароля
  if (!isPasswordStrong(data.password)) {
    errors.push('Пароль должен быть более надежным');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
});
```

### 2. Логирование и мониторинг

```javascript
// Система логирования проверки форм
class FormValidationLogger {
  static logValidationAttempt(formName, isValid, errors = [], ip = '') {
    const logEntry = {
      timestamp: new Date().toISOString(),
      formName,
      isValid,
      errors,
      ip,
      userAgent: global.userAgent || ''
    };
    
    console.log('Проверка формы:', logEntry);
    
    // В реальном приложении отправлять в систему логирования
    if (!isValid && errors.some(e => e.includes('подозрительный'))) {
      this.reportSuspiciousActivity(logEntry);
    }
  }
  
  static reportSuspiciousActivity(logEntry) {
    // Отчет о подозрительной активности
    console.warn('Подозрительная активность в форме:', logEntry);
    
    // Здесь можно отправить в систему безопасности
    // или увеличить счетчик подозрительных действий для IP
  }
}
```

### 3. Тестирование валидации

```javascript
// Тесты для проверки форм
function testFormValidation() {
  console.log('Тестирование валидации форм...');
  
  // Тест 1: Проверка корректных данных
  const validData = {
    email: 'user@example.com',
    username: 'valid_user',
    password: 'StrongPass123'
  };
  
  const validResult = validateRegistrationForm(validData);
  console.assert(validResult.isValid, 'Валидные данные должны пройти проверку');
  
  // Тест 2: Проверка некорректных данных
  const invalidData = {
    email: 'invalid-email',
    username: 'a', // слишком короткое
    password: 'weak' // слабый пароль
  };
  
  const invalidResult = validateRegistrationForm(invalidData);
  console.assert(!invalidResult.isValid, 'Некорректные данные не должны пройти проверку');
  console.assert(invalidResult.errors.length > 0, 'Должны быть возвращены ошибки');
  
  console.log('Тесты валидации форм пройдены');
}

testFormValidation();
```

## Заключение

Проверка форм - это многоуровневый процесс, требующий как клиентской, так и серверной валидации. Эффективная система проверки форм включает в себя не только базовую валидацию данных, но и защиту от различных видов атак, ограничение частоты запросов и мониторинг подозрительной активности. Правильная реализация этих мер помогает защитить веб-приложения от большинства распространенных уязвимостей, связанных с обработкой пользовательского ввода.

## Связанные темы

- [[Санитизация-ввода]]
- [[Лучшие-практики-безопасности-форм]]
- [[Проверка-ввода]]
- [[Кодирование-вывода]]
- [[Функции-безопасности-браузера]]
- [[Тестирование-безопасности]]