---
aliases: [Subdomain Security, Безопасность субдоменов, Защита поддоменов]
tags: [security, subdomain-security, domain-isolation, frontend-security]
---

# Безопасность-субдоменов

## Введение

Безопасность субдоменов - это критически важный аспект архитектуры безопасности веб-приложений, особенно в системах, использующих многосубдоменную структуру. Субдомены могут создавать дополнительные векторы атак, если не обеспечена надлежащая изоляция и защита между ними. Эта тема охватывает методы безопасного управления субдоменами и предотвращения атак, использующих доверие между субдоменами.

## Архитектура безопасности субдоменов

### Принципы безопасного разделения субдоменов

Безопасное разделение субдоменов основывается на следующих принципах:

1. **Минимальные привилегии**: Каждый субдомен должен иметь только необходимые ему права доступа
2. **Изоляция данных**: Данные одного субдомена не должны быть доступны другим без явного разрешения
3. **Ограниченное доверие**: Не все субдомены должны автоматически доверять друг другу
4. **Контроль доступа**: Четко определенные правила доступа между субдоменами

```javascript
// Класс для управления архитектурой безопасности субдоменов
class SubdomainSecurityArchitecture {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.subdomains = new Map();
    this.trustPolicies = new Map();
    this.accessRules = new Map();
  }

  // Регистрация нового субдомена
  registerSubdomain(subdomain, config = {}) {
    const fullDomain = `${subdomain}.${this.rootDomain}`;
    
    this.subdomains.set(subdomain, {
      name: subdomain,
      fullDomain,
      config,
      securityLevel: config.securityLevel || 'standard',
      trustedSubdomains: config.trustedSubdomains || [],
      permissions: config.permissions || []
    });
    
    // Устанавливаем политику доверия по умолчанию
    this.setTrustPolicy(subdomain, 'default', {
      allowCrossDomainRequests: false,
      allowCookieSharing: false,
      allowLocalStorageAccess: false
    });
    
    return this.subdomains.get(subdomain);
  }

  // Установка политики доверия между субдоменами
  setTrustPolicy(fromSubdomain, toSubdomain, policy) {
    const key = `${fromSubdomain}->${toSubdomain}`;
    this.trustPolicies.set(key, {
      ...policy,
      lastUpdated: new Date()
    });
  }

  // Проверка безопасности субдомена
  validateSubdomainSecurity(subdomain) {
    const subdomainInfo = this.subdomains.get(subdomain);
    if (!subdomainInfo) {
      throw new Error(`Субдомен ${subdomain} не зарегистрирован`);
    }

    const issues = [];
    
    // Проверяем уровень безопасности
    if (!['minimal', 'standard', 'strict', 'paranoid'].includes(subdomainInfo.securityLevel)) {
      issues.push(`Неверный уровень безопасности: ${subdomainInfo.securityLevel}`);
    }
    
    // Проверяем политики доверия
    for (const [policyKey, policy] of this.trustPolicies) {
      if (policyKey.startsWith(`${subdomain}->`)) {
        if (policy.allowCookieSharing && subdomainInfo.securityLevel === 'strict') {
          issues.push(`Субдомен с уровнем 'strict' не должен разделять cookies`);
        }
      }
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      securityLevel: subdomainInfo.securityLevel
    };
  }

  // Получение разрешений для субдомена
  getSubdomainPermissions(subdomain) {
    const subdomainInfo = this.subdomains.get(subdomain);
    return subdomainInfo ? subdomainInfo.permissions : [];
  }
}

// Использование
const securityArch = new SubdomainSecurityArchitecture('example.com');

// Регистрация субдоменов с разными уровнями безопасности
securityArch.registerSubdomain('api', {
  securityLevel: 'strict',
  trustedSubdomains: ['app'],
  permissions: ['read:users', 'write:posts']
});

securityArch.registerSubdomain('app', {
  securityLevel: 'standard',
  trustedSubdomains: ['api'],
  permissions: ['read:ui', 'write:preferences']
});

securityArch.registerSubdomain('admin', {
  securityLevel: 'paranoid',
  trustedSubdomains: [],
  permissions: ['admin:all']
});

// Проверка безопасности
const apiValidation = securityArch.validateSubdomainSecurity('api');
console.log('Валидация API субдомена:', apiValidation);
```

## Управление доступом между субдоменами

### CORS и субдомены

```javascript
// Класс для управления CORS между субдоменами
class SubdomainCORSManager {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.allowedSubdomains = new Set();
    this.corsPolicies = new Map();
  }

  // Добавление доверенного субдомена
  addTrustedSubdomain(subdomain) {
    this.allowedSubdomains.add(`${subdomain}.${this.rootDomain}`);
  }

  // Установка CORS политики для субдомена
  setSubdomainPolicy(subdomain, policy) {
    const key = `${subdomain}.${this.rootDomain}`;
    this.corsPolicies.set(key, policy);
  }

  // Проверка CORS запроса между субдоменами
  validateCORSRequest(origin, target) {
    // Проверяем, является ли origin субдоменом нашего корневого домена
    if (!origin.endsWith(`.${this.rootDomain}`)) {
      return false; // Не наш субдомен
    }

    // Проверяем, доверяем ли мы этому субдомену
    if (!this.allowedSubdomains.has(origin)) {
      return false;
    }

    // Проверяем политику CORS для этого субдомена
    const policy = this.corsPolicies.get(origin);
    if (!policy) {
      return false; // Нет политики - доступ запрещен
    }

    // Проверяем, разрешен ли доступ к целевому ресурсу
    if (policy.allowedTargets && !policy.allowedTargets.includes(target)) {
      return false;
    }

    return true;
  }

  // Генерация безопасного CORS заголовка
  generateCORSHeaders(requestingSubdomain) {
    const origin = `${requestingSubdomain}.${this.rootDomain}`;
    
    if (!this.allowedSubdomains.has(origin)) {
      return {
        'Access-Control-Allow-Origin': 'null',
        'Access-Control-Allow-Credentials': 'false'
      };
    }

    const policy = this.corsPolicies.get(origin);
    const headers = {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Credentials': policy?.allowCredentials || 'false',
      'Access-Control-Allow-Methods': policy?.allowedMethods || 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': policy?.allowedHeaders || 'Content-Type, Authorization'
    };

    if (policy?.maxAge) {
      headers['Access-Control-Max-Age'] = policy.maxAge.toString();
    }

    return headers;
  }
}

// Использование
const corsManager = new SubdomainCORSManager('example.com');

// Добавляем доверенные субдомены
corsManager.addTrustedSubdomain('app');
corsManager.addTrustedSubdomain('api');

// Устанавливаем политики CORS
corsManager.setSubdomainPolicy('app', {
  allowCredentials: 'true',
  allowedMethods: 'GET, POST, PUT, DELETE',
  allowedHeaders: 'Content-Type, Authorization, X-Requested-With',
  maxAge: 86400, // 24 часа
  allowedTargets: ['https://api.example.com']
});

corsManager.setSubdomainPolicy('admin', {
  allowCredentials: 'true',
  allowedMethods: 'GET, POST, PUT, DELETE, PATCH',
  allowedHeaders: 'Content-Type, Authorization, X-Admin-Token',
  maxAge: 3600, // 1 час
  allowedTargets: ['https://api.example.com', 'https://admin-api.example.com']
});

// Проверка CORS запроса
const isValid = corsManager.validateCORSRequest(
  'https://app.example.com', 
  'https://api.example.com'
);
console.log('CORS запрос валиден:', isValid);
```

### Управление cookies в субдоменах

```javascript
// Класс для безопасного управления cookies в субдоменах
class SubdomainCookieManager {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.cookiePolicies = new Map();
    this.domainCookies = new Map();
  }

  // Установка политики для субдомена
  setCookiePolicy(subdomain, policy) {
    this.cookiePolicies.set(subdomain, {
      ...policy,
      domain: policy.domain || this.rootDomain,
      allowedPaths: policy.allowedPaths || ['/'],
      maxAge: policy.maxAge || 3600 // 1 час по умолчанию
    });
  }

  // Установка cookie с учетом безопасности субдоменов
  setCookie(name, value, subdomain, options = {}) {
    const policy = this.getSubdomainPolicy(subdomain);
    if (!policy) {
      throw new Error(`Нет политики для субдомена: ${subdomain}`);
    }

    // Проверяем, разрешен ли путь
    if (options.path && !policy.allowedPaths.includes(options.path)) {
      throw new Error(`Путь ${options.path} не разрешен для субдомена ${subdomain}`);
    }

    const cookieParts = [
      `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
    ];

    // Устанавливаем домен для доступа между субдоменами (если разрешено)
    if (policy.allowCrossSubdomainAccess) {
      cookieParts.push(`Domain=.${this.rootDomain}`);
    } else {
      cookieParts.push(`Domain=${subdomain}.${this.rootDomain}`);
    }

    // Добавляем безопасные опции
    cookieParts.push(`Path=${options.path || '/'}`);
    cookieParts.push('Secure'); // Только по HTTPS
    cookieParts.push('HttpOnly'); // Защита от XSS
    cookieParts.push(`SameSite=${options.sameSite || 'Lax'}`);

    // Время жизни
    const maxAge = options.maxAge || policy.maxAge;
    cookieParts.push(`Max-Age=${maxAge}`);

    document.cookie = cookieParts.join('; ');
  }

  // Получение cookie с проверкой безопасности
  getCookie(name, requestingSubdomain) {
    const policy = this.getSubdomainPolicy(requestingSubdomain);
    if (!policy) {
      return null;
    }

    const nameEQ = encodeURIComponent(name) + '=';
    const ca = document.cookie.split(';');

    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) {
        return decodeURIComponent(c.substring(nameEQ.length, c.length));
      }
    }
    return null;
  }

  // Удаление cookie
  deleteCookie(name, subdomain, path = '/') {
    const fullDomain = subdomain ? `${subdomain}.${this.rootDomain}` : this.rootDomain;
    document.cookie = `${name}=; Path=${path}; Domain=${fullDomain}; Max-Age=-1`;
  }

  // Получение политики субдомена
  getSubdomainPolicy(subdomain) {
    return this.cookiePolicies.get(subdomain);
  }

  // Валидация безопасности cookies
  validateCookieSecurity(subdomain, cookieName) {
    const policy = this.getSubdomainPolicy(subdomain);
    if (!policy) {
      return { valid: false, reason: 'Нет политики для субдомена' };
    }

    // Проверяем чувствительные имена cookies
    const sensitiveCookies = ['password', 'token', 'session', 'auth'];
    const isSensitive = sensitiveCookies.some(sensitive => 
      cookieName.toLowerCase().includes(sensitive)
    );

    if (isSensitive && policy.securityLevel !== 'strict') {
      return { 
        valid: false, 
        reason: 'Чувствительные cookies требуют строгой политики безопасности' 
      };
    }

    return { valid: true, isSensitive };
  }
}

// Использование
const cookieManager = new SubdomainCookieManager('example.com');

// Устанавливаем политики для разных субдоменов
cookieManager.setCookiePolicy('app', {
  allowCrossSubdomainAccess: false,
  allowedPaths: ['/', '/app', '/dashboard'],
  maxAge: 86400, // 24 часа
  securityLevel: 'standard'
});

cookieManager.setCookiePolicy('api', {
  allowCrossSubdomainAccess: true, // API может быть доступен с других субдоменов
  allowedPaths: ['/api'],
  maxAge: 3600, // 1 час
  securityLevel: 'strict'
});

cookieManager.setCookiePolicy('admin', {
  allowCrossSubdomainAccess: false,
  allowedPaths: ['/admin'],
  maxAge: 1800, // 30 минут
  securityLevel: 'strict'
});

// Установка безопасных cookies
try {
  cookieManager.setCookie('user_session', 'session_123', 'app', {
    sameSite: 'Lax',
    maxAge: 7200
  });

  cookieManager.setCookie('api_token', 'token_456', 'api', {
    sameSite: 'Strict',
    maxAge: 1800
  });

  console.log('Cookies успешно установлены');
} catch (error) {
  console.error('Ошибка установки cookie:', error);
}
```

## Защита от атак через субдомены

### DNS Rebinding атаки

```javascript
// Класс для защиты от DNS Rebinding атак в субдоменах
class DNSRebindingProtection {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.knownSubdomains = new Set();
    this.requestHistory = new Map();
    this.maxRedirects = 3;
    this.requestTimeout = 10000; // 10 секунд
  }

  // Регистрация известных субдоменов
  registerSubdomain(subdomain) {
    this.knownSubdomains.add(subdomain);
  }

  // Проверка URL на принадлежность к разрешенным субдоменам
  validateURL(url) {
    try {
      const parsedUrl = new URL(url);
      const hostname = parsedUrl.hostname;
      
      // Проверяем, является ли домен нашим субдоменом
      if (!hostname.endsWith(`.${this.rootDomain}`)) {
        return {
          valid: false,
          reason: `Домен ${hostname} не принадлежит ${this.rootDomain}`
        };
      }

      // Извлекаем субдомен
      const subdomain = hostname.replace(`.${this.rootDomain}`, '');
      
      // Проверяем, зарегистрирован ли субдомен
      if (!this.knownSubdomains.has(subdomain)) {
        return {
          valid: false,
          reason: `Субдомен ${subdomain} не зарегистрирован`
        };
      }

      // Проверяем IP-адрес (в реальности это требует серверной проверки)
      return {
        valid: true,
        subdomain,
        hostname
      };
    } catch (error) {
      return {
        valid: false,
        reason: `Невалидный URL: ${error.message}`
      };
    }
  }

  // Безопасный fetch с проверкой субдомена
  async secureFetch(url, options = {}) {
    const validation = this.validateURL(url);
    if (!validation.valid) {
      throw new Error(`Небезопасный URL: ${validation.reason}`);
    }

    // Добавляем заголовки безопасности
    const secureOptions = {
      ...options,
      headers: {
        ...options.headers,
        'Sec-Fetch-Site': 'same-site', // или 'cross-site' в зависимости от контекста
        'Sec-Fetch-Mode': 'cors',
        'Sec-Fetch-Dest': 'empty'
      }
    };

    // Добавляем таймаут для защиты от долгих запросов
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.requestTimeout);
    
    try {
      const response = await fetch(url, {
        ...secureOptions,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === 'AbortError') {
        throw new Error('Таймаут запроса - возможная DNS Rebinding атака');
      }
      throw error;
    }
  }

  // Проверка подозрительных паттернов
  checkSuspiciousPatterns(url, previousUrls = []) {
    // Проверяем количество редиректов
    if (previousUrls.length > this.maxRedirects) {
      return {
        suspicious: true,
        reason: `Слишком много редиректов: ${previousUrls.length}`
      };
    }

    // Проверяем, не происходит ли переход с доверенного на недоверенный домен
    const currentDomain = new URL(url).hostname;
    const hasUntrustedTransition = previousUrls.some(prevUrl => {
      const prevDomain = new URL(prevUrl).hostname;
      return this.isTrustedDomain(prevDomain) && !this.isTrustedDomain(currentDomain);
    });

    if (hasUntrustedTransition) {
      return {
        suspicious: true,
        reason: 'Обнаружен переход с доверенного на недоверенный домен'
      };
    }

    return { suspicious: false };
  }

  isTrustedDomain(domain) {
    return domain.endsWith(`.${this.rootDomain}`) && 
           this.knownSubdomains.has(domain.replace(`.${this.rootDomain}`, ''));
  }
}

// Использование
const dnsProtection = new DNSRebindingProtection('example.com');

// Регистрируем известные субдомены
dnsProtection.registerSubdomain('app');
dnsProtection.registerSubdomain('api');
dnsProtection.registerSubdomain('cdn');

// Проверка URL
const validation = dnsProtection.validateURL('https://api.example.com/data');
console.log('Валидация URL:', validation);

// Безопасный запрос
try {
  // const response = await dnsProtection.secureFetch('https://api.example.com/users');
  console.log('Безопасный запрос выполнен');
} catch (error) {
  console.error('Ошибка безопасного запроса:', error);
}
```

### Subdomain Takeover защита

```javascript
// Класс для защиты от Subdomain Takeover атак
class SubdomainTakeoverProtection {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.activeSubdomains = new Set();
    this.dnsRecords = new Map();
    this.monitoringInterval = null;
  }

  // Регистрация активного субдомена
  registerActiveSubdomain(subdomain, serviceType) {
    this.activeSubdomains.add(subdomain);
    this.dnsRecords.set(subdomain, {
      serviceType,
      lastChecked: Date.now(),
      isActive: true
    });
  }

  // Проверка субдомена на уязвимость к захвату
  async checkSubdomainVulnerability(subdomain) {
    const fullDomain = `${subdomain}.${this.rootDomain}`;
    
    try {
      // Проверяем, существует ли субдомен
      const response = await fetch(`https://${fullDomain}`, { 
        method: 'HEAD',
        mode: 'no-cors' // Обход CORS для проверки доступности
      });

      // Если субдомен не зарегистрирован в нашей системе, но отвечает
      if (!this.activeSubdomains.has(subdomain)) {
        // Проверяем тип ответа для определения вероятного сервиса
        const isVulnerable = await this.detectVulnerableService(fullDomain);
        
        return {
          vulnerable: isVulnerable,
          reason: 'Субдомен не зарегистрирован в системе, но отвечает',
          serviceType: await this.detectServiceType(fullDomain)
        };
      }

      return {
        vulnerable: false,
        reason: 'Субдомен зарегистрирован в системе'
      };
    } catch (error) {
      // Если субдомен не отвечает, проверяем DNS записи
      const dnsStatus = await this.checkDNSRecord(subdomain);
      
      if (!dnsStatus.exists && this.activeSubdomains.has(subdomain)) {
        return {
          vulnerable: true,
          reason: 'DNS запись удалена, но субдомен все еще зарегистрирован в системе'
        };
      }
      
      return {
        vulnerable: false,
        reason: 'Субдомен не отвечает или не существует'
      };
    }
  }

  // Проверка DNS записи (упрощенная версия)
  async checkDNSRecord(subdomain) {
    // В реальности это требует серверной проверки DNS
    // Здесь мы симулируем проверку
    const exists = this.dnsRecords.has(subdomain);
    return {
      exists,
      record: exists ? this.dnsRecords.get(subdomain) : null
    };
  }

  // Определение типа сервиса (упрощенная версия)
  async detectServiceType(domain) {
    try {
      const response = await fetch(`https://${domain}`, { 
        method: 'GET',
        mode: 'no-cors'
      });
      
      // В реальности нужно проверять заголовки ответа, чтобы определить сервис
      // Здесь возвращаем 'unknown' для демонстрации
      return 'unknown';
    } catch (error) {
      return 'not_responding';
    }
  }

  // Обнаружение уязвимых сервисов
  async detectVulnerableService(domain) {
    try {
      const response = await fetch(`https://${domain}`, { 
        method: 'GET',
        mode: 'no-cors'
      });
      
      // В реальности проверяем ответ сервера на признаки уязвимых сервисов
      // Например, отсутствие контента, специфические заголовки и т.д.
      
      // Упрощенная проверка
      return false; // В реальности это требует сложной логики
    } catch (error) {
      return false;
    }
  }

  // Регулярная проверка всех субдоменов
  startMonitoring(interval = 3600000) { // раз в час
    this.monitoringInterval = setInterval(async () => {
      for (const subdomain of this.activeSubdomains) {
        const vulnerability = await this.checkSubdomainVulnerability(subdomain);
        
        if (vulnerability.vulnerable) {
          console.warn(`Обнаружена уязвимость субдомена ${subdomain}:`, vulnerability);
          this.handleVulnerability(subdomain, vulnerability);
        }
      }
    }, interval);
  }

  // Обработка обнаруженной уязвимости
  handleVulnerability(subdomain, vulnerability) {
    // В реальности это может включать:
    // - отправку уведомления администратору
    // - автоматическое удаление субдомена
    // - логирование инцидента
    console.error(`Уязвимость субдомена ${subdomain} требует немедленного внимания!`);
  }

  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
  }
}

// Использование
const takeoverProtection = new SubdomainTakeoverProtection('example.com');

// Регистрируем активные субдомены
takeoverProtection.registerActiveSubdomain('app', 'web-application');
takeoverProtection.registerActiveSubdomain('api', 'api-server');
takeoverProtection.registerActiveSubdomain('cdn', 'content-delivery-network');

// Проверка отдельного субдомена
takeoverProtection.checkSubdomainVulnerability('app')
  .then(result => console.log('Результат проверки app:', result));

// Запуск мониторинга
// takeoverProtection.startMonitoring();
```

## Лучшие практики безопасности субдоменов

### 1. Content Security Policy для субдоменов

```javascript
// Класс для управления CSP политиками в субдоменах
class SubdomainCSPManager {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.cspPolicies = new Map();
  }

  // Установка CSP политики для субдомена
  setCSP(subdomain, policy) {
    this.cspPolicies.set(subdomain, {
      ...policy,
      timestamp: Date.now()
    });
  }

  // Генерация CSP заголовка для субдомена
  generateCSPHeader(subdomain) {
    const policy = this.cspPolicies.get(subdomain);
    if (!policy) {
      // Политика по умолчанию для незарегистрированных субдоменов
      return this.getDefaultCSP();
    }

    const directives = [];

    // Основные директивы
    if (policy.defaultSrc) {
      directives.push(`default-src ${policy.defaultSrc.join(' ')}`);
    }
    if (policy.scriptSrc) {
      directives.push(`script-src ${policy.scriptSrc.join(' ')}`);
    }
    if (policy.styleSrc) {
      directives.push(`style-src ${policy.styleSrc.join(' ')}`);
    }
    if (policy.imgSrc) {
      directives.push(`img-src ${policy.imgSrc.join(' ')}`);
    }
    if (policy.connectSrc) {
      directives.push(`connect-src ${policy.connectSrc.join(' ')}`);
    }
    if (policy.frameAncestors) {
      directives.push(`frame-ancestors ${policy.frameAncestors.join(' ')}`);
    }

    return directives.join('; ');
  }

  // Политика по умолчанию
  getDefaultCSP() {
    return "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https://api.example.com; frame-ancestors 'none'; base-uri 'self';";
  }

  // Проверка безопасности CSP
  validateCSP(subdomain) {
    const policy = this.cspPolicies.get(subdomain);
    if (!policy) {
      return {
        secure: false,
        issues: ['Нет CSP политики для субдомена']
      };
    }

    const issues = [];

    // Проверяем потенциально небезопасные директивы
    if (policy.scriptSrc && policy.scriptSrc.includes("'unsafe-inline'")) {
      issues.push("Использование 'unsafe-inline' в script-src снижает безопасность");
    }

    if (policy.scriptSrc && policy.scriptSrc.includes("'unsafe-eval'")) {
      issues.push("Использование 'unsafe-eval' в script-src создает XSS уязвимости");
    }

    if (policy.defaultSrc && policy.defaultSrc.includes("'unsafe-inline'")) {
      issues.push("Использование 'unsafe-inline' в default-src снижает безопасность");
    }

    return {
      secure: issues.length === 0,
      issues,
      policy: policy
    };
  }
}

// Использование
const cspManager = new SubdomainCSPManager('example.com');

// Устанавливаем политики для разных субдоменов
cspManager.setCSP('app', {
  defaultSrc: ["'self'"],
  scriptSrc: ["'self'", "'unsafe-inline'"], // Может потребоваться для старых приложений
  styleSrc: ["'self'", "'unsafe-inline'"],
  imgSrc: ["'self'", "data:", "https:"],
  connectSrc: ["'self'", "https://api.example.com"],
  frameAncestors: ["'none'"]
});

cspManager.setCSP('api', {
  defaultSrc: ["'none'"], // API не должен загружать внешние ресурсы
  scriptSrc: ["'none'"],
  styleSrc: ["'none'"],
  imgSrc: ["'none'"],
  connectSrc: ["'self'"],
  frameAncestors: ["'none'"]
});

cspManager.setCSP('admin', {
  defaultSrc: ["'self'"],
  scriptSrc: ["'self'"],
  styleSrc: ["'self'"],
  imgSrc: ["'self'", "data:"],
  connectSrc: ["'self'"],
  frameAncestors: ["'none'"]
});

// Проверка безопасности
const appValidation = cspManager.validateCSP('app');
console.log('Валидация CSP для app субдомена:', appValidation);

// Генерация заголовка
const appCSP = cspManager.generateCSPHeader('app');
console.log('CSP заголовок для app:', appCSP);
```

### 2. Управление сессиями в субдоменах

```javascript
// Класс для безопасного управления сессиями в субдоменах
class SubdomainSessionManager {
  constructor(rootDomain) {
    this.rootDomain = rootDomain;
    this.sessions = new Map();
    this.subdomainScopes = new Map();
  }

  // Установка сессии с ограничением по субдомену
  createSession(userId, subdomain, options = {}) {
    const sessionId = this.generateSessionId();
    const sessionData = {
      id: sessionId,
      userId,
      subdomain,
      createdAt: Date.now(),
      expiresAt: Date.now() + (options.maxAge || 3600000), // 1 час по умолчанию
      permissions: options.permissions || [],
      scope: options.scope || 'subdomain' // 'subdomain', 'domain', 'global'
    };

    this.sessions.set(sessionId, sessionData);
    this.linkSessionToSubdomain(sessionId, subdomain);

    return sessionId;
  }

  // Привязка сессии к субдомену
  linkSessionToSubdomain(sessionId, subdomain) {
    if (!this.subdomainScopes.has(subdomain)) {
      this.subdomainScopes.set(subdomain, new Set());
    }
    this.subdomainScopes.get(subdomain).add(sessionId);
  }

  // Проверка сессии для конкретного субдомена
  validateSession(sessionId, requestingSubdomain) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return { valid: false, reason: 'Сессия не найдена' };
    }

    if (session.expiresAt < Date.now()) {
      this.destroySession(sessionId);
      return { valid: false, reason: 'Сессия истекла' };
    }

    // Проверяем, соответствует ли субдомен области действия сессии
    switch (session.scope) {
      case 'subdomain':
        if (session.subdomain !== requestingSubdomain) {
          return { 
            valid: false, 
            reason: `Сессия ограничена субдоменом ${session.subdomain}` 
          };
        }
        break;
        
      case 'domain':
        // Сессия может использоваться в любом субдомене
        break;
        
      case 'global':
        // Сессия может использоваться везде
        break;
        
      default:
        return { valid: false, reason: 'Неизвестная область действия сессии' };
    }

    return { 
      valid: true, 
      userId: session.userId,
      permissions: session.permissions 
    };
  }

  // Уничтожение сессии
  destroySession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      // Удаляем из субдоменной области
      if (this.subdomainScopes.has(session.subdomain)) {
        this.subdomainScopes.get(session.subdomain).delete(sessionId);
      }
      this.sessions.delete(sessionId);
    }
  }

  // Уничтожение всех сессий для субдомена
  destroyAllSubdomainSessions(subdomain) {
    const sessionIds = this.subdomainScopes.get(subdomain);
    if (sessionIds) {
      for (const sessionId of sessionIds) {
        this.sessions.delete(sessionId);
      }
      this.subdomainScopes.delete(subdomain);
    }
  }

  // Генерация ID сессии
  generateSessionId() {
    return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Получение статистики по субдомену
  getSubdomainStats(subdomain) {
    const sessionIds = this.subdomainScopes.get(subdomain) || new Set();
    const activeSessions = Array.from(sessionIds).filter(id => {
      const session = this.sessions.get(id);
      return session && session.expiresAt > Date.now();
    });

    return {
      totalSessions: sessionIds.size,
      activeSessions: activeSessions.length,
      subdomain
    };
  }
}

// Использование
const sessionManager = new SubdomainSessionManager('example.com');

// Создание сессий для разных субдоменов
const appSessionId = sessionManager.createSession(
  'user123', 
  'app', 
  { 
    maxAge: 7200000, // 2 часа
    permissions: ['read:app', 'write:preferences'],
    scope: 'subdomain'
  }
);

const apiSessionId = sessionManager.createSession(
  'user123', 
  'api', 
  { 
    maxAge: 1800000, // 30 минут
    permissions: ['read:api', 'write:data'],
    scope: 'domain' // Может использоваться в любом субдомене
  }
);

// Проверка сессии
const appValidation = sessionManager.validateSession(appSessionId, 'app');
console.log('Валидация сессии для app:', appValidation);

const crossValidation = sessionManager.validateSession(apiSessionId, 'admin');
console.log('Валидация API сессии для admin:', crossValidation);

// Получение статистики
const appStats = sessionManager.getSubdomainStats('app');
console.log('Статистика субдомена app:', appStats);
```

## Заключение

Безопасность субдоменов требует комплексного подхода к управлению доступом, изоляции данных и защите от специфических атак. Правильная реализация механизмов безопасности субдоменов помогает предотвратить распространение уязвимостей между различными частями приложения и защищает конфиденциальные данные пользователей.

> [!tip] Совет
> Регулярно проверяйте зарегистрированные субдомены на уязвимости и используйте автоматизированные инструменты для мониторинга безопасности.

> [!warning] Важно
> Неправильная настройка безопасности субдоменов может привести к захвату субдоменов и распространению атак по всей системе.

> [!note] Примечание
> Современные подходы к безопасности субдоменов включают использование DNSSEC, HSTS и других передовых технологий защиты.