---
aliases: [Domain Isolation, Изоляция доменов, Защита доменов]
tags: [security, domain-isolation, frontend-security, browser-security]
---

# Изоляция-доменов

## Введение

Изоляция доменов - это фундаментальный принцип безопасности в веб-разработке, который обеспечивает разделение ресурсов, данных и выполнения кода между различными доменами. Этот механизм предотвращает несанкционированный доступ к конфиденциальной информации и защищает пользователей от межсайтовых атак.

## Основы изоляции доменов

### Same-Origin Policy

Same-Origin Policy (SOP) - это основной механизм изоляции в веб-браузерах. Он определяет, когда один документ или скрипт может взаимодействовать с другим документом или скриптом в зависимости от их источника (origin).

Источник определяется тремя компонентами:
- **Протокол** (http, https)
- **Домен** (example.com)
- **Порт** (80, 443, 8080)

```javascript
// Функция для определения принадлежности к одному источнику
function isSameOrigin(url1, url2) {
  try {
    const parsed1 = new URL(url1);
    const parsed2 = new URL(url2);
    
    return parsed1.protocol === parsed2.protocol &&
           parsed1.hostname === parsed2.hostname &&
           parsed1.port === parsed2.port;
  } catch (error) {
    console.error('Ошибка при парсинге URL:', error);
    return false;
  }
}

// Примеры
console.log(isSameOrigin('https://example.com', 'https://example.com/page')); // true
console.log(isSameOrigin('https://example.com', 'https://api.example.com')); // false (разные домены)
console.log(isSameOrigin('https://example.com', 'http://example.com')); // false (разные протоколы)
```

### Области изоляции в браузере

Изоляция доменов охватывает несколько аспектов:

1. **Хранилище данных** (localStorage, sessionStorage, IndexedDB)
2. **Cookies**
3. **DOM доступ**
4. **Сетевые запросы**
5. **Шрифты и ресурсы**

## Механизмы изоляции доменов

### 1. Изоляция хранилища

```javascript
// Пример изоляции localStorage между доменами
class DomainStorageIsolation {
  constructor(domainNamespace) {
    this.namespace = domainNamespace;
    this.prefix = `domain_${this.namespace}_`;
  }

  setItem(key, value) {
    const prefixedKey = this.prefix + key;
    try {
      localStorage.setItem(prefixedKey, JSON.stringify(value));
    } catch (error) {
      if (error.name === 'QuotaExceededError') {
        console.error('Превышена квота хранилища');
        this.handleQuotaExceeded();
      } else {
        console.error('Ошибка при сохранении в localStorage:', error);
      }
    }
  }

  getItem(key) {
    const prefixedKey = this.prefix + key;
    try {
      const item = localStorage.getItem(prefixedKey);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('Ошибка при чтении из localStorage:', error);
      return null;
    }
  }

  removeItem(key) {
    const prefixedKey = this.prefix + key;
    localStorage.removeItem(prefixedKey);
  }

  clear() {
    // Удаляем только данные с нашим префиксом
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.prefix)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
  }

  handleQuotaExceeded() {
    // Очистка устаревших данных или уведомление пользователя
    this.cleanupExpiredData();
  }

  cleanupExpiredData() {
    // Очистка данных с истекшим сроком действия
    const now = Date.now();
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.prefix) && key.includes('_expiry_')) {
        try {
          const data = JSON.parse(localStorage.getItem(key));
          if (data && data.expiry && data.expiry < now) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Пропускаем некорректные данные
        }
      }
    }
  }
}

// Использование для разных доменов
const mainDomainStorage = new DomainStorageIsolation('main.example.com');
const apiDomainStorage = new DomainStorageIsolation('api.example.com');

mainDomainStorage.setItem('userPreferences', { theme: 'dark', lang: 'ru' });
apiDomainStorage.setItem('apiToken', { token: 'secret-token', expiry: Date.now() + 3600000 });
```

### 2. Изоляция cookies

```javascript
// Управление cookies с учетом изоляции доменов
class DomainCookieIsolation {
  constructor(domain) {
    this.domain = domain;
  }

  setCookie(name, value, options = {}) {
    const cookieParts = [
      `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
    ];

    // Опции безопасности
    if (options.expires) {
      cookieParts.push(`Expires=${options.expires.toUTCString()}`);
    }
    if (options.maxAge) {
      cookieParts.push(`Max-Age=${options.maxAge}`);
    }
    if (options.domain) {
      cookieParts.push(`Domain=${options.domain}`);
    } else {
      // Ограничиваем домен для изоляции
      cookieParts.push(`Domain=${this.domain}`);
    }
    if (options.path) {
      cookieParts.push(`Path=${options.path}`);
    } else {
      cookieParts.push('Path=/'); // по умолчанию для всего домена
    }
    if (options.secure) {
      cookieParts.push('Secure');
    }
    if (options.httpOnly) {
      cookieParts.push('HttpOnly');
    }
    if (options.sameSite) {
      cookieParts.push(`SameSite=${options.sameSite}`);
    }

    document.cookie = cookieParts.join('; ');
  }

  getCookie(name) {
    const nameEQ = encodeURIComponent(name) + '=';
    const ca = document.cookie.split(';');
    
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) {
        return decodeURIComponent(c.substring(nameEQ.length, c.length));
      }
    }
    return null;
  }

  deleteCookie(name, path = '/', domain = this.domain) {
    document.cookie = `${name}=; Path=${path}; Domain=${domain}; Max-Age=-1`;
  }

  // Получение всех cookies для домена
  getAllCookies() {
    const cookies = {};
    const allCookies = document.cookie.split(';');
    
    allCookies.forEach(cookie => {
      const [name, value] = cookie.trim().split('=');
      if (name && value) {
        cookies[decodeURIComponent(name)] = decodeURIComponent(value);
      }
    });
    
    return cookies;
  }
}

// Использование для разных доменов
const mainDomainCookies = new DomainCookieIsolation('example.com');
const apiDomainCookies = new DomainCookieIsolation('api.example.com');

// Установка cookies с изоляцией
mainDomainCookies.setCookie('user_session', 'session_id_123', {
  secure: true,
  httpOnly: true,
  sameSite: 'Strict',
  maxAge: 3600 // 1 час
});

apiDomainCookies.setCookie('api_token', 'token_456', {
  secure: true,
  httpOnly: true,
  sameSite: 'Lax',
  maxAge: 7200 // 2 часа
});
```

### 3. Изоляция iframe и вложенного контента

```javascript
// Класс для безопасного создания изолированных iframe
class SecureIframeIsolation {
  constructor() {
    this.activeIframes = new Map();
  }

  createSecureIframe(src, containerId, options = {}) {
    const iframe = document.createElement('iframe');
    
    // Устанавливаем безопасные атрибуты для изоляции
    iframe.src = src;
    
    // Атрибуты песочницы для усиления изоляции
    const sandboxOptions = [
      'allow-scripts',      // Разрешить выполнение скриптов
      'allow-same-origin',  // Разрешить тот же источник
      'allow-forms',        // Разрешить формы (если необходимо)
      'allow-popups',       // Разрешить всплывающие окна (если необходимо)
      'allow-top-navigation-by-user-activation' // Разрешить навигацию только по действию пользователя
    ];
    
    if (options.allowSameOrigin !== false) {
      // Для максимальной изоляции можно исключить 'allow-same-origin'
      iframe.sandbox = sandboxOptions.join(' ');
    } else {
      // Если требуется полная изоляция, исключаем тот же источник
      iframe.sandbox = sandboxOptions.filter(opt => opt !== 'allow-same-origin').join(' ');
    }
    
    // Добавляем дополнительные меры безопасности
    iframe.setAttribute('referrerpolicy', 'no-referrer');
    iframe.setAttribute('csp', this.getDefaultCSP());
    
    // Устанавливаем атрибуты доступа
    if (options.allowedFeatures) {
      iframe.setAttribute('allow', options.allowedFeatures.join('; '));
    } else {
      iframe.setAttribute('allow', 'encrypted-media; picture-in-picture');
    }
    
    // Сохраняем iframe для последующего управления
    const iframeId = this.generateIframeId();
    this.activeIframes.set(iframeId, iframe);
    
    // Добавляем в контейнер
    const container = document.getElementById(containerId);
    if (container) {
      container.appendChild(iframe);
    }
    
    return { iframe, iframeId };
  }

  getDefaultCSP() {
    return "default-src 'none'; script-src 'self'; style-src 'self'; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self';";
  }

  generateIframeId() {
    return `iframe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  destroyIframe(iframeId) {
    const iframe = this.activeIframes.get(iframeId);
    if (iframe && iframe.parentNode) {
      iframe.parentNode.removeChild(iframe);
      this.activeIframes.delete(iframeId);
    }
  }

  // Проверка изоляции iframe
  validateIframeIsolation(iframe) {
    const issues = [];
    
    // Проверяем, что iframe использует sandbox
    if (!iframe.sandbox) {
      issues.push('Iframe не использует атрибут sandbox');
    } else {
      const sandboxTokens = iframe.sandbox.split(' ');
      
      // Проверяем наличие потенциально опасных опций
      if (sandboxTokens.includes('allow-top-navigation')) {
        issues.push('Iframe позволяет полную навигацию сверху');
      }
      
      if (sandboxTokens.includes('allow-popups-to-escape-sandbox')) {
        issues.push('Iframe может создавать всплывающие окна вне песочницы');
      }
    }
    
    return {
      isSecure: issues.length === 0,
      issues
    };
  }
}

// Использование
const iframeManager = new SecureIframeIsolation();

const { iframe, iframeId } = iframeManager.createSecureIframe(
  'https://trusted-partner.com/content',
  'content-container',
  {
    allowedFeatures: ['geolocation', 'camera', 'microphone']
  }
);

// Проверка изоляции
const validation = iframeManager.validateIframeIsolation(iframe);
if (!validation.isSecure) {
  console.warn('Проблемы с изоляцией iframe:', validation.issues);
}
```

## Современные методы изоляции доменов

### 1. Cross-Origin Opener Policy (COOP)

```javascript
// Управление политикой COOP для изоляции доменов
class COOPManager {
  constructor() {
    this.policies = {
      sameOrigin: 'same-origin',
      sameOriginAllowPopups: 'same-origin-allow-popups',
      unsafeNone: 'unsafe-none'
    };
  }

  setPolicy(policyName, reportUri = null) {
    if (!this.policies[policyName]) {
      throw new Error(`Неизвестная политика COOP: ${policyName}`);
    }

    let headerValue = this.policies[policyName];
    if (reportUri) {
      headerValue += `; report-to ${reportUri}`;
    }

    // В реальном приложении заголовок устанавливается на сервере
    console.log(`Установка COOP заголовка: ${headerValue}`);
    
    // Для демонстрации в браузере
    this.applyCOOPInBrowser(policyName);
  }

  applyCOOPInBrowser(policyName) {
    // Проверяем текущее состояние
    try {
      const openerExists = window.opener !== null;
      let openerAccessible = false;
      
      if (openerExists) {
        try {
          // Пытаемся получить доступ к opener
          const openerLocation = window.opener.location.href;
          openerAccessible = true;
        } catch (e) {
          // Доступ ограничен политикой
          openerAccessible = false;
        }
      }
      
      console.log({
        openerExists,
        openerAccessible,
        policy: policyName
      });
    } catch (error) {
      console.error('Ошибка проверки COOP:', error);
    }
  }

  validateCOOPIsolation() {
    // Проверяем, изолированы ли мы от других окон
    const isolationStatus = {
      openerIsolation: window.opener === null || this.isOpenerIsolated(),
      hasNoReferrer: document.referrer === '' || !document.referrer.includes(window.location.hostname)
    };
    
    return isolationStatus;
  }

  isOpenerIsolated() {
    try {
      // Если opener изолирован, мы не должны иметь к нему доступа
      if (window.opener) {
        window.opener.location.href; // Это вызовет ошибку, если изолированы
        return false;
      }
      return true;
    } catch (e) {
      return true; // Доступ ограничен, значит изолированы
    }
  }
}

// Использование
const coopManager = new COOPManager();
coopManager.setPolicy('sameOrigin');
const isolationStatus = coopManager.validateCOOPIsolation();
console.log('Статус изоляции COOP:', isolationStatus);
```

### 2. Cross-Origin Embedder Policy (COEP)

```javascript
// Управление политикой COEP для изоляции встраиваемых ресурсов
class COEPManager {
  constructor() {
    this.policies = {
      requireCorp: 'require-corp',
      unsafeNone: 'unsafe-none'
    };
  }

  setPolicy(policyName) {
    if (!this.policies[policyName]) {
      throw new Error(`Неизвестная политика COEP: ${policyName}`);
    }

    // В реальном приложении заголовок устанавливается на сервере
    console.log(`Установка COEP заголовка: ${this.policies[policyName]}`);
    
    // Проверяем возможность встраивания ресурсов
    this.validateResourceEmbedding(policyName);
  }

  validateResourceEmbedding(policyName) {
    const validation = {
      policy: policyName,
      canEmbedCrossOrigin: policyName === 'unsafeNone',
      requiresCORS: policyName === 'requireCorp'
    };

    if (validation.requiresCORS) {
      console.log('Требуется CORS для встраивания ресурсов из других источников');
    }

    return validation;
  }

  async testResourceEmbedding(url) {
    // Проверяем возможность загрузки ресурса с учетом COEP
    try {
      const response = await fetch(url, {
        method: 'HEAD' // Только заголовки
      });

      // Проверяем, есть ли заголовки CORS
      const corsHeaders = [
        'Access-Control-Allow-Origin',
        'Access-Control-Allow-Credentials',
        'Timing-Allow-Origin'
      ];

      const hasCORS = corsHeaders.some(header => response.headers.get(header) !== null);

      return {
        url,
        status: response.status,
        hasCORS,
        canEmbed: response.status === 200 && hasCORS
      };
    } catch (error) {
      console.error(`Ошибка проверки ресурса ${url}:`, error);
      return { url, error: error.message };
    }
  }
}

// Использование
const coepManager = new COEPManager();
coepManager.setPolicy('requireCorp');

// Тестирование встраивания ресурсов
coepManager.testResourceEmbedding('https://api.example.com/data')
  .then(result => console.log('Результат проверки ресурса:', result));
```

### 3. Origin Isolation

```javascript
// Класс для проверки и обеспечения изоляции источника
class OriginIsolationManager {
  constructor() {
    this.isolationLevel = 'none';
  }

  enableOriginIsolation() {
    // Для включения изоляции источника необходим заголовок:
    // Cross-Origin-Opener-Policy: same-origin
    // Cross-Origin-Embedder-Policy: require-corp
    // Cross-Origin-Resource-Policy: same-origin
    
    this.isolationLevel = 'full';
    
    console.log('Изоляция источника включена');
    return this.validateIsolation();
  }

  validateIsolation() {
    const validation = {
      isOriginIsolated: this.isOriginIsolated(),
      hasCOOP: this.hasCOOP(),
      hasCOEP: this.hasCOEP(),
      hasCORP: this.hasCORP(),
      crossOriginIsolated: this.isCrossOriginIsolated()
    };

    return validation;
  }

  isOriginIsolated() {
    // Проверяем, изолирован ли текущий источник
    try {
      // Если мы можем получить доступ к глобальным объектам других источников,
      // изоляция не установлена
      if (window.opener) {
        try {
          // Пытаемся получить доступ к opener
          window.opener.location.href;
          return false; // Доступ есть, изоляции нет
        } catch (e) {
          // Доступ ограничен, возможно есть изоляция
          return true;
        }
      }
      return true; // Нет opener, возможно изолированы
    } catch (e) {
      return true;
    }
  }

  hasCOOP() {
    // Проверка наличия COOP (обычно на сервере)
    return document.createElement('iframe').sandbox !== undefined;
  }

  hasCOEP() {
    // Проверка наличия COEP
    try {
      return window.crossOriginIsolated !== undefined;
    } catch (e) {
      return false;
    }
  }

  hasCORP() {
    // Проверка CORP возможна только через анализ ответов
    return true; // Упрощенная проверка
  }

  isCrossOriginIsolated() {
    // Проверка полной изоляции кросс-оригина
    return typeof window.crossOriginIsolated !== 'undefined' && window.crossOriginIsolated;
  }

  getIsolationReport() {
    const validation = this.validateIsolation();
    
    const report = {
      timestamp: new Date().toISOString(),
      origin: window.location.origin,
      validation,
      recommendations: []
    };

    if (!validation.isOriginIsolated) {
      report.recommendations.push('Включите Cross-Origin-Opener-Policy');
    }
    if (!validation.hasCOEP) {
      report.recommendations.push('Включите Cross-Origin-Embedder-Policy');
    }
    if (!validation.crossOriginIsolated) {
      report.recommendations.push('Проверьте настройки изоляции источника');
    }

    return report;
  }
}

// Использование
const originIsolation = new OriginIsolationManager();
const report = originIsolation.getIsolationReport();
console.log('Отчет об изоляции источника:', report);

if (report.recommendations.length > 0) {
  console.log('Рекомендации по улучшению изоляции:', report.recommendations);
}
```

## Лучшие практики изоляции доменов

### 1. Поддоменная изоляция

```javascript
// Класс для управления изоляцией поддоменов
class SubdomainIsolationManager {
  constructor(mainDomain) {
    this.mainDomain = mainDomain;
    this.subdomainCookies = new Map();
    this.subdomainStorage = new Map();
  }

  // Управление cookies для поддоменов
  setSubdomainCookie(subdomain, name, value, options = {}) {
    const fullDomain = `${subdomain}.${this.mainDomain}`;
    
    // Устанавливаем cookie только для конкретного поддомена
    const cookieParts = [
      `${encodeURIComponent(name)}=${encodeURIComponent(value)}`,
      `Domain=${fullDomain}`,
      'Path=/',
      'Secure',
      'HttpOnly',
      'SameSite=Lax'
    ];

    document.cookie = cookieParts.join('; ');
  }

  // Проверка принадлежности домена
  isSubdomain(domainToCheck) {
    return domainToCheck.endsWith(`.${this.mainDomain}`) && 
           domainToCheck !== this.mainDomain;
  }

  // Управление безопасными доменными префиксами
  validateDomainAccess(requestingDomain, targetDomain) {
    // Проверяем, является ли целевой домен поддоменом
    const isTargetSubdomain = this.isSubdomain(targetDomain);
    const isRequestingSubdomain = this.isSubdomain(requestingDomain);
    
    // Базовая проверка: только поддомены могут взаимодействовать с другими поддоменами
    if (isTargetSubdomain && isRequestingSubdomain) {
      // Проверяем, принадлежат ли поддомены одному корневому домену
      const targetMainDomain = targetDomain.split('.').slice(-2).join('.');
      const requestMainDomain = requestingDomain.split('.').slice(-2).join('.');
      
      return targetMainDomain === requestMainDomain;
    }
    
    // Основной домен может взаимодействовать с поддоменами, но не наоборот
    if (requestingDomain === this.mainDomain && isTargetSubdomain) {
      return true;
    }
    
    return false;
  }

  // Создание изолированного контекста для поддомена
  createSubdomainContext(subdomain) {
    return {
      subdomain,
      origin: `https://${subdomain}.${this.mainDomain}`,
      storage: new DomainStorageIsolation(`${subdomain}.${this.mainDomain}`),
      cookies: new DomainCookieIsolation(`${subdomain}.${this.mainDomain}`),
      
      canAccess(otherSubdomain) {
        return otherSubdomain === subdomain || 
               otherSubdomain === 'api'; // API поддомен может быть исключением
      }
    };
  }
}

// Использование
const subdomainManager = new SubdomainIsolationManager('example.com');

// Создание контекстов для разных поддоменов
const userContext = subdomainManager.createSubdomainContext('user');
const apiContext = subdomainManager.createSubdomainContext('api');
const adminContext = subdomainManager.createSubdomainContext('admin');

console.log('User может получить доступ к API:', userContext.canAccess('api')); // true (по правилам)
console.log('User может получить доступ к Admin:', userContext.canAccess('admin')); // false
```

### 2. Защита от DNS Rebinding

```javascript
// Класс для защиты от DNS Rebinding атак
class DNSRebindingProtection {
  constructor() {
    this.validOrigins = new Set();
    this.requestHistory = new Map();
    this.maxRedirects = 3;
  }

  addValidOrigin(origin) {
    this.validOrigins.add(origin);
  }

  async validateRequest(url) {
    const parsedUrl = new URL(url);
    const origin = `${parsedUrl.protocol}//${parsedUrl.hostname}`;
    
    // Проверяем, является ли домен валидным
    if (!this.validOrigins.has(origin)) {
      throw new Error(`Невалидный домен: ${origin}`);
    }

    // Проверяем историю запросов для обнаружения подозрительных паттернов
    const requestKey = this.getRequestKey(url);
    const history = this.requestHistory.get(requestKey) || [];
    
    // Проверяем количество редиректов
    if (history.length > this.maxRedirects) {
      throw new Error('Слишком много редиректов - возможна DNS Rebinding атака');
    }

    // Добавляем текущий запрос в историю
    history.push({
      timestamp: Date.now(),
      origin
    });
    
    this.requestHistory.set(requestKey, history);
    
    return true;
  }

  getRequestKey(url) {
    // Создаем ключ на основе домена и пути
    const parsed = new URL(url);
    return `${parsed.hostname}${parsed.pathname}`;
  }

  // Метод для проверки IP-адреса домена
  async verifyDomainIP(hostname) {
    // В реальном приложении это потребует серверной проверки
    // для предотвращения DNS Rebinding атак
    console.log(`Проверка IP-адреса для ${hostname} (требует серверной реализации)`);
    
    // Возвращаем true для демонстрации
    return true;
  }

  // Метод для очистки старой истории
  cleanupHistory(maxAge = 300000) { // 5 минут
    const now = Date.now();
    for (const [key, history] of this.requestHistory) {
      const recentHistory = history.filter(record => now - record.timestamp < maxAge);
      if (recentHistory.length === 0) {
        this.requestHistory.delete(key);
      } else {
        this.requestHistory.set(key, recentHistory);
      }
    }
  }
}

// Использование
const dnsProtection = new DNSRebindingProtection();
dnsProtection.addValidOrigin('https://api.example.com');
dnsProtection.addValidOrigin('https://cdn.example.com');

try {
  await dnsProtection.validateRequest('https://api.example.com/users');
  console.log('Запрос прошел проверку безопасности');
} catch (error) {
  console.error('Ошибка проверки безопасности запроса:', error);
}
```

## Заключение

Изоляция доменов - это критически важный аспект безопасности веб-приложений. Правильная реализация механизмов изоляции помогает предотвратить межсайтовые атаки, защитить конфиденциальные данные пользователей и обеспечить надежное разделение ресурсов между различными источниками.

> [!tip] Совет
> Используйте комбинацию CORS, CSP, COOP и COEP для максимальной изоляции доменов.

> [!warning] Важно
> Нарушение принципов изоляции доменов может привести к серьезным уязвимостям безопасности.

> [!note] Примечание
> Современные браузеры продолжают развивать механизмы изоляции доменов, включая Site Isolation и другие передовые технологии.