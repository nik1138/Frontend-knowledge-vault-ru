---
aliases: [Cross-Domain Security, Безопасность между доменами, Междоменная безопасность]
tags: [security, cross-domain, cors, frontend-security, browser-security]
---

# Безопасность-между-доменами

## Введение

Безопасность между доменами (cross-domain security) - это комплекс мер и механизмов, обеспечивающих безопасное взаимодействие между веб-приложениями, расположенными на разных доменах. Эта тема охватывает политику одинакового источника (Same-Origin Policy), CORS (Cross-Origin Resource Sharing), и другие методы безопасного междоменного взаимодействия.

## Основы междоменной безопасности

### Политика одинакового источника (Same-Origin Policy)

Same-Origin Policy - это основной механизм безопасности в веб-браузерах, который ограничивает возможность веб-страницы взаимодействовать с ресурсами из другого источника (origin). Источник определяется комбинацией протокола, домена и порта.

```javascript
// Функция для определения, являются ли два URL-адреса из одного источника
function isSameOrigin(url1, url2) {
  try {
    const parsed1 = new URL(url1);
    const parsed2 = new URL(url2);
    
    return parsed1.protocol === parsed2.protocol &&
           parsed1.hostname === parsed2.hostname &&
           parsed1.port === parsed2.port;
  } catch (error) {
    console.error('Ошибка при парсинге URL:', error);
    return false;
  }
}

// Примеры использования
console.log(isSameOrigin('https://example.com/page1', 'https://example.com/page2')); // true
console.log(isSameOrigin('https://example.com', 'http://example.com')); // false (разные протоколы)
console.log(isSameOrigin('https://example.com:8080', 'https://example.com:3000')); // false (разные порты)
```

### Уязвимости, предотвращаемые политикой Same-Origin

1. **Межсайтовый скриптинг (XSS)**
2. **Межсайтовая подделка запроса (CSRF)**
3. **Кража данных между доменами**
4. **Несанкционированный доступ к сессиям**

## CORS (Cross-Origin Resource Sharing)

CORS - это механизм, который позволяет веб-страницам делать запросы к другому домену, при этом обеспечивая безопасность.

### Основы CORS

```javascript
// Пример безопасного CORS запроса
class SecureCORSClient {
  constructor(baseURL, allowedOrigins = []) {
    this.baseURL = baseURL;
    this.allowedOrigins = allowedOrigins;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    };
  }

  async request(endpoint, options = {}) {
    const url = new URL(endpoint, this.baseURL).href;
    
    // Проверяем, является ли запрос кросс-доменным
    const requestOrigin = new URL(url);
    const currentOrigin = new URL(window.location.href);
    
    const isCrossOrigin = requestOrigin.origin !== currentOrigin.origin;
    
    if (isCrossOrigin && !this.isOriginAllowed(requestOrigin.origin)) {
      throw new Error(`Запрос к ${requestOrigin.origin} не разрешен`);
    }

    const config = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers
      }
    };

    // Добавляем дополнительные заголовки безопасности для кросс-доменных запросов
    if (isCrossOrigin) {
      config.mode = 'cors';
      config.credentials = 'include'; // или 'omit' в зависимости от требований безопасности
      
      // Добавляем заголовки для отслеживания безопасности
      config.headers['Sec-Fetch-Site'] = 'cross-site';
      config.headers['Sec-Fetch-Mode'] = 'cors';
      config.headers['Sec-Fetch-Dest'] = 'empty';
    }

    try {
      const response = await fetch(url, config);
      
      // Проверяем заголовки безопасности в ответе
      this.validateSecurityHeaders(response);
      
      if (!response.ok) {
        throw new Error(`HTTP ошибка! Статус: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Ошибка CORS запроса:', error);
      throw error;
    }
  }

  isOriginAllowed(origin) {
    return this.allowedOrigins.length === 0 || this.allowedOrigins.includes(origin);
  }

  validateSecurityHeaders(response) {
    // Проверяем наличие важных заголовков безопасности
    const corsHeaders = response.headers.get('Access-Control-Allow-Origin');
    const exposedHeaders = response.headers.get('Access-Control-Expose-Headers');
    
    if (!corsHeaders) {
      console.warn('Отсутствует заголовок CORS в ответе');
    }
  }
}

// Использование
const corsClient = new SecureCORSClient('https://api.example.com', [
  'https://trusted-site.com',
  'https://another-trusted-site.org'
]);

// Пример запроса
try {
  const data = await corsClient.request('/users/123');
  console.log('Данные пользователя:', data);
} catch (error) {
  console.error('Ошибка при получении данных:', error);
}
```

### CORS Preflight Requests

```javascript
// Обработка CORS preflight запросов на клиенте
class CORSRequestManager {
  constructor() {
    this.preflightCache = new Map();
    this.cacheTimeout = 300000; // 5 минут
  }

  async makeRequest(url, options) {
    const cacheKey = this.generateCacheKey(url, options);
    
    // Проверяем кэш preflight
    if (this.isPreflightCached(cacheKey)) {
      return this.executeRequest(url, options);
    }
    
    // Выполняем preflight запрос
    const preflightResult = await this.sendPreflightRequest(url, options);
    
    if (preflightResult) {
      // Кэшируем результат preflight
      this.cachePreflight(cacheKey);
      return this.executeRequest(url, options);
    } else {
      throw new Error('Предварительная проверка CORS не удалась');
    }
  }

  async sendPreflightRequest(url, options) {
    const preflightOptions = {
      method: 'OPTIONS',
      headers: {
        'Access-Control-Request-Method': options.method || 'GET',
        'Access-Control-Request-Headers': 'Content-Type, Authorization',
        'Origin': window.location.origin
      }
    };

    try {
      const response = await fetch(url, preflightOptions);
      return response.status === 200 && response.headers.get('Access-Control-Allow-Origin') === window.location.origin;
    } catch (error) {
      console.error('Ошибка preflight запроса:', error);
      return false;
    }
  }

  async executeRequest(url, options) {
    // Выполняем основной запрос
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Origin': window.location.origin
      }
    });

    return response;
  }

  generateCacheKey(url, options) {
    return `${options.method || 'GET'}_${url}`;
  }

  isPreflightCached(cacheKey) {
    const cached = this.preflightCache.get(cacheKey);
    return cached && Date.now() - cached.timestamp < this.cacheTimeout;
  }

  cachePreflight(cacheKey) {
    this.preflightCache.set(cacheKey, { timestamp: Date.now() });
  }
}
```

## Безопасные методы междоменного взаимодействия

### 1. PostMessage API

```javascript
// Безопасное использование PostMessage API
class SecurePostMessageManager {
  constructor(trustedOrigins = []) {
    this.trustedOrigins = trustedOrigins;
    this.messageHandlers = new Map();
    this.setupMessageListener();
  }

  setupMessageListener() {
    window.addEventListener('message', (event) => {
      // Проверяем источник сообщения
      if (!this.isTrustedOrigin(event.origin)) {
        console.warn(`Получено сообщение из ненадежного источника: ${event.origin}`);
        return;
      }

      // Проверяем структуру сообщения
      if (!this.isValidMessage(event.data)) {
        console.warn('Невалидное сообщение получено');
        return;
      }

      // Обрабатываем сообщение
      this.handleMessage(event.data, event.origin, event.source);
    });
  }

  isTrustedOrigin(origin) {
    // Проверяем, доверяем ли мы этому источнику
    return this.trustedOrigins.some(trustedOrigin => {
      if (typeof trustedOrigin === 'string') {
        return trustedOrigin === origin;
      } else if (trustedOrigin instanceof RegExp) {
        return trustedOrigin.test(origin);
      }
      return false;
    });
  }

  isValidMessage(data) {
    // Проверяем структуру сообщения
    return data && 
           typeof data === 'object' && 
           typeof data.type === 'string' &&
           data.type.length > 0;
  }

  handleMessage(data, origin, source) {
    const handler = this.messageHandlers.get(data.type);
    if (handler) {
      handler(data.payload, origin, source);
    } else {
      console.warn(`Нет обработчика для типа сообщения: ${data.type}`);
    }
  }

  sendMessage(targetWindow, message, targetOrigin = '*') {
    // Валидируем сообщение перед отправкой
    if (!this.isValidMessage(message)) {
      throw new Error('Невалидное сообщение для отправки');
    }

    targetWindow.postMessage(message, targetOrigin);
  }

  registerHandler(messageType, handler) {
    this.messageHandlers.set(messageType, handler);
  }

  unregisterHandler(messageType) {
    this.messageHandlers.delete(messageType);
  }
}

// Пример использования
const postMessageManager = new SecurePostMessageManager([
  'https://trusted-partner.com',
  /^https:\/\/.*\.ourcompany\.com$/  // регулярное выражение для поддоменов
]);

// Регистрируем обработчик
postMessageManager.registerHandler('USER_DATA_REQUEST', (payload, origin, source) => {
  console.log(`Получен запрос данных от ${origin}`);
  
  // Отправляем ответ
  postMessageManager.sendMessage(
    source, 
    { 
      type: 'USER_DATA_RESPONSE', 
      payload: { userId: 123, name: 'John Doe' } 
    },
    origin
  );
});
```

### 2. JSONP (с осторожностью)

```javascript
// Безопасная реализация JSONP (не рекомендуется для новых приложений)
class SecureJSONPClient {
  constructor() {
    this.callbackCounter = 0;
    this.timeout = 10000;
  }

  async request(url, callbackParam = 'callback') {
    return new Promise((resolve, reject) => {
      // Создаем уникальное имя callback функции
      const callbackName = `jsonp_callback_${Date.now()}_${++this.callbackCounter}`;
      
      // Устанавливаем таймаут
      const timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error('Таймаут JSONP запроса'));
      }, this.timeout);

      // Определяем callback функцию в глобальной области
      window[callbackName] = (data) => {
        cleanup();
        resolve(data);
      };

      // Создаем script тег
      const script = document.createElement('script');
      script.src = `${url}${url.includes('?') ? '&' : '?'}${callbackParam}=${callbackName}`;
      
      // Обработка ошибок
      script.onerror = () => {
        cleanup();
        reject(new Error('Ошибка загрузки JSONP скрипта'));
      };

      // Очистка после выполнения
      const cleanup = () => {
        clearTimeout(timeoutId);
        delete window[callbackName];
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
      };

      // Добавляем скрипт в DOM
      document.head.appendChild(script);
    });
  }
}

// Использование (только с доверенными источниками!)
// const jsonpClient = new SecureJSONPClient();
// jsonpClient.request('https://api.example.com/data')
//   .then(data => console.log(data))
//   .catch(error => console.error(error));
```

## Защита от междоменных атак

### 1. Проверка источника в заголовках

```javascript
// Класс для проверки безопасности кросс-доменных запросов
class CrossDomainSecurityValidator {
  constructor() {
    this.allowedDomains = new Set();
    this.blockedDomains = new Set();
  }

  addAllowedDomain(domain) {
    this.allowedDomains.add(this.normalizeDomain(domain));
  }

  addBlockedDomain(domain) {
    this.blockedDomains.add(this.normalizeDomain(domain));
  }

  validateRequest(url) {
    try {
      const parsedUrl = new URL(url);
      const domain = this.normalizeDomain(parsedUrl.hostname);
      
      // Проверяем, заблокирован ли домен
      if (this.blockedDomains.has(domain)) {
        throw new Error(`Домен ${domain} заблокирован`);
      }
      
      // Для безопасных доменов проверка может быть менее строгой
      if (this.isKnownSafeDomain(domain)) {
        return true;
      }
      
      // Для остальных доменов требуем явного разрешения
      if (!this.allowedDomains.has(domain)) {
        throw new Error(`Домен ${domain} не в списке разрешенных`);
      }
      
      return true;
    } catch (error) {
      console.error('Ошибка валидации запроса:', error);
      return false;
    }
  }

  normalizeDomain(domain) {
    return domain.toLowerCase().replace(/^www\./, '');
  }

  isKnownSafeDomain(domain) {
    // Список известных безопасных доменов (например, CDN)
    const knownSafeDomains = [
      'cdnjs.cloudflare.com',
      'code.jquery.com',
      'fonts.googleapis.com'
    ];
    return knownSafeDomains.includes(domain);
  }

  async secureFetch(url, options = {}) {
    if (!this.validateRequest(url)) {
      throw new Error('Запрос не прошел проверку безопасности');
    }

    // Добавляем дополнительные заголовки безопасности
    const secureOptions = {
      ...options,
      headers: {
        ...options.headers,
        'Referer-Policy': 'strict-origin-when-cross-origin',
        'Origin': window.location.origin
      }
    };

    return await fetch(url, secureOptions);
  }
}

// Использование
const securityValidator = new CrossDomainSecurityValidator();
securityValidator.addAllowedDomain('api.ourapp.com');
securityValidator.addAllowedDomain('cdn.ourapp.com');

try {
  const response = await securityValidator.secureFetch('https://api.ourapp.com/users');
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error('Ошибка безопасного запроса:', error);
}
```

### 2. Content Security Policy для кросс-доменных запросов

```javascript
// Пример CSP заголовков для защиты кросс-доменных запросов
const CSP_POLICIES = {
  // Политика для основного домена
  mainDomain: [
    "default-src 'self'",
    "connect-src 'self' https://api.ourapp.com",
    "script-src 'self' 'unsafe-inline' https://trusted-cdn.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "img-src 'self' data: https:",
    "font-src 'self' https://fonts.gstatic.com",
    "frame-src 'self' https://trusted-partner.com",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'"  // Предотвращает встраивание в iframe
  ].join('; '),

  // Политика для API домена
  apiDomain: [
    "default-src 'none'",
    "script-src 'none'",
    "style-src 'none'",
    "img-src 'none'",
    "connect-src 'self'",
    "frame-ancestors 'none'"
  ].join('; ')
};

// Функция для динамической настройки CSP
function setDynamicCSP(isTrustedDomain = false) {
  let policy = CSP_POLICIES.mainDomain;
  
  if (isTrustedDomain) {
    policy = [
      ...CSP_POLICIES.mainDomain.split('; '),
      "frame-src https://trusted-partner.com",
      "connect-src 'self' https://api.ourapp.com https://trusted-api.com"
    ].join('; ');
  }
  
  // Устанавливаем CSP заголовок (обычно на сервере)
  console.log('CSP Политика:', policy);
  return policy;
}
```

## Современные подходы к междоменной безопасности

### 1. Cross-Origin Opener Policy (COOP)

```javascript
// Пример использования COOP заголовков
const COOP_POLICIES = {
  // Самая строгая политика
  sameOrigin: "Cross-Origin-Opener-Policy: same-origin",
  
  // Менее строгая, но все еще безопасная
  sameOriginAllowPopups: "Cross-Origin-Opener-Policy: same-origin-allow-popups",
  
  // Наименее строгая, но может быть необходима для совместимости
  unsafeNone: "Cross-Origin-Opener-Policy: unsafe-none"
};

// Пример проверки COOP статуса
function checkCOOPStatus() {
  try {
    // Проверяем, можем ли мы получить доступ к window.opener
    const openerInfo = {
      exists: window.opener !== null,
      hasAccess: false
    };
    
    try {
      // Пытаемся получить доступ к opener
      if (window.opener) {
        window.opener.location.href; // Это вызовет ошибку, если COOP включен
        openerInfo.hasAccess = true;
      }
    } catch (e) {
      // Доступ к opener ограничен COOP
      openerInfo.hasAccess = false;
    }
    
    return openerInfo;
  } catch (error) {
    console.error('Ошибка проверки COOP:', error);
    return null;
  }
}
```

### 2. Cross-Origin Embedder Policy (COEP)

```javascript
// Пример использования COEP
const COEP_POLICIES = {
  // Требует CORS для встраивания ресурсов
  requireCorp: "Cross-Origin-Embedder-Policy: require-corp",
  
  // Разрешает все источники (менее безопасно)
  unsafeNone: "Cross-Origin-Embedder-Policy: unsafe-none"
};

// Функция для проверки COEP статуса
function checkCOEPStatus() {
  // COEP влияет на возможность загрузки ресурсов из других источников
  // без соответствующих CORS заголовков
  console.log('COEP статус проверяется через заголовки ответа сервера');
}
```

## Лучшие практики

### 1. Минимизация кросс-доменных запросов

```javascript
// Класс для управления кросс-доменными запросами
class CrossDomainRequestManager {
  constructor() {
    this.requestCache = new Map();
    this.maxConcurrentRequests = 5;
    this.activeRequests = 0;
  }

  async request(url, options = {}) {
    // Проверяем, не является ли запрос кэшируемым
    const cacheKey = this.generateCacheKey(url, options);
    if (this.requestCache.has(cacheKey)) {
      const cached = this.requestCache.get(cacheKey);
      if (Date.now() - cached.timestamp < cached.ttl) {
        return cached.data;
      }
    }

    // Ограничиваем количество одновременных запросов
    if (this.activeRequests >= this.maxConcurrentRequests) {
      throw new Error('Превышено максимальное количество одновременных запросов');
    }

    this.activeRequests++;
    
    try {
      const response = await fetch(url, options);
      const data = await response.json();
      
      // Кэшируем результат
      this.requestCache.set(cacheKey, {
        data,
        timestamp: Date.now(),
        ttl: 300000 // 5 минут
      });
      
      return data;
    } finally {
      this.activeRequests--;
    }
  }

  generateCacheKey(url, options) {
    // Генерируем уникальный ключ для кэширования
    const stringifiedOptions = JSON.stringify(options);
    return `${url}_${stringifiedOptions}`;
  }

  clearCache() {
    this.requestCache.clear();
  }
}
```

### 2. Правила валидации кросс-доменных данных

```javascript
// Класс для валидации данных из кросс-доменных источников
class CrossDomainDataValidator {
  constructor() {
    this.allowedDataTypes = new Set(['object', 'array', 'string', 'number', 'boolean']);
    this.maxDataSize = 1024 * 1024; // 1MB
  }

  validate(data, sourceOrigin) {
    // Проверяем размер данных
    const dataSize = this.getDataSize(data);
    if (dataSize > this.maxDataSize) {
      throw new Error(`Размер данных превышает лимит: ${dataSize} байт`);
    }

    // Проверяем тип данных
    const dataType = typeof data;
    if (!this.allowedDataTypes.has(dataType) && !Array.isArray(data)) {
      throw new Error(`Неподдерживаемый тип данных: ${dataType}`);
    }

    // Проверяем на наличие потенциально опасного содержимого
    if (this.containsDangerousContent(data)) {
      throw new Error('Данные содержат потенциально опасный контент');
    }

    return true;
  }

  getDataSize(data) {
    const jsonString = JSON.stringify(data);
    return new Blob([jsonString]).size;
  }

  containsDangerousContent(obj) {
    const jsonStr = JSON.stringify(obj);
    
    // Проверяем на наличие потенциально опасных паттернов
    const dangerousPatterns = [
      /<script/i,
      /javascript:/i,
      /vbscript:/i,
      /on\w+\s*=/i,
      /data:text\/html/i
    ];

    return dangerousPatterns.some(pattern => pattern.test(jsonStr));
  }

  sanitize(data) {
    // Очищаем данные от потенциально опасного содержимого
    if (typeof data === 'string') {
      return this.sanitizeString(data);
    } else if (typeof data === 'object' && data !== null) {
      const sanitized = {};
      for (const [key, value] of Object.entries(data)) {
        sanitized[key] = this.sanitize(value);
      }
      return sanitized;
    } else if (Array.isArray(data)) {
      return data.map(item => this.sanitize(item));
    }
    return data;
  }

  sanitizeString(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }
}

// Использование
const validator = new CrossDomainDataValidator();

// Пример валидации данных из кросс-доменного источника
const crossDomainData = { 
  user: { 
    name: 'John', 
    bio: 'Safe bio content' 
  } 
};

try {
  validator.validate(crossDomainData, 'https://trusted-api.com');
  const sanitizedData = validator.sanitize(crossDomainData);
  console.log('Данные безопасны:', sanitizedData);
} catch (error) {
  console.error('Ошибка валидации данных:', error);
}
```

## Заключение

Безопасность между доменами - это критически важный аспект веб-безопасности, требующий тщательного подхода к реализации. Понимание механизмов CORS, правильное использование PostMessage API и соблюдение принципов безопасности помогают защитить веб-приложения от междоменных атак.

> [!tip] Совет
> Всегда валидируйте и санитизируйте данные из кросс-доменных источников перед их использованием.

> [!warning] Важно
> Неправильная реализация кросс-доменного взаимодействия может привести к серьезным уязвимостям безопасности.

> [!note] Примечание
> Современные браузеры продолжают развивать механизмы междоменной безопасности, включая COOP, COEP и другие заголовки.