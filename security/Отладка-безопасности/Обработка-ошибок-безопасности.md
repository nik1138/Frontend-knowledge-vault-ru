---
aliases: ["Обработка ошибок безопасности", "Безопасная обработка ошибок", "Ошибки и безопасность"]
tags: [security, error-handling, vulnerabilities, best-practices]
---

# Обработка ошибок безопасности

## Введение в обработку ошибок безопасности

Обработка ошибок безопасности - это критически важный аспект разработки безопасных приложений. Неправильная обработка ошибок может привести к раскрытию чувствительной информации, утечке данных и созданию векторов для атак. Безопасная обработка ошибок включает в себя как предотвращение утечки информации, так и защиту системы от атак, использующих ошибки в работе приложения.

> [!danger]
> Неправильная обработка ошибок может раскрыть внутреннюю информацию о системе, что значительно облегчает задачу злоумышленникам.

## Принципы безопасной обработки ошибок

### 1. Не раскрывать внутреннюю информацию

Основной принцип безопасной обработки ошибок - не раскрывать внутреннюю информацию о системе:

```javascript
// НЕБЕЗОПАСНО: раскрывает внутреннюю информацию
function insecureErrorHandler(error) {
  return {
    error: error.message,
    stack: error.stack,           // Раскрывает структуру кода
    fileName: error.fileName,     // Раскрывает путь к файлам
    lineNumber: error.lineNumber  // Помогает понять структуру приложения
  };
}

// БЕЗОПАСНО: не раскрывает внутреннюю информацию
function secureErrorHandler(error) {
  // Логирование полной информации об ошибке для разработчиков
  logError(error);
  
  // Возврат обобщенного сообщения для пользователя
  return {
    error: 'Произошла внутренняя ошибка',
    code: 'INTERNAL_ERROR'
  };
}
```

### 2. Логировать ошибки безопасно

При логировании ошибок необходимо убедиться, что чувствительные данные не попадают в логи:

```javascript
function logErrorSecurely(error, context = {}) {
  // Очистка чувствительных данных из контекста
  const safeContext = sanitizeContext(context);
  
  console.error({
    timestamp: new Date().toISOString(),
    message: error.message,
    type: error.constructor.name,
    context: safeContext,
    userId: context.userId ? hashUserId(context.userId) : undefined
  });
}

function sanitizeContext(context) {
  const safeContext = { ...context };
  
  // Удаление чувствительных полей
  const sensitiveFields = [
    'password', 'token', 'apiKey', 'secret', 
    'creditCard', 'ssn', 'cvv', 'pin'
  ];
  
  sensitiveFields.forEach(field => {
    if (safeContext[field]) {
      delete safeContext[field];
    }
  });
  
  return safeContext;
}

function hashUserId(userId) {
  // Хеширование ID пользователя для анонимизации в логах
  return require('crypto')
    .createHash('sha256')
    .update(userId)
    .digest('hex');
}
```

### 3. Предотвращать атаки через исключения

Некоторые атаки могут использовать исключения для получения информации о системе:

```javascript
// Уязвимый код
async function getUserData(userId) {
  try {
    const user = await database.findUser(userId);
    return user;
  } catch (error) {
    // Ошибка может раскрыть информацию о существовании пользователя
    throw new Error(`Ошибка получения данных пользователя: ${error.message}`);
  }
}

// Безопасная реализация
async function getUserDataSecure(userId) {
  try {
    const user = await database.findUser(userId);
    if (!user) {
      // Не указываем, существует ли пользователь
      throw new Error('Неверные учетные данные');
    }
    return user;
  } catch (error) {
    // Логируем ошибку, но не раскрываем детали пользователю
    logError(error, { userId });
    throw new Error('Произошла ошибка при обработке запроса');
  }
}
```

## Классификация ошибок безопасности

### Информационные утечки через ошибки

Информационные утечки происходят, когда ошибка раскрывает внутреннюю информацию о системе:

- **Стек вызовов** - может раскрыть структуру приложения
- **Пути к файлам** - может помочь злоумышленнику понять структуру файловой системы
- **Имена переменных и функций** - может раскрыть логику приложения
- **Версии библиотек** - может помочь подобрать уязвимости

### Атаки через обработку ошибок

Некоторые атаки используют обработку ошибок для получения информации:

- **Атаки по времени** - анализ времени обработки ошибок
- **Oracle-атаки** - использование различий в сообщениях об ошибках
- **Padding oracle** - атаки, использующие информацию об ошибках шифрования

## Практические примеры безопасной обработки ошибок

### Обработка ошибок валидации ввода

```javascript
// Небезопасная обработка
function validateUserInput(input) {
  if (!input.email) {
    throw new Error('Email обязателен');
  }
  
  if (!isValidEmail(input.email)) {
    throw new Error('Неверный формат email: ' + input.email);
  }
  
  // Может раскрыть слишком много информации
  return input;
}

// Безопасная обработка
function validateUserInputSecure(input) {
  const errors = [];
  
  if (!input.email || !isValidEmail(input.email)) {
    errors.push('Неверный формат email');
  }
  
  if (errors.length > 0) {
    // Логируем подробную информацию для разработчиков
    logValidationError(errors, input);
    // Возвращаем общее сообщение пользователю
    throw new Error('Неверные данные формы');
  }
  
  return input;
}

function logValidationError(errors, input) {
  const safeInput = sanitizeInput(input);
  console.warn('Validation errors:', { errors, input: safeInput });
}

function sanitizeInput(input) {
  const safeInput = { ...input };
  delete safeInput.password;
  delete safeInput.creditCard;
  return safeInput;
}
```

### Обработка ошибок аутентификации

```javascript
// Небезопасная реализация
async function authenticateUser(username, password) {
  try {
    const user = await database.findUser(username);
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    if (!await verifyPassword(password, user.passwordHash)) {
      throw new Error('Неверный пароль');
    }
    
    return generateSession(user.id);
  } catch (error) {
    // Разные сообщения для разных ошибок - утечка информации
    throw error;
  }
}

// Безопасная реализация
async function authenticateUserSecure(username, password) {
  try {
    const user = await database.findUser(username);
    if (!user) {
      // Даже если пользователь не существует, выполняем проверку пароля
      // для предотвращения атак по времени
      await verifyPassword(password, 'dummy_hash');
      throw new Error('Неверные учетные данные');
    }
    
    if (!await verifyPassword(password, user.passwordHash)) {
      throw new Error('Неверные учетные данные');
    }
    
    return generateSession(user.id);
  } catch (error) {
    if (error.message === 'Неверные учетные данные') {
      logFailedLogin(username);
      // Не раскрываем причину неудачной попытки
      throw new Error('Неверные учетные данные');
    }
    
    // Логируем неожиданные ошибки
    logError(error, { username });
    throw new Error('Произошла ошибка при аутентификации');
  }
}

async function verifyPassword(password, hash) {
  // Симуляция проверки пароля для одинакового времени выполнения
  await new Promise(resolve => setTimeout(resolve, 100));
  return password === hash; // Упрощенный пример
}
```

### Обработка ошибок в API

```javascript
// Middleware для обработки ошибок в Express.js
function securityErrorHandler(err, req, res, next) {
  // Логирование ошибки с безопасным контекстом
  logError(err, {
    url: req.url,
    method: req.method,
    userId: req.user ? req.user.id : undefined,
    userAgent: req.get('User-Agent'),
    ip: req.ip
  });
  
  // Определение типа ошибки
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Неверные данные запроса',
      code: 'VALIDATION_ERROR'
    });
  }
  
  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({
      error: 'Требуется аутентификация',
      code: 'UNAUTHORIZED'
    });
  }
  
  if (err.name === 'ForbiddenError') {
    return res.status(403).json({
      error: 'Доступ запрещен',
      code: 'FORBIDDEN'
    });
  }
  
  // Для всех других ошибок возвращаем общее сообщение
  res.status(500).json({
    error: 'Произошла внутренняя ошибка',
    code: 'INTERNAL_ERROR'
  });
}

// Функция для создания специфических ошибок
class SecurityError extends Error {
  constructor(message, code, status = 500) {
    super(message);
    this.name = 'SecurityError';
    this.code = code;
    this.status = status;
  }
}

// Использование специфических ошибок
function validateAPIRequest(req) {
  if (!req.headers.authorization) {
    throw new SecurityError(
      'Требуется заголовок Authorization', 
      'MISSING_AUTH_HEADER', 
      401
    );
  }
  
  if (req.body && req.body.length > 10000) {
    throw new SecurityError(
      'Слишком большой размер тела запроса', 
      'REQUEST_TOO_LARGE', 
      413
    );
  }
}
```

## Защита от атак через обработку ошибок

### Защита от атак по времени

```javascript
// Защита от атак по времени при сравнении токенов
function secureTokenComparison(token1, token2) {
  // Используем криптографически безопасное сравнение
  if (token1.length !== token2.length) {
    // Выполняем фиктивное сравнение для одинакового времени выполнения
    timingSafeEqual('dummy', 'dummy');
    return false;
  }
  
  return timingSafeEqual(token1, token2);
}

function timingSafeEqual(a, b) {
  // Сравнение с постоянным временем выполнения
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}
```

### Защита от атак с использованием информации об ошибках

```javascript
// Защита от атак, использующих различия в сообщениях об ошибках
class SecureAuthService {
  constructor() {
    this.attemptCounts = new Map();
  }
  
  async login(username, password) {
    const attempts = this.attemptCounts.get(username) || 0;
    
    if (attempts >= 5) {
      throw new Error('Слишком много попыток входа');
    }
    
    try {
      const user = await this.findUser(username);
      const isValid = await this.validateCredentials(user, password);
      
      if (isValid) {
        this.resetAttempts(username);
        return this.createSession(user);
      } else {
        this.incrementAttempts(username);
        // Одинаковые сообщения для разных случаев
        throw new Error('Неверные учетные данные');
      }
    } catch (error) {
      // Для всех ошибок используем одинаковое сообщение
      this.incrementAttempts(username);
      throw new Error('Неверные учетные данные');
    }
  }
  
  incrementAttempts(username) {
    const attempts = this.attemptCounts.get(username) || 0;
    this.attemptCounts.set(username, attempts + 1);
  }
  
  resetAttempts(username) {
    this.attemptCounts.set(username, 0);
  }
}
```

## Лучшие практики обработки ошибок безопасности

### 1. Использование централизованного обработчика ошибок

```javascript
class ErrorHandler {
  static handleError(error, context = {}) {
    // Классификация ошибки
    const errorType = ErrorHandler.classifyError(error);
    
    // Логирование с безопасным контекстом
    ErrorHandler.logError(error, context, errorType);
    
    // Создание безопасного ответа
    return ErrorHandler.createSecureResponse(error, errorType);
  }
  
  static classifyError(error) {
    if (error.status >= 400 && error.status < 500) {
      return 'CLIENT_ERROR';
    } else if (error.status >= 500) {
      return 'SERVER_ERROR';
    } else {
      return 'APPLICATION_ERROR';
    }
  }
  
  static logError(error, context, errorType) {
    const safeContext = ErrorHandler.sanitizeContext(context);
    
    console.error({
      timestamp: new Date().toISOString(),
      type: errorType,
      message: error.message,
      stack: error.stack, // Только для внутреннего использования
      context: safeContext
    });
  }
  
  static sanitizeContext(context) {
    // Очистка чувствительных данных
    const safeContext = { ...context };
    const sensitiveFields = ['password', 'token', 'secret'];
    
    sensitiveFields.forEach(field => {
      if (safeContext[field]) {
        safeContext[field] = '[REDACTED]';
      }
    });
    
    return safeContext;
  }
  
  static createSecureResponse(error, errorType) {
    switch (errorType) {
      case 'CLIENT_ERROR':
        return { error: 'Неверный запрос', code: 'CLIENT_ERROR' };
      case 'SERVER_ERROR':
        return { error: 'Внутренняя ошибка сервера', code: 'SERVER_ERROR' };
      default:
        return { error: 'Произошла ошибка', code: 'GENERAL_ERROR' };
    }
  }
}
```

### 2. Использование уровней логирования

```javascript
const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  FATAL: 4
};

class SecureLogger {
  constructor(level = LOG_LEVELS.ERROR) {
    this.level = level;
  }
  
  error(message, context = {}) {
    if (this.level <= LOG_LEVELS.ERROR) {
      this.writeLog('ERROR', message, context);
    }
  }
  
  warn(message, context = {}) {
    if (this.level <= LOG_LEVELS.WARN) {
      this.writeLog('WARN', message, context);
    }
  }
  
  writeLog(level, message, context) {
    const safeContext = this.sanitizeContext(context);
    
    console.log({
      timestamp: new Date().toISOString(),
      level,
      message,
      context: safeContext
    });
  }
  
  sanitizeContext(context) {
    // Очистка чувствительных данных
    const safeContext = { ...context };
    
    // Рекурсивная очистка вложенных объектов
    this.redactSensitiveData(safeContext);
    
    return safeContext;
  }
  
  redactSensitiveData(obj) {
    const sensitiveFields = [
      'password', 'token', 'apiKey', 'secret', 
      'creditCard', 'ssn', 'cvv', 'pin', 'auth'
    ];
    
    for (const [key, value] of Object.entries(obj)) {
      if (sensitiveFields.includes(key.toLowerCase())) {
        obj[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        this.redactSensitiveData(value);
      }
    }
  }
}
```

## Связанные темы

- [[Техники-отладки-безопасности]] - методы отладки безопасности
- [[Отладка-проблем-безопасности]] - поиск и устранение проблем безопасности
- [[Инструменты-отладки]] - инструменты для отладки безопасности
- [[Тестирование-безопасности]] - методы тестирования безопасности приложений
- [[Анализ-логов]] - анализ логов для обнаружения проблем безопасности
- [[Мониторинг-безопасности]] - мониторинг безопасности в реальном времени
- [[Безопасное-кэширование]] - безопасное кэширование данных
- [[Шифрование-на-клиенте]] - шифрование данных на стороне клиента
- [[Управление-сессиями-и-аутентификацией]] - безопасное управление сессиями
- [[Защита-от-инъекций]] - защита от различных типов инъекций
- [[XSS-защита]] - защита от межсайтового скриптинга
- [[CSRF-защита]] - защита от подделки межсайтовых запросов
- [[Content-Security-Policy]] - политика безопасности контента
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[Secure-Coding-Practices]] - лучшие практики безопасного программирования
- [[Dependency-Security]] - безопасность зависимостей
- [[Secure-Storage]] - безопасное хранение данных
- [[Безопасность-в-браузере]] - архитектура безопасности браузера
- [[Безопасность-форм]] - защита форм от атак
- [[Меры-против-ботов]] - защита от автоматизированных атак