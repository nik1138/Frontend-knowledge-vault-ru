---
aliases: []
tags: 
  - security
  - pwa
  - service-worker
  - offline-data
  - encryption
---

# Защита оффлайн-данных

## Введение в защиту оффлайн-данных

В современном веб-развитии все больше приложений переходят к модели Progressive Web Apps (PWA), которые могут работать автономно и хранить данные на устройстве пользователя. Это создает новые вызовы в области безопасности, поскольку оффлайн-данные находятся вне прямого контроля сервера и могут быть уязвимы для локальных атак.

Защита оффлайн-данных включает в себя стратегии и техники, направленные на обеспечение конфиденциальности, целостности и доступности данных, которые хранятся локально на устройстве пользователя. Это особенно важно для приложений, обрабатывающих чувствительную информацию, такие как банковские приложения, медицинские системы или корпоративные решения.

## Типы оффлайн-данных

### Персональные данные
Персональные данные включают любую информацию, которая может быть использована для идентификации конкретного пользователя:
- Имена и фамилии
- Адреса электронной почты
- Номера телефонов
- Данные профилей
- История взаимодействия с приложением

### Финансовые данные
Финансовые данные требуют особой защиты из-за их чувствительности:
- Информация о платежных картах
- История транзакций
- Балансы счетов
- Данные о подписках

### Конфиденциальные данные
Конфиденциальные данные могут включать:
- Коммерческие тайны
- Внутренние документы
- Служебную переписку
- Данные клиентов

### Временные данные
Временные данные, которые могут быть уязвимы:
- Кэшированные изображения
- Временные файлы
- Сессионные данные
- Данные автозаполнения

## Хранение данных в PWA

### Service Worker Cache
Service Worker предоставляет механизм кэширования сетевых запросов, что позволяет приложениям работать автономно. Однако важно понимать, что данные, хранящиеся в кэше, могут быть доступны через DevTools и другие средства отладки.

```javascript
// Пример кэширования данных в Service Worker
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        return response || fetch(event.request);
      })
  );
});
```

### IndexedDB
IndexedDB - это низкоуровневая система хранения данных, которая позволяет хранить большие объемы структурированных данных. Это предпочтительный способ хранения сложных данных в PWA.

### Web Storage (localStorage и sessionStorage)
Web Storage предоставляет простой способ хранения небольших объемов данных в формате ключ-значение. localStorage сохраняет данные неограниченно долго, а sessionStorage - до закрытия вкладки.

## Безопасность IndexedDB

### Ограничения безопасности
IndexedDB подчиняется политике одного источника (same-origin policy), что означает, что только скрипты с того же домена могут получить доступ к данным. Однако это не защищает от XSS-атак, которые могут быть использованы для доступа к данным через вредоносный JavaScript.

### Защита от XSS
Для защиты данных в IndexedDB от XSS-атак рекомендуется:
- Валидировать и санитизировать все входные данные
- Использовать Content Security Policy (CSP)
- Применять принцип наименьших привилегий

### Шифрование данных
Хотя IndexedDB не предоставляет встроенное шифрование, разработчики могут реализовать его на уровне приложения:

```javascript
// Пример шифрования данных перед сохранением в IndexedDB
async function encryptAndStoreData(db, data) {
  const encryptedData = await encrypt(data, encryptionKey);
  const transaction = db.transaction(['dataStore'], 'readwrite');
  const store = transaction.objectStore('dataStore');
  await store.add(encryptedData, 'key');
}
```

## Безопасность localStorage и sessionStorage

### Уязвимости
localStorage и sessionStorage хранят данные в открытом виде и легко доступны через JavaScript, что делает их уязвимыми для XSS-атак. Данные также могут быть прочитаны любыми скриптами на том же домене.

### Рекомендации по безопасности
- Не храните чувствительные данные в localStorage/sessionStorage
- Используйте шифрование при необходимости хранения конфиденциальной информации
- Регулярно очищайте временные данные
- Ограничьте доступ к данным с помощью проверок аутентификации

## Шифрование оффлайн-данных

### Web Cryptography API
Web Cryptography API предоставляет набор криптографических функций, которые можно использовать в браузере:

```javascript
// Пример генерации ключа шифрования
async function generateEncryptionKey() {
  const key = await window.crypto.subtle.generateKey(
    {
      name: "AES-GCM",
      length: 256,
    },
    true,
    ["encrypt", "decrypt"]
  );
  return key;
}
```

### Алгоритмы шифрования
Для шифрования оффлайн-данных рекомендуется использовать:
- AES-GCM для симметричного шифрования
- RSA для асимметричного шифрования
- SHA-256 для хеширования

### Реализация шифрования
При шифровании оффлайн-данных следует учитывать:
- Безопасное хранение ключей
- Обработку ошибок шифрования
- Производительность при шифровании больших объемов данных

## Управление ключами шифрования

### Генерация ключей
Ключи шифрования должны генерироваться с использованием криптографически безопасных генераторов случайных чисел. Web Cryptography API предоставляет встроенные функции для безопасной генерации ключей.

### Хранение ключей
Хранение ключей шифрования - одна из самых сложных задач в клиентском шифровании:
- Не храните ключи в открытом виде
- Используйте аппаратные средства безопасности, если доступны
- Рассмотрите возможность хранения ключей на сервере с использованием безопасного обмена ключами

### Обновление ключей
Регулярное обновление ключей шифрования помогает защитить данные от долгосрочных атак:
- Планируйте обновление ключей при обновлениях приложения
- Обеспечьте миграцию зашифрованных данных при смене ключей
- Используйте версионирование ключей для поддержки старых данных

## Защита от несанкционированного доступа

### Аутентификация
Реализуйте многофакторную аутентификацию для доступа к чувствительным данным:
- Пароли
- Биометрические данные
- Одноразовые коды
- Аутентификация через сторонние сервисы

### Авторизация
Ограничьте доступ к данным на основе ролей и разрешений:
- Проверяйте права доступа перед чтением/записью данных
- Используйте токены доступа с ограниченным сроком действия
- Реализуйте логику проверки сессии

### Защита от физического доступа
Учитывайте возможность физического доступа к устройству:
- Используйте биометрическую аутентификацию
- Реализуйте автоматический выход из системы
- Ограничьте доступ к данным при неактивности

## Ссылки на другие связанные файлы

- [[Безопасность-веб-приложений]]
- [[Шифрование-в-браузере]]
- [[Сервис-воркеры-и-безопасность]]
- [[Аутентификация-в-PWA]]
- [[CSP-и-безопасность]]
- [[XSS-защита]]
- [[Хранение-данных-в-PWA]]
- [[IndexedDB-безопасность]]
- [[Web-Storage-безопасность]]
- [[HTTPS-и-безопасность]]

## Заключение

Защита оффлайн-данных в PWA требует комплексного подхода, включающего шифрование, правильное управление ключами, аутентификацию и защиту от различных типов атак. При разработке безопасных приложений важно учитывать все аспекты хранения и обработки данных на стороне клиента, чтобы обеспечить конфиденциальность и целостность информации пользователей.

## Уязвимости оффлайн-хранилищ

### Уязвимости IndexedDB

IndexedDB, как и другие клиентские хранилища, имеет свои уязвимости:

- **Отсутствие встроенного шифрования**: Данные хранятся в открытом виде и могут быть прочитаны через DevTools или другие инструменты разработчика
- **XSS-атаки**: При наличии уязвимостей XSS злоумышленник может получить доступ к данным через вредоносный JavaScript
- **Недостаточная изоляция**: Данные могут быть доступны другим скриптам на том же домене

### Уязвимости Web Storage

localStorage и sessionStorage особенно уязвимы из-за следующих факторов:

- **Простой доступ через JavaScript**: Любой скрипт на странице может читать/писать данные
- **Хранение в открытом виде**: Данные легко доступны через DevTools
- **Нет встроенной защиты**: Нет механизмов шифрования или аутентификации

### Уязвимости Service Worker Cache

Кэш Service Worker также имеет уязвимости:

- **Доступ через DevTools**: Кэшированные данные легко доступны через Network или Application вкладки
- **Манипуляции с кэшем**: Злоумышленник может изменить или удалить кэшированные данные
- **Утечка чувствительной информации**: Чувствительные данные могут быть закэшированы по ошибке

### Уязвимости файловой системы

Некоторые PWA могут использовать API для доступа к файловой системе:

- **Недостаточная изоляция**: Файлы могут быть доступны другим приложениям
- **Отсутствие шифрования**: Файлы хранятся в открытом виде
- **Права доступа**: Неправильная настройка прав доступа может привести к утечке данных

## Лучшие практики хранения

### Использование шифрования

Для безопасного хранения данных рекомендуется:

- **Шифровать чувствительные данные** перед сохранением в любом хранилище
- **Использовать современные криптографические алгоритмы** (AES-GCM, RSA)
- **Разделять ключи шифрования** от самих данных
- **Использовать Web Cryptography API** для выполнения криптографических операций

### Минимизация хранения

- **Хранить минимально необходимый объем данных** оффлайн
- **Использовать краткосрочное хранение** для временных данных
- **Удалять ненужные данные** как можно скорее
- **Ограничивать срок хранения** чувствительной информации

### Архитектурные решения

- **Разделять типы данных** по различным хранилищам в зависимости от чувствительности
- **Использовать безопасные схемы аутентификации** перед доступом к данным
- **Реализовать проверки целостности** для критических данных
- **Применять принцип наименьших привилегий** для доступа к данным

### Защита от XSS

- **Санитизировать все входные данные** перед сохранением
- **Использовать Content Security Policy (CSP)** для ограничения выполнения скриптов
- **Применять защиту от CSRF** для критических операций
- **Регулярно обновлять зависимости** для устранения уязвимостей

## Очистка оффлайн-данных

### Автоматическая очистка

Для обеспечения безопасности рекомендуется реализовать автоматическую очистку данных:

- **Установка сроков хранения**: Автоматическое удаление данных по истечении определенного времени
- **Очистка при выходе из системы**: Удаление всех оффлайн-данных при логауте
- **Очистка при обновлении приложения**: Удаление устаревших данных при обновлениях

### Ручная очистка

- **Интерфейс управления данными**: Предоставление пользователям возможности управлять своими оффлайн-данными
- **Очистка при разрыве сессии**: Удаление данных при истечении срока сессии
- **Удаление при деинсталляции**: Очистка данных при удалении PWA

### Безопасная очистка

- **Перезапись данных**: Для предотвращения восстановления удаленных данных
- **Использование безопасных методов удаления**: Применение специализированных функций для удаления чувствительных данных
- **Проверка полной очистки**: Убедиться, что данные действительно удалены из всех хранилищ

### Пример реализации очистки

```javascript
// Пример функции очистки оффлайн-данных
async function clearOfflineData() {
  // Очистка IndexedDB
  const databases = await indexedDB.databases();
  for (const db of databases) {
    indexedDB.deleteDatabase(db.name);
  }

  // Очистка localStorage
  localStorage.clear();

  // Очистка sessionStorage
  sessionStorage.clear();

  // Очистка кэша Service Worker
  if ('caches' in window) {
    const cacheNames = await caches.keys();
    await Promise.all(
      cacheNames.map(cacheName => caches.delete(cacheName))
    );
  }
}
```

## Резервное копирование и синхронизация

### Стратегии резервного копирования

Для обеспечения доступности данных в автономных приложениях необходимо:

- **Создание резервных копий на устройстве**: Хранение резервных копий в зашифрованном виде
- **Синхронизация с облаком**: Использование облачных хранилищ для резервного копирования
- **Регулярные бэкапы**: Планирование автоматических резервных копий по расписанию
- **Контрольные суммы**: Использование хешей для проверки целостности резервных копий

### Синхронизация данных

- **Синхронизация при подключении**: Автоматическая синхронизация данных при восстановлении интернет-соединения
- **Конфликты синхронизации**: Обработка конфликтов при одновременном изменении данных на разных устройствах
- **Инкрементальная синхронизация**: Передача только измененных данных для экономии трафика
- **Оффлайн-режим**: Обеспечение работы приложения при отсутствии синхронизации

### Безопасность резервного копирования

- **Шифрование резервных копий**: Обязательное шифрование данных перед отправкой в облако
- **Безопасные протоколы передачи**: Использование HTTPS и других защищенных протоколов
- **Управление доступом**: Ограничение доступа к резервным копиям только авторизованным пользователям
- **Аудит синхронизации**: Логирование операций синхронизации для обнаружения аномалий

### Пример реализации синхронизации

```javascript
// Пример функции синхронизации данных
async function syncOfflineData() {
  if (navigator.onLine) {
    try {
      // Получение данных из IndexedDB
      const offlineData = await getOfflineData();
      
      // Шифрование данных перед отправкой
      const encryptedData = await encrypt(offlineData, syncKey);
      
      // Отправка данных на сервер
      const response = await fetch('/api/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`
        },
        body: JSON.stringify({
          data: encryptedData,
          timestamp: Date.now()
        })
      });
      
      if (response.ok) {
        // Очистка локальных данных после успешной синхронизации
        await clearOfflineData();
      }
    } catch (error) {
      console.error('Ошибка синхронизации:', error);
    }
  }
}

// Автоматическая синхронизация при восстановлении соединения
window.addEventListener('online', syncOfflineData);
```

## Мониторинг доступа к данным

### Логирование доступа

Для обеспечения безопасности важно отслеживать доступ к оффлайн-данным:

- **Логирование операций чтения/записи**: Запись всех операций с чувствительными данными
- **Временные метки**: Фиксация времени доступа к данным
- **Контекст доступа**: Запись информации о том, какой компонент приложения запрашивал данные
- **Сессионная информация**: Отслеживание сессий, в которых происходил доступ

### Обнаружение аномалий

- **Частота доступа**: Мониторинг необычно частого доступа к данным
- **Подозрительные операции**: Обнаружение операций, не соответствующих нормальному поведению
- **Доступ в нерабочее время**: Отслеживание доступа к данным в необычное время
- **Массовые операции**: Выявление попыток массового извлечения данных

### Аудит безопасности

- **Регулярные проверки**: Периодическая проверка логов на предмет подозрительной активности
- **Анализ паттернов**: Использование аналитики для выявления необычных паттернов доступа
- **Оповещения**: Автоматические уведомления о подозрительных событиях
- **Отчетность**: Формирование отчетов о доступе к данным

### Пример реализации мониторинга

```javascript
// Пример системы мониторинга доступа к данным
class DataAccessMonitor {
  constructor() {
    this.accessLogs = [];
    this.anomalyThreshold = 10; // Порог для аномального количества операций
  }

  // Логирование доступа к данным
  logAccess(operation, dataType, context = {}) {
    const logEntry = {
      timestamp: Date.now(),
      operation,
      dataType,
      context,
      userAgent: navigator.userAgent,
      sessionId: this.getCurrentSessionId()
    };

    this.accessLogs.push(logEntry);
    this.checkForAnomalies(logEntry);
  }

  // Проверка на аномалии
  checkForAnomalies(logEntry) {
    const recentAccesses = this.accessLogs.filter(
      log => log.timestamp > Date.now() - 60000 // За последнюю минуту
    );

    if (recentAccesses.length > this.anomalyThreshold) {
      this.reportAnomaly(recentAccesses);
    }
  }

  // Отчет о подозрительной активности
  reportAnomaly(accesses) {
    console.warn('Обнаружена подозрительная активность:', accesses);
    // Здесь можно реализовать отправку уведомления или запись в удаленный лог
  }

  // Получение текущего ID сессии
  getCurrentSessionId() {
    return sessionStorage.getItem('sessionId') || 'unknown';
  }
}

// Использование монитора
const monitor = new DataAccessMonitor();

// Пример использования при доступе к данным
function getSensitiveData() {
  monitor.logAccess('read', 'personal_data', { component: 'UserProfile' });
  // Доступ к данным
}
```

## Практические примеры

### Пример 1: Защита финансовых данных в банковском PWA

```javascript
// Пример комплексной защиты финансовых данных
class SecureFinancialStorage {
  constructor() {
    this.dbName = 'BankingApp';
    this.encryptionKey = null;
  }

  // Инициализация безопасного хранилища
  async initialize() {
    // Генерация ключа шифрования
    this.encryptionKey = await this.generateKey();
    
    // Создание зашифрованной базы данных
    const db = await this.createEncryptedDB();
    return db;
  }

  // Генерация ключа шифрования
  async generateKey() {
    return await window.crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256,
      },
      true,
      ["encrypt", "decrypt"]
    );
  }

  // Шифрование данных перед сохранением
  async encryptData(data) {
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    
    const encryptedData = await window.crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv: iv,
        tagLength: 128,
      },
      this.encryptionKey,
      encodedData
    );

    return {
      data: Array.from(new Uint8Array(encryptedData)),
      iv: Array.from(iv)
    };
  }

  // Расшифровка данных при чтении
  async decryptData(encryptedPackage) {
    const decryptedData = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: new Uint8Array(encryptedPackage.iv),
        tagLength: 128,
      },
      this.encryptionKey,
      new Uint8Array(encryptedPackage.data)
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedData));
  }

  // Сохранение зашифрованных финансовых данных
  async saveFinancialData(data) {
    const encryptedData = await this.encryptData(data);
    
    const request = indexedDB.open(this.dbName, 1);
    const db = await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const objectStore = db.createObjectStore('financial_data', { keyPath: 'id' });
        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
      };
    });

    const transaction = db.transaction(['financial_data'], 'readwrite');
    const store = transaction.objectStore('financial_data');
    
    await store.add({
      id: Date.now(),
      data: encryptedData,
      timestamp: new Date().toISOString()
    });
  }

  // Получение и расшифровка финансовых данных
  async getFinancialData() {
    const request = indexedDB.open(this.dbName, 1);
    const db = await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });

    const transaction = db.transaction(['financial_data'], 'readonly');
    const store = transaction.objectStore('financial_data');
    const allData = await store.getAll();

    const decryptedData = [];
    for (const item of allData) {
      try {
        const decrypted = await this.decryptData(item.data);
        decryptedData.push({
          ...decrypted,
          timestamp: item.timestamp
        });
      } catch (error) {
        console.error('Ошибка расшифровки данных:', error);
      }
    }

    return decryptedData;
  }
}
```

### Пример 2: Защита медицинских данных

```javascript
// Пример защиты медицинских данных с дополнительными мерами безопасности
class MedicalDataStorage {
  constructor() {
    this.storage = new SecureFinancialStorage(); // Используем предыдущий класс как основу
    this.accessMonitor = new DataAccessMonitor();
    this.biometricAuthRequired = true;
  }

  // Проверка биометрической аутентификации перед доступом к данным
  async verifyBiometricAccess() {
    if (!this.biometricAuthRequired) return true;
    
    try {
      // Использование Web Authentication API для биометрической аутентификации
      const publicKey = {
        challenge: new Uint8Array(32),
        rp: { name: 'Medical PWA' },
        user: {
          id: new Uint8Array(16),
          name: 'patient@example.com',
          displayName: 'Patient'
        },
        pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
        timeout: 60000,
        attestation: 'none',
        authenticatorSelection: {
          authenticatorAttachment: 'platform',
          userVerification: 'required'
        }
      };

      const credential = await navigator.credentials.create({ publicKey });
      return !!credential;
    } catch (error) {
      console.error('Ошибка биометрической аутентификации:', error);
      return false;
    }
  }

  // Сохранение медицинских данных с проверкой аутентификации
  async saveMedicalData(data) {
    const isAuthenticated = await this.verifyBiometricAccess();
    if (!isAuthenticated) {
      throw new Error('Биометрическая аутентификация не пройдена');
    }

    this.accessMonitor.logAccess('write', 'medical_data', { 
      component: 'MedicalRecordManager',
      patientId: data.patientId 
    });

    await this.storage.saveFinancialData(data); // Переиспользуем метод из базового класса
  }

  // Получение медицинских данных с проверкой аутентификации
  async getMedicalData(filter) {
    const isAuthenticated = await this.verifyBiometricAccess();
    if (!isAuthenticated) {
      throw new Error('Биометрическая аутентификация не пройдена');
    }

    this.accessMonitor.logAccess('read', 'medical_data', { 
      component: 'MedicalRecordViewer',
      filter 
    });

    return await this.storage.getFinancialData();
  }
}
```

### Пример 3: Защита корпоративных данных

```javascript
// Пример защиты корпоративных данных с управлением доступом
class CorporateDataStorage {
  constructor() {
    this.storage = new SecureFinancialStorage();
    this.accessControl = new AccessControlManager();
    this.dataClassification = new DataClassificationSystem();
  }

  // Классификация данных перед сохранением
  async classifyAndStore(data) {
    const classification = this.dataClassification.classify(data);
    
    // Проверка прав доступа на основе классификации
    const hasPermission = await this.accessControl.checkPermission(
      'store', 
      classification.level
    );
    
    if (!hasPermission) {
      throw new Error(`Недостаточно прав для сохранения данных уровня ${classification.level}`);
    }

    // Добавление метаданных классификации
    const enrichedData = {
      ...data,
      classification: classification,
      timestamp: new Date().toISOString(),
      storedBy: this.accessControl.getCurrentUserId()
    };

    await this.storage.saveFinancialData(enrichedData);
  }

  // Получение данных с проверкой прав доступа
  async retrieveData(request, userRole) {
    const requiredClassification = this.dataClassification.getRequiredLevel(request);
    
    const hasPermission = await this.accessControl.checkPermission(
      'retrieve', 
      requiredClassification,
      userRole
    );
    
    if (!hasPermission) {
      throw new Error('Недостаточно прав для доступа к запрашиваемым данным');
    }

    const allData = await this.storage.getFinancialData();
    return allData.filter(item => 
      this.accessControl.canAccess(item, userRole)
    );
  }
}

// Система управления доступом
class AccessControlManager {
  constructor() {
    this.userRoles = new Map();
    this.permissions = new Map();
  }

  // Проверка прав доступа
  async checkPermission(action, dataLevel, userRole = null) {
    const currentUserRole = userRole || this.getCurrentRole();
    
    // Получение разрешений для роли пользователя
    const rolePermissions = this.permissions.get(currentUserRole) || [];
    
    // Проверка, разрешено ли действие для уровня данных
    return rolePermissions.some(perm => 
      perm.action === action && 
      perm.dataLevel >= dataLevel
    );
  }

  getCurrentRole() {
    // В реальном приложении роль пользователя будет получаться из сессии
    return sessionStorage.getItem('userRole') || 'guest';
  }

  getCurrentUserId() {
    return sessionStorage.getItem('userId') || 'anonymous';
  }

  canAccess(data, userRole) {
    // Проверка, может ли пользователь с данной ролью получить доступ к данным
    const dataLevel = data.classification?.level || 1;
    return this.checkPermission('retrieve', dataLevel, userRole);
  }
}

// Система классификации данных
class DataClassificationSystem {
  constructor() {
    this.classificationRules = [
      { pattern: /credit_card|card_number/, level: 5, name: 'Конфиденциально' },
      { pattern: /ssn|social_security/, level: 5, name: 'Конфиденциально' },
      { pattern: /salary|compensation/, level: 4, name: 'Внутреннее' },
      { pattern: /email|phone/, level: 3, name: 'Ограниченный доступ' },
      { pattern: /name|title/, level: 2, name: 'Общедоступное' },
      { pattern: /.*/, level: 1, name: 'Общедоступное' }
    ];
  }

  classify(data) {
    const text = JSON.stringify(data);
    let maxLevel = 1;
    let classificationName = 'Общедоступное';

    for (const rule of this.classificationRules) {
      if (rule.pattern.test(text) && rule.level > maxLevel) {
        maxLevel = rule.level;
        classificationName = rule.name;
      }
    }

    return {
      level: maxLevel,
      name: classificationName,
      timestamp: new Date().toISOString()
    };
  }

  getRequiredLevel(request) {
    // Определение требуемого уровня классификации для запроса
    return 1; // В реальном приложении логика будет сложнее
  }
}
```

## Ссылки на другие связанные файлы

- [[Безопасность-веб-приложений]]
- [[Шифрование-в-браузере]]
- [[Сервис-воркеры-и-безопасность]]
- [[Аутентификация-в-PWA]]
- [[CSP-и-безопасность]]
- [[XSS-защита]]
- [[Хранение-данных-в-PWA]]
- [[IndexedDB-безопасность]]
- [[Web-Storage-безопасность]]
- [[HTTPS-и-безопасность]]
- [[Аутентификация-и-авторизация]]
- [[Биометрическая-аутентификация]]
- [[Шифрование-чувствительных-данных]]
- [[Управление-сессиями-PWA]]
- [[Защита-от-CSRF]]
- [[Политика-безопасности-контента]]
- [[Криптография-в-браузере]]
- [[Формы-безопасности-ввода]]
- [[Мониторинг-безопасности-PWA]]
- [[Анализ-уязвимостей-веб-приложений]]