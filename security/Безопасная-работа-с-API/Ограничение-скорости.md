---
aliases: ["Ограничение скорости", "Rate Limiting", "Защита от DDoS", "API Rate Limiting"]
tags: ["#security", "#rate-limiting", "#api-security", "#web-security"]
---

# Ограничение скорости

## Введение

Ограничение скорости (rate limiting) - это важный механизм безопасности, который контролирует количество запросов, которые могут быть отправлены в систему за определенный период времени. Это помогает предотвратить злоупотребления, DDoS-атаки, перегрузку сервера и другие проблемы, связанные с чрезмерным использованием API.

## Принципы ограничения скорости

### 1. Основные концепции

- **Window (окно)**: Временной интервал, в течение которого измеряется количество запросов
- **Limit (предел)**: Максимальное количество разрешенных запросов в окне
- **Key (ключ)**: Идентификатор, по которому ведется учет запросов (IP-адрес, ID пользователя и т.д.)

### 2. Типы ограничений

#### По IP-адресу
```javascript
// Ограничение по IP-адресу
const ipLimits = {
    windowMs: 15 * 60 * 1000, // 15 минут
    max: 100, // максимум 100 запросов
    message: 'Too many requests from this IP address'
};
```

#### По пользователю
```javascript
// Ограничение по пользователю
const userLimits = {
    windowMs: 60 * 60 * 1000, // 1 час
    max: 1000, // максимум 1000 запросов
    message: 'Too many requests for this user'
};
```

#### По API-ключу
```javascript
// Ограничение по API-ключу
const apiLimits = {
    windowMs: 60 * 60 * 1000, // 1 час
    max: 10000, // максимум 10000 запросов (для платных пользователей)
    message: 'API rate limit exceeded'
};
```

## Реализация ограничения скорости

### 1. Использование express-rate-limit

```javascript
const rateLimit = require('express-rate-limit');

// Базовое ограничение
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 минут
    max: 100, // ограничение на 100 запросов
    message: {
        error: 'Too many requests, please try again later',
        code: 'RATE_LIMIT_EXCEEDED'
    },
    standardHeaders: true, // Возвращает `RateLimit-*` заголовки
    legacyHeaders: false, // Отключает `X-RateLimit-*` заголовки
});

app.use(limiter);

// Ограничение для конкретных маршрутов
const sensitiveLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5, // только 5 попыток аутентификации
    message: { error: 'Too many authentication attempts' },
    skipSuccessfulRequests: true // не считать успешные аутентификации
});

app.post('/login', sensitiveLimiter);
```

### 2. Кастомная реализация с использованием Redis

```javascript
const redis = require('redis');
const client = redis.createClient();

class RedisRateLimiter {
    constructor(options = {}) {
        this.windowMs = options.windowMs || 15 * 60 * 1000; // 15 минут
        this.max = options.max || 100;
        this.redisClient = options.redisClient || client;
    }
    
    async check(key) {
        const now = Date.now();
        const windowStart = now - this.windowMs;
        const requestCountKey = `rate_limit:${key}:count`;
        const requestTimeKey = `rate_limit:${key}:times`;
        
        // Используем транзакцию для атомарности
        const multi = this.redisClient.multi();
        
        // Удаляем старые временные метки
        multi.zremrangebyscore(requestTimeKey, 0, windowStart);
        
        // Получаем текущее количество запросов
        multi.zcard(requestTimeKey);
        
        // Добавляем текущий запрос
        multi.zadd(requestTimeKey, now, now.toString());
        
        // Устанавливаем TTL для ключей
        multi.expire(requestTimeKey, Math.ceil(this.windowMs / 1000));
        
        const results = await multi.exec();
        const currentRequests = results[1][1]; // zcard результат
        
        return {
            current: currentRequests,
            limit: this.max,
            remaining: Math.max(0, this.max - currentRequests),
            resetTime: new Date(now + this.windowMs)
        };
    }
    
    middleware() {
        return async (req, res, next) => {
            const key = this.getKey(req);
            const limitResult = await this.check(key);
            
            // Установка заголовков
            res.set('X-RateLimit-Limit', limitResult.limit);
            res.set('X-RateLimit-Remaining', limitResult.remaining);
            res.set('X-RateLimit-Reset', limitResult.resetTime.toISOString());
            
            if (limitResult.current >= this.max) {
                return res.status(429).json({
                    error: 'Rate limit exceeded',
                    limit: limitResult.limit,
                    resetTime: limitResult.resetTime
                });
            }
            
            next();
        };
    }
    
    getKey(req) {
        // Определение ключа для ограничения
        if (req.user && req.user.id) {
            return `user:${req.user.id}`;
        }
        
        if (req.headers['x-api-key']) {
            return `api:${req.headers['x-api-key']}`;
        }
        
        return `ip:${this.getIP(req)}`;
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress || 
               req.socket.remoteAddress;
    }
}

const redisRateLimiter = new RedisRateLimiter({
    windowMs: 15 * 60 * 1000,
    max: 100
});

app.use(redisRateLimiter.middleware());
```

### 3. Гибкая система ограничений

```javascript
// Гибкая система с разными лимитами для разных пользователей
class FlexibleRateLimiter {
    constructor() {
        this.limits = {
            'free': { requests: 100, window: 15 * 60 * 1000 },      // 100 запросов в 15 минут
            'basic': { requests: 1000, window: 60 * 60 * 1000 },    // 1000 запросов в час
            'premium': { requests: 10000, window: 60 * 60 * 1000 }, // 10000 запросов в час
            'enterprise': { requests: 50000, window: 60 * 60 * 1000 } // 50000 запросов в час
        };
        
        this.requests = new Map();
    }
    
    async checkLimit(req) {
        const userTier = await this.getUserTier(req);
        const limitConfig = this.limits[userTier] || this.limits['free'];
        const key = this.getKey(req, userTier);
        
        const now = Date.now();
        const windowStart = now - limitConfig.window;
        
        if (!this.requests.has(key)) {
            this.requests.set(key, []);
        }
        
        const requests = this.requests.get(key);
        
        // Удаление старых запросов
        const recentRequests = requests.filter(time => time > windowStart);
        this.requests.set(key, recentRequests);
        
        const currentCount = recentRequests.length;
        
        return {
            current: currentCount,
            limit: limitConfig.requests,
            remaining: Math.max(0, limitConfig.requests - currentCount),
            resetTime: new Date(windowStart + limitConfig.window)
        };
    }
    
    async getUserTier(req) {
        // Определение уровня пользователя
        if (req.user) {
            return req.user.subscriptionTier || 'free';
        }
        
        if (req.headers['x-api-key']) {
            const apiKey = await this.getAPIKeyInfo(req.headers['x-api-key']);
            return apiKey.tier || 'free';
        }
        
        return 'free';
    }
    
    middleware() {
        return async (req, res, next) => {
            const limitResult = await this.checkLimit(req);
            
            // Установка заголовков
            res.set('X-RateLimit-Limit', limitResult.limit);
            res.set('X-RateLimit-Remaining', limitResult.remaining);
            res.set('X-RateLimit-Reset', limitResult.resetTime.toISOString());
            res.set('X-User-Tier', await this.getUserTier(req));
            
            if (limitResult.current >= limitResult.limit) {
                return res.status(429).json({
                    error: 'Rate limit exceeded',
                    tier: await this.getUserTier(req),
                    limit: limitResult.limit,
                    resetTime: limitResult.resetTime,
                    code: 'RATE_LIMIT_EXCEEDED'
                });
            }
            
            next();
        };
    }
    
    getKey(req, tier) {
        if (req.user && req.user.id) {
            return `user:${req.user.id}:${tier}`;
        }
        
        if (req.headers['x-api-key']) {
            return `api:${req.headers['x-api-key']}:${tier}`;
        }
        
        return `ip:${this.getIP(req)}:${tier}`;
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
    
    async getAPIKeyInfo(apiKey) {
        // В реальном приложении - запрос к БД
        return { tier: 'free' };
    }
}
```

## Продвинутые стратегии ограничения

### 1. Token Bucket Algorithm

```javascript
// Реализация Token Bucket алгоритма
class TokenBucketRateLimiter {
    constructor(capacity, refillRate) {
        this.capacity = capacity; // максимальное количество токенов
        this.refillRate = refillRate; // количество токенов, добавляемых в секунду
        this.buckets = new Map(); // хранение ведер для каждого ключа
    }
    
    async consume(key, tokens = 1) {
        const now = Date.now();
        let bucket = this.buckets.get(key);
        
        if (!bucket) {
            // Создание нового ведра
            bucket = {
                tokens: this.capacity,
                lastRefill: now
            };
            this.buckets.set(key, bucket);
        }
        
        // Расчет времени с последнего пополнения
        const timePassed = (now - bucket.lastRefill) / 1000; // в секундах
        
        // Пополнение токенов
        const tokensToAdd = Math.floor(timePassed * this.refillRate);
        bucket.tokens = Math.min(this.capacity, bucket.tokens + tokensToAdd);
        bucket.lastRefill = now;
        
        // Проверка, достаточно ли токенов
        if (bucket.tokens >= tokens) {
            bucket.tokens -= tokens;
            return { success: true, remaining: bucket.tokens };
        } else {
            const waitTime = (tokens - bucket.tokens) / this.refillRate * 1000;
            return { 
                success: false, 
                remaining: bucket.tokens,
                retryAfter: waitTime
            };
        }
    }
    
    middleware(tokens = 1) {
        return async (req, res, next) => {
            const key = this.getKey(req);
            const result = await this.consume(key, tokens);
            
            res.set('X-RateLimit-Remaining', Math.floor(result.remaining));
            
            if (!result.success) {
                res.set('Retry-After', Math.ceil(result.retryAfter / 1000));
                return res.status(429).json({
                    error: 'Rate limit exceeded',
                    retryAfter: result.retryAfter
                });
            }
            
            next();
        };
    }
    
    getKey(req) {
        if (req.user && req.user.id) return `user:${req.user.id}`;
        if (req.headers['x-api-key']) return `api:${req.headers['x-api-key']}`;
        return `ip:${this.getIP(req)}`;
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
}

// Использование: 10 запросов в секунду с максимальным ведром 100
const tokenBucketLimiter = new TokenBucketRateLimiter(100, 10);
app.use(tokenBucketLimiter.middleware());
```

### 2. Sliding Window Algorithm

```javascript
// Реализация Sliding Window алгоритма
class SlidingWindowRateLimiter {
    constructor(windowMs, maxRequests) {
        this.windowMs = windowMs;
        this.maxRequests = maxRequests;
        this.requests = new Map();
    }
    
    async check(key) {
        const now = Date.now();
        const windowStart = now - this.windowMs;
        
        if (!this.requests.has(key)) {
            this.requests.set(key, []);
        }
        
        let requests = this.requests.get(key);
        
        // Удаление запросов за пределами окна
        requests = requests.filter(time => time > windowStart);
        this.requests.set(key, requests);
        
        const currentRequests = requests.length;
        
        // Добавление текущего запроса
        requests.push(now);
        
        return {
            current: currentRequests,
            limit: this.maxRequests,
            remaining: Math.max(0, this.maxRequests - currentRequests),
            resetTime: new Date(now + this.windowMs - (now - windowStart))
        };
    }
    
    middleware() {
        return async (req, res, next) => {
            const key = this.getKey(req);
            const result = await this.check(key);
            
            res.set('X-RateLimit-Limit', result.limit);
            res.set('X-RateLimit-Remaining', result.remaining);
            res.set('X-RateLimit-Reset', result.resetTime.toISOString());
            
            if (result.current >= result.limit) {
                return res.status(429).json({
                    error: 'Rate limit exceeded',
                    resetTime: result.resetTime
                });
            }
            
            next();
        };
    }
    
    getKey(req) {
        if (req.user && req.user.id) return `user:${req.user.id}`;
        if (req.headers['x-api-key']) return `api:${req.headers['x-api-key']}`;
        return `ip:${this.getIP(req)}`;
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
}
```

## Практические примеры

### 1. Ограничение для чувствительных эндпоинтов

```javascript
// Различные ограничения для разных типов эндпоинтов
const rateLimiters = {
    // Обычные эндпоинты
    general: rateLimit({
        windowMs: 15 * 60 * 1000, // 15 минут
        max: 100,
        message: 'Too many requests, please try again later'
    }),
    
    // Эндпоинты аутентификации
    auth: rateLimit({
        windowMs: 15 * 60 * 1000,
        max: 5, // только 5 попыток
        message: 'Too many login attempts, please try again later',
        skipSuccessfulRequests: true // не считать успешные логины
    }),
    
    // Эндпоинты отправки email
    email: rateLimit({
        windowMs: 1 * 60 * 1000, // 1 минута
        max: 2, // максимум 2 email в минуту
        message: 'Too many email requests'
    }),
    
    // Административные эндпоинты
    admin: rateLimit({
        windowMs: 1 * 60 * 1000,
        max: 30, // 30 запросов в минуту
        message: 'Too many admin requests'
    })
};

// Применение ограничений
app.use('/api/', rateLimiters.general);
app.post('/login', rateLimiters.auth);
app.post('/register', rateLimiters.auth);
app.post('/forgot-password', rateLimiters.email);
app.post('/contact', rateLimiters.email);
app.use('/admin/', rateLimiters.admin);
```

### 2. Адаптивное ограничение

```javascript
// Адаптивное ограничение на основе анализа поведения
class AdaptiveRateLimiter {
    constructor() {
        this.baseLimits = {
            windowMs: 15 * 60 * 1000,
            max: 100
        };
        
        this.behaviorScores = new Map();
        this.anomalyDetector = new AnomalyDetector();
    }
    
    async check(req) {
        const key = this.getKey(req);
        const baseLimit = this.baseLimits.max;
        
        // Анализ поведения пользователя
        const behaviorScore = await this.analyzeBehavior(req, key);
        
        // Адаптация лимита на основе поведения
        const adaptiveLimit = this.calculateAdaptiveLimit(baseLimit, behaviorScore);
        
        // Проверка с адаптированным лимитом
        const result = await this.checkWithLimit(key, adaptiveLimit);
        
        return {
            ...result,
            adaptive: true,
            behaviorScore
        };
    }
    
    async analyzeBehavior(req, key) {
        // Анализ различных аспектов поведения
        const patterns = {
            requestFrequency: await this.analyzeRequestFrequency(key),
            endpointDiversity: await this.analyzeEndpointDiversity(key),
            payloadPatterns: await this.analyzePayloadPatterns(req),
            timingPatterns: await this.analyzeTimingPatterns(key)
        };
        
        // Расчет общего балла поведения
        let score = 0;
        for (const [pattern, value] of Object.entries(patterns)) {
            score += value;
        }
        
        return Math.min(10, Math.max(0, score));
    }
    
    calculateAdaptiveLimit(baseLimit, behaviorScore) {
        // Чем выше балл поведения, тем жестче ограничение
        const multiplier = 1 + (behaviorScore / 10); // 1.0 - 2.0
        return Math.max(10, Math.floor(baseLimit / multiplier)); // минимум 10 запросов
    }
    
    middleware() {
        return async (req, res, next) => {
            const result = await this.check(req);
            
            res.set('X-RateLimit-Limit', result.limit);
            res.set('X-RateLimit-Remaining', result.remaining);
            res.set('X-RateLimit-Reset', result.resetTime.toISOString());
            res.set('X-Behavior-Score', result.behaviorScore);
            
            if (result.current >= result.limit) {
                return res.status(429).json({
                    error: 'Rate limit exceeded',
                    behaviorScore: result.behaviorScore,
                    adaptive: result.adaptive
                });
            }
            
            next();
        };
    }
    
    getKey(req) {
        if (req.user && req.user.id) return `user:${req.user.id}`;
        return `ip:${this.getIP(req)}`;
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
    
    async checkWithLimit(key, limit) {
        // Реализация проверки с указанным лимитом
        // (упрощенная версия)
        return {
            current: 0,
            limit: limit,
            remaining: limit,
            resetTime: new Date(Date.now() + this.baseLimits.windowMs)
        };
    }
    
    async analyzeRequestFrequency(key) {
        // Анализ частоты запросов
        return 0; // Заглушка
    }
    
    async analyzeEndpointDiversity(key) {
        // Анализ разнообразия запрашиваемых эндпоинтов
        return 0; // Заглушка
    }
    
    async analyzePayloadPatterns(req) {
        // Анализ паттернов в данных запроса
        return 0; // Заглушка
    }
    
    async analyzeTimingPatterns(key) {
        // Анализ временных паттернов
        return 0; // Заглушка
    }
}
```

## Логирование и мониторинг

### 1. Логирование событий ограничения

```javascript
// Система логирования событий ограничения
class RateLimitLogger {
    static logEvent(req, result, isBlocked = false) {
        const logData = {
            timestamp: new Date().toISOString(),
            ip: this.getIP(req),
            userId: req.user?.id,
            apiKey: req.headers['x-api-key'],
            endpoint: req.path,
            method: req.method,
            userAgent: req.get('User-Agent')?.substring(0, 100),
            isBlocked,
            currentRequests: result.current,
            limit: result.limit,
            remaining: result.remaining
        };
        
        if (isBlocked) {
            console.warn('RATE LIMIT BLOCKED:', logData);
        } else {
            console.log('RATE LIMIT CHECK:', logData);
        }
        
        // Отправка в систему мониторинга
        this.sendToMonitoring(logData);
    }
    
    static getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
    
    static sendToMonitoring(data) {
        // Отправка данных в систему мониторинга (Prometheus, Datadog и т.д.)
        // Реализация зависит от используемой системы
    }
}

// Интеграция с ограничителем
function createRateLimiterWithLogging(options) {
    const limiter = rateLimit({
        ...options,
        skip: (req, res) => {
            // Пропуск определенных запросов (например, для мониторинга)
            return req.path === '/health';
        },
        handler: (req, res, next, options) => {
            RateLimitLogger.logEvent(req, {
                current: options.current,
                limit: options.limit,
                remaining: options.remaining
            }, true);
            
            res.status(429).json({
                error: 'Rate limit exceeded',
                code: 'RATE_LIMIT_EXCEEDED'
            });
        }
    });
    
    return limiter;
}
```

### 2. Мониторинг производительности

```javascript
// Система мониторинга производительности ограничения
class RateLimitMonitor {
    constructor() {
        this.metrics = {
            totalRequests: 0,
            blockedRequests: 0,
            avgResponseTime: 0,
            activeKeys: 0
        };
        
        this.responseTimes = [];
    }
    
    recordRequest(isBlocked, responseTime) {
        this.metrics.totalRequests++;
        if (isBlocked) this.metrics.blockedRequests++;
        
        this.responseTimes.push(responseTime);
        if (this.responseTimes.length > 1000) {
            this.responseTimes.shift();
        }
        
        // Пересчет среднего времени ответа
        this.metrics.avgResponseTime = this.responseTimes.reduce((a, b) => a + b, 0) / 
                                      this.responseTimes.length;
    }
    
    getMetrics() {
        return {
            ...this.metrics,
            blockRate: (this.metrics.blockedRequests / this.metrics.totalRequests) * 100,
            avgResponseTime: this.metrics.avgResponseTime
        };
    }
    
    getAlerts() {
        const alerts = [];
        
        // Проверка на высокий процент блокировок
        const blockRate = (this.metrics.blockedRequests / this.metrics.totalRequests) * 100;
        if (blockRate > 5) { // более 5% блокировок
            alerts.push({
                level: 'WARNING',
                message: `High block rate: ${blockRate.toFixed(2)}%`,
                metric: 'block_rate'
            });
        }
        
        // Проверка на высокое среднее время ответа
        if (this.metrics.avgResponseTime > 100) { // более 100мс
            alerts.push({
                level: 'WARNING',
                message: `High average response time: ${this.metrics.avgResponseTime}ms`,
                metric: 'response_time'
            });
        }
        
        return alerts;
    }
}

const rateLimitMonitor = new RateLimitMonitor();
```

## Лучшие практики

### 1. Гибкие настройки для разных пользователей

```javascript
// Система с гибкими настройками для разных типов пользователей
class TieredRateLimiter {
    constructor() {
        this.tiers = {
            'anonymous': { requests: 10, window: 60 * 1000 },      // 10 запросов в минуту
            'free': { requests: 100, window: 15 * 60 * 1000 },     // 100 запросов в 15 минут
            'pro': { requests: 1000, window: 60 * 60 * 1000 },     // 1000 запросов в час
            'enterprise': { requests: 10000, window: 60 * 60 * 1000 } // 10000 запросов в час
        };
    }
    
    getLimitForUser(user) {
        if (!user) return this.tiers['anonymous'];
        
        const tier = user.subscription?.tier || 'free';
        return this.tiers[tier] || this.tiers['free'];
    }
    
    createMiddleware() {
        return async (req, res, next) => {
            const user = req.user;
            const limitConfig = this.getLimitForUser(user);
            
            // Использование подходящего ограничителя
            const key = user ? `user:${user.id}` : `ip:${this.getIP(req)}`;
            
            // Здесь реализация логики ограничения
            // (упрощенная версия)
            next();
        };
    }
    
    getIP(req) {
        return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
               req.connection.remoteAddress;
    }
}
```

### 2. Обработка исключений

```javascript
// Система обработки исключений для ограничения скорости
class RateLimitExceptionHandler {
    constructor() {
        this.whitelist = new Set(); // список IP, для которых нет ограничений
        this.trustedProxies = new Set(); // доверенные прокси
    }
    
    addWhitelist(ip) {
        this.whitelist.add(ip);
    }
    
    isWhitelisted(req) {
        const ip = this.getIP(req);
        return this.whitelist.has(ip);
    }
    
    createMiddleware() {
        return (req, res, next) => {
            if (this.isWhitelisted(req)) {
                // Пропускаем проверку для белого списка
                return next();
            }
            
            // Проверка через обычный ограничитель
            next();
        };
    }
    
    getIP(req) {
        // Обработка заголовков X-Forwarded-For
        let ip = req.headers['x-forwarded-for'];
        if (ip) {
            ip = ip.split(',')[0].trim();
        } else {
            ip = req.connection.remoteAddress;
        }
        return ip;
    }
}
```

## Тестирование ограничения скорости

### 1. Автоматизированное тестирование

```javascript
// Тестирование системы ограничения скорости
describe('Rate Limiting', () => {
    test('should block requests after exceeding limit', async () => {
        // Выполнить много запросов
        for (let i = 0; i < 101; i++) {
            await request(app).get('/api/public-endpoint');
        }
        
        // Следующий запрос должен быть отклонен
        const response = await request(app).get('/api/public-endpoint');
        expect(response.status).toBe(429);
        expect(response.body.error).toBe('Rate limit exceeded');
    });
    
    test('should reset limit after window expires', async () => {
        // Выполнить запросы до лимита
        for (let i = 0; i < 100; i++) {
            await request(app).get('/api/public-endpoint');
        }
        
        // Ожидание истечения окна
        await new Promise(resolve => setTimeout(resolve, 15 * 60 * 1000 + 1000));
        
        // Запрос после истечения должен пройти
        const response = await request(app).get('/api/public-endpoint');
        expect(response.status).toBe(200);
    });
    
    test('should apply different limits for different user tiers', async () => {
        // Аутентифицированный пользователь с высоким тиром
        const premiumUserToken = generatePremiumUserToken();
        
        // Выполнить много запросов с премиум аккаунтом
        for (let i = 0; i < 1000; i++) {
            await request(app)
                .get('/api/public-endpoint')
                .set('Authorization', `Bearer ${premiumUserToken}`);
        }
        
        // Премиум пользователь не должен быть заблокирован
        const response = await request(app)
            .get('/api/public-endpoint')
            .set('Authorization', `Bearer ${premiumUserToken}`);
        
        expect(response.status).toBe(200);
    });
    
    test('should return proper headers', async () => {
        const response = await request(app).get('/api/public-endpoint');
        
        expect(response.headers).toHaveProperty('x-ratelimit-limit');
        expect(response.headers).toHaveProperty('x-ratelimit-remaining');
        expect(response.headers).toHaveProperty('x-ratelimit-reset');
    });
    
    test('should handle concurrent requests properly', async () => {
        const requests = [];
        for (let i = 0; i < 10; i++) {
            requests.push(request(app).get('/api/public-endpoint'));
        }
        
        const responses = await Promise.all(requests);
        const blockedCount = responses.filter(r => r.status === 429).length;
        
        // Должно быть хотя бы несколько заблокированных запросов
        expect(blockedCount).toBeGreaterThan(0);
    });
});
```

## Распространенные ошибки

### 1. Неправильная обработка IP-адресов

```javascript
// Плохо - не учитывает прокси
function badGetIP(req) {
    return req.connection.remoteAddress; // Может вернуть IP прокси
}

// Хорошо - учитывает заголовки прокси
function goodGetIP(req) {
    return req.headers['x-forwarded-for']?.split(',')[0].trim() || 
           req.connection.remoteAddress;
}
```

### 2. Отсутствие проверки на аутентификацию

```javascript
// Плохо - одинаковое ограничение для всех
const globalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100
});

// Хорошо - разные ограничения для разных пользователей
app.use('/api/', (req, res, next) => {
    if (req.user) {
        // Для аутентифицированных пользователей
        authenticatedLimiter(req, res, next);
    } else {
        // Для анонимных пользователей
        anonymousLimiter(req, res, next);
    }
});
```

## Связанные темы

- [[Лучшие-практики-безопасности-API]]
- [[Безопасность-CORS]]
- [[HTTP-Security-Headers]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]