---
aliases: [Безопасность передачи данных, Data Transmission Security, Secure Data Transfer]
tags: [security, data-security, encryption, tls, ssl, data-transmission]
---

# Безопасность передачи данных

## Обзор

Безопасность передачи данных - это критически важная область информационной безопасности, охватывающая методы и технологии защиты данных во время их передачи между системами, приложениями и пользователями. В условиях, когда все больше данных передается по открытым сетям, обеспечение безопасности передачи данных становится фундаментальным требованием для любой современной системы.

## Основные концепции

### Цели безопасности передачи данных

Безопасность передачи данных направлена на достижение следующих целей:

- **Конфиденциальность** - предотвращение несанкционированного доступа к передаваемым данным
- **Целостность** - обеспечение неизменности данных во время передачи
- **Доступность** - обеспечение надежной передачи данных без перерывов
- **Аутентичность** - подтверждение подлинности участников передачи данных

### Угрозы при передаче данных

#### Пассивные угрозы

- Перехват данных (eavesdropping)
- Анализ трафика
- Сбор метаданных

#### Активные угрозы

- Атаки "человек посередине" (MITM)
- Подмена данных
- Воспроизведение атак (replay attacks)
- Отказ в обслуживании (DoS)

## Криптографические методы защиты

### Шифрование данных при передаче

Шифрование данных при передаче (encryption in transit) - основной метод защиты конфиденциальности:

```javascript
// Пример реализации шифрования данных перед передачей
class DataTransmissionSecurity {
  constructor() {
    this.algorithm = 'AES-GCM';
    this.keyLength = 256;
  }

  // Генерация ключа для шифрования
  async generateKey() {
    const key = await crypto.subtle.generateKey(
      {
        name: this.algorithm,
        length: this.keyLength,
      },
      true, // экспортируемый
      ['encrypt', 'decrypt']
    );
    
    return key;
  }

  // Шифрование данных перед передачей
  async encryptData(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-битный IV для GCM
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    
    const encrypted = await crypto.subtle.encrypt(
      {
        name: this.algorithm,
        iv: iv,
        tagLength: 128
      },
      key,
      encodedData
    );
    
    return {
      encrypted: Array.from(new Uint8Array(encrypted)),
      iv: Array.from(iv),
      timestamp: Date.now()
    };
  }

  // Расшифровка полученных данных
  async decryptData(encryptedPackage, key) {
    const iv = new Uint8Array(encryptedPackage.iv);
    const encrypted = new Uint8Array(encryptedPackage.encrypted);
    
    const decrypted = await crypto.subtle.decrypt(
      {
        name: this.algorithm,
        iv: iv,
        tagLength: 128
      },
      key,
      encrypted
    );
    
    const decoded = new TextDecoder().decode(decrypted);
    return JSON.parse(decoded);
  }

  // Проверка целостности данных
  async verifyIntegrity(encryptedPackage, originalHash) {
    // В реальном приложении здесь будет проверка цифровой подписи
    // или HMAC для подтверждения целостности
    const reconstructedData = new Uint8Array([
      ...encryptedPackage.iv,
      ...encryptedPackage.encrypted
    ]);
    
    const computedHash = await this.computeHash(reconstructedData);
    return computedHash === originalHash;
  }

  // Вычисление хеша данных
  async computeHash(data) {
    const buffer = new TextEncoder().encode(JSON.stringify(data));
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
}

// Пример использования
async function secureDataTransmission() {
  const security = new DataTransmissionSecurity();
  const key = await security.generateKey();
  
  const originalData = {
    userId: 12345,
    transaction: 'payment',
    amount: 100.50,
    timestamp: Date.now()
  };
  
  // Шифрование перед отправкой
  const encryptedPackage = await security.encryptData(originalData, key);
  
  // Имитация передачи данных
  const transmittedData = JSON.parse(JSON.stringify(encryptedPackage));
  
  // Расшифровка полученных данных
  const decryptedData = await security.decryptData(transmittedData, key);
  
  console.log('Оригинальные данные:', originalData);
  console.log('Расшифрованные данные:', decryptedData);
}
```

### Протоколы шифрования

#### TLS (Transport Layer Security)

TLS - это стандартный протокол для безопасной передачи данных по сети:

```javascript
// Пример настройки TLS в Node.js
const https = require('https');
const fs = require('fs');

// Настройка TLS сервера
function createSecureServer(options) {
  const serverOptions = {
    key: fs.readFileSync(options.keyPath),
    cert: fs.readFileSync(options.certPath),
    // Безопасные настройки TLS
    minVersion: 'TLSv1.2', // Минимальная версия TLS
    maxVersion: 'TLSv1.3', // Максимальная версия TLS
    ciphers: [
      'ECDHE-RSA-AES256-GCM-SHA384',
      'ECDHE-RSA-AES128-GCM-SHA256',
      'ECDHE-RSA-AES256-SHA384',
      'ECDHE-RSA-AES128-SHA256'
    ].join(':'),
    honorCipherOrder: true,
    secureOptions: crypto.constants.SSL_OP_NO_SSLv2 | 
                   crypto.constants.SSL_OP_NO_SSLv3 |
                   crypto.constants.SSL_OP_NO_COMPRESSION
  };

  const server = https.createServer(serverOptions, (req, res) => {
    // Обработка защищенного запроса
    res.writeHead(200, {
      'Content-Type': 'application/json',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
      'X-Content-Type-Options': 'nosniff'
    });
    
    res.end(JSON.stringify({ message: 'Защищенное соединение установлено' }));
  });

  return server;
}

// Пример безопасного HTTP клиента с проверкой сертификата
async function secureAPIClient(url, data) {
  const options = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    body: JSON.stringify(data),
    // Настройки TLS для клиента
    agent: new https.Agent({
      rejectUnauthorized: true, // Проверка сертификата
      minVersion: 'TLSv1.2',
      maxVersion: 'TLSv1.3'
    })
  };

  try {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Ошибка безопасного запроса:', error);
    throw error;
  }
}
```

#### Использование сертификатов

```javascript
// Пример работы с сертификатами для проверки подлинности
class CertificateValidator {
  constructor() {
    this.trustedCAs = new Set();
  }

  // Добавление доверенного центра сертификации
  addTrustedCA(caCert) {
    this.trustedCAs.add(caCert);
  }

  // Проверка сертификата сервера
  async validateServerCertificate(cert) {
    try {
      // Проверка срока действия
      const now = new Date();
      const notBefore = new Date(cert.notBefore);
      const notAfter = new Date(cert.notAfter);
      
      if (now < notBefore || now > notAfter) {
        throw new Error('Сертификат просрочен или еще не действителен');
      }
      
      // Проверка имени хоста
      const hostname = cert.subject.CN; // Common Name
      if (!this.verifyHostname(hostname, cert.subjectAltName)) {
        throw new Error('Несоответствие имени хоста');
      }
      
      // Проверка цепочки сертификатов
      if (!this.verifyCertificateChain(cert)) {
        throw new Error('Недоверенная цепочка сертификатов');
      }
      
      return { valid: true, cert: cert };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  // Проверка имени хоста
  verifyHostname(hostname, subjectAltName) {
    // В реальном приложении здесь будет сложная логика проверки
    // включая поддержку подстановочных знаков и т.д.
    return hostname === 'example.com' || 
           (subjectAltName && subjectAltName.includes('example.com'));
  }

  // Проверка цепочки сертификатов
  verifyCertificateChain(cert) {
    // В реальном приложении проверка цепочки сертификатов
    // требует сложной логики проверки подписей
    return this.trustedCAs.has(cert.issuer);
  }
}
```

## Безопасность API и веб-сервисов

### Защита REST API

```javascript
// Пример безопасного API клиента
class SecureAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.apiKey = options.apiKey;
    this.accessToken = options.accessToken;
    this.requestTimeout = options.timeout || 10000;
    this.maxRetries = options.maxRetries || 3;
    
    // Генерация уникального ID для отслеживания запросов
    this.clientId = this.generateSecureId();
  }

  // Генерация безопасного ID
  generateSecureId() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  // Создание безопасного заголовка запроса
  createSecureHeaders(customHeaders = {}) {
    const timestamp = Date.now();
    const nonce = this.generateSecureId();
    
    // Создание подписи запроса
    const signature = this.createRequestSignature({
      timestamp,
      nonce,
      method: customHeaders['X-HTTP-Method'] || 'GET',
      path: customHeaders['X-Request-Path'] || '/'
    });
    
    return {
      'Content-Type': 'application/json',
      'X-API-Key': this.apiKey,
      'Authorization': `Bearer ${this.accessToken}`,
      'X-Request-ID': this.generateSecureId(),
      'X-Timestamp': timestamp.toString(),
      'X-Nonce': nonce,
      'X-Signature': signature,
      'X-Client-ID': this.clientId,
      ...customHeaders
    };
  }

  // Создание цифровой подписи для запроса
  createRequestSignature(data) {
    // В реальном приложении используется криптографическая подпись
    const stringToSign = `${data.timestamp}|${data.nonce}|${data.method}|${data.path}`;
    
    // Простой пример (в реальности используйте HMAC-SHA256)
    return btoa(stringToSign).substring(0, 32);
  }

  // Выполнение безопасного запроса
  async secureRequest(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const secureHeaders = this.createSecureHeaders(options.headers || {});
    
    const requestConfig = {
      ...options,
      headers: secureHeaders,
      credentials: 'include'
    };
    
    let retryCount = 0;
    while (retryCount < this.maxRetries) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.requestTimeout);
        
        const response = await fetch(url, {
          ...requestConfig,
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        // Проверка безопасности ответа
        if (this.isSecureResponse(response)) {
          return response;
        } else {
          throw new Error('Небезопасный ответ от сервера');
        }
      } catch (error) {
        retryCount++;
        if (retryCount >= this.maxRetries) {
          throw error;
        }
        
        // Экспоненциальная задержка перед повторной попыткой
        await new Promise(resolve => 
          setTimeout(resolve, Math.pow(2, retryCount) * 1000)
        );
      }
    }
  }

  // Проверка безопасности ответа
  isSecureResponse(response) {
    // Проверка наличия важных заголовков безопасности
    const securityHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'Strict-Transport-Security'
    ];
    
    return securityHeaders.every(header => 
      response.headers.has(header)
    );
  }

  // Безопасная отправка данных
  async securePost(endpoint, data) {
    // Валидация данных перед отправкой
    if (!this.validateData(data)) {
      throw new Error('Невалидные данные для отправки');
    }
    
    // Шифрование чувствительных данных
    const encryptedData = await this.encryptSensitiveData(data);
    
    return this.secureRequest(endpoint, {
      method: 'POST',
      headers: {
        'X-HTTP-Method': 'POST',
        'X-Request-Path': endpoint
      },
      body: JSON.stringify(encryptedData)
    });
  }

  // Валидация данных
  validateData(data) {
    // Проверка на наличие чувствительных данных
    if (typeof data !== 'object' || data === null) {
      return false;
    }
    
    // Проверка размера данных
    const dataSize = JSON.stringify(data).length;
    if (dataSize > 10 * 1024 * 1024) { // 10MB
      return false;
    }
    
    return true;
  }

  // Шифрование чувствительных данных
  async encryptSensitiveData(data) {
    // В реальном приложении шифрование только чувствительных полей
    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    const encryptedData = { ...data };
    
    for (const field of sensitiveFields) {
      if (encryptedData[field]) {
        encryptedData[field] = await this.encryptValue(encryptedData[field]);
      }
    }
    
    return encryptedData;
  }

  // Шифрование отдельного значения
  async encryptValue(value) {
    // Простой пример шифрования (в реальности используйте надежные алгоритмы)
    const encoder = new TextEncoder();
    const data = encoder.encode(value.toString());
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}

// Использование безопасного API клиента
const secureClient = new SecureAPIClient('https://api.example.com', {
  apiKey: 'your-api-key',
  accessToken: 'your-access-token'
});

// Безопасная отправка данных пользователя
async function sendUserData(userData) {
  try {
    const response = await secureClient.securePost('/users/profile', {
      userId: userData.id,
      email: userData.email,
      preferences: userData.preferences
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('Данные успешно отправлены:', result);
    }
  } catch (error) {
    console.error('Ошибка отправки данных:', error);
  }
}
```

### Защита GraphQL API

```javascript
// Пример безопасного GraphQL клиента
class SecureGraphQLClient {
  constructor(endpoint, options = {}) {
    this.endpoint = endpoint;
    this.headers = options.headers || {};
    this.timeout = options.timeout || 10000;
    this.maxQueryDepth = options.maxQueryDepth || 10;
  }

  // Валидация GraphQL запроса
  validateQuery(query) {
    // Проверка глубины запроса
    const depth = this.calculateQueryDepth(query);
    if (depth > this.maxQueryDepth) {
      throw new Error(`Слишком глубокий запрос GraphQL: ${depth} > ${this.maxQueryDepth}`);
    }
    
    // Проверка на потенциальные уязвимости
    if (this.containsPotentialVulnerabilities(query)) {
      throw new Error('Запрос содержит потенциальные уязвимости');
    }
    
    return true;
  }

  // Расчет глубины GraphQL запроса
  calculateQueryDepth(query) {
    // Упрощенная реализация - в реальности нужен парсер GraphQL
    const lines = query.split('\n');
    let maxDepth = 0;
    let currentDepth = 0;
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.endsWith('{')) {
        currentDepth++;
        maxDepth = Math.max(maxDepth, currentDepth);
      } else if (trimmed.endsWith('}')) {
        currentDepth--;
      }
    }
    
    return maxDepth;
  }

  // Проверка на потенциальные уязвимости
  containsPotentialVulnerabilities(query) {
    const vulnerablePatterns = [
      /__schema/i,
      /__type/i,
      /introspection/i,
      /mutation.*password/i,
      /mutation.*token/i
    ];
    
    return vulnerablePatterns.some(pattern => pattern.test(query));
  }

  // Выполнение безопасного GraphQL запроса
  async execute(query, variables = {}) {
    // Валидация запроса
    this.validateQuery(query);
    
    // Шифрование чувствительных переменных
    const secureVariables = await this.encryptSensitiveVariables(variables);
    
    const request = {
      query,
      variables: secureVariables
    };
    
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...this.headers
      },
      body: JSON.stringify(request)
    });
    
    if (!response.ok) {
      throw new Error(`GraphQL запрос не удался: ${response.status}`);
    }
    
    const result = await response.json();
    
    // Проверка результата на наличие ошибок
    if (result.errors) {
      throw new Error(`GraphQL ошибки: ${result.errors.map(e => e.message).join(', ')}`);
    }
    
    return result.data;
  }

  // Шифрование чувствительных переменных
  async encryptSensitiveVariables(variables) {
    const encryptedVars = { ...variables };
    const sensitiveKeys = ['password', 'token', 'secret', 'key'];
    
    for (const key of sensitiveKeys) {
      if (encryptedVars[key]) {
        encryptedVars[key] = await this.encryptValue(encryptedVars[key]);
      }
    }
    
    return encryptedVars;
  }

  // Шифрование значения
  async encryptValue(value) {
    const encoder = new TextEncoder();
    const data = encoder.encode(value.toString());
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}

// Использование безопасного GraphQL клиента
const graphQLClient = new SecureGraphQLClient('https://api.example.com/graphql', {
  headers: {
    'Authorization': 'Bearer your-token'
  }
});

// Безопасный запрос профиля пользователя
async function getUserProfile(userId) {
  const query = `
    query GetUser($id: ID!) {
      user(id: $id) {
        id
        name
        email
        profile {
          bio
          avatar
        }
      }
    }
  `;
  
  try {
    const result = await graphQLClient.execute(query, { id: userId });
    console.log('Профиль пользователя:', result.user);
    return result.user;
  } catch (error) {
    console.error('Ошибка GraphQL запроса:', error);
    throw error;
  }
}
```

## Защита от атак при передаче данных

### Защита от атак повторного воспроизведения

```javascript
// Реализация защиты от атак повторного воспроизведения
class ReplayAttackProtection {
  constructor() {
    this.nonceStore = new Map(); // Хранение использованных nonce
    this.maxAge = 300000; // 5 минут
    this.maxSize = 10000; // Максимальный размер хранилища
  }

  // Генерация уникального nonce
  generateNonce() {
    const timestamp = Date.now();
    const randomPart = crypto.getRandomValues(new Uint8Array(16));
    const nonce = `${timestamp}-${Array.from(randomPart, b => b.toString(16).padStart(2, '0')).join('')}`;
    return nonce;
  }

  // Проверка nonce на уникальность
  async validateNonce(nonce) {
    // Проверка формата nonce
    if (!this.isValidNonceFormat(nonce)) {
      return false;
    }

    // Проверка на повторное использование
    if (this.nonceStore.has(nonce)) {
      console.warn('Обнаружен повторный nonce:', nonce);
      return false;
    }

    // Проверка времени жизни nonce
    const timestamp = parseInt(nonce.split('-')[0]);
    if (Date.now() - timestamp > this.maxAge) {
      console.warn('Nonce просрочен:', nonce);
      return false;
    }

    // Сохранение nonce
    this.nonceStore.set(nonce, Date.now());

    // Очистка устаревших nonce
    this.cleanupExpiredNonces();

    return true;
  }

  // Проверка формата nonce
  isValidNonceFormat(nonce) {
    const pattern = /^\d{13}-[a-f0-9]{32}$/;
    return pattern.test(nonce);
  }

  // Очистка устаревших nonce
  cleanupExpiredNonces() {
    const now = Date.now();
    for (const [nonce, timestamp] of this.nonceStore) {
      if (now - timestamp > this.maxAge) {
        this.nonceStore.delete(nonce);
      }
    }

    // Ограничение размера хранилища
    if (this.nonceStore.size > this.maxSize) {
      const oldestEntries = Array.from(this.nonceStore.entries())
        .sort((a, b) => a[1] - b[1])
        .slice(0, this.maxSize / 2);
      
      oldestEntries.forEach(([nonce]) => this.nonceStore.delete(nonce));
    }
  }

  // Создание защищенного пакета данных
  async createSecurePacket(data) {
    const nonce = this.generateNonce();
    const timestamp = Date.now();
    
    const packet = {
      data,
      nonce,
      timestamp,
      // Добавление контрольной суммы
      checksum: await this.calculateChecksum(data)
    };
    
    // Подпись пакета
    packet.signature = await this.signPacket(packet);
    
    return packet;
  }

  // Проверка защищенного пакета данных
  async validateSecurePacket(packet) {
    // Проверка nonce
    if (!await this.validateNonce(packet.nonce)) {
      return { valid: false, reason: 'Invalid nonce' };
    }

    // Проверка контрольной суммы
    if (!await this.verifyChecksum(packet.data, packet.checksum)) {
      return { valid: false, reason: 'Invalid checksum' };
    }

    // Проверка подписи
    if (!await this.verifySignature(packet)) {
      return { valid: false, reason: 'Invalid signature' };
    }

    // Проверка времени (защита от атак с задержкой)
    const now = Date.now();
    if (now - packet.timestamp > this.maxAge) {
      return { valid: false, reason: 'Packet expired' };
    }

    return { valid: true, data: packet.data };
  }

  // Вычисление контрольной суммы
  async calculateChecksum(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  // Проверка контрольной суммы
  async verifyChecksum(data, expectedChecksum) {
    const actualChecksum = await this.calculateChecksum(data);
    return actualChecksum === expectedChecksum;
  }

  // Подпись пакета данных
  async signPacket(packet) {
    // В реальном приложении используется приватный ключ
    const dataToSign = JSON.stringify({
      data: packet.data,
      nonce: packet.nonce,
      timestamp: packet.timestamp,
      checksum: packet.checksum
    });
    
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(dataToSign);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  // Проверка подписи
  async verifySignature(packet) {
    const expectedSignature = await this.signPacket(packet);
    return packet.signature === expectedSignature;
  }
}

// Использование защиты от атак повторного воспроизведения
const replayProtection = new ReplayAttackProtection();

// Пример использования
async function secureDataTransfer(data) {
  // Создание защищенного пакета
  const securePacket = await replayProtection.createSecurePacket(data);
  
  // Имитация передачи данных
  const transmittedPacket = JSON.parse(JSON.stringify(securePacket));
  
  // Проверка полученного пакета
  const validation = await replayProtection.validateSecurePacket(transmittedPacket);
  
  if (validation.valid) {
    console.log('Данные успешно проверены:', validation.data);
    return validation.data;
  } else {
    console.error('Ошибка проверки пакета:', validation.reason);
    throw new Error(`Validation failed: ${validation.reason}`);
  }
}
```

## Мониторинг и аудит передачи данных

### Логирование безопасности передачи данных

```javascript
// Система логирования безопасности передачи данных
class DataTransmissionAudit {
  constructor() {
    this.logs = [];
    this.maxLogSize = 10000;
    this.alertThresholds = {
      high: 10,  // количество событий за 5 минут для высокого уровня
      critical: 20 // количество событий за 5 минут для критического уровня
    };
  }

  // Логирование события передачи данных
  logEvent(eventType, details) {
    const logEntry = {
      id: this.generateId(),
      timestamp: new Date().toISOString(),
      type: eventType,
      details: details,
      severity: this.determineSeverity(eventType),
      sourceIP: this.getClientIP(),
      userAgent: this.getUserAgent()
    };

    this.logs.push(logEntry);

    // Ограничение размера логов
    if (this.logs.length > this.maxLogSize) {
      this.logs = this.logs.slice(-this.maxLogSize);
    }

    // Проверка на необходимость оповещения
    this.checkForAlerts(logEntry);

    return logEntry;
  }

  // Определение уровня серьезности события
  determineSeverity(eventType) {
    const severityMap = {
      'DATA_SENT': 'INFO',
      'DATA_RECEIVED': 'INFO',
      'ENCRYPTION_ERROR': 'HIGH',
      'DECRYPTION_ERROR': 'HIGH',
      'CERTIFICATE_ERROR': 'HIGH',
      'AUTHENTICATION_FAILED': 'CRITICAL',
      'INTEGRITY_VIOLATION': 'CRITICAL',
      'REPLAY_ATTEMPT': 'CRITICAL',
      'UNAUTHORIZED_ACCESS': 'CRITICAL'
    };

    return severityMap[eventType] || 'MEDIUM';
  }

  // Проверка на необходимость оповещения
  checkForAlerts(newLog) {
    if (newLog.severity === 'CRITICAL') {
      this.generateCriticalAlert(newLog);
    }

    // Проверка частоты событий
    const recentEvents = this.getRecentEvents(300000); // за последние 5 минут
    const highSeverityCount = recentEvents.filter(e => e.severity === 'HIGH').length;
    const criticalSeverityCount = recentEvents.filter(e => e.severity === 'CRITICAL').length;

    if (highSeverityCount >= this.alertThresholds.high) {
      this.generateAlert('HIGH_ACTIVITY', {
        count: highSeverityCount,
        period: '5 minutes',
        type: 'HIGH_SEVERITY_EVENTS'
      });
    }

    if (criticalSeverityCount >= this.alertThresholds.critical) {
      this.generateAlert('CRITICAL_ACTIVITY', {
        count: criticalSeverityCount,
        period: '5 minutes',
        type: 'CRITICAL_SEVERITY_EVENTS'
      });
    }
  }

  // Получение недавних событий
  getRecentEvents(periodMs) {
    const now = Date.now();
    return this.logs.filter(log => 
      now - new Date(log.timestamp).getTime() <= periodMs
    );
  }

  // Генерация критического оповещения
  generateCriticalAlert(event) {
    console.error('КРИТИЧЕСКОЕ ОПОВЕЩЕНИЕ О БЕЗОПАСНОСТИ:', event);
    
    // В реальном приложении здесь будет:
    // - отправка оповещения администратору
    // - запись в внешнюю систему мониторинга
    // - возможная блокировка источника
  }

  // Генерация оповещения
  generateAlert(type, details) {
    const alert = {
      id: this.generateId(),
      timestamp: new Date().toISOString(),
      type: type,
      details: details,
      status: 'OPEN'
    };

    console.warn('ОПОВЕЩЕНИЕ:', alert);
  }

  // Генерация ID
  generateId() {
    return Math.random().toString(36).substr(2, 9) + 
           Date.now().toString(36);
  }

  // Получение IP клиента (в браузере это ограничено)
  getClientIP() {
    // В браузере точное определение IP невозможно из соображений конфиденциальности
    // В реальном приложении это будет определяться на сервере
    return 'CLIENT_IP_UNKNOWN';
  }

  // Получение User Agent
  getUserAgent() {
    return navigator.userAgent;
  }

  // Получение отчета о безопасности
  getSecurityReport() {
    const totalEvents = this.logs.length;
    const recentEvents = this.getRecentEvents(86400000); // за последние 24 часа
    
    const severityStats = {
      INFO: recentEvents.filter(e => e.severity === 'INFO').length,
      MEDIUM: recentEvents.filter(e => e.severity === 'MEDIUM').length,
      HIGH: recentEvents.filter(e => e.severity === 'HIGH').length,
      CRITICAL: recentEvents.filter(e => e.severity === 'CRITICAL').length
    };

    const typeStats = {};
    recentEvents.forEach(log => {
      typeStats[log.type] = (typeStats[log.type] || 0) + 1;
    });

    return {
      period: 'Last 24 hours',
      totalEvents: totalEvents,
      recentEvents: recentEvents.length,
      severityStats: severityStats,
      typeStats: typeStats,
      lastUpdated: new Date().toISOString()
    };
  }

  // Анонимизация логов для передачи
  anonymizeLogs(logs) {
    return logs.map(log => ({
      ...log,
      details: this.anonymizeDetails(log.details),
      sourceIP: this.anonymizeIP(log.sourceIP)
    }));
  }

  // Анонимизация деталей
  anonymizeDetails(details) {
    if (typeof details !== 'object' || details === null) return details;
    
    const anonymized = { ...details };
    
    // Удаление чувствительных данных
    ['token', 'password', 'secret', 'key', 'auth'].forEach(field => {
      if (anonymized[field]) {
        anonymized[field] = '[REDACTED]';
      }
    });
    
    return anonymized;
  }

  // Анонимизация IP
  anonymizeIP(ip) {
    if (!ip || ip === 'CLIENT_IP_UNKNOWN') return ip;
    
    // Анонимизация IP (оставляем только первые 2 октета для IPv4)
    const ipParts = ip.split('.');
    if (ipParts.length === 4) {
      return `${ipParts[0]}.${ipParts[1]}.XXX.XXX`;
    }
    
    return ip;
  }
}

// Использование системы аудита
const auditSystem = new DataTransmissionAudit();

// Пример использования в процессе передачи данных
async function secureDataTransferWithAudit(data) {
  try {
    // Логирование начала передачи
    auditSystem.logEvent('DATA_SENT', {
      dataSize: JSON.stringify(data).length,
      dataType: typeof data,
      destination: 'api.example.com'
    });

    // Выполнение безопасной передачи данных
    const result = await secureAPIClient('https://api.example.com/data', data);
    
    // Логирование успешной передачи
    auditSystem.logEvent('DATA_RECEIVED', {
      status: 'SUCCESS',
      dataSize: JSON.stringify(result).length
    });

    return result;
  } catch (error) {
    // Логирование ошибки
    auditSystem.logEvent('TRANSMISSION_ERROR', {
      error: error.message,
      severity: 'HIGH'
    });
    
    throw error;
  }
}
```

## Заключение

Безопасность передачи данных является критическим аспектом современных информационных систем. Эффективная защита требует комплексного подхода, включающего:

- Использование современных криптографических методов
- Реализацию безопасных протоколов передачи
- Защиту от известных типов атак
- Постоянный мониторинг и аудит процессов передачи данных

Ключевые принципы безопасной передачи данных:

- Шифрование данных при передаче
- Проверка подлинности участников
- Обеспечение целостности данных
- Защита от атак повторного воспроизведения
- Комплексный мониторинг безопасности

> [!tip] Совет
> Всегда используйте проверенные библиотеки и протоколы для шифрования данных, избегайте создания собственных криптографических решений.

> [!warning] Важно
> Регулярно обновляйте криптографические алгоритмы и протоколы в соответствии с последними рекомендациями безопасности.

> [!note] Примечание
> Безопасность передачи данных - это не разовое мероприятие, а непрерывный процесс, требующий постоянного внимания и обновлений.