---
aliases: ["Certificate Pinning", "Закрепление SSL", "Закрепление TLS"]
tags: ["security", "https", "ssl", "tls", "certificate-pinning", "encryption"]
---

# Закрепление сертификатов

Закрепление сертификатов (Certificate Pinning) - это метод безопасности, при котором клиентское приложение "закрепляет" или связывает определенные криптографические атрибуты серверного сертификата с конкретным сервером. Это предотвращает атаки типа "человек посередине" (MITM), когда злоумышленник использует поддельный сертификат, выданный компрометированным центром сертификации.

## Основы закрепления сертификатов

Закрепление сертификатов позволяет приложению проверять, что оно взаимодействует с ожидаемым сервером, даже если сертификат выглядит действительным с точки зрения цепочки доверия. Это особенно важно в мобильных приложениях и других средах, где доверие к центрам сертификации может быть скомпрометировано.

> [!warning] Важно
> Закрепление сертификатов должно использоваться как дополнительный уровень безопасности, а не как замена проверке сертификатов.

### Типы закрепления

1. **Закрепление сертификатов** - хранение хэша конкретного сертификата
2. **Закрепление публичного ключа** - хранение хэша публичного ключа
3. **Закрепление промежуточных сертификатов** - закрепление хэша промежуточного сертификата

## Реализация закрепления сертификатов

### Закрепление в мобильных приложениях (Android)

```java
// Пример реализации закрепления сертификатов в Android
public class CertificatePinner {
    private static final String HOSTNAME = "api.example.com";
    private static final String PIN_SHA256 = "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";

    public static OkHttpClient createSecureClient() {
        OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder();

        // Создание закрепления для конкретного хоста
        CertificatePinner certificatePinner = new CertificatePinner.Builder()
                .add(HOSTNAME, PIN_SHA256)
                .build();

        clientBuilder.certificatePinner(certificatePinner);

        return clientBuilder.build();
    }

    // Метод для получения хэша сертификата
    public static String getCertificatePin(X509Certificate certificate) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] publicKeyBytes = certificate.getPublicKey().getEncoded();
        byte[] hash = md.digest(publicKeyBytes);
        return "sha256/" + Base64.encodeToString(hash, Base64.NO_WRAP);
    }
}
```

### Закрепление в мобильных приложениях (iOS)

```swift
// Пример реализации закрепления сертификатов в iOS
import Foundation

class CertificatePinning: NSObject, URLSessionDelegate {
    private let pinnedCertificates: [Data]
    
    init(certificates: [Data]) {
        self.pinnedCertificates = certificates
    }
    
    func urlSession(_ session: URLSession, 
                    didReceive challenge: URLAuthenticationChallenge, 
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        guard let serverTrust = challenge.protectionSpace.serverTrust,
              let certificate = SecTrustGetCertificateAtIndex(serverTrust, 0) else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        let serverCertificateData = SecCertificateCopyData(certificate) as Data
        
        // Проверка, соответствует ли сертификат одному из закрепленных
        if pinnedCertificates.contains(serverCertificateData) {
            completionHandler(.useCredential, URLCredential(trust: serverTrust))
        } else {
            completionHandler(.cancelAuthenticationChallenge, nil)
        }
    }
    
    // Метод для получения данных сертификата
    static func getCertificateData(from url: String) -> Data? {
        guard let url = URL(string: url) else { return nil }
        
        var certData: Data?
        let semaphore = DispatchSemaphore(value: 0)
        
        URLSession.shared.dataTask(with: url) { _, response, _ in
            if let response = response as? HTTPURLResponse,
               let serverTrust = response.url?.host.flatMap({ SecTrustCreateWithCertificates($0, nil, nil) }),
               let certificate = SecTrustGetCertificateAtIndex(serverTrust, 0) {
                certData = SecCertificateCopyData(certificate) as Data
            }
            semaphore.signal()
        }.resume()
        
        semaphore.wait()
        return certData
    }
}
```

### Закрепление в веб-приложениях

```javascript
// Пример проверки закрепления сертификатов в веб-приложении
class CertificatePinner {
  constructor(pinnedCertHashes) {
    this.pinnedCertHashes = pinnedCertHashes;
  }

  // Вычисление хэша сертификата
  static async getCertificateHash(response) {
    // В браузере невозможно напрямую получить сертификат,
    // но можно использовать Subresource Integrity для проверки
    const certInfo = response.headers.get('X-Certificate-Info'); // Предполагаемый заголовок
    if (certInfo) {
      const encoder = new TextEncoder();
      const data = encoder.encode(certInfo);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return btoa(String.fromCharCode(...hashArray));
    }
    return null;
  }

  // Проверка закрепления сертификата
  async verifyCertificate(response) {
    const certHash = await this.getCertificateHash(response);
    
    if (!certHash) {
      throw new Error('Не удалось получить хэш сертификата');
    }

    if (!this.pinnedCertHashes.includes(certHash)) {
      throw new Error('Сертификат не соответствует закрепленным');
    }

    return true;
  }
}

// Использование закрепления сертификатов
const pinnedHashes = [
  'sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
  'sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB='
];

const pinner = new CertificatePinner(pinnedHashes);

// Пример использования при выполнении запроса
async function secureFetch(url) {
  const response = await fetch(url);
  
  try {
    await pinner.verifyCertificate(response);
    console.log('Закрепление сертификата прошло успешно');
    return response;
  } catch (error) {
    console.error('Ошибка закрепления сертификата:', error);
    throw error;
  }
}
```

### Закрепление с использованием Public Key Pinning

```javascript
// Реализация закрепления публичного ключа
class PublicKeyPinner {
  constructor(pinnedPublicKeys) {
    this.pinnedPublicKeys = pinnedPublicKeys;
  }

  // Получение публичного ключа из сертификата
  static getPublicKeyFromCertificate(certPEM) {
    // Извлечение публичного ключа из PEM-формата сертификата
    const cert = this.parseCertificate(certPEM);
    return cert.publicKey;
  }

  // Парсинг сертификата (упрощенная реализация)
  static parseCertificate(certPEM) {
    // В реальном приложении используйте специализированную библиотеку
    // для парсинга X.509 сертификатов
    const base64Cert = certPEM
      .replace('-----BEGIN CERTIFICATE-----', '')
      .replace('-----END CERTIFICATE-----', '')
      .replace(/\s/g, '');
    
    // Декодирование base64 и извлечение публичного ключа
    const certBuffer = Uint8Array.from(atob(base64Cert), c => c.charCodeAt(0));
    
    // В реальности нужно использовать библиотеку для парсинга ASN.1 структуры
    // и извлечения публичного ключа
    
    return {
      publicKey: certBuffer.slice(0, 100) // Заглушка
    };
  }

  // Вычисление хэша публичного ключа
  static async hashPublicKey(publicKey) {
    const hashBuffer = await crypto.subtle.digest('SHA-256', publicKey);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return btoa(String.fromCharCode(...hashArray));
  }

  // Проверка закрепления публичного ключа
  async verifyPublicKey(publicKey) {
    const keyHash = await PublicKeyPinner.hashPublicKey(publicKey);
    
    if (!this.pinnedPublicKeys.includes(keyHash)) {
      throw new Error('Публичный ключ не соответствует закрепленным');
    }

    return true;
  }
}
```

## Закрепление на уровне сервера

### Настройка закрепления на сервере (HSTS и HPKP)

```nginx
# Пример конфигурации Nginx с заголовками безопасности
server {
    listen 443 ssl http2;
    server_name example.com;

    # Заголовки безопасности
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    # Заголовок HTTP Public Key Pinning (HPKP) - устаревший, но для информации
    # add_header Public-Key-Pins 'pin-sha256="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; pin-sha256="BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB="; max-age=2592000; includeSubDomains';
    
    # Современная альтернатива HPKP - Certificate Transparency
    add_header Expect-CT "max-age=86400, enforce, report-uri='https://example.com/ct-report'";

    # Остальная конфигурация SSL
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
}
```

## Лучшие практики закрепления

### Многослойная стратегия

```javascript
// Многослойная стратегия закрепления сертификатов
class MultiLayerCertificatePinner {
  constructor(options = {}) {
    this.certificatePins = options.certificatePins || [];
    this.publicKeyPins = options.publicKeyPins || [];
    this.backupPins = options.backupPins || [];
    this.strictMode = options.strictMode || false;
  }

  // Проверка закрепления с поддержкой отката
  async verifyPinning(response) {
    try {
      // Попытка проверки основных закреплений
      if (await this.checkPrimaryPins(response)) {
        return true;
      }
    } catch (primaryError) {
      console.warn('Ошибка основной проверки закрепления:', primaryError);
      
      // В режиме строгой проверки не используем резервные варианты
      if (this.strictMode) {
        throw primaryError;
      }
      
      // Попытка проверки резервными закреплениями
      try {
        if (await this.checkBackupPins(response)) {
          console.warn('Используется резервное закрепление');
          return true;
        }
      } catch (backupError) {
        console.error('Ошибка резервной проверки закрепления:', backupError);
      }
      
      throw primaryError;
    }
  }

  async checkPrimaryPins(response) {
    // Проверка сертификата
    if (this.certificatePins.length > 0) {
      const certHash = await this.getCertificateHash(response);
      if (this.certificatePins.includes(certHash)) {
        return true;
      }
    }

    // Проверка публичного ключа
    if (this.publicKeyPins.length > 0) {
        const publicKeyHash = await this.getPublicKeyHash(response);
        if (this.publicKeyPins.includes(publicKeyHash)) {
          return true;
        }
    }

    return false;
  }

  async checkBackupPins(response) {
    // Проверка резервных закреплений
    const certHash = await this.getCertificateHash(response);
    return this.backupPins.includes(certHash);
  }

  async getCertificateHash(response) {
    // Реализация получения хэша сертификата
    // В браузере это ограничено, в мобильных приложениях - возможно
    const certInfo = response.headers.get('X-Certificate-Info');
    if (certInfo) {
      const encoder = new TextEncoder();
      const data = encoder.encode(certInfo);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return btoa(String.fromCharCode(...hashArray));
    }
    return null;
  }

  async getPublicKeyHash(response) {
    // Реализация получения хэша публичного ключа
    // Аналогично предыдущему методу
    return this.getCertificateHash(response); // Упрощенная реализация
  }
}
```

### Обновление закрепленных сертификатов

```javascript
// Менеджер обновления закрепленных сертификатов
class CertificatePinnerUpdater {
  constructor(storageKey = 'pinnedCertificates') {
    this.storageKey = storageKey;
  }

  // Сохранение закрепленных сертификатов
  savePins(pins) {
    localStorage.setItem(this.storageKey, JSON.stringify({
      pins: pins,
      timestamp: Date.now()
    }));
  }

  // Загрузка закрепленных сертификатов
  loadPins() {
    const stored = localStorage.getItem(this.storageKey);
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch (error) {
        console.error('Ошибка при загрузке закрепленных сертификатов:', error);
        return null;
      }
    }
    return null;
  }

  // Обновление закрепленных сертификатов с сервера
  async updatePinsFromServer(serverUrl) {
    try {
      const response = await fetch(`${serverUrl}/certificate-pins`);
      const newPins = await response.json();
      
      // Проверка целостности полученных данных
      if (this.validatePins(newPins)) {
        this.savePins(newPins);
        console.log('Закрепленные сертификаты обновлены');
        return newPins;
      } else {
        throw new Error('Полученные закрепления сертификатов недействительны');
      }
    } catch (error) {
      console.error('Ошибка обновления закрепленных сертификатов:', error);
      throw error;
    }
  }

  validatePins(pins) {
    // Проверка формата и валидности закреплений
    if (!Array.isArray(pins) || pins.length === 0) {
      return false;
    }

    // Проверка, что все закрепления имеют правильный формат
    return pins.every(pin => {
      return typeof pin === 'string' && 
             (pin.startsWith('sha256/') || pin.startsWith('sha1/'));
    });
  }

  // Проверка необходимости обновления
  shouldUpdate() {
    const stored = this.loadPins();
    if (!stored) {
      return true; // Нет сохраненных закреплений
    }

    // Обновление каждые 30 дней
    const daysSinceUpdate = (Date.now() - stored.timestamp) / (1000 * 60 * 60 * 24);
    return daysSinceUpdate > 30;
  }
}
```

## Риски и ограничения

### Риски закрепления сертификатов

1. **Проблемы с обслуживанием** - при смене сертификатов приложение может перестать работать
2. **Блокировка доступа** - при компрометации закрепленного сертификата пользователи не могут получить доступ к сервису
3. **Сложность обновления** - требуется распространение обновлений приложения для изменения закреплений

### Митигация рисков

```javascript
// Стратегия митигации рисков закрепления сертификатов
class RiskMitigationStrategy {
  constructor(options = {}) {
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelay || 5000; // 5 секунд
    this.allowBackupConnection = options.allowBackupConnection || true;
  }

  async withFallbackVerification(url, primaryValidator, backupValidator) {
    let lastError;

    // Попытка основной проверки
    try {
      return await primaryValidator(url);
    } catch (error) {
      console.warn('Основная проверка закрепления не удалась:', error);
      lastError = error;
    }

    // Если разрешено, попытка резервной проверки
    if (this.allowBackupConnection) {
      try {
        console.warn('Попытка резервной проверки закрепления');
        return await backupValidator(url);
      } catch (backupError) {
        console.error('Резервная проверка также не удалась:', backupError);
        lastError = backupError;
      }
    }

    throw lastError;
  }

  async retryWithExponentialBackoff(operation, maxRetries = 3) {
    let delay = 1000; // Начальный интервал 1 секунда

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        if (attempt === maxRetries - 1) {
          throw error; // Последняя попытка, бросаем ошибку
        }

        console.log(`Попытка ${attempt + 1} не удалась, следующая через ${delay}мс`);
        await this.delay(delay);
        delay *= 2; // Удвоение интервала (экспоненциальная отсрочка)
      }
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## Рекомендации по безопасности

- [[Реализация-HTTPS]] - правильная настройка HTTPS
- [[Сетевая-безопасность]] - общие принципы сетевой безопасности
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[SSL-TLS-настройка]] - настройка SSL/TLS

## Заключение

Закрепление сертификатов - мощный метод защиты от атак типа "человек посередине", но требует тщательного планирования и реализации. При правильной реализации закрепление сертификатов значительно повышает безопасность приложений, особенно в мобильной среде, где доверие к центрам сертификации может быть скомпрометировано.