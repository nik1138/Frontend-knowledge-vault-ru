---
aliases: ["Мониторинг безопасности", "Security Monitoring", "Безопасность систем", "Мониторинг угроз"]
tags: ["#security", "#monitoring", "#threat-detection", "#security-ops"]
---

# Мониторинг безопасности

## Введение

Мониторинг безопасности - это непрерывный процесс отслеживания, анализа и реагирования на события безопасности в системе. Эффективная система мониторинга безопасности позволяет обнаруживать атаки, уязвимости и другие инциденты в реальном времени, обеспечивая оперативное реагирование и минимизацию потенциального ущерба.

## Архитектура системы мониторинга безопасности

### 1. Компоненты системы мониторинга

```javascript
// Архитектура системы мониторинга безопасности
class SecurityMonitoringArchitecture {
    constructor(config) {
        this.config = {
            collectors: config.collectors || ['logs', 'network', 'system', 'application'],
            processors: config.processors || ['normalization', 'correlation', 'enrichment'],
            analyzers: config.analyzers || ['rule-based', 'ml', 'behavioral'],
            storages: config.storages || ['elasticsearch', 'influxdb'],
            alerting: config.alerting || ['email', 'slack', 'webhook'],
            retention: config.retention || { logs: '90d', alerts: '365d' },
            ...config
        };
        
        this.components = {
            logCollector: new LogCollector(this.config.collectors.logs),
            networkMonitor: new NetworkMonitor(this.config.collectors.network),
            systemMonitor: new SystemMonitor(this.config.collectors.system),
            applicationMonitor: new ApplicationMonitor(this.config.collectors.application),
            
            eventProcessor: new EventProcessor(this.config.processors),
            threatAnalyzer: new ThreatAnalyzer(this.config.analyzers),
            alertManager: new AlertManager(this.config.alerting),
            dataStorage: new DataStorage(this.config.storages),
            
            dashboard: new SecurityDashboard(),
            api: new SecurityMonitoringAPI()
        };
        
        this.state = {
            collectors: new Map(),
            processors: new Map(),
            analyzers: new Map(),
            alerts: [],
            metrics: new Map(),
            lastProcessed: new Date(0)
        };
    }
    
    async initialize() {
        console.log('Initializing Security Monitoring Architecture...');
        
        // Инициализация всех компонентов
        await Promise.all([
            this.components.logCollector.initialize(),
            this.components.networkMonitor.initialize(),
            this.components.systemMonitor.initialize(),
            this.components.applicationMonitor.initialize(),
            this.components.dataStorage.initialize(),
            this.components.alertManager.initialize()
        ]);
        
        // Запуск коллекции данных
        this.startDataCollection();
        
        // Запуск анализа
        this.startThreatAnalysis();
        
        // Запуск мониторинга метрик
        this.startMetricsCollection();
        
        console.log('Security Monitoring Architecture initialized successfully');
    }
    
    startDataCollection() {
        // Запуск коллекции данных из различных источников
        if (this.config.collectors.includes('logs')) {
            this.components.logCollector.startCollection();
        }
        
        if (this.config.collectors.includes('network')) {
            this.components.networkMonitor.startMonitoring();
        }
        
        if (this.config.collectors.includes('system')) {
            this.components.systemMonitor.startMonitoring();
        }
        
        if (this.config.collectors.includes('application')) {
            this.components.applicationMonitor.startMonitoring();
        }
    }
    
    startThreatAnalysis() {
        // Запуск анализа угроз
        setInterval(async () => {
            await this.performThreatAnalysis();
        }, this.config.analysisInterval || 30000); // каждые 30 секунд
    }
    
    async performThreatAnalysis() {
        try {
            // Получение событий для анализа
            const events = await this.getEventsForAnalysis();
            
            if (events.length === 0) {
                return; // нет событий для анализа
            }
            
            // Обработка событий
            const processedEvents = await this.components.eventProcessor.processEvents(events);
            
            // Анализ угроз
            const threats = await this.components.threatAnalyzer.analyze(processedEvents);
            
            // Генерация алертов
            if (threats.length > 0) {
                await this.components.alertManager.generateAlerts(threats);
            }
            
            // Сохранение результатов
            await this.components.dataStorage.storeAnalysisResults(threats);
            
            // Обновление состояния
            this.state.lastProcessed = new Date();
            this.updateMetrics({ analyzedEvents: events.length, detectedThreats: threats.length });
            
        } catch (error) {
            console.error('Threat analysis failed:', error);
            this.handleAnalysisError(error);
        }
    }
    
    async getEventsForAnalysis() {
        // Получение событий из всех источников
        const allEvents = [];
        
        // События из логов
        const logEvents = await this.components.logCollector.getRecentEvents();
        allEvents.push(...logEvents);
        
        // События из сети
        const networkEvents = await this.components.networkMonitor.getRecentEvents();
        allEvents.push(...networkEvents);
        
        // Системные события
        const systemEvents = await this.components.systemMonitor.getRecentEvents();
        allEvents.push(...systemEvents);
        
        // События приложения
        const appEvents = await this.components.applicationMonitor.getRecentEvents();
        allEvents.push(...appEvents);
        
        return allEvents;
    }
    
    updateMetrics(data) {
        // Обновление метрик системы
        for (const [key, value] of Object.entries(data)) {
            const current = this.state.metrics.get(key) || 0;
            this.state.metrics.set(key, current + value);
        }
    }
    
    async handleAnalysisError(error) {
        // Обработка ошибок анализа
        console.error('Analysis error occurred:', error);
        
        // Отправка уведомления об ошибке
        await this.components.alertManager.sendSystemAlert({
            type: 'ANALYSIS_ERROR',
            severity: 'HIGH',
            message: `Threat analysis failed: ${error.message}`,
            error: error
        });
    }
    
    startMetricsCollection() {
        // Запуск сбора метрик
        setInterval(() => {
            this.collectSystemMetrics();
        }, this.config.metricsInterval || 60000); // каждую минуту
    }
    
    async collectSystemMetrics() {
        const metrics = {
            timestamp: new Date().toISOString(),
            collectors: await this.getCollectorMetrics(),
            processors: await this.getProcessorMetrics(),
            analyzers: await this.getAnalyzerMetrics(),
            storage: await this.getStorageMetrics(),
            overall: this.getOverallMetrics()
        };
        
        await this.components.dataStorage.storeMetrics(metrics);
        
        // Обновление дашборда
        this.components.dashboard.updateMetrics(metrics);
    }
    
    async getCollectorMetrics() {
        return {
            logCollector: await this.components.logCollector.getMetrics(),
            networkMonitor: await this.components.networkMonitor.getMetrics(),
            systemMonitor: await this.components.systemMonitor.getMetrics(),
            applicationMonitor: await this.components.applicationMonitor.getMetrics()
        };
    }
    
    async getProcessorMetrics() {
        return await this.components.eventProcessor.getMetrics();
    }
    
    async getAnalyzerMetrics() {
        return await this.components.threatAnalyzer.getMetrics();
    }
    
    async getStorageMetrics() {
        return await this.components.dataStorage.getMetrics();
    }
    
    getOverallMetrics() {
        return {
            totalEvents: this.state.metrics.get('totalEvents') || 0,
            analyzedEvents: this.state.metrics.get('analyzedEvents') || 0,
            detectedThreats: this.state.metrics.get('detectedThreats') || 0,
            falsePositives: this.state.metrics.get('falsePositives') || 0,
            processingRate: this.calculateProcessingRate(),
            detectionRate: this.calculateDetectionRate()
        };
    }
    
    calculateProcessingRate() {
        const analyzed = this.state.metrics.get('analyzedEvents') || 0;
        const elapsed = (Date.now() - this.state.lastProcessed) / 1000; // в секундах
        return elapsed > 0 ? analyzed / elapsed : 0;
    }
    
    calculateDetectionRate() {
        const analyzed = this.state.metrics.get('analyzedEvents') || 0;
        const threats = this.state.metrics.get('detectedThreats') || 0;
        return analyzed > 0 ? (threats / analyzed) * 100 : 0;
    }
    
    async getSecurityDashboard() {
        return {
            summary: this.getSummary(),
            recentEvents: await this.getRecentEvents(50),
            activeAlerts: await this.getActiveAlerts(),
            systemMetrics: this.getOverallMetrics(),
            componentStatus: await this.getComponentStatus(),
            recommendations: await this.getSecurityRecommendations()
        };
    }
    
    getSummary() {
        return {
            totalEvents: this.state.metrics.get('totalEvents') || 0,
            threatsDetected: this.state.metrics.get('detectedThreats') || 0,
            falsePositives: this.state.metrics.get('falsePositives') || 0,
            lastAnalysis: this.state.lastProcessed.toISOString(),
            processingRate: this.calculateProcessingRate(),
            detectionRate: this.calculateDetectionRate(),
            overallStatus: this.getOverallStatus()
        };
    }
    
    async getRecentEvents(limit = 100) {
        // Получение последних событий из хранилища
        return await this.components.dataStorage.getRecentEvents(limit);
    }
    
    async getActiveAlerts() {
        // Получение активных алертов
        return await this.components.alertManager.getActiveAlerts();
    }
    
    async getComponentStatus() {
        return {
            logCollector: await this.components.logCollector.getStatus(),
            networkMonitor: await this.components.networkMonitor.getStatus(),
            systemMonitor: await this.components.systemMonitor.getStatus(),
            applicationMonitor: await this.components.applicationMonitor.getStatus(),
            eventProcessor: await this.components.eventProcessor.getStatus(),
            threatAnalyzer: await this.components.threatAnalyzer.getStatus(),
            dataStorage: await this.components.dataStorage.getStatus(),
            alertManager: await this.components.alertManager.getStatus()
        };
    }
    
    async getSecurityRecommendations() {
        const metrics = this.getOverallMetrics();
        const recommendations = [];
        
        if (metrics.detectionRate < 1) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Improve Threat Detection Rate',
                description: `Current detection rate is ${metrics.detectionRate.toFixed(2)}%, target is 2%+`,
                action: 'Review and tune threat detection rules'
            });
        }
        
        if (metrics.falsePositiveRate > 20) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Reduce False Positive Rate',
                description: `Current false positive rate is too high`,
                action: 'Fine-tune detection rules to reduce noise'
            });
        }
        
        if (metrics.processingRate < 10) { // событий в секунду
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Processing Performance',
                description: `Current processing rate is ${metrics.processingRate.toFixed(2)} events/sec`,
                action: 'Optimize system performance and resource allocation'
            });
        }
        
        return recommendations;
    }
    
    getOverallStatus() {
        const criticalComponents = [
            this.components.logCollector,
            this.components.threatAnalyzer,
            this.components.alertManager,
            this.components.dataStorage
        ];
        
        const allHealthy = criticalComponents.every(comp => comp.isHealthy());
        
        if (!allHealthy) return 'CRITICAL';
        if (this.state.metrics.get('detectedThreats') > 0) return 'WARNING';
        return 'HEALTHY';
    }
    
    async shutdown() {
        console.log('Shutting down Security Monitoring Architecture...');
        
        await Promise.all([
            this.components.logCollector.shutdown(),
            this.components.networkMonitor.shutdown(),
            this.components.systemMonitor.shutdown(),
            this.components.applicationMonitor.shutdown(),
            this.components.dataStorage.shutdown()
        ]);
        
        console.log('Security Monitoring Architecture shutdown completed');
    }
}

// Использование архитектуры мониторинга
const securityArch = new SecurityMonitoringArchitecture({
    collectors: ['logs', 'network', 'application'],
    processors: ['normalization', 'correlation'],
    analyzers: ['rule-based', 'ml'],
    retention: { logs: '90d', alerts: '365d' },
    analysisInterval: 30000,
    metricsInterval: 60000
});

// Запуск системы
securityArch.initialize().catch(console.error);
```

### 2. Сбор данных

```javascript
// Система сбора данных для мониторинга безопасности
class DataCollector {
    constructor(config) {
        this.config = config;
        this.dataSources = new Map();
        this.collectionRules = [];
        this.filters = [];
        this.normalizers = [];
        this.enrichers = [];
    }
    
    addDataSource(name, source) {
        this.dataSources.set(name, source);
    }
    
    addCollectionRule(rule) {
        this.collectionRules.push(rule);
    }
    
    addFilter(filter) {
        this.filters.push(filter);
    }
    
    addNormalizer(normalizer) {
        this.normalizers.push(normalizer);
    }
    
    addEnricher(enricher) {
        this.enrichers.push(enricher);
    }
}

// Коллектор логов
class LogCollector extends DataCollector {
    constructor(config) {
        super(config);
        this.logSources = config.sources || ['file', 'syslog', 'application'];
        this.logFormat = config.format || 'json';
        this.logRetention = config.retention || '7d';
        this.logBufferSize = config.bufferSize || 1000;
        
        this.buffer = [];
        this.handlers = new Map();
    }
    
    async initialize() {
        // Инициализация различных источников логов
        if (this.logSources.includes('file')) {
            await this.setupFileLogCollection();
        }
        
        if (this.logSources.includes('syslog')) {
            await this.setupSyslogCollection();
        }
        
        if (this.logSources.includes('application')) {
            await this.setupApplicationLogCollection();
        }
        
        // Установка обработчиков
        this.setupLogHandlers();
    }
    
    async setupFileLogCollection() {
        const fs = require('fs');
        const readline = require('readline');
        
        // Наблюдение за файлами логов
        const logFiles = [
            '/var/log/nginx/access.log',
            '/var/log/nginx/error.log',
            '/var/log/apache2/access.log',
            '/var/log/apache2/error.log',
            './logs/app.log',
            './logs/security.log'
        ];
        
        for (const file of logFiles) {
            if (fs.existsSync(file)) {
                const stream = fs.createReadStream(file);
                const rl = readline.createInterface({
                    input: stream,
                    crlfDelay: Infinity
                });
                
                rl.on('line', (line) => {
                    this.processLogLine(line, file);
                });
                
                this.handlers.set(file, rl);
            }
        }
    }
    
    async setupSyslogCollection() {
        // Установка Syslog сервера для приема удаленных логов
        const dgram = require('dgram');
        const server = dgram.createSocket('udp4');
        
        server.on('message', (msg, rinfo) => {
            this.processSyslogMessage(msg.toString(), rinfo.address);
        });
        
        server.on('listening', () => {
            const address = server.address();
            console.log(`Syslog server listening on ${address.address}:${address.port}`);
        });
        
        server.bind(this.config.syslogPort || 514);
        this.handlers.set('syslog', server);
    }
    
    async setupApplicationLogCollection() {
        // Интеграция с системами логирования приложения
        const winston = require('winston');
        
        const logger = winston.createLogger({
            level: 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ filename: 'security-events.log' }),
                new winston.transports.Console()
            ]
        });
        
        // Перехват логов безопасности
        global.securityLogger = logger;
        
        // Интеграция с существующей системой логирования
        this.interceptApplicationLogs(logger);
    }
    
    interceptApplicationLogs(logger) {
        // Перехват и обработка логов приложения
        const originalLog = logger.log;
        
        logger.log = (level, message, meta) => {
            // Проверка на события безопасности
            if (this.isSecurityEvent(message, meta)) {
                this.processSecurityEvent({
                    level,
                    message,
                    meta,
                    timestamp: new Date().toISOString()
                });
            }
            
            return originalLog.call(logger, level, message, meta);
        };
    }
    
    isSecurityEvent(message, meta) {
        // Определение событий безопасности
        const securityKeywords = [
            'authentication', 'authorization', 'access denied', 'failed login',
            'unauthorized', 'blocked', 'intrusion', 'attack', 'vulnerability',
            'security', 'breach', 'compromise', 'malware', 'phishing'
        ];
        
        const msgLower = (message || '').toLowerCase();
        const metaStr = JSON.stringify(meta || {}).toLowerCase();
        
        return securityKeywords.some(keyword => 
            msgLower.includes(keyword) || metaStr.includes(keyword)
        );
    }
    
    processLogLine(line, sourceFile) {
        try {
            let logEntry;
            
            if (this.logFormat === 'json') {
                logEntry = JSON.parse(line);
            } else {
                logEntry = this.parseStructuredLog(line);
            }
            
            // Применение фильтров
            if (this.applyFilters(logEntry)) {
                // Нормализация
                const normalized = this.normalizeLogEntry(logEntry);
                
                // Обогащение
                const enriched = this.enrichLogEntry(normalized);
                
                // Добавление в буфер
                this.addToBuffer(enriched);
            }
        } catch (error) {
            console.error(`Failed to process log line from ${sourceFile}:`, error.message);
        }
    }
    
    parseStructuredLog(line) {
        // Парсинг структурированных логов
        // В реальности использовать более сложные парсеры
        const timestampMatch = line.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z?)\]/);
        const levelMatch = line.match(/\s+(INFO|ERROR|WARN|DEBUG|CRITICAL)\s+/);
        const messageMatch = line.match(/]\s+(.+)$/);
        
        return {
            timestamp: timestampMatch ? timestampMatch[1] : new Date().toISOString(),
            level: levelMatch ? levelMatch[1] : 'INFO',
            message: messageMatch ? messageMatch[1] : line,
            source: 'structured-log',
            raw: line
        };
    }
    
    applyFilters(logEntry) {
        // Применение фильтров к логу
        for (const filter of this.filters) {
            if (!filter.match(logEntry)) {
                return false; // лог не проходит фильтр
            }
        }
        return true;
    }
    
    normalizeLogEntry(logEntry) {
        // Нормализация формата лога
        const normalized = {
            timestamp: logEntry.timestamp || new Date().toISOString(),
            level: logEntry.level || 'INFO',
            message: logEntry.message || logEntry.msg || logEntry.log,
            source: logEntry.source || logEntry.logger || 'unknown',
            category: logEntry.category || this.categorizeLog(logEntry),
            severity: logEntry.severity || this.assessSeverity(logEntry),
            context: logEntry.context || logEntry.meta || {},
            raw: logEntry
        };
        
        // Добавление информации из контекста
        if (logEntry.ip || logEntry.remote_addr) {
            normalized.context.ip = logEntry.ip || logEntry.remote_addr;
        }
        
        if (logEntry.user || logEntry.userId) {
            normalized.context.user = logEntry.user || logEntry.userId;
        }
        
        if (logEntry.url || logEntry.path) {
            normalized.context.url = logEntry.url || logEntry.path;
        }
        
        return normalized;
    }
    
    enrichLogEntry(logEntry) {
        // Обогащение лога дополнительной информацией
        const enriched = { ...logEntry };
        
        // Добавление геолокации IP
        if (enriched.context.ip) {
            enriched.context.geoLocation = this.getGeoLocation(enriched.context.ip);
        }
        
        // Добавление информации о пользователе
        if (enriched.context.user) {
            enriched.context.userInfo = this.getUserInfo(enriched.context.user);
        }
        
        // Добавление информации о системе
        enriched.context.systemInfo = {
            hostname: require('os').hostname(),
            platform: process.platform,
            arch: process.arch,
            nodeVersion: process.version
        };
        
        return enriched;
    }
    
    categorizeLog(logEntry) {
        const message = (logEntry.message || logEntry.msg || '').toLowerCase();
        
        if (message.includes('auth') || message.includes('login') || message.includes('password')) {
            return 'authentication';
        }
        
        if (message.includes('sql') || message.includes('query') || message.includes('database')) {
            return 'database';
        }
        
        if (message.includes('file') || message.includes('upload') || message.includes('download')) {
            return 'file-access';
        }
        
        if (message.includes('xss') || message.includes('csrf') || message.includes('injection')) {
            return 'security';
        }
        
        return 'general';
    }
    
    assessSeverity(logEntry) {
        const message = (logEntry.message || logEntry.msg || '').toLowerCase();
        const level = (logEntry.level || logEntry.level).toUpperCase();
        
        // Оценка тяжести на основе уровня лога
        if (level === 'CRITICAL' || level === 'FATAL') return 'CRITICAL';
        if (level === 'ERROR') return 'HIGH';
        if (level === 'WARN' || level === 'WARNING') return 'MEDIUM';
        if (level === 'INFO') return 'LOW';
        
        // Оценка на основе содержимого сообщения
        if (message.includes('critical') || message.includes('emergency')) return 'CRITICAL';
        if (message.includes('error') || message.includes('failed') || message.includes('attack')) return 'HIGH';
        if (message.includes('warning') || message.includes('suspicious')) return 'MEDIUM';
        if (message.includes('info') || message.includes('access')) return 'LOW';
        
        return 'INFO';
    }
    
    addToBuffer(logEntry) {
        this.buffer.push(logEntry);
        
        // Ограничение размера буфера
        if (this.buffer.length > this.logBufferSize) {
            this.buffer = this.buffer.slice(-this.logBufferSize);
        }
        
        // Проверка необходимости отправки
        if (this.buffer.length >= this.config.batchSize || 
            Date.now() - (this.lastBatchTime || 0) > this.config.batchInterval) {
            this.sendBatch();
        }
    }
    
    async sendBatch() {
        if (this.buffer.length === 0) return;
        
        const batch = [...this.buffer];
        this.buffer = [];
        this.lastBatchTime = Date.now();
        
        // Отправка батча в систему анализа
        await this.forwardToAnalyzer(batch);
    }
    
    async forwardToAnalyzer(batch) {
        // Отправка батча в систему анализа
        // В реальности использовать очередь сообщений (Redis, Kafka и т.д.)
        console.log(`Forwarding ${batch.length} log entries to analyzer`);
    }
    
    async getRecentEvents(limit = 100) {
        return this.buffer.slice(-limit);
    }
    
    async getMetrics() {
        return {
            bufferSize: this.buffer.length,
            totalCollected: this.totalCollected || 0,
            bySeverity: this.countBySeverity(this.buffer),
            byCategory: this.countByCategory(this.buffer),
            collectionRate: this.calculateCollectionRate()
        };
    }
    
    countBySeverity(events) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
        
        for (const event of events) {
            counts[event.severity] = (counts[event.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    countByCategory(events) {
        const counts = {};
        
        for (const event of events) {
            counts[event.category] = (counts[event.category] || 0) + 1;
        }
        
        return counts;
    }
    
    calculateCollectionRate() {
        // В реальности рассчитывать на основе времени
        return 0; // заглушка
    }
    
    isHealthy() {
        return this.buffer.length < this.logBufferSize * 0.9; // здоров, если буфер не переполнен
    }
    
    async getStatus() {
        return {
            healthy: this.isHealthy(),
            metrics: await this.getMetrics(),
            lastCollection: this.lastBatchTime
        };
    }
    
    async shutdown() {
        // Завершение сбора логов
        for (const [name, handler] of this.handlers) {
            if (typeof handler.close === 'function') {
                handler.close();
            } else if (typeof handler.destroy === 'function') {
                handler.destroy();
            }
        }
        
        // Отправка оставшихся данных
        await this.sendBatch();
    }
    
    async getGeoLocation(ip) {
        // Получение геолокации IP
        // В реальности использовать сервис геолокации
        return { country: 'Unknown', city: 'Unknown' }; // заглушка
    }
    
    async getUserInfo(userId) {
        // Получение информации о пользователе
        // В реальности использовать систему аутентификации
        return { id: userId, role: 'unknown' }; // заглушка
    }
}

// Коллектор сетевых событий
class NetworkMonitor extends DataCollector {
    constructor(config) {
        super(config);
        this.interfaces = config.interfaces || ['eth0', 'wlan0'];
        this.ports = config.ports || [80, 443, 22, 3306, 5432];
        this.protocols = config.protocols || ['tcp', 'udp', 'icmp'];
        this.packetCapture = config.packetCapture || false;
    }
    
    async initialize() {
        if (this.packetCapture) {
            await this.setupPacketCapture();
        }
        
        await this.setupConnectionMonitoring();
        await this.setupPortMonitoring();
    }
    
    async setupPacketCapture() {
        // Установка захвата пакетов (требует прав суперпользователя)
        if (process.env.NODE_ENV === 'production') {
            // В продакшене использовать tcpdump или другие инструменты
            this.packetCaptureEnabled = false;
            console.warn('Packet capture requires elevated privileges, running in simulation mode');
        } else {
            this.packetCaptureEnabled = true;
            this.startSimulationCapture();
        }
    }
    
    startSimulationCapture() {
        // Симуляция захвата пакетов для разработки
        setInterval(() => {
            const simulatedPackets = this.generateSimulatedPackets();
            this.processNetworkPackets(simulatedPackets);
        }, 1000); // каждую секунду
    }
    
    generateSimulatedPackets() {
        // Генерация симулированных сетевых пакетов
        const protocols = ['TCP', 'UDP', 'ICMP'];
        const srcIps = ['192.168.1.100', '10.0.0.50', '172.16.0.25'];
        const dstIps = ['192.168.1.1', '8.8.8.8', '1.1.1.1'];
        
        return Array.from({ length: 5 }, () => ({
            timestamp: new Date().toISOString(),
            sourceIP: srcIps[Math.floor(Math.random() * srcIps.length)],
            destinationIP: dstIps[Math.floor(Math.random() * dstIps.length)],
            sourcePort: Math.floor(Math.random() * 65535) + 1,
            destinationPort: Math.floor(Math.random() * 65535) + 1,
            protocol: protocols[Math.floor(Math.random() * protocols.length)],
            size: Math.floor(Math.random() * 1500) + 1,
            flags: Math.random() > 0.5 ? 'SYN' : 'ACK',
            direction: Math.random() > 0.5 ? 'incoming' : 'outgoing'
        }));
    }
    
    async setupConnectionMonitoring() {
        // Мониторинг активных соединений
        const os = require('os');
        const networkInterfaces = os.networkInterfaces();
        
        for (const [iface, addresses] of Object.entries(networkInterfaces)) {
            if (this.interfaces.includes(iface)) {
                for (const addr of addresses) {
                    if (!addr.internal && addr.family === 'IPv4') {
                        console.log(`Monitoring network interface: ${iface} (${addr.address})`);
                    }
                }
            }
        }
        
        // Регулярная проверка активных соединений
        setInterval(async () => {
            const connections = await this.getActiveConnections();
            this.processNetworkConnections(connections);
        }, this.config.connectionCheckInterval || 5000);
    }
    
    async setupPortMonitoring() {
        // Мониторинг прослушиваемых портов
        setInterval(async () => {
            const listeningPorts = await this.getListeningPorts();
            this.processListeningPorts(listeningPorts);
        }, this.config.portCheckInterval || 10000);
    }
    
    async getActiveConnections() {
        // Получение активных соединений (в реальности использовать системные вызовы)
        // Заглушка для демонстрации
        return [
            { localAddr: '192.168.1.100:3000', remoteAddr: '10.0.0.50:54321', state: 'ESTABLISHED', protocol: 'TCP' },
            { localAddr: '192.168.1.100:3000', remoteAddr: '8.8.8.8:53', state: 'ESTABLISHED', protocol: 'UDP' }
        ];
    }
    
    async getListeningPorts() {
        // Получение прослушиваемых портов
        // В реальности использовать системные вызовы
        return [
            { port: 3000, protocol: 'TCP', process: 'node' },
            { port: 22, protocol: 'TCP', process: 'sshd' },
            { port: 53, protocol: 'UDP', process: 'dnsmasq' }
        ];
    }
    
    processNetworkPackets(packets) {
        for (const packet of packets) {
            const event = {
                type: 'NETWORK_PACKET',
                timestamp: packet.timestamp,
                sourceIP: packet.sourceIP,
                destinationIP: packet.destinationIP,
                sourcePort: packet.sourcePort,
                destinationPort: packet.destinationPort,
                protocol: packet.protocol,
                size: packet.size,
                flags: packet.flags,
                direction: packet.direction,
                category: 'network_activity',
                severity: this.assessNetworkPacketSeverity(packet)
            };
            
            this.addToBuffer(event);
        }
    }
    
    processNetworkConnections(connections) {
        for (const conn of connections) {
            const event = {
                type: 'NETWORK_CONNECTION',
                timestamp: new Date().toISOString(),
                localAddress: conn.localAddr,
                remoteAddress: conn.remoteAddr,
                state: conn.state,
                protocol: conn.protocol,
                category: 'connection_monitoring',
                severity: this.assessConnectionSeverity(conn)
            };
            
            // Проверка на подозрительные соединения
            if (this.isSuspiciousConnection(conn)) {
                event.severity = 'HIGH';
                event.category = 'security_alert';
                event.suspicious = true;
            }
            
            this.addToBuffer(event);
        }
    }
    
    processListeningPorts(ports) {
        for (const port of ports) {
            const event = {
                type: 'PORT_LISTENING',
                timestamp: new Date().toISOString(),
                port: port.port,
                protocol: port.protocol,
                process: port.process,
                category: 'port_monitoring',
                severity: this.assessPortSeverity(port)
            };
            
            // Проверка на подозрительные порты
            if (this.isSuspiciousPort(port)) {
                event.severity = 'MEDIUM';
                event.category = 'security_alert';
                event.suspicious = true;
            }
            
            this.addToBuffer(event);
        }
    }
    
    assessNetworkPacketSeverity(packet) {
        // Оценка тяжести сетевого пакета
        if (packet.flags === 'SYN' && packet.size > 1000) {
            return 'MEDIUM'; // потенциальный SYN flood
        }
        
        if (packet.destinationPort === 22 && packet.sourceIP.startsWith('192.168.')) {
            return 'LOW'; // SSH из внутренней сети
        }
        
        if (['127.0.0.1', '::1'].includes(packet.sourceIP)) {
            return 'INFO'; // локальный трафик
        }
        
        return 'LOW';
    }
    
    assessConnectionSeverity(connection) {
        // Оценка тяжести соединения
        if (connection.state === 'LISTEN') {
            return 'INFO'; // прослушивание порта
        }
        
        if (connection.state === 'SYN_SENT') {
            return 'LOW'; // исходящее соединение
        }
        
        if (connection.state === 'ESTABLISHED') {
            return 'INFO'; // установленное соединение
        }
        
        return 'MEDIUM'; // другие состояния
    }
    
    assessPortSeverity(port) {
        // Оценка тяжести порта
        const criticalPorts = [22, 23, 3389, 5900, 445, 139];
        const sensitivePorts = [80, 443, 3306, 5432, 6379, 27017];
        
        if (criticalPorts.includes(port.port)) {
            return 'HIGH';
        }
        
        if (sensitivePorts.includes(port.port)) {
            return 'MEDIUM';
        }
        
        return 'LOW';
    }
    
    isSuspiciousConnection(connection) {
        // Проверка на подозрительное соединение
        const suspiciousPatterns = [
            connection.remoteAddress?.includes('10.0.0.'),
            connection.state === 'SYN_RECEIVED',
            connection.protocol === 'UDP' && connection.destinationPort === 53 // DNS
        ];
        
        return suspiciousPatterns.some(Boolean);
    }
    
    isSuspiciousPort(port) {
        // Проверка на подозрительный порт
        const suspiciousPorts = [8080, 8443, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999];
        return suspiciousPorts.includes(port.port);
    }
    
    async startMonitoring() {
        // Запуск мониторинга сетевых событий
        console.log('Network monitoring started');
    }
}

// Коллектор системных событий
class SystemMonitor extends DataCollector {
    constructor(config) {
        super(config);
        this.monitoringTargets = config.targets || ['filesystem', 'processes', 'authentication'];
        this.fileMonitoring = config.fileMonitoring || {};
        this.processMonitoring = config.processMonitoring || {};
        this.authMonitoring = config.authMonitoring || {};
    }
    
    async initialize() {
        if (this.monitoringTargets.includes('filesystem')) {
            await this.setupFilesystemMonitoring();
        }
        
        if (this.monitoringTargets.includes('processes')) {
            await this.setupProcessMonitoring();
        }
        
        if (this.monitoringTargets.includes('authentication')) {
            await this.setupAuthenticationMonitoring();
        }
    }
    
    async setupFilesystemMonitoring() {
        const chokidar = require('chokidar');
        
        // Мониторинг изменений в критических директориях
        const criticalDirs = [
            '/etc/',
            '/var/log/',
            '/usr/bin/',
            '/usr/sbin/',
            './config/',
            './secrets/',
            './keys/'
        ];
        
        for (const dir of criticalDirs) {
            if (require('fs').existsSync(dir)) {
                const watcher = chokidar.watch(dir, {
                    persistent: true,
                    ignoreInitial: true
                });
                
                watcher.on('add', (path) => this.handleFileEvent('FILE_CREATED', path));
                watcher.on('change', (path) => this.handleFileEvent('FILE_MODIFIED', path));
                watcher.on('unlink', (path) => this.handleFileEvent('FILE_DELETED', path));
                watcher.on('error', (error) => this.handleFileError(error));
                
                this.handlers.set(`fs_${dir}`, watcher);
            }
        }
    }
    
    async setupProcessMonitoring() {
        // Мониторинг процессов системы
        setInterval(async () => {
            const processes = await this.getActiveProcesses();
            this.processSystemProcesses(processes);
        }, this.config.processCheckInterval || 30000);
    }
    
    async setupAuthenticationMonitoring() {
        // Мониторинг событий аутентификации
        if (process.platform === 'linux') {
            // Мониторинг /var/log/auth.log на Linux
            const authWatcher = require('chokidar').watch('/var/log/auth.log', {
                persistent: true
            });
            
            authWatcher.on('change', (path) => {
                this.handleAuthLogChange(path);
            });
            
            this.handlers.set('auth_log', authWatcher);
        }
    }
    
    handleFileEvent(eventType, filePath) {
        const fileEvent = {
            type: eventType,
            timestamp: new Date().toISOString(),
            filePath: filePath,
            fileStats: this.getFileStats(filePath),
            category: 'filesystem',
            severity: this.assessFileEventSeverity(eventType, filePath),
            context: {
                user: process.env.USER || 'unknown',
                process: process.pid
            }
        };
        
        // Проверка на подозрительные файлы
        if (this.isSuspiciousFile(filePath)) {
            fileEvent.severity = 'HIGH';
            fileEvent.category = 'security_alert';
        }
        
        this.addToBuffer(fileEvent);
    }
    
    getFileStats(filePath) {
        try {
            const fs = require('fs');
            const stats = fs.statSync(filePath);
            
            return {
                size: stats.size,
                created: stats.birthtime.toISOString(),
                modified: stats.mtime.toISOString(),
                accessed: stats.atime.toISOString(),
                permissions: stats.mode.toString(8).slice(-3),
                owner: stats.uid,
                group: stats.gid
            };
        } catch {
            return null;
        }
    }
    
    assessFileEventSeverity(eventType, filePath) {
        if (eventType === 'FILE_CREATED' && this.isExecutableFile(filePath)) {
            return 'HIGH';
        }
        
        if (eventType === 'FILE_MODIFIED' && this.isCriticalFile(filePath)) {
            return 'CRITICAL';
        }
        
        if (eventType === 'FILE_DELETED' && this.isCriticalFile(filePath)) {
            return 'HIGH';
        }
        
        return 'MEDIUM';
    }
    
    isExecutableFile(filePath) {
        const extension = require('path').extname(filePath).toLowerCase();
        return ['.exe', '.bat', '.sh', '.bin', '.out'].includes(extension);
    }
    
    isCriticalFile(filePath) {
        const criticalPatterns = [
            /etc\/.*\.conf$/,
            /config\/.*\.json$/,
            /secrets\/.*\.txt$/,
            /keys\/.*\.pem$/,
            /.*\.env$/,
            /.*\.password$/,
            /.*\.key$/,
            /.*\.token$/
        ];
        
        return criticalPatterns.some(pattern => pattern.test(filePath));
    }
    
    isSuspiciousFile(filePath) {
        const suspiciousPatterns = [
            /\/tmp\/.*\.sh$/,
            /\/var\/tmp\/.*\.exe$/,
            /.*\.tmp$/,
            /.*\.swp$/,
            /.*\.backup$/,
            /.*\.bak$/,
            /.*\.old$/,
            /.*\.copy$/
        ];
        
        return suspiciousPatterns.some(pattern => pattern.test(filePath));
    }
    
    async getActiveProcesses() {
        // Получение активных процессов (в реальности использовать ps, top или другие инструменты)
        // Заглушка для демонстрации
        return [
            { pid: 1234, name: 'node', cpu: 5.2, memory: 100000, command: 'node app.js' },
            { pid: 5678, name: 'nginx', cpu: 1.1, memory: 50000, command: 'nginx: master process' }
        ];
    }
    
    processSystemProcesses(processes) {
        for (const proc of processes) {
            const event = {
                type: 'PROCESS_EVENT',
                timestamp: new Date().toISOString(),
                process: proc,
                category: 'process_monitoring',
                severity: this.assessProcessSeverity(proc)
            };
            
            // Проверка на подозрительные процессы
            if (this.isSuspiciousProcess(proc)) {
                event.severity = 'HIGH';
                event.category = 'security_alert';
                event.suspicious = true;
            }
            
            this.addToBuffer(event);
        }
    }
    
    assessProcessSeverity(process) {
        // Оценка тяжести процесса
        if (process.cpu > 90) return 'HIGH'; // высокая загрузка CPU
        if (process.memory > 1000000000) return 'MEDIUM'; // высокое потребление памяти (>1GB)
        
        return 'LOW';
    }
    
    isSuspiciousProcess(process) {
        // Проверка на подозрительный процесс
        const suspiciousNames = ['miner', 'crypt', 'bot', 'rootkit', 'trojan'];
        const suspiciousCmds = [/\/tmp\//, /\/dev\/shm\//, /bash.*-c/, /python.*-c/];
        
        const name = process.name.toLowerCase();
        const cmd = process.command.toLowerCase();
        
        return suspiciousNames.some(n => name.includes(n)) ||
               suspiciousCmds.some(pattern => pattern.test(cmd));
    }
    
    handleAuthLogChange(logPath) {
        // Обработка изменений в логах аутентификации
        const fs = require('fs');
        const lines = fs.readFileSync(logPath, 'utf8').split('\n');
        
        for (const line of lines.slice(-10)) { // последние 10 строк
            if (this.isAuthSecurityEvent(line)) {
                const authEvent = {
                    type: 'AUTHENTICATION_EVENT',
                    timestamp: new Date().toISOString(),
                    logLine: line,
                    category: 'authentication',
                    severity: this.assessAuthEventSeverity(line),
                    context: this.parseAuthEventContext(line)
                };
                
                this.addToBuffer(authEvent);
            }
        }
    }
    
    isAuthSecurityEvent(line) {
        const securityPatterns = [
            /failed.*password/i,
            /invalid user/i,
            /authentication failure/i,
            /connection closed/i,
            /Accepted.*password/i,
            /session opened/i,
            /session closed/i
        ];
        
        return securityPatterns.some(pattern => pattern.test(line));
    }
    
    assessAuthEventSeverity(line) {
        if (line.includes('Failed') || line.includes('Invalid')) return 'MEDIUM';
        if (line.includes('Accepted')) return 'LOW';
        if (line.includes('Multiple authentication failures')) return 'HIGH';
        return 'INFO';
    }
    
    parseAuthEventContext(line) {
        // Извлечение контекста из строки аутентификации
        const context = {};
        
        // Извлечение IP
        const ipMatch = line.match(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/);
        if (ipMatch) context.ip = ipMatch[0];
        
        // Извлечение пользователя
        const userMatch = line.match(/for (\w+)/);
        if (userMatch) context.user = userMatch[1];
        
        // Извлечение порта
        const portMatch = line.match(/port (\d+)/);
        if (portMatch) context.port = portMatch[1];
        
        return context;
    }
    
    async startMonitoring() {
        console.log('System monitoring started');
    }
}

// Коллектор событий приложения
class ApplicationMonitor extends DataCollector {
    constructor(config) {
        super(config);
        this.appEvents = config.events || ['security', 'authentication', 'authorization', 'data-access'];
        this.customHooks = config.customHooks || [];
    }
    
    async initialize() {
        // Установка хуков для мониторинга событий приложения
        this.setupSecurityEventHooks();
        this.setupApplicationHooks();
    }
    
    setupSecurityEventHooks() {
        // Перехват событий безопасности в приложении
        const originalConsole = console;
        
        console.error = (...args) => {
            this.handleApplicationEvent('APP_ERROR', args);
            originalConsole.error.apply(console, args);
        };
        
        console.warn = (...args) => {
            this.handleApplicationEvent('APP_WARNING', args);
            originalConsole.warn.apply(console, args);
        };
    }
    
    setupApplicationHooks() {
        // Установка хуков для мониторинга приложения
        if (this.customHooks.length > 0) {
            for (const hook of this.customHooks) {
                this.installHook(hook);
            }
        }
    }
    
    installHook(hook) {
        // Установка пользовательского хука
        if (hook.type === 'function') {
            // Перехват функции
            const originalFunction = global[hook.target];
            if (originalFunction) {
                global[hook.target] = (...args) => {
                    this.handleApplicationEvent(hook.eventType, args);
                    return originalFunction.apply(this, args);
                };
            }
        } else if (hook.type === 'http') {
            // Перехват HTTP событий
            this.interceptHTTPEvents(hook);
        }
    }
    
    interceptHTTPEvents(hook) {
        // Перехват HTTP событий
        const http = require('http');
        const originalRequest = http.request;
        
        http.request = (options, callback) => {
            const req = originalRequest(options, callback);
            
            req.on('response', (res) => {
                this.handleApplicationEvent('HTTP_RESPONSE', {
                    options,
                    statusCode: res.statusCode,
                    headers: res.headers
                });
            });
            
            return req;
        };
    }
    
    handleApplicationEvent(eventType, data) {
        const event = {
            type: eventType,
            timestamp: new Date().toISOString(),
            data: data,
            category: 'application',
            severity: this.assessApplicationEventSeverity(eventType, data),
            context: {
                stack: this.getCallStack(),
                user: this.getCurrentUser(),
                session: this.getCurrentSession()
            }
        };
        
        // Проверка на подозрительные события
        if (this.isSuspiciousApplicationEvent(eventType, data)) {
            event.severity = 'HIGH';
            event.category = 'security_alert';
        }
        
        this.addToBuffer(event);
    }
    
    assessApplicationEventSeverity(eventType, data) {
        if (eventType === 'APP_ERROR') return 'MEDIUM';
        if (eventType === 'SECURITY_ERROR') return 'HIGH';
        if (eventType === 'CRITICAL_ERROR') return 'CRITICAL';
        if (eventType === 'APP_WARNING') return 'LOW';
        return 'INFO';
    }
    
    isSuspiciousApplicationEvent(eventType, data) {
        // Проверка на подозрительное событие приложения
        const suspiciousPatterns = [
            /sql injection/i,
            /xss/i,
            /command injection/i,
            /path traversal/i,
            /session hijacking/i,
            /authentication bypass/i
        ];
        
        const dataStr = JSON.stringify(data).toLowerCase();
        return suspiciousPatterns.some(pattern => pattern.test(dataStr));
    }
    
    getCallStack() {
        const obj = {};
        Error.captureStackTrace(obj, this.getCallStack);
        return obj.stack;
    }
    
    getCurrentUser() {
        // В реальности получать текущего пользователя из контекста запроса
        return process.env.USER || 'system';
    }
    
    getCurrentSession() {
        // В реальности получать текущую сессию
        return 'system';
    }
    
    async startMonitoring() {
        console.log('Application monitoring started');
    }
}

// Использование коллекторов
const logCollector = new LogCollector({
    sources: ['file', 'application'],
    format: 'json',
    retention: '30d',
    batchSize: 50,
    batchInterval: 5000
});

const networkMonitor = new NetworkMonitor({
    interfaces: ['eth0'],
    ports: [80, 443, 3000],
    protocols: ['tcp', 'udp']
});

const systemMonitor = new SystemMonitor({
    targets: ['filesystem', 'processes', 'authentication'],
    fileMonitoring: { criticalDirs: ['/etc/', './config/'] },
    processMonitoring: { checkInterval: 30000 }
});

const appMonitor = new ApplicationMonitor({
    events: ['security', 'error', 'warning'],
    customHooks: [
        { type: 'function', target: 'console.error', eventType: 'APP_ERROR' }
    ]
});
```

## Анализ и корреляция событий

### 1. Движок анализа угроз

```javascript
// Движок анализа угроз
class ThreatAnalyzer {
    constructor(config) {
        this.config = {
            ruleBasedAnalysis: config.ruleBasedAnalysis !== false,
            mlAnalysis: config.mlAnalysis || false,
            behavioralAnalysis: config.behavioralAnalysis || false,
            correlationEnabled: config.correlationEnabled !== false,
            ...config
        };
        
        this.analyzers = new Map();
        
        if (this.config.ruleBasedAnalysis) {
            this.analyzers.set('rule-based', new RuleBasedAnalyzer());
        }
        
        if (this.config.mlAnalysis) {
            this.analyzers.set('ml', new MLAnalyzer());
        }
        
        if (this.config.behavioralAnalysis) {
            this.analyzers.set('behavioral', new BehavioralAnalyzer());
        }
        
        this.threatDatabase = new ThreatDatabase();
        this.patternMatcher = new PatternMatcher();
        this.correlationEngine = new CorrelationEngine();
    }
    
    async analyze(events) {
        const threats = [];
        
        // Запуск всех анализаторов параллельно
        const analyzerResults = await Promise.allSettled(
            Array.from(this.analyzers.entries()).map(async ([name, analyzer]) => {
                try {
                    const results = await analyzer.analyze(events);
                    return { analyzer: name, results };
                } catch (error) {
                    console.error(`Analyzer ${name} failed:`, error);
                    return { analyzer: name, error: error.message, results: [] };
                }
            })
        );
        
        // Объединение результатов
        for (const result of analyzerResults) {
            if (result.status === 'fulfilled' && result.value.results.length > 0) {
                threats.push(...result.value.results.map(threat => ({
                    ...threat,
                    detectedBy: result.value.analyzer
                })));
            }
        }
        
        // Корреляция угроз
        if (this.config.correlationEnabled) {
            const correlatedThreats = await this.correlationEngine.correlate(threats);
            return correlatedThreats;
        }
        
        return threats;
    }
    
    async performRuleBasedAnalysis(events) {
        const ruleAnalyzer = new RuleBasedAnalyzer();
        return await ruleAnalyzer.analyze(events);
    }
    
    async performMLAnalysis(events) {
        if (!this.config.mlAnalysis) return [];
        
        // В реальности использовать ML модели
        const mlAnalyzer = new MLAnalyzer();
        return await mlAnalyzer.analyze(events);
    }
    
    async performBehavioralAnalysis(events) {
        if (!this.config.behavioralAnalysis) return [];
        
        const behavioralAnalyzer = new BehavioralAnalyzer();
        return await behavioralAnalyzer.analyze(events);
    }
    
    async getMetrics() {
        const metrics = {
            totalAnalyzers: this.analyzers.size,
            ruleBased: 0,
            mlBased: 0,
            behavioral: 0,
            correlationEnabled: this.config.correlationEnabled
        };
        
        for (const [name, analyzer] of this.analyzers) {
            const analyzerMetrics = await analyzer.getMetrics();
            metrics[name] = analyzerMetrics;
        }
        
        return metrics;
    }
    
    async getStatus() {
        const status = {};
        
        for (const [name, analyzer] of this.analyzers) {
            status[name] = await analyzer.getStatus();
        }
        
        return {
            healthy: Object.values(status).every(s => s.healthy),
            analyzers: status,
            correlation: await this.correlationEngine.getStatus()
        };
    }
    
    isHealthy() {
        const analyzerStatus = Array.from(this.analyzers.values()).map(a => a.isHealthy());
        return analyzerStatus.every(healthy => healthy);
    }
}

// Базовый класс анализатора
class BaseAnalyzer {
    constructor() {
        this.rules = [];
        this.patterns = [];
        this.metrics = {
            processedEvents: 0,
            detectedThreats: 0,
            falsePositives: 0,
            processingTime: 0
        };
    }
    
    async analyze(events) {
        const startTime = Date.now();
        const threats = [];
        
        for (const event of events) {
            const threat = await this.analyzeSingleEvent(event);
            if (threat) {
                threats.push(threat);
                this.metrics.detectedThreats++;
            }
        }
        
        this.metrics.processedEvents += events.length;
        this.metrics.processingTime = Date.now() - startTime;
        
        return threats;
    }
    
    async analyzeSingleEvent(event) {
        throw new Error('analyzeSingleEvent must be implemented by subclass');
    }
    
    async getMetrics() {
        return {
            ...this.metrics,
            detectionRate: this.metrics.processedEvents > 0 ? 
                (this.metrics.detectedThreats / this.metrics.processedEvents) * 100 : 0,
            averageProcessingTime: this.metrics.processedEvents > 0 ? 
                this.metrics.processingTime / this.metrics.processedEvents : 0
        };
    }
    
    async getStatus() {
        return {
            healthy: this.isHealthy(),
            metrics: await this.getMetrics(),
            lastAnalysis: new Date().toISOString()
        };
    }
    
    isHealthy() {
        return this.metrics.processingTime < 10000; // не более 10 секунд на анализ
    }
}

// Правило-базированный анализатор
class RuleBasedAnalyzer extends BaseAnalyzer {
    constructor() {
        super();
        this.loadDefaultRules();
    }
    
    loadDefaultRules() {
        this.rules = [
            // Правило для обнаружения брутфорса
            {
                id: 'bruteforce_detection',
                name: 'Brute Force Attack Detection',
                description: 'Detects multiple failed authentication attempts',
                conditions: [
                    { field: 'type', operator: 'equals', value: 'AUTHENTICATION_FAILURE' },
                    { field: 'context.ip', operator: 'group_count', threshold: 5, window: 300000 } // 5 за 5 минут
                ],
                actions: ['ALERT', 'BLOCK_IP'],
                severity: 'HIGH',
                enabled: true
            },
            
            // Правило для обнаружения XSS
            {
                id: 'xss_detection',
                name: 'XSS Attack Detection',
                description: 'Detects potential XSS attacks',
                conditions: [
                    { field: 'message', operator: 'contains', value: '<script' },
                    { field: 'message', operator: 'contains', value: 'javascript:' },
                    { field: 'message', operator: 'regex', value: '<.*on\\w+\\s*=' }
                ],
                actions: ['ALERT', 'SANITIZE_INPUT'],
                severity: 'HIGH',
                enabled: true
            },
            
            // Правило для обнаружения SQL-инъекций
            {
                id: 'sqli_detection',
                name: 'SQL Injection Detection',
                description: 'Detects potential SQL injection attempts',
                conditions: [
                    { field: 'message', operator: 'regex', value: "('|;|--|\\/\\*|\\*\\/|xp_|sp_|exec|union|select|insert|update|delete)" },
                    { field: 'context.url', operator: 'regex', value: "('|;|--|\\/\\*|\\*\\/)" }
                ],
                actions: ['ALERT', 'BLOCK_REQUEST'],
                severity: 'CRITICAL',
                enabled: true
            },
            
            // Правило для обнаружения командных инъекций
            {
                id: 'cmdi_detection',
                name: 'Command Injection Detection',
                description: 'Detects potential command injection attempts',
                conditions: [
                    { field: 'message', operator: 'regex', value: '(;|&&|\\|\\||`|\\$|\\(|\\)|\\{|\\})' },
                    { field: 'context.command', operator: 'regex', value: '(rm -rf|chmod|chown|wget|curl)' }
                ],
                actions: ['ALERT', 'TERMINATE_PROCESS'],
                severity: 'CRITICAL',
                enabled: true
            },
            
            // Правило для обнаружения подозрительного трафика
            {
                id: 'suspicious_traffic',
                name: 'Suspicious Traffic Detection',
                description: 'Detects unusual traffic patterns',
                conditions: [
                    { field: 'type', operator: 'equals', value: 'NETWORK_PACKET' },
                    { field: 'size', operator: 'greater_than', value: 1000000 }, // >1MB
                    { field: 'destinationIP', operator: 'not_internal' }
                ],
                actions: ['ALERT', 'THROTTLE_BANDWIDTH'],
                severity: 'MEDIUM',
                enabled: true
            }
        ];
    }
    
    async analyzeSingleEvent(event) {
        for (const rule of this.rules) {
            if (rule.enabled && await this.evaluateRule(rule, event)) {
                return {
                    id: this.generateThreatId(),
                    ruleId: rule.id,
                    ruleName: rule.name,
                    severity: rule.severity,
                    type: 'RULE_DETECTED',
                    timestamp: new Date().toISOString(),
                    event: event,
                    confidence: 0.9, // для rule-based анализов высокая уверенность
                    actions: rule.actions
                };
            }
        }
        
        return null;
    }
    
    async evaluateRule(rule, event) {
        // Оценка соответствия события правилу
        for (const condition of rule.conditions) {
            if (!await this.evaluateCondition(condition, event)) {
                return false; // условие не выполнено
            }
        }
        
        return true; // все условия выполнены
    }
    
    async evaluateCondition(condition, event) {
        const fieldValue = this.getNestedValue(event, condition.field);
        
        switch (condition.operator) {
            case 'equals':
                return fieldValue === condition.value;
            case 'contains':
                return String(fieldValue).includes(condition.value);
            case 'regex':
                return new RegExp(condition.value, 'i').test(String(fieldValue));
            case 'greater_than':
                return Number(fieldValue) > Number(condition.value);
            case 'less_than':
                return Number(fieldValue) < Number(condition.value);
            case 'not_internal':
                return !this.isInternalIP(fieldValue);
            case 'group_count':
                return await this.checkGroupCount(condition, event);
            default:
                return false;
        }
    }
    
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    }
    
    isInternalIP(ip) {
        if (!ip) return false;
        
        const internalRanges = [
            /^10\./,
            /^172\.(1[6-9]|2[0-9]|3[01])\./,
            /^192\.168\./,
            /^127\./,
            /^::1$/,
            /^fc00:/,
            /^fe80:/
        ];
        
        return internalRanges.some(range => range.test(ip));
    }
    
    async checkGroupCount(condition, event) {
        // Проверка количества событий в группе за определенное время
        // В реальности использовать временное окно и агрегацию
        return false; // заглушка
    }
    
    generateThreatId() {
        return `threat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// ML-анализатор
class MLAnalyzer extends BaseAnalyzer {
    constructor() {
        super();
        this.model = null;
        this.featureExtractor = new FeatureExtractor();
        this.trainingData = [];
    }
    
    async initializeModel() {
        // В реальности загружать обученную модель
        // Это может быть TensorFlow.js модель или интеграция с внешним ML сервисом
        this.model = await this.loadModel();
    }
    
    async loadModel() {
        // Загрузка ML модели (заглушка)
        return { loaded: true, type: 'placeholder' };
    }
    
    async analyzeSingleEvent(event) {
        try {
            // Извлечение признаков из события
            const features = this.featureExtractor.extract(event);
            
            // Прогнозирование угрозы
            const prediction = await this.predictThreat(features);
            
            if (prediction.isThreat && prediction.confidence > 0.7) {
                return {
                    id: this.generateThreatId(),
                    type: 'ML_DETECTED',
                    severity: this.mapConfidenceToSeverity(prediction.confidence),
                    confidence: prediction.confidence,
                    predictedThreatType: prediction.threatType,
                    features: features,
                    event: event,
                    timestamp: new Date().toISOString()
                };
            }
        } catch (error) {
            console.error('ML analysis failed:', error);
        }
        
        return null;
    }
    
    async predictThreat(features) {
        // В реальности использовать ML модель для предсказания
        // Здесь заглушка с эвристикой
        const threatScore = this.calculateThreatScore(features);
        
        return {
            isThreat: threatScore > 0.5,
            confidence: threatScore,
            threatType: this.classifyThreatType(features),
            score: threatScore
        };
    }
    
    calculateThreatScore(features) {
        let score = 0;
        
        // Оценка по различным признакам
        if (features.hasSuspiciousPatterns) score += 0.3;
        if (features.unusualTiming) score += 0.2;
        if (features.anomalousBehavior) score += 0.4;
        if (features.highEntropy) score += 0.1;
        
        return Math.min(1.0, score);
    }
    
    classifyThreatType(features) {
        // Классификация типа угрозы на основе признаков
        if (features.patterns.includes('sql')) return 'SQL_INJECTION';
        if (features.patterns.includes('xss')) return 'CROSS_SITE_SCRIPTING';
        if (features.patterns.includes('brute')) return 'BRUTE_FORCE';
        if (features.patterns.includes('command')) return 'COMMAND_INJECTION';
        
        return 'UNKNOWN';
    }
    
    mapConfidenceToSeverity(confidence) {
        if (confidence >= 0.9) return 'CRITICAL';
        if (confidence >= 0.7) return 'HIGH';
        if (confidence >= 0.5) return 'MEDIUM';
        return 'LOW';
    }
}

// Анализатор поведения
class BehavioralAnalyzer extends BaseAnalyzer {
    constructor() {
        super();
        this.behaviorModels = new Map();
        this.anomalyThreshold = 0.7;
        this.learningWindow = 86400000; // 24 часа
    }
    
    async analyzeSingleEvent(event) {
        try {
            const entityId = this.getEntityId(event);
            const currentBehavior = this.extractBehavior(event);
            
            if (!this.behaviorModels.has(entityId)) {
                // Создание новой модели поведения
                this.behaviorModels.set(entityId, new BehaviorModel(entityId));
            }
            
            const model = this.behaviorModels.get(entityId);
            const anomalyScore = await model.analyze(currentBehavior);
            
            if (anomalyScore > this.anomalyThreshold) {
                return {
                    id: this.generateThreatId(),
                    type: 'BEHAVIORAL_ANOMALY',
                    severity: this.mapAnomalyScoreToSeverity(anomalyScore),
                    confidence: anomalyScore,
                    anomalyDetails: {
                        score: anomalyScore,
                        expectedBehavior: model.getLastExpectedBehavior(),
                        actualBehavior: currentBehavior
                    },
                    entity: entityId,
                    event: event,
                    timestamp: new Date().toISOString()
                };
            }
        } catch (error) {
            console.error('Behavioral analysis failed:', error);
        }
        
        return null;
    }
    
    getEntityId(event) {
        // Идентификация сущности (пользователь, IP, процесс и т.д.)
        return event.context?.ip || 
               event.context?.user || 
               event.context?.process || 
               'unknown';
    }
    
    extractBehavior(event) {
        // Извлечение поведенческих признаков из события
        return {
            eventType: event.type,
            timestamp: new Date(event.timestamp).getTime(),
            source: event.context?.ip || event.source,
            destination: event.context?.destinationIP || event.destination,
            size: event.size || event.context?.size,
            frequency: event.context?.frequency,
            patterns: this.extractBehavioralPatterns(event)
        };
    }
    
    extractBehavioralPatterns(event) {
        const patterns = [];
        
        if (event.message?.toLowerCase().includes('login')) patterns.push('authentication');
        if (event.message?.toLowerCase().includes('access')) patterns.push('authorization');
        if (event.message?.toLowerCase().includes('data')) patterns.push('data_access');
        if (event.type?.includes('NETWORK')) patterns.push('network_activity');
        
        return patterns;
    }
    
    mapAnomalyScoreToSeverity(score) {
        if (score >= 0.9) return 'CRITICAL';
        if (score >= 0.8) return 'HIGH';
        if (score >= 0.7) return 'MEDIUM';
        if (score >= 0.6) return 'LOW';
        return 'INFO';
    }
}

// Модель поведения для сущности
class BehaviorModel {
    constructor(entityId) {
        this.entityId = entityId;
        this.behaviorHistory = [];
        this.expectedPatterns = new Set();
        this.anomalyThreshold = 0.7;
    }
    
    async analyze(currentBehavior) {
        // Анализ текущего поведения относительно исторического
        if (this.behaviorHistory.length === 0) {
            // Первое поведение - просто сохраняем
            this.behaviorHistory.push(currentBehavior);
            return 0.1; // низкий риск аномалии
        }
        
        // Обновление ожидаемых паттернов
        this.updateExpectedPatterns(currentBehavior);
        
        // Расчет схожести с ожидаемым поведением
        const similarityScore = this.calculateSimilarity(currentBehavior);
        
        // Сохранение текущего поведения
        this.behaviorHistory.push(currentBehavior);
        
        // Ограничение истории
        if (this.behaviorHistory.length > 1000) {
            this.behaviorHistory = this.behaviorHistory.slice(-1000);
        }
        
        // Возвращаем степень аномалии (1 - схожесть)
        return 1 - similarityScore;
    }
    
    updateExpectedPatterns(behavior) {
        // Обновление ожидаемых паттернов поведения
        behavior.patterns?.forEach(pattern => {
            this.expectedPatterns.add(pattern);
        });
    }
    
    calculateSimilarity(behavior) {
        // Расчет схожести текущего поведения с ожидаемым
        const currentPatterns = new Set(behavior.patterns || []);
        
        let matches = 0;
        let total = 0;
        
        for (const pattern of currentPatterns) {
            if (this.expectedPatterns.has(pattern)) {
                matches++;
            }
            total++;
        }
        
        // Также проверяем другие аспекты поведения
        const timeSimilarity = this.calculateTimeSimilarity(behavior);
        const frequencySimilarity = this.calculateFrequencySimilarity(behavior);
        
        return (matches / Math.max(total, 1)) * 0.5 + 
               timeSimilarity * 0.3 + 
               frequencySimilarity * 0.2;
    }
    
    calculateTimeSimilarity(behavior) {
        // Расчет схожести по времени
        const currentHour = new Date(behavior.timestamp).getHours();
        
        // В реальности использовать статистику исторического поведения
        // Здесь заглушка
        return 0.8; // 80% схожести
    }
    
    calculateFrequencySimilarity(behavior) {
        // Расчет схожести по частоте
        if (!behavior.frequency) return 1.0; // если частота не указана, считаем нормальной
        
        // В реальности сравнивать с исторической частотой
        return 0.9; // заглушка
    }
    
    getLastExpectedBehavior() {
        // Возвращение последнего ожидаемого поведения
        return Array.from(this.expectedPatterns);
    }
}

// Движок корреляции событий
class CorrelationEngine {
    constructor() {
        this.correlationRules = [
            {
                name: 'Brute Force Campaign',
                description: 'Correlate multiple failed login attempts from same IP',
                conditions: {
                    primary: {
                        type: 'AUTHENTICATION_FAILURE',
                        severity: 'MEDIUM'
                    },
                    related: {
                        type: 'AUTHENTICATION_FAILURE',
                        timeWindow: 300000, // 5 минут
                        countThreshold: 5,
                        sameSource: true
                    }
                },
                action: 'GROUP_AS_CAMPAIGN',
                severityMultiplier: 2
            },
            {
                name: 'Multi-stage Attack',
                description: 'Correlate different types of suspicious activities',
                conditions: {
                    primary: {
                        type: 'NETWORK_SCANNING'
                    },
                    related: {
                        type: ['AUTHENTICATION_FAILURE', 'UNAUTHORIZED_ACCESS'],
                        timeWindow: 600000, // 10 минут
                        sameSource: true
                    }
                },
                action: 'GROUP_AS_ATTACK_SEQUENCE',
                severityMultiplier: 1.5
            }
        ];
        
        this.eventGroups = new Map();
    }
    
    async correlate(threats) {
        const correlated = [];
        const processed = new Set();
        
        for (const threat of threats) {
            if (processed.has(threat.id)) continue;
            
            // Проверка на корреляцию с другими угрозами
            const correlation = await this.findCorrelations(threat, threats);
            
            if (correlation.related.length > 0) {
                const groupedThreat = this.createGroupedThreat(threat, correlation.related);
                correlated.push(groupedThreat);
                
                // Пометить коррелированные угрозы как обработанные
                processed.add(threat.id);
                correlation.related.forEach(rel => processed.add(rel.id));
            } else {
                correlated.push(threat);
                processed.add(threat.id);
            }
        }
        
        return correlated;
    }
    
    async findCorrelations(primaryThreat, allThreats) {
        const related = [];
        
        for (const threat of allThreats) {
            if (threat.id === primaryThreat.id) continue;
            
            for (const rule of this.correlationRules) {
                if (await this.matchesCorrelationRule(primaryThreat, threat, rule)) {
                    related.push({
                        ...threat,
                        correlationRule: rule.name
                    });
                    break; // найдено совпадение с правилом
                }
            }
        }
        
        return { primary: primaryThreat, related };
    }
    
    async matchesCorrelationRule(primary, secondary, rule) {
        const primaryCond = rule.conditions.primary;
        const relatedCond = rule.conditions.related;
        
        // Проверка основного условия
        if (primaryCond.type && primary.type !== primaryCond.type) return false;
        if (primaryCond.severity && primary.severity !== primaryCond.severity) return false;
        
        // Проверка связанного условия
        if (relatedCond.type) {
            const types = Array.isArray(relatedCond.type) ? relatedCond.type : [relatedCond.type];
            if (!types.includes(secondary.type)) return false;
        }
        
        // Проверка временного окна
        const primaryTime = new Date(primary.timestamp).getTime();
        const secondaryTime = new Date(secondary.timestamp).getTime();
        const timeDiff = Math.abs(primaryTime - secondaryTime);
        
        if (relatedCond.timeWindow && timeDiff > relatedCond.timeWindow) return false;
        
        // Проверка источника
        if (relatedCond.sameSource) {
            const primarySource = this.getEventSource(primary);
            const secondarySource = this.getEventSource(secondary);
            
            if (primarySource !== secondarySource) return false;
        }
        
        return true;
    }
    
    getEventSource(event) {
        // Получение источника события для корреляции
        return event.event?.context?.ip || 
               event.event?.context?.user || 
               event.event?.source || 
               'unknown';
    }
    
    createGroupedThreat(primary, related) {
        return {
            id: `grouped_${primary.id}`,
            type: 'CORRELATED_THREAT',
            severity: this.calculateGroupedSeverity(primary, related),
            confidence: this.calculateGroupedConfidence(primary, related),
            primaryThreat: primary,
            relatedThreats: related,
            correlationCount: related.length + 1,
            timestamp: new Date().toISOString(),
            description: `Grouped threat: ${primary.ruleName || primary.type} with ${related.length} related events`
        };
    }
    
    calculateGroupedSeverity(primary, related) {
        // Расчет тяжести группы угроз
        const maxSeverity = Math.max(
            this.severityToNumber(primary.severity),
            Math.max(...related.map(t => this.severityToNumber(t.severity)))
        );
        
        // Увеличение тяжести за счет корреляции
        const correlatedSeverity = maxSeverity * 1.5;
        
        return this.numberToSeverity(Math.min(5, correlatedSeverity));
    }
    
    severityToNumber(severity) {
        const mapping = { 'INFO': 1, 'LOW': 2, 'MEDIUM': 3, 'HIGH': 4, 'CRITICAL': 5 };
        return mapping[severity] || 3;
    }
    
    numberToSeverity(number) {
        const mapping = { 1: 'INFO', 2: 'LOW', 3: 'MEDIUM', 4: 'HIGH', 5: 'CRITICAL' };
        return mapping[Math.round(number)] || 'MEDIUM';
    }
    
    calculateGroupedConfidence(primary, related) {
        // Расчет уверенности в групповой угрозе
        const avgConfidence = (primary.confidence + 
                              related.reduce((sum, t) => sum + (t.confidence || 0), 0)) / 
                             (related.length + 1);
        
        // Повышение уверенности за счет корреляции
        return Math.min(1.0, avgConfidence * 1.2);
    }
    
    async getStatus() {
        return {
            totalCorrelations: this.correlationRules.length,
            activeGroups: this.eventGroups.size,
            correlationEnabled: true
        };
    }
}

// Использование анализатора угроз
const threatAnalyzer = new ThreatAnalyzer({
    ruleBasedAnalysis: true,
    mlAnalysis: true,
    behavioralAnalysis: true,
    correlationEnabled: true
});
```

### 2. Система уведомлений

```javascript
// Система управления уведомлениями
class AlertManager {
    constructor(config) {
        this.config = {
            notificationChannels: config.notificationChannels || ['console'],
            alertThresholds: {
                critical: 0,
                high: 5,
                medium: 10
            },
            deduplication: config.deduplication !== false,
            aggregation: config.aggregation !== false,
            escalation: config.escalation !== false,
            ...config
        };
        
        this.alertChannels = this.initializeChannels();
        this.alertQueue = [];
        this.alertHistory = [];
        this.activeAlerts = new Map();
        this.alertCoalescing = new AlertCoalescer();
    }
    
    initializeChannels() {
        const channels = new Map();
        
        if (this.config.notificationChannels.includes('console')) {
            channels.set('console', new ConsoleAlertChannel());
        }
        
        if (this.config.notificationChannels.includes('email') && this.config.email) {
            channels.set('email', new EmailAlertChannel(this.config.email));
        }
        
        if (this.config.notificationChannels.includes('slack') && this.config.slack) {
            channels.set('slack', new SlackAlertChannel(this.config.slack));
        }
        
        if (this.config.notificationChannels.includes('pagerduty') && this.config.pagerduty) {
            channels.set('pagerduty', new PagerDutyAlertChannel(this.config.pagerduty));
        }
        
        if (this.config.notificationChannels.includes('webhook') && this.config.webhook) {
            channels.set('webhook', new WebhookAlertChannel(this.config.webhook));
        }
        
        return channels;
    }
    
    async generateAlerts(threats) {
        const alerts = [];
        
        for (const threat of threats) {
            if (this.shouldGenerateAlert(threat)) {
                const alert = await this.createAlert(threat);
                
                // Дедупликация
                if (this.config.deduplication) {
                    if (!this.isDuplicateAlert(alert)) {
                        alerts.push(alert);
                        await this.sendAlert(alert);
                        this.recordAlert(alert);
                    }
                } else {
                    alerts.push(alert);
                    await this.sendAlert(alert);
                    this.recordAlert(alert);
                }
            }
        }
        
        // Агрегация уведомлений
        if (this.config.aggregation) {
            const aggregatedAlerts = await this.alertCoalescing.coalesce(alerts);
            for (const aggregatedAlert of aggregatedAlerts) {
                await this.sendAggregatedAlert(aggregatedAlert);
            }
        }
        
        return alerts;
    }
    
    shouldGenerateAlert(threat) {
        // Проверка, нужно ли генерировать алерт
        const severityThreshold = this.config.alertThresholds[threat.severity.toLowerCase()];
        const currentCount = this.getCountForSeverity(threat.severity);
        
        return currentCount < severityThreshold;
    }
    
    async createAlert(threat) {
        return {
            id: this.generateAlertId(),
            type: threat.type,
            severity: threat.severity,
            title: this.generateAlertTitle(threat),
            description: this.generateAlertDescription(threat),
            timestamp: new Date().toISOString(),
            threat: threat,
            source: threat.event?.source || 'unknown',
            context: threat.event?.context || {},
            confidence: threat.confidence || 0.8,
            status: 'OPEN',
            assignedTo: null,
            acknowledgedBy: null,
            acknowledgedAt: null,
            resolvedBy: null,
            resolvedAt: null
        };
    }
    
    generateAlertTitle(threat) {
        const prefixes = {
            'CRITICAL': '🚨 CRITICAL',
            'HIGH': '⚠️ HIGH',
            'MEDIUM': '🔔 MEDIUM',
            'LOW': 'ℹ️ LOW'
        };
        
        const prefix = prefixes[threat.severity] || prefixes['LOW'];
        const ruleName = threat.ruleName || threat.type || 'Unknown Threat';
        
        return `${prefix} Security Alert: ${ruleName}`;
    }
    
    generateAlertDescription(threat) {
        let description = threat.event?.message || threat.description || 'Security threat detected';
        
        if (threat.event?.context?.ip) {
            description += `\nSource IP: ${threat.event.context.ip}`;
        }
        
        if (threat.event?.context?.user) {
            description += `\nUser: ${threat.event.context.user}`;
        }
        
        if (threat.event?.context?.url) {
            description += `\nURL: ${threat.event.context.url}`;
        }
        
        if (threat.confidence) {
            description += `\nConfidence: ${(threat.confidence * 100).toFixed(2)}%`;
        }
        
        return description;
    }
    
    isDuplicateAlert(alert) {
        // Проверка на дубликаты
        const existing = this.activeAlerts.get(alert.id);
        if (existing) return true;
        
        // Проверка на дубликаты по содержанию
        for (const [id, existingAlert] of this.activeAlerts) {
            if (this.areAlertsSimilar(alert, existingAlert)) {
                return true;
            }
        }
        
        return false;
    }
    
    areAlertsSimilar(alert1, alert2) {
        return alert1.type === alert2.type &&
               alert1.source === alert2.source &&
               alert1.description === alert2.description &&
               Math.abs(new Date(alert1.timestamp) - new Date(alert2.timestamp)) < 60000; // 1 минута
    }
    
    async sendAlert(alert) {
        // Отправка алерта во все каналы
        const promises = [];
        
        for (const [channelName, channel] of this.alertChannels) {
            promises.push(
                channel.sendAlert(alert)
                    .catch(error => console.error(`Failed to send alert via ${channelName}:`, error))
            );
        }
        
        await Promise.allSettled(promises);
        
        // Запись в активные алерты
        this.activeAlerts.set(alert.id, alert);
    }
    
    async sendAggregatedAlert(aggregate) {
        // Отправка агрегированного алерта
        const aggregatedAlert = {
            id: `aggregate_${Date.now()}`,
            type: 'AGGREGATED_ALERT',
            severity: this.getAggregateSeverity(aggregate.alerts),
            title: `Aggregated Alert: ${aggregate.count} ${aggregate.alerts[0].type} events`,
            description: `Detected ${aggregate.count} similar security events from ${aggregate.sources.size} sources`,
            alerts: aggregate.alerts,
            sources: Array.from(aggregate.sources),
            timestamp: new Date().toISOString(),
            status: 'OPEN'
        };
        
        for (const [channelName, channel] of this.alertChannels) {
            try {
                await channel.sendAggregatedAlert(aggregatedAlert);
            } catch (error) {
                console.error(`Failed to send aggregated alert via ${channelName}:`, error);
            }
        }
    }
    
    getAggregateSeverity(alerts) {
        // Получение максимальной тяжести из агрегированных алертов
        const severityNumbers = alerts.map(alert => this.severityToNumber(alert.severity));
        const maxSeverity = Math.max(...severityNumbers);
        return this.numberToSeverity(maxSeverity);
    }
    
    recordAlert(alert) {
        // Запись алерта в историю
        this.alertHistory.push(alert);
        
        // Ограничение истории
        if (this.alertHistory.length > 10000) {
            this.alertHistory = this.alertHistory.slice(-10000);
        }
        
        // Удаление из активных алертов через определенное время
        setTimeout(() => {
            this.activeAlerts.delete(alert.id);
        }, this.config.alertRetention || 86400000); // 24 часа
    }
    
    generateAlertId() {
        return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    getCountForSeverity(severity) {
        return this.alertHistory.filter(alert => alert.severity === severity).length;
    }
    
    severityToNumber(severity) {
        const mapping = { 'INFO': 1, 'LOW': 2, 'MEDIUM': 3, 'HIGH': 4, 'CRITICAL': 5 };
        return mapping[severity] || 3;
    }
    
    numberToSeverity(number) {
        const mapping = { 1: 'INFO', 2: 'LOW', 3: 'MEDIUM', 4: 'HIGH', 5: 'CRITICAL' };
        return mapping[Math.round(number)] || 'MEDIUM';
    }
    
    async acknowledgeAlert(alertId, acknowledgedBy) {
        const alert = this.activeAlerts.get(alertId);
        if (!alert) {
            throw new Error('Alert not found');
        }
        
        alert.status = 'ACKNOWLEDGED';
        alert.acknowledgedBy = acknowledgedBy;
        alert.acknowledgedAt = new Date().toISOString();
        
        // Обновление в хранилище
        await this.updateAlertInStorage(alert);
        
        return alert;
    }
    
    async resolveAlert(alertId, resolvedBy, resolutionNotes = '') {
        const alert = this.activeAlerts.get(alertId);
        if (!alert) {
            throw new Error('Alert not found');
        }
        
        alert.status = 'RESOLVED';
        alert.resolvedBy = resolvedBy;
        alert.resolvedAt = new Date().toISOString();
        alert.resolutionNotes = resolutionNotes;
        
        // Удаление из активных
        this.activeAlerts.delete(alertId);
        
        // Обновление в хранилище
        await this.updateAlertInStorage(alert);
        
        return alert;
    }
    
    async getActiveAlerts(filters = {}) {
        let alerts = Array.from(this.activeAlerts.values());
        
        if (filters.severity) {
            alerts = alerts.filter(alert => alert.severity === filters.severity);
        }
        
        if (filters.type) {
            alerts = alerts.filter(alert => alert.type === filters.type);
        }
        
        if (filters.source) {
            alerts = alerts.filter(alert => alert.source === filters.source);
        }
        
        if (filters.status) {
            alerts = alerts.filter(alert => alert.status === filters.status);
        }
        
        return alerts.sort((a, b) => 
            new Date(b.timestamp) - new Date(a.timestamp)
        );
    }
    
    async getAlertHistory(filters = {}, limit = 100) {
        let history = [...this.alertHistory];
        
        if (filters.severity) {
            history = history.filter(alert => alert.severity === filters.severity);
        }
        
        if (filters.type) {
            history = history.filter(alert => alert.type === filters.type);
        }
        
        if (filters.startDate) {
            history = history.filter(alert => new Date(alert.timestamp) >= new Date(filters.startDate));
        }
        
        if (filters.endDate) {
            history = history.filter(alert => new Date(alert.timestamp) <= new Date(filters.endDate));
        }
        
        return history
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            .slice(0, limit);
    }
    
    async getAlertStatistics() {
        const stats = {
            totalAlerts: this.alertHistory.length,
            activeAlerts: this.activeAlerts.size,
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 },
            byType: {},
            bySource: {},
            byStatus: { OPEN: 0, ACKNOWLEDGED: 0, RESOLVED: 0 },
            averageResolutionTime: 0,
            resolutionRate: 0
        };
        
        for (const alert of this.alertHistory) {
            stats.bySeverity[alert.severity] = (stats.bySeverity[alert.severity] || 0) + 1;
            
            stats.byType[alert.type] = (stats.byType[alert.type] || 0) + 1;
            stats.bySource[alert.source] = (stats.bySource[alert.source] || 0) + 1;
            stats.byStatus[alert.status || 'OPEN'] = (stats.byStatus[alert.status || 'OPEN'] || 0) + 1;
        }
        
        for (const [status, count] of Object.entries(stats.byStatus)) {
            stats.byStatus[status] = count;
        }
        
        // Расчет среднего времени разрешения
        const resolvedAlerts = this.alertHistory.filter(alert => alert.resolvedAt);
        if (resolvedAlerts.length > 0) {
            const totalResolutionTime = resolvedAlerts.reduce((sum, alert) => {
                const created = new Date(alert.timestamp);
                const resolved = new Date(alert.resolvedAt);
                return sum + (resolved - created);
            }, 0);
            
            stats.averageResolutionTime = totalResolutionTime / resolvedAlerts.length;
        }
        
        // Расчет процента разрешения
        stats.resolutionRate = this.alertHistory.length > 0 ? 
            (resolvedAlerts.length / this.alertHistory.length) * 100 : 0;
        
        return stats;
    }
    
    async initialize() {
        // Загрузка истории алертов из хранилища
        await this.loadAlertHistory();
    }
    
    async loadAlertHistory() {
        // Загрузка истории из постоянного хранилища
        // В реальности использовать БД или файл
        console.log('Loading alert history...');
    }
    
    async updateAlertInStorage(alert) {
        // Обновление алерта в постоянном хранилище
        // В реальности использовать БД
        console.log('Updating alert in storage:', alert.id);
    }
    
    async getAlertDashboard() {
        const stats = await this.getAlertStatistics();
        const activeAlerts = await this.getActiveAlerts();
        const recentAlerts = await this.getAlertHistory({}, 10);
        
        return {
            timestamp: new Date().toISOString(),
            statistics: stats,
            activeAlerts: activeAlerts.slice(0, 20),
            recentAlerts: recentAlerts,
            trends: await this.getAlertTrends(),
            recommendations: this.generateAlertRecommendations(stats)
        };
    }
    
    async getAlertTrends() {
        // Получение трендов алертов
        const hourlyCounts = {};
        
        for (const alert of this.alertHistory) {
            const hour = new Date(alert.timestamp).toISOString().slice(0, 13);
            hourlyCounts[hour] = (hourlyCounts[hour] || 0) + 1;
        }
        
        return Object.entries(hourlyCounts)
            .sort(([a], [b]) => a.localeCompare(b))
            .slice(-24) // последние 24 часа
            .map(([hour, count]) => ({ hour, count }));
    }
    
    generateAlertRecommendations(stats) {
        const recommendations = [];
        
        if (stats.bySeverity.CRITICAL > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Alerts Immediately',
                description: `Found ${stats.bySeverity.CRITICAL} critical alerts`,
                action: 'Investigate and resolve critical alerts immediately'
            });
        }
        
        if (stats.averageResolutionTime > 86400000) { // больше суток
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Alert Resolution Time',
                description: `Average resolution time is ${(stats.averageResolutionTime / 3600000).toFixed(2)} hours`,
                action: 'Implement faster alert response procedures'
            });
        }
        
        if (stats.resolutionRate < 80) { // ниже 80%
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Alert Resolution Rate',
                description: `Only ${stats.resolutionRate.toFixed(2)}% of alerts are resolved`,
                action: 'Ensure all alerts are properly investigated and resolved'
            });
        }
        
        return recommendations;
    }
    
    async sendSystemAlert(alert) {
        // Отправка системного алерта (не через основной движок)
        for (const channel of this.alertChannels.values()) {
            try {
                await channel.sendSystemAlert(alert);
            } catch (error) {
                console.error('Failed to send system alert:', error);
            }
        }
    }
}

// Канал уведомлений в консоль
class ConsoleAlertChannel {
    async sendAlert(alert) {
        const colors = {
            'CRITICAL': '\x1b[31m', // красный
            'HIGH': '\x1b[33m',     // желтый
            'MEDIUM': '\x1b[36m',   // голубой
            'LOW': '\x1b[37m',      // белый
            'RESET': '\x1b[0m'      // сброс цвета
        };
        
        const color = colors[alert.severity] || colors.RESET;
        
        console.log(`${color}[SECURITY ALERT] ${alert.title}${colors.RESET}`);
        console.log(`  Description: ${alert.description}`);
        console.log(`  Source: ${alert.source}`);
        console.log(`  Confidence: ${(alert.confidence * 100).toFixed(2)}%`);
        console.log(`  Timestamp: ${alert.timestamp}`);
        console.log('  ---');
    }
    
    async sendAggregatedAlert(aggregate) {
        console.log(`\x1b[35m[AGGREGATED ALERT] ${aggregate.title}\x1b[0m`);
        console.log(`  Description: ${aggregate.description}`);
        console.log(`  Count: ${aggregate.count}`);
        console.log(`  Sources: ${aggregate.sources.join(', ')}`);
        console.log('  ---');
    }
    
    async sendSystemAlert(alert) {
        console.error(`\x1b[31m[SYSTEM ALERT] ${alert.title}\x1b[0m`);
        console.error(`  ${alert.description}`);
    }
}

// Использование системы уведомлений
const alertManager = new AlertManager({
    notificationChannels: ['console', 'email', 'slack'],
    email: {
        smtpHost: process.env.SMTP_HOST,
        smtpPort: process.env.SMTP_PORT,
        from: process.env.SMTP_FROM,
        to: ['security-team@company.com']
    },
    slack: {
        webhookUrl: process.env.SLACK_SECURITY_WEBHOOK,
        channel: '#security-alerts'
    },
    alertThresholds: {
        critical: 0,
        high: 5,
        medium: 10
    }
});

await alertManager.initialize();
```

## Интеграция с системами управления инцидентами

### 1. Интеграция с Jira

```javascript
// Интеграция с системой управления инцидентами (Jira)
class IncidentManagementIntegration {
    constructor(config) {
        this.config = config;
        this.jiraClient = new JiraClient(config.jira);
        this.incidentCategories = {
            'CRITICAL': 'Security Breach',
            'HIGH': 'Security Vulnerability',
            'MEDIUM': 'Security Concern',
            'LOW': 'Security Observation'
        };
    }
    
    async createIncident(alert) {
        const incident = {
            fields: {
                project: {
                    key: this.config.jira.projectKey
                },
                summary: `Security Alert: ${alert.title}`,
                description: this.formatAlertDescription(alert),
                issuetype: {
                    name: 'Security Issue'
                },
                priority: {
                    name: this.mapSeverityToPriority(alert.severity)
                },
                labels: [
                    'security',
                    'alert',
                    alert.severity.toLowerCase(),
                    alert.type.toLowerCase().replace('_', '-')
                ],
                customfield_10000: { // Custom field for security classification
                    value: alert.severity
                }
            }
        };
        
        try {
            const response = await this.jiraClient.createIssue(incident);
            return {
                success: true,
                issueKey: response.key,
                issueUrl: `${this.config.jira.baseUrl}/browse/${response.key}`,
                alertId: alert.id
            };
        } catch (error) {
            console.error('Failed to create Jira incident:', error);
            return {
                success: false,
                error: error.message,
                alertId: alert.id
            };
        }
    }
    
    formatAlertDescription(alert) {
        return `
            **Security Alert Details**
            
            *Severity:* ${alert.severity}
            *Type:* ${alert.type}
            *Source:* ${alert.source}
            *Timestamp:* ${alert.timestamp}
            
            **Threat Information:**
            ${JSON.stringify(alert.threat, null, 2)}
            
            **Event Context:**
            ${JSON.stringify(alert.context, null, 2)}
            
            **Recommended Actions:**
            - Investigate the source of the threat
            - Apply necessary security patches
            - Monitor for similar activities
        `;
    }
    
    mapSeverityToPriority(severity) {
        const priorityMap = {
            'CRITICAL': 'Critical',
            'HIGH': 'High',
            'MEDIUM': 'Medium',
            'LOW': 'Low'
        };
        
        return priorityMap[severity] || 'Medium';
    }
    
    async updateIncidentStatus(issueKey, status, resolutionNotes = '') {
        try {
            const transition = this.getTransitionForStatus(status);
            if (transition) {
                await this.jiraClient.transitionIssue(issueKey, {
                    transition: { id: transition.id }
                });
            }
            
            if (resolutionNotes) {
                await this.jiraClient.addComment(issueKey, {
                    body: `Resolution Notes: ${resolutionNotes}`
                });
            }
            
            return { success: true, issueKey };
        } catch (error) {
            console.error('Failed to update incident status:', error);
            return { success: false, error: error.message, issueKey };
        }
    }
    
    getTransitionForStatus(status) {
        // Возвращение ID перехода для статуса
        const transitions = {
            'RESOLVED': { id: '5' }, // ID перехода в Jira
            'CLOSED': { id: '6' },
            'IN PROGRESS': { id: '3' }
        };
        
        return transitions[status];
    }
    
    async linkIncidents(alert1, alert2) {
        // Связывание инцидентов, если они коррелируют
        try {
            await this.jiraClient.linkIssues({
                type: {
                    name: 'Relates'
                },
                inwardIssue: {
                    key: alert1.jiraIssueKey
                },
                outwardIssue: {
                    key: alert2.jiraIssueKey
                }
            });
            
            return { success: true, linkedIssues: [alert1.jiraIssueKey, alert2.jiraIssueKey] };
        } catch (error) {
            console.error('Failed to link incidents:', error);
            return { success: false, error: error.message };
        }
    }
    
    async searchIncidents(criteria) {
        const jql = this.buildJQLQuery(criteria);
        
        try {
            const response = await this.jiraClient.searchIssues({
                jql: jql,
                maxResults: criteria.maxResults || 50
            });
            
            return {
                success: true,
                issues: response.issues,
                total: response.total
            };
        } catch (error) {
            console.error('Failed to search incidents:', error);
            return { success: false, error: error.message };
        }
    }
    
    buildJQLQuery(criteria) {
        const conditions = ['project = "' + this.config.jira.projectKey + '"', 'labels = security'];
        
        if (criteria.severity) {
            conditions.push(`customfield_10000 = "${criteria.severity}"`);
        }
        
        if (criteria.status) {
            conditions.push(`status = "${criteria.status}"`);
        }
        
        if (criteria.assignee) {
            conditions.push(`assignee = "${criteria.assignee}"`);
        }
        
        if (criteria.dateRange) {
            conditions.push(`created >= "${criteria.dateRange.start}" AND created <= "${criteria.dateRange.end}"`);
        }
        
        return conditions.join(' AND ');
    }
    
    async generateIncidentReport() {
        const recentIncidents = await this.searchIncidents({
            dateRange: {
                start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 7 дней
                end: new Date().toISOString().split('T')[0]
            }
        });
        
        const report = {
            timestamp: new Date().toISOString(),
            period: 'Last 7 days',
            totalIncidents: recentIncidents.total,
            bySeverity: this.countIncidentsBySeverity(recentIncidents.issues),
            byStatus: this.countIncidentsByStatus(recentIncidents.issues),
            averageResolutionTime: this.calculateAverageResolutionTime(recentIncidents.issues),
            topSources: this.getTopSources(recentIncidents.issues),
            recommendations: this.generateIncidentRecommendations(recentIncidents.issues)
        };
        
        return report;
    }
    
    countIncidentsBySeverity(issues) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        
        for (const issue of issues) {
            const severity = issue.fields.customfield_10000?.value || 'MEDIUM';
            counts[severity] = (counts[severity] || 0) + 1;
        }
        
        return counts;
    }
    
    countIncidentsByStatus(issues) {
        const counts = {};
        
        for (const issue of issues) {
            const status = issue.fields.status.name;
            counts[status] = (counts[status] || 0) + 1;
        }
        
        return counts;
    }
    
    calculateAverageResolutionTime(issues) {
        const resolvedIssues = issues.filter(issue => 
            issue.fields.status.name === 'Done' || issue.fields.status.name === 'Closed'
        );
        
        if (resolvedIssues.length === 0) return 0;
        
        const totalResolutionTime = resolvedIssues.reduce((sum, issue) => {
            const created = new Date(issue.fields.created);
            const resolved = issue.fields.resolutionDate ? 
                           new Date(issue.fields.resolutionDate) : 
                           new Date();
            return sum + (resolved - created);
        }, 0);
        
        return totalResolutionTime / resolvedIssues.length;
    }
    
    getTopSources(issues) {
        const sources = {};
        
        for (const issue of issues) {
            const description = issue.fields.description || '';
            const sourceMatch = description.match(/Source:\s*(.+)/);
            if (sourceMatch) {
                const source = sourceMatch[1].trim();
                sources[source] = (sources[source] || 0) + 1;
            }
        }
        
        return Object.entries(sources)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10)
            .map(([source, count]) => ({ source, count }));
    }
    
    generateIncidentRecommendations(issues) {
        const recommendations = [];
        
        const criticalCount = issues.filter(i => 
            i.fields.customfield_10000?.value === 'CRITICAL'
        ).length;
        
        if (criticalCount > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Security Incidents',
                description: `Found ${criticalCount} critical security incidents`,
                action: 'Prioritize investigation and resolution of critical incidents'
            });
        }
        
        const unresolvedCount = issues.filter(i => 
            !['Done', 'Closed'].includes(i.fields.status.name)
        ).length;
        
        if (unresolvedCount > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Clear Unresolved Security Incidents',
                description: `Found ${unresolvedCount} unresolved security incidents`,
                action: 'Review and resolve outstanding security incidents'
            });
        }
        
        return recommendations;
    }
}

// Использование интеграции с Jira
const incidentIntegration = new IncidentManagementIntegration({
    jira: {
        baseUrl: process.env.JIRA_BASE_URL,
        username: process.env.JIRA_USERNAME,
        apiToken: process.env.JIRA_API_TOKEN,
        projectKey: 'SEC'
    }
});

// Создание инцидента из алерта
async function createJiraIncident(alert) {
    const result = await incidentIntegration.createIncident(alert);
    console.log('Jira incident created:', result);
    return result;
}
```

### 2. Интеграция с системами SIEM

```javascript
// Интеграция с SIEM системами (например, Splunk, ELK)
class SIEMIntegration {
    constructor(config) {
        this.config = config;
        this.siemSystem = config.system; // 'splunk', 'elk', 'datadog', etc.
    }
    
    async sendToSIEM(alert) {
        switch (this.siemSystem) {
            case 'splunk':
                return await this.sendToSplunk(alert);
            case 'elk':
                return await this.sendToELK(alert);
            case 'datadog':
                return await this.sendToDatadog(alert);
            default:
                throw new Error(`Unsupported SIEM system: ${this.siemSystem}`);
        }
    }
    
    async sendToSplunk(alert) {
        const payload = {
            event: {
                sourcetype: 'security_alert',
                host: process.env.HOSTNAME || 'unknown',
                source: 'security_monitoring_system',
                time: Math.floor(new Date(alert.timestamp).getTime() / 1000),
                alert: alert
            }
        };
        
        try {
            const response = await fetch(this.config.splunk.hecUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Splunk ${this.config.splunk.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                throw new Error(`Splunk HEC request failed: ${response.status}`);
            }
            
            return { success: true, system: 'splunk' };
        } catch (error) {
            console.error('Failed to send alert to Splunk:', error);
            return { success: false, error: error.message, system: 'splunk' };
        }
    }
    
    async sendToELK(alert) {
        const { Client } = require('@elastic/elasticsearch');
        const client = new Client({ node: this.config.elk.nodeUrl });
        
        try {
            const result = await client.index({
                index: this.config.elk.index || 'security-alerts',
                body: {
                    '@timestamp': alert.timestamp,
                    alert: alert,
                    severity: alert.severity,
                    type: alert.type,
                    source: alert.source,
                    context: alert.context,
                    threat: alert.threat
                }
            });
            
            return { success: true, system: 'elk', id: result._id };
        } catch (error) {
            console.error('Failed to send alert to ELK:', error);
            return { success: false, error: error.message, system: 'elk' };
        }
    }
    
    async sendToDatadog(alert) {
        const payload = {
            title: alert.title,
            text: alert.description,
            priority: this.mapSeverityToDatadogPriority(alert.severity),
            tags: [
                'security',
                `severity:${alert.severity.toLowerCase()}`,
                `type:${alert.type.toLowerCase()}`,
                `source:${alert.source}`
            ],
            alert_type: 'security',
            source_type_name: 'security_monitoring'
        };
        
        try {
            const response = await fetch('https://api.datadoghq.com/api/v1/events', {
                method: 'POST',
                headers: {
                    'DD-API-KEY': this.config.datadog.apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                throw new Error(`Datadog API request failed: ${response.status}`);
            }
            
            return { success: true, system: 'datadog' };
        } catch (error) {
            console.error('Failed to send alert to Datadog:', error);
            return { success: false, error: error.message, system: 'datadog' };
        }
    }
    
    mapSeverityToDatadogPriority(severity) {
        const mapping = {
            'CRITICAL': 'normal',
            'HIGH': 'normal',
            'MEDIUM': 'low',
            'LOW': 'low'
        };
        return mapping[severity] || 'normal';
    }
    
    async bulkSendToSIEM(alerts) {
        // Отправка множества алертов
        const results = [];
        
        for (const alert of alerts) {
            const result = await this.sendToSIEM(alert);
            results.push({ ...result, alertId: alert.id });
        }
        
        return results;
    }
    
    async searchInSIEM(query, timeRange) {
        // Поиск в SIEM системе
        switch (this.siemSystem) {
            case 'splunk':
                return await this.searchInSplunk(query, timeRange);
            case 'elk':
                return await this.searchInELK(query, timeRange);
            default:
                throw new Error(`Search not supported for ${this.siemSystem}`);
        }
    }
    
    async searchInSplunk(query, timeRange) {
        // Поиск в Splunk
        const searchQuery = `search index=* ${query} earliest=${timeRange.start} latest=${timeRange.end}`;
        
        const payload = {
            search: searchQuery,
            exec_mode: 'oneshot',
            output_mode: 'json'
        };
        
        const response = await fetch(`${this.config.splunk.baseUrl}/services/search/jobs`, {
            method: 'POST',
            headers: {
                'Authorization': `Splunk ${this.config.splunk.token}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams(payload)
        });
        
        return await response.json();
    }
    
    async searchInELK(query, timeRange) {
        // Поиск в ELK
        const client = require('@elastic/elasticsearch').Client({
            node: this.config.elk.nodeUrl
        });
        
        const result = await client.search({
            index: this.config.elk.index || 'security-alerts',
            body: {
                query: {
                    bool: {
                        must: [
                            { query_string: { query: query } },
                            { range: { '@timestamp': { gte: timeRange.start, lte: timeRange.end } } }
                        ]
                    }
                },
                sort: [{ '@timestamp': { order: 'desc' } }],
                size: 100
            }
        });
        
        return result;
    }
    
    async generateSIEMReport() {
        // Генерация отчета из SIEM
        const recentAlerts = await this.searchInSIEM(
            'source="security_monitoring_system"', 
            {
                start: '-24h@h',
                end: 'now'
            }
        );
        
        return {
            timestamp: new Date().toISOString(),
            totalAlerts: recentAlerts.hits?.total?.value || 0,
            bySeverity: this.countBySeverity(recentAlerts),
            byType: this.countByType(recentAlerts),
            trends: await this.getTrends(recentAlerts)
        };
    }
    
    countBySeverity(result) {
        // Подсчет алертов по тяжести
        if (!result.aggregations) return {};
        
        const severityBuckets = result.aggregations.severity.buckets || [];
        const counts = {};
        
        for (const bucket of severityBuckets) {
            counts[bucket.key] = bucket.doc_count;
        }
        
        return counts;
    }
    
    countByType(result) {
        // Подсчет алертов по типу
        if (!result.aggregations) return {};
        
        const typeBuckets = result.aggregations.type.buckets || [];
        const counts = {};
        
        for (const bucket of typeBuckets) {
            counts[bucket.key] = bucket.doc_count;
        }
        
        return counts;
    }
    
    async getTrends(result) {
        // Получение трендов
        if (!result.aggregations?.time_buckets) return [];
        
        return result.aggregations.time_buckets.buckets.map(bucket => ({
            timestamp: bucket.key_as_string,
            count: bucket.doc_count
        }));
    }
}

// Использование SIEM интеграции
const siemIntegration = new SIEMIntegration({
    system: 'elk',
    elk: {
        nodeUrl: process.env.ELK_NODE_URL,
        index: 'security-alerts'
    }
});

async function sendAlertToSIEM(alert) {
    const result = await siemIntegration.sendToSIEM(alert);
    console.log('SIEM integration result:', result);
    return result;
}
```

## Лучшие практики

### 1. Политики сигнализации

```javascript
// Политики сигнализации безопасности
class AlertingPolicyManager {
    constructor() {
        this.policies = {
            // Политика тяжести
            severity: {
                critical: {
                    immediateNotification: true,
                    escalationRequired: true,
                    responseTime: 15 * 60 * 1000 // 15 минут
                },
                high: {
                    immediateNotification: true,
                    escalationRequired: false,
                    responseTime: 1 * 60 * 60 * 1000 // 1 час
                },
                medium: {
                    batchNotification: true,
                    responseTime: 4 * 60 * 60 * 1000 // 4 часа
                },
                low: {
                    dailySummary: true,
                    responseTime: 24 * 60 * 60 * 1000 // 24 часа
                }
            },
            
            // Политика дедупликации
            deduplication: {
                enabled: true,
                window: 300000, // 5 минут
                fields: ['type', 'source', 'description']
            },
            
            // Политика агрегации
            aggregation: {
                enabled: true,
                threshold: 5, // агрегировать если > 5 похожих алертов
                window: 3600000, // 1 час
                groupingFields: ['type', 'source']
            },
            
            // Политика эскалации
            escalation: {
                enabled: true,
                levels: {
                    'L1': { timeout: 30 * 60 * 1000, targets: ['oncall-engineer'] },
                    'L2': { timeout: 2 * 60 * 60 * 1000, targets: ['security-team'] },
                    'L3': { timeout: 6 * 60 * 60 * 1000, targets: ['management'] }
                }
            }
        };
        
        this.exceptions = new Map(); // исключения для конкретных пакетов/ситуаций
        this.maintenanceWindows = []; // окна технического обслуживания
    }
    
    async evaluateAlertAgainstPolicy(alert) {
        const evaluation = {
            severityCompliance: this.checkSeverityPolicy(alert),
            deduplicationCompliance: this.checkDeduplicationPolicy(alert),
            aggregationCompliance: this.checkAggregationPolicy(alert),
            escalationCompliance: this.checkEscalationPolicy(alert),
            overallCompliance: false
        };
        
        evaluation.overallCompliance = 
            evaluation.severityCompliance.compliant &&
            evaluation.deduplicationCompliance.compliant &&
            evaluation.aggregationCompliance.compliant &&
            evaluation.escalationCompliance.compliant;
        
        return evaluation;
    }
    
    checkSeverityPolicy(alert) {
        const policy = this.policies.severity[alert.severity.toLowerCase()];
        
        if (!policy) {
            return {
                compliant: false,
                reason: `No policy defined for severity: ${alert.severity}`
            };
        }
        
        return {
            compliant: true,
            policy: policy,
            responseTimeRequired: policy.responseTime
        };
    }
    
    checkDeduplicationPolicy(alert) {
        if (!this.policies.deduplication.enabled) {
            return { compliant: true };
        }
        
        // Проверка на дубликаты
        const duplicate = this.findDuplicate(alert);
        
        return {
            compliant: !duplicate,
            duplicateFound: !!duplicate,
            duplicateAlert: duplicate
        };
    }
    
    checkAggregationPolicy(alert) {
        if (!this.policies.aggregation.enabled) {
            return { compliant: true };
        }
        
        // Проверка на возможность агрегации
        const similarAlerts = this.findSimilarAlerts(alert);
        
        return {
            compliant: similarAlerts.length < this.policies.aggregation.threshold,
            similarAlertsCount: similarAlerts.length,
            aggregationRequired: similarAlerts.length >= this.policies.aggregation.threshold
        };
    }
    
    checkEscalationPolicy(alert) {
        if (!this.policies.escalation.enabled) {
            return { compliant: true };
        }
        
        // Проверка требований эскалации
        const requiresEscalation = alert.severity === 'CRITICAL' || 
                                  (alert.confidence > 0.9 && alert.severity === 'HIGH');
        
        return {
            compliant: !requiresEscalation || alert.escalated,
            escalationRequired: requiresEscalation,
            escalationLevels: this.policies.escalation.levels
        };
    }
    
    findDuplicate(alert) {
        // Поиск дубликата алерта
        const cutoffTime = new Date(Date.now() - this.policies.deduplication.window);
        
        for (const existingAlert of this.activeAlerts.values()) {
            if (new Date(existingAlert.timestamp) < cutoffTime) continue;
            
            const isDuplicate = this.policies.deduplication.fields.every(field => {
                const existingValue = this.getNestedValue(existingAlert, field);
                const currentValue = this.getNestedValue(alert, field);
                return existingValue === currentValue;
            });
            
            if (isDuplicate) {
                return existingAlert;
            }
        }
        
        return null;
    }
    
    findSimilarAlerts(alert) {
        // Поиск похожих алертов для агрегации
        const cutoffTime = new Date(Date.now() - this.policies.aggregation.window);
        const similar = [];
        
        for (const existingAlert of this.activeAlerts.values()) {
            if (new Date(existingAlert.timestamp) < cutoffTime) continue;
            
            const isSimilar = this.policies.aggregation.groupingFields.every(field => {
                const existingValue = this.getNestedValue(existingAlert, field);
                const currentValue = this.getNestedValue(alert, field);
                return existingValue === currentValue;
            });
            
            if (isSimilar) {
                similar.push(existingAlert);
            }
        }
        
        return similar;
    }
    
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    }
    
    async addException(packageName, license, reason, approver) {
        const exception = {
            id: `exception_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            packageName,
            license,
            reason,
            approvedBy: approver,
            approvedAt: new Date().toISOString(),
            expiresAt: null // может быть с датой истечения
        };
        
        this.exceptions.set(`${packageName}:${license}`, exception);
        
        // Сохранение исключения
        await this.saveExceptions();
        
        return exception;
    }
    
    async saveExceptions() {
        const fs = require('fs');
        const path = require('path');
        
        const exceptionsDir = path.join(process.cwd(), '.security');
        if (!fs.existsSync(exceptionsDir)) {
            fs.mkdirSync(exceptionsDir, { recursive: true });
        }
        
        fs.writeFileSync(
            path.join(exceptionsDir, 'alerting-exceptions.json'),
            JSON.stringify(Object.fromEntries(this.exceptions), null, 2)
        );
    }
    
    async loadExceptions() {
        const fs = require('fs');
        const path = require('path');
        
        const exceptionsFile = path.join(process.cwd(), '.security', 'alerting-exceptions.json');
        
        if (fs.existsSync(exceptionsFile)) {
            const exceptions = JSON.parse(fs.readFileSync(exceptionsFile, 'utf8'));
            this.exceptions = new Map(Object.entries(exceptions));
        }
    }
    
    async getPolicyComplianceReport() {
        const alertStats = await this.getAlertStatistics();
        
        return {
            timestamp: new Date().toISOString(),
            policies: this.policies,
            compliance: {
                severity: this.calculateSeverityCompliance(),
                deduplication: this.calculateDeduplicationCompliance(),
                aggregation: this.calculateAggregationCompliance(),
                escalation: this.calculateEscalationCompliance()
            },
            statistics: alertStats,
            recommendations: this.generatePolicyRecommendations(alertStats)
        };
    }
    
    calculateSeverityCompliance() {
        // Расчет соответствия политике тяжести
        return 100; // заглушка
    }
    
    calculateDeduplicationCompliance() {
        // Расчет соответствия политике дедупликации
        return 100; // заглушка
    }
    
    calculateAggregationCompliance() {
        // Расчет соответствия политике агрегации
        return 100; // заглушка
    }
    
    calculateEscalationCompliance() {
        // Расчет соответствия политике эскалации
        return 100; // заглушка
    }
    
    generatePolicyRecommendations(stats) {
        const recommendations = [];
        
        if (stats.bySeverity.CRITICAL > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Review Critical Alert Handling Process',
                description: 'Critical alerts require immediate attention',
                action: 'Ensure proper escalation procedures are in place'
            });
        }
        
        if (stats.falsePositives > 10) { // больше 10 ложных срабатываний
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Tune Alerting Rules',
                description: `High false positive rate: ${stats.falsePositives} FP detected`,
                action: 'Review and refine alerting rules to reduce noise'
            });
        }
        
        if (stats.averageResolutionTime > 3600000) { // больше 1 часа
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Alert Resolution Time',
                description: 'Alerts taking too long to resolve',
                action: 'Streamline investigation and resolution processes'
            });
        }
        
        return recommendations;
    }
    
    async validatePolicyConfiguration() {
        const validation = {
            valid: true,
            errors: [],
            warnings: []
        };
        
        // Проверка конфигурации политик
        if (!this.policies.severity.critical) {
            validation.errors.push('Critical severity policy is required');
            validation.valid = false;
        }
        
        if (!this.policies.severity.high) {
            validation.errors.push('High severity policy is required');
            validation.valid = false;
        }
        
        if (this.policies.deduplication.window > 3600000) { // больше 1 часа
            validation.warnings.push('Deduplication window is too long (>1 hour)');
        }
        
        if (this.policies.aggregation.threshold < 2) {
            validation.warnings.push('Aggregation threshold is too low (<2)');
        }
        
        return validation;
    }
}

// Использование менеджера политик
const policyManager = new AlertingPolicyManager();
await policyManager.loadExceptions();

async function runPolicyComplianceCheck() {
    const report = await policyManager.getPolicyComplianceReport();
    console.log('Alerting Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (!report.compliance.severity || 
        !report.compliance.deduplication || 
        !report.compliance.aggregation || 
        !report.compliance.escalation) {
        console.error('Policy compliance check failed');
        process.exit(1);
    }
    
    return report;
}
```

### 2. Автоматическое реагирование

```javascript
// Система автоматического реагирования на алерты
class AutomatedResponseSystem {
    constructor(alertManager) {
        this.alertManager = alertManager;
        this.responseRules = new Map();
        this.responseHistory = [];
        this.maxHistorySize = 1000;
    }
    
    addResponseRule(severity, conditions, actions) {
        const rule = {
            id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            severity,
            conditions,
            actions,
            enabled: true,
            createdAt: new Date().toISOString()
        };
        
        this.responseRules.set(rule.id, rule);
        return rule;
    }
    
    async processAlert(alert) {
        // Найти подходящие правила реагирования
        const applicableRules = this.getApplicableResponseRules(alert);
        
        for (const rule of applicableRules) {
            if (rule.enabled) {
                await this.executeResponseRule(rule, alert);
            }
        }
        
        // Обновление истории
        this.responseHistory.push({
            alertId: alert.id,
            ruleId: applicableRules.map(r => r.id),
            executedActions: applicableRules.flatMap(r => r.actions),
            timestamp: new Date().toISOString()
        });
        
        // Ограничение истории
        if (this.responseHistory.length > this.maxHistorySize) {
            this.responseHistory = this.responseHistory.slice(-this.maxHistorySize);
        }
    }
    
    getApplicableResponseRules(alert) {
        const applicable = [];
        
        for (const rule of this.responseRules.values()) {
            if (rule.severity === alert.severity && 
                this.evaluateConditions(rule.conditions, alert)) {
                applicable.push(rule);
            }
        }
        
        return applicable;
    }
    
    evaluateConditions(conditions, alert) {
        // Оценка условий для правила
        if (typeof conditions === 'function') {
            return conditions(alert);
        }
        
        if (typeof conditions === 'object') {
            return this.evaluateComplexConditions(conditions, alert);
        }
        
        return false;
    }
    
    evaluateComplexConditions(conditions, alert) {
        if (conditions.and) {
            return conditions.and.every(cond => this.evaluateSimpleCondition(cond, alert));
        }
        
        if (conditions.or) {
            return conditions.or.some(cond => this.evaluateSimpleCondition(cond, alert));
        }
        
        if (conditions.not) {
            return !this.evaluateSimpleCondition(conditions.not, alert);
        }
        
        return this.evaluateSimpleCondition(conditions, alert);
    }
    
    evaluateSimpleCondition(condition, alert) {
        const value = this.getNestedValue(alert, condition.field);
        
        switch (condition.operator) {
            case 'equals':
                return value === condition.value;
            case 'contains':
                return String(value).includes(condition.value);
            case 'greater_than':
                return Number(value) > Number(condition.value);
            case 'less_than':
                return Number(value) < Number(condition.value);
            case 'matches_regex':
                return new RegExp(condition.value).test(String(value));
            default:
                return false;
        }
    }
    
    async executeResponseRule(rule, alert) {
        const executedActions = [];
        
        for (const action of rule.actions) {
            try {
                const result = await this.executeAction(action, alert);
                executedActions.push({
                    action: action,
                    result: result,
                    success: true,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                executedActions.push({
                    action: action,
                    error: error.message,
                    success: false,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        // Логирование выполненных действий
        console.log(`Response rule ${rule.id} executed for alert ${alert.id}`, executedActions);
        
        return executedActions;
    }
    
    async executeAction(action, alert) {
        switch (action.type) {
            case 'BLOCK_IP':
                return await this.blockIP(action.parameters.ip || alert.context.ip);
            case 'SEND_EMAIL':
                return await this.sendEmail(action.parameters);
            case 'CREATE_INCIDENT':
                return await this.createIncident(alert, action.parameters);
            case 'CALL_WEBHOOK':
                return await this.callWebhook(action.parameters.url, { alert, action });
            case 'EXECUTE_SCRIPT':
                return await this.executeScript(action.parameters.script, { alert, action });
            case 'UPDATE_ALERT_STATUS':
                return await this.alertManager.updateAlertStatus(alert.id, action.parameters.status);
            default:
                throw new Error(`Unknown action type: ${action.type}`);
        }
    }
    
    async blockIP(ip) {
        // Блокировка IP-адреса (реализация зависит от инфраструктуры)
        console.log(`Blocking IP: ${ip}`);
        
        // В реальности: интеграция с firewall, WAF, CDN и т.д.
        return { success: true, ip, action: 'BLOCKED' };
    }
    
    async sendEmail(parameters) {
        // Отправка email (реализация зависит от настройки)
        console.log(`Sending email to: ${parameters.to}, subject: ${parameters.subject}`);
        
        // В реальности: использование почтового сервиса
        return { success: true, recipient: parameters.to };
    }
    
    async createIncident(alert, parameters) {
        // Создание инцидента в системе управления
        console.log(`Creating incident for alert: ${alert.id}`);
        
        // В реальности: интеграция с Jira, ServiceNow, PagerDuty и т.д.
        return { success: true, alertId: alert.id, incidentCreated: true };
    }
    
    async callWebhook(url, payload) {
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            return { success: response.ok, status: response.status };
        } catch (error) {
            throw new Error(`Webhook call failed: ${error.message}`);
        }
    }
    
    async executeScript(script, context) {
        // Выполнение скрипта (в безопасном контексте!)
        console.log('Executing response script');
        
        // В реальности: использование VM, Docker контейнера или других средств изоляции
        return { success: true, scriptExecuted: true };
    }
    
    async getResponseStatistics() {
        const stats = {
            totalResponses: this.responseHistory.length,
            successfulResponses: this.responseHistory.filter(r => 
                r.executedActions.every(a => a.success)
            ).length,
            failedResponses: this.responseHistory.filter(r => 
                r.executedActions.some(a => !a.success)
            ).length,
            byActionType: {},
            byRule: {},
            averageResponseTime: 0
        };
        
        // Подсчет по типам действий
        for (const record of this.responseHistory) {
            for (const action of record.executedActions) {
                stats.byActionType[action.action.type] = 
                    (stats.byActionType[action.action.type] || 0) + 1;
            }
        }
        
        // Подсчет по правилам
        for (const record of this.responseHistory) {
            for (const ruleId of record.ruleId) {
                stats.byRule[ruleId] = (stats.byRule[ruleId] || 0) + 1;
            }
        }
        
        return stats;
    }
    
    async generateResponseReport() {
        const stats = await this.getResponseStatistics();
        const recentActions = this.responseHistory.slice(-20);
        
        return {
            timestamp: new Date().toISOString(),
            statistics: stats,
            recentActions: recentActions,
            rules: Array.from(this.responseRules.values()),
            recommendations: this.generateResponseRecommendations(stats)
        };
    }
    
    generateResponseRecommendations(stats) {
        const recommendations = [];
        
        if (stats.failedResponses > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix Failed Response Actions',
                description: `Found ${stats.failedResponses} failed response actions`,
                action: 'Review and fix response action configurations'
            });
        }
        
        if (stats.averageResponseTime > 5000) { // больше 5 секунд
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Response Time',
                description: `Average response time is ${stats.averageResponseTime}ms`,
                action: 'Optimize response actions and configurations'
            });
        }
        
        return recommendations;
    }
}

// Использование системы автоматического реагирования
const responseSystem = new AutomatedResponseSystem(alertManager);

// Добавление правил реагирования
responseSystem.addResponseRule('CRITICAL', 
    { field: 'context.ip', operator: 'exists' },
    [
        { type: 'BLOCK_IP', parameters: { ip: '{{context.ip}}' } },
        { type: 'SEND_EMAIL', parameters: { to: 'security@company.com', subject: 'Critical Security Alert' } },
        { type: 'CREATE_INCIDENT', parameters: { system: 'jira', project: 'SEC' } }
    ]
);

responseSystem.addResponseRule('HIGH',
    { field: 'threat.type', operator: 'equals', value: 'BRUTE_FORCE' },
    [
        { type: 'BLOCK_IP', parameters: { ip: '{{context.ip}}', duration: 3600 } },
        { type: 'SEND_EMAIL', parameters: { to: 'security@company.com', subject: 'High Priority Security Alert' } }
    ]
);

// Обработка алерта с автоматическим реагированием
async function processAlertWithResponse(alert) {
    await responseSystem.processAlert(alert);
    await alertManager.processAlert(alert);
}
```

## Тестирование системы сигнализации

### 1. Автоматизированные тесты

```javascript
// Тесты для системы сигнализации
describe('Security Alerting System', () => {
    let alertingSystem;
    let mockNotifications;
    
    beforeEach(() => {
        alertingSystem = new SecurityAlertingSystem({
            notificationChannels: ['console'],
            alertThresholds: {
                critical: 0,
                high: 5,
                medium: 10
            }
        });
        
        mockNotifications = [];
    });
    
    test('should generate alert for critical vulnerability', async () => {
        const mockThreat = {
            id: 'test-threat-1',
            type: 'SQL_INJECTION',
            severity: 'CRITICAL',
            title: 'SQL Injection Detected',
            description: 'SQL injection attempt detected',
            confidence: 0.95,
            timestamp: new Date().toISOString()
        };
        
        const result = await alertingSystem.generateAlerts([mockThreat]);
        
        expect(result).toHaveLength(1);
        expect(result[0].severity).toBe('CRITICAL');
        expect(result[0].title).toContain('SQL Injection');
    });
    
    test('should suppress duplicate alerts', async () => {
        const mockThreat = {
            id: 'test-threat-2',
            type: 'XSS',
            severity: 'HIGH',
            title: 'XSS Attempt',
            description: 'Cross-site scripting attempt',
            timestamp: new Date().toISOString()
        };
        
        // Отправка одного и того же алерта дважды
        await alertingSystem.generateAlerts([mockThreat]);
        await alertingSystem.generateAlerts([mockThreat]);
        
        const activeAlerts = await alertingSystem.getActiveAlerts();
        // Должен быть только один алерт из-за дедупликации
        expect(activeAlerts).toHaveLength(1);
    });
    
    test('should apply alert coalescing', async () => {
        const threats = Array.from({ length: 6 }, (_, i) => ({
            id: `threat-${i}`,
            type: 'BRUTE_FORCE',
            severity: 'MEDIUM',
            title: 'Multiple Failed Logins',
            description: 'Multiple authentication failures from same IP',
            timestamp: new Date(Date.now() - i * 60000).toISOString(), // каждую минуту
            event: { context: { ip: '192.168.1.100' } }
        }));
        
        const result = await alertingSystem.generateAlerts(threats);
        
        // При агрегации должно быть меньше алертов
        expect(result.length).toBeLessThan(threats.length);
    });
    
    test('should handle different severity levels', async () => {
        const threats = [
            { type: 'test', severity: 'CRITICAL', title: 'Critical', timestamp: new Date().toISOString() },
            { type: 'test', severity: 'HIGH', title: 'High', timestamp: new Date().toISOString() },
            { type: 'test', severity: 'MEDIUM', title: 'Medium', timestamp: new Date().toISOString() },
            { type: 'test', severity: 'LOW', title: 'Low', timestamp: new Date().toISOString() }
        ];
        
        const result = await alertingSystem.generateAlerts(threats);
        
        const bySeverity = result.reduce((acc, alert) => {
            acc[alert.severity] = (acc[alert.severity] || 0) + 1;
            return acc;
        }, {});
        
        expect(bySeverity.CRITICAL).toBeGreaterThanOrEqual(0);
        expect(bySeverity.HIGH).toBeGreaterThanOrEqual(0);
        expect(bySeverity.MEDIUM).toBeGreaterThanOrEqual(0);
        expect(bySeverity.LOW).toBeGreaterThanOrEqual(0);
    });
    
    test('should validate alert structure', async () => {
        const invalidAlert = {
            type: 'test',
            // отсутствует required field 'id'
        };
        
        const result = await alertingSystem.createAlert(invalidAlert);
        
        expect(result).toHaveProperty('id');
        expect(result).toHaveProperty('timestamp');
        expect(result).toHaveProperty('severity');
    });
    
    test('should calculate alert severity correctly', async () => {
        const alert = {
            type: 'test',
            severity: 'HIGH',
            confidence: 0.8,
            event: {
                context: { ip: '192.168.1.100' }
            }
        };
        
        const processedAlert = await alertingSystem.processSingleAlert(alert);
        
        expect(processedAlert).toHaveProperty('severity');
        expect(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']).toContain(processedAlert.severity);
    });
    
    test('should maintain alert history', async () => {
        const threats = [
            { type: 'test1', severity: 'HIGH', title: 'Test 1', timestamp: new Date().toISOString() },
            { type: 'test2', severity: 'MEDIUM', title: 'Test 2', timestamp: new Date().toISOString() }
        ];
        
        await alertingSystem.generateAlerts(threats);
        
        const history = await alertingSystem.getAlertHistory();
        expect(history.length).toBeGreaterThanOrEqual(2);
        
        const recentAlerts = history.slice(0, 2);
        expect(recentAlerts[0].title).toBe('Test 2'); // более новый
        expect(recentAlerts[1].title).toBe('Test 1');
    });
    
    test('should generate accurate statistics', async () => {
        const threats = [
            { type: 'test', severity: 'CRITICAL', title: 'Critical', timestamp: new Date().toISOString() },
            { type: 'test', severity: 'HIGH', title: 'High', timestamp: new Date().toISOString() },
            { type: 'test', severity: 'MEDIUM', title: 'Medium', timestamp: new Date().toISOString() }
        ];
        
        await alertingSystem.generateAlerts(threats);
        
        const stats = await alertingSystem.getAlertStatistics();
        
        expect(stats).toHaveProperty('totalAlerts');
        expect(stats).toHaveProperty('bySeverity');
        expect(stats.bySeverity.CRITICAL).toBeGreaterThanOrEqual(1);
        expect(stats.bySeverity.HIGH).toBeGreaterThanOrEqual(1);
        expect(stats.bySeverity.MEDIUM).toBeGreaterThanOrEqual(1);
    });
    
    test('should handle alert acknowledgment', async () => {
        const threat = { 
            type: 'test', 
            severity: 'HIGH', 
            title: 'Ack Test', 
            timestamp: new Date().toISOString() 
        };
        
        const alerts = await alertingSystem.generateAlerts([threat]);
        const alertId = alerts[0].id;
        
        await alertingSystem.acknowledgeAlert(alertId, 'test-user');
        
        const activeAlerts = await alertingSystem.getActiveAlerts();
        const ackAlert = activeAlerts.find(alert => alert.id === alertId);
        
        expect(ackAlert.status).toBe('ACKNOWLEDGED');
        expect(ackAlert.acknowledgedBy).toBe('test-user');
        expect(ackAlert.acknowledgedAt).toBeDefined();
    });
    
    test('should handle alert resolution', async () => {
        const threat = { 
            type: 'test', 
            severity: 'HIGH', 
            title: 'Resolve Test', 
            timestamp: new Date().toISOString() 
        };
        
        const alerts = await alertingSystem.generateAlerts([threat]);
        const alertId = alerts[0].id;
        
        await alertingSystem.resolveAlert(alertId, 'test-user', 'Issue resolved');
        
        const activeAlerts = await alertingSystem.getActiveAlerts();
        const resolvedAlert = activeAlerts.find(alert => alert.id === alertId);
        
        expect(resolvedAlert.status).toBe('RESOLVED');
        expect(resolvedAlert.resolvedBy).toBe('test-user');
        expect(resolvedAlert.resolutionNotes).toBe('Issue resolved');
    });
    
    test('should filter alerts by criteria', async () => {
        const threats = [
            { type: 'auth', severity: 'HIGH', title: 'Auth Test', source: 'auth-service', timestamp: new Date().toISOString() },
            { type: 'network', severity: 'MEDIUM', title: 'Network Test', source: 'network-service', timestamp: new Date().toISOString() }
        ];
        
        await alertingSystem.generateAlerts(threats);
        
        const filteredBySeverity = await alertingSystem.getActiveAlerts({ severity: 'HIGH' });
        expect(filteredBySeverity).toHaveLength(1);
        expect(filteredBySeverity[0].severity).toBe('HIGH');
        
        const filteredBySource = await alertingSystem.getActiveAlerts({ source: 'auth-service' });
        expect(filteredBySource).toHaveLength(1);
        expect(filteredBySource[0].source).toBe('auth-service');
    });
    
    test('should generate comprehensive dashboard data', async () => {
        const dashboard = await alertingSystem.getAlertDashboard();
        
        expect(dashboard).toHaveProperty('timestamp');
        expect(dashboard).toHaveProperty('statistics');
        expect(dashboard).toHaveProperty('activeAlerts');
        expect(dashboard).toHaveProperty('recentAlerts');
        expect(dashboard).toHaveProperty('trends');
        expect(dashboard).toHaveProperty('recommendations');
        
        expect(dashboard.statistics).toHaveProperty('totalAlerts');
        expect(dashboard.statistics).toHaveProperty('averageResolutionTime');
        expect(dashboard.statistics).toHaveProperty('resolutionRate');
    });
    
    test('should handle system alerts', async () => {
        const systemAlert = {
            type: 'SYSTEM_ERROR',
            severity: 'CRITICAL',
            title: 'System Failure',
            description: 'Critical system component failed',
            timestamp: new Date().toISOString()
        };
        
        await alertingSystem.sendSystemAlert(systemAlert);
        
        // Проверка, что алерт был обработан (без фильтрации)
        expect(true).toBe(true); // Заглушка - в реальности проверять отправку
    });
    
    test('should calculate risk level correctly', async () => {
        const mockThreat = {
            type: 'test',
            severity: 'HIGH',
            confidence: 0.9,
            event: {
                context: { ip: '192.168.1.100', user: 'test-user' }
            }
        };
        
        const result = await alertingSystem.processSingleAlert(mockThreat);
        
        // Проверка, что уровень риска соответствует тяжести
        expect(result.severity).toBe('HIGH');
        expect(result.confidence).toBe(0.9);
    });
    
    test('should handle batch processing', async () => {
        const threats = Array.from({ length: 50 }, (_, i) => ({
            id: `batch-threat-${i}`,
            type: 'BATCH_TEST',
            severity: i % 2 === 0 ? 'HIGH' : 'MEDIUM',
            title: `Batch Threat ${i}`,
            timestamp: new Date(Date.now() - i * 1000).toISOString()
        }));
        
        const startTime = Date.now();
        const results = await alertingSystem.generateAlerts(threats);
        const endTime = Date.now();
        
        expect(results.length).toBe(50);
        expect(endTime - startTime).toBeLessThan(30000); // Должно обрабатываться быстро
    });
    
    test('should maintain alert correlation', async () => {
        const correlationEngine = new CorrelationEngine();
        
        const alerts = [
            { id: 'alert1', type: 'AUTH_FAILURE', sourceIP: '192.168.1.100', timestamp: new Date().toISOString() },
            { id: 'alert2', type: 'AUTH_FAILURE', sourceIP: '192.168.1.100', timestamp: new Date(Date.now() + 1000).toISOString() },
            { id: 'alert3', type: 'AUTH_FAILURE', sourceIP: '192.168.1.100', timestamp: new Date(Date.now() + 2000).toISOString() }
        ];
        
        const correlated = await correlationEngine.correlate(alerts);
        
        // Должен быть один коррелированный алерт
        expect(correlated.length).toBe(1);
        expect(correlated[0].type).toBe('CORRELATED_THREAT');
        expect(correlated[0].correlationCount).toBe(3);
    });
    
    test('should generate appropriate recommendations', async () => {
        const mockStats = {
            bySeverity: { CRITICAL: 2, HIGH: 5, MEDIUM: 10, LOW: 15 },
            averageResolutionTime: 7200000, // 2 часа
            resolutionRate: 60 // 60%
        };
        
        const recommendations = alertingSystem.generateAlertRecommendations(mockStats);
        
        expect(Array.isArray(recommendations)).toBe(true);
        expect(recommendations.length).toBeGreaterThan(0);
        
        const criticalRec = recommendations.find(r => r.priority === 'CRITICAL');
        expect(criticalRec).toBeDefined();
        expect(criticalRec.title).toContain('Critical');
    });
});

// Интеграционные тесты
describe('Integration: Alerting System with External Services', () => {
    test('should integrate with Jira for incident creation', async () => {
        const incidentIntegration = new IncidentManagementIntegration({
            jira: {
                baseUrl: process.env.TEST_JIRA_URL || 'http://localhost:8080',
                username: 'test-user',
                apiToken: 'test-token',
                projectKey: 'SEC'
            }
        });
        
        const mockAlert = {
            id: 'test-alert',
            title: 'Integration Test Alert',
            description: 'This is a test alert for integration purposes',
            severity: 'HIGH',
            source: 'test-service',
            timestamp: new Date().toISOString()
        };
        
        // В реальности этот тест будет требовать реальный Jira сервер
        const result = await incidentIntegration.createIncident(mockAlert);
        
        expect(result).toHaveProperty('success');
        expect(typeof result.success).toBe('boolean');
    });
    
    test('should integrate with SIEM system', async () => {
        const siemIntegration = new SIEMIntegration({
            system: 'elk',
            elk: {
                nodeUrl: process.env.TEST_ELASTICSEARCH_URL || 'http://localhost:9200',
                index: 'test-security-alerts'
            }
        });
        
        const mockAlert = {
            id: 'test-siem-alert',
            title: 'SIEM Integration Test',
            description: 'Test alert for SIEM integration',
            severity: 'MEDIUM',
            source: 'integration-test',
            timestamp: new Date().toISOString()
        };
        
        // В реальности этот тест будет требовать реальный ELK стек
        const result = await siemIntegration.sendToSIEM(mockAlert);
        
        expect(result).toHaveProperty('success');
        expect(typeof result.success).toBe('boolean');
    });
    
    test('should handle notification channel failures gracefully', async () => {
        const alertManager = new AlertManager({
            notificationChannels: ['console', 'invalid-channel'],
            alertThresholds: { critical: 0, high: 5, medium: 10 }
        });
        
        const mockAlert = {
            id: 'test-graceful-failure',
            title: 'Graceful Failure Test',
            description: 'Test alert to verify graceful failure handling',
            severity: 'HIGH',
            source: 'test-channel',
            timestamp: new Date().toISOString()
        };
        
        // Должен обработать алерт без падения, несмотря на невалидный канал
        await expect(alertManager.processAlert(mockAlert)).resolves.not.toThrow();
    });
    
    test('should maintain data integrity during processing', async () => {
        const alertingSystem = new SecurityAlertingSystem({
            notificationChannels: ['console'],
            alertThresholds: { critical: 0, high: 100, medium: 100 }
        });
        
        const originalAlert = {
            id: 'integrity-test',
            title: 'Data Integrity Test',
            description: 'Original description',
            severity: 'MEDIUM',
            context: {
                ip: '192.168.1.100',
                user: 'test-user',
                userAgent: 'test-agent'
            },
            timestamp: new Date().toISOString(),
            customField: 'original-value'
        };
        
        const alerts = await alertingSystem.generateAlerts([originalAlert]);
        const processedAlert = alerts[0];
        
        // Проверка сохранения важных полей
        expect(processedAlert.id).toBe(originalAlert.id);
        expect(processedAlert.title).toBe(originalAlert.title);
        expect(processedAlert.severity).toBe(originalAlert.severity);
        expect(processedAlert.context.ip).toBe(originalAlert.context.ip);
        expect(processedAlert.customField).toBe(originalAlert.customField);
        
        // Временные метки должны быть установлены
        expect(processedAlert.timestamp).toBeDefined();
    });
});

// Тестирование производительности
describe('Performance: Alerting System', () => {
    test('should handle high volume of alerts efficiently', async () => {
        const alertingSystem = new SecurityAlertingSystem({
            notificationChannels: ['console'],
            alertThresholds: { critical: 0, high: 1000, medium: 1000 }
        });
        
        const highVolumeAlerts = Array.from({ length: 1000 }, (_, i) => ({
            id: `perf-test-${i}`,
            type: 'PERFORMANCE_TEST',
            severity: i % 3 === 0 ? 'CRITICAL' : i % 3 === 1 ? 'HIGH' : 'MEDIUM',
            title: `Performance Test Alert ${i}`,
            description: `Test alert #${i} for performance evaluation`,
            timestamp: new Date(Date.now() - i * 100).toISOString()
        }));
        
        const startTime = Date.now();
        const results = await alertingSystem.generateAlerts(highVolumeAlerts);
        const endTime = Date.now();
        
        const processingTime = endTime - startTime;
        const alertsPerSecond = results.length / (processingTime / 1000);
        
        console.log(`Processed ${results.length} alerts in ${processingTime}ms (${alertsPerSecond.toFixed(2)} alerts/sec)`);
        
        // Проверка, что все алерты были обработаны
        expect(results.length).toBe(1000);
        
        // Проверка, что обработка не занимает слишком много времени
        expect(processingTime).toBeLessThan(30000); // 30 секунд для 1000 алертов
        expect(alertsPerSecond).toBeGreaterThan(10); // минимум 10 алертов в секунду
    });
    
    test('should maintain memory efficiency during processing', async () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        const alertingSystem = new SecurityAlertingSystem({
            notificationChannels: ['console']
        });
        
        // Обработка большого объема алертов
        for (let batch = 0; batch < 10; batch++) {
            const batchAlerts = Array.from({ length: 100 }, (_, i) => ({
                id: `memory-test-${batch}-${i}`,
                type: 'MEMORY_TEST',
                severity: 'LOW',
                title: `Memory Test ${batch}-${i}`,
                timestamp: new Date().toISOString()
            }));
            
            await alertingSystem.generateAlerts(batchAlerts);
        }
        
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryGrowth = finalMemory - initialMemory;
        
        // Проверка, что рост памяти разумный
        expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024); // 50MB
    });
    
    test('should process alerts consistently', async () => {
        const alertingSystem = new SecurityAlertingSystem({
            notificationChannels: ['console']
        });
        
        const testAlert = {
            type: 'CONSISTENCY_TEST',
            severity: 'MEDIUM',
            title: 'Consistency Test',
            description: 'Testing consistent processing',
            timestamp: new Date().toISOString()
        };
        
        // Запуск обработки несколько раз
        const results = [];
        for (let i = 0; i < 5; i++) {
            const alertResult = await alertingSystem.processSingleAlert(testAlert);
            results.push(alertResult);
        }
        
        // Проверка консистентности результатов
        const firstResult = results[0];
        for (const result of results) {
            expect(result.severity).toBe(firstResult.severity);
            expect(result.type).toBe(firstResult.type);
            expect(result.title).toBe(firstResult.title);
        }
    });
});

// Вспомогательные функции для тестов
function createMockThreat(type, severity, title) {
    return {
        id: `mock-${type.toLowerCase()}-${Date.now()}`,
        type: type,
        severity: severity,
        title: title,
        description: `Mock ${type} threat for testing`,
        confidence: Math.random(),
        timestamp: new Date().toISOString(),
        event: {
            context: {
                ip: `192.168.1.${Math.floor(Math.random() * 254) + 1}`,
                user: `user${Math.floor(Math.random() * 1000)}`,
                userAgent: 'Mozilla/5.0 (test)'
            }
        }
    };
}

function createMockAlert(options = {}) {
    return {
        id: options.id || `alert-${Date.now()}`,
        type: options.type || 'TEST_ALERT',
        severity: options.severity || 'MEDIUM',
        title: options.title || 'Test Alert',
        description: options.description || 'Test alert for validation',
        timestamp: options.timestamp || new Date().toISOString(),
        source: options.source || 'test-system',
        context: options.context || {},
        confidence: options.confidence || 0.7,
        status: options.status || 'OPEN',
        ...options
    };
}

// Запуск всех тестов
if (require.main === module) {
    // Запуск через Jest или другой тестовый фреймворк
    console.log('Security Alerting System tests ready to run');
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Управление-пакетами]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]
- [[Реагирование-на-инциденты]]