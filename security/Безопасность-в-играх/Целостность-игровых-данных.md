---
aliases: [Целостность игровых данных, Game Data Integrity, Data Integrity in Games]
tags: [security, gaming, data-integrity, game-security]
---

# Целостность игровых данных (Game Data Integrity)

## Обзор

Целостность игровых данных - это критический аспект безопасности веб-игр, обеспечивающий, что данные не были несанкционированно изменены, повреждены или подделаны. В контексте игровых приложений, целостность данных охватывает защиту игрового прогресса, статистики, инвентаря, транзакций и других критических аспектов игрового опыта.

## Определение и значение

Целостность данных в играх означает, что:

- Игровые данные не были изменены без разрешения
- Данные остаются точными и последовательными
- История изменений данных отслеживается
- Подозрительные изменения обнаруживаются и отклоняются

Для веб-игр целостность данных особенно важна из-за:

- Хранения критических данных на клиенте
- Возможности модификации клиентского кода
- Сетевого взаимодействия между клиентом и сервером
- Высокой ценности игровых активов

## Типы игровых данных, требующих защиты

### 1. Профиль игрока

- Уровень и опыт
- Статистика и достижения
- Инвентарь предметов
- Виртуальная валюта

```javascript
// Пример: Структура профиля игрока с защитой целостности
class PlayerProfile {
  constructor(playerId) {
    this.playerId = playerId;
    this.level = 1;
    this.experience = 0;
    this.coins = 0;
    this.inventory = [];
    this.achievements = [];
    
    // Контрольные суммы для проверки целостности
    this.checksums = {};
    this.signatures = {};
    this.version = 1;
  }
  
  // Вычисление контрольной суммы для данных
  calculateChecksum(data) {
    const jsonString = JSON.stringify(data);
    let hash = 0;
    
    for (let i = 0; i < jsonString.length; i++) {
      const char = jsonString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Преобразование в 32-битное целое
    }
    
    return hash.toString();
  }
  
  // Подпись данных для подтверждения подлинности
  async signData(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    
    // В реальности использовать криптографическую подпись
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  // Обновление данных с сохранением целостности
  async updateProfile(updates) {
    const oldData = { ...this };
    
    // Применение обновлений
    Object.assign(this, updates);
    
    // Вычисление новых контрольных сумм
    this.checksums.profile = this.calculateChecksum({
      level: this.level,
      experience: this.experience,
      coins: this.coins
    });
    
    // Создание подписи для подтверждения подлинности изменений
    this.signatures.lastUpdate = await this.signData({
      playerId: this.playerId,
      updates,
      timestamp: Date.now()
    });
    
    this.version++;
  }
  
  // Проверка целостности данных
  validateIntegrity() {
    const currentChecksum = this.calculateChecksum({
      level: this.level,
      experience: this.experience,
      coins: this.coins
    });
    
    if (currentChecksum !== this.checksums.profile) {
      throw new Error('Нарушение целостности профиля игрока');
    }
    
    return true;
  }
}
```

### 2. Игровое состояние

- Позиции объектов
- Состояния игры
- Временные данные
- Результаты сессий

```javascript
// Пример: Защита игрового состояния
class GameState {
  constructor() {
    this.entities = new Map();
    this.sessionId = crypto.randomUUID();
    this.timestamp = Date.now();
    this.turn = 0;
    this.hashes = new Map();
    this.signatures = new Map();
  }
  
  // Добавление сущности с проверкой целостности
  addEntity(id, entity) {
    // Вычисление хэша сущности
    const entityHash = this.calculateEntityHash(entity);
    this.hashes.set(id, entityHash);
    
    // Подпись сущности
    this.signEntity(id, entity);
    
    this.entities.set(id, entity);
  }
  
  // Обновление сущности с проверкой целостности
  updateEntity(id, updates) {
    const entity = this.entities.get(id);
    if (!entity) {
      throw new Error(`Сущность ${id} не найдена`);
    }
    
    // Проверка целостности перед обновлением
    const currentHash = this.calculateEntityHash(entity);
    const expectedHash = this.hashes.get(id);
    
    if (currentHash !== expectedHash) {
      throw new Error(`Нарушение целостности сущности ${id}`);
    }
    
    // Применение обновлений
    Object.assign(entity, updates);
    
    // Обновление хэша
    const newHash = this.calculateEntityHash(entity);
    this.hashes.set(id, newHash);
    
    // Обновление подписи
    this.signEntity(id, entity);
  }
  
  calculateEntityHash(entity) {
    const sortedKeys = Object.keys(entity).sort();
    const sortedEntity = {};
    sortedKeys.forEach(key => {
      sortedEntity[key] = entity[key];
    });
    
    const jsonString = JSON.stringify(sortedEntity);
    return btoa(jsonString).substring(0, 16);
  }
  
  signEntity(id, entity) {
    const dataToSign = {
      id,
      entity,
      timestamp: Date.now(),
      sessionId: this.sessionId
    };
    
    // В реальности использовать криптографическую подпись
    this.signatures.set(id, this.calculateEntityHash(dataToSign));
  }
  
  // Проверка целостности всех сущностей
  validateIntegrity() {
    for (const [id, entity] of this.entities) {
      const currentHash = this.calculateEntityHash(entity);
      const expectedHash = this.hashes.get(id);
      
      if (currentHash !== expectedHash) {
        throw new Error(`Нарушение целостности сущности ${id}`);
      }
    }
    
    return true;
  }
}
```

### 3. Игровая экономика

- Транзакции
- Балансы
- Обменные курсы
- История покупок

```javascript
// Пример: Защита игровой экономики
class GameEconomy {
  constructor() {
    this.transactions = [];
    this.balances = new Map();
    this.transactionLog = [];
    this.blockchain = []; // Упрощенная реализация
  }
  
  // Создание защищенной транзакции
  async createTransaction(from, to, amount, type) {
    const transaction = {
      id: crypto.randomUUID(),
      from,
      to,
      amount,
      type,
      timestamp: Date.now(),
      previousHash: this.blockchain.length > 0 ? this.blockchain[this.blockchain.length - 1].hash : null
    };
    
    // Подпись транзакции
    transaction.signature = await this.signTransaction(transaction);
    
    // Вычисление хэша транзакции
    transaction.hash = await this.calculateTransactionHash(transaction);
    
    // Проверка баланса отправителя
    if (!this.hasSufficientFunds(from, amount)) {
      throw new Error('Недостаточно средств для транзакции');
    }
    
    // Добавление в блокчейн
    this.blockchain.push(transaction);
    
    // Обновление балансов
    this.updateBalances(transaction);
    
    // Логирование транзакции
    this.logTransaction(transaction);
    
    return transaction;
  }
  
  async signTransaction(transaction) {
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify({
      from: transaction.from,
      to: transaction.to,
      amount: transaction.amount,
      timestamp: transaction.timestamp
    }));
    
    const hash = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hash))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  async calculateTransactionHash(transaction) {
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(transaction));
    const hash = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hash))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  hasSufficientFunds(playerId, amount) {
    const balance = this.balances.get(playerId) || 0;
    return balance >= amount;
  }
  
  updateBalances(transaction) {
    const fromBalance = this.balances.get(transaction.from) || 0;
    const toBalance = this.balances.get(transaction.to) || 0;
    
    this.balances.set(transaction.from, fromBalance - transaction.amount);
    this.balances.set(transaction.to, toBalance + transaction.amount);
  }
  
  logTransaction(transaction) {
    this.transactionLog.push({
      ...transaction,
      loggedAt: Date.now()
    });
  }
  
  // Проверка целостности блокчейна
  validateBlockchain() {
    for (let i = 1; i < this.blockchain.length; i++) {
      const current = this.blockchain[i];
      const previous = this.blockchain[i - 1];
      
      // Проверка связи между блоками
      if (current.previousHash !== previous.hash) {
        throw new Error(`Нарушение целостности блокчейна на блоке ${i}`);
      }
      
      // Проверка хэша текущего блока
      const recalculatedHash = this.calculateTransactionHashSync(current);
      if (recalculatedHash !== current.hash) {
        throw new Error(`Неверный хэш блока ${i}`);
      }
    }
    
    return true;
  }
  
  calculateTransactionHashSync(transaction) {
    // Синхронная версия для проверки
    const jsonString = JSON.stringify(transaction);
    let hash = 0;
    
    for (let i = 0; i < jsonString.length; i++) {
      const char = jsonString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    
    return hash.toString();
  }
}
```

## Методы обеспечения целостности данных

### 1. Криптографические хэши

Использование криптографических хэшей для проверки целостности:

```javascript
// Пример: Система криптографических хэшей
class CryptoIntegrity {
  constructor() {
    this.hashAlgorithms = ['SHA-256', 'SHA-384', 'SHA-512'];
    this.hashCache = new Map();
  }
  
  async calculateHash(data, algorithm = 'SHA-256') {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    
    const hashBuffer = await crypto.subtle.digest(algorithm, dataBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  // Создание защищенного контейнера данных
  async createSecureContainer(data) {
    const hash = await this.calculateHash(data);
    
    return {
      data,
      hash,
      algorithm: 'SHA-256',
      timestamp: Date.now()
    };
  }
  
  // Проверка целостности защищенного контейнера
  async verifyContainer(container) {
    const recalculatedHash = await this.calculateHash(container.data, container.algorithm);
    return recalculatedHash === container.hash;
  }
  
  // Множественные хэши для дополнительной защиты
  async calculateMultipleHashes(data) {
    const hashes = {};
    
    for (const algorithm of this.hashAlgorithms) {
      hashes[algorithm] = await this.calculateHash(data, algorithm);
    }
    
    return hashes;
  }
}
```

### 2. Цифровые подписи

Использование цифровых подписей для подтверждения подлинности:

```javascript
// Пример: Система цифровых подписей
class DigitalSignatures {
  constructor() {
    this.keys = new Map();
  }
  
  async generateKeyPair() {
    const keyPair = await crypto.subtle.generateKey(
      {
        name: 'RSASSA-PKCS1-v1_5',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      true,
      ['sign', 'verify']
    );
    
    return keyPair;
  }
  
  async signData(data, privateKey) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    
    const signature = await crypto.subtle.sign(
      'RSASSA-PKCS1-v1_5',
      privateKey,
      dataBuffer
    );
    
    return Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  async verifySignature(data, signature, publicKey) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const signatureBuffer = new Uint8Array(
      signature.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
    );
    
    return await crypto.subtle.verify(
      'RSASSA-PKCS1-v1_5',
      publicKey,
      signatureBuffer,
      dataBuffer
    );
  }
  
  // Подпись игровых данных
  async signGameData(gameData, playerId) {
    let keyPair = this.keys.get(playerId);
    if (!keyPair) {
      keyPair = await this.generateKeyPair();
      this.keys.set(playerId, keyPair);
    }
    
    const signature = await this.signData(gameData, keyPair.privateKey);
    
    return {
      data: gameData,
      signature,
      publicKey: await this.exportPublicKey(keyPair.publicKey)
    };
  }
  
  async exportPublicKey(publicKey) {
    const exported = await crypto.subtle.exportKey('jwk', publicKey);
    return exported;
  }
  
  // Проверка подписи игровых данных
  async verifyGameData(signedData) {
    const publicKey = await crypto.subtle.importKey(
      'jwk',
      signedData.publicKey,
      { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
      true,
      ['verify']
    );
    
    return await this.verifySignature(
      signedData.data,
      signedData.signature,
      publicKey
    );
  }
}
```

### 3. Blockchain-подобные структуры

Использование цепочек блоков для обеспечения неизменяемости:

```javascript
// Пример: Игровой блокчейн
class GameBlockchain {
  constructor() {
    this.chain = [];
    this.difficulty = 4; // Количество нулей в начале хэша
  }
  
  // Создание начального блока
  createGenesisBlock() {
    return {
      index: 0,
      timestamp: Date.now(),
      data: 'Genesis Block',
      previousHash: '0',
      hash: this.calculateHash({
        index: 0,
        timestamp: Date.now(),
        data: 'Genesis Block',
        previousHash: '0'
      }),
      nonce: 0
    };
  }
  
  // Вычисление хэша блока
  calculateHash(block) {
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify({
      index: block.index,
      timestamp: block.timestamp,
      data: block.data,
      previousHash: block.previousHash,
      nonce: block.nonce
    }));
    
    return crypto.subtle.digest('SHA-256', data).then(hash => {
      return Array.from(new Uint8Array(hash))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    });
  }
  
  // Добавление нового блока
  async addBlock(data) {
    const previousBlock = this.chain[this.chain.length - 1];
    const newBlock = {
      index: this.chain.length,
      timestamp: Date.now(),
      data,
      previousHash: previousBlock.hash,
      nonce: 0
    };
    
    // Майнинг блока (для простоты - поиск хэша с определенным количеством нулей)
    newBlock.hash = await this.mineBlock(newBlock);
    this.chain.push(newBlock);
    
    return newBlock;
  }
  
  // Майнинг блока (proof of work)
  async mineBlock(block) {
    let hash;
    let nonce = 0;
    
    do {
      block.nonce = nonce;
      hash = await this.calculateHash(block);
      nonce++;
    } while (!hash.startsWith('0'.repeat(this.difficulty)));
    
    return hash;
  }
  
  // Проверка целостности цепочки
  isValidChain() {
    for (let i = 1; i < this.chain.length; i++) {
      const currentBlock = this.chain[i];
      const previousBlock = this.chain[i - 1];
      
      // Проверка хэша
      const recalculatedHash = this.calculateHashSync(currentBlock);
      if (recalculatedHash !== currentBlock.hash) {
        return false;
      }
      
      // Проверка связи с предыдущим блоком
      if (currentBlock.previousHash !== previousBlock.hash) {
        return false;
      }
    }
    
    return true;
  }
  
  calculateHashSync(block) {
    // Синхронная версия для проверки
    const data = JSON.stringify({
      index: block.index,
      timestamp: block.timestamp,
      data: block.data,
      previousHash: block.previousHash,
      nonce: block.nonce
    });
    
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    
    return hash.toString();
  }
  
  // Получение данных из блокчейна
  getData(filter) {
    return this.chain
      .filter(block => filter(block.data))
      .map(block => block.data);
  }
}
```

## Защита данных в хранилище браузера

### 1. Зашифрованное хранилище

```javascript
// Пример: Защищенное хранилище данных
class SecureStorage {
  constructor() {
    this.encryptionKey = null;
    this.ivLength = 12; // Для AES-GCM
  }
  
  async initializeEncryption(playerId) {
    // Создание ключа на основе playerId
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(playerId),
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );
    
    this.encryptionKey = await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode('fixed-salt-for-demo'),
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  async encrypt(data) {
    if (!this.encryptionKey) {
      throw new Error('Шифрование не инициализировано');
    }
    
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));
    
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: iv },
      this.encryptionKey,
      dataBuffer
    );
    
    // Комбинирование IV и зашифрованных данных
    const resultBuffer = new Uint8Array(iv.length + encrypted.byteLength);
    resultBuffer.set(iv, 0);
    resultBuffer.set(new Uint8Array(encrypted), iv.length);
    
    return btoa(String.fromCharCode(...resultBuffer));
  }
  
  async decrypt(encryptedData) {
    if (!this.encryptionKey) {
      throw new Error('Шифрование не инициализировано');
    }
    
    const dataBuffer = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
    const iv = dataBuffer.slice(0, this.ivLength);
    const encrypted = dataBuffer.slice(this.ivLength);
    
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: iv },
      this.encryptionKey,
      encrypted
    );
    
    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  }
  
  // Защищенное сохранение в localStorage
  async secureSetItem(key, value, playerId) {
    if (!this.encryptionKey) {
      await this.initializeEncryption(playerId);
    }
    
    const encryptedValue = await this.encrypt(value);
    const checksum = await this.calculateChecksum(value);
    
    localStorage.setItem(`${key}_encrypted`, encryptedValue);
    localStorage.setItem(`${key}_checksum`, checksum);
  }
  
  // Защищенное получение из localStorage
  async secureGetItem(key, playerId) {
    if (!this.encryptionKey) {
      await this.initializeEncryption(playerId);
    }
    
    const encryptedValue = localStorage.getItem(`${key}_encrypted`);
    const storedChecksum = localStorage.getItem(`${key}_checksum`);
    
    if (!encryptedValue || !storedChecksum) {
      return null;
    }
    
    const decryptedValue = await this.decrypt(encryptedValue);
    const calculatedChecksum = await this.calculateChecksum(decryptedValue);
    
    if (calculatedChecksum !== storedChecksum) {
      console.error('Нарушение целостности данных!');
      this.reportIntegrityViolation(key);
      return null;
    }
    
    return decryptedValue;
  }
  
  async calculateChecksum(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(JSON.stringify(data));
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
  
  reportIntegrityViolation(key) {
    console.warn(`Нарушение целостности данных для ключа: ${key}`);
    // Отправка в систему безопасности
  }
}
```

### 2. Защита IndexedDB

```javascript
// Пример: Защита данных в IndexedDB
class SecureIndexedDB {
  constructor() {
    this.dbName = 'SecureGameDB';
    this.version = 1;
    this.encryptionEnabled = true;
  }
  
  async initialize(playerId) {
    this.storage = new SecureStorage();
    await this.storage.initializeEncryption(playerId);
  }
  
  async storeSecureData(storeName, key, data) {
    const encryptedData = await this.storage.encrypt(data);
    const checksum = await this.storage.calculateChecksum(data);
    
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    await store.put({
      key,
      encryptedData,
      checksum,
      timestamp: Date.now()
    });
  }
  
  async retrieveSecureData(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    
    const record = await store.get(key);
    if (!record) return null;
    
    const calculatedChecksum = await this.storage.calculateChecksum(
      await this.storage.decrypt(record.encryptedData)
    );
    
    if (calculatedChecksum !== record.checksum) {
      this.reportIntegrityViolation(storeName, key);
      return null;
    }
    
    return await this.storage.decrypt(record.encryptedData);
  }
  
  reportIntegrityViolation(storeName, key) {
    console.warn(`Нарушение целостности в IndexedDB: ${storeName}/${key}`);
  }
}
```

## Мониторинг и аудит целостности

### 1. Система аудита

```javascript
// Пример: Система аудита целостности данных
class IntegrityAudit {
  constructor() {
    this.auditLog = [];
    this.checkpoints = new Map();
    this.integrityViolations = [];
  }
  
  // Создание контрольной точки целостности
  createCheckpoint(name, data) {
    const checkpoint = {
      name,
      timestamp: Date.now(),
      hash: this.calculateDataHash(data),
      dataPreview: this.getPreview(data)
    };
    
    this.checkpoints.set(name, checkpoint);
    this.logAudit('checkpoint-created', checkpoint);
  }
  
  // Проверка контрольной точки
  verifyCheckpoint(name, currentData) {
    const checkpoint = this.checkpoints.get(name);
    if (!checkpoint) {
      throw new Error(`Контрольная точка ${name} не найдена`);
    }
    
    const currentHash = this.calculateDataHash(currentData);
    const isValid = currentHash === checkpoint.hash;
    
    const verification = {
      checkpoint: name,
      timestamp: Date.now(),
      expectedHash: checkpoint.hash,
      actualHash: currentHash,
      isValid,
      dataPreview: this.getPreview(currentData)
    };
    
    this.logAudit('checkpoint-verified', verification);
    
    if (!isValid) {
      this.recordIntegrityViolation(verification);
    }
    
    return isValid;
  }
  
  calculateDataHash(data) {
    const jsonString = JSON.stringify(data, Object.keys(data).sort());
    let hash = 0;
    
    for (let i = 0; i < jsonString.length; i++) {
      const char = jsonString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    
    return hash.toString();
  }
  
  getPreview(data) {
    // Получение краткого представления данных для логирования
    if (typeof data === 'object') {
      return Object.keys(data).slice(0, 5).reduce((obj, key) => {
        obj[key] = typeof data[key] === 'object' ? '[object]' : data[key];
        return obj;
      }, {});
    }
    return typeof data === 'string' && data.length > 50 ? 
      data.substring(0, 50) + '...' : data;
  }
  
  logAudit(action, details) {
    this.auditLog.push({
      action,
      details,
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    });
    
    // Ограничение размера лога
    if (this.auditLog.length > 10000) {
      this.auditLog = this.auditLog.slice(-5000); // Сохраняем последние 5000 записей
    }
  }
  
  recordIntegrityViolation(violation) {
    this.integrityViolations.push({
      ...violation,
      severity: this.assessViolationSeverity(violation),
      timestamp: Date.now()
    });
    
    console.error('Нарушение целостности данных:', violation);
  }
  
  assessViolationSeverity(violation) {
    // Оценка серьезности нарушения
    if (violation.checkpoint.includes('critical')) {
      return 'high';
    } else if (violation.checkpoint.includes('user')) {
      return 'medium';
    }
    return 'low';
  }
  
  getAuditReport() {
    return {
      totalAudits: this.auditLog.length,
      integrityViolations: this.integrityViolations.length,
      checkpoints: Array.from(this.checkpoints.keys()),
      recentViolations: this.integrityViolations.slice(-10),
      complianceRate: this.calculateComplianceRate()
    };
  }
  
  calculateComplianceRate() {
    if (this.auditLog.length === 0) return 100;
    
    const verificationLogs = this.auditLog.filter(log => 
      log.action === 'checkpoint-verified'
    );
    
    if (verificationLogs.length === 0) return 100;
    
    const validVerifications = verificationLogs.filter(log => 
      log.details.isValid
    ).length;
    
    return (validVerifications / verificationLogs.length) * 100;
  }
}
```

## Практические рекомендации

### 1. Многоуровневая защита

```javascript
// Пример: Комплексная система защиты целостности
class ComprehensiveIntegrityProtection {
  constructor() {
    this.layers = {
      encryption: new SecureStorage(),
      hashing: new CryptoIntegrity(),
      signatures: new DigitalSignatures(),
      blockchain: new GameBlockchain(),
      audit: new IntegrityAudit()
    };
  }
  
  async protectGameData(playerId, gameData) {
    // Шифрование данных
    const encryptedData = await this.layers.encryption.encrypt(gameData);
    
    // Вычисление хэша
    const dataHash = await this.layers.hashing.calculateHash(gameData);
    
    // Подпись данных
    const signedData = await this.layers.signatures.signGameData(gameData, playerId);
    
    // Добавление в блокчейн
    const blockchainEntry = await this.layers.blockchain.addBlock({
      playerId,
      dataHash,
      timestamp: Date.now()
    });
    
    // Создание контрольной точки
    this.layers.audit.createCheckpoint(`player_${playerId}`, gameData);
    
    return {
      encryptedData,
      dataHash,
      signature: signedData.signature,
      blockchainRef: blockchainEntry.hash,
      timestamp: Date.now()
    };
  }
  
  async verifyGameData(playerId, protectedData, originalData) {
    const results = {
      encryption: true, // Проверка шифрования требует знания ключа
      hashing: false,
      signatures: false,
      blockchain: false,
      audit: false
    };
    
    // Проверка хэша
    try {
      const calculatedHash = await this.layers.hashing.calculateHash(originalData);
      results.hashing = calculatedHash === protectedData.dataHash;
    } catch (e) {
      console.error('Ошибка проверки хэша:', e);
    }
    
    // Проверка подписи
    try {
      results.signatures = await this.layers.signatures.verifyGameData({
        data: originalData,
        signature: protectedData.signature,
        publicKey: await this.layers.signatures.exportPublicKey(
          await this.layers.signatures.generateKeyPair()
        )
      });
    } catch (e) {
      console.error('Ошибка проверки подписи:', e);
    }
    
    // Проверка контрольной точки
    try {
      results.audit = this.layers.audit.verifyCheckpoint(`player_${playerId}`, originalData);
    } catch (e) {
      console.error('Ошибка проверки аудита:', e);
    }
    
    return results;
  }
}
```

### 2. Регулярные проверки

- Периодическая проверка целостности критических данных
- Сравнение клиентских и серверных данных
- Мониторинг подозрительных изменений

### 3. Обработка нарушений

- Логирование инцидентов
- Автоматическое восстановление данных
- Уведомление администраторов
- Блокировка подозрительных действий

## Заключение

Целостность игровых данных является критическим компонентом безопасности веб-игр. Эффективная защита целостности требует:

- Использования криптографических методов
- Многоуровневой защиты
- Постоянного мониторинга
- Быстрого реагирования на нарушения

Реализация надежной системы защиты целостности данных обеспечивает честную игровую среду и защищает ценность игровых активов как для игроков, так и для разработчиков.

> [!tip] Совет
> Всегда проверяйте целостность критических данных на сервере, даже если они защищены на клиенте.

> [!warning] Важно
> Нарушение целостности данных может привести к серьезным последствиям для игровой экономики.

> [!note] Примечание
> Защита целостности должна быть частью комплексного подхода к безопасности игры.