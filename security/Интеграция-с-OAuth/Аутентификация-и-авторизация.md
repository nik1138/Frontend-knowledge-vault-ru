---
aliases: ["Аутентификация и авторизация WebSocket", "WebSocket Auth", "WebSocket Authentication"]
tags: [security, websocket, authentication, authorization]
created: 2025-11-18
updated: 2025-11-18
---

# Аутентификация и авторизация

Аутентификация и авторизация в WebSocket соединениях - это критические аспекты безопасности, обеспечивающие, что только проверенные пользователи могут установить соединение и выполнять разрешенные действия в рамках этого соединения.

## Введение

В отличие от HTTP, где аутентификация может выполняться для каждого запроса через заголовки Authorization, WebSocket соединение устанавливается один раз, и все последующие сообщения передаются в рамках этого соединения. Это создает уникальные вызовы для обеспечения безопасности.

## Особенности аутентификации WebSocket

### Отличия от HTTP

- **Однократная аутентикация**: проверка подлинности происходит при установлении соединения
- **Длительное соединение**: проверка действительности токенов должна выполняться регулярно
- **Отсутствие автоматической аутентикации**: WebSocket не предоставляет встроенных механизмов аутентификации
- **Постоянный доступ**: после установления соединения пользователь может отправлять сообщения без дополнительной проверки

### Типы аутентификации

#### Токен-базированная аутентификация

Наиболее распространенный подход:

```javascript
// Клиент
const token = localStorage.getItem('authToken');
const ws = new WebSocket(`wss://example.com/socket?token=${encodeURIComponent(token)}`);

// Сервер
wss.on('upgrade', (req, socket, head) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const token = url.searchParams.get('token');
  
  if (!isValidToken(token)) {
    socket.destroy();
    return;
  }
  
  // Продолжение установления соединения
  wss.handleUpgrade(req, socket, head, (ws) => {
    wss.emit('connection', ws, req);
  });
});
```

#### Сессионная аутентификация

Использование cookie-файлов:

```javascript
// Клиент (требует предварительной аутентификации через HTTP)
// Cookie автоматически отправляются с WebSocket запросом
const ws = new WebSocket('wss://example.com/socket');

// Сервер
wss.on('connection', (ws, req) => {
  // Извлечение сессии из cookie
  const cookies = parseCookies(req.headers.cookie || '');
  const sessionId = cookies.sessionId;
  
  if (!isValidSession(sessionId)) {
    ws.close(1008, 'Invalid session');
    return;
  }
  
  // Продолжение обработки соединения
});
```

#### Сертификатная аутентификация

Использование клиентских SSL-сертификатов:

```javascript
// Сервер с клиентской аутентификацией
const fs = require('fs');
const https = require('https');
const WebSocket = require('ws');

const server = https.createServer({
  cert: fs.readFileSync('server-cert.pem'),
  key: fs.readFileSync('server-key.pem'),
  ca: [fs.readFileSync('ca-cert.pem')],
  requestCert: true,  // Требовать клиентский сертификат
  rejectUnauthorized: false  // Не отклонять автоматически
});

const wss = new WebSocket.Server({ server });

wss.on('connection', (ws, req) => {
  const cert = req.client.getPeerCertificate();
  
  if (!cert || req.client.authorized !== true) {
    ws.close(1008, 'Client certificate required');
    return;
  }
  
  // Проверка сертификата
  if (!isValidClientCert(cert)) {
    ws.close(1008, 'Invalid client certificate');
    return;
  }
  
  // Продолжение обработки соединения
});
```

## Архитектура аутентификации

### Процесс аутентификации

```
[Клиент] --> [Запрос аутентификации] --> [Сервер аутентификации]
[Сервер аутентификации] --> [Проверка учетных данных] --> [Выдача токена]
[Клиент] --> [Установление WebSocket с токеном] --> [Сервер WebSocket]
[Сервер WebSocket] --> [Проверка токена] --> [Разрешение/Запрет соединения]
```

### Структура безопасного соединения

```javascript
class SecureWebSocketServer {
  constructor() {
    this.connections = new Map(); // userId -> Set<WebSocket>
    this.tokens = new Map();      // token -> userId
    this.tokenExpiry = new Map(); // token -> expiryTime
  }
  
  async authenticateConnection(req) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const token = url.searchParams.get('token');
    
    if (!token) {
      return { authenticated: false, reason: 'Token required' };
    }
    
    // Проверка токена
    const tokenData = await this.validateToken(token);
    if (!tokenData) {
      return { authenticated: false, reason: 'Invalid token' };
    }
    
    // Проверка срока действия
    if (Date.now() > tokenData.expiry) {
      return { authenticated: false, reason: 'Token expired' };
    }
    
    return { 
      authenticated: true, 
      userId: tokenData.userId,
      token: token 
    };
  }
  
  async validateToken(token) {
    // Проверка токена в базе данных или через JWT
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return {
        userId: decoded.userId,
        expiry: decoded.exp * 1000
      };
    } catch (error) {
      return null;
    }
  }
  
  handleConnection(ws, req) {
    this.authenticateConnection(req).then(authResult => {
      if (!authResult.authenticated) {
        ws.close(1008, authResult.reason);
        return;
      }
      
      // Сохранение соединения
      ws.userId = authResult.userId;
      if (!this.connections.has(ws.userId)) {
        this.connections.set(ws.userId, new Set());
      }
      this.connections.get(ws.userId).add(ws);
      
      // Установка обработчиков
      this.setupConnectionHandlers(ws);
    });
  }
  
  setupConnectionHandlers(ws) {
    ws.on('message', (message) => {
      this.handleMessage(ws, message);
    });
    
    ws.on('close', () => {
      if (this.connections.has(ws.userId)) {
        this.connections.get(ws.userId).delete(ws);
        if (this.connections.get(ws.userId).size === 0) {
          this.connections.delete(ws.userId);
        }
      }
    });
  }
  
  handleMessage(ws, message) {
    // Проверка сообщения с учетом прав пользователя
    try {
      const parsed = JSON.parse(message);
      
      // Проверка прав на выполнение действия
      if (!this.hasPermission(ws.userId, parsed.action)) {
        ws.close(1008, 'Insufficient permissions');
        return;
      }
      
      // Обработка сообщения
      this.processMessage(ws, parsed);
    } catch (error) {
      ws.close(1003, 'Invalid message format');
    }
  }
  
  hasPermission(userId, action) {
    // Проверка прав доступа пользователя к действию
    // Реализация зависит от системы управления доступом
    return true; // Заглушка
  }
  
  processMessage(ws, message) {
    // Обработка валидного сообщения
    console.log(`Processing message from user ${ws.userId}:`, message);
  }
}
```

## Авторизация в WebSocket

### Проверка прав доступа

```javascript
class WebSocketAuthorization {
  constructor() {
    this.userPermissions = new Map();
    this.channelAccess = new Map(); // channelId -> Set<userId>
  }
  
  async checkChannelAccess(userId, channelId) {
    // Проверка, имеет ли пользователь доступ к каналу
    if (!this.channelAccess.has(channelId)) {
      return false;
    }
    
    return this.channelAccess.get(channelId).has(userId);
  }
  
  async checkActionPermission(userId, action) {
    // Проверка прав на выполнение действия
    const userPermissions = await this.getUserPermissions(userId);
    return userPermissions.includes(action);
  }
  
  async getUserPermissions(userId) {
    // Получение прав доступа пользователя
    // Может быть реализовано через [[Методы-контроля-доступа]]
    if (!this.userPermissions.has(userId)) {
      // Загрузка прав из базы данных
      const permissions = await this.loadUserPermissionsFromDB(userId);
      this.userPermissions.set(userId, permissions);
    }
    
    return this.userPermissions.get(userId);
  }
  
  async loadUserPermissionsFromDB(userId) {
    // Загрузка прав из базы данных
    // Реализация зависит от используемой системы управления доступом
    // Может использовать [[Ролевая модель]] или [[Атрибутное-управление-доступом]]
    return ['read', 'write']; // Заглушка
  }
}
```

### Ролевая модель в WebSocket

```javascript
// Пример реализации ролевой модели
const ROLE_PERMISSIONS = {
  'admin': ['read', 'write', 'delete', 'manage_users'],
  'moderator': ['read', 'write', 'delete'],
  'user': ['read', 'write'],
  'guest': ['read']
};

class RoleBasedAuthorization {
  constructor() {
    this.userRoles = new Map(); // userId -> roles array
  }
  
  async getUserRoles(userId) {
    if (!this.userRoles.has(userId)) {
      const roles = await this.loadUserRolesFromDB(userId);
      this.userRoles.set(userId, roles);
    }
    return this.userRoles.get(userId);
  }
  
  async hasPermission(userId, action) {
    const userRoles = await this.getUserRoles(userId);
    
    for (const role of userRoles) {
      if (ROLE_PERMISSIONS[role] && ROLE_PERMISSIONS[role].includes(action)) {
        return true;
      }
    }
    
    return false;
  }
  
  async loadUserRolesFromDB(userId) {
    // Загрузка ролей из базы данных
    // Реализация зависит от архитектуры приложения
    return ['user']; // Заглушка
  }
}
```

## Практические примеры

### JWT-аутентификация с автоматической проверкой

```javascript
const jwt = require('jsonwebtoken');

class JWTWebSocketAuth {
  constructor(secret) {
    this.secret = secret;
    this.connectionTokens = new Map(); // ws -> token
  }
  
  async authenticate(req) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const token = url.searchParams.get('token');
    
    if (!token) {
      return { success: false, reason: 'Token required' };
    }
    
    try {
      const decoded = jwt.verify(token, this.secret);
      
      // Проверка дополнительных полей
      if (!decoded.userId || !decoded.type || decoded.type !== 'websocket') {
        return { success: false, reason: 'Invalid token type' };
      }
      
      return { 
        success: true, 
        userId: decoded.userId,
        token: token,
        expiry: decoded.exp * 1000
      };
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        return { success: false, reason: 'Token expired' };
      }
      return { success: false, reason: 'Invalid token' };
    }
  }
  
  setupConnection(ws, authResult) {
    ws.userId = authResult.userId;
    this.connectionTokens.set(ws, authResult.token);
    
    // Установка таймера для проверки срока действия
    this.scheduleTokenExpiryCheck(ws, authResult.expiry);
    
    ws.on('message', (message) => {
      this.handleMessage(ws, message);
    });
  }
  
  scheduleTokenExpiryCheck(ws, expiryTime) {
    const timeUntilExpiry = expiryTime - Date.now();
    
    if (timeUntilExpiry > 0) {
      setTimeout(() => {
        // Проверка, все ли еще токен действителен
        const currentToken = this.connectionTokens.get(ws);
        if (currentToken) {
          try {
            jwt.verify(currentToken, this.secret);
          } catch (error) {
            // Токен истек или недействителен
            ws.close(1008, 'Token expired');
            this.connectionTokens.delete(ws);
            return;
          }
          
          // Продление проверки
          this.scheduleTokenExpiryCheck(ws, expiryTime);
        }
      }, timeUntilExpiry);
    } else {
      // Токен уже истек
      ws.close(1008, 'Token expired');
      this.connectionTokens.delete(ws);
    }
  }
  
  handleMessage(ws, message) {
    try {
      const parsed = JSON.parse(message);
      
      // Проверка прав на выполнение действия
      if (!this.hasPermission(ws.userId, parsed.action)) {
        ws.send(JSON.stringify({
          type: 'error',
          message: 'Insufficient permissions'
        }));
        return;
      }
      
      // Обработка сообщения
      this.processMessage(ws, parsed);
    } catch (error) {
      ws.close(1003, 'Invalid message format');
    }
  }
  
  hasPermission(userId, action) {
    // Проверка прав доступа
    // Реализация зависит от системы управления доступом
    return true; // Заглушка
  }
  
  processMessage(ws, message) {
    // Обработка валидного сообщения
    console.log(`Processing message from user ${ws.userId}:`, message);
  }
}
```

### Многоуровневая аутентификация

```javascript
class MultiFactorWebSocketAuth {
  constructor() {
    this.primaryAuth = new JWTWebSocketAuth(process.env.JWT_SECRET);
    this.secondaryAuth = new TokenBasedAuth(process.env.SECONDARY_SECRET);
    this.sessionStore = new SessionStore();
  }
  
  async authenticate(req) {
    // Основная аутентификация
    const primaryResult = await this.primaryAuth.authenticate(req);
    if (!primaryResult.success) {
      return primaryResult;
    }
    
    // Проверка второго фактора (если требуется)
    const userId = primaryResult.userId;
    const session = await this.sessionStore.getSession(userId);
    
    if (session.requires2FA && !this.hasValid2FAToken(req)) {
      return { 
        success: false, 
        reason: '2FA token required',
        requires2FA: true 
      };
    }
    
    return primaryResult;
  }
  
  hasValid2FAToken(req) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const twoFAToken = url.searchParams.get('2fa_token');
    
    // Проверка 2FA токена
    // Реализация зависит от используемой системы 2FA
    return true; // Заглушка
  }
}
```

## Безопасность аутентификации

### Защита от атак

#### Защита от подбора токенов

```javascript
const rateLimiter = new Map(); // IP -> { attempts: number, lastAttempt: Date }

function checkRateLimit(ip) {
  const now = new Date();
  const record = rateLimiter.get(ip) || { attempts: 0, lastAttempt: now };
  
  // Сброс счетчика каждые 15 минут
  if (now - record.lastAttempt > 15 * 60 * 1000) {
    record.attempts = 0;
    record.lastAttempt = now;
  }
  
  record.attempts++;
  rateLimiter.set(ip, record);
  
  if (record.attempts > 5) { // 5 попыток за 15 минут
    return false; // Слишком много попыток
  }
  
  return true;
}

wss.on('upgrade', (req, socket, head) => {
  const clientIP = req.socket.remoteAddress;
  
  if (!checkRateLimit(clientIP)) {
    socket.destroy();
    return;
  }
  
  // Продолжение процесса аутентификации
});
```

#### Защита от повторного использования токенов

```javascript
class TokenReplayProtection {
  constructor() {
    this.usedTokens = new Set();
    this.cleanupInterval = setInterval(() => {
      this.usedTokens.clear(); // Очистка каждые 24 часа
    }, 24 * 60 * 60 * 1000);
  }
  
  async authenticateWithReplayProtection(req) {
    const authResult = await this.authenticate(req);
    
    if (!authResult.success) {
      return authResult;
    }
    
    // Проверка, использовался ли токен ранее
    if (this.usedTokens.has(authResult.token)) {
      return { success: false, reason: 'Token already used' };
    }
    
    // Пометка токена как использованного
    this.usedTokens.add(authResult.token);
    
    return authResult;
  }
}
```

## Интеграция с системами безопасности

### [[Потоки-авторизации]]

Интеграция с OAuth 2.0 системами:

```javascript
class OAuthWebSocketAuth {
  constructor(oauthClient) {
    this.oauthClient = oauthClient;
  }
  
  async authenticate(req) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const accessToken = url.searchParams.get('access_token');
    
    if (!accessToken) {
      return { success: false, reason: 'Access token required' };
    }
    
    try {
      // Проверка токена через OAuth сервер
      const tokenInfo = await this.oauthClient.introspect(accessToken);
      
      if (!tokenInfo.active) {
        return { success: false, reason: 'Token inactive' };
      }
      
      return {
        success: true,
        userId: tokenInfo.user_id,
        scopes: tokenInfo.scope?.split(' ') || []
      };
    } catch (error) {
      return { success: false, reason: 'Token validation failed' };
    }
  }
}
```

### [[Сигнализация-безопасности]]

Интеграция с системами мониторинга:

```javascript
class MonitoredWebSocketAuth {
  constructor(securitySystem) {
    this.securitySystem = securitySystem;
  }
  
  async authenticate(req) {
    const result = await this.performAuthentication(req);
    
    // Логирование попытки аутентификации
    this.securitySystem.logAuthAttempt({
      ip: req.socket.remoteAddress,
      userAgent: req.headers['user-agent'],
      success: result.success,
      reason: result.reason
    });
    
    if (!result.success) {
      // Проверка на подозрительную активность
      if (this.securitySystem.isSuspiciousActivity(req.socket.remoteAddress)) {
        this.securitySystem.sendAlert('suspicious_auth_attempt', {
          ip: req.socket.remoteAddress,
          attempts: this.securitySystem.getRecentAttempts(req.socket.remoteAddress)
        });
      }
    }
    
    return result;
  }
  
  async performAuthentication(req) {
    // Реализация аутентификации
    // Возвращает объект с результатом аутентификации
  }
}
```

## Лучшие практики

### Токены безопасности

- Использование JWT с коротким сроком действия
- Регулярная проверка валидности токенов
- [[Управление-ключами]] для токенов
- Обновление токенов без разрыва соединения

### Мониторинг и аудит

- [[Анализ-логов]] аутентификационных событий
- [[Сигнализация-безопасности]] для аномальных попыток
- Регулярные проверки активных сессий
- [[Инструменты-мониторинга-безопасности]]

### Архитектурные решения

- Разделение аутентификации и авторизации
- Использование промежуточных серверов аутентификации
- [[Управление-доступом]] через централизованные системы
- [[Проверка-сообщений]] на соответствие правам доступа

> [!tip] Совет
> Используйте токены с коротким сроком действия и механизм обновления токенов для обеспечения безопасности долгоживущих WebSocket соединений.

> [!warning] Важно
> Проверяйте права доступа для каждого сообщения, особенно для чувствительных операций, даже после установления соединения.

## Заключение

Аутентификация и авторизация в WebSocket соединениях требуют особого внимания к безопасности из-за их долгоживущей природы. Правильная реализация обеспечивает защиту от несанкционированного доступа и позволяет контролировать действия пользователей в реальном времени.