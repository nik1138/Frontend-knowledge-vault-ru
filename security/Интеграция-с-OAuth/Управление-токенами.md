---
aliases: ["Управление OAuth токенами", "Токены безопасности"]
tags: ["security", "oauth", "tokens", "authentication"]
---

# Управление токенами

Управление токенами - это критический аспект безопасности веб-приложений, особенно при использовании OAuth и других систем аутентификации. Правильное управление токенами включает их безопасное хранение, обновление, инвалидацию и защиту от несанкционированного доступа.

## Основы токенов

Токены аутентификации используются для подтверждения личности пользователя и предоставления доступа к защищенным ресурсам. Существуют различные типы токенов:

- **Access Token** - предоставляет доступ к API и ресурсам
- **Refresh Token** - используется для получения новых access токенов
- **ID Token** - содержит информацию о пользователе (в OpenID Connect)

> [!warning] Важно
> Токены должны рассматриваться как чувствительные данные и защищаться соответствующим образом.

## Безопасное хранение токенов

### Хранение в браузере

```javascript
// Класс для безопасного хранения токенов в браузере
class SecureTokenStorage {
    constructor() {
        this.encryptionKey = null;
        this.storagePrefix = 'secure_token_';
    }

    async initialize() {
        this.encryptionKey = await this.getOrCreateEncryptionKey();
    }

    async getOrCreateEncryptionKey() {
        // Попытка получить существующий ключ из sessionStorage
        const storedKey = sessionStorage.getItem('token_encryption_key');
        
        if (storedKey) {
            try {
                const jwk = JSON.parse(storedKey);
                return await window.crypto.subtle.importKey(
                    'jwk',
                    jwk,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            } catch (error) {
                console.error('Ошибка загрузки ключа шифрования:', error);
            }
        }

        // Создание нового ключа
        const key = await window.crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );

        // Сохранение ключа
        const exportedKey = await window.crypto.subtle.exportKey('jwk', key);
        sessionStorage.setItem('token_encryption_key', JSON.stringify(exportedKey));

        return key;
    }

    async storeToken(tokenType, tokenData) {
        if (!this.encryptionKey) {
            await this.initialize();
        }

        // Добавление метаданных к токену
        const tokenWithMetadata = {
            ...tokenData,
            type: tokenType,
            createdAt: Date.now(),
            expiresAt: tokenData.expires_in ? 
                Date.now() + (tokenData.expires_in * 1000) : null
        };

        // Шифрование токена
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encoder = new TextEncoder();
        const data = encoder.encode(JSON.stringify(tokenWithMetadata));

        const encrypted = await window.crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            this.encryptionKey,
            data
        );

        // Сохранение зашифрованного токена
        const encryptedToken = {
            encrypted: Array.from(new Uint8Array(encrypted)),
            iv: Array.from(iv),
            timestamp: Date.now()
        };

        sessionStorage.setItem(
            `${this.storagePrefix}${tokenType}`, 
            JSON.stringify(encryptedToken)
        );
    }

    async getToken(tokenType) {
        const storedData = sessionStorage.getItem(`${this.storagePrefix}${tokenType}`);
        
        if (!storedData) {
            return null;
        }

        try {
            const encryptedToken = JSON.parse(storedData);
            
            if (!this.encryptionKey) {
                await this.initialize();
            }

            // Расшифровка токена
            const iv = new Uint8Array(encryptedToken.iv);
            const encrypted = new Uint8Array(encryptedToken.encrypted);

            const decrypted = await window.crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                this.encryptionKey,
                encrypted
            );

            const decoder = new TextDecoder();
            const tokenData = JSON.parse(decoder.decode(decrypted));

            // Проверка срока действия
            if (tokenData.expiresAt && tokenData.expiresAt < Date.now()) {
                await this.clearToken(tokenType);
                return null;
            }

            return tokenData;
        } catch (error) {
            console.error('Ошибка при получении токена:', error);
            await this.clearToken(tokenType);
            return null;
        }
    }

    async clearToken(tokenType) {
        sessionStorage.removeItem(`${this.storagePrefix}${tokenType}`);
    }

    async clearAllTokens() {
        // Удаление всех токенов
        for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key && key.startsWith(this.storagePrefix)) {
                sessionStorage.removeItem(key);
            }
        }
        
        // Удаление ключа шифрования
        sessionStorage.removeItem('token_encryption_key');
    }
}
```

### Использование HttpOnly cookies для серверных приложений

```javascript
// Пример серверного кода для установки HttpOnly cookie с токеном
const express = require('express');
const jwt = require('jsonwebtoken');
const app = express();

// Установка токена в HttpOnly cookie
app.post('/login', async (req, res) => {
    try {
        // Аутентификация пользователя (реализация зависит от вашей системы)
        const user = await authenticateUser(req.body);
        
        if (!user) {
            return res.status(401).json({ error: 'Неверные учетные данные' });
        }

        // Создание токенов
        const accessToken = jwt.sign(
            { userId: user.id, role: user.role },
            process.env.JWT_SECRET,
            { expiresIn: '15m' }
        );

        const refreshToken = jwt.sign(
            { userId: user.id },
            process.env.REFRESH_TOKEN_SECRET,
            { expiresIn: '7d' }
        );

        // Сохранение refresh токена в базе данных
        await saveRefreshToken(user.id, refreshToken);

        // Установка HttpOnly cookie
        res.cookie('access_token', accessToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production', // Только по HTTPS в продакшене
            sameSite: 'strict', // Защита от CSRF
            maxAge: 15 * 60 * 1000 // 15 минут
        });

        res.cookie('refresh_token', refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 дней
        });

        res.json({ success: true, userId: user.id });
    } catch (error) {
        console.error('Ошибка при входе:', error);
        res.status(500).json({ error: 'Внутренняя ошибка сервера' });
    }
});

// Middleware для проверки токена
app.use('/api/*', async (req, res, next) => {
    const token = req.cookies.access_token;
    
    if (!token) {
        return res.status(401).json({ error: 'Токен отсутствует' });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        // Если access токен истек, попробуем обновить его
        if (error.name === 'TokenExpiredError') {
            const refreshToken = req.cookies.refresh_token;
            
            if (refreshToken) {
                try {
                    const refreshDecoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
                    const user = await findUserById(refreshDecoded.userId);
                    
                    if (user && await isValidRefreshToken(user.id, refreshToken)) {
                        // Создание нового access токена
                        const newAccessToken = jwt.sign(
                            { userId: user.id, role: user.role },
                            process.env.JWT_SECRET,
                            { expiresIn: '15m' }
                        );

                        // Установка нового токена
                        res.cookie('access_token', newAccessToken, {
                            httpOnly: true,
                            secure: process.env.NODE_ENV === 'production',
                            sameSite: 'strict',
                            maxAge: 15 * 60 * 1000
                        });

                        req.user = jwt.decode(newAccessToken);
                        return next();
                    }
                } catch (refreshError) {
                    // Refresh токен тоже недействителен
                }
            }
        }
        
        res.clearCookie('access_token');
        res.clearCookie('refresh_token');
        return res.status(401).json({ error: 'Токен недействителен' });
    }
});
```

## Обновление токенов

### Автоматическое обновление токенов

```javascript
// Класс для автоматического обновления токенов
class TokenRefresher {
    constructor(config) {
        this.config = config;
        this.tokenStorage = new SecureTokenStorage();
        this.isRefreshing = false;
        this.failedQueue = [];
    }

    async getValidToken() {
        // Получение текущего токена
        const tokenData = await this.tokenStorage.getToken('access');
        
        if (!tokenData) {
            throw new Error('Токен отсутствует');
        }

        // Проверка, нужно ли обновлять токен
        const now = Date.now();
        const refreshThreshold = 5 * 60 * 1000; // Обновлять за 5 минут до истечения
        const shouldRefresh = tokenData.expiresAt && 
                             (tokenData.expiresAt - now) < refreshThreshold;

        if (shouldRefresh) {
            return await this.refreshToken();
        }

        return tokenData.access_token;
    }

    async refreshToken() {
        if (this.isRefreshing) {
            // Если уже идет обновление, ждем завершения
            return new Promise((resolve, reject) => {
                this.failedQueue.push({ resolve, reject });
            });
        }

        this.isRefreshing = true;

        try {
            // Получение refresh токена
            const refreshTokenData = await this.tokenStorage.getToken('refresh');
            
            if (!refreshTokenData || !refreshTokenData.refresh_token) {
                throw new Error('Refresh токен отсутствует');
            }

            // Вызов API для обновления токена
            const response = await fetch(this.config.tokenEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    grant_type: 'refresh_token',
                    client_id: this.config.clientId,
                    refresh_token: refreshTokenData.refresh_token
                })
            });

            if (!response.ok) {
                throw new Error(`Ошибка обновления токена: ${response.status}`);
            }

            const newTokenData = await response.json();
            
            // Обновление времени истечения
            newTokenData.expires_at = Math.floor(Date.now() / 1000) + newTokenData.expires_in;
            
            // Сохранение новых токенов
            await this.tokenStorage.storeToken('access', {
                access_token: newTokenData.access_token,
                expires_in: newTokenData.expires_in,
                expires_at: newTokenData.expires_at
            });

            if (newTokenData.refresh_token) {
                await this.tokenStorage.storeToken('refresh', {
                    refresh_token: newTokenData.refresh_token
                });
            }

            // Оповещение ожидающих запросов
            this.processQueue(null, newTokenData.access_token);

            return newTokenData.access_token;
        } catch (error) {
            console.error('Ошибка обновления токена:', error);
            
            // Очистка токенов при ошибке
            await this.tokenStorage.clearAllTokens();
            
            // Оповещение ожидающих запросов об ошибке
            this.processQueue(error, null);
            
            throw error;
        } finally {
            this.isRefreshing = false;
        }
    }

    processQueue(error, token) {
        this.failedQueue.forEach(promise => {
            if (error) {
                promise.reject(error);
            } else {
                promise.resolve(token);
            }
        });
        
        this.failedQueue = [];
    }

    async scheduleTokenRefresh() {
        // Запланировать автоматическое обновление токена
        const tokenData = await this.tokenStorage.getToken('access');
        
        if (tokenData && tokenData.expiresAt) {
            const refreshTime = tokenData.expiresAt - 
                               (5 * 60 * 1000) - // 5 минут до истечения
                               Date.now();
            
            if (refreshTime > 0) {
                setTimeout(() => {
                    this.refreshToken().catch(error => {
                        console.error('Ошибка автоматического обновления токена:', error);
                    });
                }, refreshTime);
            }
        }
    }
}
```

## Безопасность токенов

### Проверка токенов

```javascript
// Класс для проверки токенов
class TokenValidator {
    constructor(config) {
        this.config = config;
        this.jwksCache = new Map();
    }

    async validateAccessToken(token) {
        try {
            // Разбор JWT токена
            const tokenParts = token.split('.');
            if (tokenParts.length !== 3) {
                throw new Error('Невалидный JWT токен');
            }

            const header = JSON.parse(atob(tokenParts[0]));
            const payload = JSON.parse(atob(tokenParts[1]));

            // Проверка времени действия
            const now = Math.floor(Date.now() / 1000);
            
            if (payload.exp && payload.exp < now) {
                throw new Error('Токен истек');
            }
            
            if (payload.nbf && payload.nbf > now) {
                throw new Error('Токен еще не действителен');
            }

            // Проверка аудитории
            if (payload.aud && this.config.expectedAudience) {
                if (typeof payload.aud === 'string') {
                    if (payload.aud !== this.config.expectedAudience) {
                        throw new Error('Неверная аудитория токена');
                    }
                } else if (Array.isArray(payload.aud)) {
                    if (!payload.aud.includes(this.config.expectedAudience)) {
                        throw new Error('Неверная аудитория токена');
                    }
                }
            }

            // Проверка издателя
            if (payload.iss && this.config.expectedIssuer && payload.iss !== this.config.expectedIssuer) {
                throw new Error('Неверный издатель токена');
            }

            // Проверка подписи (реализация зависит от используемой библиотеки)
            const isValid = await this.verifySignature(token, header.kid);
            
            if (!isValid) {
                throw new Error('Невалидная подпись токена');
            }

            return {
                valid: true,
                payload: payload,
                header: header
            };
        } catch (error) {
            console.error('Ошибка валидации токена:', error);
            return {
                valid: false,
                error: error.message
            };
        }
    }

    async verifySignature(token, kid) {
        // Получение ключа из JWKS
        const key = await this.getKey(kid);
        if (!key) {
            throw new Error('Ключ не найден для проверки подписи');
        }

        // В реальных приложениях используйте специализированную библиотеку
        // Ниже упрощенная реализация
        return true; // Заглушка
    }

    async getKey(kid) {
        if (this.jwksCache.has(kid)) {
            return this.jwksCache.get(kid);
        }

        try {
            const response = await fetch(this.config.jwksEndpoint);
            const jwks = await response.json();

            const key = jwks.keys.find(k => k.kid === kid);
            if (key) {
                this.jwksCache.set(kid, key);
                return key;
            }
        } catch (error) {
            console.error('Ошибка получения JWKS:', error);
        }

        return null;
    }

    // Проверка токена перед выполнением запроса
    async validateAndRefreshToken() {
        const token = await this.tokenStorage.getToken('access');
        
        if (!token) {
            throw new Error('Токен отсутствует');
        }

        // Проверка валидности токена
        const validation = await this.validateAccessToken(token.access_token);
        
        if (!validation.valid) {
            // Если токен невалиден, пытаемся обновить
            try {
                await this.tokenRefresher.refreshToken();
                return true;
            } catch (refreshError) {
                console.error('Ошибка обновления токена:', refreshError);
                throw new Error('Токен недействителен и не может быть обновлен');
            }
        }

        return true;
    }
}
```

## Инвалидация токенов

### Управление инвалидацией токенов

```javascript
// Класс для управления инвалидацией токенов
class TokenInvalidator {
    constructor(apiClient) {
        this.apiClient = apiClient;
    }

    // Инвалидация токена на стороне клиента
    async invalidateLocalTokens() {
        const tokenStorage = new SecureTokenStorage();
        await tokenStorage.clearAllTokens();
    }

    // Инвалидация токена на стороне сервера
    async invalidateServerToken(token, tokenType = 'access') {
        try {
            const response = await fetch('/api/revoke-token', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    token: token,
                    token_type_hint: tokenType
                })
            });

            if (!response.ok) {
                console.error('Ошибка инвалидации токена на сервере:', response.status);
            }
        } catch (error) {
            console.error('Ошибка при инвалидации токена:', error);
        }
    }

    // Полная инвалидация сессии пользователя
    async invalidateUserSession(userId) {
        try {
            // Инвалидация всех токенов пользователя на сервере
            const response = await fetch(`/api/users/${userId}/revoke-all-tokens`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                console.error('Ошибка инвалидации всех токенов пользователя:', response.status);
            }

            // Очистка локальных токенов
            await this.invalidateLocalTokens();
        } catch (error) {
            console.error('Ошибка при инвалидации сессии пользователя:', error);
        }
    }

    // Обработка истечения срока действия токена
    async handleTokenExpiration() {
        // Инвалидация локальных токенов
        await this.invalidateLocalTokens();
        
        // Перенаправление на страницу входа
        window.location.href = '/login?expired=true';
    }
}
```

## Мониторинг и аудит токенов

### Логирование использования токенов

```javascript
// Класс для аудита токенов
class TokenAuditLogger {
    static logTokenUsage(tokenType, action, userId = null, additionalData = {}) {
        const auditEntry = {
            event: 'token_usage',
            type: tokenType,
            action: action,
            userId: userId,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            ip: 'ANONYMIZED',
            ...additionalData
        };

        // Отправка в систему аудита (реализация зависит от инфраструктуры)
        this.sendAuditLog(auditEntry);
    }

    static logTokenCreation(tokenType, userId, expiresAt) {
        this.logTokenUsage(tokenType, 'created', userId, { expiresAt });
    }

    static logTokenRefresh(tokenType, userId) {
        this.logTokenUsage(tokenType, 'refreshed', userId);
    }

    static logTokenInvalidation(tokenType, userId, reason) {
        this.logTokenUsage(tokenType, 'invalidated', userId, { reason });
    }

    static async detectAnomalousActivity() {
        // Проверка на подозрительную активность с токенами
        const recentActivities = await this.getRecentTokenActivities();
        
        for (const activity of recentActivities) {
            if (this.isSuspiciousActivity(activity)) {
                this.logSecurityEvent('suspicious_token_activity', activity);
            }
        }
    }

    static isSuspiciousActivity(activity) {
        // Проверка на подозрительную активность
        const suspiciousPatterns = [
            multipleTokensFromSameUser(activity),
            tokenUsageFromDifferentLocations(activity),
            unusualTimePatterns(activity)
        ];

        return suspiciousPatterns.some(pattern => pattern);
    }

    static sendAuditLog(entry) {
        // Отправка лога в систему аудита
        // В реальном приложении это может быть вызов API или отправка в систему логирования
        console.log('Token audit log:', entry);
    }

    static async getRecentTokenActivities() {
        // Получение недавних активностей с токенами
        // Реализация зависит от используемой системы логирования
        return [];
    }

    static logSecurityEvent(eventType, details) {
        const securityLog = {
            event: eventType,
            details,
            timestamp: new Date().toISOString(),
            type: 'security'
        };

        // Отправка в систему безопасности
        console.log('Security event:', securityLog);
    }
}

function multipleTokensFromSameUser(activity) {
    // Проверка на множественные токены от одного пользователя за короткий промежуток времени
    return false; // Реализация зависит от требований
}

function tokenUsageFromDifferentLocations(activity) {
    // Проверка использования токена из разных географических локаций
    return false; // Реализация зависит от требований
}

function unusualTimePatterns(activity) {
    // Проверка необычных паттернов времени использования
    return false; // Реализация зависит от требований
}
```

## Рекомендации по безопасности

- [[Лучшие-практики-безопасности-OAuth]] - лучшие практики безопасности OAuth
- [[Реализация-OAuth]] - реализация OAuth
- [[OAuth-потоки]] - различные OAuth потоки
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[CSRF-защита]] - защита от подделки межсайтовых запросов

## Заключение

Управление токенами требует комплексного подхода, включающего безопасное хранение, своевременное обновление, надежную инвалидацию и мониторинг использования. Ключевые принципы включают минимальное время жизни токенов, использование шифрования, защиту от различных атак и регулярный аудит использования токенов.