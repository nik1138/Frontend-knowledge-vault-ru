---
aliases: ["Payment Processing Security", "Secure Payment Handling"]
tags: [security, payment-security, processing-security, secure-transactions]
---

# Безопасность-обработки-платежей

## Введение

Безопасность обработки платежей - это комплекс мер, направленных на защиту процесса обработки платежных данных от несанкционированного доступа, утечки и мошенничества. Обработка платежей включает в себя ввод, передачу, хранение и обработку чувствительных финансовых данных.

## Архитектура безопасной обработки платежей

### Разделение ответственности

В современных веб-приложениях безопасная обработка платежей требует четкого разделения ответственности между различными компонентами системы:

- **Клиентская сторона (фронтенд)**: сбор данных карты, валидация, передача данных
- **Серверная сторона (бэкенд)**: обработка транзакций, интеграция с платежными провайдерами
- **Платежные провайдеры**: обработка и верификация транзакций
- **Базы данных**: хранение токенизированных данных

### Модель взаимодействия

```
[Клиент] -> [Форма оплаты] -> [Платежный провайдер] -> [Банк]
```

## Безопасность на фронтенде

### Валидация данных

Валидация на клиентской стороне - это первый уровень защиты, который помогает:

- Предотвратить ввод некорректных данных
- Снизить нагрузку на сервер
- Улучшить пользовательский опыт

```javascript
class PaymentValidator {
    static validateCardInput(cardData) {
        const errors = [];
        
        // Проверка номера карты
        if (!this.isValidCardNumber(cardData.number)) {
            errors.push('Неверный номер карты');
        }
        
        // Проверка срока действия
        if (!this.isValidExpiryDate(cardData.expiryMonth, cardData.expiryYear)) {
            errors.push('Неверный срок действия карты');
        }
        
        // Проверка CVV
        if (!this.isValidCVV(cardData.cvv, this.getCardType(cardData.number))) {
            errors.push('Неверный код CVV');
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }
    
    static isValidCardNumber(cardNumber) {
        // Удалить все нецифровые символы
        const cleanNumber = cardNumber.replace(/\D/g, '');
        
        // Проверить длину
        if (cleanNumber.length < 13 || cleanNumber.length > 19) {
            return false;
        }
        
        // Проверить по алгоритму Луна
        return this.luhnCheck(cleanNumber);
    }
    
    static luhnCheck(cardNumber) {
        let sum = 0;
        let isEven = false;
        
        for (let i = cardNumber.length - 1; i >= 0; i--) {
            let digit = parseInt(cardNumber.charAt(i));
            
            if (isEven) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            
            sum += digit;
            isEven = !isEven;
        }
        
        return (sum % 10) === 0;
    }
    
    static isValidExpiryDate(month, year) {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();
        
        const fullYear = year.length === 2 ? 2000 + parseInt(year) : parseInt(year);
        
        if (fullYear > currentYear) {
            return true;
        } else if (fullYear === currentYear) {
            return parseInt(month) >= currentMonth;
        }
        
        return false;
    }
    
    static isValidCVV(cvv, cardType) {
        const cvvLength = {
            visa: 3,
            mastercard: 3,
            amex: 4,
            discover: 3
        };
        
        const expectedLength = cvvLength[cardType.toLowerCase()] || 3;
        return cvv.length === expectedLength && /^\d+$/.test(cvv);
    }
    
    static getCardType(cardNumber) {
        const cleanNumber = cardNumber.replace(/\D/g, '');
        
        if (/^4/.test(cleanNumber)) return 'visa';
        if (/^5[1-5]/.test(cleanNumber)) return 'mastercard';
        if (/^3[47]/.test(cleanNumber)) return 'amex';
        if (/^6(?:011|5)/.test(cleanNumber)) return 'discover';
        
        return 'unknown';
    }
}
```

### Защита от XSS

Защита от межсайтового скриптинга критически важна при обработке платежных данных:

```javascript
// Пример безопасного отображения информации о карте
function displayCardInfo(cardNumber, cardholderName) {
    // Не использовать innerHTML с пользовательскими данными
    const maskedNumber = maskCardNumber(cardNumber);
    
    const cardElement = document.createElement('div');
    cardElement.className = 'card-info';
    
    const numberElement = document.createElement('span');
    numberElement.textContent = maskedNumber; // Используем textContent, а не innerHTML
    
    const nameElement = document.createElement('span');
    nameElement.textContent = sanitizeInput(cardholderName);
    
    cardElement.appendChild(numberElement);
    cardElement.appendChild(nameElement);
    
    return cardElement;
}

function maskCardNumber(cardNumber) {
    const cleanNumber = cardNumber.replace(/\D/g, '');
    if (cleanNumber.length < 8) {
        return 'Некорректный номер';
    }
    
    const first4 = cleanNumber.substring(0, 4);
    const last4 = cleanNumber.substring(cleanNumber.length - 4);
    const masked = '*'.repeat(cleanNumber.length - 8);
    
    return `${first4}${masked}${last4}`;
}

function sanitizeInput(input) {
    // Очистка ввода от потенциально опасных символов
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
}
```

### Безопасная передача данных

```javascript
// Пример безопасной отправки данных платежа
class PaymentProcessor {
    constructor(apiEndpoint, publicKey) {
        this.apiEndpoint = apiEndpoint;
        this.publicKey = publicKey;
    }
    
    async processPayment(paymentData) {
        // Валидация данных на клиентской стороне
        const validation = PaymentValidator.validateCardInput(paymentData);
        if (!validation.isValid) {
            throw new Error(`Некорректные данные карты: ${validation.errors.join(', ')}`);
        }
        
        // Токенизация данных перед отправкой
        const tokenizedData = await this.tokenizePaymentData(paymentData);
        
        // Отправка данных на сервер
        const response = await fetch(`${this.apiEndpoint}/process-payment`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                'X-CSRF-Token': this.getCSRFToken()
            },
            body: JSON.stringify({
                paymentToken: tokenizedData.token,
                amount: paymentData.amount,
                currency: paymentData.currency
            })
        });
        
        if (!response.ok) {
            throw new Error(`Ошибка обработки платежа: ${response.statusText}`);
        }
        
        return await response.json();
    }
    
    async tokenizePaymentData(paymentData) {
        // Отправка данных карты напрямую платежному провайдеру
        // для получения токена (без прохождения через наш сервер)
        const response = await fetch('https://payment-provider.com/tokenize', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.publicKey}`
            },
            body: JSON.stringify({
                card_number: paymentData.number,
                expiry_month: paymentData.expiryMonth,
                expiry_year: paymentData.expiryYear,
                cvv: paymentData.cvv
            })
        });
        
        if (!response.ok) {
            throw new Error('Не удалось токенизировать данные карты');
        }
        
        return await response.json();
    }
    
    getCSRFToken() {
        return document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    }
}
```

## Безопасность на бэкенде

### Обработка платежных токенов

```javascript
// Пример серверной обработки платежа
const express = require('express');
const stripe = require('stripe')('sk_test_...'); // Секретный ключ Stripe
const app = express();

app.use(express.json());

app.post('/process-payment', async (req, res) => {
    try {
        // Проверка CSRF токена
        if (!validateCSRFToken(req.headers['x-csrf-token'], req.session)) {
            return res.status(403).json({ error: 'Неверный CSRF токен' });
        }
        
        const { paymentToken, amount, currency } = req.body;
        
        // Проверка параметров платежа
        if (!paymentToken || !amount || !currency) {
            return res.status(400).json({ error: 'Отсутствуют обязательные параметры' });
        }
        
        // Валидация суммы платежа
        if (amount <= 0 || amount > 1000000) { // Максимум 1,000,000 единиц валюты
            return res.status(400).json({ error: 'Неверная сумма платежа' });
        }
        
        // Создание платежа через платежный провайдер
        const paymentIntent = await stripe.paymentIntents.create({
            amount: amount * 100, // Stripe использует минимальные единицы (например, центы)
            currency: currency,
            payment_method: paymentToken,
            confirm: true
        });
        
        // Логирование успешного платежа (без чувствительных данных)
        logPaymentSuccess(req.user.id, paymentIntent.id, amount, currency);
        
        res.json({
            success: true,
            paymentId: paymentIntent.id,
            status: paymentIntent.status
        });
        
    } catch (error) {
        // Логирование ошибки (без чувствительных данных)
        logPaymentError(req.user.id, error.message);
        
        res.status(500).json({
            success: false,
            error: 'Ошибка обработки платежа'
        });
    }
});

function validateCSRFToken(token, session) {
    // Реализация проверки CSRF токена
    return token === session.csrfToken;
}

function logPaymentSuccess(userId, paymentId, amount, currency) {
    // Логирование успешного платежа без чувствительных данных
    console.log(`Payment successful: user=${userId}, payment=${paymentId}, amount=${amount}${currency}`);
}

function logPaymentError(userId, errorMessage) {
    // Логирование ошибки платежа
    console.error(`Payment error: user=${userId}, error=${errorMessage}`);
}
```

### Защита от повторных платежей

```javascript
// Защита от случайных или злонамеренных повторных платежей
class PaymentDuplicateChecker {
    constructor(redisClient) {
        this.redis = redisClient;
    }
    
    async isDuplicatePayment(userId, paymentData) {
        // Хэширование данных платежа для уникальной идентификации
        const paymentHash = this.hashPaymentData(paymentData);
        const key = `payment:${userId}:${paymentHash}`;
        
        // Проверка, был ли уже сделан такой платеж за последние 5 минут
        const existingPayment = await this.redis.get(key);
        if (existingPayment) {
            return true; // Повторный платеж
        }
        
        // Сохранение информации о платеже на 5 минут
        await this.redis.setex(key, 300, 'processed');
        return false; // Не повторный платеж
    }
    
    hashPaymentData(paymentData) {
        // Создание уникального хэша на основе данных платежа
        const crypto = require('crypto');
        const dataString = JSON.stringify({
            amount: paymentData.amount,
            currency: paymentData.currency,
            description: paymentData.description
        });
        
        return crypto.createHash('sha256').update(dataString).digest('hex');
    }
}
```

## Безопасность передачи данных

### Использование HTTPS

```javascript
// Middleware для принудительного использования HTTPS
function requireHTTPS(req, res, next) {
    if (!req.secure && req.get('x-forwarded-proto') !== 'https' && process.env.NODE_ENV === 'production') {
        return res.redirect(`https://${req.get('host')}${req.url}`);
    }
    next();
}

app.use(requireHTTPS);
```

### CORS и безопасность

```javascript
const cors = require('cors');

// Ограничение CORS для платежных эндпоинтов
const paymentCorsOptions = {
    origin: ['https://yourdomain.com', 'https://checkout.yourdomain.com'],
    credentials: true,
    methods: ['POST', 'GET'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-CSRF-Token']
};

app.use('/api/process-payment', cors(paymentCorsOptions));
```

## Защита от мошенничества

### Анализ рисков

```javascript
// Пример системы анализа рисков для платежей
class PaymentRiskAnalyzer {
    constructor() {
        this.rules = [
            this.checkHighAmount,
            this.checkFrequentPayments,
            this.checkGeolocation,
            this.checkNewCard,
            this.checkUnusualPattern
        ];
    }
    
    async analyzeRisk(paymentData, userData) {
        const riskFactors = [];
        
        for (const rule of this.rules) {
            const result = await rule.call(this, paymentData, userData);
            if (result.risk) {
                riskFactors.push(result);
            }
        }
        
        return {
            riskLevel: this.calculateRiskLevel(riskFactors),
            riskFactors,
            shouldBlock: riskFactors.some(factor => factor.severity === 'high')
        };
    }
    
    checkHighAmount(paymentData, userData) {
        // Проверка на подозрительно высокую сумму платежа
        const avgAmount = userData.averagePaymentAmount || 0;
        const threshold = avgAmount * 5; // 5-кратное превышение среднего
        
        if (paymentData.amount > threshold) {
            return {
                risk: true,
                severity: paymentData.amount > threshold * 2 ? 'high' : 'medium',
                reason: `Сумма платежа (${paymentData.amount}) превышает среднюю (${avgAmount}) в 5 раз`
            };
        }
        
        return { risk: false };
    }
    
    checkFrequentPayments(paymentData, userData) {
        // Проверка частых платежей от одного пользователя
        const recentPayments = userData.recentPayments || [];
        const recentCount = recentPayments.filter(
            p => Date.now() - new Date(p.timestamp).getTime() < 5 * 60 * 1000 // 5 минут
        ).length;
        
        if (recentCount > 3) {
            return {
                risk: true,
                severity: 'medium',
                reason: `Обнаружено ${recentCount} платежей за последние 5 минут`
            };
        }
        
        return { risk: false };
    }
    
    checkGeolocation(paymentData, userData) {
        // Проверка необычного географического расположения
        if (userData.lastKnownLocation && paymentData.location) {
            const distance = this.calculateDistance(
                userData.lastKnownLocation,
                paymentData.location
            );
            
            // Если расстояние слишком велико за короткое время
            if (distance > 1000) { // 1000 км
                return {
                    risk: true,
                    severity: 'high',
                    reason: `Обнаружено подозрительное географическое расхождение`
                };
            }
        }
        
        return { risk: false };
    }
    
    calculateRiskLevel(riskFactors) {
        if (riskFactors.some(f => f.severity === 'high')) return 'high';
        if (riskFactors.some(f => f.severity === 'medium')) return 'medium';
        return 'low';
    }
    
    calculateDistance(loc1, loc2) {
        // Простой расчет расстояния между двумя точками (в км)
        const R = 6371; // Радиус Земли в км
        const dLat = this.toRad(loc2.lat - loc1.lat);
        const dLon = this.toRad(loc2.lon - loc1.lon);
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(this.toRad(loc1.lat)) * Math.cos(this.toRad(loc2.lat)) * 
            Math.sin(dLon/2) * Math.sin(dLon/2); 
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        return R * c;
    }
    
    toRad(value) {
        return value * Math.PI / 180;
    }
}
```

## Мониторинг и аудит

### Логирование платежных операций

```javascript
// Система логирования платежных операций
class PaymentLogger {
    constructor(elasticsearchClient) {
        this.es = elasticsearchClient;
    }
    
    async logPaymentAttempt(paymentData, userId, ip, userAgent) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            userId: userId,
            ip: ip,
            userAgent: userAgent,
            amount: paymentData.amount,
            currency: paymentData.currency,
            status: 'attempted',
            source: 'web',
            sessionId: paymentData.sessionId
        };
        
        // Отправка в систему логирования
        await this.es.index({
            index: 'payment-logs',
            body: logEntry
        });
    }
    
    async logPaymentResult(paymentId, status, userId, additionalInfo = {}) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            paymentId: paymentId,
            userId: userId,
            status: status,
            additionalInfo: additionalInfo
        };
        
        await this.es.index({
            index: 'payment-results',
            body: logEntry
        });
    }
}
```

## Лучшие практики

### 1. Использование проверенных платежных провайдеров

- Stripe, PayPal, Square, Braintree и другие
- Эти провайдеры уже соответствуют требованиям PCI DSS
- Снижают область вашей ответственности

### 2. Токенизация данных

- Не передавать номера карт через ваш сервер
- Использовать токены для обработки платежей
- Хранить только токенизированные данные

### 3. Регулярные проверки безопасности

- Сканирование уязвимостей
- Пентестинг
- Аудит кода

### 4. Обновление зависимостей

- Регулярное обновление библиотек обработки платежей
- Мониторинг уязвимостей в зависимостях

## Заключение

Безопасность обработки платежей требует комплексного подхода, включающего как клиентские, так и серверные меры защиты. Важно следовать лучшим практикам, использовать проверенные решения и регулярно обновлять системы безопасности.

> [!warning] Важно
> Обработка платежных данных требует строгого соблюдения стандартов безопасности, таких как PCI DSS. Несоблюдение этих стандартов может привести к серьезным последствиям.

> [!tip] Совет
> Используйте внешние платежные провайдеры для обработки чувствительных данных карт, чтобы минимизировать область вашей ответственности за безопасность.

Связанные темы: [[Защита-данных-карт]], [[Соответствие-PCI-DSS]], [[Безопасность-в-веб-приложениях-с-P2P-коммуникациями]]