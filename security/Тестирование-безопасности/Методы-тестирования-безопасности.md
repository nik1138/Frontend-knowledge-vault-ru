---
aliases: ["Security Testing Methods", "Методы тестирования безопасности", "Тестирование безопасности приложений"]
tags: [security, testing, security-testing, penetration-testing]
---

# Методы тестирования безопасности

## Обзор

Тестирование безопасности - это процесс оценки безопасности приложения, системы или сети с целью выявления уязвимостей, недостатков в конфигурации, слабых мест в архитектуре и других проблем, которые могут быть использованы злоумышленниками. Эффективное тестирование безопасности включает в себя различные методы и подходы, применяемые на разных этапах жизненного цикла разработки.

## Классификация методов тестирования безопасности

### По времени выполнения

#### Тестирование "белого ящика" (White Box Testing)

Тестирование с полным знанием внутренней структуры приложения:

- Известны исходный код, архитектура, конфигурация
- Позволяет выявить уязвимости на уровне кода
- Применяется в процессе разработки

#### Тестирование "черного ящика" (Black Box Testing)

Тестирование без знания внутренней структуры:

- Оценка безопасности только на основе внешнего поведения
- Имитация атак реального злоумышленника
- Применяется в финальной стадии тестирования

#### Тестирование "серого ящика" (Gray Box Testing)

Комбинация двух предыдущих подходов:

- Частичное знание внутренней структуры
- Баланс между глубиной и реалистичностью тестирования
- Эффективен для комплексной оценки безопасности

### По автоматизации

#### Ручное тестирование

- Выполняется специалистом вручную
- Позволяет обнаружить сложные логические уязвимости
- Требует высокой квалификации специалиста

#### Автоматизированное тестирование

- Использование инструментов и скриптов
- Быстрое сканирование большого объема кода
- Может пропустить сложные уязвимости

## Методы тестирования безопасности

### 1. Статический анализ безопасности (SAST)

Анализ исходного кода без запуска приложения:

```javascript
// Пример проверки безопасности с помощью SAST
// .eslintrc.js
module.exports = {
  plugins: ['security'],
  extends: ['plugin:security/recommended'],
  rules: {
    'security/detect-object-injection': 'error',
    'security/detect-non-literal-fs-filename': 'error',
    'security/detect-unsafe-regex': 'error',
    'security/detect-buffer-noassert': 'error',
    'security/detect-child-process': 'error',
    'security/detect-disable-mustache-escape': 'error',
    'security/detect-eval-with-expression': 'error',
    'security/detect-new-buffer': 'error',
    'security/detect-no-csrf-before-method-override': 'error',
    'security/detect-non-literal-regexp': 'error',
    'security/detect-non-literal-require': 'error',
    'security/detect-object-injection': 'error',
    'security/detect-possible-timing-attacks': 'error',
    'security/detect-pseudoRandomBytes': 'error'
  }
};
```

#### Инструменты SAST:
- SonarQube
- Checkmarx
- Fortify SCA
- ESLint с плагинами безопасности

### 2. Динамический анализ безопасности (DAST)

Тестирование работающего приложения:

```bash
# Пример использования OWASP ZAP для DAST
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t https://example.com \
  -g gen.conf \
  -r report.html
```

#### Инструменты DAST:
- OWASP ZAP
- Burp Suite Professional
- Acunetix
- Netsparker

### 3. Интерактивный анализ безопасности (IAST)

Комбинированный подход, анализирующий приложение во время выполнения:

```java
// Пример использования IAST инструмента
// В коде приложения встраиваются агенты для мониторинга
public class SecureController {
    @PostMapping("/user")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        // IAST агент отслеживает поток данных и возможные уязвимости
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
}
```

### 4. Пенетрационное тестирование

Комплексный ручной метод тестирования, имитирующий реальные атаки:

#### Этапы пенетрационного тестирования:

1. **Разведка** (Reconnaissance)
   - Сбор информации о цели
   - Анализ открытых источников
   - Определение атакуемых поверхностей

2. **Сканирование** (Scanning)
   - Сканирование портов и сервисов
   - Определение используемых технологий
   - Поиск известных уязвимостей

3. **Эксплуатация** (Exploitation)
   - Попытка эксплуатации найденных уязвимостей
   - Получение несанкционированного доступа
   - Повышение привилегий

4. **Поддержание доступа** (Maintaining Access)
   - Установка backdoor'ов
   - Создание устойчивых методов доступа

5. **Очистка следов** (Covering Tracks)
   - Удаление следов атаки
   - Восстановление исходного состояния

### 5. Анализ зависимостей

Проверка сторонних библиотек на наличие уязвимостей:

```bash
# npm audit
npm audit
npm audit --audit-level high

# OWASP Dependency Check
dependency-check --project "My App" --scan /path/to/project --out /path/to/report

# Snyk
snyk test
snyk monitor
```

### 6. Тестирование конфигурации безопасности

Проверка настроек серверов, приложений и сервисов:

```bash
# Пример проверки безопасности конфигурации nginx
# nginx.conf
server {
    # Проверка заголовков безопасности
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    
    # Проверка на безопасное использование SSL
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    
    # Проверка на утечку информации
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}
```

## Практические примеры тестирования

### Тестирование аутентификации и авторизации

```javascript
// Тестирование аутентификации
const axios = require('axios');

async function testAuthentication() {
  const baseUrl = 'https://api.example.com';
  
  // Тест 1: Попытка доступа без аутентификации
  try {
    const response = await axios.get(`${baseUrl}/protected-endpoint`);
    console.log('ОШИБКА: Доступ без аутентификации разрешен');
  } catch (error) {
    if (error.response.status === 401) {
      console.log('✓ Аутентификация работает корректно');
    } else {
      console.log('ОШИБКА: Неожиданный статус при доступе без аутентификации');
    }
  }
  
  // Тест 2: Попытка подбора пароля
  const usernames = ['admin', 'user', 'test'];
  const passwords = ['', '123456', 'password'];
  
  for (const username of usernames) {
    for (const password of passwords) {
      try {
        const response = await axios.post(`${baseUrl}/login`, {
          username,
          password
        });
        
        if (response.status === 200) {
          console.log(`ОШИБКА: Успешный вход с небезопасными учетными данными: ${username}/${password}`);
        }
      } catch (error) {
        // Ожидаем ошибку аутентификации
      }
    }
  }
  
  // Тест 3: Проверка ограничения попыток
  const loginAttempts = [];
  for (let i = 0; i < 10; i++) {
    loginAttempts.push(
      axios.post(`${baseUrl}/login`, {
        username: 'nonexistent',
        password: 'wrong'
      }).catch(error => error)
    );
  }
  
  const results = await Promise.all(loginAttempts);
  const successCount = results.filter(r => r.status === 200).length;
  
  if (successCount > 0) {
    console.log('ОШИБКА: Нет ограничения на количество попыток входа');
  } else {
    console.log('✓ Ограничение попыток входа работает');
  }
}

testAuthentication();
```

### Тестирование SQL-инъекций

```javascript
// Тестирование на уязвимости к SQL-инъекциям
async function testSQLInjection() {
  const testInputs = [
    "' OR '1'='1",
    "' OR 1=1--",
    "'; DROP TABLE users; --",
    "admin'--",
    "1' OR '1'='1' --"
  ];
  
  for (const input of testInputs) {
    try {
      // Попытка доступа к конечной точке с потенциально вредоносным вводом
      const response = await axios.get(`https://api.example.com/users?q=${encodeURIComponent(input)}`);
      
      if (response.data.includes('error') || response.status >= 500) {
        console.log(`ВОЗМОЖНАЯ уязвимость к SQL-инъекции: ${input}`);
      }
    } catch (error) {
      // Обработка ошибок
    }
  }
}
```

### Тестирование XSS

```javascript
// Тестирование на уязвимости к XSS
async function testXSS() {
  const xssPayloads = [
    '<script>alert("XSS")</script>',
    '"><script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    'javascript:alert("XSS")',
    '<svg onload=alert("XSS")>'
  ];
  
  for (const payload of xssPayloads) {
    try {
      const response = await axios.post('https://example.com/comment', {
        comment: payload
      });
      
      // Проверяем, содержится ли полезная нагрузка в ответе
      if (response.data.includes(payload.replace(/"/g, '&quot;'))) {
        console.log(`ВОЗМОЖНАЯ уязвимость к XSS: ${payload}`);
      }
    } catch (error) {
      // Обработка ошибок
    }
  }
}
```

## Инструменты для автоматизации тестирования

### OWASP ZAP (Zed Attack Proxy)

```python
# Пример автоматизированного сканирования с помощью OWASP ZAP
import requests
import time

def zap_security_scan(target_url):
    zap_api_url = "http://localhost:8080"
    
    # Сканирование сайта
    requests.get(f"{zap_api_url}/JSON/spider/action/scan/", 
                 params={"url": target_url})
    
    # Ожидание завершения спайдеринга
    while True:
        status = requests.get(f"{zap_api_url}/JSON/spider/view/status/").json()["status"]
        if status == "100":
            break
        time.sleep(5)
    
    # Запуск активного сканирования
    scan_id = requests.get(f"{zap_api_url}/JSON/ascan/action/scan/", 
                          params={"url": target_url}).json()["scan"]
    
    # Ожидание завершения сканирования
    while True:
        status = requests.get(f"{zap_api_url}/JSON/ascan/view/status/", 
                            params={"scanId": scan_id}).json()["status"]
        if status == "100":
            break
        time.sleep(5)
    
    # Получение результатов
    alerts = requests.get(f"{zap_api_url}/JSON/core/view/alerts/", 
                         params={"baseurl": target_url}).json()["alerts"]
    
    return alerts

# Использование
alerts = zap_security_scan("https://example.com")
for alert in alerts:
    print(f"Уязвимость: {alert['alert']}, URL: {alert['url']}")
```

### Burp Suite API

```python
# Пример использования Burp Suite через API
import subprocess
import json

def run_burp_scan(target_url):
    # Запуск Burp через командную строку (требует лицензию)
    cmd = [
        "java", "-jar", "burpsuite.jar",
        "--unpause-spider",
        "--generate-report", "report.html",
        target_url
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.stdout
```

## Создание стратегии тестирования безопасности

### Формирование плана тестирования

```javascript
// Пример плана тестирования безопасности
const securityTestPlan = {
  scope: {
    inScope: [
      'API endpoints',
      'Authentication system',
      'User management',
      'Payment processing',
      'File upload functionality'
    ],
    outOfScope: [
      'Third-party services',
      'External integrations',
      'Development tools'
    ]
  },
  
  methodologies: [
    'SAST - Static code analysis',
    'DAST - Dynamic application security testing',
    'Manual penetration testing',
    'Dependency vulnerability scanning'
  ],
  
  timeline: {
    sastAnalysis: 'Week 1',
    dastScanning: 'Week 2',
    manualTesting: 'Week 3-4',
    reporting: 'Week 5'
  },
  
  successCriteria: {
    criticalVulnerabilities: 0,
    highVulnerabilities: 0,
    mediumVulnerabilities: 5, // допустимое количество
    lowVulnerabilities: 10    // допустимое количество
  },
  
  tools: [
    'SonarQube for SAST',
    'OWASP ZAP for DAST',
    'npm audit for dependency scanning',
    'Manual testing with Burp Suite'
  ]
};
```

### Мониторинг и отчетность

```javascript
// Пример системы отчетности по безопасности
class SecurityTestReporter {
  constructor() {
    this.findings = [];
  }
  
  addFinding(type, severity, location, description, proofOfConcept = '') {
    this.findings.push({
      id: this.generateId(),
      type,
      severity,
      location,
      description,
      proofOfConcept,
      timestamp: new Date().toISOString(),
      status: 'open'
    });
  }
  
  generateId() {
    return 'finding_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  generateReport() {
    const report = {
      summary: {
        totalFindings: this.findings.length,
        bySeverity: this.groupBySeverity(),
        byType: this.groupByType()
      },
      findings: this.findings,
      recommendations: this.generateRecommendations()
    };
    
    return report;
  }
  
  groupBySeverity() {
    return this.findings.reduce((acc, finding) => {
      acc[finding.severity] = (acc[finding.severity] || 0) + 1;
      return acc;
    }, {});
  }
  
  groupByType() {
    return this.findings.reduce((acc, finding) => {
      acc[finding.type] = (acc[finding.type] || 0) + 1;
      return acc;
    }, {});
  }
  
  generateRecommendations() {
    const recommendations = [];
    
    if (this.findings.some(f => f.severity === 'critical')) {
      recommendations.push('Немедленно устранить критические уязвимости');
    }
    
    if (this.findings.some(f => f.type === 'SQL Injection')) {
      recommendations.push('Проверить все SQL-запросы на использование параметризованных запросов');
    }
    
    if (this.findings.some(f => f.type === 'XSS')) {
      recommendations.push('Внедрить контекстно-зависимое кодирование вывода');
    }
    
    return recommendations;
  }
}

// Использование
const reporter = new SecurityTestReporter();
reporter.addFinding('SQL Injection', 'high', '/api/users', 'Параметр id уязвим к SQL-инъекции');
reporter.addFinding('XSS', 'medium', '/profile', 'Вывод имени пользователя не кодируется');
const report = reporter.generateReport();
console.log(JSON.stringify(report, null, 2));
```

## Лучшие практики тестирования безопасности

### 1. Интеграция в CI/CD

```yaml
# .github/workflows/security-test.yml
name: Security Testing
on: [push, pull_request]

jobs:
  security-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm install
      - name: Run SAST
        run: npm run sast-scan
      - name: Run dependency check
        run: npm audit --audit-level moderate
      - name: Run DAST (against test environment)
        run: |
          # Запуск DAST сканирования
          docker run -t owasp/zap2docker-stable zap-baseline.py \
            -t https://test.example.com \
            -g gen.conf \
            -r report.html
```

### 2. Регулярное тестирование

- Планируйте регулярные циклы тестирования
- Тестируйте после каждого значительного изменения
- Используйте автоматизированные сканеры в процессе разработки

### 3. Обучение команды

- Обучайте разработчиков методам безопасного программирования
- Проводите регулярные тренинги по безопасности
- Делитесь результатами тестирования с командой

### 4. Документирование процессов

- Ведите документацию по процессам тестирования
- Создавайте шаблоны отчетов
- Поддерживайте актуальность тест-кейсов

## Заключение

Эффективное тестирование безопасности требует комбинации различных методов и подходов, адаптированных под конкретное приложение и его архитектуру. Регулярное тестирование, автоматизация и интеграция в процесс разработки помогают выявлять и устранять уязвимости на ранних стадиях, снижая риски безопасности для приложения и его пользователей.

## Связанные темы

- [[Автоматизированное-тестирование-безопасности]]
- [[Оценка-уязвимостей]]
- [[Инструменты-аудита-безопасности]]
- [[Руководство-по-безопасному-коду]]
- [[Проверка-ввода]]
- [[Кодирование-вывода]]