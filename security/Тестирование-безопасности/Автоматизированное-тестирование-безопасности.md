---
aliases: ["Automated Security Testing", "Автотесты безопасности", "Автоматическое тестирование безопасности"]
tags: [security, automated-testing, security-testing, ci-cd]
---

# Автоматизированное тестирование безопасности

## Обзор

Автоматизированное тестирование безопасности - это процесс использования инструментов и скриптов для выявления уязвимостей в приложениях, системах и инфраструктуре без участия человека. Автоматизация позволяет быстро и регулярно проверять код, зависимости и конфигурации на наличие известных уязвимостей, что делает её неотъемлемой частью современного процесса разработки программного обеспечения.

## Преимущества автоматизированного тестирования безопасности

### 1. Скорость и эффективность

- Быстрое сканирование больших объемов кода
- Регулярное выполнение тестов без задержек
- Масштабируемость для больших проектов

### 2. Консистентность

- Стандартизированные проверки
- Отсутствие человеческих ошибок
- Повторяемость результатов

### 3. Интеграция с CI/CD

- Раннее обнаружение уязвимостей
- Блокировка опасных изменений
- Автоматическая отчетность

## Типы автоматизированных тестов безопасности

### 1. Статический анализ безопасности (SAST)

Проверка исходного кода без запуска приложения:

```javascript
// Пример настройки ESLint для безопасности
// .eslintrc.js
module.exports = {
  plugins: [
    'security',
    '@typescript-eslint'
  ],
  extends: [
    'eslint:recommended',
    'plugin:security/recommended',
    '@typescript-eslint/recommended'
  ],
  rules: {
    // Правила безопасности
    'security/detect-object-injection': 'error',
    'security/detect-non-literal-fs-filename': 'error',
    'security/detect-unsafe-regex': 'error',
    'security/detect-buffer-noassert': 'error',
    'security/detect-child-process': 'error',
    'security/detect-disable-mustache-escape': 'error',
    'security/detect-eval-with-expression': 'error',
    'security/detect-new-buffer': 'error',
    'security/detect-no-csrf-before-method-override': 'error',
    'security/detect-non-literal-regexp': 'error',
    'security/detect-non-literal-require': 'error',
    'security/detect-possible-timing-attacks': 'error',
    'security/detect-pseudoRandomBytes': 'error',
    
    // Правила TypeScript безопасности
    '@typescript-eslint/no-unsafe-member-access': 'error',
    '@typescript-eslint/no-unsafe-call': 'error',
    '@typescript-eslint/no-unsafe-return': 'error',
    '@typescript-eslint/no-unsafe-assignment': 'error'
  }
};
```

### 2. Анализ зависимостей

Проверка сторонних пакетов на наличие уязвимостей:

```json
// package.json с настройками безопасности
{
  "name": "secure-app",
  "scripts": {
    "security:check": "npm audit --audit-level moderate && snyk test",
    "security:check:deps": "npm audit --audit-level high",
    "security:check:full": "npm audit --audit-level moderate && snyk test && eslint . --ext .js,.ts"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run security:check"
    }
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
```

### 3. Динамическое тестирование (DAST)

Тестирование работающего приложения:

```bash
#!/bin/bash
# automated-dast.sh

# Параметры сканирования
TARGET_URL="${1:-http://localhost:3000}"
ZAP_API_KEY="your-api-key"
REPORT_FILE="dast-report-$(date +%Y%m%d-%H%M%S).html"

echo "Запуск автоматического DAST сканирования для $TARGET_URL"

# Запуск OWASP ZAP в daemon режиме
docker run -u zap -t owasp/zap2docker-stable zap.sh -daemon \
  -host 0.0.0.0 -port 8080 -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true \
  -config api.key=$ZAP_API_KEY &

# Ожидание запуска ZAP
sleep 30

# Выполнение сканирования
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t $TARGET_URL \
  -g gen.conf \
  -r $REPORT_FILE \
  -T 5 \
  -c config.conf

echo "Сканирование завершено. Отчет: $REPORT_FILE"
```

### 4. Инфраструктурное тестирование безопасности (IaC)

Проверка конфигураций инфраструктуры:

```hcl
# Terraform с безопасными настройками
resource "aws_security_group" "secure_sg" {
  name_prefix = "secure-"
  description = "Безопасная группа с минимальными разрешениями"

  # Не открываем все порты
  # ingress {
  #   from_port   = 0
  #   to_port     = 0
  #   protocol    = "-1"
  #   cidr_blocks = ["0.0.0.0/0"]
  # }

  # Открываем только необходимые порты
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "Secure Security Group"
  }
}
```

## Интеграция с CI/CD

### GitHub Actions

```yaml
# .github/workflows/security.yml
name: Security Checks
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  security-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run SAST with ESLint
        run: npx eslint . --ext .js,.ts --max-warnings 0
      
      - name: Run dependency security audit
        run: npm audit --audit-level moderate
      
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run OWASP ZAP baseline scan
        uses: zaproxy/action-baseline@v0.8.0
        with:
          target: 'https://your-app-url.com'
          fail_action: false
```

### GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - test
  - security

variables:
  SECURE_LOG_LEVEL: info

security-sast:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/eslint:latest
  script:
    - /analyzer run
  artifacts:
    reports:
      eslint: gl-security-report.json
  allow_failure: true

dependency_scanning:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/dependency-scanning:latest
  script:
    - dependency-scanning
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json

container_scanning:
  stage: security
  image:
    name: registry.gitlab.com/gitlab-org/security-products/container-scanning:latest
    entrypoint: ['']
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  services:
    - name: docker:20.10.16-dind
      alias: docker
  script:
    - container-scanning
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
```

### Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    tools {
        nodejs "NodeJS-18"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }
        
        stage('Security Scanning') {
            parallel {
                stage('SAST') {
                    steps {
                        sh 'npm run lint:security'
                    }
                }
                
                stage('Dependency Check') {
                    steps {
                        sh 'npm audit --audit-level moderate'
                    }
                }
                
                stage('Snyk Scan') {
                    steps {
                        sh 'snyk test'
                    }
                }
            }
        }
        
        stage('DAST') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Запуск DAST сканирования для продакшена
                    sh './scripts/dast-scan.sh'
                }
            }
        }
    }
    
    post {
        always {
            publishTestResults testResultsPattern: 'test-results.xml'
        }
        success {
            echo 'Безопасность в норме!'
        }
        failure {
            echo 'Обнаружены проблемы безопасности!'
            // Отправка уведомления о проблемах
            sh '''
                curl -X POST -H "Content-Type: application/json" \
                -d "{\"text\":\"Обнаружены проблемы безопасности в ветке ${BRANCH_NAME}\"}" \
                $SLACK_WEBHOOK_URL
            '''
        }
    }
}
```

## Создание собственных автоматизированных тестов

### Тестирование аутентификации

```javascript
// auth-security.test.js
const axios = require('axios');
const { expect } = require('chai');

describe('Тестирование безопасности аутентификации', function() {
  const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
  let authToken = null;

  before(async function() {
    // Получение токена для тестов
    try {
      const response = await axios.post(`${API_BASE_URL}/auth/login`, {
        email: process.env.TEST_USER_EMAIL,
        password: process.env.TEST_USER_PASSWORD
      });
      authToken = response.data.token;
    } catch (error) {
      console.log('Не удалось получить токен для тестов');
    }
  });

  it('должен защищать эндпоинты без токена', async function() {
    try {
      const response = await axios.get(`${API_BASE_URL}/api/protected`);
      expect(response.status).to.equal(401);
    } catch (error) {
      expect(error.response.status).to.equal(401);
    }
  });

  it('должен защищать эндпоинты с невалидным токеном', async function() {
    try {
      const response = await axios.get(`${API_BASE_URL}/api/protected`, {
        headers: { Authorization: 'Bearer invalid-token' }
      });
      expect(response.status).to.equal(401);
    } catch (error) {
      expect(error.response.status).to.equal(401);
    }
  });

  it('должен разрешать доступ с валидным токеном', async function() {
    if (!authToken) {
      this.skip();
    }
    
    const response = await axios.get(`${API_BASE_URL}/api/protected`, {
      headers: { Authorization: `Bearer ${authToken}` }
    });
    expect(response.status).to.equal(200);
  });

  it('должен ограничивать количество попыток входа', async function() {
    const loginAttempts = [];
    
    for (let i = 0; i < 10; i++) {
      loginAttempts.push(
        axios.post(`${API_BASE_URL}/auth/login`, {
          email: 'nonexistent@example.com',
          password: 'wrongpassword'
        })
        .catch(error => error)
      );
    }
    
    const results = await Promise.all(loginAttempts);
    const blockedAttempts = results.filter(r => 
      r.response && (r.response.status === 429 || r.response.status === 403)
    );
    
    expect(blockedAttempts.length).to.be.greaterThan(0);
  });

  it('токен должен содержать безопасные параметры', function() {
    if (!authToken) {
      this.skip();
    }
    
    // Проверка структуры токена
    const tokenParts = authToken.split('.');
    expect(tokenParts).to.have.length(3); // JWT состоит из 3 частей
    
    // Декодирование payload (вторая часть)
    const payload = JSON.parse(atob(tokenParts[1]));
    
    // Проверка наличия обязательных полей безопасности
    expect(payload).to.have.property('exp'); // срок действия
    expect(payload).to.have.property('iat'); // время создания
    expect(payload).to.have.property('sub'); // субъект (пользователь)
    
    // Проверка срока действия (не более 24 часов)
    const tokenLifetime = payload.exp - payload.iat;
    expect(tokenLifetime).to.be.lessThan(24 * 60 * 60); // 24 часа в секундах
  });
});
```

### Тестирование валидации ввода

```javascript
// input-validation.test.js
const axios = require('axios');

describe('Тестирование валидации ввода', function() {
  const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';

  const dangerousInputs = [
    '<script>alert("XSS")</script>',
    '"><script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    'javascript:alert("XSS")',
    '"><svg onload=alert("XSS")>',
    '1\' OR \'1\'=\'1',
    '; DROP TABLE users; --',
    '<svg onload=alert&lpar;1&rpar;>',
    '"><img src=x onerror=alert("XSS")>',
    '{{7*7}}' // возможная инъекция шаблона
  ];

  it('должен отклонять опасные XSS-вводы', async function() {
    for (const input of dangerousInputs) {
      try {
        const response = await axios.post(`${API_BASE_URL}/api/echo`, {
          data: input
        });
        
        // Если запрос проходит, проверяем, не содержит ли ответ вредоносный код
        if (response.data.includes(input.replace(/"/g, '&quot;'))) {
          console.log(`ВОЗМОЖНАЯ уязвимость XSS с вводом: ${input}`);
          expect.fail(`Найдена возможная XSS-уязвимость с вводом: ${input}`);
        }
      } catch (error) {
        // Ожидаем ошибку или корректную обработку
        if (error.response && error.response.status !== 400) {
          console.log(`Неожиданный статус ${error.response.status} для ввода: ${input}`);
        }
      }
    }
  });

  it('должен проверять длину строк', async function() {
    const longString = 'A'.repeat(10000); // 10,000 символов
    
    try {
      const response = await axios.post(`${API_BASE_URL}/api/echo`, {
        data: longString
      });
      
      // Ожидаем ошибку 400 (Bad Request) или успешную обработку с ограничением
      if (response.status === 200 && response.data.length > 1000) {
        expect.fail('Строка не была ограничена по длине');
      }
    } catch (error) {
      if (error.response && error.response.status === 413) { // Payload Too Large
        // Это корректное поведение
        return;
      }
      if (error.response && error.response.status === 400) {
        // Это корректное поведение
        return;
      }
      expect.fail(`Неожиданная ошибка при обработке длинной строки: ${error.message}`);
    }
  });

  it('должен проверять формат email', async function() {
    const invalidEmails = [
      'invalid-email',
      '@example.com',
      'user@',
      'user@.com',
      'user name@example.com',
      'user@exam\nple.com'
    ];

    for (const email of invalidEmails) {
      try {
        const response = await axios.post(`${API_BASE_URL}/api/validate-email`, {
          email: email
        });
        
        // Ожидаем ошибку валидации
        if (response.status === 200) {
          expect.fail(`Email прошел валидацию, хотя является недействительным: ${email}`);
        }
      } catch (error) {
        if (error.response && error.response.status !== 400) {
          console.log(`Неожиданный статус при проверке email ${email}: ${error.response.status}`);
        }
      }
    }
  });
});
```

### Тестирование заголовков безопасности

```javascript
// security-headers.test.js
const axios = require('axios');

describe('Тестирование заголовков безопасности', function() {
  const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';

  it('должен возвращать безопасные заголовки', async function() {
    const response = await axios.get(`${API_BASE_URL}/`);
    
    const headers = response.headers;
    
    // Проверка заголовков безопасности
    expect(headers).to.have.property('x-frame-options');
    expect(headers['x-frame-options']).to.match(/^(SAMEORIGIN|DENY)$/i);
    
    expect(headers).to.have.property('x-content-type-options');
    expect(headers['x-content-type-options']).to.equal('nosniff');
    
    expect(headers).to.have.property('x-xss-protection');
    expect(headers['x-xss-protection']).to.match(/^1(; mode=block)?$/);
    
    expect(headers).to.have.property('strict-transport-security');
    // Проверяем, что HSTS включено на срок не менее 6 месяцев
    const hsts = headers['strict-transport-security'];
    if (hsts) {
      const maxAgeMatch = hsts.match(/max-age=([0-9]+)/);
      if (maxAgeMatch) {
        const maxAge = parseInt(maxAgeMatch[1]);
        expect(maxAge).to.be.at.least(15768000); // 6 месяцев в секундах
      }
    }
    
    expect(headers).to.have.property('content-security-policy');
  });

  it('должен защищать от MIME-типов атак', async function() {
    const response = await axios.get(`${API_BASE_URL}/`);
    
    expect(response.headers['x-content-type-options']).to.equal('nosniff');
    
    // Проверяем, что ответ не позволяет выполнение скриптов из файлов
    const csp = response.headers['content-security-policy'];
    if (csp) {
      expect(csp.toLowerCase()).to.include('script-src');
      expect(csp.toLowerCase()).to.include('\'self\'');
    }
  });

  it('должен использовать безопасные куки', async function() {
    const response = await axios.get(`${API_BASE_URL}/auth/login`, {
      maxRedirects: 0 // чтобы не следовать редиректам
    });
    
    const setCookieHeaders = response.headers['set-cookie'] || [];
    
    for (const cookie of setCookieHeaders) {
      // Проверяем наличие атрибутов безопасности
      expect(cookie).to.include('HttpOnly');
      expect(cookie).to.include('Secure');
      expect(cookie).to.include('SameSite');
    }
  });
});
```

## Инструменты автоматизированного тестирования

### OWASP ZAP (Zed Attack Proxy)

```javascript
// zap-automation.js
const { exec } = require('child_process');
const fs = require('fs').promises;

class ZAPAutomation {
  constructor(apiKey, targetUrl) {
    this.apiKey = apiKey;
    this.targetUrl = targetUrl;
    this.reportFile = `zap-report-${Date.now()}.html`;
  }

  async runAutomatedScan() {
    return new Promise((resolve, reject) => {
      const command = `docker run -t owasp/zap2docker-stable zap-baseline.py ` +
                     `-t ${this.targetUrl} ` +
                     `-g gen.conf ` +
                     `-r ${this.reportFile} ` +
                     `-T 5 ` +
                     `-c config.conf`;

      exec(command, async (error, stdout, stderr) => {
        if (error) {
          reject(error);
          return;
        }

        try {
          const report = await fs.readFile(this.reportFile, 'utf8');
          const hasIssues = this.analyzeReport(report);
          
          resolve({
            success: !hasIssues.highRisk,
            report: report,
            issues: hasIssues
          });
        } catch (readError) {
          reject(readError);
        }
      });
    });
  }

  analyzeReport(report) {
    // Простой анализ HTML отчета
    const issues = {
      highRisk: (report.match(/<td class="high">/g) || []).length,
      mediumRisk: (report.match(/<td class="medium">/g) || []).length,
      lowRisk: (report.match(/<td class="low">/g) || []).length
    };

    return issues;
  }
}

// Использование
async function runSecurityTests() {
  const zap = new ZAPAutomation('your-api-key', 'https://example.com');
  
  try {
    const result = await zap.runAutomatedScan();
    
    if (result.success) {
      console.log('✓ Безопасность в норме');
    } else {
      console.log(`⚠ Найдены уязвимости: ${JSON.stringify(result.issues)}`);
      process.exit(1); // Завершаем с ошибкой
    }
  } catch (error) {
    console.error('Ошибка при автоматическом тестировании безопасности:', error);
    process.exit(1);
  }
}

// Запуск при вызове напрямую
if (require.main === module) {
  runSecurityTests();
}
```

### Интеграция с SonarQube

```json
// sonar-project.properties
sonar.projectKey=my-secure-project
sonar.organization=my-org
sonar.sources=src
sonar.tests=test
sonar.exclusions=**/node_modules/**,**/dist/**,**/*.test.js
sonar.coverage.exclusions=**/node_modules/**,**/test/**
sonar.javascript.lcov.reportPaths=coverage/lcov.info
sonar.security.reportPath=security-report.json
```

```bash
# Скрипт для запуска SonarQube сканирования
#!/bin/bash
# sonar-scan.sh

# Установка SonarScanner
if ! command -v sonar &> /dev/null; then
    echo "Установка SonarScanner..."
    # Установка через npm или другой способ
    npm install -g sonarqube-scanner
fi

echo "Запуск SonarQube сканирования..."
sonar-scanner \
  -Dsonar.projectKey=my-secure-project \
  -Dsonar.sources=src \
  -Dsonar.host.url=https://sonarcloud.io \
  -Dsonar.login=$SONAR_TOKEN \
  -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

echo "Сканирование завершено"
```

## Создание системы отчетности

```javascript
// security-reporter.js
class SecurityTestReporter {
  constructor() {
    this.tests = [];
    this.findings = [];
    this.metadata = {
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development',
      commitHash: process.env.GIT_COMMIT || 'unknown'
    };
  }

  addTestResult(testName, result, details = {}) {
    this.tests.push({
      name: testName,
      passed: result,
      details,
      timestamp: new Date().toISOString()
    });
  }

  addFinding(type, severity, location, description, proofOfConcept = '') {
    this.findings.push({
      id: this.generateId(),
      type,
      severity,
      location,
      description,
      proofOfConcept,
      timestamp: new Date().toISOString(),
      status: 'open'
    });
  }

  generateId() {
    return 'finding_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  async generateReport() {
    const report = {
      metadata: this.metadata,
      summary: {
        totalTests: this.tests.length,
        passedTests: this.tests.filter(t => t.passed).length,
        failedTests: this.tests.filter(t => !t.passed).length,
        totalFindings: this.findings.length,
        bySeverity: this.groupBySeverity(),
        byType: this.groupByType()
      },
      tests: this.tests,
      findings: this.findings,
      recommendations: this.generateRecommendations()
    };

    return report;
  }

  groupBySeverity() {
    return this.findings.reduce((acc, finding) => {
      acc[finding.severity] = (acc[finding.severity] || 0) + 1;
      return acc;
    }, {});
  }

  groupByType() {
    return this.findings.reduce((acc, finding) => {
      acc[finding.type] = (acc[finding.type] || 0) + 1;
      return acc;
    }, {});
  }

  generateRecommendations() {
    const recommendations = [];

    const severityCounts = this.groupBySeverity();
    if (severityCounts.critical > 0 || severityCounts.high > 0) {
      recommendations.push('Немедленно устранить критические и высокие уязвимости');
    }

    const typeCounts = this.groupByType();
    if (typeCounts['SQL Injection']) {
      recommendations.push('Проверить все SQL-запросы на использование параметризованных запросов');
    }

    if (typeCounts['XSS']) {
      recommendations.push('Внедрить контекстно-зависимое кодирование вывода');
    }

    if (typeCounts['Authentication']) {
      recommendations.push('Усилить механизм аутентификации и авторизации');
    }

    return recommendations;
  }

  async saveReport(filename = null) {
    const report = await this.generateReport();
    const fs = require('fs').promises;
    
    const reportFilename = filename || `security-report-${this.metadata.timestamp}.json`;
    await fs.writeFile(reportFilename, JSON.stringify(report, null, 2));
    
    console.log(`Отчет сохранен: ${reportFilename}`);
    return reportFilename;
  }
}

// Использование
async function runAutomatedSecurityTests() {
  const reporter = new SecurityTestReporter();
  
  // Запуск различных тестов
  try {
    // Тестирование зависимости
    const auditResult = await runDependencyAudit();
    reporter.addTestResult('Dependency Audit', auditResult.success, auditResult.details);
    
    if (!auditResult.success) {
      for (const vuln of auditResult.vulnerabilities) {
        reporter.addFinding(
          'Dependency Vulnerability',
          vuln.severity,
          vuln.module,
          vuln.title,
          `Package: ${vuln.module}, Version: ${vuln.version}`
        );
      }
    }
    
    // Тестирование кода
    const sastResult = await runSAST();
    reporter.addTestResult('SAST Scan', sastResult.success, sastResult.details);
    
    // Тестирование заголовков безопасности
    const headersResult = await testSecurityHeaders();
    reporter.addTestResult('Security Headers', headersResult.success, headersResult.details);
    
    // Сохранение отчета
    await reporter.saveReport();
    
    // Проверка, нужно ли завершать с ошибкой
    const report = await reporter.generateReport();
    if (report.summary.failedTests > 0 || report.summary.bySeverity.high > 0 || report.summary.bySeverity.critical > 0) {
      process.exit(1);
    }
    
  } catch (error) {
    console.error('Ошибка при выполнении автоматизированных тестов безопасности:', error);
    process.exit(1);
  }
}

// Вспомогательные функции
async function runDependencyAudit() {
  const { exec } = require('child_process');
  return new Promise((resolve) => {
    exec('npm audit --json', (error, stdout) => {
      const auditResult = JSON.parse(stdout);
      const vulnerabilities = auditResult.audit?.vulnerabilities || {};
      const hasHighVulns = vulnerabilities.high > 0 || vulnerabilities.critical > 0;
      
      resolve({
        success: !hasHighVulns,
        details: {
          total: auditResult.audit?.metadata?.vulnerabilities?.total || 0,
          high: auditResult.audit?.metadata?.vulnerabilities?.high || 0,
          critical: auditResult.audit?.metadata?.vulnerabilities?.critical || 0
        },
        vulnerabilities: auditResult.audit?.advisories ? Object.values(auditResult.audit.advisories) : []
      });
    });
  });
}

async function runSAST() {
  const { exec } = require('child_process');
  return new Promise((resolve) => {
    exec('npx eslint . --ext .js,.ts --format json', (error, stdout) => {
      const results = JSON.parse(stdout);
      const errors = results.flatMap(r => r.messages).filter(m => m.severity === 2);
      
      resolve({
        success: errors.length === 0,
        details: {
          totalErrors: errors.length,
          errors: errors
        }
      });
    });
  });
}

async function testSecurityHeaders() {
  const axios = require('axios');
  
  try {
    const response = await axios.get('https://example.com');
    const requiredHeaders = ['x-frame-options', 'x-content-type-options', 'strict-transport-security'];
    const missingHeaders = requiredHeaders.filter(header => !response.headers[header]);
    
    return {
      success: missingHeaders.length === 0,
      details: {
        missingHeaders,
        allHeaders: Object.keys(response.headers)
      }
    };
  } catch (error) {
    return {
      success: false,
      details: { error: error.message }
    };
  }
}

// Запуск при вызове напрямую
if (require.main === module) {
  runAutomatedSecurityTests();
}
```

## Лучшие практики

### 1. Интеграция в процесс разработки

- Запуск автоматических тестов в pre-commit хуках
- Интеграция с CI/CD пайплайнами
- Блокировка PR при обнаружении критических уязвимостей

### 2. Настройка порогов безопасности

```javascript
// security-config.js
const securityConfig = {
  thresholds: {
    critical: 0,
    high: 0,
    medium: 5,
    low: 10
  },
  
  allowedVulnerabilities: [
    // Список уязвимостей, для которых допускается исключение
    // с указанием причины и срока устранения
  ],
  
  scanSchedule: {
    // Расписание сканирования
    dependency: 'every day',
    code: 'on push',
    infrastructure: 'weekly'
  }
};
```

### 3. Мониторинг и оповещение

- Настройка уведомлений о новых уязвимостях
- Интеграция с системами отслеживания задач
- Регулярные отчеты для команды и менеджмента

## Заключение

Автоматизированное тестирование безопасности - ключевой элемент современного процесса разработки безопасного ПО. Оно позволяет быстро и эффективно выявлять уязвимости на ранних стадиях разработки, снижая риски и стоимость их устранения. Правильная интеграция автоматических тестов в CI/CD пайплайны обеспечивает постоянный контроль безопасности приложения.

## Связанные темы

- [[Методы-тестирования-безопасности]]
- [[Оценка-уязвимостей]]
- [[Инструменты-аудита-безопасности]]
- [[Проверка-ввода]]
- [[Кодирование-вывода]]
- [[Руководство-по-безопасному-коду]]