---
aliases: ["Тестирование безопасности баз данных", "Database Security Testing", "Безопасность СУБД"]
tags: ["#security", "#database-security", "#testing", "#sql-security"]
---

# Тестирование безопасности баз данных

## Введение

Тестирование безопасности баз данных - это критически важный процесс, направленный на выявление уязвимостей в системах управления базами данных (СУБД), их конфигурации, архитектуре и взаимодействии с приложениями. Базы данных часто содержат наиболее чувствительные данные, и их компрометация может привести к серьезным последствиям для безопасности организации.

## Архитектура безопасности баз данных

### 1. Уровни безопасности СУБД

```javascript
// Модель архитектуры безопасности базы данных
class DatabaseSecurityArchitecture {
    constructor() {
        this.securityLayers = {
            network: new NetworkSecurityLayer(),
            authentication: new AuthenticationSecurityLayer(),
            authorization: new AuthorizationSecurityLayer(),
            application: new ApplicationSecurityLayer(),
            data: new DataSecurityLayer(),
            audit: new AuditSecurityLayer()
        };
        
        this.securityControls = {
            accessControl: new AccessControlManager(),
            encryption: new EncryptionManager(),
            monitoring: new DatabaseMonitoringSystem(),
            backup: new BackupSecurityManager()
        };
    }
    
    async assessDatabaseSecurity(databaseConfig) {
        const assessment = {
            layers: {},
            controls: {},
            vulnerabilities: [],
            compliance: {},
            recommendations: []
        };
        
        // Оценка каждого уровня безопасности
        for (const [layerName, layer] of Object.entries(this.securityLayers)) {
            try {
                assessment.layers[layerName] = await layer.assessSecurity(databaseConfig);
            } catch (error) {
                console.error(`Failed to assess ${layerName} security:`, error);
                assessment.layers[layerName] = { error: error.message };
            }
        }
        
        // Оценка контрольных мер
        for (const [controlName, control] of Object.entries(this.securityControls)) {
            try {
                assessment.controls[controlName] = await control.evaluate(databaseConfig);
            } catch (error) {
                console.error(`Failed to evaluate ${controlName} control:`, error);
                assessment.controls[controlName] = { error: error.message };
            }
        }
        
        // Агрегация уязвимостей
        assessment.vulnerabilities = this.aggregateVulnerabilities(assessment);
        
        // Проверка соответствия
        assessment.compliance = await this.checkCompliance(assessment);
        
        // Генерация рекомендаций
        assessment.recommendations = this.generateRecommendations(assessment);
        
        return assessment;
    }
    
    aggregateVulnerabilities(assessment) {
        const vulnerabilities = [];
        
        // Сбор уязвимостей из всех уровней
        for (const [layerName, layerAssessment] of Object.entries(assessment.layers)) {
            if (layerAssessment.vulnerabilities) {
                vulnerabilities.push(...layerAssessment.vulnerabilities.map(v => ({
                    ...v,
                    layer: layerName
                })));
            }
        }
        
        // Сбор уязвимостей из контрольных мер
        for (const [controlName, controlAssessment] of Object.entries(assessment.controls)) {
            if (controlAssessment.vulnerabilities) {
                vulnerabilities.push(...controlAssessment.vulnerabilities.map(v => ({
                    ...v,
                    control: controlName
                })));
            }
        }
        
        return vulnerabilities;
    }
    
    async checkCompliance(assessment) {
        const compliance = {
            owasp: await this.checkOWASPCompliance(assessment),
            pciDSS: await this.checkPCIDSSCompliance(assessment),
            gdpr: await this.checkGDPRCompliance(assessment),
            hipaa: await this.checkHIPAACompliance(assessment),
            overall: 'PENDING'
        };
        
        compliance.overall = this.calculateOverallCompliance(compliance);
        
        return compliance;
    }
    
    calculateOverallCompliance(compliance) {
        const scores = Object.values(compliance)
            .filter(value => typeof value === 'object' && value.score !== undefined)
            .map(value => value.score || 0);
        
        if (scores.length === 0) return 'UNKNOWN';
        
        const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        
        if (avgScore >= 90) return 'FULLY_COMPLIANT';
        if (avgScore >= 70) return 'MAINLY_COMPLIANT';
        if (avgScore >= 50) return 'PARTIALLY_COMPLIANT';
        return 'NON_COMPLIANT';
    }
    
    generateRecommendations(assessment) {
        const recommendations = [];
        
        // Рекомендации по уровням безопасности
        for (const [layerName, layerAssessment] of Object.entries(assessment.layers)) {
            if (layerAssessment.recommendations) {
                recommendations.push(...layerAssessment.recommendations.map(rec => ({
                    ...rec,
                    category: 'security_layer',
                    layer: layerName
                })));
            }
        }
        
        // Рекомендации по контрольным мерам
        for (const [controlName, controlAssessment] of Object.entries(assessment.controls)) {
            if (controlAssessment.recommendations) {
                recommendations.push(...controlAssessment.recommendations.map(rec => ({
                    ...rec,
                    category: 'security_control',
                    control: controlName
                })));
            }
        }
        
        // Глобальные рекомендации на основе уязвимостей
        const vulnRecommendations = this.generateVulnerabilityBasedRecommendations(assessment.vulnerabilities);
        recommendations.push(...vulnRecommendations);
        
        return recommendations;
    }
    
    generateVulnerabilityBasedRecommendations(vulnerabilities) {
        const recommendations = [];
        
        const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
        if (criticalVulns.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Database Vulnerabilities',
                description: `Found ${criticalVulns.length} critical vulnerabilities`,
                action: 'Implement immediate fixes and security controls',
                affectedComponents: [...new Set(criticalVulns.map(v => v.component || v.layer || v.control))]
            });
        }
        
        const highVulns = vulnerabilities.filter(v => v.severity === 'HIGH');
        if (highVulns.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix High Severity Database Issues',
                description: `Found ${highVulns.length} high severity vulnerabilities`,
                action: 'Review and implement recommended security measures',
                affectedComponents: [...new Set(highVulns.map(v => v.component || v.layer || v.control))]
            });
        }
        
        return recommendations;
    }
    
    async getSecurityDashboard(databaseConfig) {
        const assessment = await this.assessDatabaseSecurity(databaseConfig);
        
        return {
            timestamp: new Date().toISOString(),
            databaseType: databaseConfig.type || 'unknown',
            version: databaseConfig.version || 'unknown',
            securityScore: this.calculateSecurityScore(assessment),
            riskLevel: this.determineRiskLevel(assessment),
            summary: this.generateDashboardSummary(assessment),
            trends: await this.getSecurityTrends(),
            nextSteps: this.generateNextSteps(assessment)
        };
    }
    
    calculateSecurityScore(assessment) {
        // Расчет общего балла безопасности
        let totalScore = 0;
        let totalChecks = 0;
        
        for (const layer of Object.values(assessment.layers)) {
            if (layer.score !== undefined) {
                totalScore += layer.score;
                totalChecks++;
            }
        }
        
        for (const control of Object.values(assessment.controls)) {
            if (control.score !== undefined) {
                totalScore += control.score;
                totalChecks++;
            }
        }
        
        return totalChecks > 0 ? Math.round(totalScore / totalChecks) : 0;
    }
    
    determineRiskLevel(assessment) {
        const criticalCount = assessment.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
        const highCount = assessment.vulnerabilities.filter(v => v.severity === 'HIGH').length;
        const mediumCount = assessment.vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
        
        if (criticalCount > 0) return 'CRITICAL';
        if (highCount > 5) return 'HIGH';
        if (highCount > 0) return 'MEDIUM-HIGH';
        if (mediumCount > 10) return 'MEDIUM';
        if (mediumCount > 0) return 'LOW-MEDIUM';
        return 'LOW';
    }
    
    generateDashboardSummary(assessment) {
        return {
            totalVulnerabilities: assessment.vulnerabilities.length,
            bySeverity: {
                critical: assessment.vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
                high: assessment.vulnerabilities.filter(v => v.severity === 'HIGH').length,
                medium: assessment.vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
                low: assessment.vulnerabilities.filter(v => v.severity === 'LOW').length
            },
            byLayer: this.countByLayer(assessment.layers),
            byControl: this.countByControl(assessment.controls),
            complianceStatus: assessment.compliance.overall
        };
    }
    
    countByLayer(layers) {
        const counts = {};
        for (const [layerName, layerAssessment] of Object.entries(layers)) {
            counts[layerName] = layerAssessment.vulnerabilities?.length || 0;
        }
        return counts;
    }
    
    countByControl(controls) {
        const counts = {};
        for (const [controlName, controlAssessment] of Object.entries(controls)) {
            counts[controlName] = controlAssessment.vulnerabilities?.length || 0;
        }
        return counts;
    }
    
    async getSecurityTrends() {
        // В реальности анализировать исторические данные
        return {
            vulnerabilityTrend: 'stable',
            securityScoreTrend: 'improving',
            complianceTrend: 'stable'
        };
    }
    
    generateNextSteps(assessment) {
        const steps = [];
        
        if (assessment.summary.bySeverity.critical > 0) {
            steps.push('1. Address all critical vulnerabilities immediately');
            steps.push('2. Implement emergency security controls');
        }
        
        if (assessment.summary.bySeverity.high > 0) {
            steps.push('1. Prioritize fixing high severity issues');
            steps.push('2. Review access controls and permissions');
        }
        
        steps.push('1. Implement continuous security monitoring');
        steps.push('2. Regular security assessments and penetration testing');
        steps.push('3. Security training for database administrators');
        
        return steps;
    }
}

// Уровень сетевой безопасности
class NetworkSecurityLayer {
    async assessSecurity(config) {
        const assessment = {
            encryption: await this.checkEncryption(config),
            authentication: await this.checkNetworkAuth(config),
            firewall: await this.checkFirewall(config),
            connectionSecurity: await this.checkConnectionSecurity(config),
            vulnerabilities: [],
            recommendations: [],
            score: 0
        };
        
        // Оценка уязвимостей
        if (!assessment.encryption.enabled) {
            assessment.vulnerabilities.push({
                id: 'DB_NET_ENCRYPTION_DISABLED',
                severity: 'HIGH',
                description: 'Network encryption is disabled',
                component: 'network_layer'
            });
        }
        
        if (assessment.firewall.openPorts > 1) {
            assessment.vulnerabilities.push({
                id: 'DB_OPEN_PORTS',
                severity: 'MEDIUM',
                description: `Too many open ports: ${assessment.firewall.openPorts}`,
                component: 'network_layer'
            });
        }
        
        assessment.score = this.calculateNetworkScore(assessment);
        
        return assessment;
    }
    
    async checkEncryption(config) {
        // Проверка шифрования сетевых соединений
        const hasTLS = config.ssl || config.tls || config.encryption?.enabled;
        
        return {
            enabled: hasTLS,
            protocol: config.tls?.protocol || config.ssl?.protocol || 'unknown',
            cipher: config.tls?.cipher || config.ssl?.cipher || 'unknown',
            strength: this.evaluateCipherStrength(config.tls?.cipher || config.ssl?.cipher)
        };
    }
    
    evaluateCipherStrength(cipher) {
        if (!cipher) return 'UNKNOWN';
        
        const strongCiphers = [
            'TLS_AES_256_GCM_SHA384',
            'TLS_AES_128_GCM_SHA256',
            'ECDHE-RSA-AES256-GCM-SHA384',
            'ECDHE-RSA-AES128-GCM-SHA256'
        ];
        
        return strongCiphers.includes(cipher) ? 'STRONG' : 'WEAK';
    }
    
    async checkNetworkAuth(config) {
        // Проверка аутентификации на сетевом уровне
        return {
            required: config.requireAuth || config.auth?.required,
            method: config.auth?.method || 'unknown',
            secure: config.auth?.method === 'SCRAM-SHA-256' || 
                   config.auth?.method === 'certificate' ||
                   config.auth?.method === 'kerberos'
        };
    }
    
    async checkFirewall(config) {
        // Проверка настройки брандмауэра
        const openPorts = config.allowedPorts || config.firewall?.openPorts || [config.port || 5432];
        
        return {
            openPorts: openPorts.length,
            allowedIPs: config.allowedIPs || config.firewall?.allowedIPs || [],
            secure: openPorts.length <= 2 && 
                   this.hasIPWhitelist(config) && 
                   !this.hasBroadAccess(config)
        };
    }
    
    hasIPWhitelist(config) {
        return (config.allowedIPs || config.firewall?.allowedIPs || []).length > 0;
    }
    
    hasBroadAccess(config) {
        return (config.allowedIPs || config.firewall?.allowedIPs || [])
            .some(ip => ip === '0.0.0.0/0' || ip === '::/0');
    }
    
    async checkConnectionSecurity(config) {
        // Проверка безопасности соединений
        return {
            maxConnections: config.maxConnections || config.connection?.max || 'unlimited',
            connectionTimeout: config.connectionTimeout || config.connection?.timeout || 300,
            idleTimeout: config.idleTimeout || config.connection?.idleTimeout || 300,
            secure: (config.maxConnections || 1000) !== 'unlimited' && 
                   (config.connectionTimeout || 0) > 0
        };
    }
    
    calculateNetworkScore(assessment) {
        let score = 100;
        
        if (!assessment.encryption.enabled) score -= 30;
        if (assessment.encryption.strength === 'WEAK') score -= 20;
        if (!assessment.authentication.secure) score -= 15;
        if (!assessment.firewall.secure) score -= 25;
        if (!assessment.connectionSecurity.secure) score -= 10;
        
        return Math.max(0, score);
    }
}

// Уровень аутентификации
class AuthenticationSecurityLayer {
    async assessSecurity(config) {
        const assessment = {
            authenticationMethods: await this.checkAuthMethods(config),
            passwordPolicy: await this.checkPasswordPolicy(config),
            accountManagement: await this.checkAccountManagement(config),
            vulnerabilities: [],
            recommendations: [],
            score: 0
        };
        
        // Проверка на уязвимости
        if (assessment.passwordPolicy.weak) {
            assessment.vulnerabilities.push({
                id: 'DB_WEAK_PASSWORD_POLICY',
                severity: 'MEDIUM',
                description: 'Weak password policy detected',
                component: 'authentication_layer'
            });
        }
        
        if (assessment.accountManagement.insecure) {
            assessment.vulnerabilities.push({
                id: 'DB_ACCOUNT_MANAGEMENT_INSECURE',
                severity: 'HIGH',
                description: 'Insecure account management practices',
                component: 'authentication_layer'
            });
        }
        
        assessment.score = this.calculateAuthScore(assessment);
        
        return assessment;
    }
    
    async checkAuthMethods(config) {
        const methods = config.auth?.methods || config.authentication?.methods || [];
        
        return {
            supported: methods,
            secure: methods.includes('SCRAM-SHA-256') || 
                    methods.includes('certificate') || 
                    methods.includes('kerberos'),
            insecure: methods.includes('md5') || methods.includes('plaintext')
        };
    }
    
    async checkPasswordPolicy(config) {
        const policy = config.auth?.passwordPolicy || config.passwordPolicy || {};
        
        const checks = {
            minLength: policy.minLength >= 12,
            complexity: policy.complexity || policy.requireComplexity,
            expiration: policy.expirationDays <= 90,
            history: policy.historyLength >= 5,
            lockout: policy.lockoutAttempts <= 5 && policy.lockoutDuration >= 15
        };
        
        const weak = !checks.minLength || !checks.complexity || !checks.expiration;
        
        return {
            ...checks,
            weak: weak,
            overallStrength: this.calculatePasswordPolicyStrength(checks)
        };
    }
    
    calculatePasswordPolicyStrength(checks) {
        const criteriaMet = Object.values(checks).filter(Boolean).length;
        const totalCriteria = Object.keys(checks).length;
        
        return Math.round((criteriaMet / totalCriteria) * 100);
    }
    
    async checkAccountManagement(config) {
        const management = config.accountManagement || config.auth?.accountManagement || {};
        
        const checks = {
            defaultAccounts: !management.allowDefaultAccounts,
            accountLockout: management.accountLockoutEnabled,
            passwordHistory: management.passwordHistoryEnabled,
            sessionTimeout: management.sessionTimeout > 0,
            inactiveAccountCleanup: management.inactiveAccountCleanup > 0
        };
        
        const insecure = Object.entries(checks)
            .filter(([, enabled]) => !enabled)
            .length > 0;
        
        return {
            ...checks,
            insecure: insecure,
            overallSecurity: this.calculateAccountManagementSecurity(checks)
        };
    }
    
    calculateAccountManagementSecurity(checks) {
        const criteriaMet = Object.values(checks).filter(Boolean).length;
        const totalCriteria = Object.keys(checks).length;
        
        return Math.round((criteriaMet / totalCriteria) * 100);
    }
    
    calculateAuthScore(assessment) {
        let score = 100;
        
        if (assessment.authenticationMethods.insecure) score -= 25;
        if (assessment.passwordPolicy.weak) score -= 20;
        if (assessment.accountManagement.insecure) score -= 30;
        
        return Math.max(0, score);
    }
}

// Уровень авторизации
class AuthorizationSecurityLayer {
    async assessSecurity(config) {
        const assessment = {
            roleBasedAccess: await this.checkRBAC(config),
            privilegeManagement: await this.checkPrivilegeManagement(config),
            accessControls: await this.checkAccessControls(config),
            vulnerabilities: [],
            recommendations: [],
            score: 0
        };
        
        // Проверка на уязвимости
        if (assessment.privilegeManagement.hasExcessivePrivileges) {
            assessment.vulnerabilities.push({
                id: 'DB_EXCESSIVE_PRIVILEGES',
                severity: 'HIGH',
                description: 'Users have excessive privileges',
                component: 'authorization_layer'
            });
        }
        
        if (assessment.accessControls.hasWeakControls) {
            assessment.vulnerabilities.push({
                id: 'DB_WEAK_ACCESS_CONTROLS',
                severity: 'MEDIUM',
                description: 'Weak access controls detected',
                component: 'authorization_layer'
            });
        }
        
        assessment.score = this.calculateAuthorizationScore(assessment);
        
        return assessment;
    }
    
    async checkRBAC(config) {
        const rbac = config.rbac || config.roleBasedAccess || {};
        
        return {
            enabled: rbac.enabled,
            roles: rbac.roles || [],
            roleInheritance: rbac.roleInheritance,
            principleOfLeastPrivilege: rbac.principleOfLeastPrivilege,
            secure: rbac.enabled && 
                   rbac.roles.length > 0 && 
                   rbac.principleOfLeastPrivilege
        };
    }
    
    async checkPrivilegeManagement(config) {
        const privileges = config.privileges || config.privilegeManagement || {};
        
        // Проверка наличия пользователей с чрезмерными привилегиями
        const excessivePrivileges = await this.checkForExcessivePrivileges(config);
        
        return {
            principleOfLeastPrivilege: privileges.principleOfLeastPrivilege,
            roleSeparation: privileges.roleSeparation,
            excessivePrivileges: excessivePrivileges,
            hasExcessivePrivileges: excessivePrivileges.length > 0,
            secure: !excessivePrivileges.length > 0 && privileges.principleOfLeastPrivilege
        };
    }
    
    async checkForExcessivePrivileges(config) {
        // Проверка на чрезмерные привилегии
        // В реальности это будет сложный запрос к системным таблицам СУБД
        return []; // Заглушка
    }
    
    async checkAccessControls(config) {
        const controls = config.accessControls || config.authorization || {};
        
        const checks = {
            rowLevelSecurity: controls.rowLevelSecurity,
            columnLevelSecurity: controls.columnLevelSecurity,
            tableLevelSecurity: controls.tableLevelSecurity,
            databaseLevelSecurity: controls.databaseLevelSecurity,
            applicationLevelSecurity: controls.applicationLevelSecurity
        };
        
        const weakControls = Object.entries(checks)
            .filter(([, enabled]) => !enabled)
            .length > 2;
        
        return {
            ...checks,
            hasWeakControls: weakControls,
            overallSecurity: this.calculateAccessControlSecurity(checks)
        };
    }
    
    calculateAccessControlSecurity(checks) {
        const criteriaMet = Object.values(checks).filter(Boolean).length;
        const totalCriteria = Object.keys(checks).length;
        
        return Math.round((criteriaMet / totalCriteria) * 100);
    }
    
    calculateAuthorizationScore(assessment) {
        let score = 100;
        
        if (!assessment.roleBasedAccess.secure) score -= 20;
        if (assessment.privilegeManagement.hasExcessivePrivileges) score -= 30;
        if (assessment.accessControls.hasWeakControls) score -= 25;
        
        return Math.max(0, score);
    }
}
```

## Тестирование на уязвимости SQL-инъекций

### 1. Сканирование SQL-инъекций

```javascript
// Система тестирования SQL-инъекций
class SQLInjectionTester {
    constructor(databaseConnection) {
        this.db = databaseConnection;
        this.testPayloads = [
            // Базовые SQL-инъекции
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL, NULL, NULL--",
            "'; DROP TABLE users;--",
            "' AND 1=2 UNION SELECT 1,2,3--",
            
            // Более сложные пейлоады
            "' AND (SELECT COUNT(*) FROM sysobjects)>0--",
            "' AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES)>0--",
            "' OR EXISTS(SELECT * FROM users WHERE username='admin')--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND SLEEP(5)--",
            
            // Unicode и энкодированные пейлоады
            "%27%20OR%20%271%27=%271",
            "%22%20OR%20%221%22=%221",
            "' OR 'a'='a",
            '" OR "a"="a',
            
            // MSSQL специфичные
            "'; EXEC xp_cmdshell 'dir'--",
            "'; DECLARE @s VARCHAR(4000); SET @s = (SELECT password FROM users WHERE id = 1); EXEC(@s)--",
            
            // MySQL специфичные
            "' OR SLEEP(5)#",
            "' OR BENCHMARK(1000000,MD5(1))#",
            
            // PostgreSQL специфичные
            "' OR pg_sleep(5)--",
            "'; SELECT pg_read_file('/etc/passwd')--"
        ];
        
        this.detectionPatterns = [
            /sql syntax/i,
            /mysql/i,
            /postgresql/i,
            /ora-\d{4}/i,
            /sqlite/i,
            /unclosed quotation mark/i,
            /syntax error/i,
            /near "/i,
            /at character \d+/i
        ];
    }
    
    async testSQLInjectionVulnerabilities(testCases) {
        const results = {
            vulnerableEndpoints: [],
            confirmedVulnerabilities: [],
            falsePositives: [],
            totalTests: testCases.length * this.testPayloads.length,
            completedTests: 0
        };
        
        for (const testCase of testCases) {
            const endpointResults = await this.testEndpointSQLInjection(testCase);
            results.completedTests += endpointResults.testsRun;
            
            if (endpointResults.vulnerable) {
                results.vulnerableEndpoints.push(endpointResults);
                
                for (const vulnerability of endpointResults.vulnerabilities) {
                    results.confirmedVulnerabilities.push({
                        ...vulnerability,
                        endpoint: testCase.endpoint,
                        parameter: testCase.parameter
                    });
                }
            } else {
                results.falsePositives.push(...endpointResults.tests);
            }
        }
        
        return results;
    }
    
    async testEndpointSQLInjection(testCase) {
        const results = {
            endpoint: testCase.endpoint,
            parameter: testCase.parameter,
            vulnerable: false,
            vulnerabilities: [],
            tests: [],
            testsRun: 0
        };
        
        for (const payload of this.testPayloads) {
            const testResult = await this.executeSQLInjectionTest(testCase, payload);
            results.tests.push(testResult);
            results.testsRun++;
            
            if (testResult.vulnerable) {
                results.vulnerable = true;
                results.vulnerabilities.push({
                    payload: payload,
                    type: testResult.type,
                    severity: testResult.severity,
                    evidence: testResult.evidence,
                    databaseType: testResult.databaseType
                });
            }
        }
        
        return results;
    }
    
    async executeSQLInjectionTest(testCase, payload) {
        try {
            const startTime = Date.now();
            
            // Выполнение теста с пейлоадом
            const response = await this.makeRequest(testCase.endpoint, {
                [testCase.parameter]: payload
            });
            
            const responseTime = Date.now() - startTime;
            
            // Проверка на признаки SQL-инъекции
            const detectionResult = this.analyzeResponse(response, payload, responseTime);
            
            return {
                payload: payload,
                response: response,
                responseTime: responseTime,
                ...detectionResult
            };
        } catch (error) {
            return {
                payload: payload,
                error: error.message,
                vulnerable: false,
                type: 'REQUEST_FAILED',
                severity: 'INFO',
                evidence: null,
                databaseType: 'UNKNOWN'
            };
        }
    }
    
    analyzeResponse(response, payload, responseTime) {
        const result = {
            vulnerable: false,
            type: null,
            severity: 'LOW',
            evidence: null,
            databaseType: 'UNKNOWN'
        };
        
        // Проверка на SQL-ошибки
        if (response.body && this.containsSQLError(response.body)) {
            result.vulnerable = true;
            result.type = 'ERROR_BASED_SQLI';
            result.severity = 'HIGH';
            result.evidence = 'SQL error message detected';
            result.databaseType = this.detectDatabaseType(response.body);
        }
        
        // Проверка на увеличение времени ответа (time-based injection)
        if (responseTime > 5000 && payload.includes('SLEEP') || payload.includes('WAITFOR')) {
            result.vulnerable = true;
            result.type = 'TIME_BASED_SQLI';
            result.severity = 'MEDIUM';
            result.evidence = `Response time increased to ${responseTime}ms`;
            result.databaseType = this.detectDatabaseTypeFromPayload(payload);
        }
        
        // Проверка на изменения в ответе (boolean-based injection)
        if (this.hasResponseChanges(response, payload)) {
            result.vulnerable = true;
            result.type = 'BOOLEAN_BASED_SQLI';
            result.severity = 'MEDIUM';
            result.evidence = 'Response content changed with injection payload';
        }
        
        return result;
    }
    
    containsSQLError(responseBody) {
        if (!responseBody) return false;
        
        const body = typeof responseBody === 'string' ? 
                    responseBody.toLowerCase() : 
                    JSON.stringify(responseBody).toLowerCase();
        
        return this.detectionPatterns.some(pattern => pattern.test(body));
    }
    
    detectDatabaseType(responseBody) {
        const body = typeof responseBody === 'string' ? 
                    responseBody.toLowerCase() : 
                    JSON.stringify(responseBody).toLowerCase();
        
        if (body.includes('mysql')) return 'MySQL';
        if (body.includes('postgresql') || body.includes('postgres')) return 'PostgreSQL';
        if (body.includes('oracle') || body.includes('ora-')) return 'Oracle';
        if (body.includes('microsoft') || body.includes('sql server')) return 'SQL Server';
        if (body.includes('sqlite')) return 'SQLite';
        if (body.includes('db2')) return 'DB2';
        
        return 'UNKNOWN';
    }
    
    detectDatabaseTypeFromPayload(payload) {
        if (payload.includes('SLEEP') || payload.includes('BENCHMARK')) return 'MySQL';
        if (payload.includes('pg_sleep') || payload.includes('pg_read_file')) return 'PostgreSQL';
        if (payload.includes('WAITFOR')) return 'SQL Server';
        if (payload.includes('EXEC xp_cmdshell')) return 'SQL Server';
        
        return 'UNKNOWN';
    }
    
    hasResponseChanges(response, payload) {
        // Проверка на изменения в ответе
        // В реальности сравнивать с ответом без пейлоада
        return false; // Заглушка
    }
    
    async makeRequest(url, params) {
        // Выполнение HTTP-запроса для тестирования
        const queryString = new URLSearchParams(params).toString();
        
        try {
            const response = await fetch(`${url}?${queryString}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'SecurityScanner/1.0'
                }
            });
            
            return {
                status: response.status,
                headers: Object.fromEntries(response.headers.entries()),
                body: await response.text()
            };
        } catch (error) {
            return {
                error: error.message,
                status: 0,
                body: null
            };
        }
    }
    
    async testStoredProcedures(testCases) {
        // Тестирование хранимых процедур на SQL-инъекции
        const results = [];
        
        for (const testCase of testCases) {
            const procedureResult = await this.testStoredProcSQLInjection(testCase);
            results.push(procedureResult);
        }
        
        return results;
    }
    
    async testStoredProcSQLInjection(testCase) {
        const result = {
            procedure: testCase.procedure,
            vulnerable: false,
            vulnerabilities: [],
            testResults: []
        };
        
        for (const payload of this.testPayloads) {
            try {
                // Вызов хранимой процедуры с пейлоадом
                const procResult = await this.db.query(
                    `CALL ${testCase.procedure}('${payload}')`
                );
                
                if (this.analyzeStoredProcResult(procResult, payload)) {
                    result.vulnerable = true;
                    result.vulnerabilities.push({
                        payload: payload,
                        type: 'STORED_PROCEDURE_INJECTION',
                        severity: 'HIGH'
                    });
                }
                
                result.testResults.push({
                    payload: payload,
                    result: procResult,
                    vulnerable: this.analyzeStoredProcResult(procResult, payload)
                });
            } catch (error) {
                // Ошибки могут указывать на уязвимость
                result.testResults.push({
                    payload: payload,
                    error: error.message,
                    vulnerable: this.analyzeStoredProcError(error, payload)
                });
            }
        }
        
        return result;
    }
    
    analyzeStoredProcResult(result, payload) {
        // Анализ результата выполнения хранимой процедуры
        if (result.error) {
            return this.containsSQLError(result.error);
        }
        
        // Проверка на неожиданные данные в результате
        if (result.rows && result.rows.length > 1000) { // Подозрительно много строк
            return true;
        }
        
        return false;
    }
    
    analyzeStoredProcError(error, payload) {
        // Анализ ошибки хранимой процедуры
        if (error.message && this.containsSQLError(error.message)) {
            return true;
        }
        
        return false;
    }
    
    async testDatabaseConnectionSecurity() {
        // Тестирование безопасности соединения с базой данных
        const connectionTests = [
            this.testConnectionEncryption(),
            this.testConnectionPooling(),
            this.testConnectionTimeouts(),
            this.testIdleConnections()
        ];
        
        const results = await Promise.allSettled(connectionTests);
        
        return results.map((result, index) => ({
            test: ['encryption', 'pooling', 'timeouts', 'idle_connections'][index],
            success: result.status === 'fulfilled',
            result: result.status === 'fulfilled' ? result.value : result.reason
        }));
    }
    
    async testConnectionEncryption() {
        // Проверка шифрования соединения
        try {
            // В реальности проверять параметры соединения
            const connectionConfig = this.db.connectionConfig;
            
            return {
                encrypted: connectionConfig.ssl || connectionConfig.encrypted,
                cipher: connectionConfig.ssl?.cipher || 'none',
                secure: connectionConfig.ssl?.require || connectionConfig.encrypted
            };
        } catch (error) {
            return { error: error.message };
        }
    }
    
    async testConnectionPooling() {
        // Проверка безопасности пула соединений
        return {
            maxConnections: this.db.pool?.max || 'unlimited',
            idleTimeout: this.db.pool?.idleTimeout || 0,
            secure: (this.db.pool?.max || 1000) !== 'unlimited' && 
                    (this.db.pool?.idleTimeout || 0) > 0
        };
    }
    
    async testConnectionTimeouts() {
        // Проверка таймаутов соединений
        return {
            connectTimeout: this.db.config?.connectTimeout || 10000,
            queryTimeout: this.db.config?.queryTimeout || 30000,
            secure: (this.db.config?.connectTimeout || 0) > 0 && 
                    (this.db.config?.queryTimeout || 0) > 0
        };
    }
    
    async testIdleConnections() {
        // Проверка обработки неактивных соединений
        return {
            idleConnectionTimeout: this.db.config?.idleTimeout || 0,
            connectionCleanup: this.db.config?.cleanup || false,
            secure: (this.db.config?.idleTimeout || 0) > 0
        };
    }
    
    generateSQLITestReport(results) {
        return {
            timestamp: new Date().toISOString(),
            totalTests: results.totalTests,
            vulnerableEndpoints: results.vulnerableEndpoints.length,
            confirmedVulnerabilities: results.confirmedVulnerabilities.length,
            vulnerabilityDistribution: this.countVulnerabilitiesByType(results.confirmedVulnerabilities),
            databaseTypes: this.getDatabaseTypes(results.confirmedVulnerabilities),
            severityBreakdown: this.countBySeverity(results.confirmedVulnerabilities),
            recommendations: this.generateSQLIRecommendations(results),
            nextSteps: this.generateNextSteps(results)
        };
    }
    
    countVulnerabilitiesByType(vulnerabilities) {
        const counts = {};
        for (const vuln of vulnerabilities) {
            counts[vuln.type] = (counts[vuln.type] || 0) + 1;
        }
        return counts;
    }
    
    getDatabaseTypes(vulnerabilities) {
        const types = new Set();
        for (const vuln of vulnerabilities) {
            types.add(vuln.databaseType);
        }
        return Array.from(types);
    }
    
    countBySeverity(vulnerabilities) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        for (const vuln of vulnerabilities) {
            counts[vuln.severity] = (counts[vuln.severity] || 0) + 1;
        }
        return counts;
    }
    
    generateSQLIRecommendations(results) {
        const recommendations = [];
        
        if (results.confirmedVulnerabilities.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Implement Parameterized Queries',
                description: 'SQL injection vulnerabilities detected',
                action: 'Use parameterized queries or prepared statements exclusively',
                affectedEndpoints: [...new Set(results.confirmedVulnerabilities.map(v => v.endpoint))]
            });
        }
        
        if (results.confirmedVulnerabilities.some(v => v.type === 'TIME_BASED_SQLI')) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix Time-Based SQL Injection',
                description: 'Time-based SQL injection vulnerabilities detected',
                action: 'Implement proper input validation and query parameterization',
                affectedEndpoints: [...new Set(
                    results.confirmedVulnerabilities
                        .filter(v => v.type === 'TIME_BASED_SQLI')
                        .map(v => v.endpoint)
                )]
            });
        }
        
        return recommendations;
    }
    
    generateNextSteps(results) {
        const steps = [];
        
        if (results.confirmedVulnerabilities.length > 0) {
            steps.push('1. Address all SQL injection vulnerabilities immediately');
            steps.push('2. Review all database queries for parameterization');
            steps.push('3. Implement input validation and sanitization');
            steps.push('4. Conduct security training for developers');
        }
        
        steps.push('1. Implement automated SQL injection testing in CI/CD');
        steps.push('2. Regular security assessments and penetration testing');
        steps.push('3. Monitor database logs for suspicious queries');
        
        return steps;
    }
}

// Использование SQLI тестера
const sqlTester = new SQLInjectionTester(dbConnection);

// Тестирование SQL-инъекций
async function runSQLInjectionTests() {
    const testCases = [
        { endpoint: '/api/users', parameter: 'id' },
        { endpoint: '/api/products', parameter: 'category' },
        { endpoint: '/api/search', parameter: 'query' }
    ];
    
    const results = await sqlTester.testSQLInjectionVulnerabilities(testCases);
    const report = sqlTester.generateSQLITestReport(results);
    
    console.log('SQL Injection Test Report:', JSON.stringify(report, null, 2));
    
    return report;
}
```

### 2. Тестирование привилегий и доступа

```javascript
// Система тестирования привилегий и доступа к базе данных
class DatabasePrivilegeTester {
    constructor(connection) {
        this.db = connection;
        this.testUsers = [];
        this.privilegeTests = [
            this.testDatabaseAccess,
            this.testTableAccess,
            this.testColumnAccess,
            this.testProcedureAccess,
            this.testViewAccess
        ];
    }
    
    async setupTestEnvironment() {
        // Создание тестовых пользователей с разными уровнями доступа
        const testUsers = [
            { username: 'test_admin', password: 'SecurePass123!', privileges: ['ALL PRIVILEGES'] },
            { username: 'test_user', password: 'UserPass456!', privileges: ['SELECT', 'INSERT'] },
            { username: 'test_readonly', password: 'ReadOnly789!', privileges: ['SELECT'] },
            { username: 'test_compromised', password: 'Compromised!', privileges: [] } // без привилегий
        ];
        
        for (const user of testUsers) {
            await this.createTestUser(user);
            this.testUsers.push(user);
        }
        
        // Создание тестовых таблиц
        await this.createTestTables();
    }
    
    async createTestUser(user) {
        try {
            // Создание пользователя (синтаксис зависит от СУБД)
            const createUserQuery = `
                CREATE USER IF NOT EXISTS '${user.username}'@'%' IDENTIFIED BY '${user.password}';
            `;
            
            await this.db.query(createUserQuery);
            
            // Назначение привилегий
            for (const privilege of user.privileges) {
                const grantQuery = `
                    GRANT ${privilege} ON *.* TO '${user.username}'@'%';
                `;
                await this.db.query(grantQuery);
            }
            
            // Применение изменений
            await this.db.query('FLUSH PRIVILEGES;');
            
        } catch (error) {
            console.error(`Failed to create test user ${user.username}:`, error.message);
        }
    }
    
    async createTestTables() {
        const testTables = [
            'CREATE TABLE IF NOT EXISTS test_users (id INT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255), password_hash VARCHAR(255))',
            'CREATE TABLE IF NOT EXISTS test_orders (id INT PRIMARY KEY, user_id INT, amount DECIMAL(10,2), status VARCHAR(50))',
            'CREATE TABLE IF NOT EXISTS test_sensitive (id INT PRIMARY KEY, credit_card VARCHAR(255), ssn VARCHAR(255), medical_record TEXT)'
        ];
        
        for (const tableQuery of testTables) {
            await this.db.query(tableQuery);
        }
    }
    
    async testPrivilegeEscalation() {
        const results = {
            horizontalEscalation: [],
            verticalEscalation: [],
            privilegeAbuse: [],
            principleOfLeastPrivilege: []
        };
        
        // Тестирование горизонтального эскалирования
        results.horizontalEscalation = await this.testHorizontalPrivilegeEscalation();
        
        // Тестирование вертикального эскалирования
        results.verticalEscalation = await this.testVerticalPrivilegeEscalation();
        
        // Тестирование злоупотребления привилегиями
        results.privilegeAbuse = await this.testPrivilegeAbuse();
        
        // Проверка принципа минимальных привилегий
        results.principleOfLeastPrivilege = await this.testPrincipleOfLeastPrivilege();
        
        return results;
    }
    
    async testHorizontalPrivilegeEscalation() {
        // Проверка возможности доступа к данным других пользователей
        const results = [];
        
        // Попытка пользователя с ограниченными правами получить данные других пользователей
        const testUser = this.testUsers.find(u => u.username === 'test_user');
        if (!testUser) return results;
        
        try {
            // Подключаемся с правами обычного пользователя
            const testConnection = await this.createConnectionAsUser(testUser);
            
            // Попытка доступа к данным других пользователей
            const query = "SELECT * FROM test_users WHERE id != 1"; // попытка получить не свои данные
            const result = await testConnection.query(query);
            
            if (result.rows && result.rows.length > 0) {
                results.push({
                    type: 'HORIZONTAL_PRIVILEGE_ESCALATION',
                    severity: 'HIGH',
                    description: 'User can access other users\' data',
                    user: testUser.username,
                    query: query,
                    rowsReturned: result.rows.length
                });
            }
            
            await testConnection.end();
        } catch (error) {
            // Ошибка доступа - это хорошо
            console.log('Horizontal privilege escalation properly blocked:', error.message);
        }
        
        return results;
    }
    
    async testVerticalPrivilegeEscalation() {
        // Проверка возможности получения административных привилегий
        const results = [];
        
        // Попытка пользователя без административных прав выполнить административные операции
        const testUser = this.testUsers.find(u => u.username === 'test_readonly');
        if (!testUser) return results;
        
        try {
            const testConnection = await this.createConnectionAsUser(testUser);
            
            // Попытка выполнить административные операции
            const adminQueries = [
                "GRANT ALL PRIVILEGES ON *.* TO 'test_user'@'%'", // попытка назначить привилегии себе
                "CREATE USER 'new_admin'@'%' IDENTIFIED BY 'password'", // попытка создать нового пользователя
                "DROP DATABASE mysql", // попытка удалить системную базу
                "ALTER USER 'test_admin'@'%' IDENTIFIED BY 'new_password'" // попытка изменить пароль администратора
            ];
            
            for (const query of adminQueries) {
                try {
                    await testConnection.query(query);
                    results.push({
                        type: 'VERTICAL_PRIVILEGE_ESCALATION',
                        severity: 'CRITICAL',
                        description: 'User can perform administrative operations',
                        user: testUser.username,
                        query: query
                    });
                } catch (queryError) {
                    // Ошибка - нормально, доступ заблокирован
                    console.log(`Query properly blocked: ${queryError.message}`);
                }
            }
            
            await testConnection.end();
        } catch (error) {
            console.error('Failed to test vertical privilege escalation:', error.message);
        }
        
        return results;
    }
    
    async testPrivilegeAbuse() {
        // Проверка на злоупотребление имеющимися привилегиями
        const results = [];
        
        const testUser = this.testUsers.find(u => u.username === 'test_user');
        if (!testUser) return results;
        
        try {
            const testConnection = await this.createConnectionAsUser(testUser);
            
            // Проверка на возможность выполнения вредоносных операций с разрешенными привилегиями
            const abuseQueries = [
                "SELECT * FROM test_sensitive", // попытка доступа к чувствительным данным
                "INSERT INTO test_users SELECT * FROM test_sensitive", // попытка копирования чувствительных данных
                "UPDATE test_users SET password_hash = (SELECT credit_card FROM test_sensitive LIMIT 1)", // попытка вредоносного обновления
                "CREATE TABLE malicious_table AS SELECT * FROM test_sensitive" // попытка копирования данных
            ];
            
            for (const query of abuseQueries) {
                try {
                    const result = await testConnection.query(query);
                    if (result.rows && result.rows.length > 0) {
                        results.push({
                            type: 'PRIVILEGE_ABUSE',
                            severity: 'MEDIUM',
                            description: 'User can abuse existing privileges',
                            user: testUser.username,
                            query: query,
                            rowsAffected: result.rows.length
                        });
                    }
                } catch (queryError) {
                    // Ошибки доступа - это нормально
                    console.log(`Query properly blocked: ${queryError.message}`);
                }
            }
            
            await testConnection.end();
        } catch (error) {
            console.error('Failed to test privilege abuse:', error.message);
        }
        
        return results;
    }
    
    async testPrincipleOfLeastPrivilege() {
        // Проверка соответствия принципу минимальных привилегий
        const results = [];
        
        for (const user of this.testUsers) {
            const userPrivileges = await this.getUserPrivileges(user.username);
            const requiredPrivileges = this.getRequiredPrivilegesForUser(user.username);
            
            // Проверка, есть ли у пользователя лишние привилегии
            const excessPrivileges = userPrivileges.filter(priv => 
                !requiredPrivileges.includes(priv)
            );
            
            if (excessPrivileges.length > 0) {
                results.push({
                    type: 'EXCESSIVE_PRIVILEGES',
                    severity: 'MEDIUM',
                    description: `User has excessive privileges: ${excessPrivileges.join(', ')}`,
                    user: user.username,
                    excessPrivileges: excessPrivileges,
                    requiredPrivileges: requiredPrivileges,
                    currentPrivileges: userPrivileges
                });
            }
        }
        
        return results;
    }
    
    async getUserPrivileges(username) {
        // Получение привилегий пользователя (MySQL пример)
        try {
            const result = await this.db.query(`
                SHOW GRANTS FOR '${username}'@'%'
            `);
            
            const privileges = [];
            for (const row of result.rows) {
                const grant = Object.values(row)[0]; // MySQL возвращает в формате {Grants for 'user'@'%': 'GRANT ...'}
                privileges.push(...this.parseGrantStatement(grant));
            }
            
            return [...new Set(privileges)]; // уникальные привилегии
        } catch (error) {
            console.error(`Failed to get privileges for user ${username}:`, error.message);
            return [];
        }
    }
    
    parseGrantStatement(grant) {
        // Парсинг SQL GRANT оператора для извлечения привилегий
        const privileges = [];
        
        // Пример: GRANT SELECT, INSERT, UPDATE ON *.* TO 'user'@'%'
        const match = grant.match(/GRANT\s+([^\s]+(?:,\s*[^\s]+)*)\s+ON/);
        if (match) {
            const privString = match[1];
            const individualPrivs = privString.split(',')
                .map(p => p.trim().toUpperCase());
            
            privileges.push(...individualPrivs);
        }
        
        return privileges;
    }
    
    getRequiredPrivilegesForUser(username) {
        // Определение минимально необходимых привилегий для пользователя
        const privilegeMap = {
            'test_admin': ['ALL PRIVILEGES'],
            'test_user': ['SELECT', 'INSERT', 'UPDATE'],
            'test_readonly': ['SELECT'],
            'test_compromised': [] // пользователь без привилегий для тестирования
        };
        
        return privilegeMap[username] || [];
    }
    
    async createConnectionAsUser(user) {
        // Создание соединения с базой данных под тестовым пользователем
        const mysql = require('mysql2/promise');
        
        return await mysql.createConnection({
            host: process.env.DB_HOST,
            port: process.env.DB_PORT,
            user: user.username,
            password: user.password,
            database: process.env.DB_NAME,
            ssl: process.env.DB_SSL ? { rejectUnauthorized: false } : false
        });
    }
    
    async testRoleBasedAccessControl() {
        // Тестирование Role-Based Access Control
        const results = {
            roleInheritance: await this.testRoleInheritance(),
            roleSeparation: await this.testRoleSeparation(),
            privilegeInheritance: await this.testPrivilegeInheritance(),
            roleManagement: await this.testRoleManagement()
        };
        
        return results;
    }
    
    async testRoleInheritance() {
        // Проверка наследования ролей
        const results = [];
        
        // Создание тестовых ролей
        const roles = [
            { name: 'test_role_basic', privileges: ['SELECT'] },
            { name: 'test_role_advanced', privileges: ['SELECT', 'INSERT', 'UPDATE'], inherits: 'test_role_basic' },
            { name: 'test_role_admin', privileges: ['ALL PRIVILEGES'], inherits: 'test_role_advanced' }
        ];
        
        for (const role of roles) {
            try {
                // Проверка, наследует ли роль привилегии родителя
                const rolePrivileges = await this.getRolePrivileges(role.name);
                
                if (role.inherits) {
                    const parentPrivileges = await this.getRolePrivileges(role.inherits);
                    
                    const missingPrivileges = parentPrivileges.filter(priv => 
                        !rolePrivileges.includes(priv)
                    );
                    
                    if (missingPrivileges.length > 0) {
                        results.push({
                            type: 'ROLE_INHERITANCE_BROKEN',
                            severity: 'HIGH',
                            description: `Role ${role.name} doesn't inherit privileges from ${role.inherits}`,
                            role: role.name,
                            parentRole: role.inherits,
                            missingPrivileges: missingPrivileges
                        });
                    }
                }
            } catch (error) {
                results.push({
                    type: 'ROLE_INHERITANCE_CHECK_FAILED',
                    severity: 'MEDIUM',
                    description: `Failed to check role inheritance for ${role.name}`,
                    role: role.name,
                    error: error.message
                });
            }
        }
        
        return results;
    }
    
    async getRolePrivileges(roleName) {
        // Получение привилегий роли (зависит от СУБД)
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.role_table_grants 
                WHERE grantee = '${roleName}'
            `);
            
            return result.rows.map(row => row.privilege_type);
        } catch {
            return [];
        }
    }
    
    async testRoleSeparation() {
        // Проверка разделения ролей (separation of duties)
        const results = [];
        
        // Проверка, что одна роль не имеет чрезмерных привилегий
        const sensitivePrivilegeCombinations = [
            ['CREATE USER', 'GRANT OPTION'],
            ['DROP', 'ALTER'],
            ['SELECT', 'INSERT', 'UPDATE', 'DELETE'] // полный доступ к данным
        ];
        
        // В реальности проверить все роли на наличие комбинаций
        // которые нарушают принцип разделения обязанностей
        
        return results;
    }
    
    async testPrivilegeInheritance() {
        // Проверка наследования привилегий
        const results = [];
        
        // Проверка, что привилегии правильно наследуются через цепочку ролей
        // и не возникает неожиданных привилегий
        
        return results;
    }
    
    async testRoleManagement() {
        // Проверка безопасности управления ролями
        const results = [];
        
        // Проверка, кто может создавать/удалять/модифицировать роли
        try {
            // Попытка обычного пользователя создать роль
            const readonlyUser = this.testUsers.find(u => u.username === 'test_readonly');
            if (readonlyUser) {
                const conn = await this.createConnectionAsUser(readonlyUser);
                
                try {
                    await conn.query("CREATE ROLE 'test_new_role'");
                    results.push({
                        type: 'ROLE_CREATION_WITHOUT_PRIVILEGE',
                        severity: 'CRITICAL',
                        description: 'User without privileges can create roles',
                        user: readonlyUser.username
                    });
                } catch (error) {
                    // Это нормально - пользователь не может создавать роли
                    console.log('Role creation properly restricted');
                }
                
                await conn.end();
            }
        } catch (error) {
            console.error('Role management test failed:', error.message);
        }
        
        return results;
    }
    
    async cleanupTestEnvironment() {
        // Удаление тестовых пользователей и таблиц
        for (const user of this.testUsers) {
            try {
                await this.db.query(`DROP USER IF EXISTS '${user.username}'@'%'`);
            } catch (error) {
                console.error(`Failed to drop test user ${user.username}:`, error.message);
            }
        }
        
        // Удаление тестовых таблиц
        const testTables = ['test_users', 'test_orders', 'test_sensitive'];
        for (const table of testTables) {
            try {
                await this.db.query(`DROP TABLE IF EXISTS ${table}`);
            } catch (error) {
                console.error(`Failed to drop test table ${table}:`, error.message);
            }
        }
        
        console.log('Test environment cleaned up');
    }
    
    generatePrivilegeTestReport(results) {
        return {
            timestamp: new Date().toISOString(),
            testResults: results,
            summary: {
                totalTests: this.countTotalTests(results),
                vulnerabilitiesFound: this.countVulnerabilities(results),
                bySeverity: this.countBySeverity(results),
                compliance: this.calculateCompliance(results)
            },
            recommendations: this.generatePrivilegeRecommendations(results),
            nextSteps: this.generateNextSteps(results)
        };
    }
    
    countTotalTests(results) {
        let count = 0;
        for (const category of Object.values(results)) {
            if (Array.isArray(category)) {
                count += category.length;
            } else {
                count += Object.values(category).flat().length;
            }
        }
        return count;
    }
    
    countVulnerabilities(results) {
        let count = 0;
        for (const category of Object.values(results)) {
            if (Array.isArray(category)) {
                count += category.length;
            } else {
                count += Object.values(category).flat().length;
            }
        }
        return count;
    }
    
    countBySeverity(results) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        
        const allVulns = [];
        for (const category of Object.values(results)) {
            if (Array.isArray(category)) {
                allVulns.push(...category);
            } else {
                allVulns.push(...Object.values(category).flat());
            }
        }
        
        for (const vuln of allVulns) {
            counts[vuln.severity] = (counts[vuln.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    calculateCompliance(results) {
        const totalVulns = this.countVulnerabilities(results);
        const critical = results.horizontalEscalation.filter(v => v.severity === 'CRITICAL').length +
                        results.verticalEscalation.filter(v => v.severity === 'CRITICAL').length;
        
        if (critical > 0) return 'CRITICAL_NON_COMPLIANT';
        if (totalVulns > 0) return 'PARTIALLY_COMPLIANT';
        return 'FULLY_COMPLIANT';
    }
    
    generatePrivilegeRecommendations(results) {
        const recommendations = [];
        
        if (results.horizontalEscalation.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Fix Horizontal Privilege Escalation',
                description: `Found ${results.horizontalEscalation.length} horizontal privilege escalation vulnerabilities`,
                action: 'Implement proper row-level security and access controls'
            });
        }
        
        if (results.verticalEscalation.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Fix Vertical Privilege Escalation',
                description: `Found ${results.verticalEscalation.length} vertical privilege escalation vulnerabilities`,
                action: 'Review and restrict administrative privileges'
            });
        }
        
        if (results.principleOfLeastPrivilege.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Apply Principle of Least Privilege',
                description: `Found ${results.principleOfLeastPrivilege.length} cases of excessive privileges`,
                action: 'Audit and reduce user privileges to minimum required'
            });
        }
        
        return recommendations;
    }
    
    generateNextSteps(results) {
        const steps = [];
        
        if (results.horizontalEscalation.length > 0) {
            steps.push('1. Implement row-level security for sensitive data');
            steps.push('2. Review application-level access controls');
            steps.push('3. Audit user permissions regularly');
        }
        
        if (results.verticalEscalation.length > 0) {
            steps.push('1. Restrict administrative privileges');
            steps.push('2. Implement role-based access control');
            steps.push('3. Enable database audit logging');
        }
        
        steps.push('1. Regular privilege audits');
        steps.push('2. Implement automated privilege monitoring');
        steps.push('3. Security training for database administrators');
        
        return steps;
    }
}

// Использование тестера привилегий
const privilegeTester = new DatabasePrivilegeTester(dbConnection);

async function runPrivilegeTests() {
    await privilegeTester.setupTestEnvironment();
    
    const results = await privilegeTester.testPrivilegeEscalation();
    const rbacResults = await privilegeTester.testRoleBasedAccessControl();
    
    const fullResults = { ...results, rbac: rbacResults };
    const report = privilegeTester.generatePrivilegeTestReport(fullResults);
    
    console.log('Database Privilege Test Report:', JSON.stringify(report, null, 2));
    
    await privilegeTester.cleanupTestEnvironment();
    
    return report;
}
```

## Шифрование данных в базе данных

### 1. Тестирование шифрования

```javascript
// Система тестирования шифрования данных
class DatabaseEncryptionTester {
    constructor(connection) {
        this.db = connection;
        this.encryptionAlgorithms = [
            'AES-256-GCM',
            'AES-192-GCM', 
            'AES-128-GCM',
            'AES-256-CBC',
            'AES-192-CBC',
            'AES-128-CBC',
            'ChaCha20-Poly1305'
        ];
        
        this.sensitiveDataPatterns = [
            /password|pwd|pass/i,
            /credit.*card|cc_number/i,
            /ssn|social.*security/i,
            /medical|health/i,
            /personal|private/i
        ];
    }
    
    async testDatabaseEncryption() {
        const results = {
            columnEncryption: await this.testColumnEncryption(),
            tableEncryption: await this.testTableEncryption(),
            databaseEncryption: await this.testDatabaseEncryption(),
            keyManagement: await this.testKeyManagement(),
            dataAtRest: await this.testDataAtRestEncryption(),
            dataInTransit: await this.testDataInTransitEncryption(),
            vulnerabilities: [],
            recommendations: []
        };
        
        // Сбор уязвимостей
        for (const [testType, testResults] of Object.entries(results)) {
            if (Array.isArray(testResults)) {
                results.vulnerabilities.push(...testResults.filter(r => !r.encrypted));
            } else if (testResults.vulnerabilities) {
                results.vulnerabilities.push(...testResults.vulnerabilities);
            }
        }
        
        results.recommendations = this.generateEncryptionRecommendations(results);
        
        return results;
    }
    
    async testColumnEncryption() {
        const results = [];
        
        // Получение информации о таблицах
        const tables = await this.getDatabaseTables();
        
        for (const table of tables) {
            const columns = await this.getTableColumns(table.name);
            
            for (const column of columns) {
                const isEncrypted = await this.isColumnEncrypted(table.name, column.name);
                const isSensitive = this.isSensitiveDataColumn(column.name, column.type);
                
                results.push({
                    tableName: table.name,
                    columnName: column.name,
                    dataType: column.type,
                    isEncrypted: isEncrypted,
                    isSensitive: isSensitive,
                    encryptionAlgorithm: await this.getColumnEncryptionAlgorithm(table.name, column.name),
                    keyId: await this.getColumnEncryptionKeyId(table.name, column.name)
                });
                
                if (isSensitive && !isEncrypted) {
                    results[results.length - 1].vulnerable = true;
                }
            }
        }
        
        return results;
    }
    
    async testTableEncryption() {
        const results = [];
        
        const tables = await this.getDatabaseTables();
        
        for (const table of tables) {
            const isEncrypted = await this.isTableEncrypted(table.name);
            const sensitive = await this.isTableContainsSensitiveData(table.name);
            
            results.push({
                tableName: table.name,
                isEncrypted: isEncrypted,
                containsSensitiveData: sensitive,
                encryptionType: await this.getTableEncryptionType(table.name),
                vulnerability: sensitive && !isEncrypted
            });
        }
        
        return results;
    }
    
    async testDataAtRestEncryption() {
        // Проверка шифрования данных при хранении
        const results = {
            fileLevelEncryption: await this.checkFileLevelEncryption(),
            tablespaceEncryption: await this.checkTablespaceEncryption(),
            databaseLevelEncryption: await this.checkDatabaseLevelEncryption(),
            overallEncryption: false
        };
        
        results.overallEncryption = results.fileLevelEncryption.encrypted ||
                                   results.tablespaceEncryption.encrypted ||
                                   results.databaseLevelEncryption.encrypted;
        
        return results;
    }
    
    async checkFileLevelEncryption() {
        // Проверка шифрования файлов базы данных
        try {
            // Для MySQL - проверка encrypted tablespaces
            const result = await this.db.query(`
                SELECT * FROM information_schema.innodb_tables 
                WHERE encrypt = 'Y'
            `);
            
            return {
                encrypted: result.rows.length > 0,
                count: result.rows.length,
                tables: result.rows.map(row => row.name)
            };
        } catch {
            // Для других СУБД - другой подход
            return { encrypted: false, count: 0, tables: [] };
        }
    }
    
    async checkTablespaceEncryption() {
        // Проверка шифрования табличных пространств
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.tablespaces 
                WHERE encryption_algorithm IS NOT NULL
            `);
            
            return {
                encrypted: result.rows.length > 0,
                count: result.rows.length,
                tablespaces: result.rows.map(row => row.tablespace_name)
            };
        } catch {
            return { encrypted: false, count: 0, tablespaces: [] };
        }
    }
    
    async checkDatabaseLevelEncryption() {
        // Проверка шифрования на уровне базы данных
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.databases 
                WHERE encryption = 'Y'
            `);
            
            return {
                encrypted: result.rows.length > 0,
                count: result.rows.length,
                databases: result.rows.map(row => row.schema_name)
            };
        } catch {
            return { encrypted: false, count: 0, databases: [] };
        }
    }
    
    async testDataInTransitEncryption() {
        // Проверка шифрования данных при передаче
        const results = {
            connectionEncryption: await this.checkConnectionEncryption(),
            sslEnabled: await this.checkSSLEnabled(),
            tlsVersion: await this.checkTLSVersion(),
            cipherStrength: await this.checkCipherStrength(),
            secure: false
        };
        
        results.secure = results.connectionEncryption &&
                        results.sslEnabled &&
                        results.tlsVersion >= 1.2 &&
                        results.cipherStrength === 'STRONG';
        
        return results;
    }
    
    async checkConnectionEncryption() {
        try {
            const result = await this.db.query("SHOW VARIABLES LIKE 'ssl_%'");
            const sslVars = result.rows.reduce((obj, row) => {
                obj[row.Variable_name] = row.Value;
                return obj;
            }, {});
            
            return {
                enabled: sslVars['ssl_enabled'] === 'ON' || sslVars['have_ssl'] === 'YES',
                cipher: sslVars['ssl_cipher'],
                key: sslVars['ssl_key']
            };
        } catch {
            return { enabled: false, cipher: null, key: null };
        }
    }
    
    async checkSSLEnabled() {
        try {
            const result = await this.db.query("SELECT @@have_ssl as ssl_status");
            return result.rows[0]?.ssl_status === 'YES';
        } catch {
            return false;
        }
    }
    
    async checkTLSVersion() {
        try {
            const result = await this.db.query("SELECT @@tls_version as tls_version");
            const versions = result.rows[0]?.tls_version?.split(',');
            return versions ? Math.max(...versions.map(v => parseFloat(v.replace('TLS', '').trim()))) : 0;
        } catch {
            return 0;
        }
    }
    
    async checkCipherStrength() {
        try {
            const result = await this.db.query("SHOW STATUS LIKE 'Ssl_cipher'");
            const cipher = result.rows[0]?.Value;
            
            if (!cipher) return 'UNKNOWN';
            
            const strongCiphers = [
                'TLS_AES_256_GCM_SHA384',
                'TLS_AES_128_GCM_SHA256',
                'ECDHE-RSA-AES256-GCM-SHA384',
                'ECDHE-RSA-AES128-GCM-SHA256'
            ];
            
            return strongCiphers.includes(cipher) ? 'STRONG' : 'WEAK';
        } catch {
            return 'UNKNOWN';
        }
    }
    
    async testKeyManagement() {
        const results = {
            keyRotation: await this.checkKeyRotation(),
            keyStorage: await this.checkKeyStorage(),
            keyAccess: await this.checkKeyAccess(),
            keyLifecycle: await this.checkKeyLifecycle(),
            secure: false
        };
        
        results.secure = results.keyRotation.enabled &&
                        results.keyStorage.secure &&
                        results.keyAccess.restricted &&
                        results.keyLifecycle.managed;
        
        return results;
    }
    
    async checkKeyRotation() {
        // Проверка ротации ключей
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.encryption_keys 
                WHERE rotation_period IS NOT NULL
            `);
            
            return {
                enabled: result.rows.length > 0,
                count: result.rows.length,
                rotationPeriod: result.rows[0]?.rotation_period
            };
        } catch {
            return { enabled: false, count: 0, rotationPeriod: null };
        }
    }
    
    async checkKeyStorage() {
        // Проверка безопасного хранения ключей
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.encryption_keys 
                WHERE key_storage_location = 'EXTERNAL'
            `);
            
            return {
                secure: result.rows.length > 0,
                count: result.rows.length,
                storageLocations: [...new Set(result.rows.map(row => row.key_storage_location))]
            };
        } catch {
            return { secure: false, count: 0, storageLocations: [] };
        }
    }
    
    async checkKeyAccess() {
        // Проверка ограничения доступа к ключам
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.encryption_key_access 
                WHERE access_control_enabled = 'YES'
            `);
            
            return {
                restricted: result.rows.length > 0,
                count: result.rows.length,
                accessControls: result.rows.map(row => row.access_method)
            };
        } catch {
            return { restricted: false, count: 0, accessControls: [] };
        }
    }
    
    async checkKeyLifecycle() {
        // Проверка управления жизненным циклом ключей
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.encryption_key_lifecycle 
                WHERE lifecycle_management = 'ACTIVE'
            `);
            
            return {
                managed: result.rows.length > 0,
                count: result.rows.length,
                lifecycleFeatures: result.rows.map(row => row.feature)
            };
        } catch {
            return { managed: false, count: 0, lifecycleFeatures: [] };
        }
    }
    
    async getDatabaseTables() {
        // Получение списка таблиц
        try {
            const result = await this.db.query(`
                SELECT table_name as name, table_type as type 
                FROM information_schema.tables 
                WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
            `);
            return result.rows;
        } catch (error) {
            console.error('Failed to get database tables:', error.message);
            return [];
        }
    }
    
    async getTableColumns(tableName) {
        // Получение колонок таблицы
        try {
            const result = await this.db.query(`
                SELECT column_name as name, data_type as type, is_nullable as nullable
                FROM information_schema.columns 
                WHERE table_name = ? AND table_schema = DATABASE()
            `, [tableName]);
            
            return result.rows;
        } catch (error) {
            console.error(`Failed to get columns for table ${tableName}:`, error.message);
            return [];
        }
    }
    
    async isColumnEncrypted(tableName, columnName) {
        // Проверка, зашифрована ли колонка
        try {
            // MySQL Transparent Data Encryption
            const result = await this.db.query(`
                SELECT * FROM information_schema.columns 
                WHERE table_name = ? AND column_name = ? AND encryption_type IS NOT NULL
            `, [tableName, columnName]);
            
            return result.rows.length > 0;
        } catch {
            return false;
        }
    }
    
    async getColumnEncryptionAlgorithm(tableName, columnName) {
        try {
            const result = await this.db.query(`
                SELECT encryption_algorithm 
                FROM information_schema.columns 
                WHERE table_name = ? AND column_name = ?
            `, [tableName, columnName]);
            
            return result.rows[0]?.encryption_algorithm || null;
        } catch {
            return null;
        }
    }
    
    async isSensitiveDataColumn(columnName, dataType) {
        // Проверка, содержит ли колонка чувствительные данные
        const name = columnName.toLowerCase();
        const type = dataType.toLowerCase();
        
        // Проверка по имени колонки
        for (const pattern of this.sensitiveDataPatterns) {
            if (pattern.test(name)) {
                return true;
            }
        }
        
        // Проверка по типу данных
        if (type.includes('text') || type.includes('varchar')) {
            // Текстовые поля могут содержать чувствительные данные
            return true;
        }
        
        return false;
    }
    
    async isTableContainsSensitiveData(tableName) {
        // Проверка, содержит ли таблица чувствительные данные
        const columns = await this.getTableColumns(tableName);
        
        return columns.some(col => this.isSensitiveDataColumn(col.name, col.type));
    }
    
    async isTableEncrypted(tableName) {
        // Проверка, зашифрована ли вся таблица
        try {
            const result = await this.db.query(`
                SELECT * FROM information_schema.tables 
                WHERE table_name = ? AND encryption = 'Y'
            `, [tableName]);
            
            return result.rows.length > 0;
        } catch {
            return false;
        }
    }
    
    async getTableEncryptionType(tableName) {
        try {
            const result = await this.db.query(`
                SELECT encryption_type 
                FROM information_schema.tables 
                WHERE table_name = ? AND encryption = 'Y'
            `, [tableName]);
            
            return result.rows[0]?.encryption_type || null;
        } catch {
            return null;
        }
    }
    
    generateEncryptionRecommendations(results) {
        const recommendations = [];
        
        if (!results.dataAtRest.overallEncryption) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Enable Data at Rest Encryption',
                description: 'Database does not have encryption at rest enabled',
                action: 'Configure TDE (Transparent Data Encryption) or similar feature'
            });
        }
        
        if (!results.dataInTransit.secure) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Improve Data in Transit Encryption',
                description: 'Connection encryption is not properly configured',
                action: 'Enable SSL/TLS with strong ciphers and TLS 1.2+'
            });
        }
        
        if (!results.keyManagement.secure) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Key Management',
                description: 'Key management practices need improvement',
                action: 'Implement proper key rotation, storage, and access controls'
            });
        }
        
        const unencryptedSensitive = results.columnEncryption.filter(col => 
            col.isSensitive && !col.isEncrypted
        );
        
        if (unencryptedSensitive.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Encrypt Sensitive Data Columns',
                description: `Found ${unencryptedSensitive.length} sensitive columns without encryption`,
                action: 'Implement column-level encryption for sensitive data',
                affectedColumns: unencryptedSensitive.map(col => `${col.tableName}.${col.columnName}`)
            });
        }
        
        return recommendations;
    }
    
    async generateEncryptionReport() {
        const results = await this.testDatabaseEncryption();
        
        return {
            timestamp: new Date().toISOString(),
            testResults: results,
            summary: {
                dataAtRestSecure: results.dataAtRest.overallEncryption,
                dataInTransitSecure: results.dataInTransit.secure,
                keyManagementSecure: results.keyManagement.secure,
                sensitiveDataEncrypted: this.calculateSensitiveDataEncryption(results),
                overallSecurityScore: this.calculateEncryptionSecurityScore(results)
            },
            recommendations: results.recommendations,
            compliance: this.checkEncryptionCompliance(results)
        };
    }
    
    calculateSensitiveDataEncryption(results) {
        const sensitiveColumns = results.columnEncryption.filter(col => col.isSensitive);
        const encryptedColumns = sensitiveColumns.filter(col => col.isEncrypted);
        
        return sensitiveColumns.length > 0 ? 
            (encryptedColumns.length / sensitiveColumns.length) * 100 : 100;
    }
    
    calculateEncryptionSecurityScore(results) {
        let score = 0;
        
        if (results.dataAtRest.overallEncryption) score += 25;
        if (results.dataInTransit.secure) score += 25;
        if (results.keyManagement.secure) score += 25;
        if (this.calculateSensitiveDataEncryption(results) === 100) score += 25;
        
        return score;
    }
    
    checkEncryptionCompliance(results) {
        return {
            pciDSS: this.checkPCIDSSCompliance(results),
            gdpr: this.checkGDPRCompliance(results),
            hipaa: this.checkHIPAACompliance(results),
            overall: this.calculateOverallEncryptionCompliance(results)
        };
    }
    
    checkPCIDSSCompliance(results) {
        // Проверка соответствия PCI DSS требованиям шифрования
        return results.dataAtRest.overallEncryption && 
               results.dataInTransit.secure && 
               results.keyManagement.secure;
    }
    
    checkGDPRCompliance(results) {
        // Проверка соответствия GDPR требованиям защиты персональных данных
        const sensitiveColsEncrypted = this.calculateSensitiveDataEncryption(results);
        return sensitiveColsEncrypted >= 95; // 95% чувствительных данных зашифрованы
    }
    
    checkHIPAACompliance(results) {
        // Проверка соответствия HIPAA требованиям защиты медицинских данных
        return results.dataAtRest.overallEncryption && 
               results.dataInTransit.secure;
    }
    
    calculateOverallEncryptionCompliance(results) {
        const checks = [
            results.dataAtRest.overallEncryption,
            results.dataInTransit.secure,
            results.keyManagement.secure,
            this.calculateSensitiveDataEncryption(results) >= 95
        ];
        
        const passed = checks.filter(Boolean).length;
        const total = checks.length;
        
        const complianceRate = (passed / total) * 100;
        
        if (complianceRate >= 90) return 'FULLY_COMPLIANT';
        if (complianceRate >= 70) return 'PARTIALLY_COMPLIANT';
        return 'NON_COMPLIANT';
    }
}

// Использование тестера шифрования
const encryptionTester = new DatabaseEncryptionTester(dbConnection);

async function runEncryptionTests() {
    const report = await encryptionTester.generateEncryptionReport();
    console.log('Database Encryption Test Report:', JSON.stringify(report, null, 2));
    return report;
}
```

## Лучшие практики управления пакетами

### 1. Политики безопасности

```javascript
// Система политики безопасности управления пакетами
class PackageSecurityPolicy {
    constructor() {
        this.policy = {
            // Политики версий
            versionPolicy: {
                allowMajorUpdates: false,
                requireSecurityPatches: true,
                maxAgeDays: 365,
                requireSignedPackages: true
            },
            
            // Политики источников
            sourcePolicy: {
                trustedRegistries: [
                    'https://registry.npmjs.org/',
                    'https://pkgs.dev.azure.com/',
                    process.env.PRIVATE_REGISTRY
                ],
                allowGitDependencies: false,
                allowTarballDependencies: false
            },
            
            // Политики лицензий
            licensePolicy: {
                allowedLicenses: [
                    'MIT',
                    'Apache-2.0',
                    'BSD-2-Clause',
                    'BSD-3-Clause',
                    'ISC',
                    'CC0-1.0'
                ],
                forbiddenLicenses: [
                    'GPL-2.0',
                    'GPL-3.0',
                    'AGPL-3.0',
                    'CC-BY-NC-4.0',
                    'CC-BY-NC-SA-4.0'
                ],
                requireApproval: [
                    'MPL-2.0',
                    'EPL-2.0',
                    'OSL-3.0'
                ]
            },
            
            // Политики безопасности
            securityPolicy: {
                maxCriticalVulnerabilities: 0,
                maxHighVulnerabilities: 5,
                auditLevel: 'moderate',
                requireSecurityReview: true
            },
            
            // Политики качества
            qualityPolicy: {
                minDownloads: 1000,
                minAgeDays: 30,
                requireDocumentation: true,
                requireTests: true
            }
        };
        
        this.enforcementEngine = new PolicyEnforcementEngine(this.policy);
    }
    
    async enforcePolicy() {
        const dependencies = await this.getProjectDependencies();
        const validationResults = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            validationResults[`${name}@${version}`] = await this.validatePackageAgainstPolicy({
                name,
                version,
                current: version
            });
        }
        
        const nonCompliant = Object.entries(validationResults)
            .filter(([, result]) => !result.compliant);
        
        if (nonCompliant.length > 0) {
            console.error(`Policy enforcement failed: ${nonCompliant.length} non-compliant dependencies`);
            
            for (const [pkg, result] of nonCompliant) {
                console.error(`Non-compliant package: ${pkg}`, result);
            }
            
            throw new Error('Policy enforcement failed');
        }
        
        console.log('All dependencies comply with security policy');
        return { success: true, validationResults };
    }
    
    async validatePackageAgainstPolicy(pkgInfo) {
        const validations = {
            version: await this.validateVersionPolicy(pkgInfo),
            source: await this.validateSourcePolicy(pkgInfo),
            license: await this.validateLicensePolicy(pkgInfo),
            security: await this.validateSecurityPolicy(pkgInfo),
            quality: await this.validateQualityPolicy(pkgInfo),
            overallCompliance: false
        };
        
        validations.overallCompliance = this.isOverallCompliant(validations);
        
        return validations;
    }
    
    async validateVersionPolicy(pkgInfo) {
        // Проверка политики версий
        const packageInfo = await this.getPackageInfo(pkgInfo.name);
        
        const isMajorUpdate = this.isMajorUpdate(pkgInfo.current, packageInfo['dist-tags']?.latest);
        
        if (isMajorUpdate && !this.policy.versionPolicy.allowMajorUpdates) {
            return {
                compliant: false,
                issues: ['Major version updates not allowed by policy'],
                severity: 'HIGH'
            };
        }
        
        // Проверка максимального возраста
        const age = await this.getPackageAge(packageInfo);
        if (age > this.policy.versionPolicy.maxAgeDays) {
            return {
                compliant: false,
                issues: [`Package is ${age} days old, exceeds maximum age of ${this.policy.versionPolicy.maxAgeDays}`],
                severity: 'MEDIUM'
            };
        }
        
        return { compliant: true, issues: [], severity: 'LOW' };
    }
    
    async validateSourcePolicy(pkgInfo) {
        const packageInfo = await this.getPackageInfo(pkgInfo.name);
        
        // Проверка источника
        if (packageInfo._resolved) {
            const registry = this.extractRegistry(packageInfo._resolved);
            
            if (!this.policy.sourcePolicy.trustedRegistries.includes(registry)) {
                return {
                    compliant: false,
                    issues: [`Package from untrusted registry: ${registry}`],
                    severity: 'HIGH'
                };
            }
        }
        
        // Проверка типа зависимости
        if (pkgInfo.specification.startsWith('git+') && !this.policy.sourcePolicy.allowGitDependencies) {
            return {
                compliant: false,
                issues: ['Git dependencies not allowed by policy'],
                severity: 'HIGH'
            };
        }
        
        if (pkgInfo.specification.startsWith('file:') && !this.policy.sourcePolicy.allowTarballDependencies) {
            return {
                compliant: false,
                issues: ['File/tarball dependencies not allowed by policy'],
                severity: 'HIGH'
            };
        }
        
        return { compliant: true, issues: [], severity: 'LOW' };
    }
    
    async validateLicensePolicy(pkgInfo) {
        const packageInfo = await this.getPackageInfo(pkgInfo.name);
        const license = this.extractLicense(packageInfo);
        
        if (!license) {
            return {
                compliant: false,
                issues: ['No license specified'],
                severity: 'MEDIUM'
            };
        }
        
        if (this.policy.licensePolicy.forbiddenLicenses.includes(license)) {
            return {
                compliant: false,
                issues: [`Forbidden license: ${license}`],
                severity: 'CRITICAL'
            };
        }
        
        if (this.policy.licensePolicy.requireApproval.includes(license)) {
            return {
                compliant: false,
                issues: [`License requires manual approval: ${license}`],
                severity: 'MEDIUM'
            };
        }
        
        if (!this.policy.licensePolicy.allowedLicenses.includes(license)) {
            return {
                compliant: false,
                issues: [`License not in allowed list: ${license}`],
                severity: 'HIGH'
            };
        }
        
        return { compliant: true, issues: [], severity: 'LOW' };
    }
    
    async validateSecurityPolicy(pkgInfo) {
        const vulnerabilities = await this.checkVulnerabilities(pkgInfo.name, pkgInfo.version);
        
        const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
        const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
        
        if (criticalCount > this.policy.securityPolicy.maxCriticalVulnerabilities) {
            return {
                compliant: false,
                issues: [`Too many critical vulnerabilities: ${criticalCount}`],
                severity: 'CRITICAL'
            };
        }
        
        if (highCount > this.policy.securityPolicy.maxHighVulnerabilities) {
            return {
                compliant: false,
                issues: [`Too many high vulnerabilities: ${highCount}`],
                severity: 'HIGH'
            };
        }
        
        return { compliant: true, issues: [], severity: 'LOW' };
    }
    
    async validateQualityPolicy(pkgInfo) {
        const packageInfo = await this.getPackageInfo(pkgInfo.name);
        
        const issues = [];
        
        // Проверка количества скачиваний
        if (packageInfo.downloads && packageInfo.downloads < this.policy.qualityPolicy.minDownloads) {
            issues.push(`Package has only ${packageInfo.downloads} downloads, minimum required: ${this.policy.qualityPolicy.minDownloads}`);
        }
        
        // Проверка возраста
        const age = await this.getPackageAge(packageInfo);
        if (age < this.policy.qualityPolicy.minAgeDays) {
            issues.push(`Package is only ${age} days old, minimum required: ${this.policy.qualityPolicy.minAgeDays}`);
        }
        
        // Проверка наличия документации
        if (this.policy.qualityPolicy.requireDocumentation && !packageInfo.readme) {
            issues.push('Package does not have README documentation');
        }
        
        return {
            compliant: issues.length === 0,
            issues,
            severity: issues.length > 0 ? 'MEDIUM' : 'LOW'
        };
    }
    
    isOverallCompliant(validationResults) {
        return Object.values(validationResults)
            .filter(result => typeof result === 'object' && result.hasOwnProperty('compliant'))
            .every(result => result.compliant);
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo) return null;
        
        if (typeof packageInfo.license === 'string') {
            return packageInfo.license;
        }
        
        if (typeof packageInfo.license === 'object' && packageInfo.license.type) {
            return packageInfo.license.type;
        }
        
        if (Array.isArray(packageInfo.licenses) && packageInfo.licenses[0]) {
            return typeof packageInfo.licenses[0] === 'string' ? 
                   packageInfo.licenses[0] : 
                   packageInfo.licenses[0].type;
        }
        
        return null;
    }
    
    extractRegistry(resolvedUrl) {
        try {
            const url = new URL(resolvedUrl);
            return `${url.protocol}//${url.host}`;
        } catch {
            return 'unknown';
        }
    }
    
    isMajorUpdate(current, target) {
        if (!current || !target) return false;
        
        const [cMajor] = current.replace('^', '').replace('~', '').split('.').map(Number);
        const [tMajor] = target.split('.').map(Number);
        
        return tMajor > cMajor;
    }
    
    async getPackageAge(packageInfo) {
        if (!packageInfo.time || !packageInfo['dist-tags']?.latest) return 0;
        
        const latestVersion = packageInfo['dist-tags'].latest;
        const publishTime = new Date(packageInfo.time[latestVersion]);
        const now = new Date();
        
        return Math.floor((now - publishTime) / (1000 * 60 * 60 * 24)); // в днях
    }
    
    async getPackageInfo(name) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            throw new Error(`Failed to get package info for ${name}: ${error.message}`);
        }
    }
    
    async checkVulnerabilities(name, version) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm audit --package ${name} --json`, { encoding: 'utf8' });
            const audit = JSON.parse(result);
            return audit.advisories ? Object.values(audit.advisories) : [];
        } catch (error) {
            if (error.stdout) {
                const audit = JSON.parse(error.stdout);
                return audit.advisories ? Object.values(audit.advisories) : [];
            }
            return [];
        }
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        return {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
    }
    
    async generatePolicyReport() {
        const dependencies = await this.getProjectDependencies();
        const validationResults = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            validationResults[`${name}@${version}`] = await this.validatePackageAgainstPolicy({
                name,
                version,
                current: version
            });
        }
        
        const report = {
            timestamp: new Date().toISOString(),
            policy: this.policy,
            validationResults,
            summary: {
                totalDependencies: Object.keys(dependencies).length,
                compliantDependencies: Object.values(validationResults).filter(r => r.overallCompliance).length,
                nonCompliantDependencies: Object.values(validationResults).filter(r => !r.overallCompliance).length,
                complianceRate: (Object.values(validationResults).filter(r => r.overallCompliance).length / Object.keys(dependencies).length) * 100
            },
            recommendations: this.generatePolicyRecommendations(validationResults)
        };
        
        return report;
    }
    
    generatePolicyRecommendations(validationResults) {
        const recommendations = [];
        
        const nonCompliant = Object.entries(validationResults)
            .filter(([, result]) => !result.overallCompliance);
        
        if (nonCompliant.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Non-Compliant Dependencies',
                description: `Found ${nonCompliant.length} non-compliant dependencies`,
                action: 'Review and replace non-compliant packages',
                affectedPackages: nonCompliant.map(([pkg]) => pkg)
            });
        }
        
        const criticalIssues = nonCompliant.filter(([, result]) => 
            result.license?.severity === 'CRITICAL' || 
            result.security?.severity === 'CRITICAL'
        );
        
        if (criticalIssues.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Remove Critical Security/License Issues',
                description: `Found ${criticalIssues.length} packages with critical issues`,
                action: 'Remove or replace packages with critical vulnerabilities immediately',
                affectedPackages: criticalIssues.map(([pkg]) => pkg)
            });
        }
        
        return recommendations;
    }
}

// Использование системы политики безопасности
const policyManager = new PackageSecurityPolicy();

async function runPolicyEnforcement() {
    try {
        const report = await policyManager.generatePolicyReport();
        console.log('Package Security Policy Report:', JSON.stringify(report, null, 2));
        
        if (report.summary.complianceRate < 100) {
            console.error('Policy compliance check failed');
            process.exit(1);
        }
        
        console.log('All packages comply with security policy');
    } catch (error) {
        console.error('Policy enforcement failed:', error.message);
        process.exit(1);
    }
}

// Запуск проверки политики
if (require.main === module) {
    runPolicyEnforcement().catch(console.error);
}
```

### 2. Автоматизация управления зависимостями

```javascript
// Система автоматического управления зависимостями
class AutomatedDependencyManager {
    constructor(config) {
        this.config = {
            autoUpdate: config.autoUpdate || false,
            updateSchedule: config.updateSchedule || 'daily',
            securityOnly: config.securityOnly || true,
            testBeforeUpdate: config.testBeforeUpdate || true,
            backupBeforeUpdate: config.backupBeforeUpdate || true,
            ...config
        };
        
        this.updateQueue = [];
        this.updateHistory = [];
        this.securityChecker = new SecurityChecker();
        this.policyEnforcer = new PackageSecurityPolicy();
    }
    
    async scheduleUpdates() {
        if (!this.config.autoUpdate) return;
        
        const interval = this.getUpdateInterval(this.config.updateSchedule);
        
        setInterval(async () => {
            await this.performScheduledUpdate();
        }, interval);
    }
    
    getUpdateInterval(schedule) {
        const intervals = {
            'hourly': 60 * 60 * 1000,
            'daily': 24 * 60 * 60 * 1000,
            'weekly': 7 * 24 * 60 * 60 * 1000,
            'monthly': 30 * 24 * 60 * 60 * 1000
        };
        
        return intervals[schedule] || intervals['daily'];
    }
    
    async performScheduledUpdate() {
        console.log('Starting scheduled dependency update...');
        
        try {
            // Создание бэкапа
            if (this.config.backupBeforeUpdate) {
                await this.createBackup();
            }
            
            // Проверка обновлений
            const updates = await this.checkForUpdates();
            
            // Фильтрация обновлений по типу
            const updatesToApply = this.filterUpdates(updates);
            
            if (updatesToApply.length > 0) {
                console.log(`Found ${updatesToApply.length} updates to apply`);
                
                for (const update of updatesToApply) {
                    await this.applyUpdate(update);
                }
                
                // Запуск тестов после обновлений
                if (this.config.testBeforeUpdate) {
                    await this.runTests();
                }
                
                // Коммит обновлений
                await this.commitUpdates(updatesToApply);
            } else {
                console.log('No updates to apply');
            }
            
        } catch (error) {
            console.error('Scheduled update failed:', error);
            await this.handleUpdateError(error);
        }
    }
    
    async checkForUpdates() {
        const { execSync } = require('child_process');
        
        try {
            const outdatedResult = execSync('npm outdated --json', { encoding: 'utf8' });
            const outdated = JSON.parse(outdatedResult);
            
            const updates = [];
            
            for (const [name, info] of Object.entries(outdated)) {
                updates.push({
                    name,
                    current: info.current,
                    wanted: info.wanted,
                    latest: info.latest,
                    location: info.location,
                    type: this.getUpdateType(info.current, info.wanted),
                    security: await this.securityChecker.hasSecurityUpdate(name, info.current, info.wanted)
                });
            }
            
            return updates;
        } catch (error) {
            console.error('Failed to check for updates:', error.message);
            return [];
        }
    }
    
    getUpdateType(current, wanted) {
        const [cMajor, cMinor, cPatch] = current.replace('^', '').replace('~', '').split('.').map(Number);
        const [wMajor, wMinor, wPatch] = wanted.split('.').map(Number);
        
        if (wMajor > cMajor) return 'major';
        if (wMinor > cMinor) return 'minor';
        if (wPatch > cPatch) return 'patch';
        return 'unknown';
    }
    
    filterUpdates(updates) {
        if (this.config.securityOnly) {
            // Только обновления безопасности
            return updates.filter(update => update.security.hasUpdate);
        }
        
        // Все обновления, соответствующие политике
        return updates.filter(update => {
            if (update.type === 'major' && !this.config.allowMajorUpdates) {
                return false;
            }
            if (update.type === 'minor' && !this.config.allowMinorUpdates) {
                return false;
            }
            if (update.type === 'patch' && !this.config.allowPatchUpdates) {
                return false;
            }
            
            return true;
        });
    }
    
    async applyUpdate(update) {
        const { execSync } = require('child_process');
        
        try {
            console.log(`Updating ${update.name} from ${update.current} to ${update.wanted}...`);
            
            // Обновление пакета
            execSync(`npm install ${update.name}@${update.wanted}`, {
                stdio: 'inherit',
                cwd: process.cwd()
            });
            
            // Проверка безопасности после обновления
            const postUpdateCheck = await this.securityChecker.checkPackage(update.name, update.wanted);
            if (postUpdateCheck.vulnerabilities.length > 0) {
                console.warn(`Security issues still present after update: ${update.name}`);
            }
            
            // Проверка политики после обновления
            const policyCheck = await this.policyEnforcer.validatePackageAgainstPolicy({
                name: update.name,
                version: update.wanted
            });
            
            if (!policyCheck.overallCompliance) {
                console.warn(`Policy violation after update: ${update.name}`);
            }
            
            // Запись в историю
            this.updateHistory.push({
                package: update.name,
                from: update.current,
                to: update.wanted,
                timestamp: new Date().toISOString(),
                securityUpdate: update.security.hasUpdate,
                policyCompliant: policyCheck.overallCompliance
            });
            
            console.log(`Successfully updated ${update.name}`);
            
        } catch (error) {
            console.error(`Failed to update ${update.name}:`, error.message);
            throw error;
        }
    }
    
    async runTests() {
        const { execSync } = require('child_process');
        
        try {
            console.log('Running tests after updates...');
            execSync('npm test', { stdio: 'inherit', cwd: process.cwd() });
            console.log('All tests passed after updates');
        } catch (error) {
            console.error('Tests failed after updates:', error.message);
            throw new Error('Tests failed after dependency updates');
        }
    }
    
    async commitUpdates(updates) {
        const { execSync } = require('child_process');
        
        try {
            // Добавить измененные файлы
            execSync('git add package-lock.json', { stdio: 'inherit' });
            
            // Сделать коммит
            const updateSummary = updates.map(u => `${u.name}: ${u.current} → ${u.wanted}`).join(', ');
            execSync(`git commit -m "chore: Update dependencies for security - ${updateSummary}"`, {
                stdio: 'inherit'
            });
            
            // Запушить изменения
            execSync('git push', { stdio: 'inherit' });
            
            console.log('Updates committed and pushed successfully');
        } catch (error) {
            console.error('Failed to commit updates:', error.message);
        }
    }
    
    async createBackup() {
        const fs = require('fs');
        const path = require('path');
        
        const backupDir = path.join(process.cwd(), 'backups');
        if (!fs.existsSync(backupDir)) {
            fs.mkdirSync(backupDir, { recursive: true });
        }
        
        const timestamp = Date.now();
        const backupName = `deps-backup-${timestamp}`;
        const backupPath = path.join(backupDir, backupName);
        
        fs.copyFileSync('package.json', path.join(backupPath, 'package.json'));
        fs.copyFileSync('package-lock.json', path.join(backupPath, 'package-lock.json'));
        
        console.log(`Backup created at: ${backupPath}`);
    }
    
    async handleUpdateError(error) {
        console.error('Update error occurred:', error.message);
        
        // В реальности отправка уведомления в систему мониторинга
        if (process.env.SECURITY_ALERT_WEBHOOK) {
            try {
                await fetch(process.env.SECURITY_ALERT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: `Dependency update failed: ${error.message}`,
                        attachments: [{
                            color: 'danger',
                            fields: [
                                { title: 'Error', value: error.message, short: false }
                            ]
                        }]
                    })
                });
            } catch (webhookError) {
                console.error('Failed to send security alert:', webhookError);
            }
        }
    }
    
    async getUpdateStatistics() {
        const stats = {
            totalUpdates: this.updateHistory.length,
            securityUpdates: this.updateHistory.filter(u => u.securityUpdate).length,
            policyCompliantUpdates: this.updateHistory.filter(u => u.policyCompliant).length,
            successRate: this.updateHistory.length > 0 ? 
                (this.updateHistory.filter(u => u.policyCompliant).length / this.updateHistory.length) * 100 : 0,
            recentUpdates: this.updateHistory.slice(-10)
        };
        
        return stats;
    }
    
    async generateUpdateReport() {
        const stats = await this.getUpdateStatistics();
        
        return {
            timestamp: new Date().toISOString(),
            statistics: stats,
            updateHistory: this.updateHistory,
            recommendations: this.generateUpdateRecommendations(stats)
        };
    }
    
    generateUpdateRecommendations(stats) {
        const recommendations = [];
        
        if (stats.successRate < 80) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Improve Update Success Rate',
                description: `Only ${stats.successRate.toFixed(2)}% of updates are policy compliant`,
                action: 'Review update process and policy requirements'
            });
        }
        
        if (stats.securityUpdates === 0 && this.config.securityOnly) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'No Security Updates Applied',
                description: 'No security updates were applied in the last cycle',
                action: 'Verify security update detection is working'
            });
        }
        
        return recommendations;
    }
}

// Использование автоматического менеджера зависимостей
const autoManager = new AutomatedDependencyManager({
    autoUpdate: true,
    updateSchedule: 'daily',
    securityOnly: true,
    testBeforeUpdate: true,
    backupBeforeUpdate: true
});

// Запуск автоматических обновлений
autoManager.scheduleUpdates().catch(console.error);
```

## Тестирование безопасности управления пакетами

### 1. Автоматизированные тесты

```javascript
// Тесты для системы управления пакетами
describe('Package Management Security', () => {
    let packageManager;
    let policyManager;
    
    beforeEach(() => {
        packageManager = new SecurePackageManager();
        policyManager = new PackageSecurityPolicy();
    });
    
    test('should validate package against security policy', async () => {
        const packageInfo = {
            name: 'safe-package',
            version: '1.0.0',
            license: 'MIT'
        };
        
        const result = await policyManager.validatePackageAgainstPolicy(packageInfo);
        
        expect(result.overallCompliance).toBe(true);
        expect(result.license.compliant).toBe(true);
        expect(result.security.compliant).toBe(true);
    });
    
    test('should reject package with forbidden license', async () => {
        const packageInfo = {
            name: 'forbidden-license-package',
            version: '1.0.0',
            license: 'GPL-3.0'
        };
        
        const result = await policyManager.validatePackageAgainstPolicy(packageInfo);
        
        expect(result.overallCompliance).toBe(false);
        expect(result.license.compliant).toBe(false);
        expect(result.license.issues).toContainEqual(
            expect.objectContaining({ severity: 'CRITICAL' })
        );
    });
    
    test('should detect vulnerable packages', async () => {
        const packageInfo = {
            name: 'vulnerable-package',
            version: '1.0.0'
        };
        
        // Mock vulnerable package
        const result = await packageManager.checkVulnerabilities(packageInfo.name, packageInfo.version);
        
        expect(Array.isArray(result)).toBe(true);
        expect(result.length).toBeGreaterThanOrEqual(0);
    });
    
    test('should enforce version policy', async () => {
        const packageInfo = {
            name: 'test-package',
            current: '1.0.0',
            target: '2.0.0' // major update
        };
        
        const result = await policyManager.validateVersionPolicy(packageInfo);
        
        expect(result.compliant).toBe(false);
        expect(result.issues).toContain('Major version updates not allowed by policy');
    });
    
    test('should validate source policy', async () => {
        const packageInfo = {
            name: 'trusted-package',
            specification: 'git+https://github.com/trusted/repo.git'
        };
        
        const result = await policyManager.validateSourcePolicy(packageInfo);
        
        expect(result.compliant).toBe(false); // git dependencies not allowed
        expect(result.issues).toContain('Git dependencies not allowed by policy');
    });
    
    test('should handle policy compliance report', async () => {
        const report = await policyManager.generatePolicyReport();
        
        expect(report).toHaveProperty('timestamp');
        expect(report).toHaveProperty('policy');
        expect(report).toHaveProperty('summary');
        expect(report.summary).toHaveProperty('totalDependencies');
        expect(report.summary).toHaveProperty('compliantDependencies');
        expect(report.summary).toHaveProperty('complianceRate');
    });
    
    test('should implement automated updates', async () => {
        const autoManager = new AutomatedDependencyManager({
            autoUpdate: false, // не запускать на самом деле
            securityOnly: true
        });
        
        // Тестирование фильтрации обновлений
        const mockUpdates = [
            { name: 'safe-pkg', current: '1.0.0', wanted: '1.1.0', security: { hasUpdate: false } },
            { name: 'vuln-pkg', current: '1.0.0', wanted: '1.2.0', security: { hasUpdate: true } }
        ];
        
        const filtered = autoManager.filterUpdates(mockUpdates);
        
        expect(filtered.length).toBe(1);
        expect(filtered[0].name).toBe('vuln-pkg');
    });
    
    test('should validate quality policy', async () => {
        const packageInfo = {
            name: 'new-package',
            version: '1.0.0'
        };
        
        const result = await policyManager.validateQualityPolicy(packageInfo);
        
        // Новый пакет может не соответствовать политике качества
        expect(result).toHaveProperty('compliant');
        expect(result).toHaveProperty('issues');
    });
    
    test('should check package age correctly', async () => {
        const mockPackageInfo = {
            time: {
                '1.0.0': new Date(Date.now() - 1000 * 60 * 60 * 24 * 365).toISOString() // 1 год назад
            },
            'dist-tags': { latest: '1.0.0' }
        };
        
        const age = await policyManager.getPackageAge(mockPackageInfo);
        
        expect(age).toBe(365); // 365 дней
    });
    
    test('should handle policy exceptions', async () => {
        // Тестирование исключений из политики для конкретных пакетов
        const exceptions = {
            'known-safe-but-not-in-list': {
                license: 'APACHE-2.0', // лицензия не в белом списке
                approvedUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // одобрено на 30 дней
            }
        };
        
        // Реализация будет зависеть от конкретной логики обработки исключений
        expect(exceptions).toBeDefined();
    });
});

// Интеграционные тесты
describe('Integration: Package Security Pipeline', () => {
    test('should run complete security pipeline', async () => {
        const pipeline = new SecurityPipeline();
        
        const results = await pipeline.runCompleteSecurityCheck();
        
        expect(results).toHaveProperty('validation');
        expect(results).toHaveProperty('vulnerabilityCheck');
        expect(results).toHaveProperty('licenseCheck');
        expect(results).toHaveProperty('policyEnforcement');
        expect(results).toHaveProperty('finalReport');
        
        // Проверка, что политика соблюдена
        expect(results.policyEnforcement.compliant).toBe(true);
    });
    
    test('should handle security incidents', async () => {
        const securitySystem = new SecurityIncidentHandler();
        
        const incident = {
            type: 'SECURITY_VULNERABILITY',
            package: 'compromised-package',
            severity: 'CRITICAL',
            timestamp: new Date().toISOString()
        };
        
        const response = await securitySystem.handleIncident(incident);
        
        expect(response).toHaveProperty('status');
        expect(response).toHaveProperty('actionsTaken');
        expect(response.status).toBe('RESOLVED');
    });
    
    test('should generate comprehensive security report', async () => {
        const reporter = new SecurityReporter();
        
        const report = await reporter.generateComprehensiveReport();
        
        expect(report).toHaveProperty('metadata');
        expect(report).toHaveProperty('findings');
        expect(report).toHaveProperty('recommendations');
        expect(report).toHaveProperty('compliance');
        expect(report.metadata).toHaveProperty('timestamp');
        expect(report.findings).toHaveProperty('total');
        expect(report.recommendations).toHaveProperty('length');
    });
});

// Тестирование производительности
describe('Performance: Package Security Operations', () => {
    test('should validate large number of packages efficiently', async () => {
        const policyManager = new PackageSecurityPolicy();
        
        // Симуляция большого количества пакетов
        const largePackageList = Array.from({ length: 100 }, (_, i) => ({
            name: `package-${i}`,
            version: '1.0.0',
            license: 'MIT'
        }));
        
        const startTime = Date.now();
        
        const validationPromises = largePackageList.map(pkg => 
            policyManager.validatePackageAgainstPolicy(pkg)
        );
        
        const results = await Promise.all(validationPromises);
        
        const executionTime = Date.now() - startTime;
        
        // Проверка, что время выполнения разумное
        expect(executionTime).toBeLessThan(30000); // 30 секунд для 100 пакетов
        
        // Проверка, что все результаты валидны
        expect(results.length).toBe(100);
        expect(results.every(r => r !== undefined)).toBe(true);
    });
    
    test('should handle concurrent security checks', async () => {
        const securityChecker = new SecurityChecker();
        
        const concurrentChecks = Array.from({ length: 10 }, (_, i) => 
            securityChecker.checkPackage(`test-package-${i}`, '1.0.0')
        );
        
        const results = await Promise.allSettled(concurrentChecks);
        
        const successful = results.filter(r => r.status === 'fulfilled').length;
        const failed = results.filter(r => r.status === 'rejected').length;
        
        expect(successful + failed).toBe(10);
        expect(successful).toBeGreaterThanOrEqual(5); // хотя бы половина должна пройти
    });
    
    test('should manage memory efficiently during bulk operations', async () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        // Выполнение массовой проверки
        const largeCheck = new LargeScaleSecurityChecker();
        await largeCheck.performBulkCheck(500); // 500 пакетов
        
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryGrowth = finalMemory - initialMemory;
        
        // Рост памяти не должен быть чрезмерным
        expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024); // 50MB
    });
});

// Вспомогательные функции для тестов
function createMockPackageInfo(name, version, license = 'MIT') {
    return {
        name,
        version,
        license,
        downloads: 10000,
        age: 30,
        maintainers: ['maintainer@example.com'],
        repository: { url: `https://github.com/example/${name}` }
    };
}

function simulateVulnerablePackage() {
    return {
        name: 'vulnerable-package',
        version: '1.0.0',
        vulnerabilities: [
            {
                id: 'CVE-2023-1234',
                severity: 'CRITICAL',
                title: 'Remote Code Execution',
                description: 'Arbitrary code execution vulnerability'
            }
        ]
    };
}

function simulateForbiddenLicense() {
    return {
        name: 'forbidden-license-package',
        version: '1.0.0',
        license: 'AGPL-3.0'
    };
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Инструменты-аудита-безопасности]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]