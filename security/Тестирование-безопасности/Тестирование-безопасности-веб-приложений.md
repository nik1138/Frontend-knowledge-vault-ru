---
aliases: ["Тестирование безопасности веб-приложений", "Web Application Security Testing", "WAST"]
tags: ["#security", "#web-security", "#security-testing", "#pentesting"]
---

# Тестирование безопасности веб-приложений

## Введение

Тестирование безопасности веб-приложений (WAST) - это процесс систематической проверки веб-приложений на наличие уязвимостей и недостатков в системе безопасности. Это критически важный этап в обеспечении безопасности веб-приложений, позволяющий выявить и устранить потенциальные угрозы до их эксплуатации злоумышленниками.

## Методологии тестирования

### 1. OWASP Testing Guide

#### Фазы тестирования по OWASP

```javascript
// Структура тестирования по OWASP Testing Guide
class OWASPTestingGuide {
    constructor() {
        this.testingPhases = [
            {
                phase: 'Information Gathering',
                tests: [
                    'Identify application entry points',
                    'Map application architecture',
                    'Identify technologies used',
                    'Discover hidden content',
                    'Map execution paths'
                ],
                tools: ['Burp Suite', 'Nmap', 'Dirbuster', 'WhatWeb']
            },
            {
                phase: 'Configuration and Deploy Management Testing',
                tests: [
                    'Test network infrastructure configuration',
                    'Test application platform configuration',
                    'Test file extensions handling',
                    'Backup and unreferenced files',
                    'Infrastructure and application admin interfaces'
                ],
                tools: ['Nikto', 'Nmap', 'OWASP ZAP']
            },
            {
                phase: 'Identity Management Testing',
                tests: [
                    'Test user registration process',
                    'Test account provisioning process',
                    'Account enumeration',
                    'Weak username policy'
                ],
                tools: ['Burp Suite', 'OWASP ZAP']
            },
            {
                phase: 'Authentication Testing',
                tests: [
                    'Credential transport',
                    'Default credentials',
                    'Brute force protection',
                    'User enumeration',
                    'Password quality',
                    'Remember me functionality',
                    'Logout functionality',
                    'Password reset mechanisms'
                ],
                tools: ['Hydra', 'Medusa', 'Burp Suite']
            },
            {
                phase: 'Authorization Testing',
                tests: [
                    'Directory traversal',
                    'Bypass authorization schema',
                    'Privilege escalation',
                    'Horizontal privilege escalation'
                ],
                tools: ['Burp Suite', 'OWASP ZAP']
            },
            {
                phase: 'Session Management Testing',
                tests: [
                    'Session token generation',
                    'Session fixation',
                    'Session timeout',
                    'Cross-site request forgery'
                ],
                tools: ['Burp Suite', 'OWASP ZAP']
            },
            {
                phase: 'Input Validation Testing',
                tests: [
                    'Reflected XSS',
                    'Stored XSS',
                    'DOM-based XSS',
                    'SQL injection',
                    'LDAP injection',
                    'ORM injection',
                    'XPath injection',
                    'SSI injection',
                    'Command injection',
                    'Buffer overflow',
                    'Path traversal',
                    'Application logic data validation'
                ],
                tools: ['SQLMap', 'XSStrike', 'Burp Suite']
            },
            {
                phase: 'Testing for Error Handling',
                tests: [
                    'Stack traces',
                    'Error codes',
                    'SQL errors',
                    'Generic error messages'
                ],
                tools: ['OWASP ZAP', 'Burp Suite']
            },
            {
                phase: 'Testing for Weak Cryptography',
                tests: [
                    'Weak SSL/TLS protocols',
                    'Weak algorithms',
                    'Weak keys',
                    'Inadequate entropy'
                ],
                tools: ['SSLyze', 'TestSSL', 'Nmap']
            },
            {
                phase: 'Business Logic Testing',
                tests: [
                    'Workflow bypass',
                    'Data validation',
                    'Anti-automation',
                    'Process timing'
                ],
                tools: ['Manual testing', 'Burp Suite']
            },
            {
                phase: 'Client Side Testing',
                tests: [
                    'Cross-origin resource sharing',
                    'HTML5 security features',
                    'WebSockets security',
                    'Client-side resource manipulation'
                ],
                tools: ['OWASP ZAP', 'Browser developer tools']
            }
        ];
    }
    
    async performOWASPTesting(target) {
        const results = {
            target: target,
            phases: [],
            findings: [],
            vulnerabilities: [],
            recommendations: []
        };
        
        for (const phase of this.testingPhases) {
            console.log(`Testing phase: ${phase.phase}`);
            
            const phaseResult = {
                phase: phase.phase,
                tests: [],
                findings: [],
                toolsUsed: phase.tools
            };
            
            for (const test of phase.tests) {
                const testResult = await this.executeTest(test, target, phase.tools);
                phaseResult.tests.push(testResult);
                
                if (testResult.findings.length > 0) {
                    phaseResult.findings.push(...testResult.findings);
                    results.findings.push(...testResult.findings);
                }
            }
            
            results.phases.push(phaseResult);
        }
        
        results.vulnerabilities = await this.analyzeFindings(results.findings);
        results.recommendations = await this.generateRecommendations(results.vulnerabilities);
        
        return results;
    }
    
    async executeTest(test, target, tools) {
        // В реальности здесь будет выполнение конкретного теста
        // с использованием указанных инструментов
        
        // Пример реализации для одного теста
        const testResults = {
            testName: test,
            status: 'PENDING',
            findings: [],
            toolsUsed: tools,
            evidence: [],
            timestamp: new Date().toISOString()
        };
        
        try {
            // Выполнение теста в зависимости от типа
            if (test.includes('XSS')) {
                testResults.findings = await this.testForXSS(target);
            } else if (test.includes('SQL')) {
                testResults.findings = await this.testForSQLInjection(target);
            } else if (test.includes('Authentication')) {
                testResults.findings = await this.testAuthentication(target);
            } else if (test.includes('Authorization')) {
                testResults.findings = await this.testAuthorization(target);
            } else {
                // Для других тестов - заглушка
                testResults.status = 'SKIPPED';
                testResults.findings = [];
            }
            
            testResults.status = testResults.findings.length > 0 ? 'VULNERABLE' : 'SECURE';
        } catch (error) {
            testResults.status = 'ERROR';
            testResults.error = error.message;
        }
        
        return testResults;
    }
    
    async testForXSS(target) {
        const xssPayloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>'
        ];
        
        const findings = [];
        
        // В реальности здесь будет отправка пейлоадов и проверка ответов
        // Примерная реализация:
        for (const payload of xssPayloads) {
            try {
                // Проверка на наличие пейлоада в ответе
                const response = await this.sendTestRequest(target, payload);
                
                if (response.body.includes(payload)) {
                    findings.push({
                        type: 'XSS',
                        severity: 'HIGH',
                        payload: payload,
                        location: 'Response body',
                        evidence: `Payload reflected in response: ${payload}`,
                        cvssScore: 7.5,
                        cweId: 'CWE-79'
                    });
                }
            } catch (error) {
                console.error(`Error testing XSS with payload ${payload}:`, error);
            }
        }
        
        return findings;
    }
    
    async testForSQLInjection(target) {
        const sqlPayloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL, NULL, NULL --",
            "'; DROP TABLE users; --",
            "admin'--",
            "1' AND 1=1--"
        ];
        
        const findings = [];
        
        for (const payload of sqlPayloads) {
            try {
                const response = await this.sendTestRequest(target, payload);
                
                // Проверка на признаки SQL-ошибок
                const sqlErrorPatterns = [
                    /SQL syntax/,
                    /mysql/i,
                    /postgresql/i,
                    /ora-/i,
                    /sqlite/i
                ];
                
                for (const pattern of sqlErrorPatterns) {
                    if (pattern.test(response.body)) {
                        findings.push({
                            type: 'SQL Injection',
                            severity: 'CRITICAL',
                            payload: payload,
                            location: 'Response body',
                            evidence: `SQL error detected: ${response.body.substring(0, 200)}`,
                            cvssScore: 9.8,
                            cweId: 'CWE-89'
                        });
                        break;
                    }
                }
            } catch (error) {
                console.error(`Error testing SQL injection with payload ${payload}:`, error);
            }
        }
        
        return findings;
    }
    
    async testAuthentication(target) {
        const findings = [];
        
        // Проверка на дефолтные учетные данные
        const defaultCredentials = [
            { username: 'admin', password: 'admin' },
            { username: 'admin', password: 'password' },
            { username: 'root', password: 'root' },
            { username: 'test', password: 'test' }
        ];
        
        for (const cred of defaultCredentials) {
            try {
                const response = await this.attemptLogin(target, cred);
                
                if (response.success) {
                    findings.push({
                        type: 'Default Credentials',
                        severity: 'CRITICAL',
                        credential: cred,
                        evidence: 'Successfully logged in with default credentials',
                        cvssScore: 9.8,
                        cweId: 'CWE-798'
                    });
                }
            } catch (error) {
                console.error(`Error testing default credentials ${cred}:`, error);
            }
        }
        
        // Проверка на отсутствие ограничения попыток
        const bruteForceTest = await this.testBruteForceProtection(target);
        if (bruteForceTest.vulnerable) {
            findings.push({
                type: 'Brute Force Vulnerability',
                severity: 'MEDIUM',
                evidence: 'No rate limiting detected for authentication',
                cvssScore: 5.0,
                cweId: 'CWE-307'
            });
        }
        
        return findings;
    }
    
    async testAuthorization(target) {
        const findings = [];
        
        // Проверка на горизонтальное эскалирование привилегий
        const horizontalPrivilegeTests = await this.testHorizontalPrivilegeEscalation(target);
        if (horizontalPrivilegeTests.vulnerable) {
            findings.push({
                type: 'Horizontal Privilege Escalation',
                severity: 'HIGH',
                evidence: 'Access to other users\' resources detected',
                cvssScore: 7.5,
                cweId: 'CWE-285'
            });
        }
        
        // Проверка на вертикальное эскалирование привилегий
        const verticalPrivilegeTests = await this.testVerticalPrivilegeEscalation(target);
        if (verticalPrivilegeTests.vulnerable) {
            findings.push({
                type: 'Vertical Privilege Escalation',
                severity: 'CRITICAL',
                evidence: 'Access to administrative functions detected',
                cvssScore: 9.1,
                cweId: 'CWE-285'
            });
        }
        
        return findings;
    }
    
    async sendTestRequest(target, payload) {
        // В реальности использовать безопасный HTTP клиент
        // для отправки тестовых запросов
        
        // Заглушка для примера
        return {
            status: 200,
            body: `Response with ${payload} reflected`,
            headers: {}
        };
    }
    
    async attemptLogin(target, credentials) {
        // Заглушка для попытки логина
        return {
            success: false,
            status: 401
        };
    }
    
    async testBruteForceProtection(target) {
        // Заглушка для тестирования защиты от брутфорса
        return {
            vulnerable: false,
            attempts: 0
        };
    }
    
    async testHorizontalPrivilegeEscalation(target) {
        // Заглушка для тестирования горизонтального эскалирования
        return {
            vulnerable: false
        };
    }
    
    async testVerticalPrivilegeEscalation(target) {
        // Заглушка для тестирования вертикального эскалирования
        return {
            vulnerable: false
        };
    }
    
    async analyzeFindings(findings) {
        const vulnerabilities = [];
        
        for (const finding of findings) {
            const vulnerability = {
                ...finding,
                id: this.generateVulnerabilityId(),
                status: 'NEW',
                assignedTo: 'security-team',
                priority: this.calculatePriority(finding),
                remediationDifficulty: this.estimateRemediationDifficulty(finding),
                businessImpact: this.assessBusinessImpact(finding)
            };
            
            vulnerabilities.push(vulnerability);
        }
        
        return vulnerabilities;
    }
    
    generateVulnerabilityId() {
        return `VULN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    calculatePriority(finding) {
        const severityScores = {
            'INFO': 1,
            'LOW': 2,
            'MEDIUM': 3,
            'HIGH': 4,
            'CRITICAL': 5
        };
        
        const severityScore = severityScores[finding.severity] || 3;
        const cvssScore = finding.cvssScore || 0;
        
        // Комбинированный расчет приоритета
        return Math.round((severityScore * 0.4) + (cvssScore * 0.6));
    }
    
    estimateRemediationDifficulty(finding) {
        const difficultyMapping = {
            'XSS': 'MEDIUM',
            'SQL Injection': 'MEDIUM',
            'Default Credentials': 'LOW',
            'Brute Force Vulnerability': 'LOW',
            'Horizontal Privilege Escalation': 'HIGH',
            'Vertical Privilege Escalation': 'HIGH'
        };
        
        return difficultyMapping[finding.type] || 'MEDIUM';
    }
    
    assessBusinessImpact(finding) {
        const impactMapping = {
            'CRITICAL': 'HIGH',
            'HIGH': 'HIGH',
            'MEDIUM': 'MEDIUM',
            'LOW': 'LOW'
        };
        
        return impactMapping[finding.severity] || 'MEDIUM';
    }
    
    async generateRecommendations(vulnerabilities) {
        const recommendations = [];
        
        for (const vuln of vulnerabilities) {
            const recommendation = {
                vulnerabilityId: vuln.id,
                type: vuln.type,
                recommendation: this.getRecommendationForType(vuln.type),
                implementationGuidance: this.getImplementationGuidance(vuln.type),
                estimatedTime: this.estimateImplementationTime(vuln.type),
                priority: vuln.priority
            };
            
            recommendations.push(recommendation);
        }
        
        return recommendations;
    }
    
    getRecommendationForType(type) {
        const recommendations = {
            'XSS': 'Implement proper output encoding and input validation',
            'SQL Injection': 'Use parameterized queries or prepared statements',
            'Default Credentials': 'Remove or change default credentials',
            'Brute Force Vulnerability': 'Implement rate limiting and account lockout mechanisms',
            'Horizontal Privilege Escalation': 'Implement proper access controls and authorization checks',
            'Vertical Privilege Escalation': 'Implement proper role-based access control'
        };
        
        return recommendations[type] || 'Review and implement appropriate security controls';
    }
    
    getImplementationGuidance(type) {
        const guidance = {
            'XSS': [
                'Use frameworks that automatically encode output',
                'Implement Content Security Policy (CSP)',
                'Validate and sanitize all user inputs'
            ],
            'SQL Injection': [
                'Use parameterized queries',
                'Avoid dynamic SQL construction',
                'Implement input validation'
            ],
            'Default Credentials': [
                'Force password change on first login',
                'Remove default accounts',
                'Implement strong password policies'
            ]
        };
        
        return guidance[type] || ['Consult security best practices documentation'];
    }
    
    estimateImplementationTime(type) {
        const timeEstimates = {
            'Default Credentials': '1-2 hours',
            'Brute Force Vulnerability': '4-8 hours',
            'XSS': '1-2 days',
            'SQL Injection': '1-3 days',
            'Horizontal Privilege Escalation': '3-7 days',
            'Vertical Privilege Escalation': '5-10 days'
        };
        
        return timeEstimates[type] || '1-2 weeks';
    }
}

// Использование OWASP Testing Guide
const owaspTester = new OWASPTestingGuide();

async function runOWASPTest(target) {
    const results = await owaspTester.performOWASPTesting(target);
    console.log('OWASP Testing Results:', JSON.stringify(results, null, 2));
    return results;
}
```

### 2. PTES (Penetration Testing Execution Standard)

```javascript
// Реализация PTES методологии
class PTESTester {
    constructor() {
        this.phases = [
            {
                name: 'Pre-engagement Interactions',
                description: 'Initial contact and agreement establishment',
                activities: [
                    'Define scope and objectives',
                    'Establish rules of engagement',
                    'Obtain written authorization',
                    'Define deliverables'
                ]
            },
            {
                name: 'Intelligence Gathering',
                description: 'Collect information about the target',
                activities: [
                    'Passive information gathering',
                    'Active information gathering',
                    'Social engineering preparation',
                    'Technology identification'
                ],
                tools: ['Whois', 'Nslookup', 'Shodan', 'Google Dorks', 'Recon-ng']
            },
            {
                name: 'Threat Modeling',
                description: 'Analyze the target to identify potential threats',
                activities: [
                    'Identify assets',
                    'Identify vulnerabilities',
                    'Map attack vectors',
                    'Prioritize threats'
                ],
                tools: ['Microsoft Threat Modeling Tool', 'Oryx']
            },
            {
                name: 'Vulnerability Analysis',
                description: 'Identify potential vulnerabilities',
                activities: [
                    'Automated vulnerability scanning',
                    'Manual vulnerability analysis',
                    'Configuration review',
                    'Architecture analysis'
                ],
                tools: ['Nessus', 'OpenVAS', 'Nmap', 'Nikto', 'OWASP ZAP']
            },
            {
                name: 'Exploitation',
                description: 'Attempt to exploit identified vulnerabilities',
                activities: [
                    'Exploitation of identified vulnerabilities',
                    'Privilege escalation',
                    'Maintaining access',
                    'Covering tracks'
                ],
                tools: ['Metasploit', 'Empire', 'Cobalt Strike', 'SQLMap']
            },
            {
                name: 'Post-exploitation',
                description: 'Maintain access and gather additional information',
                activities: [
                    'Establish persistent access',
                    'Data exfiltration',
                    'Lateral movement',
                    'Cleanup activities'
                ],
                tools: ['Mimikatz', 'PowerShell Empire', 'Cobalt Strike']
            },
            {
                name: 'Reporting',
                description: 'Document findings and recommendations',
                activities: [
                    'Compile findings',
                    'Risk assessment',
                    'Recommendations',
                    'Executive summary'
                ]
            }
        ];
    }
    
    async performPTES(target, config) {
        const engagement = {
            target: target,
            config: config,
            phases: [],
            timeline: [],
            findings: [],
            finalReport: null
        };
        
        for (const phase of this.phases) {
            console.log(`Executing PTES Phase: ${phase.name}`);
            
            const phaseResult = await this.executePhase(phase, target, config);
            engagement.phases.push(phaseResult);
            
            if (phaseResult.findings) {
                engagement.findings.push(...phaseResult.findings);
            }
            
            engagement.timeline.push({
                phase: phase.name,
                startTime: phaseResult.startTime,
                endTime: phaseResult.endTime,
                status: phaseResult.status
            });
        }
        
        engagement.finalReport = await this.generateFinalReport(engagement);
        
        return engagement;
    }
    
    async executePhase(phase, target, config) {
        const phaseResult = {
            name: phase.name,
            description: phase.description,
            startTime: new Date().toISOString(),
            status: 'IN_PROGRESS',
            activities: [],
            findings: [],
            toolsUsed: phase.tools || [],
            endTime: null
        };
        
        for (const activity of phase.activities) {
            const activityResult = await this.executeActivity(activity, target, config);
            phaseResult.activities.push(activityResult);
            
            if (activityResult.findings) {
                phaseResult.findings.push(...activityResult.findings);
            }
        }
        
        phaseResult.endTime = new Date().toISOString();
        phaseResult.status = 'COMPLETED';
        
        return phaseResult;
    }
    
    async executeActivity(activity, target, config) {
        const activityResult = {
            name: activity,
            startTime: new Date().toISOString(),
            status: 'IN_PROGRESS',
            toolsUsed: [],
            findings: [],
            details: '',
            endTime: null
        };
        
        try {
            // Выполнение конкретной активности
            switch (activity) {
                case 'Passive information gathering':
                    activityResult.findings = await this.passiveReconnaissance(target);
                    break;
                case 'Automated vulnerability scanning':
                    activityResult.findings = await this.automatedVulnerabilityScanning(target, config);
                    break;
                case 'Exploitation of identified vulnerabilities':
                    activityResult.findings = await this.exploitation(target, config);
                    break;
                case 'Manual vulnerability analysis':
                    activityResult.findings = await this.manualVulnerabilityAnalysis(target, config);
                    break;
                default:
                    activityResult.status = 'SKIPPED';
                    activityResult.details = 'Activity not implemented';
            }
            
            activityResult.status = activityResult.findings.length > 0 ? 'VULNERABLE' : 'SECURE';
        } catch (error) {
            activityResult.status = 'ERROR';
            activityResult.error = error.message;
        }
        
        activityResult.endTime = new Date().toISOString();
        
        return activityResult;
    }
    
    async passiveReconnaissance(target) {
        const findings = [];
        
        // Пример пассивного сбора информации
        try {
            // Сбор информации через DNS
            const dnsInfo = await this.getDnsInfo(target);
            if (dnsInfo) {
                findings.push({
                    type: 'Information Disclosure',
                    severity: 'LOW',
                    category: 'Passive Reconnaissance',
                    details: `DNS information gathered: ${JSON.stringify(dnsInfo)}`,
                    cvssScore: 2.0,
                    cweId: 'CWE-200'
                });
            }
            
            // Сбор информации через Whois
            const whoisInfo = await this.getWhoisInfo(target);
            if (whoisInfo) {
                findings.push({
                    type: 'Information Disclosure',
                    severity: 'LOW',
                    category: 'Passive Reconnaissance',
                    details: `WHOIS information gathered: ${JSON.stringify(whoisInfo)}`,
                    cvssScore: 2.0,
                    cweId: 'CWE-200'
                });
            }
            
        } catch (error) {
            console.error('Error during passive reconnaissance:', error);
        }
        
        return findings;
    }
    
    async automatedVulnerabilityScanning(target, config) {
        const findings = [];
        
        // Использование различных сканеров
        const scanners = [
            new NessusScanner(config.nessus),
            new NmapScanner(config.nmap),
            new NiktoScanner(config.nikto),
            new ZapScanner(config.zap)
        ];
        
        for (const scanner of scanners) {
            try {
                const scanResults = await scanner.scan(target);
                findings.push(...this.convertScanResults(scanResults));
            } catch (error) {
                console.error(`Error with scanner ${scanner.constructor.name}:`, error);
            }
        }
        
        return findings;
    }
    
    async manualVulnerabilityAnalysis(target, config) {
        const findings = [];
        
        // Ручной анализ уязвимостей
        const manualTests = [
            this.testForXSSManually,
            this.testForSQLInjectionManually,
            this.testForAuthenticationBypass,
            this.testForAuthorizationIssues,
            this.testForSessionManagement
        ];
        
        for (const test of manualTests) {
            try {
                const testResults = await test.call(this, target, config);
                findings.push(...testResults);
            } catch (error) {
                console.error(`Error during manual test ${test.name}:`, error);
            }
        }
        
        return findings;
    }
    
    async exploitation(target, config) {
        const findings = [];
        
        // Попытка эксплуатации известных уязвимостей
        // В реальности это должен быть осторожный и контролируемый процесс
        
        // Пример: проверка на возможность эксплуатации известных CVE
        const knownVulnerabilities = await this.identifyKnownVulnerabilities(target);
        
        for (const vuln of knownVulnerabilities) {
            const exploitResult = await this.attemptExploitation(vuln, target, config);
            if (exploitResult.success) {
                findings.push({
                    type: 'Successful Exploitation',
                    severity: 'CRITICAL',
                    vulnerability: vuln,
                    evidence: exploitResult.evidence,
                    cvssScore: vuln.cvssScore,
                    cweId: vuln.cweId
                });
            }
        }
        
        return findings;
    }
    
    async getDnsInfo(target) {
        // Заглушка для получения DNS информации
        return { 
            domain: target,
            subdomains: ['www', 'mail', 'ftp'],
            mxRecords: ['mail.example.com'],
            nsRecords: ['ns1.example.com', 'ns2.example.com']
        };
    }
    
    async getWhoisInfo(target) {
        // Заглушка для получения WHOIS информации
        return {
            registrar: 'Example Registrar',
            created: '2020-01-01',
            updated: '2023-01-01',
            expires: '2024-01-01',
            adminContact: 'admin@example.com'
        };
    }
    
    convertScanResults(scanResults) {
        // Конвертация результатов сканирования в стандартный формат
        const findings = [];
        
        for (const result of scanResults) {
            findings.push({
                type: result.type || 'Vulnerability',
                severity: result.severity || 'MEDIUM',
                category: result.category || 'Unknown',
                details: result.description || result.name,
                cvssScore: result.cvss || 0,
                cweId: result.cwe || 'CWE-Unknown',
                port: result.port,
                service: result.service,
                proofOfConcept: result.proofOfConcept || result.output
            });
        }
        
        return findings;
    }
    
    async identifyKnownVulnerabilities(target) {
        // Заглушка для идентификации известных уязвимостей
        return [
            {
                cve: 'CVE-2023-1234',
                description: 'Example vulnerability',
                cvssScore: 9.8,
                cweId: 'CWE-79',
                severity: 'CRITICAL'
            }
        ];
    }
    
    async attemptExploitation(vulnerability, target, config) {
        // Заглушка для попытки эксплуатации
        return {
            success: false,
            evidence: 'Exploitation not performed in this example',
            method: 'Manual verification required'
        };
    }
    
    async generateFinalReport(engagement) {
        const report = {
            metadata: {
                generatedAt: new Date().toISOString(),
                tester: 'Automated PTES Tester',
                target: engagement.target,
                scope: engagement.config.scope || 'Full penetration test'
            },
            executiveSummary: {
                totalVulnerabilities: engagement.findings.length,
                bySeverity: this.countBySeverity(engagement.findings),
                criticalIssues: this.countCriticalIssues(engagement.findings),
                riskRating: this.calculateRiskRating(engagement.findings)
            },
            technicalFindings: engagement.findings,
            recommendations: await this.generateDetailedRecommendations(engagement.findings),
            methodology: 'PTES',
            timeline: engagement.timeline,
            conclusions: this.generateConclusions(engagement)
        };
        
        return report;
    }
    
    countBySeverity(findings) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
        
        for (const finding of findings) {
            counts[finding.severity] = (counts[finding.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    countCriticalIssues(findings) {
        return findings.filter(f => f.severity === 'CRITICAL').length;
    }
    
    calculateRiskRating(findings) {
        if (findings.length === 0) return 'LOW';
        
        const critical = this.countCriticalIssues(findings);
        const high = findings.filter(f => f.severity === 'HIGH').length;
        
        if (critical > 0) return 'CRITICAL';
        if (high > 5) return 'HIGH';
        if (high > 0) return 'MEDIUM';
        return 'LOW';
    }
    
    async generateDetailedRecommendations(findings) {
        const recommendations = [];
        
        // Группировка уязвимостей по типу
        const groupedFindings = this.groupFindingsByType(findings);
        
        for (const [type, typeFindings] of Object.entries(groupedFindings)) {
            const recommendation = {
                vulnerabilityType: type,
                count: typeFindings.length,
                severityDistribution: this.getSeverityDistribution(typeFindings),
                priority: this.calculateRecommendationPriority(typeFindings),
                remediationSteps: this.getRemediationSteps(type),
                estimatedTime: this.estimateRemediationTime(type),
                businessImpact: this.assessBusinessImpact(type)
            };
            
            recommendations.push(recommendation);
        }
        
        return recommendations;
    }
    
    groupFindingsByType(findings) {
        const grouped = {};
        
        for (const finding of findings) {
            const type = finding.type;
            if (!grouped[type]) grouped[type] = [];
            grouped[type].push(finding);
        }
        
        return grouped;
    }
    
    getSeverityDistribution(findings) {
        const distribution = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
        
        for (const finding of findings) {
            distribution[finding.severity] = (distribution[finding.severity] || 0) + 1;
        }
        
        return distribution;
    }
    
    calculateRecommendationPriority(findings) {
        const highestSeverity = Math.max(
            ...findings.map(f => this.severityToNumber(f.severity))
        );
        
        return this.numberToSeverity(highestSeverity);
    }
    
    severityToNumber(severity) {
        const mapping = { 'INFO': 1, 'LOW': 2, 'MEDIUM': 3, 'HIGH': 4, 'CRITICAL': 5 };
        return mapping[severity] || 3;
    }
    
    numberToSeverity(number) {
        const mapping = { 1: 'INFO', 2: 'LOW', 3: 'MEDIUM', 4: 'HIGH', 5: 'CRITICAL' };
        return mapping[number] || 'MEDIUM';
    }
    
    getRemediationSteps(type) {
        const steps = {
            'XSS': [
                'Implement proper output encoding',
                'Use Content Security Policy (CSP)',
                'Validate and sanitize all inputs'
            ],
            'SQL Injection': [
                'Use parameterized queries',
                'Implement input validation',
                'Apply principle of least privilege'
            ],
            'Authentication Bypass': [
                'Implement proper authentication controls',
                'Use multi-factor authentication',
                'Implement account lockout mechanisms'
            ]
        };
        
        return steps[type] || ['Implement appropriate security controls', 'Follow security best practices'];
    }
    
    estimateRemediationTime(type) {
        const estimates = {
            'XSS': '1-2 days',
            'SQL Injection': '2-5 days',
            'Authentication Bypass': '1-3 days',
            'Authorization Issues': '3-7 days'
        };
        
        return estimates[type] || '1-2 weeks';
    }
    
    assessBusinessImpact(type) {
        const impacts = {
            'XSS': 'MEDIUM - Could lead to data theft or session hijacking',
            'SQL Injection': 'HIGH - Could lead to data breach',
            'Authentication Bypass': 'CRITICAL - Full system compromise possible',
            'Authorization Issues': 'HIGH - Unauthorized access to sensitive data'
        };
        
        return impacts[type] || 'MEDIUM - Potential security impact';
    }
    
    generateConclusions(engagement) {
        const conclusions = {
            overallSecurityPosture: this.assessOverallSecurity(engagement.findings),
            mainConcerns: this.identifyMainConcerns(engagement.findings),
            strengths: this.identifyStrengths(engagement.phases),
            weaknesses: this.identifyWeaknesses(engagement.findings),
            immediateActions: this.getImmediateActions(engagement.findings),
            longTermRecommendations: this.getLongTermRecommendations()
        };
        
        return conclusions;
    }
    
    assessOverallSecurity(findings) {
        const critical = this.countCriticalIssues(findings);
        const high = findings.filter(f => f.severity === 'HIGH').length;
        
        if (critical > 0) return 'POOR - Critical vulnerabilities detected';
        if (high > 10) return 'FAIR - Multiple high severity issues';
        if (high > 5) return 'FAIR - Several high severity issues';
        if (findings.length > 20) return 'ADEQUATE - Multiple issues need attention';
        if (findings.length > 5) return 'GOOD - Minor issues detected';
        return 'EXCELLENT - No significant vulnerabilities detected';
    }
    
    identifyMainConcerns(findings) {
        const concerns = [];
        
        const criticalFindings = findings.filter(f => f.severity === 'CRITICAL');
        if (criticalFindings.length > 0) {
            concerns.push('Critical vulnerabilities present requiring immediate attention');
        }
        
        const authFindings = findings.filter(f => f.type.includes('Authentication'));
        if (authFindings.length > 0) {
            concerns.push(`${authFindings.length} authentication-related vulnerabilities detected`);
        }
        
        const dataFindings = findings.filter(f => f.type.includes('Data') || f.type.includes('Information'));
        if (dataFindings.length > 0) {
            concerns.push(`${dataFindings.length} data exposure vulnerabilities detected`);
        }
        
        return concerns;
    }
    
    identifyStrengths(phases) {
        const strengths = [];
        
        // Проверка, были ли пройдены все фазы
        if (phases.length === this.phases.length) {
            strengths.push('Comprehensive testing methodology followed');
        }
        
        // Проверка на наличие автоматизированных и ручных тестов
        const hasAutomation = phases.some(phase => 
            phase.name === 'Vulnerability Analysis' && 
            phase.toolsUsed.length > 0
        );
        
        if (hasAutomation) {
            strengths.push('Both automated and manual testing approaches utilized');
        }
        
        return strengths;
    }
    
    identifyWeaknesses(findings) {
        const weaknesses = [];
        
        const xssFindings = findings.filter(f => f.type.includes('XSS'));
        if (xssFindings.length > 0) {
            weaknesses.push(`XSS vulnerabilities detected (${xssFindings.length}) - input validation/output encoding insufficient`);
        }
        
        const sqlFindings = findings.filter(f => f.type.includes('SQL'));
        if (sqlFindings.length > 0) {
            weaknesses.push(`SQL Injection vulnerabilities detected (${sqlFindings.length}) - query parameterization needed`);
        }
        
        return weaknesses;
    }
    
    getImmediateActions(findings) {
        const criticalFindings = findings.filter(f => f.severity === 'CRITICAL');
        const highFindings = findings.filter(f => f.severity === 'HIGH');
        
        const actions = [];
        
        if (criticalFindings.length > 0) {
            actions.push('Patch critical vulnerabilities immediately');
            actions.push('Implement temporary mitigations if patches unavailable');
        }
        
        if (highFindings.length > 0) {
            actions.push('Address high severity vulnerabilities within 30 days');
            actions.push('Review and strengthen access controls');
        }
        
        return actions;
    }
    
    getLongTermRecommendations() {
        return [
            'Implement secure coding training for development team',
            'Establish regular security testing schedule',
            'Deploy automated security scanning in CI/CD pipeline',
            'Implement security-focused design reviews',
            'Regular penetration testing (quarterly/bi-annually)'
        ];
    }
}

// Использование PTES тестера
const ptesTester = new PTESTester();

async function runPTEST(target, config) {
    const engagement = await ptesTester.performPTES(target, config);
    console.log('PTES Engagement Results:', JSON.stringify(engagement, null, 2));
    return engagement;
}
```

## Типы тестирования безопасности

### 1. Black Box Testing

```javascript
// Black Box тестирование - тестирование без знания внутренней структуры
class BlackBoxTester {
    constructor(target) {
        this.target = target;
        this.session = null;
        this.discoveredEndpoints = [];
        this.testResults = [];
    }
    
    async performBlackBoxTest() {
        const results = {
            target: this.target,
            methodology: 'Black Box',
            discovery: await this.performDiscovery(),
            vulnerabilityAssessment: await this.performVulnerabilityAssessment(),
            exploitation: await this.attemptExploitation(),
            report: null
        };
        
        results.report = this.generateBlackBoxReport(results);
        
        return results;
    }
    
    async performDiscovery() {
        const discovery = {
            endpoints: [],
            technologies: [],
            interestingParameters: [],
            backupFiles: [],
            adminInterfaces: []
        };
        
        // Discovery of endpoints
        discovery.endpoints = await this.discoverEndpoints();
        
        // Technology fingerprinting
        discovery.technologies = await this.fingerprintTechnologies();
        
        // Interesting parameters discovery
        discovery.interestingParameters = await this.discoverInterestingParameters();
        
        // Backup and hidden files
        discovery.backupFiles = await this.discoverBackupFiles();
        
        // Admin interfaces
        discovery.adminInterfaces = await this.discoverAdminInterfaces();
        
        return discovery;
    }
    
    async discoverEndpoints() {
        const endpoints = [];
        const commonEndpoints = [
            '/admin', '/api', '/api/v1', '/api/v2', '/auth', '/login', '/register',
            '/dashboard', '/users', '/config', '/backup', '/logs', '/debug',
            '/test', '/dev', '/staging', '/internal'
        ];
        
        for (const endpoint of commonEndpoints) {
            try {
                const response = await this.makeRequest('GET', this.target + endpoint);
                if (response.status !== 404) {
                    endpoints.push({
                        path: endpoint,
                        status: response.status,
                        length: response.body?.length || 0,
                        technology: this.detectTechnology(response)
                    });
                }
            } catch (error) {
                // Endpoint not accessible
            }
        }
        
        // Fuzzing for additional endpoints
        const fuzzedEndpoints = await this.fuzzEndpoints();
        endpoints.push(...fuzzedEndpoints);
        
        return endpoints;
    }
    
    async fingerprintTechnologies() {
        const technologies = [];
        
        try {
            const response = await this.makeRequest('GET', this.target);
            
            // Check Server header
            const server = response.headers['server'];
            if (server) {
                technologies.push({
                    type: 'Web Server',
                    name: server,
                    confidence: 'HIGH'
                });
            }
            
            // Check X-Powered-By header
            const poweredBy = response.headers['x-powered-by'];
            if (poweredBy) {
                technologies.push({
                    type: 'Framework/Language',
                    name: poweredBy,
                    confidence: 'MEDIUM'
                });
            }
            
            // Check for common CMS signatures
            const body = response.body.toLowerCase();
            if (body.includes('wordpress') || body.includes('wp-')) {
                technologies.push({
                    type: 'CMS',
                    name: 'WordPress',
                    confidence: 'HIGH'
                });
            }
            
            if (body.includes('drupal')) {
                technologies.push({
                    type: 'CMS',
                    name: 'Drupal',
                    confidence: 'MEDIUM'
                });
            }
            
            if (body.includes('laravel') || body.includes('symfony')) {
                technologies.push({
                    type: 'Framework',
                    name: 'Laravel/Symfony',
                    confidence: 'MEDIUM'
                });
            }
            
            // Check for specific file extensions
            const fileExtensions = this.detectFileExtensions(body);
            technologies.push(...fileExtensions);
            
        } catch (error) {
            console.error('Technology fingerprinting failed:', error);
        }
        
        return technologies;
    }
    
    detectFileExtensions(body) {
        const extensions = [];
        const extensionRegex = /\.(php|asp|aspx|jsp|jspx|cgi|pl|py|rb|node|js|ts|html|htm|shtml|shtm)/gi;
        const matches = body.match(extensionRegex) || [];
        const uniqueExtensions = [...new Set(matches)];
        
        for (const ext of uniqueExtensions) {
            extensions.push({
                type: 'File Extension',
                name: ext,
                confidence: 'MEDIUM'
            });
        }
        
        return extensions;
    }
    
    detectTechnology(response) {
        // Простое определение технологии по ответу
        if (response.headers['x-powered-by']?.toLowerCase().includes('express')) {
            return 'Express.js';
        }
        if (response.headers['server']?.toLowerCase().includes('nginx')) {
            return 'Nginx';
        }
        if (response.body?.toLowerCase().includes('asp.net')) {
            return 'ASP.NET';
        }
        return 'Unknown';
    }
    
    async discoverInterestingParameters() {
        // Попытка обнаружить интересные параметры через fuzzing
        const interestingParams = [];
        const commonParams = [
            'id', 'user', 'username', 'email', 'password', 'file', 'path', 'url',
            'redirect', 'callback', 'return', 'next', 'continue', 'back', 'from',
            'debug', 'test', 'admin', 'root', 'config', 'setting', 'action'
        ];
        
        // Простой тест с одним из параметров
        for (const param of commonParams.slice(0, 5)) { // Ограничиваем для примера
            try {
                const testUrl = `${this.target}?${param}=test`;
                const response = await this.makeRequest('GET', testUrl);
                
                // Если параметр влияет на ответ, возможно он интересен
                if (response.body && response.body.includes('test')) {
                    interestingParams.push({
                        parameter: param,
                        reflectsValue: true,
                        potentialIssue: 'Possible reflected value'
                    });
                }
            } catch (error) {
                // Параметр не обрабатывается
            }
        }
        
        return interestingParams;
    }
    
    async discoverBackupFiles() {
        const backupFiles = [];
        const commonBackupExtensions = [
            '.bak', '.backup', '.old', '.orig', '.tmp', '~', '.swp', '.save'
        ];
        
        // Проверяем основные файлы с бэкапными расширениями
        const commonFiles = ['index', 'config', 'admin', 'login', 'api'];
        
        for (const file of commonFiles) {
            for (const ext of commonBackupExtensions) {
                try {
                    const response = await this.makeRequest('GET', `${this.target}/${file}${ext}`);
                    if (response.status === 200) {
                        backupFiles.push({
                            file: `${file}${ext}`,
                            status: response.status,
                            size: response.body?.length || 0
                        });
                    }
                } catch (error) {
                    // Файл не найден
                }
            }
        }
        
        return backupFiles;
    }
    
    async discoverAdminInterfaces() {
        const adminInterfaces = [];
        const commonAdminPaths = [
            '/admin', '/administrator', '/admin1', '/admin2', '/admin_area', '/panel',
            '/wp-admin', '/adminer', '/phpmyadmin', '/pma', '/admin-console',
            '/manager', '/control', '/dashboard', '/cms', '/backend'
        ];
        
        for (const path of commonAdminPaths) {
            try {
                const response = await this.makeRequest('GET', this.target + path);
                if (response.status === 200) {
                    adminInterfaces.push({
                        path: path,
                        status: response.status,
                        title: this.extractTitle(response.body),
                        size: response.body?.length || 0
                    });
                }
            } catch (error) {
                // Путь не доступен
            }
        }
        
        return adminInterfaces;
    }
    
    extractTitle(html) {
        if (!html) return '';
        const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
        return titleMatch ? titleMatch[1].trim() : '';
    }
    
    async fuzzEndpoints() {
        const endpoints = [];
        const fuzzList = [
            'admin', 'backup', 'config', 'debug', 'dev', 'docs', 'test',
            'temp', 'tmp', 'upload', 'downloads', 'includes', 'libraries'
        ];
        
        for (const fuzz of fuzzList) {
            try {
                const response = await this.makeRequest('GET', `${this.target}/${fuzz}`);
                if (response.status !== 404) {
                    endpoints.push({
                        path: `/${fuzz}`,
                        status: response.status,
                        length: response.body?.length || 0
                    });
                }
            } catch (error) {
                // Путь не найден
            }
        }
        
        return endpoints;
    }
    
    async performVulnerabilityAssessment() {
        const assessment = {
            injection: await this.testForInjections(),
            authIssues: await this.testAuthenticationIssues(),
            authzIssues: await this.testAuthorizationIssues(),
            sessionIssues: await this.testSessionManagement(),
            misconfigurations: await this.testMisconfigurations(),
            sensitiveData: await this.testSensitiveDataExposure()
        };
        
        return assessment;
    }
    
    async testForInjections() {
        const injections = {
            sql: [],
            xss: [],
            cmd: [],
            pathTraversal: []
        };
        
        // Тестирование на XSS
        const xssPayloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>'
        ];
        
        for (const payload of xssPayloads) {
            const result = await this.testForReflectedXSS(payload);
            if (result.vulnerable) {
                injections.xss.push(result);
            }
        }
        
        // Тестирование на SQL Injection
        const sqlPayloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL, NULL, NULL --",
            "'; DROP TABLE users; --"
        ];
        
        for (const payload of sqlPayloads) {
            const result = await this.testForSQLInjection(payload);
            if (result.vulnerable) {
                injections.sql.push(result);
            }
        }
        
        return injections;
    }
    
    async testForReflectedXSS(payload) {
        // Простой тест на reflected XSS
        // В реальности нужно тестировать каждый параметр
        const testUrl = `${this.target}?test=${encodeURIComponent(payload)}`;
        
        try {
            const response = await this.makeRequest('GET', testUrl);
            
            if (response.body && response.body.includes(payload)) {
                return {
                    vulnerable: true,
                    payload: payload,
                    location: 'response_body',
                    url: testUrl,
                    severity: 'HIGH'
                };
            }
        } catch (error) {
            // Ошибка запроса
        }
        
        return { vulnerable: false, payload: payload };
    }
    
    async testForSQLInjection(payload) {
        const testUrl = `${this.target}?id=${encodeURIComponent(payload)}`;
        
        try {
            const response = await this.makeRequest('GET', testUrl);
            
            // Проверка на признаки SQL ошибок
            const errorPatterns = [
                /SQL syntax/,
                /mysql/i,
                /postgresql/i,
                /ora-/i,
                /sqlite/i
            ];
            
            for (const pattern of errorPatterns) {
                if (response.body && pattern.test(response.body)) {
                    return {
                        vulnerable: true,
                        payload: payload,
                        location: 'response_body',
                        url: testUrl,
                        severity: 'CRITICAL',
                        errorPattern: pattern.toString()
                    };
                }
            }
        } catch (error) {
            // Ошибка запроса
        }
        
        return { vulnerable: false, payload: payload };
    }
    
    async testAuthenticationIssues() {
        const authIssues = {
            defaultCredentials: [],
            weakPasswordPolicy: [],
            bruteForce: [],
            sessionFixation: []
        };
        
        // Проверка на дефолтные учетные данные
        const defaultCreds = [
            { username: 'admin', password: 'admin' },
            { username: 'admin', password: 'password' },
            { username: 'root', password: 'root' }
        ];
        
        for (const cred of defaultCreds) {
            const result = await this.testDefaultCredentials(cred);
            if (result.success) {
                authIssues.defaultCredentials.push(result);
            }
        }
        
        // Проверка на брутфорс
        const bfResult = await this.testBruteForceProtection();
        if (bfResult.vulnerable) {
            authIssues.bruteForce.push(bfResult);
        }
        
        return authIssues;
    }
    
    async testDefaultCredentials(credentials) {
        try {
            const response = await this.makeRequest('POST', `${this.target}/login`, {
                username: credentials.username,
                password: credentials.password
            });
            
            // Проверка успешного логина (может быть по-разному)
            if (response.status === 302 || response.status === 200) {
                if (response.headers['location'] || response.body?.includes('dashboard') || 
                    response.body?.includes('welcome') || response.headers['set-cookie']) {
                    return {
                        success: true,
                        credentials: credentials,
                        severity: 'CRITICAL'
                    };
                }
            }
        } catch (error) {
            // Ошибка запроса
        }
        
        return { success: false, credentials: credentials };
    }
    
    async testBruteForceProtection() {
        // Попытка определить наличие защиты от брутфорса
        const attempts = 10;
        const startTime = Date.now();
        
        for (let i = 0; i < attempts; i++) {
            await this.makeRequest('POST', `${this.target}/login`, {
                username: `test${i}`,
                password: 'invalid'
            });
        }
        
        const endTime = Date.now();
        const totalTime = endTime - startTime;
        
        // Если время выполнения слишком маленькое, возможно нет защиты
        if (totalTime < 2000) { // менее 2 секунд на 10 попыток
            return {
                vulnerable: true,
                attempts: attempts,
                totalTime: totalTime,
                rate: attempts / (totalTime / 1000),
                severity: 'MEDIUM'
            };
        }
        
        return { vulnerable: false };
    }
    
    async testAuthorizationIssues() {
        const authzIssues = {
            horizontalPrivilegeEscalation: [],
            verticalPrivilegeEscalation: [],
            forcedBrowsing: []
        };
        
        // Проверка на горизонтальное эскалирование
        const horizontalResult = await this.testHorizontalPrivilegeEscalation();
        if (horizontalResult.vulnerable) {
            authzIssues.horizontalPrivilegeEscalation.push(horizontalResult);
        }
        
        // Проверка на вертикальное эскалирование
        const verticalResult = await this.testVerticalPrivilegeEscalation();
        if (verticalResult.vulnerable) {
            authzIssues.verticalPrivilegeEscalation.push(verticalResult);
        }
        
        return authzIssues;
    }
    
    async testHorizontalPrivilegeEscalation() {
        // Тестирование доступа к чужим данным
        // В реальности потребуется сессия аутентифицированного пользователя
        return { vulnerable: false };
    }
    
    async testVerticalPrivilegeEscalation() {
        // Тестирование доступа к административным функциям
        // В реальности потребуется сессия обычного пользователя
        return { vulnerable: false };
    }
    
    async testSessionManagement() {
        const sessionIssues = {
            insecureCookies: [],
            weakSessionTokens: [],
            sessionFixation: [],
            insufficientSessionTimeout: []
        };
        
        // Проверка cookie на безопасность
        const cookieSecurity = await this.testCookieSecurity();
        sessionIssues.insecureCookies.push(...cookieSecurity);
        
        return sessionIssues;
    }
    
    async testCookieSecurity() {
        const insecureCookies = [];
        
        try {
            const response = await this.makeRequest('GET', this.target);
            const cookies = this.parseCookies(response.headers['set-cookie'] || []);
            
            for (const cookie of cookies) {
                if (!cookie.secure) {
                    insecureCookies.push({
                        name: cookie.name,
                        issue: 'Missing Secure flag',
                        severity: 'MEDIUM'
                    });
                }
                
                if (!cookie.httponly) {
                    insecureCookies.push({
                        name: cookie.name,
                        issue: 'Missing HttpOnly flag',
                        severity: 'HIGH'
                    });
                }
                
                if (!cookie.samesite) {
                    insecureCookies.push({
                        name: cookie.name,
                        issue: 'Missing SameSite attribute',
                        severity: 'MEDIUM'
                    });
                }
            }
        } catch (error) {
            console.error('Cookie security test failed:', error);
        }
        
        return insecureCookies;
    }
    
    parseCookies(setCookieHeaders) {
        return setCookieHeaders.map(header => {
            const parts = header.split(';');
            const nameValue = parts[0].split('=');
            
            return {
                name: nameValue[0]?.trim(),
                value: nameValue[1]?.trim(),
                secure: parts.some(p => p.trim().toLowerCase() === 'secure'),
                httponly: parts.some(p => p.trim().toLowerCase() === 'httponly'),
                samesite: parts.find(p => p.trim().toLowerCase().includes('samesite'))?.split('=')[1]?.trim().toLowerCase() || null
            };
        });
    }
    
    async testMisconfigurations() {
        const misconfigs = {
            informationDisclosure: [],
            debugEnabled: [],
            errorHandling: [],
            securityHeaders: []
        };
        
        // Проверка на раскрытие информации
        const infoDisclosures = await this.testInformationDisclosure();
        misconfigs.informationDisclosure.push(...infoDisclosures);
        
        // Проверка заголовков безопасности
        const secHeaders = await this.testSecurityHeaders();
        misconfigs.securityHeaders.push(...secHeaders);
        
        return misconfigs;
    }
    
    async testInformationDisclosure() {
        const disclosures = [];
        
        try {
            const response = await this.makeRequest('GET', this.target);
            
            // Проверка на раскрытие информации в теле ответа
            const body = response.body?.toLowerCase() || '';
            
            if (body.includes('debug') && body.includes('traceback')) {
                disclosures.push({
                    type: 'Stack Trace Disclosure',
                    location: 'response_body',
                    severity: 'MEDIUM'
                });
            }
            
            if (body.includes('version') && (body.includes('php') || body.includes('python') || body.includes('node'))) {
                disclosures.push({
                    type: 'Version Disclosure',
                    location: 'response_body',
                    severity: 'LOW'
                });
            }
            
            // Проверка заголовков
            const headers = response.headers;
            if (headers['x-powered-by']) {
                disclosures.push({
                    type: 'Technology Disclosure',
                    location: 'x-powered-by header',
                    value: headers['x-powered-by'],
                    severity: 'LOW'
                });
            }
            
            if (headers['server']) {
                disclosures.push({
                    type: 'Server Disclosure',
                    location: 'server header',
                    value: headers['server'],
                    severity: 'LOW'
                });
            }
            
        } catch (error) {
            console.error('Information disclosure test failed:', error);
        }
        
        return disclosures;
    }
    
    async testSecurityHeaders() {
        const missingHeaders = [];
        
        try {
            const response = await this.makeRequest('GET', this.target);
            const headers = response.headers;
            
            // Проверка основных заголовков безопасности
            if (!headers['x-content-type-options']) {
                missingHeaders.push({
                    header: 'X-Content-Type-Options',
                    severity: 'MEDIUM',
                    recommendation: 'Set to "nosniff"'
                });
            }
            
            if (!headers['x-frame-options'] && !headers['content-security-policy']?.includes('frame-ancestors')) {
                missingHeaders.push({
                    header: 'X-Frame-Options/CSP frame-ancestors',
                    severity: 'MEDIUM',
                    recommendation: 'Set to "DENY" or implement CSP with frame-ancestors'
                });
            }
            
            if (!headers['x-xss-protection']) {
                missingHeaders.push({
                    header: 'X-XSS-Protection',
                    severity: 'MEDIUM',
                    recommendation: 'Set to "1; mode=block"'
                });
            }
            
            if (!headers['strict-transport-security'] && this.target.startsWith('https://')) {
                missingHeaders.push({
                    header: 'Strict-Transport-Security',
                    severity: 'MEDIUM',
                    recommendation: 'Implement HSTS with appropriate max-age'
                });
            }
            
        } catch (error) {
            console.error('Security headers test failed:', error);
        }
        
        return missingHeaders;
    }
    
    async testSensitiveDataExposure() {
        const sensitiveData = {
            credentials: [],
            personalInfo: [],
            internalInfo: []
        };
        
        // Проверка на наличие чувствительных данных в ответах
        const endpointsToCheck = this.discoveredEndpoints.length > 0 ? 
                                this.discoveredEndpoints : 
                                [{ path: '', status: 200 }];
        
        for (const endpoint of endpointsToCheck) {
            try {
                const response = await this.makeRequest('GET', this.target + endpoint.path);
                const body = response.body || '';
                
                // Проверка на наличие email адресов
                const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                const emails = body.match(emailRegex);
                if (emails && emails.length > 0) {
                    sensitiveData.personalInfo.push({
                        type: 'Email Disclosure',
                        emails: emails,
                        endpoint: endpoint.path,
                        count: emails.length,
                        severity: 'MEDIUM'
                    });
                }
                
                // Проверка на наличие телефонных номеров
                const phoneRegex = /(\+\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
                const phones = body.match(phoneRegex);
                if (phones && phones.length > 0) {
                    sensitiveData.personalInfo.push({
                        type: 'Phone Number Disclosure',
                        phoneNumbers: phones,
                        endpoint: endpoint.path,
                        count: phones.length,
                        severity: 'LOW'
                    });
                }
                
                // Проверка на наличие кредитных карт
                const ccRegex = /\b(?:\d{4}[-\s]?){3}\d{4}\b/g;
                const creditCards = body.match(ccRegex);
                if (creditCards && creditCards.length > 0) {
                    sensitiveData.personalInfo.push({
                        type: 'Credit Card Disclosure',
                        creditCards: creditCards,
                        endpoint: endpoint.path,
                        count: creditCards.length,
                        severity: 'CRITICAL'
                    });
                }
                
                // Проверка на наличие паролей в открытом виде
                const passwordRegex = /(password|pwd|pass)["\s:=]+["\s]*([^"\s<>\n\r]{4,})/gi;
                let match;
                const passwords = [];
                
                while ((match = passwordRegex.exec(body)) !== null) {
                    passwords.push(match[2]);
                }
                
                if (passwords.length > 0) {
                    sensitiveData.credentials.push({
                        type: 'Password Disclosure',
                        passwords: passwords,
                        endpoint: endpoint.path,
                        count: passwords.length,
                        severity: 'CRITICAL'
                    });
                }
                
            } catch (error) {
                console.error(`Error checking sensitive data in ${endpoint.path}:`, error);
            }
        }
        
        return sensitiveData;
    }
    
    async makeRequest(method, url, data = null) {
        // Заглушка для HTTP запросов
        // В реальности использовать безопасный HTTP клиент
        try {
            if (method === 'GET') {
                // Имитация GET запроса
                return {
                    status: 200,
                    headers: {
                        'content-type': 'text/html',
                        'server': 'Apache/2.4.41 (Ubuntu)',
                        'x-powered-by': 'Express'
                    },
                    body: '<html><body>Test response</body></html>'
                };
            } else if (method === 'POST' && data) {
                // Имитация POST запроса
                return {
                    status: 200,
                    headers: { 'content-type': 'application/json' },
                    body: JSON.stringify({ success: true })
                };
            }
        } catch (error) {
            throw new Error(`Request failed: ${error.message}`);
        }
    }
    
    generateBlackBoxReport(results) {
        return {
            methodology: 'Black Box Testing',
            target: results.target,
            discovery: results.discovery,
            vulnerabilities: this.aggregateVulnerabilities(results.vulnerabilityAssessment),
            riskAssessment: this.assessRisk(results.vulnerabilityAssessment),
            recommendations: this.generateRecommendations(results.vulnerabilityAssessment),
            conclusion: this.generateConclusion(results.vulnerabilityAssessment)
        };
    }
    
    aggregateVulnerabilities(assessment) {
        const allVulns = [];
        
        // Сбор всех уязвимостей из различных категорий
        for (const [category, tests] of Object.entries(assessment)) {
            if (typeof tests === 'object' && tests !== null) {
                for (const [testType, findings] of Object.entries(tests)) {
                    if (Array.isArray(findings)) {
                        for (const finding of findings) {
                            allVulns.push({
                                ...finding,
                                category: category,
                                testType: testType
                            });
                        }
                    }
                }
            }
        }
        
        return allVulns;
    }
    
    assessRisk(assessment) {
        const critical = this.countBySeverity(assessment, 'CRITICAL');
        const high = this.countBySeverity(assessment, 'HIGH');
        const medium = this.countBySeverity(assessment, 'MEDIUM');
        const low = this.countBySeverity(assessment, 'LOW');
        
        let overallRisk = 'LOW';
        if (critical > 0) overallRisk = 'CRITICAL';
        else if (high > 5) overallRisk = 'HIGH';
        else if (high > 0) overallRisk = 'MEDIUM';
        else if (medium > 10) overallRisk = 'MEDIUM';
        
        return {
            overallRisk: overallRisk,
            critical: critical,
            high: high,
            medium: medium,
            low: low,
            total: critical + high + medium + low
        };
    }
    
    countBySeverity(assessment, severity) {
        let count = 0;
        
        for (const tests of Object.values(assessment)) {
            if (typeof tests === 'object' && tests !== null) {
                for (const findings of Object.values(tests)) {
                    if (Array.isArray(findings)) {
                        count += findings.filter(f => f.severity === severity).length;
                    }
                }
            }
        }
        
        return count;
    }
    
    generateRecommendations(assessment) {
        const recommendations = [];
        
        // Рекомендации на основе найденных уязвимостей
        if (this.countBySeverity(assessment, 'CRITICAL') > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Vulnerabilities Immediately',
                description: 'Critical vulnerabilities were discovered that could lead to complete system compromise',
                actions: ['Patch immediately', 'Implement temporary mitigations', 'Review security controls']
            });
        }
        
        if (this.countBySeverity(assessment, 'HIGH') > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix High Severity Issues',
                description: 'High severity vulnerabilities pose significant risk to the application',
                actions: ['Implement secure coding practices', 'Add input validation', 'Strengthen access controls']
            });
        }
        
        if (assessment.misconfigurations?.securityHeaders?.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Implement Security Headers',
                description: 'Missing security headers leave the application vulnerable to various attacks',
                actions: ['Add X-Content-Type-Options', 'Implement CSP', 'Set X-Frame-Options']
            });
        }
        
        return recommendations;
    }
    
    generateConclusion(assessment) {
        const risk = this.assessRisk(assessment);
        
        let conclusion = '';
        if (risk.overallRisk === 'CRITICAL') {
            conclusion = 'The application has critical vulnerabilities that require immediate attention. It is not suitable for production use until these issues are resolved.';
        } else if (risk.overallRisk === 'HIGH') {
            conclusion = 'The application has high severity vulnerabilities that need to be addressed before production deployment.';
        } else if (risk.overallRisk === 'MEDIUM') {
            conclusion = 'The application has some security concerns that should be addressed to improve its security posture.';
        } else {
            conclusion = 'The application appears to have a reasonable security posture with only minor issues identified.';
        }
        
        return {
            overallAssessment: risk.overallRisk,
            conclusion: conclusion,
            nextSteps: this.getRecommendedNextSteps(risk.overallRisk)
        };
    }
    
    getRecommendedNextSteps(riskLevel) {
        const steps = [];
        
        if (['CRITICAL', 'HIGH'].includes(riskLevel)) {
            steps.push('Immediate remediation of critical/high vulnerabilities');
            steps.push('Security code review');
            steps.push('Penetration testing retest');
        }
        
        steps.push('Implement security training for development team');
        steps.push('Establish regular security testing schedule');
        steps.push('Deploy security scanning in CI/CD pipeline');
        
        return steps;
    }
}

// Использование Black Box тестера
const blackBoxTester = new BlackBoxTester('https://example.com');

async function runBlackBoxTest() {
    const results = await blackBoxTester.performBlackBoxTest();
    console.log('Black Box Test Results:', JSON.stringify(results, null, 2));
    return results;
}
```

### 2. White Box Testing

```javascript
// White Box тестирование - тестирование с доступом к исходному коду
class WhiteBoxTester {
    constructor(sourcePath, target) {
        this.sourcePath = sourcePath;
        this.target = target;
        this.sourceCode = null;
        this.ast = null;
        this.vulnerabilityPatterns = this.initializePatterns();
    }
    
    initializePatterns() {
        return {
            sqlInjection: [
                /query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /execute\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /mysql_query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /mysqli_query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /pg_query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi
            ],
            xss: [
                /innerHTML\s*=\s*\w+/gi,
                /outerHTML\s*=\s*\w+/gi,
                /document\.write\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /eval\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /new\s+Function\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi
            ],
            commandInjection: [
                /exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /spawn\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /child_process\.exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /shell_exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /system\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi
            ],
            pathTraversal: [
                /filepath\s*=\s*[^)]*\+\s*\w+\s*\+[^)]*/gi,
                /filename\s*=\s*[^)]*\+\s*\w+\s*\+[^)]*/gi,
                /file\s*=\s*[^)]*\+\s*\w+\s*\+[^)]*/gi,
                /include\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi,
                /require\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/gi
            ],
            hardcodedCredentials: [
                /password\s*[:=]\s*["'][^"']*["']/gi,
                /token\s*[:=]\s*["'][^"']*["']/gi,
                /secret\s*[:=]\s*["'][^"']*["']/gi,
                /key\s*[:=]\s*["'][^"']*["']/gi,
                /api[_-]?key\s*[:=]\s*["'][^"']*["']/gi
            ]
        };
    }
    
    async performWhiteBoxTest() {
        const results = {
            target: this.target,
            sourcePath: this.sourcePath,
            methodology: 'White Box',
            sourceAnalysis: await this.analyzeSourceCode(),
            codeReview: await this.performCodeReview(),
            staticAnalysis: await this.performStaticAnalysis(),
            report: null
        };
        
        results.report = this.generateWhiteBoxReport(results);
        
        return results;
    }
    
    async analyzeSourceCode() {
        const analysis = {
            fileCount: 0,
            totalLines: 0,
            fileTypes: {},
            securityIssues: [],
            codeQuality: {}
        };
        
        // Загрузка исходного кода
        this.sourceCode = await this.loadSourceCode();
        
        // Анализ файлов
        const files = await this.enumerateSourceFiles();
        analysis.fileCount = files.length;
        
        for (const file of files) {
            const fileInfo = await this.analyzeFile(file);
            analysis.totalLines += fileInfo.lines;
            
            // Подсчет типов файлов
            const ext = this.getFileExtension(file);
            analysis.fileTypes[ext] = (analysis.fileTypes[ext] || 0) + 1;
            
            // Добавление найденных проблем
            analysis.securityIssues.push(...fileInfo.issues);
        }
        
        // Анализ качества кода
        analysis.codeQuality = await this.analyzeCodeQuality(files);
        
        return analysis;
    }
    
    async loadSourceCode() {
        // Загрузка исходного кода из файловой системы
        const fs = require('fs');
        const path = require('path');
        
        const loadFile = (filePath) => {
            if (fs.existsSync(filePath)) {
                return fs.readFileSync(filePath, 'utf8');
            }
            return '';
        };
        
        // Для примера, загружаем код из указанной директории
        if (fs.lstatSync(this.sourcePath).isDirectory()) {
            const allCode = [];
            this.walkDirectory(this.sourcePath, (filePath) => {
                if (this.isSourceFile(filePath)) {
                    allCode.push({
                        path: filePath,
                        content: loadFile(filePath)
                    });
                }
            });
            return allCode;
        } else {
            return [{
                path: this.sourcePath,
                content: loadFile(this.sourcePath)
            }];
        }
    }
    
    walkDirectory(dir, callback) {
        const fs = require('fs');
        const path = require('path');
        
        const files = fs.readdirSync(dir);
        
        for (const file of files) {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);
            
            if (stat.isDirectory()) {
                this.walkDirectory(filePath, callback);
            } else {
                callback(filePath);
            }
        }
    }
    
    isSourceFile(filePath) {
        const extensions = ['.js', '.ts', '.py', '.java', '.php', '.rb', '.go', '.cs', '.cpp', '.c'];
        return extensions.some(ext => filePath.toLowerCase().endsWith(ext));
    }
    
    getFileExtension(filePath) {
        const path = require('path');
        return path.extname(filePath).toLowerCase();
    }
    
    async enumerateSourceFiles() {
        const fs = require('fs');
        const path = require('path');
        
        const files = [];
        
        const walk = (dir) => {
            const items = fs.readdirSync(dir);
            for (const item of items) {
                const itemPath = path.join(dir, item);
                if (fs.statSync(itemPath).isDirectory()) {
                    walk(itemPath);
                } else if (this.isSourceFile(itemPath)) {
                    files.push(itemPath);
                }
            }
        };
        
        walk(this.sourcePath);
        return files;
    }
    
    async analyzeFile(filePath) {
        const fs = require('fs');
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        
        const fileAnalysis = {
            path: filePath,
            lines: lines.length,
            issues: [],
            dependencies: [],
            functions: [],
            classes: []
        };
        
        // Поиск уязвимостей в содержимом файла
        for (const [vulnType, patterns] of Object.entries(this.vulnerabilityPatterns)) {
            for (const [index, line] of lines.entries()) {
                for (const [patternIndex, pattern] of patterns.entries()) {
                    if (pattern.test(line)) {
                        fileAnalysis.issues.push({
                            type: vulnType,
                            line: index + 1,
                            code: line.trim(),
                            pattern: pattern.toString(),
                            severity: this.estimateSeverity(vulnType),
                            filePath: filePath
                        });
                    }
                }
            }
        }
        
        // Анализ зависимостей (для различных языков)
        fileAnalysis.dependencies = this.extractDependencies(content);
        
        // Анализ функций и классов
        fileAnalysis.functions = this.extractFunctions(content);
        fileAnalysis.classes = this.extractClasses(content);
        
        return fileAnalysis;
    }
    
    extractDependencies(content) {
        const dependencies = [];
        
        // Для JavaScript/Node.js
        const jsImports = content.match(/import\s+.*\s+from\s+["'](.*?)["']/g);
        if (jsImports) {
            dependencies.push(...jsImports.map(imp => ({
                type: 'import',
                value: imp
            })));
        }
        
        const jsRequires = content.match(/require\(["'](.*?)["']\)/g);
        if (jsRequires) {
            dependencies.push(...jsRequires.map(req => ({
                type: 'require',
                value: req
            })));
        }
        
        // Для Python
        const pyImports = content.match(/^import\s+([a-zA-Z_]\w*)/gm);
        if (pyImports) {
            dependencies.push(...pyImports.map(imp => ({
                type: 'import',
                value: imp
            })));
        }
        
        const pyFromImports = content.match(/^from\s+([a-zA-Z_]\w*)\s+import/gm);
        if (pyFromImports) {
            dependencies.push(...pyFromImports.map(imp => ({
                type: 'from_import',
                value: imp
            })));
        }
        
        return dependencies;
    }
    
    extractFunctions(content) {
        const functions = [];
        
        // Для JavaScript
        const jsFunctions = content.match(/function\s+([a-zA-Z_]\w*)\s*\(/g);
        if (jsFunctions) {
            functions.push(...jsFunctions.map(func => ({
                name: func.match(/function\s+([a-zA-Z_]\w*)/)[1],
                type: 'function',
                language: 'javascript'
            })));
        }
        
        // Для Python
        const pyFunctions = content.match(/def\s+([a-zA-Z_]\w*)\s*\(/g);
        if (pyFunctions) {
            functions.push(...pyFunctions.map(func => ({
                name: func.match(/def\s+([a-zA-Z_]\w*)/)[1],
                type: 'function',
                language: 'python'
            })));
        }
        
        return functions;
    }
    
    extractClasses(content) {
        const classes = [];
        
        // Для JavaScript (ES6 Classes)
        const jsClasses = content.match(/class\s+([a-zA-Z_]\w*)\s+{/g);
        if (jsClasses) {
            classes.push(...jsClasses.map(cls => ({
                name: cls.match(/class\s+([a-zA-Z_]\w*)/)[1],
                type: 'class',
                language: 'javascript'
            })));
        }
        
        // Для Python
        const pyClasses = content.match(/class\s+([a-zA-Z_]\w*)\s*[:\(]/g);
        if (pyClasses) {
            classes.push(...pyClasses.map(cls => ({
                name: cls.match(/class\s+([a-zA-Z_]\w*)/)[1],
                type: 'class',
                language: 'python'
            })));
        }
        
        return classes;
    }
    
    estimateSeverity(vulnerabilityType) {
        const severityMap = {
            'sqlInjection': 'CRITICAL',
            'xss': 'HIGH',
            'commandInjection': 'CRITICAL',
            'pathTraversal': 'HIGH',
            'hardcodedCredentials': 'CRITICAL'
        };
        
        return severityMap[vulnerabilityType] || 'MEDIUM';
    }
    
    async analyzeCodeQuality(files) {
        const quality = {
            totalFiles: files.length,
            duplicatedCode: 0,
            complexFunctions: [],
            securityIssues: 0,
            maintainability: 0
        };
        
        // Простой анализ качества (в реальности использовать специализированные инструменты)
        let totalSecurityIssues = 0;
        
        for (const file of files) {
            const fileContent = require('fs').readFileSync(file, 'utf8');
            totalSecurityIssues += this.countSecurityIssuesInFile(fileContent);
        }
        
        quality.securityIssues = totalSecurityIssues;
        quality.maintainability = this.calculateMaintainability(files);
        
        return quality;
    }
    
    countSecurityIssuesInFile(content) {
        let count = 0;
        const contentLower = content.toLowerCase();
        
        // Простой подсчет потенциальных проблем
        if (contentLower.includes('eval(')) count++;
        if (contentLower.includes('innerhtml')) count++;
        if (contentLower.includes('document.write')) count++;
        if (contentLower.includes('exec(')) count++;
        if (contentLower.includes('password') && contentLower.includes('=')) count++;
        
        return count;
    }
    
    calculateMaintainability(files) {
        // Упрощенный расчет поддерживаемости
        // В реальности использовать инструменты анализа кода
        return 75; // из 100
    }
    
    async performCodeReview() {
        const review = {
            securityBestPractices: await this.checkSecurityBestPractices(),
            inputValidation: await this.checkInputValidation(),
            outputEncoding: await this.checkOutputEncoding(),
            authentication: await this.checkAuthentication(),
            authorization: await this.checkAuthorization(),
            errorHandling: await this.checkErrorHandling(),
            cryptography: await this.checkCryptography(),
            dependencies: await this.checkDependencies()
        };
        
        return review;
    }
    
    async checkSecurityBestPractices() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                // Проверка на использование eval()
                if (/\beval\s*\(/.test(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Use of eval() function',
                        severity: 'HIGH',
                        recommendation: 'Avoid eval(), use JSON.parse() or other safer alternatives'
                    });
                }
                
                // Проверка на использование innerHTML
                if (/(innerHTML|outerHTML)\s*=/.test(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Direct assignment to innerHTML/outerHTML',
                        severity: 'HIGH',
                        recommendation: 'Use textContent or proper sanitization'
                    });
                }
                
                // Проверка на хранение чувствительных данных
                if (this.containsSensitiveData(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Sensitive data in source code',
                        severity: 'CRITICAL',
                        recommendation: 'Move sensitive data to environment variables or secure storage',
                        code: line.trim()
                    });
                }
            }
        }
        
        return { issues, compliance: issues.length === 0 };
    }
    
    containsSensitiveData(line) {
        const sensitivePatterns = [
            /password\s*[:=]/i,
            /token\s*[:=]/i,
            /secret\s*[:=]/i,
            /key\s*[:=]/i,
            /api[_-]?key\s*[:=]/i,
            /private[_-]?key\s*[:=]/i,
            /certificate\s*[:=]/i
        ];
        
        return sensitivePatterns.some(pattern => pattern.test(line));
    }
    
    async checkInputValidation() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                // Проверка на отсутствие валидации входных данных
                if (this.looksLikeInputUsage(line) && !this.hasValidation(line, lines, index)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Missing input validation',
                        severity: 'HIGH',
                        code: line.trim(),
                        recommendation: 'Implement proper input validation and sanitization'
                    });
                }
            }
        }
        
        return { issues, validationCoverage: this.calculateValidationCoverage(issues) };
    }
    
    looksLikeInputUsage(line) {
        const inputPatterns = [
            /req\./, // Express.js request
            /request\./, // Generic request
            /input\./, // HTML input
            /document\./, // DOM manipulation
            /params\./, // Route parameters
            /query\./, // Query parameters
            /body\./, // Request body
            /headers\./ // Request headers
        ];
        
        return inputPatterns.some(pattern => pattern.test(line));
    }
    
    hasValidation(line, allLines, currentIndex) {
        // Проверка на наличие валидации в окрестности
        const validationPatterns = [
            /validate/,
            /sanitize/,
            /escape/,
            /filter/,
            /check/,
            /verify/,
            /assert/,
            /is[A-Z]/,
            /has[A-Z]/
        ];
        
        // Проверяем текущую строку и несколько предыдущих
        for (let i = Math.max(0, currentIndex - 5); i <= currentIndex; i++) {
            if (i < allLines.length && validationPatterns.some(pattern => pattern.test(allLines[i]))) {
                return true;
            }
        }
        
        return false;
    }
    
    calculateValidationCoverage(issues) {
        // Простой расчет покрытия валидации
        return issues.length > 0 ? 0 : 100;
    }
    
    async checkOutputEncoding() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                // Проверка на небезопасный вывод
                if (this.looksLikeUnsafeOutput(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Potentially unsafe output encoding',
                        severity: 'HIGH',
                        code: line.trim(),
                        recommendation: 'Implement proper output encoding'
                    });
                }
            }
        }
        
        return { issues, encodingCoverage: this.calculateEncodingCoverage(issues) };
    }
    
    looksLikeUnsafeOutput(line) {
        const unsafeOutputPatterns = [
            /innerHTML\s*=/,
            /outerHTML\s*=/,
            /write\s*\(/,
            /writeln\s*\(/,
            /element\.\w+\s*=\s*/,
            /document\.\w+\s*=\s*/
        ];
        
        return unsafeOutputPatterns.some(pattern => pattern.test(line));
    }
    
    calculateEncodingCoverage(issues) {
        return issues.length > 0 ? 0 : 100;
    }
    
    async checkAuthentication() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                // Проверка на отсутствие аутентификации
                if (this.looksLikeProtectedRoute(line) && !this.hasAuthentication(line, allLines, index)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Missing authentication check',
                        severity: 'CRITICAL',
                        code: line.trim(),
                        recommendation: 'Implement proper authentication for protected routes'
                    });
                }
            }
        }
        
        return { issues, authenticationCoverage: this.calculateAuthCoverage(issues) };
    }
    
    looksLikeProtectedRoute(line) {
        const routePatterns = [
            /\/admin/,
            /\/api\/v\d+\/\w+\/\w+/,
            /\/dashboard/,
            /\/settings/,
            /\/profile/,
            /\/user\/\w+/
        ];
        
        return routePatterns.some(pattern => pattern.test(line));
    }
    
    hasAuthentication(line, allLines, currentIndex) {
        const authPatterns = [
            /auth/i,
            /login/i,
            /session/i,
            /jwt/i,
            /token/i,
            /verify/i,
            /authenticate/i,
            /middleware/i
        ];
        
        // Проверяем текущую строку и несколько окружающих
        const start = Math.max(0, currentIndex - 10);
        const end = Math.min(allLines.length, currentIndex + 10);
        
        for (let i = start; i <= end; i++) {
            if (authPatterns.some(pattern => pattern.test(allLines[i]))) {
                return true;
            }
        }
        
        return false;
    }
    
    calculateAuthCoverage(issues) {
        return issues.length > 0 ? 0 : 100;
    }
    
    async checkAuthorization() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                if (this.looksLikeAdminFunction(line) && !this.hasAuthorization(line, lines, index)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Missing authorization check',
                        severity: 'CRITICAL',
                        code: line.trim(),
                        recommendation: 'Implement proper authorization for admin functions'
                    });
                }
            }
        }
        
        return { issues, authorizationCoverage: this.calculateAuthzCoverage(issues) };
    }
    
    looksLikeAdminFunction(line) {
        const adminPatterns = [
            /admin/i,
            /delete/i,
            /remove/i,
            /settings/i,
            /config/i,
            /system/i,
            /user.*role/i,
            /privilege/i,
            /permission/i
        ];
        
        return adminPatterns.some(pattern => pattern.test(line));
    }
    
    hasAuthorization(line, allLines, currentIndex) {
        const authzPatterns = [
            /permission/i,
            /role/i,
            /authorize/i,
            /allow/i,
            /check.*access/i,
            /can.*access/i,
            /has.*permission/i
        ];
        
        const start = Math.max(0, currentIndex - 10);
        const end = Math.min(allLines.length, currentIndex + 10);
        
        for (let i = start; i <= end; i++) {
            if (authzPatterns.some(pattern => pattern.test(allLines[i]))) {
                return true;
            }
        }
        
        return false;
    }
    
    calculateAuthzCoverage(issues) {
        return issues.length > 0 ? 0 : 100;
    }
    
    async checkErrorHandling() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                // Проверка на раскрытие информации в ошибках
                if (this.looksLikeErrorWithSensitiveInfo(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Potential sensitive information disclosure in error handling',
                        severity: 'MEDIUM',
                        code: line.trim(),
                        recommendation: 'Implement generic error messages'
                    });
                }
            }
        }
        
        return { issues, errorHandlingQuality: this.calculateErrorHandlingQuality(issues) };
    }
    
    looksLikeErrorWithSensitiveInfo(line) {
        const sensitiveErrorPatterns = [
            /error.*sql/i,
            /exception.*stack/i,
            /traceback/i,
            /debug.*info/i,
            /error.*database/i,
            /exception.*path/i
        ];
        
        return sensitiveErrorPatterns.some(pattern => pattern.test(line));
    }
    
    calculateErrorHandlingQuality(issues) {
        return issues.length > 0 ? 50 : 100; // Условно
    }
    
    async checkCryptography() {
        const issues = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                if (this.looksLikeWeakCrypto(line)) {
                    issues.push({
                        file: file.path,
                        line: index + 1,
                        issue: 'Use of weak cryptographic practices',
                        severity: 'HIGH',
                        code: line.trim(),
                        recommendation: 'Use strong cryptographic algorithms and proper key management'
                    });
                }
            }
        }
        
        return { issues, cryptoQuality: this.calculateCryptoQuality(issues) };
    }
    
    looksLikeWeakCrypto(line) {
        const weakCryptoPatterns = [
            /md5/i,
            /sha1/i,
            /des/i,
            /rc4/i,
            /base64.*encrypt/i,
            /xor.*encrypt/i,
            /simple.*hash/i,
            /custom.*crypto/i
        ];
        
        return weakCryptoPatterns.some(pattern => pattern.test(line));
    }
    
    calculateCryptoQuality(issues) {
        return issues.length > 0 ? 0 : 100;
    }
    
    async checkDependencies() {
        const issues = [];
        
        // Проверка файлов зависимостей
        const depFiles = ['package.json', 'requirements.txt', 'Gemfile', 'composer.json'];
        
        for (const depFile of depFiles) {
            const fullPath = require('path').join(this.sourcePath, depFile);
            if (require('fs').existsSync(fullPath)) {
                const depContent = require('fs').readFileSync(fullPath, 'utf8');
                const vulnerableDeps = await this.checkForVulnerableDependencies(depContent, depFile);
                issues.push(...vulnerableDeps);
            }
        }
        
        return { issues, dependencyHealth: this.calculateDependencyHealth(issues) };
    }
    
    async checkForVulnerableDependencies(content, fileType) {
        const issues = [];
        
        if (fileType === 'package.json') {
            try {
                const packageJson = JSON.parse(content);
                const dependencies = {
                    ...packageJson.dependencies,
                    ...packageJson.devDependencies
                };
                
                for (const [dep, version] of Object.entries(dependencies)) {
                    // В реальности проверять через npm audit API или подобное
                    // Заглушка для примера
                    if (dep.includes('vulnerable') || version.includes('vuln')) {
                        issues.push({
                            dependency: dep,
                            version: version,
                            issue: 'Potentially vulnerable dependency',
                            severity: 'HIGH',
                            fileType: fileType,
                            recommendation: 'Update to secure version or find alternative'
                        });
                    }
                }
            } catch (error) {
                console.error('Error parsing package.json:', error);
            }
        }
        
        return issues;
    }
    
    calculateDependencyHealth(issues) {
        return issues.length > 0 ? 50 : 100; // Условно
    }
    
    async performStaticAnalysis() {
        const analysis = {
            sastFindings: await this.runSAST(),
            complexityMetrics: await this.calculateComplexity(),
            codeSmells: await this.identifyCodeSmells(),
            securityHotspots: await this.identifySecurityHotspots()
        };
        
        return analysis;
    }
    
    async runSAST() {
        const findings = [];
        
        // Запуск статического анализа
        for (const file of this.sourceCode) {
            const fileFindings = await this.analyzeFileForSAST(file);
            findings.push(...fileFindings);
        }
        
        return findings;
    }
    
    async analyzeFileForSAST(file) {
        const findings = [];
        const content = file.content;
        const lines = content.split('\n');
        
        for (const [index, line] of lines.entries()) {
            // Проверка на различные шаблоны уязвимостей
            for (const [vulnType, patterns] of Object.entries(this.vulnerabilityPatterns)) {
                for (const pattern of patterns) {
                    if (pattern.test(line)) {
                        findings.push({
                            file: file.path,
                            line: index + 1,
                            type: vulnType,
                            code: line.trim(),
                            severity: this.estimateSeverity(vulnType),
                            pattern: pattern.toString(),
                            description: this.getVulnerabilityDescription(vulnType)
                        });
                    }
                }
            }
        }
        
        return findings;
    }
    
    getVulnerabilityDescription(vulnType) {
        const descriptions = {
            'sqlInjection': 'Unsanitized input used in SQL query - can lead to data theft or manipulation',
            'xss': 'Unsanitized input reflected in output - can lead to client-side code execution',
            'commandInjection': 'Unsanitized input used in system command - can lead to RCE',
            'pathTraversal': 'Unsanitized input used in file operations - can lead to arbitrary file access',
            'hardcodedCredentials': 'Sensitive credentials stored in source code - can lead to unauthorized access'
        };
        
        return descriptions[vulnType] || 'Potential security vulnerability';
    }
    
    async calculateComplexity() {
        const metrics = {
            cyclomaticComplexity: 0,
            halsteadMetrics: {},
            maintainabilityIndex: 0
        };
        
        // В реальности использовать специализированные инструменты
        // Заглушка для примера
        metrics.cyclomaticComplexity = 10; // условное значение
        metrics.maintainabilityIndex = 65; // условное значение
        
        return metrics;
    }
    
    async identifyCodeSmells() {
        const smells = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                if (this.looksLikeCodeSmell(line)) {
                    smells.push({
                        file: file.path,
                        line: index + 1,
                        smell: this.identifySpecificSmell(line),
                        code: line.trim(),
                        severity: 'MEDIUM'
                    });
                }
            }
        }
        
        return smells;
    }
    
    looksLikeCodeSmell(line) {
        const smellPatterns = [
            /function.*{\s*\n\s*\w.*\n\s*}/, // Empty functions
            /if\s*\([^)]+\)\s*{\s*}/, // Empty if blocks
            /try\s*{\s*\n\s*\w.*\n\s*}\s*catch/, // Catch blocks without proper handling
            /console\.log\([^)]*password|token|secret/i, // Debugging sensitive data
            /TODO|FIXME|HACK|BUG/i // Code comments indicating problems
        ];
        
        return smellPatterns.some(pattern => pattern.test(line));
    }
    
    identifySpecificSmell(line) {
        if (line.includes('console.log') && /password|token|secret/i.test(line)) {
            return 'Debug logging of sensitive data';
        }
        if (/TODO|FIXME|HACK|BUG/i.test(line)) {
            return 'Technical debt marker';
        }
        if (/\s*{\s*}\s*$/.test(line)) {
            return 'Empty code block';
        }
        return 'General code smell';
    }
    
    async identifySecurityHotspots() {
        const hotspots = [];
        
        for (const file of this.sourceCode) {
            const content = file.content;
            const lines = content.split('\n');
            
            for (const [index, line] of lines.entries()) {
                if (this.looksLikeSecurityHotspot(line)) {
                    hotspots.push({
                        file: file.path,
                        line: index + 1,
                        hotspots: this.identifySpecificHotspots(line),
                        code: line.trim(),
                        severity: this.estimateSecurityRisk(line)
                    });
                }
            }
        }
        
        return hotspots;
    }
    
    looksLikeSecurityHotspot(line) {
        const hotspotPatterns = [
            /crypto/i,
            /hash/i,
            /encrypt/i,
            /decrypt/i,
            /encode/i,
            /decode/i,
            /password/i,
            /token/i,
            /secret/i,
            /key/i,
            /auth/i,
            /session/i,
            /cookie/i,
            /jwt/i,
            /oauth/i,
            /saml/i,
            /ldap/i,
            /sso/i
        ];
        
        return hotspotPatterns.some(pattern => pattern.test(line));
    }
    
    identifySpecificHotspots(line) {
        const hotspots = [];
        
        if (/crypto/i.test(line)) hotspots.push('Cryptographic implementation');
        if (/password|token|secret/i.test(line)) hotspots.push('Sensitive data handling');
        if (/auth|session|cookie/i.test(line)) hotspots.push('Authentication/Session management');
        if (/saml|oauth|ldap/i.test(line)) hotspots.push('Identity management');
        
        return hotspots;
    }
    
    estimateSecurityRisk(line) {
        if (/(password|token|secret).*=/i.test(line)) return 'CRITICAL';
        if (/(crypto|hash|encrypt).*=/i.test(line)) return 'HIGH';
        if (/(auth|session|cookie).*=/i.test(line)) return 'MEDIUM';
        return 'LOW';
    }
    
    generateWhiteBoxReport(results) {
        return {
            methodology: 'White Box Testing',
            target: results.target,
            sourceAnalysis: results.sourceAnalysis,
            codeReview: results.codeReview,
            staticAnalysis: results.staticAnalysis,
            summary: this.generateSummary(results),
            recommendations: this.generateRecommendations(results),
            severityBreakdown: this.getSeverityBreakdown(results),
            nextSteps: this.getNextSteps(results)
        };
    }
    
    generateSummary(results) {
        const totalIssues = this.countTotalIssues(results);
        const critical = this.countBySeverity(results, 'CRITICAL');
        const high = this.countBySeverity(results, 'HIGH');
        const medium = this.countBySeverity(results, 'MEDIUM');
        const low = this.countBySeverity(results, 'LOW');
        
        return {
            totalIssues,
            critical,
            high,
            medium,
            low,
            securityPosture: this.assessSecurityPosture(critical, high, medium, low)
        };
    }
    
    countTotalIssues(results) {
        let count = 0;
        
        // Подсчет в статическом анализе
        count += results.staticAnalysis.sastFindings.length;
        
        // Подсчет в результатах ревью кода
        for (const review of Object.values(results.codeReview)) {
            if (Array.isArray(review.issues)) {
                count += review.issues.length;
            }
        }
        
        return count;
    }
    
    countBySeverity(results, severity) {
        let count = 0;
        
        // В SAST результатах
        count += results.staticAnalysis.sastFindings.filter(f => f.severity === severity).length;
        
        // В результатах ревью
        for (const review of Object.values(results.codeReview)) {
            if (Array.isArray(review.issues)) {
                count += review.issues.filter(i => i.severity === severity).length;
            }
        }
        
        return count;
    }
    
    assessSecurityPosture(critical, high, medium, low) {
        if (critical > 0) return 'CRITICAL - Immediate action required';
        if (high > 5) return 'HIGH - Significant security issues present';
        if (high > 0) return 'MEDIUM - Several high severity issues';
        if (medium > 10) return 'MEDIUM - Multiple medium severity issues';
        if (medium > 0) return 'LOW-MEDIUM - Some security concerns';
        if (low > 0) return 'LOW - Minor security concerns';
        return 'GOOD - No significant security issues found';
    }
    
    generateRecommendations(results) {
        const recommendations = [];
        
        const sastFindings = results.staticAnalysis.sastFindings;
        const codeReview = results.codeReview;
        
        // Рекомендации по SAST находкам
        const sastByType = this.groupByType(sastFindings);
        for (const [type, findings] of Object.entries(sastByType)) {
            recommendations.push({
                category: type,
                count: findings.length,
                priority: this.getPriorityByType(type),
                recommendation: this.getRecommendationByType(type),
                impactedFiles: [...new Set(findings.map(f => f.file))]
            });
        }
        
        // Рекомендации по результатам ревью кода
        for (const [reviewType, reviewResult] of Object.entries(codeReview)) {
            if (reviewResult.issues && reviewResult.issues.length > 0) {
                recommendations.push({
                    category: reviewType,
                    count: reviewResult.issues.length,
                    priority: 'HIGH',
                    recommendation: `Address ${reviewType} issues in the codebase`,
                    impactedFiles: [...new Set(reviewResult.issues.map(i => i.file))]
                });
            }
        }
        
        return recommendations;
    }
    
    groupByType(findings) {
        const grouped = {};
        for (const finding of findings) {
            if (!grouped[finding.type]) grouped[finding.type] = [];
            grouped[finding.type].push(finding);
        }
        return grouped;
    }
    
    getPriorityByType(type) {
        const priorityMap = {
            'sqlInjection': 'CRITICAL',
            'xss': 'HIGH',
            'commandInjection': 'CRITICAL',
            'pathTraversal': 'HIGH',
            'hardcodedCredentials': 'CRITICAL'
        };
        return priorityMap[type] || 'MEDIUM';
    }
    
    getRecommendationByType(type) {
        const recommendations = {
            'sqlInjection': 'Use parameterized queries or prepared statements',
            'xss': 'Implement proper input validation and output encoding',
            'commandInjection': 'Validate and sanitize all user inputs before using in system commands',
            'pathTraversal': 'Validate file paths and use allow-lists for file access',
            'hardcodedCredentials': 'Move credentials to environment variables or secure vault'
        };
        return recommendations[type] || 'Review and secure the implementation';
    }
    
    getSeverityBreakdown(results) {
        const breakdown = {
            CRITICAL: this.countBySeverity(results, 'CRITICAL'),
            HIGH: this.countBySeverity(results, 'HIGH'),
            MEDIUM: this.countBySeverity(results, 'MEDIUM'),
            LOW: this.countBySeverity(results, 'LOW')
        };
        
        return breakdown;
    }
    
    getNextSteps(results) {
        const steps = [];
        
        const critical = this.countBySeverity(results, 'CRITICAL');
        const high = this.countBySeverity(results, 'HIGH');
        
        if (critical > 0) {
            steps.push('1. Address all CRITICAL vulnerabilities immediately');
            steps.push('2. Conduct emergency security review');
            steps.push('3. Plan for immediate deployment of fixes');
        }
        
        if (high > 0) {
            steps.push('1. Prioritize fixing HIGH severity issues');
            steps.push('2. Implement compensating controls where immediate fixes not possible');
            steps.push('3. Schedule fixes in next sprint');
        }
        
        steps.push('1. Implement security training for development team');
        steps.push('2. Deploy automated security scanning in CI/CD');
        steps.push('3. Establish regular security code reviews');
        steps.push('4. Plan for retesting after fixes');
        
        return steps;
    }
}

// Использование White Box тестера
const whiteBoxTester = new WhiteBoxTester('./src', 'https://example.com');

async function runWhiteBoxTest() {
    const results = await whiteBoxTester.performWhiteBoxTest();
    console.log('White Box Test Results:', JSON.stringify(results, null, 2));
    return results;
}
```

## Инструменты тестирования

### 1. SAST инструменты

```javascript
// Интеграция с SAST инструментами
class SASTIntegration {
    constructor(tool) {
        this.tool = tool;
        this.config = this.getDefaultConfig();
    }
    
    getDefaultConfig() {
        const configs = {
            sonarqube: {
                host: process.env.SONAR_HOST || 'http://localhost:9000',
                projectKey: process.env.SONAR_PROJECT_KEY,
                token: process.env.SONAR_TOKEN,
                properties: {
                    'sonar.sources': 'src',
                    'sonar.tests': 'test',
                    'sonar.java.binaries': 'target/classes',
                    'sonar.java.test.binaries': 'target/test-classes'
                }
            },
            semgrep: {
                config: 'p/security-audit',
                targets: ['.'],
                exclude: ['node_modules', 'vendor', 'build', 'dist'],
                outputFormat: 'json'
            },
            checkmarx: {
                serverUrl: process.env.CHECKMARX_SERVER,
                username: process.env.CHECKMARX_USERNAME,
                password: process.env.CHECKMARX_PASSWORD,
                projectName: process.env.CHECKMARX_PROJECT_NAME
            }
        };
        
        return configs[this.tool] || {};
    }
    
    async runScan(targetPath) {
        switch (this.tool) {
            case 'sonarqube':
                return await this.runSonarQubeScan(targetPath);
            case 'semgrep':
                return await this.runSemgrepScan(targetPath);
            case 'checkmarx':
                return await this.runCheckmarxScan(targetPath);
            default:
                throw new Error(`Unsupported SAST tool: ${this.tool}`);
        }
    }
    
    async runSonarQubeScan(targetPath) {
        const { exec } = require('child_process');
        const { promisify } = require('util');
        const execAsync = promisify(exec);
        
        try {
            const command = `sonar-scanner -Dsonar.projectKey=${this.config.projectKey} ` +
                           `-Dsonar.sources=${this.config.properties['sonar.sources']} ` +
                           `-Dsonar.host.url=${this.config.host} ` +
                           `-Dsonar.login=${this.config.token}`;
            
            const { stdout, stderr } = await execAsync(command);
            
            return {
                tool: 'SonarQube',
                success: true,
                output: stdout,
                errors: stderr,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'SonarQube',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async runSemgrepScan(targetPath) {
        const { exec } = require('child_process');
        const { promisify } = require('util');
        const execAsync = promisify(exec);
        
        try {
            const excludeArgs = this.config.exclude.map(ex => `--exclude=${ex}`).join(' ');
            const command = `semgrep --config=${this.config.config} ${excludeArgs} --json ${this.config.targets.join(' ')}`;
            
            const { stdout, stderr } = await execAsync(command);
            const results = JSON.parse(stdout);
            
            return {
                tool: 'Semgrep',
                success: true,
                results: results,
                errors: stderr,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'Semgrep',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async runCheckmarxScan(targetPath) {
        // Checkmarx CxConsoleClient
        const { exec } = require('child_process');
        const { promisify } = require('util');
        const execAsync = promisify(exec);
        
        try {
            const command = `CxConsolePlugin.CA.CxConsole.exe -v -preset "Checkmarx Default" ` +
                           `-S "${targetPath}" -2 -LocationType folder -LocationPath "${targetPath}" ` +
                           `-projectName "${this.config.projectName}" -reportDefects`;
            
            const { stdout, stderr } = await execAsync(command);
            
            return {
                tool: 'Checkmarx',
                success: true,
                output: stdout,
                errors: stderr,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'Checkmarx',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async parseResults(toolResults) {
        switch (this.tool) {
            case 'sonarqube':
                return this.parseSonarQubeResults(toolResults);
            case 'semgrep':
                return this.parseSemgrepResults(toolResults);
            case 'checkmarx':
                return this.parseCheckmarxResults(toolResults);
            default:
                throw new Error(`Unsupported tool for parsing: ${this.tool}`);
        }
    }
    
    parseSonarQubeResults(results) {
        // Парсинг результатов SonarQube
        // В реальности результаты получаются через SonarQube API
        return {
            totalIssues: 0,
            bySeverity: { BLOCKER: 0, CRITICAL: 0, MAJOR: 0, MINOR: 0, INFO: 0 },
            issues: []
        };
    }
    
    parseSemgrepResults(results) {
        if (!results.results) return { totalIssues: 0, issues: [] };
        
        const parsed = {
            totalIssues: results.results.length,
            bySeverity: { ERROR: 0, WARNING: 0, INFO: 0 },
            issues: []
        };
        
        for (const result of results.results) {
            const severity = result.extra.severity || 'WARNING';
            parsed.bySeverity[severity] = (parsed.bySeverity[severity] || 0) + 1;
            
            parsed.issues.push({
                severity: result.extra.severity,
                message: result.extra.message,
                location: {
                    file: result.path,
                    start: result.start,
                    end: result.end
                },
                code: result.extra.lines,
                metadata: result.extra.metadata
            });
        }
        
        return parsed;
    }
    
    parseCheckmarxResults(results) {
        // Парсинг результатов Checkmarx
        return {
            totalIssues: 0,
            bySeverity: { HIGH: 0, MEDIUM: 0, LOW: 0 },
            issues: []
        };
    }
    
    async generateReport(toolResults) {
        const parsedResults = await this.parseResults(toolResults);
        
        return {
            tool: this.tool,
            timestamp: new Date().toISOString(),
            summary: {
                totalIssues: parsedResults.totalIssues,
                bySeverity: parsedResults.bySeverity
            },
            detailedResults: parsedResults.issues,
            compliance: this.checkCompliance(parsedResults.issues),
            recommendations: this.generateRecommendations(parsedResults.issues)
        };
    }
    
    checkCompliance(issues) {
        // Проверка соответствия стандартам
        const compliance = {
            owaspTop10: this.checkOWASPCompliance(issues),
            pciDss: this.checkPCIDSSCompliance(issues),
            gdpr: this.checkGDPRCompliance(issues)
        };
        
        return compliance;
    }
    
    checkOWASPTop10(issues) {
        const owaspCategories = {
            'Injection': 0,
            'Broken_Authentication': 0,
            'Sensitive_Data_Exposure': 0,
            'XML_External_Entities': 0,
            'Broken_Access_Control': 0,
            'Security_Misconfiguration': 0,
            'Cross_Site_Scripting': 0,
            'Insecure_Deserialization': 0,
            'Using_Components_with_Known_Vulnerabilities': 0,
            'Insufficient_Logging': 0
        };
        
        for (const issue of issues) {
            if (issue.message.toLowerCase().includes('injection')) {
                owaspCategories.Injection++;
            } else if (issue.message.toLowerCase().includes('auth')) {
                owaspCategories.Broken_Authentication++;
            } else if (issue.message.toLowerCase().includes('xss')) {
                owaspCategories.Cross_Site_Scripting++;
            }
            // Другие категории...
        }
        
        return {
            categories: owaspCategories,
            compliant: Object.values(owaspCategories).every(count => count === 0)
        };
    }
    
    checkPCIDSSCompliance(issues) {
        // Проверка соответствия PCI DSS
        return { compliant: false, gaps: ['SAQ_A', 'SAQ_B'] };
    }
    
    checkGDPRCompliance(issues) {
        // Проверка соответствия GDPR
        return { compliant: false, privacyIssues: [] };
    }
    
    generateRecommendations(issues) {
        const recommendations = [];
        
        if (issues.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address High Severity Issues',
                description: `Found ${issues.filter(i => i.severity === 'ERROR').length} high severity issues`,
                action: 'Fix immediately'
            });
        }
        
        const injectionIssues = issues.filter(i => i.message.toLowerCase().includes('injection'));
        if (injectionIssues.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Implement Input Validation',
                description: 'Multiple injection vulnerabilities detected',
                action: 'Use parameterized queries and input sanitization'
            });
        }
        
        const authIssues = issues.filter(i => i.message.toLowerCase().includes('auth'));
        if (authIssues.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Strengthen Authentication',
                description: 'Authentication-related issues found',
                action: 'Implement multi-factor authentication and session management'
            });
        }
        
        return recommendations;
    }
}

// Использование SAST интеграции
async function runSASTScan() {
    const sast = new SASTIntegration('semgrep');
    const results = await sast.runScan('./src');
    const report = await sast.generateReport(results);
    
    console.log('SAST Scan Report:', JSON.stringify(report, null, 2));
    return report;
}
```

### 2. DAST инструменты

```javascript
// Интеграция с DAST инструментами
class DASTIntegration {
    constructor(tool) {
        this.tool = tool;
        this.config = this.getDefaultConfig();
    }
    
    getDefaultConfig() {
        const configs = {
            zap: {
                host: process.env.ZAP_HOST || 'localhost',
                port: process.env.ZAP_PORT || 8080,
                apikey: process.env.ZAP_API_KEY,
                target: null,
                context: 'Default Context',
                excludedPaths: ['/login', '/admin']
            },
            burp: {
                host: process.env.BURP_HOST || 'localhost',
                port: process.env.BURP_PORT || 1337,
                apikey: process.env.BURP_API_KEY,
                target: null,
                scope: []
            },
            netsparker: {
                apiUrl: process.env.NETSPARKER_API_URL,
                apiToken: process.env.NETSPARKER_API_TOKEN,
                target: null
            }
        };
        
        return configs[this.tool] || {};
    }
    
    async runScan(target) {
        this.config.target = target;
        
        switch (this.tool) {
            case 'zap':
                return await this.runZAPScan(target);
            case 'burp':
                return await this.runBurpScan(target);
            case 'netsparker':
                return await this.runNetSparkerScan(target);
            default:
                throw new Error(`Unsupported DAST tool: ${this.tool}`);
        }
    }
    
    async runZAPScan(target) {
        const axios = require('axios');
        
        try {
            const baseUrl = `http://${this.config.host}:${this.config.port}`;
            const zapApiUrl = `${baseUrl}/JSON/core/action/accessUrl/?apikey=${this.config.apikey}&url=${encodeURIComponent(target)}`;
            
            // Отправка запроса в ZAP
            await axios.get(zapApiUrl);
            
            // Запуск активного сканирования
            const scanUrl = `${baseUrl}/JSON/ascan/action/scan/?apikey=${this.config.apikey}&url=${encodeURIComponent(target)}`;
            const scanResponse = await axios.get(scanUrl);
            const scanId = scanResponse.data.scan;
            
            // Ожидание завершения сканирования
            let scanProgress = 0;
            while (scanProgress < 100) {
                const progressUrl = `${baseUrl}/JSON/ascan/view/status/?apikey=${this.config.apikey}&scanId=${scanId}`;
                const progressResponse = await axios.get(progressUrl);
                scanProgress = parseInt(progressResponse.data.status);
                
                await new Promise(resolve => setTimeout(resolve, 5000)); // Ждать 5 секунд
            }
            
            // Получение результатов
            const alertsUrl = `${baseUrl}/JSON/core/view/alerts/?apikey=${this.config.apikey}&baseurl=${encodeURIComponent(target)}`;
            const alertsResponse = await axios.get(alertsUrl);
            
            return {
                tool: 'ZAP',
                success: true,
                scanId: scanId,
                alerts: alertsResponse.data.alerts || [],
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'ZAP',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async runBurpScan(target) {
        const axios = require('axios');
        
        try {
            const burpApiUrl = `http://${this.config.host}:${this.config.port}/burp/api`;
            
            // Создание нового сканирования
            const scanConfig = {
                scope: [target],
                scan_configurations: ['active', 'passive']
            };
            
            const response = await axios.post(`${burpApiUrl}/scans`, scanConfig, {
                headers: {
                    'X-ApiKey': this.config.apikey,
                    'Content-Type': 'application/json'
                }
            });
            
            const scanId = response.data.scan_id;
            
            // Ожидание завершения сканирования
            let scanComplete = false;
            while (!scanComplete) {
                const statusResponse = await axios.get(`${burpApiUrl}/scans/${scanId}/status`, {
                    headers: { 'X-ApiKey': this.config.apikey }
                });
                
                scanComplete = statusResponse.data.status === 'COMPLETE';
                if (!scanComplete) {
                    await new Promise(resolve => setTimeout(resolve, 10000)); // Ждать 10 секунд
                }
            }
            
            // Получение результатов
            const resultsResponse = await axios.get(`${burpApiUrl}/scans/${scanId}/results`, {
                headers: { 'X-ApiKey': this.config.apikey }
            });
            
            return {
                tool: 'Burp',
                success: true,
                scanId: scanId,
                results: resultsResponse.data.results || [],
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'Burp',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async runNetSparkerScan(target) {
        const axios = require('axios');
        
        try {
            const response = await axios.post(`${this.config.apiUrl}/scans`, {
                scan: {
                    target: target,
                    scanType: 'full',
                    authentication: {
                        enabled: false
                    },
                    crawling: {
                        enabled: true,
                        maxDepth: 5
                    },
                    testing: {
                        enabled: true,
                        attackStrength: 'high'
                    }
                }
            }, {
                headers: {
                    'Authorization': `Bearer ${this.config.apiToken}`,
                    'Content-Type': 'application/json'
                }
            });
            
            const scanId = response.data.scanId;
            
            // Ожидание завершения
            let scanStatus = 'running';
            while (scanStatus === 'running') {
                const statusResponse = await axios.get(`${this.config.apiUrl}/scans/${scanId}`, {
                    headers: { 'Authorization': `Bearer ${this.config.apiToken}` }
                });
                
                scanStatus = statusResponse.data.status;
                if (scanStatus === 'running') {
                    await new Promise(resolve => setTimeout(resolve, 30000)); // Ждать 30 секунд
                }
            }
            
            // Получение отчета
            const reportResponse = await axios.get(`${this.config.apiUrl}/scans/${scanId}/report`, {
                headers: { 'Authorization': `Bearer ${this.config.apiToken}` }
            });
            
            return {
                tool: 'NetSparker',
                success: true,
                scanId: scanId,
                report: reportResponse.data,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return {
                tool: 'NetSparker',
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    
    async parseResults(toolResults) {
        switch (this.tool) {
            case 'zap':
                return this.parseZAPResults(toolResults);
            case 'burp':
                return this.parseBurpResults(toolResults);
            case 'netsparker':
                return this.parseNetSparkerResults(toolResults);
            default:
                throw new Error(`Unsupported tool for parsing: ${this.tool}`);
        }
    }
    
    parseZAPResults(results) {
        const parsed = {
            totalAlerts: results.alerts?.length || 0,
            byRisk: { High: 0, Medium: 0, Low: 0, Informational: 0 },
            alerts: []
        };
        
        if (results.alerts) {
            for (const alert of results.alerts) {
                const risk = alert.risk || 'Informational';
                parsed.byRisk[risk] = (parsed.byRisk[risk] || 0) + 1;
                
                parsed.alerts.push({
                    risk: alert.risk,
                    alert: alert.alert,
                    description: alert.description,
                    solution: alert.solution,
                    url: alert.url,
                    param: alert.param,
                    attack: alert.attack,
                    evidence: alert.evidence,
                    reference: alert.reference,
                    cweid: alert.cweid,
                    wascid: alert.wascid
                });
            }
        }
        
        return parsed;
    }
    
    parseBurpResults(results) {
        // Парсинг результатов Burp
        return {
            totalIssues: results.results?.length || 0,
            bySeverity: { Critical: 0, High: 0, Medium: 0, Low: 0, Information: 0 },
            issues: []
        };
    }
    
    parseNetSparkerResults(results) {
        // Парсинг результатов NetSparker
        return {
            totalIssues: results.report?.vulnerabilities?.length || 0,
            bySeverity: { Critical: 0, High: 0, Medium: 0, Low: 0 },
            vulnerabilities: []
        };
    }
    
    async generateReport(toolResults) {
        const parsedResults = await this.parseResults(toolResults);
        
        return {
            tool: this.tool,
            target: this.config.target,
            timestamp: new Date().toISOString(),
            summary: {
                totalIssues: parsedResults.totalAlerts || parsedResults.totalIssues,
                bySeverity: parsedResults.byRisk || parsedResults.bySeverity
            },
            detailedResults: parsedResults.alerts || parsedResults.issues || parsedResults.vulnerabilities,
            riskAssessment: this.assessRisk(parsedResults),
            recommendations: this.generateRecommendations(parsedResults),
            compliance: this.checkCompliance(parsedResults)
        };
    }
    
    assessRisk(results) {
        const high = results.byRisk?.High || results.bySeverity?.High || 0;
        const critical = results.byRisk?.Critical || results.bySeverity?.Critical || 0;
        const medium = results.byRisk?.Medium || results.bySeverity?.Medium || 0;
        
        if (critical > 0) return 'CRITICAL';
        if (high > 5) return 'HIGH';
        if (high > 0) return 'MEDIUM-HIGH';
        if (medium > 10) return 'MEDIUM';
        if (medium > 0) return 'LOW-MEDIUM';
        return 'LOW';
    }
    
    generateRecommendations(results) {
        const recommendations = [];
        
        if (results.byRisk) {
            if (results.byRisk.High > 0) {
                recommendations.push({
                    priority: 'HIGH',
                    title: 'Address High Risk Issues',
                    description: `Found ${results.byRisk.High} high risk security issues`,
                    action: 'Fix immediately, implement compensating controls'
                });
            }
            
            if (results.byRisk.Medium > 0) {
                recommendations.push({
                    priority: 'MEDIUM',
                    title: 'Resolve Medium Risk Issues',
                    description: `Found ${results.byRisk.Medium} medium risk security issues`,
                    action: 'Schedule fixes in upcoming sprints'
                });
            }
        }
        
        return recommendations;
    }
    
    checkCompliance(results) {
        // Проверка соответствия стандартам безопасности
        return {
            owaspTop10: this.checkOWASPCompliance(results),
            pciDss: this.checkPCIDSSCompliance(results),
            iso27001: this.checkISO27001Compliance(results)
        };
    }
    
    checkOWASPCompliance(results) {
        const issues = results.alerts || results.issues || [];
        const injectionIssues = issues.filter(i => i.alert?.toLowerCase().includes('injection'));
        const authIssues = issues.filter(i => i.alert?.toLowerCase().includes('auth'));
        const xssIssues = issues.filter(i => i.alert?.toLowerCase().includes('xss'));
        
        return {
            compliant: injectionIssues.length === 0 && authIssues.length === 0 && xssIssues.length === 0,
            gaps: {
                injection: injectionIssues.length,
                authentication: authIssues.length,
                xss: xssIssues.length
            }
        };
    }
    
    checkPCIDSSCompliance(results) {
        return { compliant: false, gaps: [] };
    }
    
    checkISO27001Compliance(results) {
        return { compliant: false, gaps: [] };
    }
}

// Использование DAST интеграции
async function runDASTScan() {
    const dast = new DASTIntegration('zap');
    const results = await dast.runScan('https://example.com');
    const report = await dast.generateReport(results);
    
    console.log('DAST Scan Report:', JSON.stringify(report, null, 2));
    return report;
}
```

## Практические примеры тестирования

### 1. Тестирование аутентификации

```javascript
// Тестирование аутентификации
class AuthenticationTester {
    constructor(target) {
        this.target = target;
        this.session = null;
        this.testResults = [];
    }
    
    async testAuthenticationMechanism() {
        const results = {
            defaultCredentials: await this.testDefaultCredentials(),
            bruteForceProtection: await this.testBruteForceProtection(),
            passwordPolicy: await this.testPasswordPolicy(),
            sessionManagement: await this.testSessionManagement(),
            mfa: await this.testMFA(),
            oauth: await this.testOAuthImplementation(),
            summary: null
        };
        
        results.summary = this.generateAuthSummary(results);
        
        return results;
    }
    
    async testDefaultCredentials() {
        const defaultCredentials = [
            { username: 'admin', password: 'admin' },
            { username: 'admin', password: 'password' },
            { username: 'root', password: 'root' },
            { username: 'test', password: 'test' },
            { username: 'guest', password: 'guest' },
            { username: 'user', password: 'password' },
            { username: 'admin', password: 'admin123' },
            { username: 'admin', password: '' },
            { username: 'root', password: '' }
        ];
        
        const findings = [];
        
        for (const creds of defaultCredentials) {
            try {
                const response = await this.attemptLogin(creds);
                
                if (response.success) {
                    findings.push({
                        type: 'Default Credentials',
                        severity: 'CRITICAL',
                        credentials: creds,
                        evidence: 'Successfully logged in with default credentials',
                        cvssScore: 9.8,
                        cweId: 'CWE-798'
                    });
                    
                    // Если дефолтные креды работают, проверить другие
                    break; // Выйти после первого успеха
                }
            } catch (error) {
                // Продолжить с другими кредами
            }
        }
        
        return findings;
    }
    
    async testBruteForceProtection() {
        const findings = [];
        
        // Попытка нескольких неудачных логинов
        const testCredentials = [
            { username: 'test1', password: 'wrong1' },
            { username: 'test2', password: 'wrong2' },
            { username: 'test3', password: 'wrong3' },
            { username: 'test4', password: 'wrong4' },
            { username: 'test5', password: 'wrong5' }
        ];
        
        const startTime = Date.now();
        
        for (const creds of testCredentials) {
            await this.attemptLogin(creds);
        }
        
        const totalTime = Date.now() - startTime;
        const rate = testCredentials.length / (totalTime / 1000); // попыток в секунду
        
        // Если все попытки прошли быстро, вероятно, нет защиты
        if (totalTime < 2000) { // меньше 2 секунд на 5 попыток
            findings.push({
                type: 'Brute Force Vulnerability',
                severity: 'MEDIUM',
                evidence: `Login attempts completed in ${totalTime}ms, rate: ${rate.toFixed(2)} attempts/sec`,
                cvssScore: 5.0,
                cweId: 'CWE-307'
            });
        }
        
        return findings;
    }
    
    async testPasswordPolicy() {
        const findings = [];
        
        // Тестирование различных слабых паролей
        const weakPasswords = [
            '123456',
            'password',
            'admin',
            'letmein',
            'welcome',
            'monkey',
            '1234567890',
            '',
            'a',
            'aa'
        ];
        
        for (const password of weakPasswords) {
            const canRegister = await this.testPasswordRegistration(password);
            if (canRegister) {
                findings.push({
                    type: 'Weak Password Policy',
                    severity: 'HIGH',
                    password: password,
                    evidence: 'System allows registration with weak password',
                    cvssScore: 7.5,
                    cweId: 'CWE-521'
                });
            }
        }
        
        // Тестирование минимальной длины
        const minLengthTest = await this.testPasswordMinLength();
        if (minLengthTest.minLength < 8) {
            findings.push({
                type: 'Insufficient Password Length Requirement',
                severity: 'MEDIUM',
                currentMinLength: minLengthTest.minLength,
                recommendedMinLength: 8,
                evidence: `Minimum password length is only ${minLengthTest.minLength} characters`,
                cvssScore: 5.0,
                cweId: 'CWE-521'
            });
        }
        
        return findings;
    }
    
    async testSessionManagement() {
        const findings = [];
        
        // Тестирование создания сессии
        const loginResult = await this.attemptLogin({ username: 'test', password: 'valid_password' });
        if (!loginResult.success) return findings; // Не можем протестировать без валидной сессии
        
        // Проверка атрибутов cookie
        const sessionCookie = this.extractSessionCookie(loginResult.response);
        if (sessionCookie) {
            if (!sessionCookie.secure) {
                findings.push({
                    type: 'Missing Secure Flag',
                    severity: 'MEDIUM',
                    cookie: sessionCookie.name,
                    evidence: 'Session cookie lacks Secure flag',
                    cvssScore: 5.0,
                    cweId: 'CWE-614'
                });
            }
            
            if (!sessionCookie.httponly) {
                findings.push({
                    type: 'Missing HttpOnly Flag',
                    severity: 'HIGH',
                    cookie: sessionCookie.name,
                    evidence: 'Session cookie lacks HttpOnly flag',
                    cvssScore: 7.5,
                    cweId: 'CWE-16'
                });
            }
            
            if (!sessionCookie.samesite || sessionCookie.samesite.toLowerCase() === 'none') {
                findings.push({
                    type: 'Missing SameSite Attribute',
                    severity: 'MEDIUM',
                    cookie: sessionCookie.name,
                    evidence: 'Session cookie lacks SameSite attribute or set to None',
                    cvssScore: 6.5,
                    cweId: 'CWE-352'
                });
            }
        }
        
        // Тестирование таймаута сессии
        const timeoutResult = await this.testSessionTimeout();
        if (!timeoutResult.hasTimeout) {
            findings.push({
                type: 'Missing Session Timeout',
                severity: 'MEDIUM',
                evidence: 'Session appears to persist indefinitely',
                cvssScore: 5.0,
                cweId: 'CWE-613'
            });
        }
        
        // Тестирование смены токена при аутентификации
        const tokenRenewalResult = await this.testTokenRenewal();
        if (!tokenRenewalResult.renews) {
            findings.push({
                type: 'Predictable Session Token',
                severity: 'HIGH',
                evidence: 'Session token does not change after login',
                cvssScore: 7.5,
                cweId: 'CWE-384'
            });
        }
        
        return findings;
    }
    
    async testMFA() {
        const findings = [];
        
        // Проверка, включена ли MFA по умолчанию
        const mfaStatus = await this.checkMFAStatus();
        
        if (!mfaStatus.enabledByDefault) {
            findings.push({
                type: 'MFA Not Enforced',
                severity: 'MEDIUM',
                evidence: 'Multi-factor authentication is not required by default',
                cvssScore: 6.5,
                cweId: 'CWE-308'
            });
        }
        
        // Проверка на обход MFA
        const bypassTest = await this.testMFABypass();
        if (bypassTest.vulnerable) {
            findings.push({
                type: 'MFA Bypass Vulnerability',
                severity: 'CRITICAL',
                evidence: 'MFA can be bypassed in certain circumstances',
                cvssScore: 9.8,
                cweId: 'CWE-308'
            });
        }
        
        return findings;
    }
    
    async testOAuthImplementation() {
        const findings = [];
        
        // Проверка на insecure OAuth redirects
        const redirectTest = await this.testOAuthRedirects();
        if (redirectTest.vulnerable) {
            findings.push({
                type: 'OAuth Redirect URI Vulnerability',
                severity: 'HIGH',
                evidence: 'OAuth redirect URI can be manipulated',
                cvssScore: 7.7,
                cweId: 'CWE-601'
            });
        }
        
        // Проверка на утечку токенов
        const tokenLeakTest = await this.testTokenLeakage();
        if (tokenLeakTest.vulnerable) {
            findings.push({
                type: 'OAuth Token Leakage',
                severity: 'CRITICAL',
                evidence: 'OAuth tokens may be leaked in URLs or referrer headers',
                cvssScore: 9.1,
                cweId: 'CWE-524'
            });
        }
        
        return findings;
    }
    
    async attemptLogin(credentials) {
        // Попытка логина
        try {
            const response = await fetch(`${this.target}/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(credentials)
            });
            
            const responseBody = await response.text();
            
            // Определение успеха/неудачи
            const successIndicators = [
                response.status === 302, // редирект после логина
                response.status === 200 && responseBody.toLowerCase().includes('dashboard'),
                response.status === 200 && responseBody.toLowerCase().includes('welcome'),
                response.headers.get('set-cookie')?.toLowerCase().includes('session')
            ];
            
            return {
                success: successIndicators.some(indicator => indicator),
                response: response,
                responseBody: responseBody
            };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    async testPasswordRegistration(password) {
        // Проверка, можно ли зарегистрироваться с слабым паролем
        try {
            const response = await fetch(`${this.target}/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    username: `test_${Date.now()}`,
                    email: `test_${Date.now()}@example.com`,
                    password: password
                })
            });
            
            // Если регистрация успешна, значит пароль принят
            return response.status === 200 || response.status === 201;
        } catch (error) {
            return false;
        }
    }
    
    async testPasswordMinLength() {
        // Тестирование минимальной длины пароля
        const testPasswords = [
            { pwd: 'a', shouldWork: false },
            { pwd: 'aa', shouldWork: false },
            { pwd: 'aaa', shouldWork: false },
            { pwd: 'aaaa', shouldWork: false },
            { pwd: 'aaaaa', shouldWork: false },
            { pwd: 'aaaaaa', shouldWork: false }, // 6 chars
            { pwd: 'aaaaaaa', shouldWork: false }, // 7 chars
            { pwd: 'aaaaaaaa', shouldWork: true } // 8 chars
        ];
        
        for (const test of testPasswords) {
            const canRegister = await this.testPasswordRegistration(test.pwd);
            if (canRegister && !test.shouldWork) {
                return { minLength: test.pwd.length, allows: canRegister };
            }
        }
        
        return { minLength: 8, allows: false };
    }
    
    extractSessionCookie(response) {
        const setCookieHeader = response.headers.get('set-cookie');
        if (!setCookieHeader) return null;
        
        const cookies = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];
        
        for (const cookie of cookies) {
            if (cookie.toLowerCase().includes('session') || 
                cookie.toLowerCase().includes('auth') ||
                cookie.toLowerCase().includes('token')) {
                
                return {
                    name: cookie.split('=')[0],
                    secure: cookie.toLowerCase().includes('secure'),
                    httponly: cookie.toLowerCase().includes('httponly'),
                    samesite: this.extractSameSite(cookie)
                };
            }
        }
        
        return null;
    }
    
    extractSameSite(cookie) {
        const match = cookie.match(/samesite=([a-zA-Z]+)/i);
        return match ? match[1] : null;
    }
    
    async testSessionTimeout() {
        // Тестирование таймаута сессии
        const loginResult = await this.attemptLogin({ username: 'test', password: 'valid_password' });
        if (!loginResult.success) return { hasTimeout: false };
        
        // Сохранение сессии
        this.session = this.extractSessionCookie(loginResult.response);
        
        // Ждем 30 минут и пробуем использовать сессию
        await new Promise(resolve => setTimeout(resolve, 30 * 60 * 1000)); // 30 минут
        
        const testResponse = await fetch(`${this.target}/dashboard`, {
            headers: {
                'Cookie': `${this.session.name}=${this.session.value}`
            }
        });
        
        // Если все еще можем получить доступ, то таймаута нет
        return { hasTimeout: testResponse.status !== 200 };
    }
    
    async testTokenRenewal() {
        // Проверка, обновляется ли токен при повторной аутентификации
        const firstLogin = await this.attemptLogin({ username: 'test', password: 'valid_password' });
        if (!firstLogin.success) return { renews: false };
        
        const firstToken = this.extractSessionCookie(firstLogin.response);
        
        // Повторная аутентификация
        const secondLogin = await this.attemptLogin({ username: 'test', password: 'valid_password' });
        if (!secondLogin.success) return { renews: false };
        
        const secondToken = this.extractSessionCookie(secondLogin.response);
        
        // Токены должны отличаться
        return { renews: firstToken.value !== secondToken.value };
    }
    
    async checkMFAStatus() {
        // Проверка статуса MFA
        return { enabledByDefault: false }; // Заглушка
    }
    
    async testMFABypass() {
        // Тестирование обхода MFA
        return { vulnerable: false }; // Заглушка
    }
    
    async testOAuthRedirects() {
        // Тестирование OAuth redirect URI
        return { vulnerable: false }; // Заглушка
    }
    
    async testTokenLeakage() {
        // Тестирование утечки токенов
        return { vulnerable: false }; // Заглушка
    }
    
    generateAuthSummary(results) {
        const totalIssues = Object.values(results)
            .filter(value => Array.isArray(value))
            .flat()
            .length;
        
        const criticalIssues = this.countBySeverity(results, 'CRITICAL');
        const highIssues = this.countBySeverity(results, 'HIGH');
        const mediumIssues = this.countBySeverity(results, 'MEDIUM');
        
        return {
            totalIssues,
            criticalIssues,
            highIssues,
            mediumIssues,
            authSecurityPosture: this.assessAuthSecurity(criticalIssues, highIssues, mediumIssues),
            immediateActions: this.getImmediateAuthActions(results),
            recommendations: this.getAuthRecommendations(results)
        };
    }
    
    countBySeverity(results, severity) {
        let count = 0;
        for (const value of Object.values(results)) {
            if (Array.isArray(value)) {
                count += value.filter(item => item.severity === severity).length;
            }
        }
        return count;
    }
    
    assessAuthSecurity(critical, high, medium) {
        if (critical > 0) return 'CRITICAL - Authentication mechanism severely compromised';
        if (high > 2) return 'HIGH - Multiple serious authentication issues';
        if (high > 0) return 'MEDIUM-HIGH - Significant authentication weaknesses';
        if (medium > 5) return 'MEDIUM - Several authentication concerns';
        if (medium > 0) return 'LOW-MEDIUM - Minor authentication issues';
        return 'GOOD - Authentication mechanism appears secure';
    }
    
    getImmediateAuthActions(results) {
        const actions = [];
        
        if (results.defaultCredentials.length > 0) {
            actions.push('Remove or change default credentials immediately');
        }
        
        if (results.bruteForceProtection.length > 0) {
            actions.push('Implement rate limiting and account lockout mechanisms');
        }
        
        if (results.passwordPolicy.length > 0) {
            actions.push('Strengthen password policy with minimum length and complexity requirements');
        }
        
        if (results.sessionManagement.length > 0) {
            actions.push('Review and strengthen session management implementation');
        }
        
        return actions;
    }
    
    getAuthRecommendations(results) {
        const recommendations = [];
        
        if (results.defaultCredentials.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Eliminate Default Credentials',
                description: 'Default credentials were found and must be removed',
                steps: [
                    'Remove default accounts',
                    'Force password change on first login',
                    'Implement strong password policies'
                ]
            });
        }
        
        if (results.bruteForceProtection.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Implement Brute Force Protection',
                description: 'No protection against authentication brute force attacks',
                steps: [
                    'Implement rate limiting',
                    'Add CAPTCHA after failed attempts',
                    'Account lockout after multiple failures'
                ]
            });
        }
        
        if (results.sessionManagement.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Strengthen Session Management',
                description: 'Session management has security weaknesses',
                steps: [
                    'Use secure, HttpOnly, and SameSite attributes for cookies',
                    'Implement proper session timeout',
                    'Regenerate session tokens after authentication'
                ]
            });
        }
        
        return recommendations;
    }
}

// Использование аутентификационного тестера
const authTester = new AuthenticationTester('https://example.com');
const authResults = await authTester.testAuthenticationMechanism();
console.log('Authentication Test Results:', authResults);
```

## Лучшие практики тестирования

### 1. Комбинирование методов

```javascript
// Комбинированный подход к тестированию
class CombinedSecurityTester {
    constructor(target) {
        this.target = target;
        this.blackBoxTester = new BlackBoxTester(target);
        this.whiteBoxTester = new WhiteBoxTester('./src', target);
        this.sastIntegration = new SASTIntegration('semgrep');
        this.dastIntegration = new DASTIntegration('zap');
    }
    
    async performCombinedTest() {
        const results = {
            blackBox: await this.blackBoxTester.performBlackBoxTest(),
            whiteBox: await this.whiteBoxTester.performWhiteBoxTest(),
            sast: await this.sastIntegration.runScan('./src'),
            dast: await this.dastIntegration.runScan(this.target),
            combinedAnalysis: null
        };
        
        results.combinedAnalysis = await this.performCombinedAnalysis(results);
        
        return results;
    }
    
    async performCombinedAnalysis(results) {
        const analysis = {
            findingsCorrelation: this.correlateFindings(results),
            coverage: this.calculateCoverage(results),
            confidence: this.calculateConfidence(results),
            unifiedRecommendations: this.generateUnifiedRecommendations(results),
            riskAssessment: this.performRiskAssessment(results)
        };
        
        return analysis;
    }
    
    correlateFindings(results) {
        const correlations = [];
        
        // Корреляция SAST и DAST находок
        const sastFindings = results.sast.results?.results || [];
        const dastFindings = results.dast.detailedResults || [];
        
        for (const sast of sastFindings) {
            for (const dast of dastFindings) {
                // Простая корреляция по типу уязвимости
                if (sast.extra?.message?.toLowerCase().includes('xss') && 
                    dast.alert?.toLowerCase().includes('xss')) {
                    correlations.push({
                        type: 'XSS',
                        sastFinding: sast,
                        dastFinding: dast,
                        confidence: 'HIGH',
                        impact: 'CONFIRMED'
                    });
                }
            }
        }
        
        return correlations;
    }
    
    calculateCoverage(results) {
        const coverage = {
            sast: results.sast.success ? 100 : 0,
            dast: results.dast.success ? 100 : 0,
            blackBox: results.blackBox ? 100 : 0,
            whiteBox: results.whiteBox ? 100 : 0,
            overall: 0
        };
        
        coverage.overall = Object.values(coverage).reduce((sum, val) => sum + val, 0) / Object.keys(coverage).length;
        
        return coverage;
    }
    
    calculateConfidence(results) {
        // Расчет уверенности на основе корреляции находок
        const correlations = this.correlateFindings(results);
        const correlationCount = correlations.length;
        const totalSast = results.sast.results?.results?.length || 0;
        const totalDast = results.dast.detailedResults?.length || 0;
        
        // Уверенность выше, когда находки подтверждаются разными методами
        const correlationRatio = totalSast > 0 ? correlationCount / totalSast : 0;
        const confidence = Math.min(100, correlationRatio * 200); // Масштабируем до 100%
        
        return {
            baseConfidence: confidence,
            correlationCount,
            totalSast,
            totalDast,
            confidenceLevel: this.getConfidenceLevel(confidence)
        };
    }
    
    getConfidenceLevel(confidence) {
        if (confidence >= 80) return 'HIGH';
        if (confidence >= 50) return 'MEDIUM';
        return 'LOW';
    }
    
    generateUnifiedRecommendations(results) {
        const allFindings = [
            ...(results.sast.results?.results || []),
            ...(results.dast.detailedResults || []),
            ...(results.blackBox.staticAnalysis?.sastFindings || []),
            ...(results.whiteBox.staticAnalysis?.sastFindings || [])
        ];
        
        const recommendations = [];
        
        // Группировка находок по типу
        const findingsByType = {};
        for (const finding of allFindings) {
            const type = this.classifyFinding(finding);
            if (!findingsByType[type]) findingsByType[type] = [];
            findingsByType[type].push(finding);
        }
        
        for (const [type, findings] of Object.entries(findingsByType)) {
            recommendations.push({
                type,
                count: findings.length,
                priority: this.calculateRecommendationPriority(findings),
                description: this.getRecommendationDescription(type),
                implementation: this.getImplementationSteps(type),
                tools: this.getRelevantTools(type)
            });
        }
        
        return recommendations;
    }
    
    classifyFinding(finding) {
        if (finding.extra?.message?.toLowerCase().includes('xss')) return 'XSS';
        if (finding.extra?.message?.toLowerCase().includes('sql')) return 'SQL Injection';
        if (finding.alert?.toLowerCase().includes('xss')) return 'XSS';
        if (finding.alert?.toLowerCase().includes('sql')) return 'SQL Injection';
        if (finding.type?.toLowerCase().includes('xss')) return 'XSS';
        if (finding.type?.toLowerCase().includes('sql')) return 'SQL Injection';
        
        return 'Unclassified';
    }
    
    calculateRecommendationPriority(findings) {
        const severityWeights = {
            'CRITICAL': 5,
            'HIGH': 4,
            'MEDIUM': 3,
            'LOW': 2,
            'INFO': 1
        };
        
        let totalWeight = 0;
        for (const finding of findings) {
            const severity = finding.extra?.metadata?.severity || finding.risk || 'MEDIUM';
            totalWeight += severityWeights[severity] || 3;
        }
        
        const avgWeight = totalWeight / findings.length;
        if (avgWeight >= 4) return 'CRITICAL';
        if (avgWeight >= 3) return 'HIGH';
        if (avgWeight >= 2) return 'MEDIUM';
        return 'LOW';
    }
    
    getRecommendationDescription(type) {
        const descriptions = {
            'XSS': 'Cross-Site Scripting vulnerabilities allow attackers to inject malicious scripts',
            'SQL Injection': 'SQL Injection allows attackers to manipulate database queries',
            'Authentication Bypass': 'Authentication mechanisms can be bypassed',
            'Authorization Issues': 'Insufficient access controls allow unauthorized access'
        };
        
        return descriptions[type] || `Issues related to ${type} were detected`;
    }
    
    getImplementationSteps(type) {
        const steps = {
            'XSS': [
                'Implement proper input validation',
                'Use output encoding',
                'Implement Content Security Policy',
                'Use frameworks with automatic encoding'
            ],
            'SQL Injection': [
                'Use parameterized queries',
                'Implement input validation',
                'Apply principle of least privilege',
                'Use stored procedures where appropriate'
            ],
            'Authentication Bypass': [
                'Implement proper authentication checks',
                'Use multi-factor authentication',
                'Implement secure session management',
                'Add rate limiting'
            ]
        };
        
        return steps[type] || ['Review and secure the implementation'];
    }
    
    getRelevantTools(type) {
        const tools = {
            'XSS': ['ESLint', 'DOMPurify', 'Helmet.js'],
            'SQL Injection': ['SQLAlchemy', 'Sequelize', 'JPA'],
            'Authentication Bypass': ['Passport.js', 'JWT', 'OAuth 2.0'],
            'Authorization Issues': ['Casbin', 'Open Policy Agent']
        };
        
        return tools[type] || ['Security libraries relevant to the technology stack'];
    }
    
    performRiskAssessment(results) {
        const sastIssues = results.sast.results?.results?.length || 0;
        const dastIssues = results.dast.detailedResults?.length || 0;
        const blackBoxIssues = this.countBlackBoxIssues(results.blackBox);
        const whiteBoxIssues = this.countWhiteBoxIssues(results.whiteBox);
        
        const totalIssues = sastIssues + dastIssues + blackBoxIssues + whiteBoxIssues;
        const criticalIssues = this.countCriticalIssues(results);
        
        return {
            totalIssues,
            criticalIssues,
            riskLevel: this.determineRiskLevel(criticalIssues, totalIssues),
            riskScore: this.calculateRiskScore(criticalIssues, totalIssues),
            riskFactors: {
                sast: sastIssues,
                dast: dastIssues,
                blackBox: blackBoxIssues,
                whiteBox: whiteBoxIssues
            },
            mitigationStrategy: this.getMitigationStrategy(criticalIssues, totalIssues)
        };
    }
    
    countBlackBoxIssues(blackBoxResults) {
        return blackBoxResults.staticAnalysis.sastFindings.length;
    }
    
    countWhiteBoxIssues(whiteBoxResults) {
        return whiteBoxResults.staticAnalysis.sastFindings.length;
    }
    
    countCriticalIssues(results) {
        let count = 0;
        
        // Подсчет критических уязвимостей
        const allFindings = [
            ...(results.sast.results?.results || []),
            ...(results.dast.detailedResults || []),
            ...(results.blackBox.staticAnalysis?.sastFindings || []),
            ...(results.whiteBox.staticAnalysis?.sastFindings || [])
        ];
        
        for (const finding of allFindings) {
            const severity = finding.extra?.metadata?.severity || 
                           finding.risk || 
                           finding.severity || 'MEDIUM';
            
            if (['CRITICAL', 'HIGH'].includes(severity)) {
                count++;
            }
        }
        
        return count;
    }
    
    determineRiskLevel(critical, total) {
        if (critical > 0) return 'CRITICAL';
        if (total > 50) return 'HIGH';
        if (total > 20) return 'MEDIUM';
        if (total > 5) return 'LOW';
        return 'INFO';
    }
    
    calculateRiskScore(critical, total) {
        // Простой расчет риска
        return Math.min(100, (critical * 10) + (total * 0.5));
    }
    
    getMitigationStrategy(critical, total) {
        if (critical > 0) {
            return [
                'Immediate patching of critical vulnerabilities',
                'Implementation of security controls',
                'Security monitoring enhancement'
            ];
        }
        
        if (total > 50) {
            return [
                'Comprehensive security remediation plan',
                'Security awareness training',
                'Implementation of security tools'
            ];
        }
        
        return [
            'Address identified vulnerabilities',
            'Implement security best practices',
            'Regular security assessments'
        ];
    }
}

// Использование комбинированного тестера
const combinedTester = new CombinedSecurityTester('https://example.com');
const combinedResults = await combinedTester.performCombinedTest();
console.log('Combined Security Test Results:', combinedResults);
```

## Связанные темы

- [[Методы-тестирования-безопасности]]
- [[Автоматизированное-тестирование-безопасности]]
- [[Оценка-уязвимостей]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]