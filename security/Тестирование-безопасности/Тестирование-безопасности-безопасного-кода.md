---
aliases: ["Тестирование безопасности безопасного кода", "Secure Code Testing", "Тестирование безопасного кодирования"]
tags: ["#security", "#secure-coding", "#testing", "#code-security"]
---

# Тестирование безопасности безопасного кода

## Введение

Тестирование безопасности безопасного кода - это процесс проверки соответствия кода приложения принципам безопасного программирования и выявления потенциальных уязвимостей, которые могут возникнуть из-за неправильной реализации безопасности. Это включает в себя как автоматизированные, так и ручные методы тестирования, направленные на проверку корректности реализации мер безопасности.

## Принципы тестирования безопасного кода

### 1. Раннее тестирование безопасности

```javascript
// Система раннего тестирования безопасности кода
class EarlySecurityCodeTesting {
    constructor() {
        this.testingPhases = {
            development: new DevelopmentSecurityTesting(),
            codeReview: new SecurityCodeReview(),
            preCommit: new PreCommitSecurityTesting(),
            ci: new CITestingIntegration()
        };
        
        this.securityRules = new SecureCodingRules();
        this.vulnerabilityPatterns = new VulnerabilityPatternDetector();
        this.testGenerators = new SecurityTestGenerator();
    }
    
    async runSecurityTests(code, context = {}) {
        const results = {
            staticAnalysis: await this.performStaticAnalysis(code),
            patternDetection: await this.detectVulnerabilityPatterns(code),
            ruleCompliance: await this.checkRuleCompliance(code),
            securityTests: await this.generateSecurityTests(code),
            recommendations: [],
            overallScore: 0
        };
        
        results.overallScore = this.calculateSecurityScore(results);
        results.recommendations = await this.generateRecommendations(results);
        
        return results;
    }
    
    async performStaticAnalysis(code) {
        const analysis = {
            sastIssues: [],
            complexityMetrics: {},
            securityHotspots: [],
            codeQuality: {}
        };
        
        // Анализ синтаксиса
        try {
            const ast = this.parseCodeToAST(code);
            analysis.sastIssues = await this.analyzeAST(ast);
        } catch (error) {
            analysis.sastIssues.push({
                type: 'PARSING_ERROR',
                severity: 'MEDIUM',
                message: `Failed to parse code: ${error.message}`,
                line: 0
            });
        }
        
        // Метрики сложности
        analysis.complexityMetrics = this.calculateComplexityMetrics(code);
        
        // Проверка на "горячие точки" безопасности
        analysis.securityHotspots = this.identifySecurityHotspots(code);
        
        // Метрики качества кода
        analysis.codeQuality = this.calculateCodeQuality(code);
        
        return analysis;
    }
    
    parseCodeToAST(code) {
        // В реальности использовать библиотеку для парсинга (esprima, acorn и т.д.)
        try {
            const parser = require('esprima');
            return parser.parseScript(code, { tolerant: true, loc: true });
        } catch (error) {
            throw new Error(`AST parsing failed: ${error.message}`);
        }
    }
    
    async analyzeAST(ast) {
        const issues = [];
        
        // Рекурсивный обход AST для поиска уязвимостей
        const walker = (node, parent) => {
            if (this.isSecurityVulnerable(node)) {
                issues.push(this.createIssueFromNode(node, 'SECURITY_VULNERABILITY'));
            }
            
            if (this.isInputVulnerable(node)) {
                issues.push(this.createIssueFromNode(node, 'INPUT_VALIDATION_MISSING'));
            }
            
            if (this.isOutputVulnerable(node)) {
                issues.push(this.createIssueFromNode(node, 'OUTPUT_ENCODING_MISSING'));
            }
            
            if (this.hasInsecureFunction(node)) {
                issues.push(this.createIssueFromNode(node, 'INSECURE_FUNCTION_USAGE'));
            }
            
            // Рекурсивный обход дочерних узлов
            for (const key in node) {
                if (node[key] && typeof node[key] === 'object') {
                    if (Array.isArray(node[key])) {
                        node[key].forEach(child => walker(child, node));
                    } else if (node[key].type) {
                        walker(node[key], node);
                    }
                }
            }
        };
        
        walker(ast, null);
        
        return issues;
    }
    
    isSecurityVulnerable(node) {
        // Проверка узла AST на потенциальные уязвимости
        if (node.type === 'CallExpression') {
            const callee = node.callee;
            
            // Проверка на использование небезопасных функций
            if (callee.type === 'Identifier') {
                const dangerousFunctions = [
                    'eval', 'Function', 'setTimeout', 'setInterval', 
                    'document.write', 'innerHTML', 'outerHTML',
                    'exec', 'spawn', 'execFile', 'child_process'
                ];
                
                return dangerousFunctions.includes(callee.name);
            }
        }
        
        return false;
    }
    
    isInputVulnerable(node) {
        // Проверка на отсутствие валидации ввода
        if (node.type === 'MemberExpression' && node.property?.name === 'params') {
            // Использование параметров запроса без валидации
            return true;
        }
        
        if (node.type === 'MemberExpression' && node.property?.name === 'query') {
            // Использование query параметров без валидации
            return true;
        }
        
        if (node.type === 'MemberExpression' && node.property?.name === 'body') {
            // Использование body данных без валидации
            return true;
        }
        
        return false;
    }
    
    isOutputVulnerable(node) {
        // Проверка на отсутствие кодирования вывода
        if (node.type === 'AssignmentExpression' && 
            node.left?.property?.name === 'innerHTML') {
            return true;
        }
        
        if (node.type === 'CallExpression' && 
            node.callee?.property?.name === 'write') {
            return true;
        }
        
        return false;
    }
    
    hasInsecureFunction(node) {
        // Проверка на использование потенциально небезопасных функций
        if (node.type === 'CallExpression' && node.callee?.name) {
            const insecureFunctions = [
                'eval', 'Function', 'setTimeout', 'setInterval',
                'exec', 'spawn', 'execFile', 'child_process',
                'require', 'import', 'eval', 'new Function'
            ];
            
            return insecureFunctions.includes(node.callee.name);
        }
        
        return false;
    }
    
    createIssueFromNode(node, type) {
        return {
            type: type,
            severity: this.estimateSeverity(type),
            line: node.loc?.start?.line || 0,
            column: node.loc?.start?.column || 0,
            code: this.extractCodeSnippet(node),
            description: this.getDescriptionForIssue(type),
            recommendation: this.getRecommendationForIssue(type)
        };
    }
    
    estimateSeverity(issueType) {
        const severityMap = {
            'SECURITY_VULNERABILITY': 'HIGH',
            'INPUT_VALIDATION_MISSING': 'MEDIUM',
            'OUTPUT_ENCODING_MISSING': 'MEDIUM',
            'INSECURE_FUNCTION_USAGE': 'HIGH',
            'PARSING_ERROR': 'LOW'
        };
        
        return severityMap[issueType] || 'MEDIUM';
    }
    
    extractCodeSnippet(node) {
        // Извлечение фрагмента кода для узла
        // В реальности использовать исходный код и информацию о расположении
        return 'CODE_SNIPPET'; // Заглушка
    }
    
    getDescriptionForIssue(type) {
        const descriptions = {
            'SECURITY_VULNERABILITY': 'Potential security vulnerability detected',
            'INPUT_VALIDATION_MISSING': 'Input validation is missing for user-provided data',
            'OUTPUT_ENCODING_MISSING': 'Output encoding is missing, potential XSS vulnerability',
            'INSECURE_FUNCTION_USAGE': 'Usage of potentially insecure function detected'
        };
        
        return descriptions[type] || 'Security issue detected';
    }
    
    getRecommendationForIssue(type) {
        const recommendations = {
            'SECURITY_VULNERABILITY': 'Review the code for potential security issues',
            'INPUT_VALIDATION_MISSING': 'Implement proper input validation and sanitization',
            'OUTPUT_ENCODING_MISSING': 'Use proper output encoding to prevent XSS',
            'INSECURE_FUNCTION_USAGE': 'Replace with secure alternatives or add proper validation'
        };
        
        return recommendations[type] || 'Implement security measures';
    }
    
    calculateComplexityMetrics(code) {
        // Расчет метрик сложности для оценки безопасности
        const lines = code.split('\n');
        const functions = (code.match(/function\s+\w+\s*\(/g) || []).length;
        const conditionals = (code.match(/\b(if|else|switch|while|for)\b/g) || []).length;
        const operators = (code.match(/\+\+|--|\+=|-=|\*=|\/=|%=|&=|\|=|\^=|<<=|>>=|>>>=|&&|\|\||\?|:|===|!==|<=|>=|<|>/g) || []).length;
        
        return {
            linesOfCode: lines.length,
            functionCount: functions,
            conditionalComplexity: conditionals,
            operatorComplexity: operators,
            cyclomaticComplexity: conditionals + 1,
            maintainabilityIndex: this.calculateMaintainability(lines.length, functions, conditionals)
        };
    }
    
    calculateMaintainability(lines, functions, conditionals) {
        // Упрощенный расчет индекса сопровождаемости
        const complexity = conditionals / Math.max(functions, 1);
        const length = lines / Math.max(functions, 1);
        
        // Оценка от 0 до 100 (100 = лучшая сопровождаемость)
        return Math.max(0, 100 - (complexity * 2) - (length * 0.5));
    }
    
    identifySecurityHotspots(code) {
        const hotspots = [];
        const lines = code.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            const lineNum = i + 1;
            
            if (this.containsSecurityHotspot(line)) {
                hotspots.push({
                    line: lineNum,
                    code: line,
                    type: this.getHotspotType(line),
                    severity: this.estimateHotspotSeverity(line)
                });
            }
        }
        
        return hotspots;
    }
    
    containsSecurityHotspot(line) {
        const securityHotspotPatterns = [
            /eval\s*\(/i,
            /innerHTML\s*=/i,
            /outerHTML\s*=/i,
            /document\.write/i,
            /Function\s*\(/,
            /setTimeout\s*\(\s*["']/,
            /setInterval\s*\(\s*["']/,
            /exec\s*\(/,
            /spawn\s*\(/,
            /execFile\s*\(/,
            /child_process\.exec\s*\(/,
            /require\s*\(\s*["']\s*\+\s*\w+\s*\+\s*["']\s*\)/,
            /import\s*\(\s*["']\s*\+\s*\w+\s*\+\s*["']\s*\)/,
            /SQL|SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER/i,
            /password|token|secret|key|auth|credential/i
        ];
        
        return securityHotspotPatterns.some(pattern => pattern.test(line));
    }
    
    getHotspotType(line) {
        if (line.includes('eval(')) return 'DYNAMIC_CODE_EXECUTION';
        if (line.includes('innerHTML')) return 'XSS_RISK';
        if (line.includes('document.write')) return 'XSS_RISK';
        if (line.includes('exec(')) return 'COMMAND_INJECTION_RISK';
        if (line.includes('SQL') || line.includes('SELECT')) return 'SQL_INJECTION_RISK';
        if (line.includes('password') || line.includes('token')) return 'CREDENTIAL_EXPOSURE_RISK';
        return 'GENERAL_SECURITY_HOTSPOT';
    }
    
    estimateHotspotSeverity(line) {
        if (line.includes('eval(') || line.includes('exec(')) return 'HIGH';
        if (line.includes('innerHTML') || line.includes('document.write')) return 'MEDIUM';
        if (line.includes('password') || line.includes('token')) return 'HIGH';
        return 'MEDIUM';
    }
    
    calculateCodeQuality(code) {
        const qualityMetrics = {
            readability: this.assessReadability(code),
            namingConvention: this.assessNamingConvention(code),
            errorHandling: this.assessErrorHandling(code),
            securityAwareness: this.assessSecurityAwareness(code)
        };
        
        qualityMetrics.overallScore = this.calculateQualityScore(qualityMetrics);
        
        return qualityMetrics;
    }
    
    assessReadability(code) {
        // Оценка читаемости кода
        const lines = code.split('\n');
        const commentRatio = this.calculateCommentRatio(lines);
        const indentationConsistency = this.checkIndentationConsistency(lines);
        
        return Math.min(100, (commentRatio * 30) + (indentationConsistency * 70));
    }
    
    calculateCommentRatio(lines) {
        const commentLines = lines.filter(line => 
            line.trim().startsWith('//') || 
            line.trim().startsWith('/*') || 
            line.trim().startsWith('*')
        ).length;
        
        return lines.length > 0 ? (commentLines / lines.length) * 100 : 0;
    }
    
    checkIndentationConsistency(lines) {
        // Проверка согласованности отступов
        const spaces = lines.filter(line => line.startsWith(' ')).length;
        const tabs = lines.filter(line => line.startsWith('\t')).length;
        
        if (spaces === 0 && tabs === 0) return 100; // Нет отступов
        
        const consistency = Math.max(spaces, tabs) / (spaces + tabs);
        return consistency * 100;
    }
    
    assessNamingConvention(code) {
        // Оценка соглашений об именовании
        const variableNames = (code.match(/\b(var|let|const)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g) || []);
        const functionNames = (code.match(/\bfunction\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g) || []);
        
        let compliantNames = 0;
        let totalNames = 0;
        
        // Проверка имен переменных
        for (const declaration of variableNames) {
            const match = declaration.match(/(var|let|const)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/);
            if (match) {
                const name = match[2];
                if (this.isValidNamingConvention(name)) {
                    compliantNames++;
                }
                totalNames++;
            }
        }
        
        // Проверка имен функций
        for (const declaration of functionNames) {
            const match = declaration.match(/function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/);
            if (match) {
                const name = match[1];
                if (this.isValidNamingConvention(name)) {
                    compliantNames++;
                }
                totalNames++;
            }
        }
        
        return totalNames > 0 ? (compliantNames / totalNames) * 100 : 100;
    }
    
    isValidNamingConvention(name) {
        // Проверка на соответствие соглашениям об именовании
        const camelCase = /^[a-z][a-zA-Z0-9]*$/;
        const snakeCase = /^[a-z][a-z0-9_]*$/;
        const pascalCase = /^[A-Z][a-zA-Z0-9]*$/;
        
        return camelCase.test(name) || snakeCase.test(name) || pascalCase.test(name);
    }
    
    assessErrorHandling(code) {
        // Оценка обработки ошибок
        const tryCatchBlocks = (code.match(/\btry\s*{/g) || []).length;
        const errorHandlers = (code.match(/\bcatch\s*\(/g) || []).length;
        const finallyBlocks = (code.match(/\bfinally\s*{/g) || []).length;
        
        // Оценка на основе соотношения try-catch блоков
        if (tryCatchBlocks === 0) return 0; // Нет обработки ошибок
        
        const handledRatio = errorHandlers / tryCatchBlocks;
        return handledRatio * 100;
    }
    
    assessSecurityAwareness(code) {
        // Оценка осведомленности о безопасности
        const securityPatterns = [
            /validate/i,
            /sanitize/i,
            /escape/i,
            /encode/i,
            /auth/i,
            /authen/i,
            /authoriz/i,
            /session/i,
            /cookie/i,
            /csp/i,
            /csrf/i,
            /xss/i,
            /sql/i,
            /injection/i
        ];
        
        let securityScore = 0;
        
        for (const pattern of securityPatterns) {
            if (pattern.test(code)) {
                securityScore += 5;
            }
        }
        
        return Math.min(100, securityScore);
    }
    
    calculateQualityScore(metrics) {
        const weights = {
            readability: 0.25,
            namingConvention: 0.25,
            errorHandling: 0.25,
            securityAwareness: 0.25
        };
        
        return Object.entries(weights).reduce((score, [metric, weight]) => {
            return score + (metrics[metric] * weight);
        }, 0);
    }
    
    async detectVulnerabilityPatterns(code) {
        return await this.vulnerabilityPatterns.analyze(code);
    }
    
    async checkRuleCompliance(code) {
        return await this.securityRules.validateCode(code);
    }
    
    async generateSecurityTests(code) {
        return await this.testGenerators.generateTests(code);
    }
    
    calculateSecurityScore(results) {
        const { staticAnalysis, complexityMetrics, codeQuality } = results;
        
        let score = 0;
        
        // Оценка по количеству уязвимостей
        const sastScore = Math.max(0, 100 - (staticAnalysis.sastIssues.length * 10));
        score += sastScore * 0.4;
        
        // Оценка по метрикам сложности
        const complexityScore = Math.max(0, 100 - complexityMetrics.cyclomaticComplexity);
        score += complexityScore * 0.2;
        
        // Оценка по качеству кода
        score += codeQuality.overallScore * 0.4;
        
        return Math.min(100, Math.max(0, score));
    }
    
    async generateRecommendations(results) {
        const recommendations = [];
        
        // Рекомендации на основе SAST результатов
        if (results.staticAnalysis.sastIssues.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'STATIC_ANALYSIS',
                title: 'Address SAST Issues',
                description: `Found ${results.staticAnalysis.sastIssues.length} static analysis issues`,
                action: 'Review and fix identified security issues',
                affectedLines: results.staticAnalysis.sastIssues.map(issue => issue.line)
            });
        }
        
        // Рекомендации на основе сложности
        if (results.complexityMetrics.cyclomaticComplexity > 10) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'COMPLEXITY',
                title: 'Reduce Code Complexity',
                description: `Cyclomatic complexity is ${results.complexityMetrics.cyclomaticComplexity}, recommended maximum is 10`,
                action: 'Refactor complex functions into smaller, more manageable units'
            });
        }
        
        // Рекомендации на основе качества кода
        if (results.codeQuality.overallScore < 70) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'CODE_QUALITY',
                title: 'Improve Code Quality',
                description: `Code quality score is ${results.codeQuality.overallScore}, recommended minimum is 70`,
                action: 'Follow secure coding best practices and improve code structure'
            });
        }
        
        // Рекомендации по конкретным уязвимостям
        for (const issue of results.staticAnalysis.sastIssues) {
            recommendations.push({
                priority: issue.severity === 'HIGH' ? 'HIGH' : 'MEDIUM',
                category: 'SPECIFIC_ISSUE',
                title: issue.description,
                description: `Security issue found at line ${issue.line}`,
                action: issue.recommendation,
                code: issue.code
            });
        }
        
        return recommendations;
    }
    
    async runCompleteSecurityAnalysis(code) {
        const analysis = await this.runSecurityTests(code);
        
        return {
            timestamp: new Date().toISOString(),
            results: analysis,
            summary: {
                securityScore: analysis.overallScore,
                issuesCount: analysis.staticAnalysis.sastIssues.length,
                hotspotsCount: analysis.staticAnalysis.securityHotspots.length,
                codeQualityScore: analysis.staticAnalysis.codeQuality.overallScore,
                complianceRate: await this.calculateComplianceRate(analysis)
            },
            recommendations: analysis.recommendations
        };
    }
    
    async calculateComplianceRate(analysis) {
        const totalChecks = 10; // общий счетчик проверок
        let passedChecks = 0;
        
        // Проверка наличия проблем
        if (analysis.staticAnalysis.sastIssues.length === 0) passedChecks++;
        if (analysis.staticAnalysis.securityHotspots.length === 0) passedChecks++;
        if (analysis.overallScore >= 80) passedChecks++;
        if (analysis.staticAnalysis.codeQuality.overallScore >= 80) passedChecks++;
        
        // Дополнительные проверки могут быть добавлены
        
        return (passedChecks / totalChecks) * 100;
    }
}

// Использование системы раннего тестирования
const earlySecurityTester = new EarlySecurityCodeTesting();

async function analyzeSecurityCode(code) {
    const results = await earlySecurityTester.runCompleteSecurityAnalysis(code);
    console.log('Security Code Analysis Results:', JSON.stringify(results, null, 2));
    return results;
}
```

### 2. Паттерны уязвимостей

```javascript
// Система обнаружения паттернов уязвимостей
class VulnerabilityPatternDetector {
    constructor() {
        this.patterns = {
            injection: [
                {
                    name: 'SQL Injection',
                    patterns: [
                        /query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /execute\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /mysql_query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /mysqli_query\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i
                    ],
                    severity: 'CRITICAL',
                    cwe: 'CWE-89',
                    description: 'Potential SQL injection vulnerability detected'
                },
                {
                    name: 'Command Injection',
                    patterns: [
                        /exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /spawn\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /child_process\.exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /shell_exec\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i
                    ],
                    severity: 'CRITICAL',
                    cwe: 'CWE-78',
                    description: 'Potential command injection vulnerability detected'
                },
                {
                    name: 'XSS',
                    patterns: [
                        /innerHTML\s*=\s*\w+/i,
                        /outerHTML\s*=\s*\w+/i,
                        /document\.write\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i,
                        /eval\s*\([^)]*\+\s*\w+\s*\+[^)]*\)/i
                    ],
                    severity: 'HIGH',
                    cwe: 'CWE-79',
                    description: 'Potential XSS vulnerability detected'
                }
            ],
            authentication: [
                {
                    name: 'Hardcoded Credentials',
                    patterns: [
                        /password\s*[:=]\s*["'][^"']*["']/i,
                        /token\s*[:=]\s*["'][^"']*["']/i,
                        /secret\s*[:=]\s*["'][^"']*["']/i,
                        /key\s*[:=]\s*["'][^"']*["']/i,
                        /api[_-]?key\s*[:=]\s*["'][^"']*["']/i
                    ],
                    severity: 'CRITICAL',
                    cwe: 'CWE-798',
                    description: 'Hardcoded credentials detected'
                },
                {
                    name: 'Weak Password Hashing',
                    patterns: [
                        /hash\(["']md5["']\s*,/i,
                        /hash\(["']sha1["']\s*,/i,
                        /btoa\s*\(/i,
                        /atob\s*\(/i
                    ],
                    severity: 'HIGH',
                    cwe: 'CWE-327',
                    description: 'Weak password hashing algorithm detected'
                }
            ],
            authorization: [
                {
                    name: 'Missing Authorization Check',
                    patterns: [
                        /app\.\w+\(\s*["']\/admin/i,
                        /app\.\w+\(\s*["']\/api\/v\d+\/admin/i,
                        /app\.\w+\(\s*["']\/secure/i
                    ],
                    severity: 'HIGH',
                    cwe: 'CWE-862',
                    description: 'Potential missing authorization check detected'
                }
            ],
            session: [
                {
                    name: 'Insecure Session Handling',
                    patterns: [
                        /session\.secret\s*=\s*["'][^"']*["']/i,
                        /cookie\.secret\s*=\s*["'][^"']*["']/i
                    ],
                    severity: 'MEDIUM',
                    cwe: 'CWE-613',
                    description: 'Potential insecure session handling detected'
                }
            ],
            input: [
                {
                    name: 'Input Validation Missing',
                    patterns: [
                        /req\.\w+\s*\+\s*\w+/i,
                        /params\.\w+\s*\+\s*\w+/i,
                        /query\.\w+\s*\+\s*\w+/i,
                        /body\.\w+\s*\+\s*\w+/i
                    ],
                    severity: 'MEDIUM',
                    cwe: 'CWE-20',
                    description: 'Potential input validation issue detected'
                }
            ]
        };
    }
    
    async analyze(code) {
        const findings = [];
        
        for (const [category, categoryPatterns] of Object.entries(this.patterns)) {
            for (const patternInfo of categoryPatterns) {
                const matches = this.findPatternMatches(code, patternInfo.patterns);
                
                for (const match of matches) {
                    findings.push({
                        category: category,
                        name: patternInfo.name,
                        severity: patternInfo.severity,
                        cwe: patternInfo.cwe,
                        description: patternInfo.description,
                        match: match.text,
                        line: match.line,
                        column: match.column,
                        recommendation: this.getRecommendationForPattern(patternInfo.name)
                    });
                }
            }
        }
        
        return findings;
    }
    
    findPatternMatches(code, patterns) {
        const matches = [];
        const lines = code.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            for (const pattern of patterns) {
                const regex = typeof pattern === 'string' ? new RegExp(pattern, 'gi') : pattern;
                let match;
                
                while ((match = regex.exec(line)) !== null) {
                    matches.push({
                        text: match[0],
                        line: i + 1,
                        column: match.index + 1,
                        pattern: regex.toString()
                    });
                }
            }
        }
        
        return matches;
    }
    
    getRecommendationForPattern(patternName) {
        const recommendations = {
            'SQL Injection': 'Use parameterized queries or prepared statements',
            'Command Injection': 'Validate and sanitize all user inputs before executing commands',
            'XSS': 'Implement proper output encoding and input validation',
            'Hardcoded Credentials': 'Move credentials to environment variables or secure vault',
            'Weak Password Hashing': 'Use bcrypt, scrypt, or Argon2 for password hashing',
            'Missing Authorization Check': 'Implement proper authorization checks for protected endpoints',
            'Insecure Session Handling': 'Use secure session management with proper secret management',
            'Input Validation Missing': 'Implement comprehensive input validation and sanitization'
        };
        
        return recommendations[patternName] || 'Review and secure the implementation';
    }
    
    async analyzeWithContext(code, context = {}) {
        const findings = await this.analyze(code);
        
        // Анализ в контексте (например, тип запроса, используемые библиотеки и т.д.)
        const contextualFindings = findings.map(finding => {
            const enhanced = { ...finding };
            
            // Уточнение тяжести в зависимости от контекста
            enhanced.adjustedSeverity = this.adjustSeverityWithContext(finding, context);
            
            // Добавление контекстной информации
            enhanced.context = context;
            
            return enhanced;
        });
        
        return contextualFindings;
    }
    
    adjustSeverityWithContext(finding, context) {
        // Уточнение тяжести на основе контекста
        let severity = finding.severity;
        
        // Повышение тяжести для критических путей
        if (context.route && context.route.includes('/admin')) {
            if (finding.category === 'authorization') {
                severity = 'CRITICAL';
            }
        }
        
        // Повышение тяжести для чувствительных данных
        if (context.dataType && context.dataType.includes('sensitive')) {
            if (['input', 'authentication'].includes(finding.category)) {
                severity = 'CRITICAL';
            }
        }
        
        // Повышение тяжести для публичных эндпоинтов
        if (context.visibility === 'public') {
            if (['authentication', 'authorization'].includes(finding.category)) {
                severity = 'HIGH';
            }
        }
        
        return severity;
    }
    
    async generatePatternReport(code) {
        const findings = await this.analyze(code);
        
        const report = {
            timestamp: new Date().toISOString(),
            totalFindings: findings.length,
            byCategory: this.countByCategory(findings),
            bySeverity: this.countBySeverity(findings),
            byCWE: this.countByCWE(findings),
            findings: findings,
            recommendations: this.generatePatternRecommendations(findings)
        };
        
        return report;
    }
    
    countByCategory(findings) {
        const counts = {};
        for (const finding of findings) {
            counts[finding.category] = (counts[finding.category] || 0) + 1;
        }
        return counts;
    }
    
    countBySeverity(findings) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        for (const finding of findings) {
            counts[finding.severity] = (counts[finding.severity] || 0) + 1;
        }
        return counts;
    }
    
    countByCWE(findings) {
        const counts = {};
        for (const finding of findings) {
            counts[finding.cwe] = (counts[finding.cwe] || 0) + 1;
        }
        return counts;
    }
    
    generatePatternRecommendations(findings) {
        const recommendations = [];
        
        const criticalFindings = findings.filter(f => f.severity === 'CRITICAL');
        if (criticalFindings.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Vulnerabilities Immediately',
                description: `Found ${criticalFindings.length} critical vulnerabilities`,
                action: 'Fix all critical vulnerabilities before deployment',
                affectedPatterns: [...new Set(criticalFindings.map(f => f.name))]
            });
        }
        
        const highFindings = findings.filter(f => f.severity === 'HIGH');
        if (highFindings.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix High Severity Issues',
                description: `Found ${highFindings.length} high severity vulnerabilities`,
                action: 'Implement fixes as soon as possible',
                affectedPatterns: [...new Set(highFindings.map(f => f.name))]
            });
        }
        
        const injectionFindings = findings.filter(f => f.category === 'injection');
        if (injectionFindings.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Implement Input Sanitization',
                description: `Found ${injectionFindings.length} potential injection vulnerabilities`,
                action: 'Use parameterized queries and input validation',
                affectedPatterns: [...new Set(injectionFindings.map(f => f.name))]
            });
        }
        
        return recommendations;
    }
    
    async createSecureCodeTemplate(vulnerabilityType) {
        // Создание шаблона безопасного кода для устранения уязвимости
        const templates = {
            'SQL Injection': `
                // SECURE: Use parameterized queries
                const query = 'SELECT * FROM users WHERE id = ?';
                const result = await db.query(query, [userId]);
            `,
            'Command Injection': `
                // SECURE: Validate and sanitize inputs
                const allowedCommands = ['ls', 'pwd', 'date'];
                if (allowedCommands.includes(userCommand)) {
                    const result = spawn(userCommand, args);
                }
            `,
            'XSS': `
                // SECURE: Use output encoding
                const safeOutput = escapeHtml(userInput);
                document.getElementById('output').textContent = safeOutput;
            `,
            'Hardcoded Credentials': `
                // SECURE: Use environment variables
                const apiKey = process.env.API_KEY;
                const dbPassword = process.env.DB_PASSWORD;
            `
        };
        
        return templates[vulnerabilityType] || '// Secure implementation needed';
    }
}

// Использование детектора паттернов
const patternDetector = new VulnerabilityPatternDetector();
```

## Автоматизированные тесты безопасности

### 1. Генератор тестов безопасности

```javascript
// Генератор автоматических тестов безопасности
class SecurityTestGenerator {
    constructor() {
        this.testTemplates = {
            injection: {
                name: 'Injection Tests',
                description: 'Tests for various injection vulnerabilities',
                template: this.generateInjectionTestTemplate.bind(this)
            },
            authentication: {
                name: 'Authentication Tests',
                description: 'Tests for authentication bypass and related issues',
                template: this.generateAuthenticationTestTemplate.bind(this)
            },
            authorization: {
                name: 'Authorization Tests',
                description: 'Tests for authorization bypass and privilege escalation',
                template: this.generateAuthorizationTestTemplate.bind(this)
            },
            session: {
                name: 'Session Tests',
                description: 'Tests for session management vulnerabilities',
                template: this.generateSessionTestTemplate.bind(this)
            },
            input: {
                name: 'Input Validation Tests',
                description: 'Tests for input validation and sanitization',
                template: this.generateInputValidationTestTemplate.bind(this)
            }
        };
    }
    
    async generateTests(code, options = {}) {
        const tests = {
            unitTests: [],
            integrationTests: [],
            securityTests: [],
            recommendations: []
        };
        
        // Анализ кода для определения типов уязвимостей
        const vulnerabilityAnalysis = await this.analyzeCodeForVulnerabilities(code);
        
        // Генерация тестов для каждого типа уязвимости
        for (const vulnerability of vulnerabilityAnalysis) {
            const testCategory = this.mapVulnerabilityToTestCategory(vulnerability);
            const testTemplate = this.testTemplates[testCategory];
            
            if (testTemplate) {
                const generatedTest = await testTemplate.template(code, vulnerability, options);
                tests.securityTests.push(generatedTest);
            }
        }
        
        // Генерация общих тестов
        tests.unitTests = await this.generateUnitTests(code);
        tests.integrationTests = await this.generateIntegrationTests(code);
        
        tests.recommendations = await this.generateTestRecommendations(tests);
        
        return tests;
    }
    
    async analyzeCodeForVulnerabilities(code) {
        // Использование детектора паттернов для анализа кода
        const detector = new VulnerabilityPatternDetector();
        return await detector.analyze(code);
    }
    
    mapVulnerabilityToTestCategory(vulnerability) {
        const categoryMap = {
            'SQL Injection': 'injection',
            'Command Injection': 'injection',
            'XSS': 'injection',
            'Hardcoded Credentials': 'authentication',
            'Weak Password Hashing': 'authentication',
            'Missing Authorization Check': 'authorization',
            'Insecure Session Handling': 'session',
            'Input Validation Missing': 'input'
        };
        
        return categoryMap[vulnerability.name] || 'general';
    }
    
    generateInjectionTestTemplate(code, vulnerability, options) {
        const testCases = [];
        
        switch (vulnerability.name) {
            case 'SQL Injection':
                testCases.push(this.generateSQLInjectionTest(code, vulnerability));
                break;
            case 'XSS':
                testCases.push(this.generateXSSTest(code, vulnerability));
                break;
            case 'Command Injection':
                testCases.push(this.generateCommandInjectionTest(code, vulnerability));
                break;
        }
        
        return {
            vulnerability: vulnerability.name,
            category: 'injection',
            tests: testCases,
            framework: options.framework || 'jest'
        };
    }
    
    generateSQLInjectionTest(code, vulnerability) {
        return {
            name: `SQL Injection Prevention Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                const sinon = require('sinon');
                
                describe('SQL Injection Prevention', () => {
                    test('should prevent SQL injection with malicious input', async () => {
                        const maliciousInput = "' OR '1'='1";
                        
                        // Mock database query
                        const dbQueryStub = sinon.stub(db, 'query');
                        dbQueryStub.resolves([]);
                        
                        try {
                            await vulnerableFunction(maliciousInput);
                            
                            // Verify that the query was parameterized
                            expect(dbQueryStub.calledOnce).toBe(true);
                            const [query, params] = dbQueryStub.firstCall.args;
                            
                            // Ensure the malicious input was not directly concatenated
                            expect(query).not.toContain(maliciousInput);
                            expect(params).toContain(maliciousInput); // Should be in parameters, not query
                        } finally {
                            dbQueryStub.restore();
                        }
                    });
                    
                    test('should handle parameterized queries correctly', async () => {
                        const userInput = 'valid_input';
                        const dbQueryStub = sinon.stub(db, 'query');
                        dbQueryStub.resolves([{ id: 1, name: 'test' }]);
                        
                        try {
                            const result = await vulnerableFunction(userInput);
                            
                            expect(dbQueryStub.calledOnce).toBe(true);
                            const [query, params] = dbQueryStub.firstCall.args;
                            
                            // Verify parameterization
                            expect(query).toContain('?'); // or named parameters
                            expect(params).toEqual([userInput]);
                        } finally {
                            dbQueryStub.restore();
                        }
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateXSSTest(code, vulnerability) {
        return {
            name: `XSS Prevention Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                
                describe('XSS Prevention', () => {
                    test('should prevent XSS with malicious input', () => {
                        const maliciousInput = '<script>alert("XSS")</script>';
                        
                        const result = vulnerableFunction(maliciousInput);
                        
                        // Verify output is properly encoded
                        expect(result).not.toContain('<script>');
                        expect(result).not.toContain('alert(');
                        expect(result).toContain('&lt;script&gt;'); // encoded version
                    });
                    
                    test('should encode special characters', () => {
                        const testInputs = [
                            '<script>alert("test")</script>',
                            '"><img src=x onerror=alert("XSS")>',
                            'javascript:alert("XSS")'
                        ];
                        
                        for (const input of testInputs) {
                            const result = vulnerableFunction(input);
                            expect(result).not.toEqual(input); // Should be different after encoding
                        }
                    });
                    
                    test('should preserve legitimate content', () => {
                        const safeInput = 'Hello, World!';
                        const result = vulnerableFunction(safeInput);
                        expect(result).toEqual(safeInput); // Safe content should pass through
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateCommandInjectionTest(code, vulnerability) {
        return {
            name: `Command Injection Prevention Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                const { execSync } = require('child_process');
                
                describe('Command Injection Prevention', () => {
                    test('should prevent command injection with malicious input', () => {
                        const maliciousInput = '; rm -rf /';
                        
                        // Should throw an error or handle safely
                        expect(() => {
                            vulnerableFunction(maliciousInput);
                        }).toThrow();
                        
                        // Or return a safe response
                        const result = vulnerableFunction(maliciousInput);
                        expect(result).toEqual(expect.objectContaining({
                            success: false,
                            error: expect.stringContaining('invalid')
                        }));
                    });
                    
                    test('should validate input before command execution', () => {
                        const validInput = 'ls';
                        const result = vulnerableFunction(validInput);
                        
                        // Verify that only allowed commands are executed
                        expect(result).toBeDefined();
                    });
                    
                    test('should sanitize user input', () => {
                        const userInput = 'ls && echo "test"';
                        const result = vulnerableFunction(userInput);
                        
                        // Should only execute 'ls', not the entire command
                        expect(result).not.toContain('test'); // Second command shouldn't execute
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateAuthenticationTestTemplate(code, vulnerability, options) {
        const testCases = [];
        
        if (vulnerability.name === 'Hardcoded Credentials') {
            testCases.push(this.generateCredentialSecurityTest(code, vulnerability));
        } else if (vulnerability.name === 'Weak Password Hashing') {
            testCases.push(this.generatePasswordHashingTest(code, vulnerability));
        }
        
        return {
            vulnerability: vulnerability.name,
            category: 'authentication',
            tests: testCases,
            framework: options.framework || 'jest'
        };
    }
    
    generateCredentialSecurityTest(code, vulnerability) {
        return {
            name: `Credential Security Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                
                describe('Credential Security', () => {
                    test('should not contain hardcoded credentials', () => {
                        const fs = require('fs');
                        const sourceCode = fs.readFileSync(__filename, 'utf8');
                        
                        // Verify no hardcoded credentials in code
                        expect(sourceCode).not.toMatch(/password\\s*[:=]\\s*["'][^"']*["']/i);
                        expect(sourceCode).not.toMatch(/token\\s*[:=]\\s*["'][^"']*["']/i);
                        expect(sourceCode).not.toMatch(/secret\\s*[:=]\\s*["'][^"']*["']/i);
                    });
                    
                    test('should use environment variables for sensitive data', () => {
                        // Verify credentials come from environment
                        expect(process.env.API_KEY).toBeDefined();
                        expect(process.env.DB_PASSWORD).toBeDefined();
                    });
                    
                    test('should fail gracefully without credentials', () => {
                        // Temporarily unset environment variables
                        const originalApiKey = process.env.API_KEY;
                        delete process.env.API_KEY;
                        
                        try {
                            expect(() => {
                                vulnerableFunction();
                            }).toThrow();
                        } finally {
                            process.env.API_KEY = originalApiKey; // Restore
                        }
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generatePasswordHashingTest(code, vulnerability) {
        return {
            name: `Password Hashing Security Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                const bcrypt = require('bcrypt');
                
                describe('Password Hashing Security', () => {
                    test('should use strong hashing algorithm', async () => {
                        const password = 'securePassword123!';
                        const hash = await hashPassword(password);
                        
                        // Verify it's not using weak algorithms
                        expect(hash).not.toEqual(password); // Should be different
                        expect(hash.startsWith('$2b$')).toBe(true); // bcrypt format
                        
                        // Verify the hash is actually bcrypt
                        const isValid = await bcrypt.compare(password, hash);
                        expect(isValid).toBe(true);
                    });
                    
                    test('should have sufficient salt rounds', async () => {
                        const password = 'testPassword';
                        const hash = await hashPassword(password);
                        
                        // Extract salt rounds from bcrypt hash (format: $algorithm$rounds$salt$hash)
                        const parts = hash.split('$');
                        const rounds = parseInt(parts[2]);
                        
                        expect(rounds).toBeGreaterThanOrEqual(10); // Minimum recommended
                        expect(rounds).toBeLessThanOrEqual(15); // Not too expensive
                    });
                    
                    test('should verify passwords correctly', async () => {
                        const password = 'correctPassword';
                        const wrongPassword = 'wrongPassword';
                        const hash = await hashPassword(password);
                        
                        const correctMatch = await bcrypt.compare(password, hash);
                        const wrongMatch = await bcrypt.compare(wrongPassword, hash);
                        
                        expect(correctMatch).toBe(true);
                        expect(wrongMatch).toBe(false);
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateAuthorizationTestTemplate(code, vulnerability, options) {
        return {
            name: `Authorization Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                
                describe('Authorization Security', () => {
                    test('should require proper authorization for protected endpoints', async () => {
                        const response = await request(app)
                            .get('/admin/protected')
                            .expect(401); // Should require authentication
                    });
                    
                    test('should prevent horizontal privilege escalation', async () => {
                        const regularUserToken = await getRegularUserToken();
                        
                        const response = await request(app)
                            .get('/api/users/other-user-id')
                            .set('Authorization', \`Bearer \${regularUserToken}\`)
                            .expect(403); // Should not access other user's data
                    });
                    
                    test('should prevent vertical privilege escalation', async () => {
                        const regularUserToken = await getRegularUserToken();
                        
                        const response = await request(app)
                            .post('/api/admin/users')
                            .set('Authorization', \`Bearer \${regularUserToken}\`)
                            .expect(403); // Should not access admin functions
                    });
                    
                    test('should validate role-based access', async () => {
                        const userWithoutAdminRole = await getUserWithoutRole('admin');
                        
                        const response = await request(app)
                            .post('/api/admin/endpoint')
                            .set('Authorization', \`Bearer \${userWithoutAdminRole.token}\`)
                            .expect(403);
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateSessionTestTemplate(code, vulnerability, options) {
        return {
            name: `Session Security Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                
                describe('Session Security', () => {
                    test('should use secure session configuration', () => {
                        const sessionConfig = getSessionConfig();
                        
                        expect(sessionConfig.cookie.secure).toBe(true); // HTTPS only
                        expect(sessionConfig.cookie.httpOnly).toBe(true); // No JS access
                        expect(sessionConfig.cookie.sameSite).toBe('lax'); // CSRF protection
                    });
                    
                    test('should regenerate session IDs after authentication', async () => {
                        const sessionBeforeAuth = await getSessionId();
                        
                        await authenticateUser('valid-credentials');
                        const sessionAfterAuth = await getSessionId();
                        
                        expect(sessionBeforeAuth).not.toEqual(sessionAfterAuth);
                    });
                    
                    test('should invalidate sessions on logout', async () => {
                        const validSession = await getValidSession();
                        
                        await logoutUser(validSession);
                        const response = await requestWithSession(validSession)
                            .get('/protected-endpoint')
                            .expect(401);
                    });
                    
                    test('should have proper session timeout', async () => {
                        const session = await createSession();
                        
                        // Wait for timeout period
                        await sleep(sessionTimeout + 1000);
                        
                        const response = await requestWithSession(session)
                            .get('/protected-endpoint')
                            .expect(401);
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    generateInputValidationTestTemplate(code, vulnerability, options) {
        return {
            name: `Input Validation Test for ${vulnerability.match}`,
            code: `
                const { expect } = require('chai');
                
                describe('Input Validation', () => {
                    test('should validate input types', () => {
                        expect(() => {
                            vulnerableFunction(123); // Should reject non-string input
                        }).toThrow();
                        
                        expect(() => {
                            vulnerableFunction('valid-string-input');
                        }).not.toThrow();
                    });
                    
                    test('should validate input length', () => {
                        const tooLong = 'a'.repeat(1000); // Assuming max length is 100
                        
                        expect(() => {
                            vulnerableFunction(tooLong);
                        }).toThrow();
                        
                        const validLength = 'a'.repeat(50);
                        expect(() => {
                            vulnerableFunction(validLength);
                        }).not.toThrow();
                    });
                    
                    test('should validate input format', () => {
                        const invalidEmail = 'not-an-email';
                        const validEmail = 'user@example.com';
                        
                        expect(() => {
                            validateEmail(invalidEmail);
                        }).toThrow();
                        
                        expect(() => {
                            validateEmail(validEmail);
                        }).not.toThrow();
                    });
                    
                    test('should sanitize input before processing', () => {
                        const maliciousInput = '<script>alert("xss")</script>';
                        const sanitized = sanitizeInput(maliciousInput);
                        
                        expect(sanitized).not.toContain('<script>');
                        expect(sanitized).not.toEqual(maliciousInput);
                    });
                });
            `,
            severity: vulnerability.severity,
            cwe: vulnerability.cwe
        };
    }
    
    async generateUnitTests(code) {
        // Генерация юнит-тестов для безопасного кода
        const functions = this.extractFunctions(code);
        const unitTests = [];
        
        for (const func of functions) {
            unitTests.push({
                name: `Unit test for ${func.name}`,
                code: this.generateUnitTestForFunction(func),
                type: 'unit'
            });
        }
        
        return unitTests;
    }
    
    extractFunctions(code) {
        // Извлечение функций из кода
        const functionPattern = /function\s+(\w+)\s*\([^)]*\)\s*{/g;
        const arrowPattern = /(\w+)\s*=\s*\([^)]*\)\s*=>\s*{/g;
        const methodPattern = /(\w+)\s*\([^)]*\)\s*{/g;
        
        const functions = [];
        
        let match;
        while ((match = functionPattern.exec(code)) !== null) {
            functions.push({ name: match[1], type: 'function' });
        }
        
        while ((match = arrowPattern.exec(code)) !== null) {
            functions.push({ name: match[1], type: 'arrow-function' });
        }
        
        return functions;
    }
    
    generateUnitTestForFunction(func) {
        return `
            const { expect } = require('chai');
            
            describe('${func.name}', () => {
                test('should handle valid input correctly', () => {
                    // Valid input test cases
                });
                
                test('should reject invalid input', () => {
                    // Invalid input test cases
                });
                
                test('should not expose sensitive information', () => {
                    // Privacy test cases
                });
                
                test('should handle errors gracefully', () => {
                    // Error handling test cases
                });
            });
        `;
    }
    
    async generateIntegrationTests(code) {
        // Генерация интеграционных тестов
        const endpoints = this.extractEndpoints(code);
        const integrationTests = [];
        
        for (const endpoint of endpoints) {
            integrationTests.push({
                name: `Integration test for ${endpoint.path}`,
                code: this.generateIntegrationTestForEndpoint(endpoint),
                type: 'integration'
            });
        }
        
        return integrationTests;
    }
    
    extractEndpoints(code) {
        // Извлечение эндпоинтов из кода
        const endpointPattern = /app\.(get|post|put|delete|patch)\s*\(['"`](\/[^'"`]+)['"`]/g;
        const endpoints = [];
        
        let match;
        while ((match = endpointPattern.exec(code)) !== null) {
            endpoints.push({
                method: match[1].toUpperCase(),
                path: match[2],
                line: this.getLineNumber(code, match.index)
            });
        }
        
        return endpoints;
    }
    
    getLineNumber(code, position) {
        return code.substring(0, position).split('\n').length;
    }
    
    generateIntegrationTestForEndpoint(endpoint) {
        return `
            const request = require('supertest');
            const app = require('../app');
            
            describe('${endpoint.method} ${endpoint.path}', () => {
                test('should return appropriate status for valid request', async () => {
                    const response = await request(app)
                        .${endpoint.method.toLowerCase()}('${endpoint.path}')
                        .send({ /* valid payload */ })
                        .expect(200);
                });
                
                test('should return 400 for invalid input', async () => {
                    const response = await request(app)
                        .${endpoint.method.toLowerCase()}('${endpoint.path}')
                        .send({ /* invalid payload */ })
                        .expect(400);
                });
                
                test('should require authentication for protected endpoints', async () => {
                    const response = await request(app)
                        .${endpoint.method.toLowerCase()}('${endpoint.path}')
                        .expect(401);
                });
                
                test('should validate request headers', async () => {
                    const response = await request(app)
                        .${endpoint.method.toLowerCase()}('${endpoint.path}')
                        .set('Content-Type', 'application/json')
                        .expect(200);
                });
            });
        `;
    }
    
    generateTestRecommendations(tests) {
        const recommendations = [];
        
        const securityTests = tests.securityTests;
        if (securityTests.length === 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'No Security Tests Generated',
                description: 'No security tests were generated for the analyzed code',
                action: 'Review code for potential vulnerabilities and add security tests'
            });
        }
        
        const criticalTests = securityTests.filter(t => 
            ['CRITICAL', 'HIGH'].includes(t.severity)
        );
        
        if (criticalTests.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Implement Critical Security Tests',
                description: `Generated ${criticalTests.length} critical security tests`,
                action: 'Review and implement the generated security tests immediately',
                testCount: criticalTests.length
            });
        }
        
        return recommendations;
    }
    
    async generateTestReport(code) {
        const tests = await this.generateTests(code);
        
        return {
            timestamp: new Date().toISOString(),
            generatedTests: {
                unit: tests.unitTests.length,
                integration: tests.integrationTests.length,
                security: tests.securityTests.length,
                total: tests.unitTests.length + tests.integrationTests.length + tests.securityTests.length
            },
            securityTests: tests.securityTests,
            recommendations: tests.recommendations,
            coverageEstimate: this.estimateTestCoverage(code, tests)
        };
    }
    
    estimateTestCoverage(code, tests) {
        // Оценка покрытия тестами
        const functions = this.extractFunctions(code);
        const testedFunctions = new Set();
        
        // Простая оценка на основе имен функций в тестах
        tests.securityTests.forEach(test => {
            if (test.name.includes('Function')) {
                testedFunctions.add(test.name.split(' ')[3]); // имя функции
            }
        });
        
        return {
            totalFunctions: functions.length,
            testedFunctions: testedFunctions.size,
            coveragePercentage: functions.length > 0 ? 
                (testedFunctions.size / functions.length) * 100 : 0
        };
    }
}

// Использование генератора тестов
const testGenerator = new SecurityTestGenerator();

async function generateSecurityTestsForCode(code) {
    const tests = await testGenerator.generateTests(code);
    console.log('Generated Security Tests:', JSON.stringify(tests, null, 2));
    return tests;
}
```

### 2. Интеграция с системами тестирования

```javascript
// Интеграция с Jest для тестирования безопасности
class JestSecurityIntegration {
    constructor(config) {
        this.config = config;
        this.testSuites = [];
    }
    
    async createSecurityTestSuite(code) {
        const securityTests = await this.generateSecurityTests(code);
        
        const testSuite = {
            name: 'Security Tests',
            description: 'Automated security tests generated from code analysis',
            tests: securityTests.securityTests,
            setup: this.generateTestSetup(),
            teardown: this.generateTestTeardown(),
            coverage: this.calculateSecurityCoverage(securityTests)
        };
        
        this.testSuites.push(testSuite);
        
        return testSuite;
    }
    
    generateTestSetup() {
        return `
            const fs = require('fs');
            const path = require('path');
            const { createApp } = require('./app'); // ваше приложение
            
            let app;
            let server;
            
            beforeAll(async () => {
                app = createApp();
                server = app.listen(0); // случайный порт
            });
            
            afterAll(async () => {
                if (server) {
                    server.close();
                }
            });
            
            beforeEach(() => {
                // Сброс состояния между тестами
                jest.clearAllMocks();
            });
        `;
    }
    
    generateTestTeardown() {
        return `
            // Закрытие соединений, очистка данных и т.д.
        `;
    }
    
    calculateSecurityCoverage(securityTests) {
        const totalVulnerabilities = securityTests.securityTests.length;
        const testedVulnerabilities = securityTests.securityTests.filter(test => 
            test.code && test.code.includes('expect')
        ).length;
        
        return {
            total: totalVulnerabilities,
            tested: testedVulnerabilities,
            coverage: totalVulnerabilities > 0 ? (testedVulnerabilities / totalVulnerabilities) * 100 : 0
        };
    }
    
    async runSecurityTests(testSuite) {
        const jest = require('jest');
        
        // Создание временного файла с тестами
        const tempTestFile = `security-tests-${Date.now()}.test.js`;
        
        const testContent = `
            ${testSuite.setup}
            
            describe('Security Tests', () => {
                ${testSuite.tests.map(test => `
                    test('${test.name}', async () => {
                        ${test.code}
                    });
                `).join('\n')}
            });
            
            ${testSuite.teardown}
        `;
        
        fs.writeFileSync(tempTestFile, testContent);
        
        try {
            // Запуск тестов
            const results = await jest.runCLI({
                testPathPattern: [tempTestFile],
                silent: true,
                verbose: false
            }, [process.cwd()]);
            
            return results.results;
        } finally {
            // Удаление временного файла
            if (fs.existsSync(tempTestFile)) {
                fs.unlinkSync(tempTestFile);
            }
        }
    }
    
    async integrateWithExistingTests(code) {
        // Интеграция с существующими тестами
        const existingTests = await this.findExistingTests();
        const newSecurityTests = await this.generateSecurityTests(code);
        
        // Добавление security tests к существующим
        const enhancedTestSuites = this.enhanceTestSuites(existingTests, newSecurityTests);
        
        return enhancedTestSuites;
    }
    
    async findExistingTests() {
        const fs = require('fs');
        const path = require('path');
        
        const testFiles = [];
        const walk = (dir) => {
            const files = fs.readdirSync(dir);
            
            for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                
                if (stat.isDirectory()) {
                    walk(filePath);
                } else if (file.endsWith('.test.js') || file.endsWith('.spec.js')) {
                    testFiles.push(filePath);
                }
            }
        };
        
        walk('./tests');
        walk('./__tests__');
        walk('./test');
        
        return testFiles;
    }
    
    enhanceTestSuites(existingTests, newSecurityTests) {
        // Добавление security tests к существующим test suites
        const enhanced = [];
        
        for (const testFile of existingTests) {
            const content = fs.readFileSync(testFile, 'utf8');
            
            // Добавление security tests к существующему файлу
            const enhancedContent = this.addSecurityTests(content, newSecurityTests);
            
            // Сохранение обновленного файла
            fs.writeFileSync(testFile, enhancedContent);
            
            enhanced.push({
                file: testFile,
                securityTestsAdded: newSecurityTests.securityTests.length,
                originalTests: this.countOriginalTests(content),
                totalTests: this.countOriginalTests(enhancedContent)
            });
        }
        
        return enhanced;
    }
    
    addSecurityTests(content, securityTests) {
        // Добавление security tests к существующему тестовому файлу
        const securityTestSection = `
            // AUTO-GENERATED SECURITY TESTS
            describe('Security Tests', () => {
                ${securityTests.securityTests.map(test => `
                    test('${test.name}', async () => {
                        ${test.code}
                    });
                `).join('\n')}
            });
        `;
        
        return content + '\n' + securityTestSection;
    }
    
    countOriginalTests(content) {
        // Подсчет оригинальных тестов в файле
        const testPattern = /test\s*\(|it\s*\(|describe\s*\(/g;
        return (content.match(testPattern) || []).length;
    }
    
    async generateJestConfig() {
        return {
            preset: 'ts-jest',
            testEnvironment: 'node',
            collectCoverageFrom: [
                'src/**/*.js',
                '!src/**/*.test.js',
                '!src/**/*.spec.js',
                '!src/config/**',
                '!src/migrations/**'
            ],
            coverageThreshold: {
                global: {
                    branches: 80,
                    functions: 80,
                    lines: 80,
                    statements: 80
                }
            },
            setupFilesAfterEnv: ['<rootDir>/tests/setup-security.js'],
            testTimeout: 10000
        };
    }
}

// Использование интеграции с Jest
const jestIntegration = new JestSecurityIntegration({
    coverageThreshold: 80,
    timeout: 10000
});
```

## Практические примеры тестирования

### 1. Тестирование безопасного ввода

```javascript
// Пример тестов для безопасного ввода
describe('Secure Input Validation', () => {
    const validator = new InputValidator();
    
    test('should reject malicious XSS input', () => {
        const maliciousInputs = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")'
        ];
        
        for (const input of maliciousInputs) {
            expect(() => {
                validator.validate(input);
            }).toThrow('Invalid input detected');
        }
    });
    
    test('should accept safe input', () => {
        const safeInputs = [
            'Hello, World!',
            'Username123',
            'Email@domain.com',
            'Valid input with spaces and punctuation.'
        ];
        
        for (const input of safeInputs) {
            expect(() => {
                validator.validate(input);
            }).not.toThrow();
        }
    });
    
    test('should sanitize input properly', () => {
        const input = '<p>Safe paragraph</p>';
        const sanitized = validator.sanitize(input);
        
        // Paragraph tags might be allowed, but script tags should be removed
        expect(sanitized).toContain('<p>');
        expect(sanitized).not.toContain('<script>');
    });
    
    test('should validate email format', () => {
        const validEmail = 'user@example.com';
        const invalidEmail = 'not-an-email';
        
        expect(validator.validateEmail(validEmail)).toBe(true);
        expect(validator.validateEmail(invalidEmail)).toBe(false);
    });
    
    test('should validate URL format', () => {
        const validUrl = 'https://example.com';
        const invalidUrl = 'javascript:alert(1)';
        
        expect(validator.validateUrl(validUrl)).toBe(true);
        expect(validator.validateUrl(invalidUrl)).toBe(false);
    });
    
    test('should validate file uploads', () => {
        const validFile = { name: 'document.pdf', size: 1024, type: 'application/pdf' };
        const invalidFile = { name: 'script.exe', size: 1024, type: 'application/octet-stream' };
        
        expect(validator.validateFileUpload(validFile)).toBe(true);
        expect(validator.validateFileUpload(invalidFile)).toBe(false);
    });
    
    test('should validate file extension', () => {
        const allowedExtensions = ['.jpg', '.png', '.pdf', '.doc'];
        
        expect(validator.validateFileExtension('image.jpg', allowedExtensions)).toBe(true);
        expect(validator.validateFileExtension('script.exe', allowedExtensions)).toBe(false);
    });
    
    test('should validate file content type', () => {
        const validType = 'image/jpeg';
        const maliciousType = 'text/html';
        
        expect(validator.validateFileType(validType)).toBe(true);
        expect(validator.validateFileType(maliciousType)).toBe(false);
    });
    
    test('should validate number ranges', () => {
        const min = 1;
        const max = 100;
        
        expect(validator.validateNumberRange(50, min, max)).toBe(true);
        expect(validator.validateNumberRange(0, min, max)).toBe(false);
        expect(validator.validateNumberRange(101, min, max)).toBe(false);
    });
    
    test('should validate string length', () => {
        const minLength = 3;
        const maxLength = 20;
        
        expect(validator.validateStringLength('abc', minLength, maxLength)).toBe(true);
        expect(validator.validateStringLength('ab', minLength, maxLength)).toBe(false);
        expect(validator.validateStringLength('a'.repeat(21), minLength, maxLength)).toBe(false);
    });
    
    test('should validate phone number format', () => {
        const validPhone = '+1-234-567-8900';
        const invalidPhone = 'not-a-phone';
        
        expect(validator.validatePhone(validPhone)).toBe(true);
        expect(validator.validatePhone(invalidPhone)).toBe(false);
    });
    
    test('should validate date format', () => {
        const validDate = '2023-12-25';
        const invalidDate = 'invalid-date';
        
        expect(validator.validateDate(validDate)).toBe(true);
        expect(validator.validateDate(invalidDate)).toBe(false);
    });
    
    test('should validate credit card number', () => {
        const validCard = '4532015112830366'; // Visa test number
        const invalidCard = '1234567890123456';
        
        expect(validator.validateCreditCard(validCard)).toBe(true);
        expect(validator.validateCreditCard(invalidCard)).toBe(false);
    });
    
    test('should validate UUID format', () => {
        const validUUID = '550e8400-e29b-41d4-a716-446655440000';
        const invalidUUID = 'not-a-uuid';
        
        expect(validator.validateUUID(validUUID)).toBe(true);
        expect(validator.validateUUID(invalidUUID)).toBe(false);
    });
    
    test('should validate IP address', () => {
        const validIPv4 = '192.168.1.1';
        const validIPv6 = '2001:0db8:85a3:0000:0000:8a2e:0370:7334';
        const invalidIP = '999.999.999.999';
        
        expect(validator.validateIP(validIPv4)).toBe(true);
        expect(validator.validateIP(validIPv6)).toBe(true);
        expect(validator.validateIP(invalidIP)).toBe(false);
    });
    
    test('should validate JSON format', () => {
        const validJSON = '{"name": "test", "value": 123}';
        const invalidJSON = '{"name": test, "value": 123}'; // missing quotes
        
        expect(validator.validateJSON(validJSON)).toBe(true);
        expect(validator.validateJSON(invalidJSON)).toBe(false);
    });
    
    test('should validate XML format', () => {
        const validXML = '<?xml version="1.0"?><root><item>test</item></root>';
        const invalidXML = '<root><item>test</item>'; // unclosed tag
        
        expect(validator.validateXML(validXML)).toBe(true);
        expect(validator.validateXML(invalidXML)).toBe(false);
    });
    
    test('should validate SQL query safety', () => {
        const safeQuery = 'SELECT * FROM users WHERE id = ?';
        const unsafeQuery = "SELECT * FROM users WHERE id = '1' OR '1'='1'";
        
        expect(validator.validateSQLQuery(safeQuery)).toBe(true);
        expect(validator.validateSQLQuery(unsafeQuery)).toBe(false);
    });
    
    test('should validate file path for traversal', () => {
        const safePath = 'documents/file.txt';
        const unsafePath = '../../../etc/passwd';
        
        expect(validator.validateFilePath(safePath)).toBe(true);
        expect(validator.validateFilePath(unsafePath)).toBe(false);
    });
    
    test('should validate command for injection', () => {
        const safeCommand = 'ls -la';
        const unsafeCommand = 'ls -la; rm -rf /';
        
        expect(validator.validateCommand(safeCommand)).toBe(true);
        expect(validator.validateCommand(unsafeCommand)).toBe(false);
    });
    
    test('should validate regular expression safety', () => {
        const safeRegex = /^[a-zA-Z0-9_]+$/;
        const potentiallyUnsafeRegex = /(a+)+b/; // catastrophic backtracking
        
        expect(validator.validateRegexSafety(safeRegex)).toBe(true);
        expect(validator.validateRegexSafety(potentiallyUnsafeRegex)).toBe(false);
    });
});

// Класс валидатора для тестов
class InputValidator {
    validate(input) {
        if (typeof input !== 'string') {
            throw new Error('Input must be a string');
        }
        
        if (this.containsMaliciousPatterns(input)) {
            throw new Error('Invalid input detected');
        }
        
        return true;
    }
    
    containsMaliciousPatterns(input) {
        const maliciousPatterns = [
            /<script/i,
            /javascript:/i,
            /vbscript:/i,
            /on\w+\s*=/i,
            /eval\s*\(/i,
            /exec\s*\(/i,
            /document\.cookie/i,
            /window\.location/i,
            /<iframe/i,
            /<object/i,
            /<embed/i,
            /<meta/i,
            /<link/i
        ];
        
        return maliciousPatterns.some(pattern => pattern.test(input));
    }
    
    sanitize(input) {
        if (typeof input !== 'string') return input;
        
        // Базовая санитизация
        return input
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    
    validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    
    validateUrl(url) {
        try {
            new URL(url);
            return !url.includes('javascript:') && !url.includes('data:');
        } catch {
            return false;
        }
    }
    
    validateFileUpload(file) {
        const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf', 'text/plain'];
        const allowedExtensions = ['.jpg', '.jpeg', '.png', '.pdf', '.txt'];
        
        const hasValidType = allowedTypes.includes(file.type);
        const hasValidExtension = allowedExtensions.some(ext => 
            file.name.toLowerCase().endsWith(ext)
        );
        
        return hasValidType && hasValidExtension;
    }
    
    validateFileExtension(filename, allowedExtensions) {
        return allowedExtensions.some(ext => 
            filename.toLowerCase().endsWith(ext.toLowerCase())
        );
    }
    
    validateFileType(type) {
        const allowedTypes = [
            'image/jpeg', 'image/png', 'image/gif',
            'application/pdf', 'text/plain', 'application/json'
        ];
        
        return allowedTypes.includes(type);
    }
    
    validateNumberRange(value, min, max) {
        const num = Number(value);
        return !isNaN(num) && num >= min && num <= max;
    }
    
    validateStringLength(str, min, max) {
        return str.length >= min && str.length <= max;
    }
    
    validatePhone(phone) {
        const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
        return phoneRegex.test(phone);
    }
    
    validateDate(dateString) {
        const date = new Date(dateString);
        return date instanceof Date && !isNaN(date);
    }
    
    validateCreditCard(cardNumber) {
        // Простая проверка (в реальности использовать алгоритм Луна)
        const cleaned = cardNumber.replace(/\D/g, '');
        return cleaned.length === 16 && /^\d+$/.test(cleaned);
    }
    
    validateUUID(uuid) {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(uuid);
    }
    
    validateIP(ip) {
        const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
        const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
        
        if (ipv4Regex.test(ip)) {
            return ip.split('.').every(octet => parseInt(octet, 10) <= 255);
        }
        
        return ipv6Regex.test(ip);
    }
    
    validateJSON(jsonString) {
        try {
            JSON.parse(jsonString);
            return true;
        } catch {
            return false;
        }
    }
    
    validateXML(xmlString) {
        try {
            // В реальности использовать XML парсер
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlString, 'text/xml');
            return doc.getElementsByTagName('parsererror').length === 0;
        } catch {
            return false;
        }
    }
    
    validateSQLQuery(query) {
        // Проверка на SQL-инъекции
        const injectionPatterns = [
            /(\b(union|select|insert|delete|update|drop|create|alter|exec|execute)\b)/i,
            /('|;|--|\/\*|\*\/)/,
            /(\b(or|and)\s+1\s*=\s*1\b)/i
        ];
        
        return !injectionPatterns.some(pattern => pattern.test(query));
    }
    
    validateFilePath(path) {
        // Проверка на путь traversal
        return !path.includes('../') && !path.includes('..\\');
    }
    
    validateCommand(command) {
        // Проверка на command injection
        const dangerousPatterns = [/(;|&&|\||`|\$|\(|\)|\{|\})/g];
        return !dangerousPatterns.some(pattern => pattern.test(command));
    }
    
    validateRegexSafety(regex) {
        // Простая проверка на потенциально опасные регулярные выражения
        const unsafePatterns = [
            /\(.*\+.+\)\+/, // catastrophic backtracking
            /\[.*\^.*\]/ // potentially unsafe character classes
        ];
        
        const regexStr = regex.toString();
        return !unsafePatterns.some(pattern => pattern.test(regexStr));
    }
}

// Использование валидатора
const inputValidator = new InputValidator();
```

### 2. Тестирование безопасного вывода

```javascript
// Тестирование безопасного вывода
describe('Secure Output Encoding', () => {
    const encoder = new OutputEncoder();
    
    test('should encode HTML entities', () => {
        const input = '<script>alert("XSS")</script>';
        const encoded = encoder.encodeHtml(input);
        
        expect(encoded).toBe('&lt;script&gt;alert(&quot;XSS&quot;)&lt;&#x2F;script&gt;');
        expect(encoded).not.toContain('<script>');
    });
    
    test('should encode for JavaScript context', () => {
        const input = '"; alert("XSS"); "';
        const encoded = encoder.encodeJavaScript(input);
        
        expect(encoded).toBe('\\"; alert(\\"XSS\\"); \\"');
        expect(encoded).not.toContain('alert(');
    });
    
    test('should encode for CSS context', () => {
        const input = 'red; color: expression(alert("XSS"));';
        const encoded = encoder.encodeCSS(input);
        
        expect(encoded).not.toContain('expression');
        expect(encoded).not.toContain('alert');
    });
    
    test('should encode for URL context', () => {
        const input = 'javascript:alert("XSS")';
        const encoded = encoder.encodeUrl(input);
        
        expect(encoded).toBe('javascript%3Aalert%28%22XSS%22%29');
        expect(encoded).not.toEqual(input);
    });
    
    test('should encode for HTML attribute context', () => {
        const input = '" onload="alert("XSS")';
        const encoded = encoder.encodeHtmlAttribute(input);
        
        expect(encoded).not.toContain('onload');
        expect(encoded).not.toContain('alert');
    });
    
    test('should handle null and undefined values', () => {
        expect(encoder.encodeHtml(null)).toBeNull();
        expect(encoder.encodeHtml(undefined)).toBeUndefined();
        expect(encoder.encodeHtml('')).toBe('');
    });
    
    test('should preserve safe content', () => {
        const safeContent = 'Hello, World! This is safe content with normal punctuation: .,!?';
        const encoded = encoder.encodeHtml(safeContent);
        
        expect(encoded).toBe(safeContent); // Safe content should not be altered
    });
    
    test('should handle special characters', () => {
        const specialChars = '&<>"\'`/=';
        const encoded = encoder.encodeHtml(specialChars);
        
        expect(encoded).toBe('&amp;&lt;&gt;&quot;&#x27;&#x60;&#x2F;&#x3D;');
    });
    
    test('should encode different contexts appropriately', () => {
        const testValue = '<div>Test</div>';
        
        const htmlEncoded = encoder.encodeHtml(testValue);
        const jsEncoded = encoder.encodeJavaScript(testValue);
        const cssEncoded = encoder.encodeCSS(testValue);
        const urlEncoded = encoder.encodeUrl(testValue);
        
        expect(htmlEncoded).not.toEqual(jsEncoded);
        expect(jsEncoded).not.toEqual(cssEncoded);
        expect(cssEncoded).not.toEqual(urlEncoded);
    });
    
    test('should not double encode', () => {
        const encodedOnce = encoder.encodeHtml('<script>');
        const encodedTwice = encoder.encodeHtml(encodedOnce);
        
        expect(encodedOnce).toBe(encodedTwice); // Should remain the same
    });
    
    test('should handle large inputs efficiently', () => {
        const largeInput = 'A'.repeat(10000); // 10KB of data
        const startTime = Date.now();
        
        const encoded = encoder.encodeHtml(largeInput);
        
        const executionTime = Date.now() - startTime;
        
        expect(executionTime).toBeLessThan(100); // Should encode quickly (<100ms)
        expect(encoded).toBe(largeInput); // Safe content unchanged
    });
    
    test('should handle Unicode characters', () => {
        const unicodeInput = 'Unicode: ñáéíóú 中文 العربية';
        const encoded = encoder.encodeHtml(unicodeInput);
        
        expect(encoded).toBe(unicodeInput); // Unicode should be preserved
    });
    
    test('should encode JSON strings safely', () => {
        const jsonInput = '{"name": "<script>alert(1)</script>", "value": 123}';
        const encoded = encoder.encodeJsonString(jsonInput);
        
        expect(encoded).not.toContain('<script>');
        expect(encoded).not.toContain('alert');
    });
    
    test('should encode XML content', () => {
        const xmlInput = '<tag attribute="value">content</tag>';
        const encoded = encoder.encodeXml(xmlInput);
        
        expect(encoded).toBe('&lt;tag attribute=&quot;value&quot;&gt;content&lt;/tag&gt;');
    });
    
    test('should encode email addresses safely', () => {
        const emailInput = 'user<script>alert(1)</script>@example.com';
        const encoded = encoder.encodeHtml(emailInput);
        
        expect(encoded).not.toContain('<script>');
        expect(encoded).not.toContain('alert');
    });
    
    test('should encode file paths safely', () => {
        const pathInput = '../<script>alert(1)</script>/file.txt';
        const encoded = encoder.encodeHtml(pathInput);
        
        expect(encoded).not.toContain('<script>');
        expect(encoded).not.toContain('..');
    });
    
    test('should encode query parameters safely', () => {
        const paramInput = 'search=<script>alert(1)</script>';
        const encoded = encoder.encodeUrl(paramInput);
        
        expect(encoded).not.toContain('<script>');
        expect(encoded).not.toContain('alert');
    });
    
    test('should encode form data safely', () => {
        const formData = {
            name: '<script>alert(1)</script>',
            email: 'user@<script>alert(1)</script>.com',
            message: 'Safe message'
        };
        
        const encodedData = encoder.encodeFormData(formData);
        
        expect(encodedData.name).not.toContain('<script>');
        expect(encodedData.email).not.toContain('<script>');
        expect(encodedData.message).toBe('Safe message'); // Safe content unchanged
    });
    
    test('should encode HTML with mixed content', () => {
        const mixedInput = '<p>Hello & welcome to <a href="javascript:alert(1)">our site</a></p>';
        const encoded = encoder.encodeHtml(mixedInput);
        
        expect(encoded).not.toContain('javascript:');
        expect(encoded).not.toContain('alert');
        expect(encoded).toContain('&amp;'); // Safe ampersand preserved
    });
    
    test('should encode nested structures', () => {
        const nestedData = {
            user: {
                name: '<script>alert(1)</script>',
                profile: {
                    bio: 'Safe bio',
                    website: 'javascript:alert(1)'
                }
            }
        };
        
        const encoded = encoder.encodeNestedData(nestedData);
        
        expect(encoded.user.name).not.toContain('<script>');
        expect(encoded.user.profile.website).toBe('javascript%3Aalert%281%29'); // URL-encoded
        expect(encoded.user.profile.bio).toBe('Safe bio'); // Safe content unchanged
    });
    
    test('should handle circular references', () => {
        const circularObj = { name: 'test' };
        circularObj.self = circularObj; // Circular reference
        
        expect(() => {
            encoder.encodeNestedData(circularObj);
        }).not.toThrow();
    });
    
    test('should handle arrays', () => {
        const arrayInput = [
            '<script>alert(1)</script>',
            'safe item',
            { nested: '<script>alert(2)</script>' }
        ];
        
        const encoded = encoder.encodeNestedData(arrayInput);
        
        expect(encoded[0]).not.toContain('<script>');
        expect(encoded[1]).toBe('safe item');
        expect(encoded[2].nested).not.toContain('<script>');
    });
});

// Класс кодировщика для тестов
class OutputEncoder {
    encodeHtml(text) {
        if (typeof text !== 'string') return text;
        
        const entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '/': '&#x2F;',
            '`': '&#x60;',
            '=': '&#x3D;'
        };
        
        return text.replace(/[&<>"'`=\/]/g, function(s) {
            return entityMap[s];
        });
    }
    
    encodeJavaScript(str) {
        if (typeof str !== 'string') return str;
        
        return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(/\0/g, '\\0')
            .replace(/</g, '\\u003c')  // Prevent closing tags
            .replace(/>/g, '\\u003e'); // Prevent opening tags
    }
    
    encodeCSS(str) {
        if (typeof str !== 'string') return str;
        
        // Prevent CSS injection
        return str
            .replace(/</g, '\\3C ')
            .replace(/>/g, '\\3E ')
            .replace(/javascript:/gi, 'java script:')
            .replace(/expression\s*\(/gi, 'expression (')
            .replace(/eval\s*\(/gi, 'eval (');
    }
    
    encodeUrl(str) {
        if (typeof str !== 'string') return str;
        return encodeURIComponent(str);
    }
    
    encodeHtmlAttribute(str) {
        if (typeof str !== 'string') return str;
        
        // More aggressive encoding for HTML attributes
        return this.encodeHtml(str)
            .replace(/\s/g, '&#x20;')  // Encode spaces
            .replace(/[\(\)]/g, function(s) {  // Encode parentheses
                return s === '(' ? '&#x28;' : '&#x29;';
            });
    }
    
    encodeJsonString(str) {
        if (typeof str !== 'string') return str;
        
        // Encode for use inside JSON strings
        return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(/\f/g, '\\f')
            .replace(/\b/g, '\\b');
    }
    
    encodeXml(str) {
        return this.encodeHtml(str);
    }
    
    encodeFormData(data) {
        if (typeof data !== 'object' || data === null) return data;
        
        const encoded = {};
        for (const [key, value] of Object.entries(data)) {
            encoded[key] = typeof value === 'string' ? this.encodeHtml(value) : value;
        }
        return encoded;
    }
    
    encodeNestedData(data) {
        if (typeof data !== 'object' || data === null) {
            return typeof data === 'string' ? this.encodeHtml(data) : data;
        }
        
        if (Array.isArray(data)) {
            return data.map(item => this.encodeNestedData(item));
        }
        
        const encoded = {};
        for (const [key, value] of Object.entries(data)) {
            encoded[key] = this.encodeNestedData(value);
        }
        return encoded;
    }
}

// Использование кодировщика
const outputEncoder = new OutputEncoder();
```

## Интеграция с системами мониторинга

### 1. Мониторинг тестов безопасности

```javascript
// Система мониторинга тестов безопасности
class SecurityTestMonitor {
    constructor() {
        this.testResults = new Map();
        this.metrics = {
            totalTests: 0,
            passedTests: 0,
            failedTests: 0,
            skippedTests: 0,
            executionTime: 0
        };
        
        this.alertThresholds = {
            failureRate: 0.1, // 10% порог
            executionTime: 30000, // 30 секунд
            criticalFailures: 0 // 0 критических ошибок допустимо
        };
    }
    
    async runSecurityTestSuite(suite) {
        const startTime = Date.now();
        const results = {
            suite: suite.name,
            timestamp: new Date().toISOString(),
            tests: [],
            summary: {
                total: 0,
                passed: 0,
                failed: 0,
                skipped: 0
            },
            executionTime: 0
        };
        
        for (const test of suite.tests) {
            const testResult = await this.executeSecurityTest(test);
            results.tests.push(testResult);
            
            results.summary.total++;
            if (testResult.status === 'PASS') results.summary.passed++;
            else if (testResult.status === 'FAIL') results.summary.failed++;
            else if (testResult.status === 'SKIP') results.summary.skipped++;
        }
        
        results.executionTime = Date.now() - startTime;
        
        // Обновление метрик
        this.updateMetrics(results);
        
        // Проверка порогов
        await this.checkAlertThresholds(results);
        
        // Сохранение результатов
        this.testResults.set(results.timestamp, results);
        
        return results;
    }
    
    async executeSecurityTest(test) {
        const result = {
            name: test.name,
            description: test.description,
            severity: test.severity,
            startTime: new Date().toISOString(),
            status: 'RUNNING',
            error: null,
            executionTime: 0
        };
        
        try {
            const testStartTime = Date.now();
            
            // Выполнение теста
            await eval(`(${test.code})`)(); // В реальности использовать безопасное выполнение
            
            result.executionTime = Date.now() - testStartTime;
            result.status = 'PASS';
        } catch (error) {
            result.executionTime = Date.now() - Date.parse(result.startTime);
            result.status = 'FAIL';
            result.error = {
                message: error.message,
                stack: error.stack,
                type: error.constructor.name
            };
        }
        
        return result;
    }
    
    updateMetrics(results) {
        this.metrics.totalTests += results.summary.total;
        this.metrics.passedTests += results.summary.passed;
        this.metrics.failedTests += results.summary.failed;
        this.metrics.skippedTests += results.summary.skipped;
        this.metrics.executionTime += results.executionTime;
    }
    
    async checkAlertThresholds(results) {
        const failureRate = results.summary.failed / results.summary.total;
        const criticalFailures = results.tests.filter(t => 
            t.status === 'FAIL' && t.severity === 'CRITICAL'
        ).length;
        
        const alerts = [];
        
        if (failureRate > this.alertThresholds.failureRate) {
            alerts.push({
                type: 'HIGH_FAILURE_RATE',
                severity: 'HIGH',
                message: `Security test failure rate (${(failureRate * 100).toFixed(2)}%) exceeds threshold (${this.alertThresholds.failureRate * 100}%)`,
                data: { failureRate, threshold: this.alertThresholds.failureRate }
            });
        }
        
        if (results.executionTime > this.alertThresholds.executionTime) {
            alerts.push({
                type: 'SLOW_EXECUTION',
                severity: 'MEDIUM',
                message: `Security test suite took too long: ${results.executionTime}ms (threshold: ${this.alertThresholds.executionTime}ms)`,
                data: { executionTime: results.executionTime, threshold: this.alertThresholds.executionTime }
            });
        }
        
        if (criticalFailures > this.alertThresholds.criticalFailures) {
            alerts.push({
                type: 'CRITICAL_FAILURES',
                severity: 'CRITICAL',
                message: `Found ${criticalFailures} critical security test failures (threshold: ${this.alertThresholds.criticalFailures})`,
                data: { criticalFailures, threshold: this.alertThresholds.criticalFailures }
            });
        }
        
        if (alerts.length > 0) {
            await this.sendAlerts(alerts);
        }
    }
    
    async sendAlerts(alerts) {
        for (const alert of alerts) {
            console.error(`SECURITY TEST ALERT [${alert.severity}]: ${alert.message}`);
            
            // В реальности интеграция с системами уведомлений
            if (process.env.SECURITY_ALERT_WEBHOOK) {
                try {
                    await fetch(process.env.SECURITY_ALERT_WEBHOOK, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: 'SECURITY_TEST_ALERT',
                            alert: alert,
                            timestamp: new Date().toISOString()
                        })
                    });
                } catch (error) {
                    console.error('Failed to send security alert:', error);
                }
            }
        }
    }
    
    getTestMetrics() {
        return {
            ...this.metrics,
            passRate: this.metrics.totalTests > 0 ? 
                (this.metrics.passedTests / this.metrics.totalTests) * 100 : 0,
            failureRate: this.metrics.totalTests > 0 ? 
                (this.metrics.failedTests / this.metrics.totalTests) * 100 : 0,
            averageExecutionTime: this.metrics.totalTests > 0 ? 
                this.metrics.executionTime / this.metrics.totalTests : 0
        };
    }
    
    getComplianceReport() {
        const metrics = this.getTestMetrics();
        
        return {
            timestamp: new Date().toISOString(),
            metrics: metrics,
            compliance: {
                overall: metrics.passRate >= 90 ? 'COMPLIANT' : 'NON_COMPLIANT',
                critical: metrics.criticalFailures === 0 ? 'COMPLIANT' : 'NON_COMPLIANT',
                performance: metrics.averageExecutionTime < 10000 ? 'OPTIMAL' : 'SUBOPTIMAL'
            },
            recommendations: this.generateRecommendations(metrics)
        };
    }
    
    generateRecommendations(metrics) {
        const recommendations = [];
        
        if (metrics.passRate < 90) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Improve Security Test Pass Rate',
                description: `Current pass rate is ${metrics.passRate.toFixed(2)}%, target is 90%+`,
                action: 'Review and fix failing security tests'
            });
        }
        
        if (metrics.criticalFailures > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Security Failures',
                description: `Found ${metrics.criticalFailures} critical security test failures`,
                action: 'Fix critical security issues immediately'
            });
        }
        
        if (metrics.averageExecutionTime > 30000) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Optimize Security Test Performance',
                description: `Average test execution time is ${metrics.averageExecutionTime}ms, target is <30s`,
                action: 'Optimize slow security tests'
            });
        }
        
        return recommendations;
    }
    
    async getHistoricalTrends() {
        const timestamps = Array.from(this.testResults.keys())
            .sort()
            .slice(-30); // последние 30 запусков
        
        const trends = {
            passRateOverTime: [],
            executionTimeOverTime: [],
            failureRateOverTime: []
        };
        
        for (const timestamp of timestamps) {
            const result = this.testResults.get(timestamp);
            trends.passRateOverTime.push({
                timestamp,
                rate: result.summary.total > 0 ? (result.summary.passed / result.summary.total) * 100 : 0
            });
            
            trends.executionTimeOverTime.push({
                timestamp,
                time: result.executionTime
            });
            
            trends.failureRateOverTime.push({
                timestamp,
                rate: result.summary.total > 0 ? (result.summary.failed / result.summary.total) * 100 : 0
            });
        }
        
        return trends;
    }
    
    async exportTestResults(format = 'json') {
        const results = Array.from(this.testResults.values());
        
        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(results, null, 2);
            case 'csv':
                return this.generateCSVReport(results);
            case 'html':
                return this.generateHTMLReport(results);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    generateCSVReport(results) {
        let csv = 'Suite,Timestamp,Total,Passed,Failed,Skipped,ExecutionTime\n';
        
        for (const result of results) {
            csv += `${result.suite},"${result.timestamp}",${result.summary.total},${result.summary.passed},${result.summary.failed},${result.summary.skipped},${result.executionTime}\n`;
        }
        
        return csv;
    }
    
    generateHTMLReport(results) {
        return `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Security Test Results</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f0f0f0; padding: 15px; margin: 10px 0; }
                .test { border: 1px solid #ddd; margin: 10px 0; padding: 10px; }
                .pass { background: #e8f5e8; }
                .fail { background: #ffe8e8; }
                .skip { background: #fff3e0; }
            </style>
        </head>
        <body>
            <h1>Security Test Results</h1>
            <div class="summary">
                <h2>Summary</h2>
                <p>Total Tests: ${this.metrics.totalTests}</p>
                <p>Passed: ${this.metrics.passedTests} (${this.metrics.totalTests > 0 ? ((this.metrics.passedTests / this.metrics.totalTests) * 100).toFixed(2) : 0}%)</p>
                <p>Failed: ${this.metrics.failedTests} (${this.metrics.totalTests > 0 ? ((this.metrics.failedTests / this.metrics.totalTests) * 100).toFixed(2) : 0}%)</p>
                <p>Skipped: ${this.metrics.skippedTests}</p>
            </div>
            
            <h2>Recent Test Runs</h2>
            ${results.slice(-10).map(result => `
                <div class="test">
                    <h3>${result.suite} - ${result.timestamp}</h3>
                    <p>Execution Time: ${result.executionTime}ms</p>
                    <p>Passed: ${result.summary.passed}, Failed: ${result.summary.failed}, Skipped: ${result.summary.skipped}</p>
                </div>
            `).join('')}
        </body>
        </html>
        `;
    }
}

// Использование монитора тестов безопасности
const testMonitor = new SecurityTestMonitor();

// Запуск тестов безопасности
async function runSecurityTests() {
    const testSuite = {
        name: 'Core Security Tests',
        tests: [
            {
                name: 'Input Validation Test',
                description: 'Tests for input validation vulnerabilities',
                severity: 'HIGH',
                code: `
                    test('should validate input properly', () => {
                        expect(validateInput('<script>alert(1)</script>')).toBe(false);
                    });
                `
            },
            {
                name: 'Output Encoding Test',
                description: 'Tests for output encoding vulnerabilities',
                severity: 'HIGH',
                code: `
                    test('should encode output properly', () => {
                        const encoded = encodeOutput('<script>alert(1)</script>');
                        expect(encoded).toBe('&lt;script&gt;alert(1)&lt;/script&gt;');
                    });
                `
            }
        ]
    };
    
    const results = await testMonitor.runSecurityTestSuite(testSuite);
    console.log('Security Test Results:', JSON.stringify(results, null, 2));
    
    const complianceReport = testMonitor.getComplianceReport();
    console.log('Compliance Report:', JSON.stringify(complianceReport, null, 2));
    
    return results;
}
```

## Лучшие практики

### 1. Политики безопасности кода

```javascript
// Политики безопасности для кода
class SecureCodePolicy {
    constructor() {
        this.policies = {
            // Политика валидации ввода
            inputValidation: {
                required: true,
                methods: ['whitelist', 'typeChecking', 'lengthValidation', 'formatValidation'],
                frameworks: ['joi', 'yup', 'validator.js'],
                forbidden: ['eval', 'Function constructor', 'innerHTML']
            },
            
            // Политика кодирования вывода
            outputEncoding: {
                required: true,
                contexts: ['html', 'javascript', 'css', 'url', 'attribute'],
                frameworks: ['escape-html', 'he', 'sanitize-html'],
                requiredFor: ['userProvided', 'externalData', 'databaseResults']
            },
            
            // Политика управления сессиями
            sessionManagement: {
                required: true,
                requirements: [
                    'secureCookies',
                    'httpOnly',
                    'sameSite',
                    'regenerateOnAuth',
                    'timeout',
                    'invalidateOnLogout'
                ]
            },
            
            // Политика аутентификации
            authentication: {
                required: true,
                requirements: [
                    'bcrypt',
                    'rateLimiting',
                    'multiFactor',
                    'secureStorage',
                    'properLogout'
                ]
            },
            
            // Политика авторизации
            authorization: {
                required: true,
                requirements: [
                    'rbac',
                    'leastPrivilege',
                    'accessControls',
                    'permissionValidation'
                ]
            },
            
            // Политика обработки ошибок
            errorHandling: {
                required: true,
                requirements: [
                    'genericMessages',
                    'noStackTrace',
                    'secureLogging',
                    'gracefulDegradation'
                ]
            }
        };
        
        this.enforcementRules = new Map();
        this.violationHistory = [];
    }
    
    async validateCodeAgainstPolicy(code, context = {}) {
        const results = {
            inputValidation: await this.checkInputValidation(code),
            outputEncoding: await this.checkOutputEncoding(code),
            sessionManagement: await this.checkSessionManagement(code),
            authentication: await this.checkAuthentication(code),
            authorization: await this.checkAuthorization(code),
            errorHandling: await this.checkErrorHandling(code),
            overallCompliance: false
        };
        
        results.overallCompliance = this.isOverallCompliant(results);
        
        if (!results.overallCompliance) {
            await this.recordPolicyViolation(code, results, context);
        }
        
        return results;
    }
    
    async checkInputValidation(code) {
        const checks = {
            hasValidation: this.containsValidationLogic(code),
            usesSafeMethods: this.usesSafeValidationMethods(code),
            avoidsDangerousPatterns: !this.containsDangerousPatterns(code),
            coversAllInputs: this.coversAllInputSources(code),
            passes: false
        };
        
        checks.passes = checks.hasValidation && 
                       checks.usesSafeMethods && 
                       checks.avoidsDangerousPatterns && 
                       checks.coversAllInputs;
        
        return checks;
    }
    
    async checkOutputEncoding(code) {
        const checks = {
            hasEncoding: this.containsOutputEncoding(code),
            usesContextualEncoding: this.usesContextualOutputEncoding(code),
            coversAllOutputs: this.coversAllOutputDestinations(code),
            passes: false
        };
        
        checks.passes = checks.hasEncoding && 
                       checks.usesContextualEncoding && 
                       checks.coversAllOutputs;
        
        return checks;
    }
    
    async checkSessionManagement(code) {
        const checks = {
            secureCookies: this.implementsSecureCookies(code),
            httpOnlyCookies: this.implementsHttpOnlyCookies(code),
            sameSiteProtection: this.implementsSameSiteProtection(code),
            sessionRegeneration: this.implementsSessionRegeneration(code),
            timeoutHandling: this.implementsSessionTimeout(code),
            properInvalidation: this.implementsProperSessionInvalidation(code),
            passes: false
        };
        
        checks.passes = checks.secureCookies && 
                       checks.httpOnlyCookies && 
                       checks.sameSiteProtection && 
                       checks.sessionRegeneration && 
                       checks.timeoutHandling && 
                       checks.properInvalidation;
        
        return checks;
    }
    
    async checkAuthentication(code) {
        const checks = {
            securePasswordHashing: this.usesSecurePasswordHashing(code),
            rateLimiting: this.implementsRateLimiting(code),
            secureStorage: this.implementsSecureCredentialStorage(code),
            properLogout: this.implementsProperLogout(code),
            multiFactor: this.implementsMultiFactorAuthentication(code),
            passes: false
        };
        
        checks.passes = checks.securePasswordHashing && 
                       checks.rateLimiting && 
                       checks.secureStorage && 
                       checks.properLogout;
        
        return checks;
    }
    
    async checkAuthorization(code) {
        const checks = {
            accessControls: this.implementsAccessControls(code),
            roleBased: this.implementsRoleBasedAccess(code),
            leastPrivilege: this.implementsLeastPrivilege(code),
            permissionValidation: this.implementsPermissionValidation(code),
            passes: false
        };
        
        checks.passes = checks.accessControls && 
                       checks.roleBased && 
                       checks.leastPrivilege && 
                       checks.permissionValidation;
        
        return checks;
    }
    
    async checkErrorHandling(code) {
        const checks = {
            genericMessages: this.usesGenericErrorMessages(code),
            noStackTrace: this.avoidsStackTraceExposure(code),
            secureLogging: this.implementsSecureErrorLogging(code),
            gracefulDegradation: this.implementsGracefulErrorHandling(code),
            passes: false
        };
        
        checks.passes = checks.genericMessages && 
                       checks.noStackTrace && 
                       checks.secureLogging && 
                       checks.gracefulDegradation;
        
        return checks;
    }
    
    containsValidationLogic(code) {
        const validationPatterns = [
            /joi\./,
            /yup\./,
            /validator\./,
            /validate/,
            /check/,
            /sanitiz/,
            /escape/,
            /encode/
        ];
        
        return validationPatterns.some(pattern => pattern.test(code));
    }
    
    usesSafeValidationMethods(code) {
        const dangerousMethods = [
            /eval\s*\(/,
            /Function\s*\(/,
            /innerHTML\s*=/,
            /outerHTML\s*=/
        ];
        
        return !dangerousMethods.some(pattern => pattern.test(code));
    }
    
    containsDangerousPatterns(code) {
        const dangerousPatterns = [
            /eval\s*\(/,
            /new\s+Function\s*\(/,
            /setTimeout\s*\(\s*["']/,
            /setInterval\s*\(\s*["']/,
            /document\.write\s*\(/,
            /exec\s*\(/,
            /spawn\s*\(/,
            /child_process\./
        ];
        
        return dangerousPatterns.some(pattern => pattern.test(code));
    }
    
    coversAllInputSources(code) {
        // Проверка, что все источники ввода валидируются
        const inputSources = [
            'req.body',
            'req.query', 
            'req.params',
            'req.headers',
            'req.cookies'
        ];
        
        const validatedSources = inputSources.filter(source => 
            new RegExp(`${source}\\s*\\.\\w+`).test(code) && 
            this.isSourceValidated(code, source)
        );
        
        return validatedSources.length === inputSources.length;
    }
    
    isSourceValidated(code, source) {
        // Проверка, что источник ввода проходит валидацию
        const validationCalls = [
            `${source}\\s*\\.validate`,
            `${source}\\s*\\.check`,
            `${source}\\s*\\.sanitize`
        ];
        
        return validationCalls.some(call => new RegExp(call).test(code));
    }
    
    containsOutputEncoding(code) {
        const encodingPatterns = [
            /encode/,
            /escape/,
            /sanitize/,
            /htmlEntities/,
            /htmlspecialchars/,
            /textContent/
        ];
        
        return encodingPatterns.some(pattern => pattern.test(code));
    }
    
    usesContextualOutputEncoding(code) {
        // Проверка использования контекстно-зависимого кодирования
        const contextualEncoding = [
            /encodeHtml/,
            /encodeJavaScript/,
            /encodeCSS/,
            /encodeUrl/,
            /encodeAttribute/
        ];
        
        return contextualEncoding.some(pattern => pattern.test(code));
    }
    
    coversAllOutputDestinations(code) {
        // Проверка, что все места вывода защищены
        const outputMethods = [
            'res.send',
            'res.json',
            'document.innerHTML',
            'document.write',
            'console.log'
        ];
        
        const encodedOutputs = outputMethods.filter(method => 
            new RegExp(method).test(code) && 
            this.isOutputEncoded(code, method)
        );
        
        return encodedOutputs.length === outputMethods.length;
    }
    
    isOutputEncoded(code, outputMethod) {
        const encodingMethods = ['encode', 'escape', 'sanitize'];
        const methodPattern = new RegExp(`${outputMethod}\\s*\\(\\s*(${encodingMethods.join('|')})`);
        
        return methodPattern.test(code);
    }
    
    implementsSecureCookies(code) {
        const secureCookiePattern = /secure\s*:\s*true/;
        return secureCookiePattern.test(code);
    }
    
    implementsHttpOnlyCookies(code) {
        const httpOnlyPattern = /httpOnly\s*:\s*true/;
        return httpOnlyPattern.test(code);
    }
    
    implementsSameSiteProtection(code) {
        const sameSitePattern = /sameSite\s*:\s*['"](strict|lax|none)['"]/;
        return sameSitePattern.test(code);
    }
    
    implementsSessionRegeneration(code) {
        const regenPattern = /regenerate|rotate|change/;
        return regenPattern.test(code) && /session/.test(code);
    }
    
    implementsSessionTimeout(code) {
        const timeoutPattern = /maxAge|timeout|expires/;
        return timeoutPattern.test(code) && /session/.test(code);
    }
    
    implementsProperSessionInvalidation(code) {
        const invalidatePattern = /destroy|clear|logout/;
        return invalidatePattern.test(code) && /session/.test(code);
    }
    
    usesSecurePasswordHashing(code) {
        const secureHashing = /bcrypt|argon2|scrypt/;
        return secureHashing.test(code);
    }
    
    implementsRateLimiting(code) {
        const rateLimitPattern = /rateLimit|throttle|window|count/;
        return rateLimitPattern.test(code);
    }
    
    implementsSecureCredentialStorage(code) {
        const secureStorage = /process\.env|vault|keystore|config/;
        return secureStorage.test(code);
    }
    
    implementsProperLogout(code) {
        const logoutPattern = /logout|invalidate|clearSession/;
        return logoutPattern.test(code);
    }
    
    implementsAccessControls(code) {
        const accessControlPattern = /authorize|permission|role|acl|rbac/;
        return accessControlPattern.test(code);
    }
    
    implementsRoleBasedAccess(code) {
        const rbacPattern = /role|permission|rbac/;
        return rbacPattern.test(code);
    }
    
    implementsLeastPrivilege(code) {
        const leastPrivPattern = /least|minimum|privilege|principle/;
        return leastPrivPattern.test(code);
    }
    
    implementsPermissionValidation(code) {
        const permValidPattern = /validate|check|verify.*permission/;
        return permValidPattern.test(code);
    }
    
    usesGenericErrorMessages(code) {
        const genericErrorPattern = /error.*message.*generic|error.*message.*safe/;
        return genericErrorPattern.test(code);
    }
    
    avoidsStackTraceExposure(code) {
        const stackTracePattern = /stack|trace|error\.stack/;
        const safeErrorPattern = /safe|generic|hide|mask/;
        
        // Проверка, что stack trace не экспортируется напрямую
        return !stackTracePattern.test(code) || 
               (stackTracePattern.test(code) && safeErrorPattern.test(code));
    }
    
    implementsSecureErrorLogging(code) {
        const secureLogPattern = /log.*secure|log.*safe|sanitize.*log/;
        return secureLogPattern.test(code);
    }
    
    implementsGracefulErrorHandling(code) {
        const gracefulPattern = /try\s*{|catch\s*\(|finally|error\.handler|graceful/;
        return gracefulPattern.test(code);
    }
    
    isOverallCompliant(results) {
        return Object.values(results)
            .filter(result => typeof result === 'object' && result.hasOwnProperty('passes'))
            .every(result => result.passes);
    }
    
    async recordPolicyViolation(code, results, context) {
        const violation = {
            id: `violation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date().toISOString(),
            codeSnippet: code.substring(0, 200) + '...', // Обрезаем для безопасности
            violations: this.extractViolations(results),
            context: context,
            severity: this.calculateViolationSeverity(results)
        };
        
        this.violationHistory.push(violation);
        
        // Ограничение истории
        if (this.violationHistory.length > 1000) {
            this.violationHistory = this.violationHistory.slice(-1000);
        }
        
        // Отправка алерта
        await this.sendPolicyViolationAlert(violation);
    }
    
    extractViolations(results) {
        const violations = [];
        
        for (const [policyName, checkResult] of Object.entries(results)) {
            if (typeof checkResult === 'object' && checkResult.passes === false) {
                violations.push({
                    policy: policyName,
                    failedChecks: Object.entries(checkResult)
                        .filter(([, value]) => typeof value === 'boolean' && value === false)
                        .map(([key]) => key)
                });
            }
        }
        
        return violations;
    }
    
    calculateViolationSeverity(results) {
        const failedPolicies = Object.values(results)
            .filter(result => typeof result === 'object' && result.passes === false)
            .length;
        
        if (failedPolicies >= 5) return 'CRITICAL';
        if (failedPolicies >= 3) return 'HIGH';
        if (failedPolicies >= 1) return 'MEDIUM';
        return 'LOW';
    }
    
    async sendPolicyViolationAlert(violation) {
        console.error(`POLICY VIOLATION [${violation.severity}]:`, violation);
        
        // В реальности интеграция с системами уведомлений
        if (process.env.POLICY_VIOLATION_WEBHOOK) {
            try {
                await fetch(process.env.POLICY_VIOLATION_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(violation)
                });
            } catch (error) {
                console.error('Failed to send policy violation alert:', error);
            }
        }
    }
    
    async getPolicyComplianceReport() {
        return {
            timestamp: new Date().toISOString(),
            totalViolations: this.violationHistory.length,
            byPolicy: this.countViolationsByPolicy(),
            bySeverity: this.countViolationsBySeverity(),
            complianceRate: this.calculateComplianceRate(),
            recommendations: this.generatePolicyRecommendations()
        };
    }
    
    countViolationsByPolicy() {
        const counts = {};
        
        for (const violation of this.violationHistory) {
            for (const policyViolation of violation.violations) {
                counts[policyViolation.policy] = (counts[policyViolation.policy] || 0) + 1;
            }
        }
        
        return counts;
    }
    
    countViolationsBySeverity() {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        
        for (const violation of this.violationHistory) {
            counts[violation.severity] = (counts[violation.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    calculateComplianceRate() {
        // Простой расчет - в реальности более сложный
        return this.violationHistory.length > 0 ? 0 : 100; // заглушка
    }
    
    generatePolicyRecommendations() {
        const recommendations = [];
        
        const violationCounts = this.countViolationsByPolicy();
        
        for (const [policy, count] of Object.entries(violationCounts)) {
            if (count > 10) { // больше 10 нарушений
                recommendations.push({
                    priority: 'HIGH',
                    policy: policy,
                    title: `Address ${policy} Policy Violations`,
                    description: `Found ${count} violations of ${policy} policy`,
                    action: `Review and fix ${policy} implementation`
                });
            }
        }
        
        return recommendations;
    }
}

// Использование политики безопасности кода
const codePolicy = new SecureCodePolicy();

async function validateCodeSecurity(code) {
    const results = await codePolicy.validateCodeAgainstPolicy(code);
    const report = await codePolicy.getPolicyComplianceReport();
    
    console.log('Code Security Validation Results:', JSON.stringify(results, null, 2));
    console.log('Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    return { results, report };
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Управление-пакетами]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]