---
aliases: ["Vulnerability Assessment", "Оценка уязвимостей", "Анализ безопасности"]
tags: [security, vulnerability-assessment, risk-assessment, security-testing]
---

# Оценка уязвимостей

## Обзор

Оценка уязвимостей (vulnerability assessment) - это систематический процесс выявления, классификации и анализа уязвимостей в системах, приложениях, сетях и инфраструктуре. Этот процесс помогает организациям понимать свои слабые места и принимать обоснованные решения для улучшения безопасности.

## Различие между оценкой уязвимостей и пенетрационным тестированием

### Оценка уязвимостей

- **Цель**: Идентификация и документирование известных уязвимостей
- **Метод**: Автоматизированные сканеры и базы данных уязвимостей
- **Глубина**: Поверхностный анализ известных проблем
- **Частота**: Может выполняться регулярно (еженедельно, ежемесячно)

### Пенетрационное тестирование

- **Цель**: Имитация реальных атак для оценки реальной безопасности
- **Метод**: Комбинация автоматизированных инструментов и ручного тестирования
- **Глубина**: Глубокий анализ с попытками эксплуатации
- **Частота**: Обычно раз в квартал или раз в полгода

## Процесс оценки уязвимостей

### 1. Планирование и подготовка

```javascript
// Пример плана оценки уязвимостей
const vulnerabilityAssessmentPlan = {
  scope: {
    assets: [
      'Веб-приложения',
      'Мобильные приложения', 
      'API сервисы',
      'Серверы и инфраструктура',
      'Базы данных',
      'Сетевые устройства'
    ],
    inScope: [
      'Продакшн среда',
      'Стейджинг среда',
      'Критические системы'
    ],
    outOfScope: [
      'Локальные разработческие окружения',
      'Тестовые системы',
      'Третьесторонние сервисы'
    ]
  },
  
  methodology: [
    'Automated scanning',
    'Configuration review', 
    'Dependency analysis',
    'Code review',
    'Network mapping'
  ],
  
  timeline: {
    start: '2023-06-01',
    end: '2023-06-30',
    weeklyReports: true
  },
  
  tools: [
    'Nessus',
    'OpenVAS',
    'OWASP ZAP',
    'Burp Suite',
    'npm audit',
    'SonarQube'
  ]
};
```

### 2. Идентификация активов

#### Инвентаризация систем

```javascript
// Система отслеживания активов
class AssetInventory {
  constructor() {
    this.assets = new Map();
  }
  
  addAsset(id, details) {
    this.assets.set(id, {
      ...details,
      id,
      lastScanned: null,
      vulnerabilities: [],
      riskScore: 0
    });
  }
  
  updateAsset(id, updates) {
    const asset = this.assets.get(id);
    if (asset) {
      Object.assign(asset, updates);
      asset.lastUpdated = new Date().toISOString();
    }
  }
  
  getAssetsByRisk(minRisk = 0) {
    return Array.from(this.assets.values())
      .filter(asset => asset.riskScore >= minRisk)
      .sort((a, b) => b.riskScore - a.riskScore);
  }
  
  getAssetsByType(type) {
    return Array.from(this.assets.values())
      .filter(asset => asset.type === type);
  }
}

// Пример использования
const inventory = new AssetInventory();

inventory.addAsset('web-app-001', {
  name: 'Main Web Application',
  type: 'web-application',
  environment: 'production',
  owner: 'web-team',
  criticality: 'high',
  technology: ['Node.js', 'Express', 'PostgreSQL']
});

inventory.addAsset('api-service-002', {
  name: 'User Management API',
  type: 'api-service', 
  environment: 'production',
  owner: 'auth-team',
  criticality: 'critical',
  technology: ['Java', 'Spring Boot', 'MongoDB']
});
```

### 3. Сканирование уязвимостей

#### Автоматизированное сканирование

```javascript
// Система автоматического сканирования
class VulnerabilityScanner {
  constructor() {
    this.scanners = new Map();
    this.scanResults = [];
  }
  
  registerScanner(name, scanner) {
    this.scanners.set(name, scanner);
  }
  
  async scanAsset(assetId, assetDetails) {
    const results = [];
    
    for (const [scannerName, scanner] of this.scanners) {
      try {
        const scannerResults = await scanner.scan(assetDetails);
        results.push({
          scanner: scannerName,
          assetId,
          results: scannerResults,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error(`Ошибка сканирования ${scannerName} для ${assetId}:`, error);
      }
    }
    
    this.scanResults.push(...results);
    return results;
  }
  
  async scanAllAssets(inventory) {
    const assets = Array.from(inventory.assets.values());
    const scanPromises = assets.map(asset => 
      this.scanAsset(asset.id, asset)
    );
    
    return await Promise.all(scanPromises);
  }
}

// Пример сканера зависимости
class DependencyScanner {
  async scan(asset) {
    if (!asset.technology.includes('Node.js')) {
      return { vulnerabilities: [], summary: 'Not applicable' };
    }
    
    // Имитация сканирования зависимостей
    const vulnerabilities = await this.checkDependencies(asset);
    
    return {
      vulnerabilities,
      summary: {
        total: vulnerabilities.length,
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length
      }
    };
  }
  
  async checkDependencies(asset) {
    // В реальном приложении это будет вызов npm audit или другого инструмента
    return [
      {
        id: 'CVE-2023-1234',
        name: 'Prototype Pollution',
        severity: 'high',
        module: 'lodash',
        version: '4.17.20',
        fixedIn: '4.17.21',
        description: 'Prototype pollution vulnerability in lodash'
      },
      {
        id: 'CVE-2023-5678', 
        name: 'Regular Expression Denial of Service',
        severity: 'medium',
        module: 'moment',
        version: '2.29.3',
        fixedIn: '2.29.4',
        description: 'ReDoS vulnerability in moment.js'
      }
    ];
  }
}

// Регистрация сканеров
const scanner = new VulnerabilityScanner();
scanner.registerScanner('dependencies', new DependencyScanner());
```

### 4. Классификация уязвимостей

#### Система классификации CVSS

```javascript
// Система оценки CVSS (Common Vulnerability Scoring System)
class CVSSCalculator {
  static calculateBaseScore(attackVector, attackComplexity, privilegesRequired, 
                           userInteraction, scope, confidentiality, 
                           integrity, availability) {
    
    // Матрица взвешивания для CVSS v3.1
    const weights = {
      AV: { N: 0.85, A: 0.62, L: 0.55, P: 0.2 },
      AC: { L: 0.77, H: 0.44 },
      PR: { N: 0.85, L: 0.62, H: 0.27 }, // для same scope
      UI: { N: 0.85, R: 0.62 },
      S: { U: 6.42, C: 7.52 },
      C: { N: 0, L: 0.22, H: 0.56 },
      I: { N: 0, L: 0.22, H: 0.56 },
      A: { N: 0, L: 0.22, H: 0.56 }
    };
    
    // Оценка вектора атаки
    const avScore = weights.AV[attackVector];
    const acScore = weights.AC[attackComplexity];
    const prScore = weights.PR[privilegesRequired];
    const uiScore = weights.UI[userInteraction];
    
    // Оценка воздействия
    const cScore = weights.C[confidentiality];
    const iScore = weights.I[integrity]; 
    const aScore = weights.A[availability];
    
    // Расчет базовой оценки
    let iss = 1 - ((1 - cScore) * (1 - iScore) * (1 - aScore));
    
    let scopeChanged = scope === 'C';
    let prWeight = scopeChanged ? weights.PR[privilegesRequired] : (privilegesRequired === 'N' ? 0.85 : (privilegesRequired === 'L' ? 0.68 : 0.5));
    
    let impact = scopeChanged ? 7.52 * (iss - 0.029) - 3.25 * Math.pow(iss - 0.02, 15) 
                              : 6.42 * iss;
    
    let exploitability = 8.22 * avScore * acScore * prWeight * uiScore;
    
    let baseScore;
    if (impact <= 0) {
      baseScore = 0;
    } else {
      if (!scopeChanged) {
        baseScore = Math.min(impact + exploitability, 10);
      } else {
        baseScore = Math.min(1.08 * (impact + exploitability), 10);
      }
    }
    
    // Округление до 1 знака после запятой
    return Math.round(baseScore * 10) / 10;
  }
  
  static getSeverity(score) {
    if (score >= 9.0) return 'critical';
    if (score >= 7.0) return 'high';
    if (score >= 4.0) return 'medium';
    if (score > 0.0) return 'low';
    return 'none';
  }
}

// Пример использования
const cvssScore = CVSSCalculator.calculateBaseScore(
  'N', // Network
  'L', // Low
  'N', // None
  'N', // None
  'U', // Unchanged
  'H', // High
  'H', // High
  'H'  // High
);

console.log(`CVSS Score: ${cvssScore}, Severity: ${CVSSCalculator.getSeverity(cvssScore)}`);
```

### 5. Оценка рисков

#### Матрица рисков

```javascript
// Система оценки рисков
class RiskAssessment {
  constructor() {
    this.riskMatrix = {
      'critical': { score: 9, color: 'red', description: 'Немедленное действие требуется' },
      'high': { score: 7, color: 'orange', description: 'Высокий приоритет для исправления' },
      'medium': { score: 4, color: 'yellow', description: 'Средний приоритет' },
      'low': { score: 1, color: 'blue', description: 'Низкий приоритет' },
      'none': { score: 0, color: 'green', description: 'Нет риска' }
    };
  }
  
  calculateRisk(vulnerability, asset) {
    // Базовая оценка из CVSS
    const baseRisk = vulnerability.cvssScore || CVSSCalculator.calculateBaseScore(
      vulnerability.attackVector || 'N',
      vulnerability.attackComplexity || 'L', 
      vulnerability.privilegesRequired || 'N',
      vulnerability.userInteraction || 'N',
      vulnerability.scope || 'U',
      vulnerability.confidentiality || 'N',
      vulnerability.integrity || 'N', 
      vulnerability.availability || 'N'
    );
    
    // Дополнительные факторы риска
    const assetCriticality = this.getAssetCriticalityScore(asset.criticality);
    const exploitability = this.getExploitabilityScore(vulnerability);
    const impact = this.getImpactScore(vulnerability, asset);
    
    // Комбинированная оценка риска
    const riskScore = (baseRisk * 0.5) + (assetCriticality * 0.2) + 
                     (exploitability * 0.2) + (impact * 0.1);
    
    return {
      riskScore: Math.min(10, riskScore),
      severity: CVSSCalculator.getSeverity(riskScore),
      details: {
        baseRisk,
        assetCriticality,
        exploitability,
        impact
      }
    };
  }
  
  getAssetCriticalityScore(criticality) {
    const scores = { critical: 1.0, high: 0.8, medium: 0.6, low: 0.4 };
    return scores[criticality] || 0.5;
  }
  
  getExploitabilityScore(vulnerability) {
    // Оценка на основе доступности эксплойтов
    if (vulnerability.exploitAvailable === 'true') return 1.0;
    if (vulnerability.exploitAvailable === 'proof-of-concept') return 0.7;
    if (vulnerability.exploitAvailable === 'theoretical') return 0.3;
    return 0.5;
  }
  
  getImpactScore(vulnerability, asset) {
    // Оценка на основе типа данных и бизнес-влияния
    let score = 0.5; // базовая оценка
    
    if (asset.dataType && asset.dataType.includes('PII')) score += 0.3; // Персональные данные
    if (asset.dataType && asset.dataType.includes('financial')) score += 0.2; // Финансовые данные
    if (asset.businessCriticality === 'high') score += 0.2; // Высокая бизнес-критичность
    
    return Math.min(1.0, score);
  }
}
```

## Инструменты оценки уязвимостей

### OWASP Dependency Check

```bash
# Установка и запуск OWASP Dependency Check
wget https://github.com/jeremylong/DependencyCheck/releases/latest/download/dependency-check-X.X.X-release.zip
unzip dependency-check-X.X.X-release.zip

# Запуск сканирования
./dependency-check/bin/dependency-check.sh \
  --project "My Application" \
  --scan "/path/to/application" \
  --out "/path/to/reports" \
  --format "ALL" \
  --enableRetired \
  --suppression "/path/to/suppressions.xml"
```

### NPM Audit

```javascript
// Интеграция npm audit в процесс оценки
class NPMAuditScanner {
  async scan(projectPath) {
    const { exec } = require('child_process');
    
    return new Promise((resolve, reject) => {
      exec(`cd ${projectPath} && npm audit --audit-level moderate --json`, 
        (error, stdout, stderr) => {
          if (error) {
            reject(error);
            return;
          }
          
          try {
            const auditResult = JSON.parse(stdout);
            const vulnerabilities = this.parseAuditResult(auditResult);
            
            resolve({
              tool: 'npm-audit',
              vulnerabilities,
              metadata: auditResult.metadata,
              summary: this.createSummary(auditResult.metadata.vulnerabilities)
            });
          } catch (parseError) {
            reject(parseError);
          }
        });
    });
  }
  
  parseAuditResult(auditResult) {
    if (!auditResult.vulnerabilities) return [];
    
    return Object.values(auditResult.vulnerabilities).map(vuln => ({
      id: vuln.id,
      name: vuln.name,
      severity: vuln.severity,
      module: vuln.module_name,
      version: vuln.version,
      vulnerableVersions: vuln.vulnerable_versions,
      patchedVersions: vuln.patched_versions,
      overview: vuln.overview,
      recommendation: vuln.recommendation,
      references: vuln.references
    }));
  }
  
  createSummary(vulnMetadata) {
    return {
      total: vulnMetadata.total,
      critical: vulnMetadata.critical || 0,
      high: vulnMetadata.high || 0,
      moderate: vulnMetadata.moderate || 0,
      low: vulnMetadata.low || 0,
      info: vulnMetadata.info || 0
    };
  }
}
```

### OWASP ZAP для веб-приложений

```javascript
// Автоматизированное сканирование OWASP ZAP
class ZAPScanner {
  constructor(apiKey, targetUrl) {
    this.apiKey = apiKey;
    this.targetUrl = targetUrl;
    this.zapApiUrl = 'http://localhost:8080';
  }
  
  async performSpidering() {
    const response = await fetch(
      `${this.zapApiUrl}/JSON/spider/action/scan/?apikey=${this.apiKey}&url=${encodeURIComponent(this.targetUrl)}`
    );
    const result = await response.json();
    return result.scan;
  }
  
  async waitForSpiderCompletion(scanId) {
    let status = 0;
    while (status < 100) {
      const response = await fetch(
        `${this.zapApiUrl}/JSON/spider/view/status/?apikey=${this.apiKey}&scanId=${scanId}`
      );
      const result = await response.json();
      status = parseInt(result.status);
      await new Promise(resolve => setTimeout(resolve, 5000)); // ждем 5 секунд
    }
  }
  
  async performActiveScan() {
    const response = await fetch(
      `${this.zapApiUrl}/JSON/ascan/action/scan/?apikey=${this.apiKey}&url=${encodeURIComponent(this.targetUrl)}`
    );
    const result = await response.json();
    return result.scan;
  }
  
  async waitForScanCompletion(scanId) {
    let status = 0;
    while (status < 100) {
      const response = await fetch(
        `${this.zapApiUrl}/JSON/ascan/view/status/?apikey=${this.apiKey}&scanId=${scanId}`
      );
      const result = await response.json();
      status = parseInt(result.status);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
  
  async getAlerts() {
    const response = await fetch(
      `${this.zapApiUrl}/JSON/core/view/alerts/?apikey=${this.apiKey}&baseurl=${encodeURIComponent(this.targetUrl)}`
    );
    const result = await response.json();
    return result.alerts;
  }
  
  async fullScan() {
    console.log('Запуск спайдеринга...');
    const spiderId = await this.performSpidering();
    await this.waitForSpiderCompletion(spiderId);
    
    console.log('Запуск активного сканирования...');
    const scanId = await this.performActiveScan();
    await this.waitForScanCompletion(scanId);
    
    console.log('Получение результатов...');
    const alerts = await this.getAlerts();
    
    return {
      alerts: this.processAlerts(alerts),
      summary: this.createAlertSummary(alerts)
    };
  }
  
  processAlerts(alerts) {
    return alerts.map(alert => ({
      id: alert.id,
      alert: alert.alert,
      name: alert.name,
      risk: alert.risk,
      confidence: alert.confidence,
      description: alert.description,
      solution: alert.solution,
      url: alert.url,
      param: alert.param,
      attack: alert.attack,
      evidence: alert.evidence,
      cweid: alert.cweid,
      wascid: alert.wascid
    }));
  }
  
  createAlertSummary(alerts) {
    const summary = {
      total: alerts.length,
      high: 0,
      medium: 0, 
      low: 0,
      info: 0
    };
    
    for (const alert of alerts) {
      switch(alert.risk) {
        case 'High': summary.high++; break;
        case 'Medium': summary.medium++; break;
        case 'Low': summary.low++; break;
        case 'Informational': summary.info++; break;
      }
    }
    
    return summary;
  }
}
```

## Создание отчетов по уязвимостям

### Структура отчета

```javascript
// Генератор отчетов по уязвимостям
class VulnerabilityReportGenerator {
  constructor() {
    this.template = this.loadReportTemplate();
  }
  
  generateReport(assessmentResults, inventory) {
    const report = {
      metadata: {
        timestamp: new Date().toISOString(),
        assessor: process.env.USER || 'system',
        scope: this.getAssessmentScope(assessmentResults),
        toolsUsed: this.getToolsUsed(assessmentResults)
      },
      
      executiveSummary: this.createExecutiveSummary(assessmentResults),
      
      findings: this.categorizeFindings(assessmentResults),
      
      riskAnalysis: this.performRiskAnalysis(assessmentResults, inventory),
      
      recommendations: this.generateRecommendations(assessmentResults),
      
      appendix: {
        rawData: assessmentResults,
        methodology: 'Automated and manual assessment',
        limitations: this.identifyLimitations(assessmentResults)
      }
    };
    
    return report;
  }
  
  createExecutiveSummary(results) {
    const totalVulnerabilities = results.flatMap(r => r.vulnerabilities || []).length;
    const criticalVulns = results.flatMap(r => r.vulnerabilities || [])
      .filter(v => v.severity === 'critical').length;
    const highVulns = results.flatMap(r => r.vulnerabilities || [])
      .filter(v => v.severity === 'high').length;
    
    return {
      totalVulnerabilities,
      criticalVulnerabilities: criticalVulns,
      highVulnerabilities: highVulns,
      affectedAssets: new Set(results.map(r => r.assetId)).size,
      overallRiskLevel: this.calculateOverallRisk(criticalVulns, highVulns),
      keyFindings: this.extractKeyFindings(results)
    };
  }
  
  calculateOverallRisk(critical, high) {
    if (critical > 0) return 'critical';
    if (high > 5) return 'high';
    if (high > 0) return 'medium';
    return 'low';
  }
  
  extractKeyFindings(results) {
    const allVulns = results.flatMap(r => r.vulnerabilities || []);
    const topVulns = allVulns
      .filter(v => v.severity === 'critical' || v.severity === 'high')
      .sort((a, b) => this.getSeverityScore(b.severity) - this.getSeverityScore(a.severity))
      .slice(0, 5); // Топ-5 критических уязвимостей
    
    return topVulns.map(v => ({
      title: v.name || v.title,
      severity: v.severity,
      affectedAsset: v.assetId,
      cvssScore: v.cvssScore
    }));
  }
  
  getSeverityScore(severity) {
    const scores = { critical: 4, high: 3, medium: 2, low: 1 };
    return scores[severity] || 0;
  }
  
  categorizeFindings(results) {
    const categorized = {
      bySeverity: {},
      byType: {},
      byAsset: {}
    };
    
    for (const result of results) {
      for (const vuln of result.vulnerabilities || []) {
        // По критичности
        categorized.bySeverity[vuln.severity] = categorized.bySeverity[vuln.severity] || 0;
        categorized.bySeverity[vuln.severity]++;
        
        // По типу
        const vulnType = vuln.type || 'unknown';
        categorized.byType[vulnType] = categorized.byType[vulnType] || 0;
        categorized.byType[vulnType]++;
        
        // По активу
        categorized.byAsset[result.assetId] = categorized.byAsset[result.assetId] || [];
        categorized.byAsset[result.assetId].push(vuln);
      }
    }
    
    return categorized;
  }
  
  performRiskAnalysis(results, inventory) {
    const riskAssessment = new RiskAssessment();
    const analysis = {
      overallRiskScore: 0,
      riskDistribution: {},
      businessImpact: this.assessBusinessImpact(results, inventory),
      remediationPriorities: this.determinePriorities(results, inventory)
    };
    
    let totalRisk = 0;
    let count = 0;
    
    for (const result of results) {
      const asset = inventory.assets.get(result.assetId);
      for (const vuln of result.vulnerabilities || []) {
        const risk = riskAssessment.calculateRisk(vuln, asset);
        totalRisk += risk.riskScore;
        count++;
        
        analysis.riskDistribution[risk.severity] = analysis.riskDistribution[risk.severity] || 0;
        analysis.riskDistribution[risk.severity]++;
      }
    }
    
    analysis.overallRiskScore = count > 0 ? totalRisk / count : 0;
    return analysis;
  }
  
  assessBusinessImpact(results, inventory) {
    // Оценка бизнес-влияния уязвимостей
    const impact = {
      financial: 0,
      operational: 0, 
      reputational: 0,
      compliance: 0
    };
    
    for (const result of results) {
      const asset = inventory.assets.get(result.assetId);
      if (asset.businessCriticality === 'critical') {
        impact.operational += 3;
        if (asset.dataType && asset.dataType.includes('PII')) {
          impact.reputational += 2;
          impact.compliance += 2;
        }
      }
    }
    
    return impact;
  }
  
  determinePriorities(results, inventory) {
    // Определение приоритетов устранения
    const priorities = [];
    
    for (const result of results) {
      const asset = inventory.assets.get(result.assetId);
      for (const vuln of result.vulnerabilities || []) {
        const risk = new RiskAssessment().calculateRisk(vuln, asset);
        
        priorities.push({
          vulnerability: vuln,
          asset: asset,
          riskScore: risk.riskScore,
          priority: this.calculatePriority(risk.riskScore, vuln.exploitability || 'unknown'),
          estimatedEffort: this.estimateRemediationEffort(vuln.type || 'unknown'),
          deadline: this.calculateDeadline(risk.severity)
        });
      }
    }
    
    return priorities
      .sort((a, b) => b.riskScore - a.riskScore)
      .slice(0, 20); // Топ-20 приоритетов
  }
  
  calculatePriority(riskScore, exploitability) {
    let priority = riskScore;
    
    // Повышаем приоритет для легко эксплуатируемых уязвимостей
    if (exploitability === 'high') priority += 1;
    if (exploitability === 'medium') priority += 0.5;
    
    if (priority >= 9) return 'critical';
    if (priority >= 7) return 'high';
    if (priority >= 4) return 'medium';
    return 'low';
  }
  
  estimateRemediationEffort(vulnType) {
    const effortEstimates = {
      'dependency-update': 'low',
      'configuration-issue': 'low', 
      'code-vulnerability': 'medium',
      'design-flaw': 'high',
      'architecture-issue': 'high'
    };
    
    return effortEstimates[vulnType] || 'medium';
  }
  
  calculateDeadline(severity) {
    const deadlines = {
      critical: '24 hours',
      high: '7 days',
      medium: '30 days', 
      low: '90 days'
    };
    
    return deadlines[severity] || '30 days';
  }
  
  generateRecommendations(results) {
    const recommendations = {
      immediate: [],
      shortTerm: [],
      longTerm: [],
      policy: []
    };
    
    // Анализ результатов для генерации рекомендаций
    const allVulns = results.flatMap(r => r.vulnerabilities || []);
    const commonTypes = this.getCommonVulnerabilityTypes(allVulns);
    
    // Рекомендации на основе типов уязвимостей
    for (const [type, count] of Object.entries(commonTypes)) {
      if (count > 3) { // Если тип встречается более 3 раз
        recommendations.immediate.push(this.getRecommendationForType(type));
      }
    }
    
    // Общие рекомендации
    recommendations.policy.push(
      'Внедрить автоматизированные сканеры безопасности в CI/CD пайплайн',
      'Регулярно обновлять зависимости и следить за уязвимостями',
      'Проводить обучение разработчиков по безопасному программированию'
    );
    
    return recommendations;
  }
  
  getCommonVulnerabilityTypes(vulnerabilities) {
    const counts = {};
    for (const vuln of vulnerabilities) {
      const type = vuln.type || 'unknown';
      counts[type] = (counts[type] || 0) + 1;
    }
    return counts;
  }
  
  getRecommendationForType(type) {
    const recommendations = {
      'dependency-vulnerability': 'Немедленно обновить уязвимые зависимости до безопасных версий',
      'misconfiguration': 'Проверить и исправить конфигурацию безопасности',
      'input-validation': 'Внедрить надежную проверку и санитизацию входных данных',
      'authentication': 'Усилить механизм аутентификации и авторизации',
      'authorization': 'Проверить и улучшить механизм авторизации'
    };
    
    return recommendations[type] || `Провести анализ и устранение уязвимости типа: ${type}`;
  }
  
  identifyLimitations(results) {
    return [
      'Оценка основана на автоматизированных инструментах и может не выявить всех уязвимостей',
      'Некоторые уязвимости требуют ручной проверки для подтверждения',
      'Оценка не включает социальную инженерию или физические атаки'
    ];
  }
  
  async saveReport(report, filename = null) {
    const fs = require('fs').promises;
    
    const reportFilename = filename || `vulnerability-assessment-${new Date().toISOString().split('T')[0]}.json`;
    await fs.writeFile(reportFilename, JSON.stringify(report, null, 2));
    
    console.log(`Отчет сохранен: ${reportFilename}`);
    return reportFilename;
  }
}

// Пример использования
async function performVulnerabilityAssessment() {
  const inventory = new AssetInventory();
  const scanner = new VulnerabilityScanner();
  const reportGenerator = new VulnerabilityReportGenerator();
  
  // Добавляем активы
  inventory.addAsset('web-app-001', {
    name: 'Main Web Application',
    type: 'web-application',
    environment: 'production', 
    criticality: 'high',
    dataType: ['PII', 'financial'],
    businessCriticality: 'high'
  });
  
  // Выполняем сканирование
  await scanner.scanAllAssets(inventory);
  
  // Генерируем отчет
  const report = reportGenerator.generateReport(scanner.scanResults, inventory);
  
  // Сохраняем отчет
  await reportGenerator.saveReport(report);
  
  return report;
}
```

## Лучшие практики оценки уязвимостей

### 1. Регулярное выполнение

```javascript
// Планировщик оценки уязвимостей
class VulnerabilityAssessmentScheduler {
  constructor() {
    this.schedule = new Map();
  }
  
  scheduleAssessment(assetId, frequency, callback) {
    // frequency: daily, weekly, monthly, quarterly
    const interval = this.getIntervalFromFrequency(frequency);
    
    const intervalId = setInterval(async () => {
      try {
        await callback(assetId);
      } catch (error) {
        console.error(`Ошибка при оценке уязвимостей для ${assetId}:`, error);
      }
    }, interval);
    
    this.schedule.set(assetId, { intervalId, frequency });
  }
  
  getIntervalFromFrequency(frequency) {
    const intervals = {
      daily: 24 * 60 * 60 * 1000,
      weekly: 7 * 24 * 60 * 60 * 1000,
      monthly: 30 * 24 * 60 * 60 * 1000,
      quarterly: 3 * 30 * 24 * 60 * 60 * 1000
    };
    
    return intervals[frequency] || intervals.weekly;
  }
  
  cancelAssessment(assetId) {
    const scheduleItem = this.schedule.get(assetId);
    if (scheduleItem) {
      clearInterval(scheduleItem.intervalId);
      this.schedule.delete(assetId);
    }
  }
}
```

### 2. Интеграция с системами управления задачами

```javascript
// Интеграция с Jira для отслеживания уязвимостей
class VulnerabilityTracker {
  constructor(jiraConfig) {
    this.jiraConfig = jiraConfig;
  }
  
  async createVulnerabilityTicket(vulnerability) {
    const issue = {
      fields: {
        project: { key: this.jiraConfig.projectKey },
        summary: `Уязвимость: ${vulnerability.name}`,
        description: vulnerability.description || vulnerability.overview,
        issuetype: { name: 'Bug' },
        priority: { name: this.mapSeverityToPriority(vulnerability.severity) },
        labels: ['security', 'vulnerability', `cvss-${vulnerability.cvssScore || 'unknown'}`],
        customfield_10000: vulnerability.id, // внешний ID уязвимости
        customfield_10001: vulnerability.severity,
        customfield_10002: vulnerability.cvssScore
      }
    };
    
    // Отправка в Jira
    const response = await fetch(`${this.jiraConfig.baseUrl}/rest/api/3/issue`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Basic ${btoa(`${this.jiraConfig.username}:${this.jiraConfig.apiToken}`)}`
      },
      body: JSON.stringify(issue)
    });
    
    return response.json();
  }
  
  mapSeverityToPriority(severity) {
    const priorityMap = {
      critical: 'Highest',
      high: 'High', 
      medium: 'Medium',
      low: 'Low'
    };
    
    return priorityMap[severity] || 'Medium';
  }
}
```

## Заключение

Оценка уязвимостей - важный процесс, который помогает организациям выявлять и устранять слабые места в системах безопасности. Эффективная оценка требует комбинации автоматизированных инструментов, ручного анализа и системного подхода к управлению найденными уязвимостями. Регулярное выполнение оценки, правильная классификация и приоритизация уязвимостей позволяют сосредоточиться на наиболее критических проблемах и эффективно использовать ресурсы на их устранение.

## Связанные темы

- [[Методы-тестирования-безопасности]]
- [[Автоматизированное-тестирование-безопасности]]
- [[Инструменты-аудита-безопасности]]
- [[Проверка-ввода]]
- [[Кодирование-вывода]]
- [[Руководство-по-безопасному-коду]]