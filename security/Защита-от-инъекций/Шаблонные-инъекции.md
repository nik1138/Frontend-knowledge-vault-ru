---
aliases: ["Шаблонные инъекции", "Template Injection", "Server-Side Template Injection", "SSTI"]
tags: [security, injection, template]
created: 2025-11-18
updated: 2025-11-18
---

# Шаблонные инъекции

Шаблонные инъекции (Template Injection) - это уязвимость, при которой злоумышленник может внедрить вредоносный шаблон в систему обработки шаблонов, что позволяет выполнить произвольный код или получить доступ к внутренним данным приложения.

## Введение

Шаблонные инъекции происходят, когда приложение позволяет пользователю контролировать часть шаблона, который затем обрабатывается движком шаблонов. В отличие от других видов инъекций, шаблонные инъекции позволяют злоумышленнику использовать функции шаблонизатора для выполнения вредоносных действий.

## Типы шаблонных инъекций

### Server-Side Template Injection (SSTI)

Шаблон обрабатывается на сервере:

- Выполнение произвольного кода на сервере
- Доступ к внутренним данным приложения
- Компрометация сервера
- Утечка конфиденциальной информации

### Client-Side Template Injection (CSTI)

Шаблон обрабатывается на клиенте:

- Выполнение JavaScript в браузере
- Перехват сессий пользователей
- Подделка запросов
- Кража cookies и токенов

## Механизм атаки

### Принцип работы SSTI

1. Приложение принимает пользовательский ввод
2. Ввод используется в шаблоне без должной обработки
3. Шаблон обрабатывается движком шаблонов
4. Вредоносный код выполняется в контексте сервера

### Примеры вредоносных шаблонов

#### Jinja2 (Python)

```jinja2
{{ 7*7 }}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("id").read()}}{% endif %}{% endfor %}
```

#### Twig (PHP)

```twig
{{ dump(app) }}
{{ app.request.server.all|join(', ') }}
```

#### Freemarker (Java)

```freemarker
<#assign ex = "freemarker.template.utility.Execute"?new()>${ ex("id") }
```

#### Handlebars (JavaScript)

```handlebars
{{#with "s" as |string|}}
  {{#with "e"}}
    {{#with split as |conslist|}}
      {{this.pop}}
      {{#each conslist.slice(0,7)}}
        {{pop}} {{#with bind}} {{#each split}} {{#with "c"}} {{pop}} {{/with}} {{/each}} {{/with}} {{/each}}
      {{/with}}
    {{/with}}
  {{/with}}
{{/with}}
```

## Распространенные шаблонизаторы и уязвимости

### Jinja2 (Python)

Используется в Flask и других Python-фреймворках:

```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/hello')
def hello():
    name = request.args.get('name', 'World')
    # Уязвимость: пользовательский ввод в шаблон
    template = f'Hello {name}!'
    return render_template_string(template)
```

### Twig (PHP)

Используется в Symfony и других PHP-фреймворках:

```php
// Уязвимый код
$template = $twig->createTemplate($userInput);
echo $template->render();
```

### Freemarker (Java)

Используется в Spring и других Java-фреймворках:

```java
// Уязвимый код
Template template = new Template("name", new StringReader(userInput), cfg);
```

### Handlebars (JavaScript)

Используется в Node.js приложениях:

```javascript
// Уязвимый код
const template = Handlebars.compile(userInput);
const result = template(context);
```

## Последствия атак

### Выполнение произвольного кода

- Запуск системных команд
- Установка вредоносного ПО
- Изменение конфигурации системы
- Доступ к файловой системе

### Утечка данных

- Доступ к внутренним переменным шаблона
- Чтение конфиденциальных данных
- Кража учетных данных
- Дамп конфигурации приложения

### Компрометация сервера

- Получение root-прав
- Установка backdoor
- Контроль над сервером
- Использование сервера для атак на другие системы

## Методы обнаружения

### Автоматизированные инструменты

- Tplmap
- Commix
- Wapiti
- Burp Suite с плагинами

### Ручное тестирование

#### Базовые тесты

Попробовать простые выражения:

```
{{7*7}}
${7*7}
<%= 7*7 %>
#{7*7}
```

#### Проверка функций

Проверить доступ к системным функциям:

```
{{config.items()}}
{{self.__class__.__mro__[1].__subclasses__()}}
{{app.request.query_string}}
```

### Анализ ответов

- Изменение поведения приложения
- Нестандартные ответы
- Ошибки шаблонизатора
- Неожиданные данные в ответе

## Методы защиты

### Избегание динамических шаблонов

Не использовать пользовательский ввод в шаблонах:

```python
# ПЛОХО
@app.route('/hello')
def hello():
    name = request.args.get('name', 'World')
    template = f'Hello {name}!'
    return render_template_string(template)

# ХОРОШО
@app.route('/hello')
def hello():
    name = request.args.get('name', 'World')
    # Санитизация и проверка
    safe_name = sanitize_input(name)
    return render_template('hello.html', name=safe_name)
```

### Санитизация пользовательского ввода

```python
import html
import re

def sanitize_input(input_str):
    # Экранирование HTML
    escaped = html.escape(input_str)
    
    # Удаление потенциально опасных символов
    sanitized = re.sub(r'[{}<>"\']', '', escaped)
    
    return sanitized
```

### Использование белых списков

```python
# Проверка ввода по белому списку
ALLOWED_VARIABLES = ['name', 'email', 'date']

def validate_template_input(input_str):
    # Проверка, что ввод содержит только разрешенные переменные
    for var in ALLOWED_VARIABLES:
        if f'{{{var}}}' not in input_str and var in input_str:
            raise ValueError(f"Variable {var} not allowed in template")
    return input_str
```

### Ограничение функций шаблонизатора

```python
# Ограничение доступных функций в Jinja2
from jinja2.sandbox import SandboxedEnvironment

def create_sandboxed_template(template_str, context):
    env = SandboxedEnvironment()
    template = env.from_string(template_str)
    return template.render(context)
```

### Правила безопасности для шаблонизаторов

#### Jinja2

```python
from jinja2.sandbox import SandboxedEnvironment
from jinja2 import Template

# Использование песочницы
def safe_render(template_str, context):
    env = SandboxedEnvironment()
    template = env.from_string(template_str)
    return template.render(context)
```

#### Freemarker

```java
// Ограничение доступа к опасным классам
Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
```

## Практические примеры защиты

### Защита в Flask (Python)

```python
from flask import Flask, request, render_template
from jinja2.sandbox import SandboxedEnvironment
import html
import re

app = Flask(__name__)

def validate_template_content(content):
    """Проверка содержимого шаблона"""
    dangerous_patterns = [
        r'\b(__class__|__mro__|__subclasses__)\b',
        r'\b(request|config|session|g)\b',
        r'[{}<>"\']{3,}'  # Последовательности потенциально опасных символов
    ]
    
    for pattern in dangerous_patterns:
        if re.search(pattern, content, re.IGNORECASE):
            raise ValueError("Dangerous pattern detected in template")
    
    return True

def safe_template_render(template_content, context):
    """Безопасный рендеринг шаблона"""
    validate_template_content(template_content)
    
    # Использование песочницы
    env = SandboxedEnvironment()
    template = env.from_string(template_content)
    return template.render(context)

@app.route('/dynamic')
def dynamic():
    template_input = request.args.get('template', '')
    user_data = request.args.get('data', '')
    
    # Проверка и санитизация
    if not template_input or not user_data:
        return "Missing parameters", 400
    
    # Ограничение длины
    if len(template_input) > 1000:
        return "Template too long", 400
    
    try:
        # Безопасный рендеринг
        result = safe_template_render(template_input, {'data': user_data})
        return result
    except Exception as e:
        return f"Error rendering template: {str(e)}", 400
```

### Защита в Node.js с Handlebars

```javascript
const Handlebars = require('handlebars');

// Ограничение доступа к опасным функциям
function createSecureTemplate(templateStr) {
  // Белый список разрешенных помощников
  const allowedHelpers = ['if', 'unless', 'each', 'with', 'log'];
  
  // Проверка шаблона на наличие запрещенных конструкций
  const dangerousPatterns = [
    /constructor/g,
    /__proto__/g,
    /prototype/g,
    /import/g,
    /require/g,
    /eval/g,
    /Function/g
  ];
  
  for (const pattern of dangerousPatterns) {
    if (pattern.test(templateStr)) {
      throw new Error('Dangerous pattern detected in template');
    }
  }
  
  // Создание безопасного шаблона
  const template = Handlebars.compile(templateStr, {
    noEscape: true,  // Отключить автоматическое экранирование
    strict: true     // Строгий режим
  });
  
  return template;
}
```

### Защита в Java с Freemarker

```java
import freemarker.core.TemplateClassResolver;
import freemarker.template.Configuration;
import freemarker.template.Template;

public class SecureTemplateProcessor {
    private Configuration config;
    
    public SecureTemplateProcessor() {
        config = new Configuration(Configuration.VERSION_2_3_31);
        
        // Установка безопасного резолвера классов
        config.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
        
        // Отключение опасных настроек
        config.setClassicCompatible(false);
        config.setLogTemplateExceptions(false);
        config.setWrapUncheckedExceptions(true);
    }
    
    public String processTemplate(String templateContent, Map<String, Object> data) 
            throws Exception {
        
        // Проверка содержимого шаблона
        validateTemplateContent(templateContent);
        
        // Создание и обработка шаблона
        java.io.StringReader reader = new java.io.StringReader(templateContent);
        Template template = new Template("secure", reader, config);
        
        java.io.StringWriter writer = new java.io.StringWriter();
        template.process(data, writer);
        
        return writer.toString();
    }
    
    private void validateTemplateContent(String content) {
        // Проверка на наличие опасных паттернов
        String[] dangerousPatterns = {
            "exec", "process", "runtime", "class", "new", 
            "import", "include", "ftl", "setting"
        };
        
        String lowerContent = content.toLowerCase();
        for (String pattern : dangerousPatterns) {
            if (lowerContent.contains(pattern)) {
                throw new SecurityException("Dangerous pattern detected in template");
            }
        }
    }
}
```

## Лучшие практики

### Проектирование безопасных шаблонов

- Избегать динамических шаблонов
- Использовать предопределенные шаблоны
- Санитизация пользовательского ввода
- Валидация перед вставкой в шаблон

### Использование песочниц

- Ограничение доступных функций
- Белые списки разрешенных операций
- Изоляция выполнения шаблонов
- Мониторинг выполнения

### Мониторинг и аудит

- [[Анализ-логов]] обработки шаблонов
- [[Сигнализация-безопасности]] для подозрительных шаблонов
- Регулярный аудит шаблонов
- [[Инструменты-мониторинга-безопасности]]

## Тестирование на уязвимости

### Автоматизированные тесты

- Использование инструментов статического анализа
- Проверка шаблонов в CI/CD
- Тестирование с вредоносными шаблонами
- Проверка обработки ошибок

### Ручное тестирование

- Тестирование с различными шаблонными выражениями
- Проверка обработки специальных символов
- Анализ поведения при вводе потенциально опасных данных
- Тестирование граничных условий

> [!tip] Совет
> Используйте предопределенные шаблоны вместо динамических, когда это возможно.

> [!warning] Важно
> Никогда не передавайте пользовательский ввод напрямую в шаблонизатор без тщательной проверки.

## Заключение

Шаблонные инъекции представляют серьезную угрозу безопасности приложений, особенно веб-приложений. Для предотвращения таких уязвимостей необходимо использовать безопасные методы обработки шаблонов, избегать динамических шаблонов и применять принципы безопасного программирования.