---
aliases: [SQL Injection, SQL-инъекция, Защита от SQL-инъекций]
tags: [security, web-security, sql-injection, secure-coding, backend-security]
---

# SQL-инъекции

## Введение в SQL-инъекции

SQL-инъекция (SQL injection) — это тип уязвимости веб-приложений, при котором злоумышленник может вмешиваться в работу базы данных, внедряя вредоносный SQL-код через пользовательский ввод. Это одна из наиболее опасных и распространенных уязвимостей в веб-безопасности, которая может привести к краже данных, изменению информации в базе данных или даже полному компрометированию системы.

SQL-инъекции возникают, когда приложение неадекватно обрабатывает пользовательский ввод перед его использованием в SQL-запросах. Злоумышленник может манипулировать SQL-запросами, чтобы обойти аутентификацию, получить доступ к конфиденциальным данным или выполнить произвольные команды в базе данных.

> [!note] Важно
> SQL-инъекции могут возникать в любом месте, где пользовательский ввод используется в SQL-запросе без надлежащей проверки и экранирования.

## Как работают SQL-инъекции

SQL-инъекции работают за счет внедрения вредоносного SQL-кода в параметры, передаваемые в базу данных. Злоумышленник может использовать специальные символы и синтаксис SQL, чтобы изменить логику исходного запроса.

Обычно SQL-инъекции происходят в следующих сценариях:
- Веб-формы аутентификации
- Поисковые формы
- URL-параметры
- Заголовки HTTP
- Cookie

Когда приложение формирует SQL-запрос, объединяя пользовательский ввод с SQL-кодом, без надлежащей проверки, злоумышленник может ввести специальные символы, такие как одинарная кавычка (`'`), точка с запятой (`;`), или логические операторы (`AND`, `OR`), чтобы изменить структуру запроса.

Пример уязвимого запроса:
```sql
SELECT * FROM users WHERE username = 'admin' AND password = 'user_input'
```

Если пользователь введет в поле пароля: `' OR '1'='1`, запрос станет:
```sql
SELECT * FROM users WHERE username = 'admin' AND password = '' OR '1'='1'
```

Этот запрос вернет все записи из таблицы пользователей, поскольку `'1'='1'` всегда истинно.

## Типы SQL-инъекций

Существует несколько типов SQL-инъекций, различающихся по способу внедрения и извлечения данных:

### 1. Временная (In-Band) SQL-инъекция

Это наиболее распространенный тип, при котором злоумышленник использует тот же канал связи для внедрения и получения результатов. Включает:

- **Error-based SQL injection**: Использует сообщения об ошибках для получения информации о структуре базы данных.
- **Union-based SQL injection**: Использует оператор UNION для объединения результатов исходного запроса с результатами, сформированными злоумышленником.

### 2. Контрастная (Blind) SQL-инъекция

При этом типе инъекции злоумышленник не получает прямой ответ от базы данных. Вместо этого он делает предположения и наблюдает за реакцией приложения:

- **Boolean-based (content-based) SQL injection**: Злоумышленник отправляет логические запросы и анализирует, возвращается ли правильный или неправильный контент.
- **Time-based SQL injection**: Злоумышленник отправляет запросы, которые заставляют базу данных ждать перед ответом, чтобы определить, является ли условие истинным или ложным.

### 3. Внешняя (Out-of-Band) SQL-инъекция

Этот тип инъекции зависит от функций, доступных в базе данных, и возможности установления соединения с внешними системами. Злоумышленник может использовать эту технику для передачи данных напрямую на сервер, контролируемый им.

## Примеры SQL-инъекций

### Пример 1: Простая аутентификационная обходная инъекция

Предположим, у нас есть форма входа с SQL-запросом:
```sql
SELECT * FROM users WHERE username = '$username' AND password = '$password'
```

Если злоумышленник введет в поле имени пользователя `' OR '1'='1` и в поле пароля `' OR '1'='1`, то результирующий запрос будет:
```sql
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '' OR '1'='1'
```

Это приведет к аутентификации без знания реальных учетных данных.

### Пример 2: UNION-инъекция

Злоумышленник может использовать UNION для извлечения данных из других таблиц. Например:
```
' UNION SELECT username, password FROM admin --
```

Этот запрос может извлечь учетные данные администратора, если структура таблиц совместима.

### Пример 3: Time-based инъекция

Злоумышленник может использовать задержки для определения информации:
```
admin' AND (SELECT SLEEP(5)) --
```

Если страница загружается с задержкой в 5 секунд, это указывает на уязвимость.

## Последствия атак

SQL-инъекции могут иметь катастрофические последствия:

- **Кража конфиденциальных данных**: Злоумышленник может получить доступ к паролям, персональным данным, финансовой информации.
- **Изменение или удаление данных**: Злоумышленник может изменить или удалить важные данные в базе данных.
- **Повышение привилегий**: Злоумышленник может получить доступ к административным функциям.
- **Полный компромет системы**: В некоторых случаях можно получить доступ к операционной системе сервера.
- **Репутационные потери**: Утечка данных может серьезно повредить репутации компании.
- **Финансовые потери**: Злоумышленник может украсть деньги или данные для мошенничества.

## Методы обнаружения

### Автоматизированные инструменты

- **SQLMap**: Инструмент для автоматического обнаружения и эксплуатации SQL-инъекций
- **OWASP ZAP**: Веб-сканер уязвимостей
- **Burp Suite**: Комплексный инструмент для тестирования безопасности веб-приложений

### Ручное тестирование

- Проверка полей ввода на внедрение специальных символов
- Анализ сообщений об ошибках
- Использование логических операторов для проверки уязвимости
- Тестирование с помощью UNION-запросов

### Мониторинг и логирование

- Анализ логов приложений на наличие подозрительных запросов
- Мониторинг аномалий в поведении базы данных
- Использование систем обнаружения вторжений (IDS)

## Способы предотвращения

### 1. Использование подготовленных выражений

Самый эффективный способ предотвратить SQL-инъекции — использовать подготовленные выражения (prepared statements) с параметрами. Это гарантирует, что пользовательский ввод обрабатывается как данные, а не как часть SQL-команды.

### 2. Проверка и фильтрация ввода

- Проверка типа данных
- Ограничение длины ввода
- Использование белых списков для допустимых значений

### 3. Экранирование специальных символов

- Использование функций экранирования, предоставляемых СУБД
- Ручное экранирование специальных символов

### 4. Ограничение привилегий

- Использование аккаунтов с минимальными привилегиями для подключения к базе данных
- Разграничение доступа к таблицам и процедурам

### 5. Валидация и санитизация

- Валидация данных на стороне сервера
- Санитизация ввода перед использованием

## Подготовленные выражения

Подготовленные выражения (prepared statements) — это заранее скомпилированные SQL-запросы, в которые можно безопасно вставлять параметры. Это предотвращает SQL-инъекции, потому что параметры обрабатываются отдельно от SQL-кода.

Пример на PHP:
```php
$stmt = $pdo->prepare("SELECT * FROM users WHERE email = ?");
$stmt->execute([$email]);
$user = $stmt->fetch();
```

Пример на Python (с использованием psycopg2):
```python
cursor.execute("SELECT * FROM users WHERE email = %s", (email,))
```

Пример на Java (с использованием JDBC):
```java
PreparedStatement stmt = connection.prepareStatement("SELECT * FROM users WHERE email = ?");
stmt.setString(1, email);
ResultSet rs = stmt.executeQuery();
```

### Преимущества подготовленных выражений

- **Безопасность**: Предотвращают SQL-инъекции
- **Производительность**: Запросы могут быть повторно использованы
- **Читаемость**: Код становится более понятным

## Параметризованные запросы

Параметризованные запросы — это метод, при котором SQL-запрос и данные передаются отдельно. Это позволяет базе данных различать SQL-код и пользовательские данные, предотвращая интерпретацию пользовательского ввода как части SQL-команды.

### Особенности параметризованных запросов

- Параметры указываются в виде заполнителей (`?`, `@parameter`, `$1`)
- Значения параметров передаются отдельно от SQL-запроса
- Параметры автоматически экранируются базой данных

### Примеры на разных языках

**C# (.NET)**:
```csharp
string sql = "SELECT * FROM Users WHERE Email = @email";
using (SqlCommand cmd = new SqlCommand(sql, connection))
{
    cmd.Parameters.AddWithValue("@email", userInput);
    // выполнение запроса
}
```

**Node.js (с использованием mysql2)**:
```javascript
const sql = 'SELECT * FROM users WHERE email = ?';
connection.execute(sql, [userEmail], (err, results) => {
    // обработка результата
});
```

**Python (с использованием SQLAlchemy)**:
```python
from sqlalchemy import text

query = text("SELECT * FROM users WHERE email = :email")
result = session.execute(query, {"email": email})
```

## Экранирование специальных символов

Экранирование специальных символов — это метод, при котором потенциально опасные символы заменяются на безопасные эквиваленты, чтобы они не интерпретировались как часть SQL-команды.

### Часто экранируемые символы

- Одинарная кавычка (`'`) → `\'`
- Двойная кавычка (`"`) → `\"`
- Обратная косая черта (`\`) → `\\`
- Точка с запятой (`;`) → не используется в строках
- Комментарии (`--`, `/* */`) → обрабатываются специальным образом

### Примеры экранирования

**PHP**:
```php
$escaped_input = mysqli_real_escape_string($connection, $user_input);
$query = "SELECT * FROM users WHERE name = '$escaped_input'";
```

**Python**:
```python
# Использование параметров предпочтительнее, но для экранирования:
escaped_input = connection.escape(user_input)
```

> [!warning] Осторожно
> Экранирование специальных символов менее надежно, чем использование подготовленных выражений. Оно может быть обойдено в некоторых случаях, особенно при сложных инъекциях.

## Роли и разграничение доступа

Разграничение доступа к базе данных играет важную роль в предотвращении последствий SQL-инъекций:

### Принцип наименьших привилегий

- Создание отдельных учетных записей для разных компонентов приложения
- Назначение минимально необходимых прав каждому пользователю базы данных
- Ограничение доступа к чувствительным таблицам и процедурам

### Пример настройки ролей

```sql
-- Создание роли с ограниченными правами
CREATE ROLE web_app_user;
GRANT SELECT, INSERT, UPDATE ON users TO web_app_user;
GRANT USAGE ON SCHEMA public TO web_app_user;

-- Создание пользователя и присвоение роли
CREATE USER web_app WITH PASSWORD 'secure_password';
GRANT web_app_user TO web_app;
```

### Роли для разных функций приложения

- **Чтение данных**: Только SELECT права
- **Запись данных**: SELECT, INSERT, UPDATE (без DELETE)
- **Административные функции**: Все права (ограничено по IP и времени)

## Практические примеры уязвимого и безопасного кода

### Уязвимый код (PHP)

```php
// Уязвимый код
$email = $_POST['email'];
$query = "SELECT * FROM users WHERE email = '$email'";
$result = mysqli_query($connection, $query);
```

### Безопасный код (PHP)

```php
// Безопасный код с подготовленным выражением
$email = $_POST['email'];
$stmt = $pdo->prepare("SELECT * FROM users WHERE email = ?");
$stmt->execute([$email]);
$result = $stmt->fetchAll();
```

### Уязвимый код (Python)

```python
# Уязвимый код
user_id = request.form['user_id']
query = f"SELECT * FROM orders WHERE user_id = {user_id}"
cursor.execute(query)
```

### Безопасный код (Python)

```python
# Безопасный код с параметрами
user_id = request.form['user_id']
cursor.execute("SELECT * FROM orders WHERE user_id = %s", (user_id,))
```

### Уязвимый код (JavaScript/Node.js)

```javascript
// Уязвимый код
const userId = req.body.userId;
const query = `SELECT * FROM users WHERE id = ${userId}`;
connection.query(query, (err, results) => {
    // обработка результата
});
```

### Безопасный код (JavaScript/Node.js)

```javascript
// Безопасный код с подготовленным выражением
const userId = req.body.userId;
const query = 'SELECT * FROM users WHERE id = ?';
connection.execute(query, [userId], (err, results) => {
    // обработка результата
});
```

## Инструменты для тестирования

### SQLMap

SQLMap — один из самых популярных инструментов для автоматического обнаружения и эксплуатации SQL-инъекций.

Пример использования:
```bash
sqlmap -u "http://example.com/page?id=1" --dbs
```

### OWASP ZAP

Веб-сканер уязвимостей, который может обнаруживать SQL-инъекции и другие веб-уязвимости.

### Burp Suite

Комплексный инструмент для тестирования безопасности веб-приложений, включая автоматическое и ручное тестирование на SQL-инъекции.

### Custom Scripts

Разработка собственных скриптов для тестирования специфичных сценариев и бизнес-логики.

## Лучшие практики

### 1. Используйте подготовленные выражения по умолчанию

Всегда используйте подготовленные выражения или параметризованные запросы при работе с пользовательским вводом.

### 2. Проверяйте и валидируйте все входные данные

Проверяйте тип, формат и диапазон всех входных данных на стороне сервера.

### 3. Используйте минимально необходимые привилегии

Подключайтесь к базе данных с учетной записью, имеющей минимально необходимые права для выполнения задач.

### 4. Регулярно обновляйте СУБД и фреймворки

Поддерживайте актуальные версии базы данных и используемых фреймворков для устранения известных уязвимостей.

### 5. Используйте белые списки при валидации

Предпочитайте белые списки (allowlists) черным спискам (blocklists) при валидации входных данных.

### 6. Регулярно проводите аудит безопасности

Проводите регулярные аудиты кода и тестирование на проникновение для выявления потенциальных уязвимостей.

### 7. Логируйте и мониторьте SQL-запросы

Ведите логи SQL-запросов и используйте мониторинг для выявления подозрительной активности.

### 8. Обучайте разработчиков

Обеспечьте обучение разработчиков принципам безопасного программирования и уязвимостям веб-приложений.

## Ссылки на другие связанные файлы

- [[Обработка-персональных-данных]] - важные аспекты при работе с конфиденциальной информацией
- [[Secure-Coding-Practices]] - общие практики безопасного программирования
- [[Тестирование-безопасности]] - методы и инструменты для тестирования безопасности
- [[Управление-сессиями-и-аутентификацией]] - безопасная аутентификация и управление сессиями
- [[XSS-защита]] - другая важная веб-уязвимость
- [[CSRF-защита]] - защита от подделки межсайтовых запросов
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[Content-Security-Policy]] - политика безопасности контента
- [[Ограничение-доступа-к-API]] - контроль доступа к API
- [[Шифрование-на-клиенте]] - методы шифрования данных на клиенте
- [[Secure-Storage]] - безопасное хранение данных
- [[Аудит-безопасности]] - комплексный подход к аудиту безопасности
- [[Безопасность-в-веб-приложениях-для-детей]] - специфические аспекты безопасности
- [[Меры-против-ботов]] - защита от автоматизированных атак
- [[Ограничение-ресурсов-и-защита-от-злоупотреблений]] - предотвращение злоупотреблений

## Заключение

SQL-инъекции остаются одной из самых серьезных угроз безопасности веб-приложений. Понимание механизмов этих атак и применение надежных методов защиты, таких как подготовленные выражения, проверка входных данных и принцип наименьших привилегий, являются критически важными для обеспечения безопасности приложений. Регулярное тестирование и обучение команды разработчиков помогут предотвратить появление уязвимостей в коде.
