---
aliases: ["Сервис-воркеры безопасность", "Защита сервис-воркеров"]
tags: ["security", "service-workers", "pwa", "caching"]
---

# Безопасность сервис-воркеров

Сервис-воркеры предоставляют мощные возможности для кэширования, оффлайн-функциональности и фоновой синхронизации, но также создают уникальные векторы атак. Эта статья охватывает ключевые аспекты безопасности сервис-воркеров и методы их защиты.

## Основы безопасности сервис-воркеров

Сервис-воркеры работают в отдельном контексте и имеют доступ к сетевым запросам, кэшированию и другим API, что делает их потенциально опасными, если они скомпрометированы.

> [!warning] Важно
> Сервис-воркеры имеют доступ ко всем сетевым запросам домена, поэтому их компрометация может привести к серьезным последствиям.

## Безопасная регистрация сервис-воркера

### Проверка безопасности перед регистрацией

```javascript
// Регистрация сервис-воркера только по HTTPS
if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js', {
            scope: '/'  // Ограничиваем область действия
        }).then(registration => {
            console.log('SW зарегистрирован с областью:', registration.scope);
        }).catch(error => {
            console.error('Ошибка регистрации SW:', error);
        });
    });
}
```

### Защита от неправильной области действия

```javascript
// Проверка области действия сервис-воркера
function validateServiceWorkerScope(swUrl, expectedScope) {
    const swPath = new URL(swUrl, window.location).pathname;
    const scopePath = new URL(expectedScope, window.location).pathname;
    
    if (!swPath.startsWith(scopePath)) {
        throw new Error('Неверная область действия сервис-воркера');
    }
}
```

## Безопасное кэширование данных

### Контроль кэширования чувствительных данных

```javascript
// sw.js - безопасное кэширование
const SECURE_CACHE_NAME = 'secure-cache-v1';
const PUBLIC_CACHE_NAME = 'public-cache-v1';

self.addEventListener('fetch', event => {
    const { request } = event;
    
    // Проверка, содержит ли URL чувствительные данные
    if (isSensitiveUrl(request.url)) {
        // Не кэшировать чувствительные данные
        event.respondWith(fetch(request));
        return;
    }
    
    if (isPublicResource(request)) {
        event.respondWith(
            caches.open(PUBLIC_CACHE_NAME)
                .then(cache => cache.match(request))
                .then(response => response || fetchAndCache(request))
        );
    } else {
        event.respondWith(fetch(request));
    }
});

function isSensitiveUrl(url) {
    const sensitivePatterns = [
        /\/api\/auth/,
        /\/api\/user\/.*\/private/,
        /\/api\/payment/,
        /\/api\/profile/
    ];
    
    return sensitivePatterns.some(pattern => pattern.test(url));
}

function isPublicResource(request) {
    const publicTypes = ['script', 'style', 'image', 'font'];
    return publicTypes.includes(request.destination);
}
```

### Валидация кэшированных данных

```javascript
// sw.js - валидация данных при кэшировании
async function fetchAndCache(request) {
    const response = await fetch(request);
    
    // Проверка статуса ответа
    if (!response || response.status !== 200 || response.type !== 'basic') {
        return response;
    }
    
    // Проверка типа содержимого
    const contentType = response.headers.get('content-type');
    if (!isValidContentType(contentType)) {
        return response;
    }
    
    // Кэширование только валидных ответов
    const cache = await caches.open(PUBLIC_CACHE_NAME);
    cache.put(request, response.clone());
    
    return response;
}

function isValidContentType(contentType) {
    if (!contentType) return false;
    
    const allowedTypes = [
        'text/html',
        'text/css',
        'application/javascript',
        'image/',
        'font/'
    ];
    
    return allowedTypes.some(type => contentType.includes(type));
}
```

## Защита от подделки сервис-воркера

### Проверка целостности сервис-воркера

```javascript
// Проверка наличия подозрительных сервис-воркеров
function checkForSuspiciousSW() {
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
            registrations.forEach(registration => {
                // Проверка области действия
                if (registration.scope !== expectedScope) {
                    console.warn('Обнаружена регистрация SW с подозрительной областью:', registration.scope);
                    // Здесь можно выполнить дополнительные действия
                }
            });
        });
    }
}
```

### Контроль версий сервис-воркеров

```javascript
// sw.js - управление версиями кэша
const CACHE_VERSIONS = {
    'public': 'public-v1.2.0',
    'secure': 'secure-v1.0.0'
};

self.addEventListener('install', event => {
    event.waitUntil(
        Promise.all([
            caches.open(CACHE_VERSIONS.public),
            caches.open(CACHE_VERSIONS.secure)
        ]).then(() => self.skipWaiting())
    );
});

self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    // Удаление устаревших кэшей
                    if (!Object.values(CACHE_VERSIONS).includes(cacheName)) {
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => self.clients.claim())
    );
});
```

## Защита от атак через fetch-перехват

### Фильтрация сетевых запросов

```javascript
// sw.js - безопасная обработка запросов
self.addEventListener('fetch', event => {
    const { request } = event;
    
    // Блокировка запросов к подозрительным доменам
    try {
        const url = new URL(request.url);
        
        // Проверка, что запрос к разрешенному домену
        if (!isAllowedDomain(url.hostname)) {
            console.warn('Заблокирован запрос к подозрительному домену:', url.hostname);
            event.respondWith(new Response(null, { status: 403 }));
            return;
        }
        
        // Обработка запроса
        event.respondWith(handleSecureRequest(request));
    } catch (error) {
        // Ошибка парсинга URL - возможно, подозрительный запрос
        event.respondWith(new Response(null, { status: 400 }));
    }
});

function isAllowedDomain(hostname) {
    const allowedDomains = [
        self.location.hostname,
        'api.example.com',
        'cdn.example.com'
    ];
    
    return allowedDomains.includes(hostname);
}
```

### Защита от DNS rebinding

```javascript
// sw.js - защита от DNS rebinding атак
function isLocalhost(url) {
    const hostname = new URL(url).hostname;
    return hostname === 'localhost' || 
           hostname === '127.0.0.1' || 
           hostname.startsWith('[') && hostname.endsWith(']'); // IPv6 loopback
}

self.addEventListener('fetch', event => {
    const { request } = event;
    
    // Блокировка запросов к localhost из production окружения
    if (self.location.hostname !== 'localhost' && isLocalhost(request.url)) {
        event.respondWith(new Response(null, { status: 403 }));
        return;
    }
    
    // Продолжение обработки запроса
    event.respondWith(fetch(request));
});
```

## Безопасность с API и данными

### Защита от подделки запросов

```javascript
// sw.js - добавление безопасности к API запросам
self.addEventListener('fetch', event => {
    const { request } = event;
    
    if (request.url.includes('/api/')) {
        // Проверка и при необходимости модификация заголовков
        const modifiedRequest = addSecurityHeaders(request);
        
        event.respondWith(
            fetch(modifiedRequest)
                .then(response => {
                    // Проверка ответа API на безопасность
                    return validateApiResponse(response);
                })
        );
    }
});

function addSecurityHeaders(request) {
    const headers = new Headers(request.headers);
    
    // Добавление CSRF токена, если доступен
    if (csrfToken) {
        headers.set('X-CSRF-Token', csrfToken);
    }
    
    // Установка безопасных заголовков
    headers.set('X-Requested-With', 'XMLHttpRequest');
    
    return new Request(request, { headers });
}

function validateApiResponse(response) {
    // Проверка заголовков безопасности в ответе
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
        // Проверка, что ответ действительно JSON
        return response.clone().text().then(text => {
            try {
                JSON.parse(text);
                return response;
            } catch (e) {
                // Ответ не является валидным JSON
                return new Response(null, { status: 500 });
            }
        });
    }
    
    return response;
}
```

## Обнаружение и предотвращение атак

### Мониторинг активности сервис-воркера

```javascript
// sw.js - логирование подозрительной активности
function logSecurityEvent(eventType, details) {
    // Отправка логов безопасности (только через безопасные каналы)
    const logData = {
        type: eventType,
        details,
        timestamp: Date.now(),
        worker: 'service-worker'
    };
    
    // Отправка через fetch (не beacon, чтобы избежать рекурсии)
    fetch('/api/security-log', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'service-worker'
        },
        body: JSON.stringify(logData)
    }).catch(() => {
        // Игнорируем ошибки отправки логов
    });
}

self.addEventListener('fetch', event => {
    // Проверка на подозрительные паттерны
    if (isSuspiciousRequest(event.request)) {
        logSecurityEvent('suspicious_fetch', {
            url: event.request.url,
            method: event.request.method,
            destination: event.request.destination
        });
    }
});

function isSuspiciousRequest(request) {
    // Проверка на подозрительные URL паттерны
    const suspiciousPatterns = [
        /javascript:/i,
        /vbscript:/i,
        /data:/i,
        /<script/i,
        /on\w+\s*=/i
    ];
    
    return suspiciousPatterns.some(pattern => 
        pattern.test(request.url) || 
        pattern.test(request.headers.get('content-type') || '')
    );
}
```

## Обновление и безопасность сервис-воркеров

### Безопасное обновление сервис-воркеров

```javascript
// Контроль обновлений сервис-воркера
navigator.serviceWorker.addEventListener('controllerchange', () => {
    // Проверка обновления сервис-воркера
    const newSW = navigator.serviceWorker.controller;
    
    if (newSW) {
        // Проверка версии и целостности
        verifySWIntegrity(newSW);
    }
});

function verifySWIntegrity(serviceWorker) {
    // В реальном приложении это может включать:
    // - Проверку цифровой подписи
    // - Сравнение контрольных сумм
    // - Валидацию через внешний сервис
    
    console.log('Проверка целостности SW:', serviceWorker.scriptURL);
}
```

## Рекомендации по безопасности

- [[Лучшие-практики-безопасности-PWA]] - общие практики безопасности PWA
- [[Безопасность-манифеста]] - безопасность манифеста PWA
- [[Безопасность-оффлайн-данных]] - безопасность данных в оффлайн режиме
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[XSS-защита]] - защита от межсайтового скриптинга

## Заключение

Безопасность сервис-воркеров требует особого внимания из-за их уникального доступа к сетевым запросам и кэшированию. Ключевые принципы включают ограничение области действия, проверку всех запросов и ответов, защиту от атак подмены и регулярный мониторинг активности.