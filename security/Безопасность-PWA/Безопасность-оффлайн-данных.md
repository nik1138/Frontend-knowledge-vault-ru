---
aliases: ["Оффлайн данные безопасность", "Защита данных в оффлайн режиме"]
tags: ["security", "pwa", "offline", "data-protection", "storage"]
---

# Безопасность оффлайн данных

Безопасность оффлайн данных в PWA и веб-приложениях с оффлайн функциональностью - это критически важная область, требующая особого внимания. Приложения, работающие в оффлайн режиме, должны безопасно хранить, обрабатывать и защищать данные даже без подключения к серверу.

## Основы безопасности оффлайн данных

Оффлайн данные включают в себя:

- Аутентификационные токены и сессии
- Личные данные пользователей
- Конфиденциальные настройки
- Кэшированные API-ответы
- Локальные настройки приложения

> [!warning] Важно
> Оффлайн данные находятся на устройстве пользователя и могут быть доступны другим приложениям или пользователям устройства, если не защищены должным образом.

## Безопасное хранение данных в браузере

### IndexedDB безопасное использование

```javascript
class SecureIndexedDB {
    constructor(dbName, version) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Создание безопасных хранилищ
                if (!db.objectStoreNames.contains('secure_data')) {
                    const store = db.createObjectStore('secure_data', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('user_id', 'user_id', { unique: false });
                    store.createIndex('data_type', 'data_type', { unique: false });
                }
            };
        });
    }

    async storeSecureData(data, userId, dataType) {
        if (!this.db) await this.init();

        const transaction = this.db.transaction(['secure_data'], 'readwrite');
        const store = transaction.objectStore('secure_data');

        // Шифрование данных перед сохранением
        const encryptedData = await this.encryptData(data);
        const id = crypto.randomUUID();

        const record = {
            id,
            user_id: userId,
            data_type: dataType,
            data: encryptedData,
            timestamp: Date.now(),
            created_at: new Date().toISOString()
        };

        await store.add(record);
        return id;
    }

    async retrieveSecureData(recordId, userId) {
        if (!this.db) await this.init();

        const transaction = this.db.transaction(['secure_data'], 'readonly');
        const store = transaction.objectStore('secure_data');

        const record = await store.get(recordId);

        if (!record || record.user_id !== userId) {
            throw new Error('Доступ запрещен или запись не найдена');
        }

        // Расшифровка данных
        return await this.decryptData(record.data);
    }

    async encryptData(data) {
        // Использование Web Crypto API для шифрования
        const key = await this.getEncryptionKey();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const dataBuffer = new TextEncoder().encode(JSON.stringify(data));

        const encrypted = await window.crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            key,
            dataBuffer
        );

        return {
            encrypted: Array.from(new Uint8Array(encrypted)),
            iv: Array.from(iv),
            algorithm: 'AES-GCM'
        };
    }

    async decryptData(encryptedData) {
        const key = await this.getEncryptionKey();
        const iv = new Uint8Array(encryptedData.iv);
        const dataBuffer = new Uint8Array(encryptedData.encrypted);

        const decrypted = await window.crypto.subtle.decrypt(
            { name: 'AES-GCM', iv },
            key,
            dataBuffer
        );

        const decryptedText = new TextDecoder().decode(decrypted);
        return JSON.parse(decryptedText);
    }

    async getEncryptionKey() {
        // Получение ключа из безопасного хранилища
        let keyMaterial = await this.getKeyMaterial();
        
        if (!keyMaterial) {
            // Создание нового ключа
            keyMaterial = await window.crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            
            // Сохранение ключа (в реальном приложении - в более безопасном хранилище)
            await this.storeKeyMaterial(keyMaterial);
        }

        return keyMaterial;
    }

    async getKeyMaterial() {
        // В реальном приложении ключи должны храниться в безопасном хранилище
        // например, с использованием Web Crypto API и ключей устройства
        const storedKey = sessionStorage.getItem('encryption-key');
        if (storedKey) {
            return await window.crypto.subtle.importKey(
                'jwk',
                JSON.parse(storedKey),
                { name: 'AES-GCM' },
                true,
                ['encrypt', 'decrypt']
            );
        }
        return null;
    }

    async storeKeyMaterial(keyMaterial) {
        const jwk = await window.crypto.subtle.exportKey('jwk', keyMaterial);
        sessionStorage.setItem('encryption-key', JSON.stringify(jwk));
    }
}
```

### Безопасное использование localStorage

```javascript
class SecureLocalStorage {
    constructor(encryptionKey) {
        this.encryptionKey = encryptionKey;
    }

    async setItem(key, value) {
        // Шифрование данных перед сохранением
        const encryptedValue = await this.encrypt(JSON.stringify(value));
        localStorage.setItem(this.getSecureKey(key), encryptedValue);
    }

    async getItem(key) {
        const encryptedValue = localStorage.getItem(this.getSecureKey(key));
        
        if (!encryptedValue) {
            return null;
        }

        try {
            const decryptedValue = await this.decrypt(encryptedValue);
            return JSON.parse(decryptedValue);
        } catch (error) {
            console.error('Ошибка расшифровки данных:', error);
            // Удаление поврежденных данных
            this.removeItem(key);
            return null;
        }
    }

    removeItem(key) {
        localStorage.removeItem(this.getSecureKey(key));
    }

    getSecureKey(key) {
        // Добавление префикса для изоляции данных
        return `secure_${key}`;
    }

    async encrypt(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const key = await this.importKey(this.encryptionKey);
        
        const encrypted = await window.crypto.subtle.encrypt(
            { name: 'AES-GCM', iv },
            key,
            dataBuffer
        );

        const result = new Uint8Array(iv.length + encrypted.byteLength);
        result.set(iv, 0);
        result.set(new Uint8Array(encrypted), iv.length);

        return btoa(String.fromCharCode(...result));
    }

    async decrypt(encryptedData) {
        const dataBuffer = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
        
        const iv = dataBuffer.slice(0, 12);
        const encrypted = dataBuffer.slice(12);
        
        const key = await this.importKey(this.encryptionKey);
        
        const decrypted = await window.crypto.subtle.decrypt(
            { name: 'AES-GCM', iv },
            key,
            encrypted
        );

        const decoder = new TextDecoder();
        return decoder.decode(decrypted);
    }

    async importKey(keyMaterial) {
        return await window.crypto.subtle.importKey(
            'raw',
            typeof keyMaterial === 'string' ? new TextEncoder().encode(keyMaterial) : keyMaterial,
            { name: 'AES-GCM' },
            false,
            ['encrypt', 'decrypt']
        );
    }
}
```

## Шифрование оффлайн данных

### Клиентское шифрование

```javascript
class ClientSideEncryption {
    constructor() {
        this.key = null;
    }

    async initialize() {
        this.key = await this.getOrCreateKey();
    }

    async getOrCreateKey() {
        // Попытка получить существующий ключ
        const storedKey = await this.getStoredKey();
        
        if (storedKey) {
            return storedKey;
        }

        // Создание нового ключа
        const newKey = await window.crypto.subtle.generateKey(
            {
                name: 'AES-GCM',
                length: 256
            },
            true,
            ['encrypt', 'decrypt']
        );

        // Сохранение ключа
        await this.storeKey(newKey);

        return newKey;
    }

    async getStoredKey() {
        // В реальном приложении ключ должен быть защищен дополнительными мерами
        const keyData = sessionStorage.getItem('app-encryption-key');
        
        if (!keyData) {
            return null;
        }

        try {
            return await window.crypto.subtle.importKey(
                'jwk',
                JSON.parse(keyData),
                { name: 'AES-GCM' },
                true,
                ['encrypt', 'decrypt']
            );
        } catch (error) {
            console.error('Ошибка загрузки ключа:', error);
            return null;
        }
    }

    async storeKey(key) {
        const jwk = await window.crypto.subtle.exportKey('jwk', key);
        sessionStorage.setItem('app-encryption-key', JSON.stringify(jwk));
    }

    async encrypt(data) {
        if (!this.key) {
            await this.initialize();
        }

        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encodedData = new TextEncoder().encode(JSON.stringify(data));

        const encrypted = await window.crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: iv
            },
            this.key,
            encodedData
        );

        // Возврат зашифрованных данных с IV
        return {
            encrypted: Array.from(new Uint8Array(encrypted)),
            iv: Array.from(iv)
        };
    }

    async decrypt(encryptedPackage) {
        if (!this.key) {
            await this.initialize();
        }

        const iv = new Uint8Array(encryptedPackage.iv);
        const encrypted = new Uint8Array(encryptedPackage.encrypted);

        const decrypted = await window.crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv: iv
            },
            this.key,
            encrypted
        );

        const decoded = new TextDecoder().decode(decrypted);
        return JSON.parse(decoded);
    }
}
```

## Безопасность аутентификационных данных

### Хранение токенов доступа

```javascript
class SecureTokenStorage {
    constructor() {
        this.encryption = new ClientSideEncryption();
    }

    async storeToken(token, userId) {
        await this.encryption.initialize();
        
        const tokenData = {
            token,
            userId,
            timestamp: Date.now(),
            expiresAt: Date.now() + (30 * 24 * 60 * 60 * 1000) // 30 дней
        };

        const encryptedToken = await this.encryption.encrypt(tokenData);
        localStorage.setItem('secure_token', JSON.stringify(encryptedToken));
    }

    async getToken() {
        const storedToken = localStorage.getItem('secure_token');
        
        if (!storedToken) {
            return null;
        }

        try {
            const encryptedToken = JSON.parse(storedToken);
            const tokenData = await this.encryption.decrypt(encryptedToken);
            
            // Проверка срока действия
            if (tokenData.expiresAt < Date.now()) {
                this.clearToken();
                return null;
            }

            return tokenData.token;
        } catch (error) {
            console.error('Ошибка при получении токена:', error);
            this.clearToken();
            return null;
        }
    }

    clearToken() {
        localStorage.removeItem('secure_token');
    }

    async validateToken(token) {
        // Валидация токена на сервере (когда есть подключение)
        try {
            const response = await fetch('/api/validate-token', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            return response.ok;
        } catch (error) {
            // В оффлайн режиме возвращаем true, если токен был недавно проверен
            return this.wasRecentlyValidated();
        }
    }

    wasRecentlyValidated() {
        const lastValidation = localStorage.getItem('token_validation_time');
        const now = Date.now();
        // Считаем токен валидным в оффлайн режиме в течение 1 часа после последней проверки
        return lastValidation && (now - parseInt(lastValidation)) < (60 * 60 * 1000);
    }
}
```

## Защита от несанкционированного доступа

### Проверка аутентификации в оффлайн режиме

```javascript
class OfflineAuthManager {
    constructor() {
        this.tokenStorage = new SecureTokenStorage();
        this.biometricAuth = new BiometricAuth();
    }

    async authenticateOffline() {
        // Проверка наличия сохраненного токена
        const token = await this.tokenStorage.getToken();
        
        if (!token) {
            throw new Error('Нет сохраненного токена для оффлайн аутентификации');
        }

        // Проверка срока действия токена
        if (!(await this.tokenStorage.validateToken(token))) {
            throw new Error('Токен недействителен');
        }

        // Дополнительная проверка с помощью биометрии (если доступна)
        if (await this.biometricAuth.isAvailable()) {
            const authResult = await this.biometricAuth.authenticate();
            if (!authResult) {
                throw new Error('Биометрическая аутентификация не пройдена');
            }
        }

        return true;
    }

    async storeUserData(userData) {
        // Шифрование пользовательских данных перед сохранением
        const encryptedData = await this.encryptUserData(userData);
        localStorage.setItem('user_data', JSON.stringify(encryptedData));
    }

    async getUserData() {
        const storedData = localStorage.getItem('user_data');
        
        if (!storedData) {
            return null;
        }

        try {
            const encryptedData = JSON.parse(storedData);
            return await this.decryptUserData(encryptedData);
        } catch (error) {
            console.error('Ошибка при получении пользовательских данных:', error);
            return null;
        }
    }

    async encryptUserData(data) {
        const encryption = new ClientSideEncryption();
        await encryption.initialize();
        return await encryption.encrypt(data);
    }

    async decryptUserData(encryptedData) {
        const encryption = new ClientSideEncryption();
        await encryption.initialize();
        return await encryption.decrypt(encryptedData);
    }
}

class BiometricAuth {
    async isAvailable() {
        // Проверка доступности Web Authentication API
        return 'credentials' in navigator;
    }

    async authenticate() {
        if (!(await this.isAvailable())) {
            throw new Error('Биометрическая аутентификация недоступна');
        }

        try {
            const credential = await navigator.credentials.create({
                publicKey: {
                    challenge: new Uint8Array(32),
                    rp: { name: 'My App' },
                    user: {
                        id: new Uint8Array(16),
                        name: 'user@example.com',
                        displayName: 'User Name'
                    },
                    pubKeyCredParams: [{ alg: -7, type: 'public-key' }]
                }
            });

            return !!credential;
        } catch (error) {
            console.error('Ошибка биометрической аутентификации:', error);
            return false;
        }
    }
}
```

## Очистка оффлайн данных

### Безопасная очистка данных

```javascript
class SecureDataCleaner {
    static async clearAllOfflineData() {
        // Очистка localStorage
        const keysToRemove = [];
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('secure_')) {
                keysToRemove.push(key);
            }
        }
        
        keysToRemove.forEach(key => localStorage.removeItem(key));
        
        // Очистка sessionStorage
        sessionStorage.clear();
        
        // Очистка IndexedDB
        await this.clearSecureDatabase();
        
        // Очистка кэша сервис-воркера (если применимо)
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            await this.clearCache();
        }
    }

    static async clearSecureDatabase() {
        // Удаление защищенной базы данных
        indexedDB.deleteDatabase('secure_data_db');
    }

    static async clearCache() {
        if ('caches' in window) {
            const cacheNames = await caches.keys();
            await Promise.all(
                cacheNames
                    .filter(name => name.startsWith('secure-'))
                    .map(name => caches.delete(name))
            );
        }
    }

    static async clearSensitiveData() {
        // Очистка только чувствительных данных
        localStorage.removeItem('secure_token');
        localStorage.removeItem('user_data');
        sessionStorage.removeItem('encryption-key');
    }
}
```

## Мониторинг безопасности оффлайн данных

### Логирование безопасности

```javascript
class OfflineSecurityLogger {
    static logSecurityEvent(eventType, details) {
        const securityEvent = {
            type: eventType,
            details,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            platform: navigator.platform
        };

        // Сохранение события безопасности в защищенное хранилище
        const events = JSON.parse(localStorage.getItem('security_events') || '[]');
        events.push(securityEvent);
        
        // Ограничение количества событий для экономии места
        if (events.length > 100) {
            events.splice(0, events.length - 100);
        }
        
        localStorage.setItem('security_events', JSON.stringify(events));
    }

    static async detectSecurityIssues() {
        // Проверка на наличие подозрительной активности
        const suspiciousPatterns = [
            multipleFailedAuthAttempts(),
            unexpectedStorageAccess(),
            modifiedDataIntegrity()
        ];

        for (const pattern of suspiciousPatterns) {
            if (await pattern) {
                this.logSecurityEvent('suspicious_activity', { pattern });
            }
        }
    }

    static async reportSecurityEvents() {
        // Отправка событий безопасности при восстановлении подключения
        const events = JSON.parse(localStorage.getItem('security_events') || '[]');
        
        if (events.length > 0 && navigator.onLine) {
            try {
                await fetch('/api/security-events', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(events)
                });
                
                // Очистка локальных событий после отправки
                localStorage.removeItem('security_events');
            } catch (error) {
                console.error('Ошибка отправки событий безопасности:', error);
            }
        }
    }
}

function multipleFailedAuthAttempts() {
    // Реализация проверки на множественные неудачные попытки аутентификации
    const attempts = JSON.parse(sessionStorage.getItem('auth_attempts') || '[]');
    const recentAttempts = attempts.filter(time => Date.now() - time < 5 * 60 * 1000); // 5 минут
    
    return recentAttempts.length > 5; // Более 5 попыток за 5 минут
}

function unexpectedStorageAccess() {
    // Проверка на неожиданный доступ к хранилищу из подозрительных источников
    return false; // Реализация зависит от конкретных требований
}

function modifiedDataIntegrity() {
    // Проверка целостности зашифрованных данных
    return false; // Реализация проверки целостности
}
```

## Рекомендации по безопасности

- [[Шифрование-на-клиенте]] - шифрование данных на стороне клиента
- [[Безопасность-сервис-воркеров]] - безопасность сервис-воркеров
- [[Безопасность-манифеста]] - безопасность манифеста PWA
- [[Лучшие-практики-безопасности-PWA]] - общие практики безопасности PWA
- [[Управление-сессиями]] - управление сессиями и аутентификацией

## Заключение

Безопасность оффлайн данных требует комплексного подхода, включающего шифрование, аутентификацию, защиту от несанкционированного доступа и регулярный мониторинг. Ключевые принципы включают минимальное хранение чувствительных данных, использование клиентского шифрования и регулярную проверку целостности данных.