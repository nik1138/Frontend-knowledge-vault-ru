---
aliases: ["Кэширование в сервис воркерах", "Service Worker Caching Security"]
tags: [security, service-workers, caching, web-security, javascript]
---

# Кэширование в сервис воркерах

Кэширование в сервис воркерах предоставляет мощный механизм для управления кэшем на клиентской стороне, но требует особого внимания к безопасности. Service Workers позволяют разработчикам перехватывать сетевые запросы и управлять кэшем, что открывает как возможности для улучшения производительности, так и риски безопасности.

## Введение в кэширование в сервис воркерах

Service Workers - это скрипты, которые работают в фоновом режиме и могут перехватывать и обрабатывать сетевые запросы. Они имеют доступ к глобальному объекту `caches`, который позволяет хранить ресурсы локально для последующего использования.

```javascript
// Регистрация Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
```

Кэширование в Service Workers особенно полезно для:
- Офлайн-функциональности
- Улучшения производительности
- Контроля над сетевыми запросами
- Кэширования API-ответов

Однако неправильное использование может привести к серьезным уязвимостям безопасности.

## Основные риски безопасности кэширования в сервис воркерах

### Утечка конфиденциальной информации

Service Workers могут кэшировать любые данные, включая конфиденциальные. Если чувствительные данные, такие как токены аутентификации или личная информация пользователя, будут закэшированы, они могут остаться на устройстве пользователя дольше, чем необходимо.

### Кэширование вредоносного контента

Если Service Worker будет скомпрометирован, злоумышленник может заставить его кэшировать вредоносный контент, который будет обслуживаться даже после устранения уязвимости на сервере.

### Атаки с использованием кэшированных данных

Злоумышленник может манипулировать кэшированными данными, чтобы повлиять на поведение приложения или получить доступ к конфиденциальной информации.

### Персистентность угроз

Кэшированные вредоносные данные могут оставаться на устройстве пользователя даже после перезапуска браузера или очистки обычного кэша, пока не будет обновлен или удален Service Worker.

## Безопасные практики кэширования в сервис воркерах

### 1. Не кэшировать конфиденциальные данные

Самое важное правило - никогда не кэшировать конфиденциальные данные в Service Worker:

```javascript
// НЕПРАВИЛЬНО: кэширование чувствительных данных
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/user/profile')) {
    event.respondWith(
      caches.match(event.request).then(response => {
        return response || fetch(event.request);
      })
    );
  }
});

// ПРАВИЛЬНО: не кэшировать чувствительные API-запросы
self.addEventListener('fetch', event => {
  if (event.request.url.includes('/api/user/profile')) {
    // Не кэшировать конфиденциальные данные
    event.respondWith(fetch(event.request));
  } else {
    // Кэшировать статические ресурсы
    event.respondWith(
      caches.match(event.request).then(response => {
        return response || fetch(event.request);
      })
    );
  }
});
```

### 2. Проверка целостности кэшированных данных

Всегда проверяйте целостность кэшированных данных при их извлечении:

```javascript
// Пример проверки целостности данных
async function validateAndCache(request, response) {
  // Проверка MIME-типа
  if (!isValidMimeType(response.headers.get('content-type'))) {
    return response;
  }

  // Проверка контрольной суммы (если доступна)
  const body = await response.clone().text();
  if (hasValidChecksum(body)) {
    const cache = await caches.open('secure-cache-v1');
    cache.put(request, response.clone());
  }

  return response;
}
```

### 3. Использование безопасных имен кэшей

Используйте уникальные имена кэшей с версионированием, чтобы избежать конфликтов и обеспечить безопасность:

```javascript
const CACHE_VERSION = 'v1.2.3';
const STATIC_CACHE_NAME = `static-${CACHE_VERSION}`;
const DYNAMIC_CACHE_NAME = `dynamic-${CACHE_VERSION}`;
```

### 4. Очистка кэша при обновлении Service Worker

При обновлении Service Worker обязательно очищайте старые кэши, чтобы избежать использования устаревших или потенциально вредоносных данных:

```javascript
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!cacheWhitelist.includes(cacheName)) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

## Примеры безопасного кэширования

### Кэширование статических ресурсов

```javascript
const CACHE_NAME = 'static-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Открыт кэш');
        return cache.addAll(urlsToCache);
      })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Возврат кэшированного ответа или выполнение запроса
        return response || fetch(event.request);
      }
    )
  );
});
```

### Безопасное кэширование API-ответов

```javascript
const API_CACHE_NAME = 'api-v1';

self.addEventListener('fetch', event => {
  // Проверяем, является ли запрос API-запросом
  if (event.request.url.includes('/api/') && 
      !event.request.url.includes('/api/user/')) { // Не кэшируем персональные данные
    
    event.respondWith(
      caches.match(event.request).then(cachedResponse => {
        return cachedResponse || fetch(event.request).then(response => {
          // Кэшируем только успешные ответы
          if (response.status === 200) {
            const responseToCache = response.clone();
            caches.open(API_CACHE_NAME).then(cache => {
              cache.put(event.request, responseToCache);
            });
          }
          return response;
        });
      })
    );
  } else {
    // Не кэшируем чувствительные API-запросы
    event.respondWith(fetch(event.request));
  }
});
```

## Защита от атак

### Проверка источника запросов

Проверяйте, что запросы происходят из доверенного источника:

```javascript
self.addEventListener('fetch', event => {
  // Проверяем источник запроса
  if (event.request.referrer && 
      !event.request.referrer.startsWith(self.location.origin)) {
    // Отклоняем запросы из непроверенных источников
    return;
  }
  
  // Обрабатываем запрос
  event.respondWith(handleRequest(event.request));
});
```

### Ограничение размера кэша

Ограничивайте размер кэша, чтобы предотвратить DoS-атаки через переполнение:

```javascript
async function addToCacheSafely(request, response) {
  const cache = await caches.open('safe-cache');
  const keys = await cache.keys();
  
  // Ограничиваем количество элементов в кэше
  if (keys.length > MAX_CACHE_SIZE) {
    // Удаляем старые элементы
    await cache.delete(keys[0]);
  }
  
  await cache.put(request, response);
}
```

## Мониторинг и аудит кэширования

Для обеспечения безопасности кэширования в Service Workers рекомендуется:

1. Регулярно проверять содержимое кэшей на наличие конфиденциальной информации
2. Мониторить использование кэша и выявлять аномалии
3. Проводить аудит кода Service Worker на предмет уязвимостей
4. Использовать Content Security Policy для ограничения возможностей Service Worker

## Совместимость с другими механизмами безопасности

Service Workers должны работать в сочетании с другими механизмами безопасности:

- [[Content Security Policy]] - ограничивает возможности скриптов
- [[HTTP Strict Transport Security]] - обеспечивает безопасное соединение
- [[Subresource Integrity]] - проверяет целостность ресурсов

## Заключение

Кэширование в сервис воркерах предоставляет мощные возможности для улучшения производительности веб-приложений, но требует особого внимания к безопасности. Правильная реализация кэширования в Service Workers включает в себя не кэширование конфиденциальных данных, проверку целостности кэшированных данных, очистку кэша при обновлениях и защиту от различных атак.

Для дальнейшего изучения рекомендуется ознакомиться с [[Политики-безопасности-кэширования]], [[Безопасность-HTTP-кэширования]] и [[Безопасность-манифеста-кэша]].

## См. также

- [[Service Workers]]
- [[Политики-безопасности-кэширования]]
- [[Безопасность-HTTP-кэширования]]
- [[Content Security Policy]]

#security #service-workers #caching #web-security #javascript