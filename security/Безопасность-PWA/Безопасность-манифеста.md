---
aliases: ["PWA манифест безопасность", "Защита webapp.manifest"]
tags: ["security", "pwa", "manifest", "web-apps"]
---

# Безопасность манифеста

Манифест веб-приложения (web app manifest) - это JSON-файл, который предоставляет информацию о веб-приложении, такой как имя, иконки, начальный URL и режим отображения. Безопасность манифеста важна, так как он может быть использован для атак подмены идентичности или социальной инженерии.

## Основы безопасности манифеста

Манифест веб-приложения используется браузерами для установки PWA и предоставления информации о приложении. Неправильно защищенный манифест может быть подделан для:

- Подмены идентичности приложения
- Отображения ложной информации пользователю
- Перенаправления на вредоносные URL

> [!warning] Важно
> Манифест должен быть защищен от несанкционированного изменения и подделки, так как он влияет на восприятие пользователем приложения.

## Структура безопасного манифеста

### Основные поля безопасности

```json
{
  "name": "Мое безопасное PWA",
  "short_name": "SecurePWA",
  "description": "Безопасное прогрессивное веб-приложение",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png", 
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "categories": ["productivity"],
  "lang": "ru-RU",
  "dir": "ltr",
  "orientation": "any",
  "prefer_related_applications": false,
  "related_applications": [],
  "serviceworker": {
    "src": "/sw.js",
    "scope": "/",
    "type": "javascript"
  },
  "shortcuts": [
    {
      "name": "Главная",
      "short_name": "Главная",
      "description": "Перейти на главную страницу",
      "url": "/",
      "icons": [{ "src": "/icons/home-icon.png", "sizes": "192x192" }]
    }
  ]
}
```

### Проверка корректности манифеста

```javascript
// Проверка манифеста на клиенте
async function validateManifest(manifestUrl) {
    try {
        const response = await fetch(manifestUrl);
        
        if (!response.ok) {
            throw new Error(`Ошибка загрузки манифеста: ${response.status}`);
        }
        
        // Проверка Content-Type
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/manifest+json')) {
            console.warn('Некорректный Content-Type для манифеста');
        }
        
        const manifest = await response.json();
        
        // Валидация структуры манифеста
        validateManifestStructure(manifest);
        
        return manifest;
    } catch (error) {
        console.error('Ошибка валидации манифеста:', error);
        throw error;
    }
}

function validateManifestStructure(manifest) {
    // Обязательные поля
    const requiredFields = ['name', 'short_name', 'start_url'];
    
    for (const field of requiredFields) {
        if (!manifest[field]) {
            throw new Error(`Отсутствует обязательное поле: ${field}`);
        }
    }
    
    // Проверка URL полей
    if (manifest.start_url && !isValidRelativeUrl(manifest.start_url)) {
        throw new Error('Невалидный start_url в манифесте');
    }
    
    if (manifest.scope && !isValidRelativeUrl(manifest.scope)) {
        throw new Error('Невалидный scope в манифесте');
    }
    
    // Проверка иконок
    if (manifest.icons) {
        for (const icon of manifest.icons) {
            if (!isValidIcon(icon)) {
                throw new Error('Невалидная иконка в манифесте');
            }
        }
    }
}

function isValidRelativeUrl(url) {
    try {
        // Проверка, что URL относительный или начинается с /
        return url.startsWith('/') || url.startsWith('./') || url.startsWith('../');
    } catch {
        return false;
    }
}

function isValidIcon(icon) {
    return icon && 
           icon.src && 
           icon.sizes && 
           icon.type && 
           isValidRelativeUrl(icon.src);
}
```

## Защита манифеста на сервере

### Правильные заголовки HTTP

```javascript
// Express.js middleware для безопасного предоставления манифеста
app.get('/manifest.json', (req, res) => {
    // Проверка безопасности запроса
    if (!isValidManifestRequest(req)) {
        res.status(403).send('Доступ запрещен');
        return;
    }
    
    // Установка безопасных заголовков
    res.setHeader('Content-Type', 'application/manifest+json');
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('Content-Security-Policy', "default-src 'none'; img-src 'self'; connect-src 'self'");
    
    // Кэширование с проверкой целостности
    res.setHeader('Cache-Control', 'public, max-age=3600');
    res.setHeader('ETag', generateETag(manifestData));
    
    res.json(manifestData);
});

function isValidManifestRequest(req) {
    // Проверка реферера и других заголовков
    const origin = req.get('Origin');
    const referer = req.get('Referer');
    const userAgent = req.get('User-Agent');
    
    // Блокировка прямого доступа без реферера (кроме браузеров)
    if (!referer && !isBrowserUserAgent(userAgent)) {
        return false;
    }
    
    // Проверка, что реферер с того же домена
    if (referer && !referer.includes(req.get('host'))) {
        return false;
    }
    
    return true;
}

function isBrowserUserAgent(userAgent) {
    return userAgent && (
        userAgent.includes('Mozilla') || 
        userAgent.includes('Chrome') || 
        userAgent.includes('Safari')
    );
}
```

### Подпись манифеста

```javascript
const crypto = require('crypto');

// Генерация подписи манифеста
function generateManifestSignature(manifestData, secretKey) {
    const manifestString = JSON.stringify(manifestData);
    const hmac = crypto.createHmac('sha256', secretKey);
    hmac.update(manifestString);
    return hmac.digest('hex');
}

// Проверка подписи манифеста
function verifyManifestSignature(manifestData, signature, secretKey) {
    const expectedSignature = generateManifestSignature(manifestData, secretKey);
    return crypto.timingSafeEqual(
        Buffer.from(signature, 'hex'),
        Buffer.from(expectedSignature, 'hex')
    );
}

// Пример манифеста с подписью
function createSecureManifest(baseManifest, secretKey) {
    const signature = generateManifestSignature(baseManifest, secretKey);
    
    return {
        ...baseManifest,
        _signature: signature,
        _timestamp: Date.now()
    };
}
```

## Защита от атак подмены манифеста

### Проверка целостности манифеста

```javascript
// Клиентская проверка целостности манифеста
class ManifestIntegrityChecker {
    constructor(expectedIntegrity) {
        this.expectedIntegrity = expectedIntegrity;
    }
    
    async verifyManifest(manifest) {
        // Вычисление хэша манифеста
        const manifestString = JSON.stringify(manifest);
        const hashBuffer = await crypto.subtle.digest('SHA-256', 
            new TextEncoder().encode(manifestString));
        const actualIntegrity = 'sha256-' + Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        
        // Сравнение с ожидаемой целостностью
        return actualIntegrity === this.expectedIntegrity;
    }
    
    async fetchAndVerify(url, expectedIntegrity) {
        const response = await fetch(url);
        const manifest = await response.json();
        
        if (!(await this.verifyManifest(manifest))) {
            throw new Error('Манифест не прошел проверку целостности');
        }
        
        return manifest;
    }
}

// Использование
const checker = new ManifestIntegrityChecker('sha256-expected-hash-here');
checker.fetchAndVerify('/manifest.json', 'sha256-expected-hash-here')
    .then(manifest => console.log('Манифест проверен и безопасен'))
    .catch(err => console.error('Манифест скомпрометирован:', err));
```

## Безопасность иконок в манифесте

### Проверка иконок

```javascript
// Проверка безопасности иконок из манифеста
async function validateManifestIcons(manifest) {
    if (!manifest.icons) return;
    
    for (const icon of manifest.icons) {
        const iconUrl = new URL(icon.src, window.location).href;
        
        // Проверка, что иконка с того же домена
        if (!iconUrl.startsWith(window.location.origin)) {
            console.warn('Обнаружена иконка с внешнего домена:', iconUrl);
            continue;
        }
        
        // Проверка типа файла
        if (!isValidImageType(icon.type)) {
            throw new Error(`Неподдерживаемый тип иконки: ${icon.type}`);
        }
        
        // Проверка размеров
        if (!isValidIconSize(icon.sizes)) {
            throw new Error(`Невалидный размер иконки: ${icon.sizes}`);
        }
    }
}

function isValidImageType(type) {
    return ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/svg+xml'].includes(type);
}

function isValidIconSize(sizes) {
    const sizePattern = /^(\d+)x(\d+)$/;
    return sizes.split(/\s+/).every(size => sizePattern.test(size));
}
```

## Динамическая генерация манифеста

### Генерация персонализированного манифеста

```javascript
// Серверная генерация персонализированного манифеста
app.get('/manifest/:userId.json', authenticateUser, (req, res) => {
    const userId = req.params.userId;
    const user = req.user;
    
    // Проверка, что пользователь запрашивает свой манифест
    if (user.id !== userId) {
        res.status(403).send('Доступ запрещен');
        return;
    }
    
    // Генерация персонализированного манифеста
    const personalizedManifest = {
        ...baseManifest,
        name: `${user.name} - Мое PWA`,
        short_name: `${user.name}`,
        start_url: `/dashboard?userId=${userId}`,
        // Добавление персонализированных иконок
        icons: getPersonalizedIcons(user.theme)
    };
    
    res.setHeader('Content-Type', 'application/manifest+json');
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.json(personalizedManifest);
});

function getPersonalizedIcons(theme) {
    // Возвращение иконок в зависимости от темы пользователя
    const themeIcons = {
        light: [
            { src: '/icons/light/icon-192x192.png', sizes: '192x192', type: 'image/png' }
        ],
        dark: [
            { src: '/icons/dark/icon-192x192.png', sizes: '192x192', type: 'image/png' }
        ]
    };
    
    return themeIcons[theme] || themeIcons.light;
}
```

## Мониторинг и аудит манифеста

### Логирование изменений манифеста

```javascript
// Серверное логирование изменений манифеста
class ManifestAuditLogger {
    static logManifestAccess(userId, manifestVersion, ipAddress) {
        const logEntry = {
            event: 'manifest_access',
            userId,
            manifestVersion,
            ipAddress,
            userAgent: globalThis.userAgent || 'unknown',
            timestamp: new Date().toISOString()
        };
        
        // Логирование в безопасное хранилище
        secureLogStorage.write(logEntry);
    }
    
    static logManifestChange(oldManifest, newManifest, changedBy) {
        const changeLog = {
            event: 'manifest_change',
            oldVersion: this.calculateManifestHash(oldManifest),
            newVersion: this.calculateManifestHash(newManifest),
            changedBy,
            changes: this.diffManifests(oldManifest, newManifest),
            timestamp: new Date().toISOString()
        };
        
        secureLogStorage.write(changeLog);
    }
    
    static calculateManifestHash(manifest) {
        const manifestString = JSON.stringify(manifest);
        return crypto.createHash('sha256').update(manifestString).digest('hex');
    }
    
    static diffManifests(oldManifest, newManifest) {
        // Реализация сравнения манифестов
        const changes = [];
        
        for (const key in newManifest) {
            if (JSON.stringify(oldManifest[key]) !== JSON.stringify(newManifest[key])) {
                changes.push({
                    field: key,
                    oldValue: oldManifest[key],
                    newValue: newManifest[key]
                });
            }
        }
        
        return changes;
    }
}
```

## Рекомендации по безопасности

- [[Лучшие-практики-безопасности-PWA]] - общие практики безопасности PWA
- [[Безопасность-сервис-воркеров]] - безопасность сервис-воркеров
- [[Безопасность-оффлайн-данных]] - безопасность данных в оффлайн режиме
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[Content-Security-Policy]] - политика безопасности контента

## Заключение

Безопасность манифеста веб-приложения требует комплексного подхода, включающего правильные HTTP-заголовки, проверку структуры, защиту от подделки и мониторинг изменений. Манифест должен быть защищен как с серверной, так и с клиентской стороны.