---
aliases: ["Метрики безопасности производительности", "Мониторинг безопасности", "Измерение безопасности"]
tags: [security, performance, metrics, monitoring, measurement]
---

# Метрики безопасности производительности

## Введение в метрики безопасности производительности

Метрики безопасности производительности - это количественные и качественные показатели, которые позволяют оценить баланс между обеспечением безопасности приложения и его производительностью. Эти метрики помогают разработчикам и специалистам по безопасности принимать обоснованные решения о том, как оптимизировать системы для достижения максимальной безопасности при минимальном влиянии на производительность.

> [!tip]
> Регулярный мониторинг метрик безопасности производительности позволяет выявлять узкие места и оптимизировать системы до того, как они станут критическими.

## Основные метрики безопасности

### 1. Время отклика с учетом безопасности

Время, необходимое для обработки запроса с выполнением всех проверок безопасности:

```javascript
// Система измерения времени отклика
class ResponseTimeMetrics {
  constructor() {
    this.responseTimes = [];
    this.securityChecks = 0;
    this.totalRequests = 0;
  }
  
  async measureResponseTime(requestHandler, request) {
    const startTime = performance.now();
    
    try {
      const result = await requestHandler(request);
      const endTime = performance.now();
      const responseTime = endTime - startTime;
      
      // Логирование времени отклика
      this.recordResponseTime(responseTime, request.securityLevel);
      
      return result;
    } catch (error) {
      const endTime = performance.now();
      const responseTime = endTime - startTime;
      
      // Логирование времени отклика даже при ошибках
      this.recordResponseTime(responseTime, request.securityLevel, true);
      
      throw error;
    }
  }
  
  recordResponseTime(time, securityLevel, isError = false) {
    this.responseTimes.push({
      time,
      securityLevel,
      isError,
      timestamp: Date.now()
    });
    
    this.totalRequests++;
  }
  
  getAverageResponseTime(securityLevel = null) {
    let filteredTimes = this.responseTimes;
    
    if (securityLevel) {
      filteredTimes = filteredTimes.filter(rt => rt.securityLevel === securityLevel);
    }
    
    if (filteredTimes.length === 0) return 0;
    
    const sum = filteredTimes.reduce((acc, rt) => acc + rt.time, 0);
    return sum / filteredTimes.length;
  }
  
  getPercentileResponseTime(percentile, securityLevel = null) {
    let filteredTimes = this.responseTimes;
    
    if (securityLevel) {
      filteredTimes = filteredTimes.filter(rt => rt.securityLevel === securityLevel);
    }
    
    if (filteredTimes.length === 0) return 0;
    
    const sortedTimes = filteredTimes
      .map(rt => rt.time)
      .sort((a, b) => a - b);
    
    const index = Math.floor((percentile / 100) * sortedTimes.length);
    return sortedTimes[index] || 0;
  }
}
```

### 2. Частота выполнения проверок безопасности

Количество выполненных проверок безопасности в единицу времени:

```javascript
// Мониторинг частоты проверок безопасности
class SecurityCheckMetrics {
  constructor() {
    this.checkCounters = new Map();
    this.checkTimings = new Map();
    this.checkSuccessRates = new Map();
  }
  
  recordCheck(checkType, success, executionTime) {
    // Учет количества проверок
    const count = this.checkCounters.get(checkType) || 0;
    this.checkCounters.set(checkType, count + 1);
    
    // Учет времени выполнения
    const timing = this.checkTimings.get(checkType) || [];
    timing.push(executionTime);
    this.checkTimings.set(checkType, timing);
    
    // Учет успешности
    const successRate = this.checkSuccessRates.get(checkType) || { success: 0, total: 0 };
    successRate.total++;
    if (success) {
      successRate.success++;
    }
    this.checkSuccessRates.set(checkType, successRate);
  }
  
  getCheckFrequency(checkType, timeWindow = 60000) { // 1 минута
    const counter = this.checkCounters.get(checkType) || 0;
    return counter / (timeWindow / 1000); // проверок в секунду
  }
  
  getAverageCheckTime(checkType) {
    const timings = this.checkTimings.get(checkType) || [];
    if (timings.length === 0) return 0;
    
    const sum = timings.reduce((acc, time) => acc + time, 0);
    return sum / timings.length;
  }
  
  getSuccessRate(checkType) {
    const rate = this.checkSuccessRates.get(checkType);
    if (!rate || rate.total === 0) return 0;
    
    return rate.success / rate.total;
  }
}
```

### 3. Эффективность обнаружения угроз

Процент обнаруженных угроз по сравнению с общим количеством атак:

```javascript
// Метрики эффективности обнаружения угроз
class ThreatDetectionMetrics {
  constructor() {
    this.totalAttacks = 0;
    this.detectedAttacks = 0;
    this.falsePositives = 0;
    this.falseNegatives = 0;
  }
  
  recordAttack(attackType, detected, wasReal) {
    this.totalAttacks++;
    
    if (detected && wasReal) {
      this.detectedAttacks++; // Правильное обнаружение
    } else if (detected && !wasReal) {
      this.falsePositives++; // Ложное срабатывание
    } else if (!detected && wasReal) {
      this.falseNegatives++; // Пропущенная угроза
    }
  }
  
  getDetectionRate() {
    return this.totalAttacks > 0 ? this.detectedAttacks / this.totalAttacks : 0;
  }
  
  getFalsePositiveRate() {
    return this.totalAttacks > 0 ? this.falsePositives / this.totalAttacks : 0;
  }
  
  getFalseNegativeRate() {
    return this.totalAttacks > 0 ? this.falseNegatives / this.totalAttacks : 0;
  }
  
  getPrecision() {
    const detected = this.detectedAttacks + this.falsePositives;
    return detected > 0 ? this.detectedAttacks / detected : 0;
  }
  
  getRecall() {
    const realAttacks = this.detectedAttacks + this.falseNegatives;
    return realAttacks > 0 ? this.detectedAttacks / realAttacks : 0;
  }
  
  getF1Score() {
    const precision = this.getPrecision();
    const recall = this.getRecall();
    
    if (precision + recall === 0) return 0;
    return 2 * (precision * recall) / (precision + recall);
  }
}
```

## Метрики производительности безопасности

### 1. Влияние безопасности на общую производительность

Измерение снижения производительности из-за мер безопасности:

```javascript
// Сравнение производительности с и без мер безопасности
class PerformanceImpactMetrics {
  constructor() {
    this.baselineMetrics = {
      requestsPerSecond: 0,
      averageResponseTime: 0,
      cpuUsage: 0,
      memoryUsage: 0
    };
    
    this.secureMetrics = {
      requestsPerSecond: 0,
      averageResponseTime: 0,
      cpuUsage: 0,
      memoryUsage: 0
    };
  }
  
  setBaseline(metrics) {
    this.baselineMetrics = { ...metrics };
  }
  
  setSecureMetrics(metrics) {
    this.secureMetrics = { ...metrics };
  }
  
  getPerformanceImpact() {
    return {
      throughputImpact: this.calculateThroughputImpact(),
      responseTimeImpact: this.calculateResponseTimeImpact(),
      resourceImpact: this.calculateResourceImpact()
    };
  }
  
  calculateThroughputImpact() {
    if (this.baselineMetrics.requestsPerSecond === 0) return 0;
    
    return (this.baselineMetrics.requestsPerSecond - this.secureMetrics.requestsPerSecond) / 
           this.baselineMetrics.requestsPerSecond * 100;
  }
  
  calculateResponseTimeImpact() {
    if (this.baselineMetrics.averageResponseTime === 0) return 0;
    
    return (this.secureMetrics.averageResponseTime - this.baselineMetrics.averageResponseTime) / 
           this.baselineMetrics.averageResponseTime * 100;
  }
  
  calculateResourceImpact() {
    return {
      cpu: (this.secureMetrics.cpuUsage - this.baselineMetrics.cpuUsage) / 
           this.baselineMetrics.cpuUsage * 100,
      memory: (this.secureMetrics.memoryUsage - this.baselineMetrics.memoryUsage) / 
              this.baselineMetrics.memoryUsage * 100
    };
  }
}
```

### 2. Эффективность кэширования безопасности

Процент запросов, обслуживаемых из кэша безопасности:

```javascript
// Метрики эффективности кэширования безопасности
class SecurityCacheMetrics {
  constructor() {
    this.cacheHits = 0;
    this.cacheMisses = 0;
    this.cacheEvictions = 0;
    this.totalRequests = 0;
  }
  
  recordCacheHit() {
    this.cacheHits++;
    this.totalRequests++;
  }
  
  recordCacheMiss() {
    this.cacheMisses++;
    this.totalRequests++;
  }
  
  recordCacheEviction() {
    this.cacheEvictions++;
  }
  
  getHitRate() {
    if (this.totalRequests === 0) return 0;
    return this.cacheHits / this.totalRequests;
  }
  
  getMissRate() {
    if (this.totalRequests === 0) return 0;
    return this.cacheMisses / this.totalRequests;
  }
  
  getHitRatio() {
    if ((this.cacheHits + this.cacheMisses) === 0) return 0;
    return this.cacheHits / (this.cacheHits + this.cacheMisses);
  }
  
  getCacheEfficiency() {
    // Комбинированная метрика эффективности кэша
    const hitRate = this.getHitRate();
    const missPenalty = this.cacheMisses * 0.1; // Условный штраф за промахи
    
    return Math.max(0, hitRate - missPenalty);
  }
}
```

## Специфические метрики для различных аспектов безопасности

### 1. Метрики аутентификации

```javascript
// Метрики производительности аутентификации
class AuthenticationMetrics {
  constructor() {
    this.authAttempts = 0;
    this.successfulAuths = 0;
    this.failedAuths = 0;
    this.avgAuthTime = 0;
    this.authTimings = [];
  }
  
  recordAuthentication(success, executionTime) {
    this.authAttempts++;
    this.authTimings.push(executionTime);
    
    if (success) {
      this.successfulAuths++;
    } else {
      this.failedAuths++;
    }
    
    // Обновление среднего времени аутентификации
    this.avgAuthTime = this.authTimings.reduce((a, b) => a + b, 0) / this.authTimings.length;
  }
  
  getSuccessRate() {
    return this.authAttempts > 0 ? this.successfulAuths / this.authAttempts : 0;
  }
  
  getFailureRate() {
    return this.authAttempts > 0 ? this.failedAuths / this.authAttempts : 0;
  }
  
  getPercentileTime(percentile) {
    const sorted = [...this.authTimings].sort((a, b) => a - b);
    const index = Math.floor((percentile / 100) * sorted.length);
    return sorted[index] || 0;
  }
  
  getAvgTime() {
    return this.avgAuthTime;
  }
}
```

### 2. Метрики валидации входных данных

```javascript
// Метрики производительности валидации
class ValidationMetrics {
  constructor() {
    this.validationCount = 0;
    this.validInputs = 0;
    this.invalidInputs = 0;
    this.avgValidationTime = 0;
    this.validationTimings = [];
  }
  
  recordValidation(isValid, executionTime) {
    this.validationCount++;
    this.validationTimings.push(executionTime);
    
    if (isValid) {
      this.validInputs++;
    } else {
      this.invalidInputs++;
    }
    
    this.avgValidationTime = this.validationTimings.reduce((a, b) => a + b, 0) / this.validationTimings.length;
  }
  
  getValidationRate() {
    return {
      valid: this.validationCount > 0 ? this.validInputs / this.validationCount : 0,
      invalid: this.validationCount > 0 ? this.invalidInputs / this.validationCount : 0
    };
  }
  
  getAvgValidationTime() {
    return this.avgValidationTime;
  }
  
  getThroughput() {
    // Валидаций в секунду
    if (this.validationTimings.length === 0) return 0;
    
    const totalTime = this.validationTimings.reduce((a, b) => a + b, 0);
    return this.validationCount / (totalTime / 1000); // преобразование в секунды
  }
}
```

### 3. Метрики шифрования

```javascript
// Метрики производительности шифрования
class EncryptionMetrics {
  constructor() {
    this.encryptionOperations = 0;
    this.decryptionOperations = 0;
    this.totalEncryptedBytes = 0;
    this.totalDecryptedBytes = 0;
    this.avgEncryptionTime = 0;
    this.avgDecryptionTime = 0;
    this.encryptionTimings = [];
    this.decryptionTimings = [];
  }
  
  recordEncryption(bytes, executionTime) {
    this.encryptionOperations++;
    this.totalEncryptedBytes += bytes;
    this.encryptionTimings.push(executionTime);
    
    this.avgEncryptionTime = this.encryptionTimings.reduce((a, b) => a + b, 0) / this.encryptionTimings.length;
  }
  
  recordDecryption(bytes, executionTime) {
    this.decryptionOperations++;
    this.totalDecryptedBytes += bytes;
    this.decryptionTimings.push(executionTime);
    
    this.avgDecryptionTime = this.decryptionTimings.reduce((a, b) => a + b, 0) / this.decryptionTimings.length;
  }
  
  getEncryptionThroughput() {
    // МБ/с
    if (this.encryptionTimings.length === 0) return 0;
    
    const totalTime = this.encryptionTimings.reduce((a, b) => a + b, 0) / 1000; // в секундах
    const totalMB = this.totalEncryptedBytes / (1024 * 1024); // в мегабайтах
    
    return totalTime > 0 ? totalMB / totalTime : 0;
  }
  
  getDecryptionThroughput() {
    // МБ/с
    if (this.decryptionTimings.length === 0) return 0;
    
    const totalTime = this.decryptionTimings.reduce((a, b) => a + b, 0) / 1000; // в секундах
    const totalMB = this.totalDecryptedBytes / (1024 * 1024); // в мегабайтах
    
    return totalTime > 0 ? totalMB / totalTime : 0;
  }
  
  getOperationsPerSecond() {
    const totalOperations = this.encryptionOperations + this.decryptionOperations;
    const totalTime = (this.encryptionTimings.reduce((a, b) => a + b, 0) + 
                      this.decryptionTimings.reduce((a, b) => a + b, 0)) / 1000; // в секундах
    
    return totalTime > 0 ? totalOperations / totalTime : 0;
  }
}
```

## Система сбора и агрегации метрик

### 1. Централизованная система метрик

```javascript
// Централизованная система сбора метрик безопасности
class SecurityMetricsCollector {
  constructor() {
    this.metrics = {
      responseTime: new ResponseTimeMetrics(),
      securityChecks: new SecurityCheckMetrics(),
      threatDetection: new ThreatDetectionMetrics(),
      auth: new AuthenticationMetrics(),
      validation: new ValidationMetrics(),
      encryption: new EncryptionMetrics(),
      cache: new SecurityCacheMetrics()
    };
    
    this.aggregatedMetrics = {};
  }
  
  // Методы для записи метрик
  recordResponseTime(time, securityLevel, isError = false) {
    this.metrics.responseTime.recordResponseTime(time, securityLevel, isError);
  }
  
  recordSecurityCheck(checkType, success, executionTime) {
    this.metrics.securityChecks.recordCheck(checkType, success, executionTime);
  }
  
  recordThreat(attackType, detected, wasReal) {
    this.metrics.threatDetection.recordAttack(attackType, detected, wasReal);
  }
  
  recordAuthentication(success, executionTime) {
    this.metrics.auth.recordAuthentication(success, executionTime);
  }
  
  recordValidation(isValid, executionTime) {
    this.metrics.validation.recordValidation(isValid, executionTime);
  }
  
  recordEncryption(bytes, executionTime) {
    this.metrics.encryption.recordEncryption(bytes, executionTime);
  }
  
  recordDecryption(bytes, executionTime) {
    this.metrics.encryption.recordDecryption(bytes, executionTime);
  }
  
  recordCacheHit() {
    this.metrics.cache.recordCacheHit();
  }
  
  recordCacheMiss() {
    this.metrics.cache.recordCacheMiss();
  }
  
  // Методы для получения метрик
  getMetricsReport() {
    return {
      responseTime: {
        avg: this.metrics.responseTime.getAverageResponseTime(),
        p95: this.metrics.responseTime.getPercentileResponseTime(95),
        p99: this.metrics.responseTime.getPercentileResponseTime(99)
      },
      securityChecks: {
        frequencies: this.getCheckFrequencies(),
        avgTimes: this.getCheckAverageTimes(),
        successRates: this.getCheckSuccessRates()
      },
      threatDetection: {
        detectionRate: this.metrics.threatDetection.getDetectionRate(),
        falsePositiveRate: this.metrics.threatDetection.getFalsePositiveRate(),
        f1Score: this.metrics.threatDetection.getF1Score()
      },
      authentication: {
        successRate: this.metrics.auth.getSuccessRate(),
        avgTime: this.metrics.auth.getAvgTime(),
        p95Time: this.metrics.auth.getPercentileTime(95)
      },
      validation: {
        rates: this.metrics.validation.getValidationRate(),
        avgTime: this.metrics.validation.getAvgValidationTime(),
        throughput: this.metrics.validation.getThroughput()
      },
      encryption: {
        encThroughput: this.metrics.encryption.getEncryptionThroughput(),
        decThroughput: this.metrics.encryption.getDecryptionThroughput(),
        opsPerSecond: this.metrics.encryption.getOperationsPerSecond()
      },
      cache: {
        hitRate: this.metrics.cache.getHitRate(),
        efficiency: this.metrics.cache.getCacheEfficiency()
      }
    };
  }
  
  getCheckFrequencies() {
    const frequencies = {};
    for (const [type] of this.metrics.securityChecks.checkCounters) {
      frequencies[type] = this.metrics.securityChecks.getCheckFrequency(type);
    }
    return frequencies;
  }
  
  getCheckAverageTimes() {
    const avgTimes = {};
    for (const [type] of this.metrics.securityChecks.checkTimings) {
      avgTimes[type] = this.metrics.securityChecks.getAverageCheckTime(type);
    }
    return avgTimes;
  }
  
  getCheckSuccessRates() {
    const successRates = {};
    for (const [type] of this.metrics.securityChecks.checkSuccessRates) {
      successRates[type] = this.metrics.securityChecks.getSuccessRate(type);
    }
    return successRates;
  }
}
```

### 2. Визуализация метрик

```javascript
// Класс для визуализации метрик
class MetricsVisualizer {
  static createDashboard(metricsReport) {
    // Создание визуального представления метрик
    const dashboard = {
      title: 'Метрики безопасности и производительности',
      timestamp: new Date().toISOString(),
      sections: [
        this.createResponseTimeSection(metricsReport.responseTime),
        this.createSecurityChecksSection(metricsReport.securityChecks),
        this.createThreatDetectionSection(metricsReport.threatDetection),
        this.createAuthenticationSection(metricsReport.authentication),
        this.createValidationSection(metricsReport.validation),
        this.createEncryptionSection(metricsReport.encryption),
        this.createCacheSection(metricsReport.cache)
      ]
    };
    
    return dashboard;
  }
  
  static createResponseTimeSection(data) {
    return {
      title: 'Время отклика',
      metrics: [
        { name: 'Среднее время', value: `${data.avg.toFixed(2)}ms` },
        { name: '95-й перцентиль', value: `${data.p95.toFixed(2)}ms` },
        { name: '99-й перцентиль', value: `${data.p99.toFixed(2)}ms` }
      ],
      status: this.getPerformanceStatus(data.avg, 200, 500) // пороги условные
    };
  }
  
  static createSecurityChecksSection(data) {
    return {
      title: 'Проверки безопасности',
      metrics: [
        { name: 'Частота проверок', value: `${Object.values(data.frequencies).reduce((a, b) => a + b, 0).toFixed(2)}/с` },
        { name: 'Среднее время проверки', value: `${Object.values(data.avgTimes).reduce((a, b) => a + b, 0) / Object.keys(data.avgTimes).length || 0}ms` },
        { name: 'Средняя успешность', value: `${(Object.values(data.successRates).reduce((a, b) => a + b, 0) / Object.keys(data.successRates).length || 0 * 100).toFixed(2)}%` }
      ]
    };
  }
  
  static createThreatDetectionSection(data) {
    return {
      title: 'Обнаружение угроз',
      metrics: [
        { name: 'Ставка обнаружения', value: `${(data.detectionRate * 100).toFixed(2)}%` },
        { name: 'Ставка ложных срабатываний', value: `${(data.falsePositiveRate * 100).toFixed(2)}%` },
        { name: 'F1-оценка', value: data.f1Score.toFixed(3) }
      ],
      status: data.f1Score > 0.8 ? 'good' : data.f1Score > 0.5 ? 'warning' : 'critical'
    };
  }
  
  static getPerformanceStatus(value, warningThreshold, criticalThreshold) {
    if (value > criticalThreshold) return 'critical';
    if (value > warningThreshold) return 'warning';
    return 'good';
  }
}
```

## Практические примеры использования метрик

### 1. Мониторинг в реальном времени

```javascript
// Система мониторинга в реальном времени
class RealTimeSecurityMonitor {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
    this.alertThresholds = {
      responseTime: 500, // ms
      falsePositiveRate: 0.05, // 5%
      detectionRate: 0.8, // 80%
      cacheHitRate: 0.7 // 70%
    };
    this.alerts = [];
  }
  
  async monitor() {
    // Проверка метрик на превышение порогов
    const report = this.metricsCollector.getMetricsReport();
    
    this.checkResponseTime(report.responseTime.avg);
    this.checkFalsePositiveRate(report.threatDetection.falsePositiveRate);
    this.checkDetectionRate(report.threatDetection.detectionRate);
    this.checkCacheHitRate(report.cache.hitRate);
    
    return this.alerts;
  }
  
  checkResponseTime(avgTime) {
    if (avgTime > this.alertThresholds.responseTime) {
      this.alerts.push({
        type: 'performance',
        severity: 'high',
        message: `Среднее время отклика превышает порог: ${avgTime}ms > ${this.alertThresholds.responseTime}ms`,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  checkFalsePositiveRate(rate) {
    if (rate > this.alertThresholds.falsePositiveRate) {
      this.alerts.push({
        type: 'security',
        severity: 'medium',
        message: `Ставка ложных срабатываний превышает порог: ${(rate * 100).toFixed(2)}% > ${(this.alertThresholds.falsePositiveRate * 100).toFixed(2)}%`,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  checkDetectionRate(rate) {
    if (rate < this.alertThresholds.detectionRate) {
      this.alerts.push({
        type: 'security',
        severity: 'high',
        message: `Ставка обнаружения ниже порога: ${(rate * 100).toFixed(2)}% < ${(this.alertThresholds.detectionRate * 100).toFixed(2)}%`,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  checkCacheHitRate(rate) {
    if (rate < this.alertThresholds.cacheHitRate) {
      this.alerts.push({
        type: 'performance',
        severity: 'medium',
        message: `Ставка попадания в кэш ниже порога: ${(rate * 100).toFixed(2)}% < ${(this.alertThresholds.cacheHitRate * 100).toFixed(2)}%`,
        timestamp: new Date().toISOString()
      });
    }
  }
}
```

### 2. Отчетность и анализ

```javascript
// Система отчетности по метрикам
class SecurityMetricsReporter {
  static generateReport(metricsCollector, period = 'daily') {
    const report = metricsCollector.getMetricsReport();
    
    return {
      period,
      generatedAt: new Date().toISOString(),
      summary: {
        responseTime: this.formatResponseTimeSummary(report.responseTime),
        securityEffectiveness: this.formatSecurityEffectiveness(report.threatDetection),
        performanceImpact: this.formatPerformanceMetrics(report),
        recommendations: this.generateRecommendations(report)
      },
      detailedMetrics: report
    };
  }
  
  static formatResponseTimeSummary(responseTime) {
    return {
      average: `${responseTime.avg.toFixed(2)}ms`,
      percentile95: `${responseTime.p95.toFixed(2)}ms`,
      percentile99: `${responseTime.p99.toFixed(2)}ms`,
      trend: this.analyzeTrend(responseTime)
    };
  }
  
  static formatSecurityEffectiveness(threatDetection) {
    return {
      detectionRate: `${(threatDetection.detectionRate * 100).toFixed(2)}%`,
      falsePositiveRate: `${(threatDetection.falsePositiveRate * 100).toFixed(2)}%`,
      f1Score: threatDetection.f1Score.toFixed(3),
      overallEffectiveness: this.calculateOverallEffectiveness(threatDetection)
    };
  }
  
  static formatPerformanceMetrics(report) {
    return {
      authPerformance: {
        avgTime: `${report.authentication.avgTime.toFixed(2)}ms`,
        throughput: `${report.validation.throughput.toFixed(2)}/s`
      },
      validationPerformance: {
        avgTime: `${report.validation.avgTime.toFixed(2)}ms`,
        throughput: `${report.validation.throughput.toFixed(2)}/s`
      },
      encryptionPerformance: {
        throughput: {
          encryption: `${report.encryption.encThroughput.toFixed(2)} MB/s`,
          decryption: `${report.encryption.decThroughput.toFixed(2)} MB/s`
        }
      }
    };
  }
  
  static generateRecommendations(report) {
    const recommendations = [];
    
    // Рекомендации по производительности
    if (report.responseTime.avg > 300) {
      recommendations.push('Рассмотрите оптимизацию проверок безопасности для снижения времени отклика');
    }
    
    // Рекомендации по безопасности
    if (report.threatDetection.falsePositiveRate > 0.1) {
      recommendations.push('Снижение ставки ложных срабатываний для улучшения UX');
    }
    
    if (report.threatDetection.detectionRate < 0.85) {
      recommendations.push('Улучшение алгоритмов обнаружения угроз');
    }
    
    // Рекомендации по кэшированию
    if (report.cache.hitRate < 0.8) {
      recommendations.push('Оптимизация стратегии кэширования безопасности');
    }
    
    return recommendations;
  }
  
  static calculateOverallEffectiveness(threatDetection) {
    // Комбинированная оценка эффективности безопасности
    const detectionWeight = 0.6;
    const falsePositiveWeight = 0.4;
    
    return (threatDetection.detectionRate * detectionWeight) + 
           ((1 - threatDetection.falsePositiveRate) * falsePositiveWeight);
  }
  
  static analyzeTrend(responseTime) {
    // Упрощенный анализ тренда (в реальном приложении потребуется больше данных)
    return 'stable'; // или 'increasing', 'decreasing'
  }
}
```

## Лучшие практики измерения метрик

### 1. Регулярный сбор и агрегация

```javascript
// Регулярный сбор метрик
class MetricsAggregator {
  constructor(metricsCollector) {
    this.metricsCollector = metricsCollector;
    this.aggregationPeriod = 60000; // 1 минута
    this.aggregatedData = [];
  }
  
  startAggregation() {
    setInterval(() => {
      const currentReport = this.metricsCollector.getMetricsReport();
      this.aggregatedData.push({
        timestamp: new Date().toISOString(),
        data: currentReport
      });
      
      // Ограничение размера хранимых данных
      if (this.aggregatedData.length > 1440) { // 24 часа с интервалом 1 минута
        this.aggregatedData.shift();
      }
    }, this.aggregationPeriod);
  }
  
  getHistoricalData(hours = 1) {
    const cutoffTime = Date.now() - (hours * 60 * 60 * 1000);
    return this.aggregatedData.filter(item => 
      new Date(item.timestamp).getTime() > cutoffTime
    );
  }
  
  getTrend(metricPath, hours = 1) {
    const historicalData = this.getHistoricalData(hours);
    if (historicalData.length < 2) return 'insufficient_data';
    
    const values = historicalData.map(item => this.getNestedValue(item.data, metricPath));
    const first = values[0];
    const last = values[values.length - 1];
    
    if (last > first * 1.1) return 'increasing';
    if (last < first * 0.9) return 'decreasing';
    return 'stable';
  }
  
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => current && current[key], obj);
  }
}
```

### 2. Установка порогов и алертов

```javascript
// Система управления порогами
class ThresholdManager {
  constructor() {
    this.thresholds = {
      responseTime: { warning: 200, critical: 500 }, // ms
      detectionRate: { warning: 0.7, critical: 0.5 }, // fraction
      falsePositiveRate: { warning: 0.1, critical: 0.2 }, // fraction
      cacheHitRate: { warning: 0.8, critical: 0.6 } // fraction
    };
    
    this.callbacks = new Map();
  }
  
  setThreshold(metric, level, value) {
    if (!this.thresholds[metric]) {
      this.thresholds[metric] = {};
    }
    this.thresholds[metric][level] = value;
  }
  
  checkThreshold(metric, value) {
    const thresholds = this.thresholds[metric];
    if (!thresholds) return 'normal';
    
    if (value >= thresholds.critical) return 'critical';
    if (value >= thresholds.warning) return 'warning';
    return 'normal';
  }
  
  onThresholdCrossed(metric, callback) {
    if (!this.callbacks.has(metric)) {
      this.callbacks.set(metric, []);
    }
    this.callbacks.get(metric).push(callback);
  }
  
  notifyIfThresholdCrossed(metric, value) {
    const level = this.checkThreshold(metric, value);
    if (level !== 'normal' && this.callbacks.has(metric)) {
      this.callbacks.get(metric).forEach(callback => callback(metric, value, level));
    }
  }
}
```

## Связанные темы

- [[Баланс-безопасности-и-производительности]] - баланс между безопасностью и производительностью
- [[Оптимизированные-реализации-безопасности]] - эффективные реализации безопасности
- [[Эффективные-проверки-безопасности]] - оптимизированные методы проверки безопасности
- [[Тестирование-безопасности]] - методы тестирования безопасности приложений
- [[Анализ-логов]] - анализ логов для обнаружения проблем безопасности
- [[Мониторинг-безопасности]] - мониторинг безопасности в реальном времени
- [[Безопасное-кэширование]] - безопасное кэширование данных
- [[Шифрование-на-клиенте]] - шифрование данных на стороне клиента
- [[Управление-сессиями-и-аутентификацией]] - безопасное управление сессиями
- [[Защита-от-инъекций]] - защита от различных типов инъекций
- [[XSS-защита]] - защита от межсайтового скриптинга
- [[CSRF-защита]] - защита от подделки межсайтовых запросов
- [[Content-Security-Policy]] - политика безопасности контента
- [[HTTP-Security-Headers]] - заголовки безопасности HTTP
- [[Secure-Coding-Practices]] - лучшие практики безопасного программирования
- [[Dependency-Security]] - безопасность зависимостей
- [[Secure-Storage]] - безопасное хранение данных
- [[Безопасность-в-браузере]] - архитектура безопасности браузера
- [[Безопасность-форм]] - защита форм от атак
- [[Меры-против-ботов]] - защита от автоматизированных атак