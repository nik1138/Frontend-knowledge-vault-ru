---
aliases: ["Custom-Elements-Security", "Web-Components-Security"]
tags: [security, web-components, custom-elements]
---

# Безопасность настраиваемых элементов

## Введение

Настраиваемые элементы (Custom Elements) - это технология веб-компонентов, позволяющая разработчикам создавать собственные HTML-элементы с собственным поведением. Хотя настраиваемые элементы предоставляют мощные возможности для расширения HTML, они также создают новые векторы атак и требуют специального подхода к обеспечению безопасности.

## Основы настраиваемых элементов

Настраиваемые элементы определяются с помощью `customElements.define()` и наследуют от `HTMLElement` или его подклассов:

```javascript
class SecureCustomElement extends HTMLElement {
  constructor() {
    super();
    // Инициализация элемента
  }
  
  connectedCallback() {
    // Вызывается при добавлении элемента в DOM
  }
  
  disconnectedCallback() {
    // Вызывается при удалении из DOM
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    // Вызывается при изменении атрибута
  }
}

customElements.define('secure-element', SecureCustomElement);
```

## Потенциальные уязвимости

### 1. Уязвимости XSS через атрибуты

Настраиваемые элементы могут быть уязвимы к XSS-атакам, если не проверяют и не санируют значения атрибутов:

```javascript
// Потенциально уязвимый код
class VulnerableElement extends HTMLElement {
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'content') {
      this.innerHTML = newValue; // Уязвимость XSS
    }
  }
}
```

> [!warning] Важно
> Всегда санируйте пользовательский ввод перед вставкой в DOM, особенно в настраиваемых элементах.

### 2. Уязвимости через события

Настраиваемые элементы могут отправлять события, которые могут быть использованы для передачи конфиденциальных данных:

```javascript
// Потенциально опасный код
class LeakyElement extends HTMLElement {
  someMethod(data) {
    // Отправка конфиденциальных данных через событие
    this.dispatchEvent(new CustomEvent('data-exposed', {
      detail: { sensitiveInfo: this.internalData }
    }));
  }
}
```

### 3. Уязвимости через методы

Открытые методы настраиваемых элементов могут быть использованы для выполнения нежелательных действий:

```javascript
// Потенциально опасный метод
class DangerousElement extends HTMLElement {
  executeCode(code) {
    eval(code); // Опасное использование
  }
}
```

## Лучшие практики безопасности

### 1. Санитизация входных данных

Всегда санируйте все данные, полученные из атрибутов, свойств или событий:

```javascript
import DOMPurify from 'dompurify';

class SecureCustomElement extends HTMLElement {
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'content') {
      // Санитизация содержимого перед вставкой
      const cleanContent = DOMPurify.sanitize(newValue);
      this.textContent = cleanContent;
    }
  }
}
```

### 2. Валидация атрибутов

Определите список наблюдаемых атрибутов и валидируйте их значения:

```javascript
class ValidatedElement extends HTMLElement {
  static get observedAttributes() {
    return ['data-value', 'config'];
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    switch(name) {
      case 'data-value':
        if (!this.isValidValue(newValue)) {
          console.warn('Invalid value for data-value attribute');
          return;
        }
        this.updateValue(newValue);
        break;
      case 'config':
        this.updateConfig(this.parseConfig(newValue));
        break;
    }
  }
  
  isValidValue(value) {
    // Проверка значения
    return typeof value === 'string' && value.length < 100;
  }
}
```

### 3. Ограничение методов

Ограничьте количество открытых методов и используйте приватные поля для внутреннего состояния:

```javascript
class SecureElement extends HTMLElement {
  #internalState = {};
  
  constructor() {
    super();
    // Приватное состояние защищено
  }
  
  // Открытые методы с проверкой
  updateData(data) {
    if (!this.validateData(data)) {
      throw new Error('Invalid data');
    }
    this.#internalState = data;
    this.render();
  }
  
  #internalMethod() {
    // Приватный метод, недоступный извне
  }
}
```

## Защита от атак

### 1. Защита от неправильного использования

Обеспечьте, чтобы настраиваемые элементы не могли быть использованы не по назначению:

```javascript
class ProtectedElement extends HTMLElement {
  constructor() {
    super();
    
    // Защита от неправильного использования
    if (new.target !== ProtectedElement) {
      throw new TypeError('Cannot use ProtectedElement as mixin');
    }
  }
  
  connectedCallback() {
    // Проверка контекста использования
    if (!this.isValidParent()) {
      console.warn('Element used in invalid context');
    }
    
    this.initialize();
  }
  
  isValidParent() {
    // Проверка, что элемент используется в разрешенном контексте
    return this.parentElement?.tagName !== 'FORBIDDEN-TAG';
  }
}
```

### 2. Контроль доступа к DOM

Ограничьте возможность модификации DOM из настраиваемого элемента:

```javascript
class RestrictedElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({mode: 'closed'});
  }
  
  updateContent(content) {
    // Ограниченное обновление содержимого
    const allowedTags = ['div', 'span', 'p', 'strong', 'em'];
    
    // Проверка разрешенных тегов
    if (this.containsOnlyAllowedTags(content)) {
      this.shadowRoot.innerHTML = content;
    }
  }
  
  containsOnlyAllowedTags(html) {
    const temp = document.createElement('div');
    temp.innerHTML = html;
    const allElements = temp.querySelectorAll('*');
    
    for (let element of allElements) {
      if (!allowedTags.includes(element.tagName.toLowerCase())) {
        return false;
      }
    }
    return true;
  }
}
```

### 3. Защита от рекурсивных вызовов

Предотвратите рекурсивные вызовы, которые могут привести к исчерпанию стека:

```javascript
class NonRecursiveElement extends HTMLElement {
  #updating = false;
  
  updateState(newState) {
    if (this.#updating) {
      // Предотвращение рекурсивных вызовов
      return;
    }
    
    this.#updating = true;
    try {
      this.internalUpdate(newState);
    } finally {
      this.#updating = false;
    }
  }
}
```

## Проверка безопасности

### 1. Аудит настраиваемых элементов

Регулярно проводите аудит настраиваемых элементов на наличие уязвимостей:

- Проверьте все точки ввода данных
- Убедитесь в надлежащей санитизации
- Проверьте обработку событий
- Проверьте доступ к внутреннему состоянию

### 2. Тестирование на мутации

Тестируйте настраиваемые элементы на устойчивость к неожиданным изменениям DOM:

```javascript
// Тестирование на мутации
function testElementMutation(element) {
  // Попытка изменить внутреннюю структуру
  const originalShadow = element.shadowRoot;
  try {
    element.shadowRoot = null;
    if (element.shadowRoot !== originalShadow) {
      console.warn('Shadow DOM доступен для записи');
    }
  } catch(e) {
    // Ожидаемая ошибка
  }
}
```

### 3. Проверка на утечки данных

Убедитесь, что настраиваемые элементы не передают конфиденциальные данные:

```javascript
// Проверка утечки данных
function testForDataLeakage() {
  const element = document.createElement('secure-element');
  document.body.appendChild(element);
  
  const events = [];
  const originalDispatch = element.dispatchEvent;
  
  element.dispatchEvent = function(event) {
    events.push(event);
    return originalDispatch.call(this, event);
  };
  
  // Выполнение действий с элементом
  // Проверка событий на наличие конфиденциальных данных
}
```

## Совместимость и поддержка

### 1. Поддержка старых браузеров

При использовании полифилов для настраиваемых элементов учитывайте дополнительные риски безопасности:

```javascript
// Проверка поддержки нативных настраиваемых элементов
if (!window.customElements) {
  // Использование полифила с дополнительными проверками
  import('document-register-element').then(() => {
    // Дополнительные проверки безопасности при использовании полифила
  });
}
```

### 2. Обновление элементов

При обновлении настраиваемых элементов убедитесь, что не вносятся регрессии безопасности:

```javascript
// Пример безопасного обновления элемента
class UpdatableElement extends HTMLElement {
  static get version() {
    return '2.0.0';
  }
  
  connectedCallback() {
    if (this.dataset.version !== this.constructor.version) {
      this.migrate();
      this.dataset.version = this.constructor.version;
    }
  }
  
  migrate() {
    // Обновление данных с проверкой безопасности
  }
}
```

## Заключение

Безопасность настраиваемых элементов требует комплексного подхода, включающего:

- Санитизацию всех входных данных
- Ограничение открытого API
- Защиту внутреннего состояния
- Регулярный аудит и тестирование

> [!tip] Помните
> Настраиваемые элементы должны быть спроектированы с учетом принципа наименьших привилегий - предоставлять только необходимый минимум функциональности.

## Связанные темы

- [[Безопасность-веб-компонентов]]
- [[Безопасность-Shadow-DOM]]
- [[Изоляция-компонентов]]
- [[XSS-атаки]]
- [[Content-Security-Policy]]