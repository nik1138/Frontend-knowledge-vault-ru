---
aliases: ["Проверка лицензий", "License Compliance", "Лицензионное соответствие", "Проверка лицензий зависимостей"]
tags: ["#security", "#license-compliance", "#dependency-security", "#legal-compliance"]
---

# Проверка лицензий

## Введение

Проверка лицензий - это критически важный процесс, который обеспечивает соблюдение лицензионных требований при использовании внешних зависимостей. Несоблюдение лицензионных соглашений может привести к юридическим последствиям, финансовым штрафам и даже к запрету использования программного обеспечения.

## Типы лицензий

### 1. Permissive Licenses (Разрешительные лицензии)

```javascript
// Классификация разрешительных лицензий
class PermissiveLicenseChecker {
    constructor() {
        this.permissiveLicenses = [
            'MIT',
            'Apache-2.0',
            'BSD-2-Clause',
            'BSD-3-Clause',
            'ISC',
            'WTFPL',
            'Unlicense',
            'CC0-1.0'
        ];
        
        this.licenseInfo = {
            'MIT': {
                name: 'MIT License',
                description: 'Разрешительная лицензия с минимальными ограничениями',
                permissions: ['Commercial Use', 'Modification', 'Distribution', 'Private Use'],
                conditions: ['License and copyright notice'],
                limitations: ['Liability', 'Warranty'],
                compatibility: ['All permissive licenses']
            },
            'Apache-2.0': {
                name: 'Apache License 2.0',
                description: 'Разрешительная лицензия с дополнительными положениями о патентах',
                permissions: ['Commercial Use', 'Modification', 'Distribution', 'Patent Use', 'Private Use'],
                conditions: ['License and copyright notice', 'State Changes', 'Patent Grant'],
                limitations: ['Patent Use Rights', 'Liability'],
                compatibility: ['Apache 2.0', 'MIT', 'BSD variants']
            },
            'BSD-3-Clause': {
                name: 'BSD 3-Clause License',
                description: 'Разрешительная лицензия с ограничениями на использование имени',
                permissions: ['Commercial Use', 'Modification', 'Distribution', 'Private Use'],
                conditions: ['License and copyright notice', 'No endorsement'],
                limitations: ['Liability', 'Warranty'],
                compatibility: ['BSD variants', 'MIT', 'Apache 2.0']
            }
        };
    }
    
    isPermissive(license) {
        return this.permissiveLicenses.includes(license);
    }
    
    getLicenseInfo(license) {
        return this.licenseInfo[license] || null;
    }
    
    async checkPackageLicenseCompatibility(packageName, targetLicense) {
        try {
            const packageInfo = await this.getPackageInfo(packageName);
            const packageLicense = this.normalizeLicense(packageInfo.license);
            
            if (!packageLicense) {
                return {
                    compatible: false,
                    reason: 'No license specified',
                    packageInfo: packageInfo
                };
            }
            
            const compatibilityResult = this.checkLicenseCompatibility(packageLicense, targetLicense);
            
            return {
                compatible: compatibilityResult.compatible,
                reason: compatibilityResult.reason,
                compatibilityDetails: compatibilityResult.details,
                packageInfo: packageInfo,
                licenseInfo: this.getLicenseInfo(packageLicense)
            };
        } catch (error) {
            return {
                compatible: false,
                reason: `Failed to check license: ${error.message}`,
                error: true
            };
        }
    }
    
    checkLicenseCompatibility(packageLicense, targetLicense) {
        // Проверка совместимости лицензий
        if (packageLicense === targetLicense) {
            return { compatible: true, reason: 'Same license' };
        }
        
        // Проверка через базу данных совместимости
        const compatibilityDB = this.getCompatibilityDatabase();
        
        if (compatibilityDB[packageLicense]?.[targetLicense]) {
            return {
                compatible: compatibilityDB[packageLicense][targetLicense].compatible,
                reason: compatibilityDB[packageLicense][targetLicense].reason,
                details: compatibilityDB[packageLicense][targetLicense]
            };
        }
        
        // Для разрешительных лицензий обычно совместимы
        if (this.isPermissive(packageLicense) && this.isPermissive(targetLicense)) {
            return {
                compatible: true,
                reason: 'Both are permissive licenses',
                details: {
                    source: 'permissive_compatibility',
                    notes: 'Permissive licenses are typically compatible with each other'
                }
            };
        }
        
        return {
            compatible: false,
            reason: 'Licenses not explicitly marked as compatible',
            details: {
                source: 'default_logic',
                notes: 'Manual verification required for non-permissive combinations'
            }
        };
    }
    
    normalizeLicense(license) {
        if (!license) return null;
        
        // Приведение лицензии к нормальному формату
        if (typeof license === 'object') {
            return license.type || license.name || null;
        }
        
        if (Array.isArray(license)) {
            return license[0]; // берем первую лицензию
        }
        
        // Очистка от лишних символов и пробелов
        return license
            .replace(/\s+/g, '-')
            .replace(/\(|\)/g, '')
            .toUpperCase();
    }
    
    getCompatibilityDatabase() {
        // База данных совместимости лицензий
        return {
            'MIT': {
                'MIT': { compatible: true, reason: 'Same license' },
                'APACHE-2.0': { compatible: true, reason: 'MIT is compatible with Apache 2.0' },
                'BSD-3-CLAUSE': { compatible: true, reason: 'MIT is compatible with BSD 3-Clause' },
                'GPL-2.0': { compatible: false, reason: 'MIT is not compatible with GPL 2.0' },
                'GPL-3.0': { compatible: false, reason: 'MIT is not compatible with GPL 3.0' },
                'AGPL-3.0': { compatible: false, reason: 'MIT is not compatible with AGPL 3.0' },
                'LGPL-2.1': { compatible: false, reason: 'MIT is not compatible with LGPL 2.1' }
            },
            'APACHE-2.0': {
                'MIT': { compatible: true, reason: 'Apache 2.0 is compatible with MIT' },
                'APACHE-2.0': { compatible: true, reason: 'Same license' },
                'BSD-3-CLAUSE': { compatible: true, reason: 'Apache 2.0 is compatible with BSD 3-Clause' },
                'GPL-2.0': { compatible: false, reason: 'Apache 2.0 is not compatible with GPL 2.0' },
                'GPL-3.0': { compatible: true, reason: 'Apache 2.0 is compatible with GPL 3.0' },
                'AGPL-3.0': { compatible: true, reason: 'Apache 2.0 is compatible with AGPL 3.0' }
            },
            'BSD-3-CLAUSE': {
                'MIT': { compatible: true, reason: 'BSD 3-Clause is compatible with MIT' },
                'APACHE-2.0': { compatible: true, reason: 'BSD 3-Clause is compatible with Apache 2.0' },
                'BSD-3-CLAUSE': { compatible: true, reason: 'Same license' },
                'GPL-2.0': { compatible: false, reason: 'BSD 3-Clause is not compatible with GPL 2.0' },
                'GPL-3.0': { compatible: true, reason: 'BSD 3-Clause is compatible with GPL 3.0' }
            },
            'GPL-2.0': {
                'MIT': { compatible: false, reason: 'GPL 2.0 is not compatible with MIT' },
                'APACHE-2.0': { compatible: false, reason: 'GPL 2.0 is not compatible with Apache 2.0' },
                'BSD-3-CLAUSE': { compatible: false, reason: 'GPL 2.0 is not compatible with BSD 3-Clause' },
                'GPL-2.0': { compatible: true, reason: 'Same license' },
                'GPL-3.0': { compatible: true, reason: 'GPL 3.0 is backward compatible with GPL 2.0' }
            },
            'GPL-3.0': {
                'MIT': { compatible: false, reason: 'GPL 3.0 is not compatible with MIT' },
                'APACHE-2.0': { compatible: true, reason: 'GPL 3.0 is compatible with Apache 2.0' },
                'BSD-3-CLAUSE': { compatible: true, reason: 'GPL 3.0 is compatible with BSD 3-Clause' },
                'GPL-2.0': { compatible: false, reason: 'GPL 3.0 is not forward compatible with GPL 2.0' },
                'GPL-3.0': { compatible: true, reason: 'Same license' }
            }
        };
    }
    
    async getPackageInfo(packageName) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${packageName} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            throw new Error(`Failed to get package info for ${packageName}: ${error.message}`);
        }
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        
        try {
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            return {
                dependencies: packageJson.dependencies || {},
                devDependencies: packageJson.devDependencies || {}
            };
        } catch (error) {
            throw new Error(`Failed to read package.json: ${error.message}`);
        }
    }
    
    async checkProjectLicenseCompliance() {
        const dependencies = await this.getProjectDependencies();
        const allPackages = {
            ...dependencies.dependencies,
            ...dependencies.devDependencies
        };
        
        const results = {
            compliant: true,
            packages: {},
            summary: {
                total: 0,
                compliant: 0,
                nonCompliant: 0,
                issues: 0
            },
            licenseBreakdown: {}
        };
        
        for (const [name, version] of Object.entries(allPackages)) {
            const checkResult = await this.checkPackageLicense(name, version);
            results.packages[name] = checkResult;
            
            results.summary.total++;
            
            if (checkResult.compliant) {
                results.summary.compliant++;
            } else {
                results.summary.nonCompliant++;
                results.compliant = false;
            }
            
            if (checkResult.issues.length > 0) {
                results.summary.issues++;
            }
            
            // Подсчет по лицензиям
            const license = checkResult.normalizedLicense || 'UNKNOWN';
            results.licenseBreakdown[license] = (results.licenseBreakdown[license] || 0) + 1;
        }
        
        return results;
    }
    
    async checkPackageLicense(name, version) {
        try {
            const packageInfo = await this.getPackageInfo(name);
            const license = this.normalizeLicense(packageInfo.license);
            
            const result = {
                packageName: name,
                version: version,
                originalLicense: packageInfo.license,
                normalizedLicense: license,
                compliant: true,
                issues: [],
                licenseInfo: this.getLicenseInfo(license)
            };
            
            // Проверка на запрещенные лицензии
            if (this.isForbiddenLicense(license)) {
                result.compliant = false;
                result.issues.push({
                    type: 'FORBIDDEN_LICENSE',
                    severity: 'CRITICAL',
                    message: `Package uses forbidden license: ${license}`,
                    license: license
                });
            }
            
            // Проверка на лицензии с ограничениями
            if (this.hasRestrictions(license)) {
                result.issues.push({
                    type: 'LICENSE_RESTRICTIONS',
                    severity: 'MEDIUM',
                    message: `Package license has restrictions: ${license}`,
                    license: license,
                    restrictions: this.getLicenseRestrictions(license)
                });
            }
            
            // Проверка на совместимость с проектной лицензией
            if (process.env.PROJECT_LICENSE) {
                const projectLicense = process.env.PROJECT_LICENSE;
                const compatibility = this.checkLicenseCompatibility(license, projectLicense);
                
                if (!compatibility.compatible) {
                    result.compliant = false;
                    result.issues.push({
                        type: 'COMPATIBILITY_ISSUE',
                        severity: 'HIGH',
                        message: `Package license ${license} is not compatible with project license ${projectLicense}`,
                        sourceLicense: license,
                        targetLicense: projectLicense,
                        compatibilityDetails: compatibility
                    });
                }
            }
            
            return result;
        } catch (error) {
            return {
                packageName: name,
                version: version,
                compliant: false,
                issues: [{
                    type: 'CHECK_FAILED',
                    severity: 'HIGH',
                    message: `Failed to check license: ${error.message}`,
                    error: error.message
                }]
            };
        }
    }
    
    isForbiddenLicense(license) {
        const forbidden = [
            'AGPL-1.0',
            'AGPL-3.0',
            'CC-BY-NC-4.0',
            'CC-BY-NC-SA-4.0',
            'CC-BY-NC-ND-4.0',
            'EUPL-1.2',
            'OSL-3.0',
            'CDDL-1.0'
        ];
        
        return forbidden.includes(license);
    }
    
    hasRestrictions(license) {
        const restricted = [
            'GPL-2.0',
            'GPL-3.0',
            'LGPL-2.1',
            'LGPL-3.0',
            'MPL-2.0'
        ];
        
        return restricted.includes(license);
    }
    
    getLicenseRestrictions(license) {
        const restrictions = {
            'GPL-2.0': ['Copyleft requirements', 'Derivative work licensing'],
            'GPL-3.0': ['Strong copyleft', 'Patent protection clause'],
            'LGPL-2.1': ['Library linking restrictions', 'Modified library licensing'],
            'MPL-2.0': ['File-level copyleft', 'Patent grant requirements'],
            'EUPL-1.2': ['EU law jurisdiction', 'Translation requirements']
        };
        
        return restrictions[license] || [];
    }
    
    async generateLicenseReport() {
        const complianceCheck = await this.checkProjectLicenseCompliance();
        
        const report = {
            timestamp: new Date().toISOString(),
            projectName: process.env.npm_package_name || 'Unknown',
            projectVersion: process.env.npm_package_version || 'Unknown',
            complianceCheck: complianceCheck,
            recommendations: this.generateRecommendations(complianceCheck),
            summary: this.generateSummary(complianceCheck)
        };
        
        return report;
    }
    
    generateRecommendations(complianceCheck) {
        const recommendations = [];
        
        if (complianceCheck.summary.nonCompliant > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'COMPLIANCE',
                title: 'Replace Non-Compliant Packages',
                description: `Found ${complianceCheck.summary.nonCompliant} packages with non-compliant licenses`,
                action: 'Replace packages with compliant alternatives'
            });
        }
        
        const forbiddenLicenses = this.getForbiddenLicenseCount(complianceCheck);
        if (forbiddenLicenses > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'LEGAL',
                title: 'Remove Forbidden License Dependencies',
                description: `Found ${forbiddenLicenses} packages with forbidden licenses`,
                action: 'Remove or replace packages with forbidden licenses immediately'
            });
        }
        
        const restrictionCount = this.getRestrictedLicenseCount(complianceCheck);
        if (restrictionCount > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'COMPLIANCE',
                title: 'Review Restricted License Usage',
                description: `Found ${restrictionCount} packages with license restrictions`,
                action: 'Review license restrictions and ensure compliance'
            });
        }
        
        return recommendations;
    }
    
    getForbiddenLicenseCount(complianceCheck) {
        let count = 0;
        for (const result of Object.values(complianceCheck.packages)) {
            if (result.issues.some(issue => issue.type === 'FORBIDDEN_LICENSE')) {
                count++;
            }
        }
        return count;
    }
    
    getRestrictedLicenseCount(complianceCheck) {
        let count = 0;
        for (const result of Object.values(complianceCheck.packages)) {
            if (result.issues.some(issue => issue.type === 'LICENSE_RESTRICTIONS')) {
                count++;
            }
        }
        return count;
    }
    
    generateSummary(complianceCheck) {
        const summary = {
            totalPackages: complianceCheck.summary.total,
            compliantPackages: complianceCheck.summary.compliant,
            nonCompliantPackages: complianceCheck.summary.nonCompliant,
            complianceRate: complianceCheck.summary.total > 0 ? 
                (complianceCheck.summary.compliant / complianceCheck.summary.total) * 100 : 0,
            criticalIssues: this.countCriticalIssues(complianceCheck),
            highIssues: this.countHighIssues(complianceCheck),
            mediumIssues: this.countMediumIssues(complianceCheck),
            licenseDistribution: complianceCheck.licenseBreakdown
        };
        
        return summary;
    }
    
    countCriticalIssues(complianceCheck) {
        let count = 0;
        for (const result of Object.values(complianceCheck.packages)) {
            count += result.issues.filter(issue => issue.severity === 'CRITICAL').length;
        }
        return count;
    }
    
    countHighIssues(complianceCheck) {
        let count = 0;
        for (const result of Object.values(complianceCheck.packages)) {
            count += result.issues.filter(issue => issue.severity === 'HIGH').length;
        }
        return count;
    }
    
    countMediumIssues(complianceCheck) {
        let count = 0;
        for (const result of Object.values(complianceCheck.packages)) {
            count += result.issues.filter(issue => issue.severity === 'MEDIUM').length;
        }
        return count;
    }
}

// Использование проверки разрешительных лицензий
const permissiveChecker = new PermissiveLicenseChecker();
```

### 2. Copyleft Licenses (Обратные лицензии)

```javascript
// Классификация copyleft лицензий
class CopyleftLicenseChecker {
    constructor() {
        this.copyleftLicenses = [
            'GPL-2.0',
            'GPL-3.0',
            'LGPL-2.1',
            'LGPL-3.0',
            'AGPL-3.0',
            'MPL-2.0',
            'EUPL-1.2'
        ];
        
        this.licenseCharacteristics = {
            'GPL-2.0': {
                name: 'GNU General Public License v2.0',
                type: 'Strong Copyleft',
                requirements: [
                    'Distribute source code',
                    'Use same license',
                    'Include license text',
                    'Preserve copyright notices'
                ],
                compatibility: {
                    compatible: ['GPL-2.0', 'GPL-3.0'],
                    incompatible: ['MIT', 'Apache-2.0', 'BSD'],
                    requires: 'GPL-compatible license'
                },
                commercialUse: 'Yes, but with restrictions',
                patentProtection: 'No explicit patent clause'
            },
            'GPL-3.0': {
                name: 'GNU General Public License v3.0',
                type: 'Strong Copyleft',
                requirements: [
                    'Distribute source code',
                    'Use same license',
                    'Include license text',
                    'Patent grant to users',
                    'Provide installation information'
                ],
                compatibility: {
                    compatible: ['GPL-3.0'],
                    incompatible: ['GPL-2.0', 'MIT', 'Apache-2.0'],
                    requires: 'GPL-3.0 or later'
                },
                commercialUse: 'Yes, but with restrictions',
                patentProtection: 'Explicit patent clause included'
            },
            'LGPL-2.1': {
                name: 'GNU Lesser General Public License v2.1',
                type: 'Weak Copyleft',
                requirements: [
                    'Distribute modified library source',
                    'Allow reverse engineering',
                    'Include license text'
                ],
                compatibility: {
                    compatible: ['GPL-2.0', 'GPL-3.0'],
                    incompatible: ['MIT', 'Apache-2.0'],
                    allows: 'Linking with proprietary code'
                },
                commercialUse: 'Yes, with linking exceptions',
                patentProtection: 'No explicit patent clause'
            },
            'MPL-2.0': {
                name: 'Mozilla Public License 2.0',
                type: 'File-level Copyleft',
                requirements: [
                    'Include license text',
                    'Mark modifications',
                    'Patent grant'
                ],
                compatibility: {
                    compatible: ['MIT', 'Apache-2.0', 'BSD variants'],
                    incompatible: ['GPL-2.0'],
                    allows: 'Combination with proprietary code'
                },
                commercialUse: 'Yes',
                patentProtection: 'Explicit patent clause included'
            }
        };
    }
    
    isCopyleft(license) {
        return this.copyleftLicenses.includes(license);
    }
    
    getLicenseRequirements(license) {
        return this.licenseCharacteristics[license]?.requirements || [];
    }
    
    async checkCopyleftImplications(packageName) {
        const packageInfo = await this.getPackageInfo(packageName);
        const license = this.normalizeLicense(packageInfo.license);
        
        if (!this.isCopyleft(license)) {
            return {
                isCopyleft: false,
                implications: [],
                compliance: true
            };
        }
        
        const characteristics = this.licenseCharacteristics[license];
        
        const implications = {
            license: license,
            type: characteristics.type,
            requirements: characteristics.requirements,
            commercialImplications: characteristics.commercialUse,
            patentProtection: characteristics.patentProtection,
            compatibility: characteristics.compatibility,
            projectImpact: this.assessProjectImpact(license, packageInfo)
        };
        
        return {
            isCopyleft: true,
            implications: implications,
            compliance: this.checkComplianceWithRequirements(implications),
            riskLevel: this.assessRiskLevel(implications)
        };
    }
    
    assessProjectImpact(license, packageInfo) {
        // Оценка влияния на проект
        const projectType = process.env.PROJECT_TYPE || 'unknown';
        const projectLicense = process.env.PROJECT_LICENSE || 'unknown';
        
        const impact = {
            distribution: this.assessDistributionImpact(license, projectType),
            sourceCode: this.assessSourceCodeImpact(license),
            commercial: this.assessCommercialImpact(license, projectType),
            licenseCompatibility: this.checkProjectLicenseCompatibility(license, projectLicense)
        };
        
        return impact;
    }
    
    assessDistributionImpact(license, projectType) {
        const impact = {
            requirement: 'Distribute source code',
            appliesTo: false,
            severity: 'HIGH'
        };
        
        // GPL лицензии требуют распространения исходного кода
        if (['GPL-2.0', 'GPL-3.0', 'AGPL-3.0'].includes(license)) {
            impact.appliesTo = true;
            
            if (projectType === 'closed-source') {
                impact.severity = 'CRITICAL';
                impact.reason = 'Closed-source project cannot use GPL licenses';
            } else if (projectType === 'open-source') {
                impact.severity = 'MEDIUM';
                impact.reason = 'Open-source project can comply with GPL requirements';
            }
        }
        
        // LGPL лицензии имеют исключения для linking
        if (['LGPL-2.1', 'LGPL-3.0'].includes(license)) {
            impact.appliesTo = true;
            impact.severity = 'MEDIUM';
            impact.reason = 'LGPL requires library source code distribution but allows proprietary linking';
        }
        
        return impact;
    }
    
    assessSourceCodeImpact(license) {
        const impact = {
            requirement: 'Source code availability',
            applies: false,
            severity: 'HIGH'
        };
        
        if (['GPL-2.0', 'GPL-3.0', 'AGPL-3.0'].includes(license)) {
            impact.applies = true;
            impact.severity = 'CRITICAL';
            impact.reason = 'Must distribute complete source code under GPL';
        } else if (['LGPL-2.1', 'LGPL-3.0'].includes(license)) {
            impact.applies = true;
            impact.severity = 'MEDIUM';
            impact.reason = 'Must distribute library source code under LGPL';
        }
        
        return impact;
    }
    
    assessCommercialImpact(license, projectType) {
        const impact = {
            commercialUseAllowed: true,
            restrictions: [],
            severity: 'LOW'
        };
        
        if (['GPL-2.0', 'GPL-3.0', 'AGPL-3.0'].includes(license)) {
            if (projectType === 'proprietary') {
                impact.commercialUseAllowed = false;
                impact.restrictions.push('Copyleft requirements');
                impact.severity = 'CRITICAL';
            } else {
                impact.restrictions.push('Must comply with copyleft requirements');
                impact.severity = 'MEDIUM';
            }
        }
        
        return impact;
    }
    
    checkProjectLicenseCompatibility(packageLicense, projectLicense) {
        if (!projectLicense || projectLicense === 'unknown') {
            return { compatible: false, reason: 'Project license not specified' };
        }
        
        const compatibility = this.getLicenseCompatibility(packageLicense, projectLicense);
        
        return {
            compatible: compatibility.compatible,
            reason: compatibility.reason,
            details: compatibility.details
        };
    }
    
    getLicenseCompatibility(packageLicense, projectLicense) {
        const compatibilityDB = {
            'GPL-2.0': {
                'GPL-2.0': { compatible: true, reason: 'Same license' },
                'GPL-3.0': { compatible: true, reason: 'GPL 3.0 is backward compatible' },
                'MIT': { compatible: false, reason: 'GPL 2.0 is not compatible with MIT' },
                'APACHE-2.0': { compatible: false, reason: 'GPL 2.0 is not compatible with Apache 2.0' }
            },
            'GPL-3.0': {
                'GPL-2.0': { compatible: false, reason: 'GPL 3.0 is not forward compatible with GPL 2.0' },
                'GPL-3.0': { compatible: true, reason: 'Same license' },
                'MIT': { compatible: false, reason: 'GPL 3.0 is not compatible with MIT' },
                'APACHE-2.0': { compatible: true, reason: 'GPL 3.0 is compatible with Apache 2.0' }
            },
            'LGPL-2.1': {
                'GPL-2.0': { compatible: true, reason: 'LGPL 2.1 is compatible with GPL 2.0' },
                'GPL-3.0': { compatible: true, reason: 'LGPL 2.1 is compatible with GPL 3.0' },
                'MIT': { compatible: false, reason: 'LGPL 2.1 is not compatible with MIT' },
                'APACHE-2.0': { compatible: false, reason: 'LGPL 2.1 is not compatible with Apache 2.0' }
            }
        };
        
        const packageCompat = compatibilityDB[packageLicense];
        if (packageCompat && packageCompat[projectLicense]) {
            return packageCompat[projectLicense];
        }
        
        return { compatible: false, reason: 'Unknown compatibility' };
    }
    
    checkComplianceWithRequirements(implications) {
        // Проверка соответствия требованиям лицензии
        const projectSettings = {
            sourceCodeAvailable: process.env.SOURCE_CODE_AVAILABLE === 'true',
            projectLicense: process.env.PROJECT_LICENSE,
            distributionModel: process.env.DISTRIBUTION_MODEL
        };
        
        let compliant = true;
        const issues = [];
        
        // Проверка требования к исходному коду
        if (implications.sourceCode.applies && !projectSettings.sourceCodeAvailable) {
            compliant = false;
            issues.push({
                requirement: 'Source code availability',
                fulfilled: false,
                impact: implications.sourceCode.reason
            });
        }
        
        // Проверка лицензионной совместимости
        if (!implications.licenseCompatibility.compatible) {
            compliant = false;
            issues.push({
                requirement: 'License compatibility',
                fulfilled: false,
                impact: implications.licenseCompatibility.reason
            });
        }
        
        return {
            compliant,
            issues,
            projectSettings
        };
    }
    
    assessRiskLevel(implications) {
        let riskScore = 0;
        
        // Оценка по типу лицензии
        if (implications.type === 'Strong Copyleft') riskScore += 25;
        if (implications.type === 'Weak Copyleft') riskScore += 15;
        
        // Оценка по коммерческим ограничениям
        if (!implications.commercial.commercialUseAllowed) riskScore += 20;
        
        // Оценка по требованиям к распространению
        if (implications.distribution.severity === 'CRITICAL') riskScore += 30;
        else if (implications.distribution.severity === 'HIGH') riskScore += 20;
        
        if (riskScore >= 70) return 'CRITICAL';
        if (riskScore >= 50) return 'HIGH';
        if (riskScore >= 30) return 'MEDIUM';
        if (riskScore >= 10) return 'LOW';
        return 'ACCEPTABLE';
    }
    
    async generateCopyleftReport() {
        const projectDeps = await this.getProjectDependencies();
        const copyleftPackages = [];
        
        for (const [name, version] of Object.entries({
            ...projectDeps.dependencies,
            ...projectDeps.devDependencies
        })) {
            const checkResult = await this.checkCopyleftImplications(name);
            if (checkResult.isCopyleft) {
                copyleftPackages.push({
                    name,
                    version,
                    ...checkResult
                });
            }
        }
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: Object.keys({
                ...projectDeps.dependencies,
                ...projectDeps.devDependencies
            }).length,
            copyleftDependencies: copyleftPackages,
            summary: {
                totalCopyleft: copyleftPackages.length,
                byType: this.countByType(copyleftPackages),
                riskDistribution: this.countByRisk(copyleftPackages)
            },
            recommendations: this.generateCopyleftRecommendations(copyleftPackages)
        };
    }
    
    countByType(packages) {
        const counts = {};
        for (const pkg of packages) {
            const type = pkg.implications.type;
            counts[type] = (counts[type] || 0) + 1;
        }
        return counts;
    }
    
    countByRisk(packages) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, ACCEPTABLE: 0 };
        for (const pkg of packages) {
            counts[pkg.riskLevel] = (counts[pkg.riskLevel] || 0) + 1;
        }
        return counts;
    }
    
    generateCopyleftRecommendations(packages) {
        const recommendations = [];
        
        const criticalRisk = packages.filter(p => p.riskLevel === 'CRITICAL');
        if (criticalRisk.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Replace Critical Copyleft Dependencies',
                description: `Found ${criticalRisk.length} packages with critical copyleft implications`,
                action: 'Replace with permissive-licensed alternatives immediately',
                packages: criticalRisk.map(p => p.name)
            });
        }
        
        const highRisk = packages.filter(p => p.riskLevel === 'HIGH');
        if (highRisk.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Review High-Risk Copyleft Dependencies',
                description: `Found ${highRisk.length} packages with high-risk copyleft implications`,
                action: 'Review usage and consider alternatives',
                packages: highRisk.map(p => p.name)
            });
        }
        
        const complianceIssues = packages.filter(p => !p.compliance.compliant);
        if (complianceIssues.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Address License Compliance Issues',
                description: `Found ${complianceIssues.length} packages with compliance issues`,
                action: 'Ensure project meets all license requirements',
                issues: complianceIssues.map(p => p.compliance.issues).flat()
            });
        }
        
        return recommendations;
    }
}

// Использование проверки copyleft лицензий
const copyleftChecker = new CopyleftLicenseChecker();
```

## Инструменты проверки лицензий

### 1. License Checker

```javascript
// Комплексная система проверки лицензий
class ComprehensiveLicenseChecker {
    constructor(config = {}) {
        this.config = {
            allowedLicenses: config.allowedLicenses || [
                'MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'
            ],
            forbiddenLicenses: config.forbiddenLicenses || [
                'AGPL-3.0', 'GPL-2.0', 'GPL-3.0', 'LGPL-2.1', 'CC-BY-NC-4.0'
            ],
            checkDevDependencies: config.checkDevDependencies !== false,
            reportFormat: config.reportFormat || 'json',
            failOnForbidden: config.failOnForbidden !== false,
            ...config
        };
        
        this.licenseDB = this.initializeLicenseDatabase();
        this.spdxLicenseList = this.loadSPDXLicenseList();
    }
    
    initializeLicenseDatabase() {
        // Инициализация базы данных лицензий
        return {
            permissive: ['MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 'ISC', 'MIT-0'],
            copyleft: ['GPL-2.0', 'GPL-3.0', 'LGPL-2.1', 'LGPL-3.0', 'AGPL-3.0'],
            weakCopyleft: ['MPL-2.0', 'EPL-2.0'],
            forbidden: ['CC-BY-NC-4.0', 'CC-BY-NC-SA-4.0', 'CC-BY-NC-ND-4.0', 'EUPL-1.2'],
            patentLicensed: ['Apache-2.0', 'GPL-3.0', 'MPL-2.0'],
            viral: ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0']
        };
    }
    
    loadSPDXLicenseList() {
        // Загрузка SPDX списка лицензий
        // В реальности загружать из https://spdx.org/licenses/
        return new Set([
            'MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 'GPL-2.0', 'GPL-3.0',
            'LGPL-2.1', 'LGPL-3.0', 'AGPL-3.0', 'MPL-2.0', 'ISC', 'CC0-1.0', 'Unlicense',
            'EPL-2.0', 'EUPL-1.2', 'OSL-3.0', 'CDDL-1.0', 'LGPL-2.0', 'LPPL-1.3c',
            'MS-PL', 'Artistic-2.0', 'CC-BY-4.0', 'CC-BY-SA-4.0', 'CC-BY-NC-4.0'
        ]);
    }
    
    async checkProjectLicenses() {
        const dependencies = await this.getProjectDependencies();
        const results = {
            dependencies: {},
            summary: {
                total: 0,
                compliant: 0,
                nonCompliant: 0,
                forbidden: 0,
                warnings: 0
            },
            licenseBreakdown: {},
            issues: []
        };
        
        const allDeps = {
            ...dependencies.dependencies,
            ...(this.config.checkDevDependencies ? dependencies.devDependencies : {})
        };
        
        for (const [name, version] of Object.entries(allDeps)) {
            const checkResult = await this.checkSingleDependency(name, version);
            
            results.dependencies[name] = checkResult;
            results.summary.total++;
            
            if (checkResult.compliant) {
                results.summary.compliant++;
            } else {
                results.summary.nonCompliant++;
                
                if (checkResult.forbidden) {
                    results.summary.forbidden++;
                }
                
                if (checkResult.warnings.length > 0) {
                    results.summary.warnings++;
                }
            }
            
            // Подсчет по лицензиям
            const license = checkResult.normalizedLicense || 'UNKNOWN';
            results.licenseBreakdown[license] = (results.licenseBreakdown[license] || 0) + 1;
            
            // Сбор проблем
            if (!checkResult.compliant) {
                results.issues.push({
                    package: name,
                    version: version,
                    license: license,
                    issues: checkResult.issues,
                    severity: checkResult.severity
                });
            }
        }
        
        results.compliant = results.summary.nonCompliant === 0;
        
        return results;
    }
    
    async checkSingleDependency(name, version) {
        try {
            const packageInfo = await this.getPackageInfo(name);
            const license = this.extractLicense(packageInfo);
            
            const result = {
                packageName: name,
                version: version,
                originalLicense: packageInfo.license,
                normalizedLicense: license,
                compliant: true,
                forbidden: false,
                warnings: [],
                issues: [],
                licenseType: this.getLicenseType(license),
                spdxCompliant: this.spdxLicenseList.has(license),
                licenseInfo: this.getLicenseDetails(license)
            };
            
            // Проверка на запрещенные лицензии
            if (this.isForbiddenLicense(license)) {
                result.compliant = false;
                result.forbidden = true;
                result.severity = 'CRITICAL';
                
                result.issues.push({
                    type: 'FORBIDDEN_LICENSE',
                    severity: 'CRITICAL',
                    message: `Package uses forbidden license: ${license}`,
                    license: license,
                    allowedLicenses: this.config.allowedLicenses
                });
            }
            
            // Проверка на лицензии вне белого списка
            if (!this.isAllowedLicense(license) && !result.forbidden) {
                result.compliant = false;
                result.severity = 'HIGH';
                
                result.issues.push({
                    type: 'LICENSE_NOT_ALLOWED',
                    severity: 'HIGH',
                    message: `Package uses license not in allowed list: ${license}`,
                    license: license,
                    allowedLicenses: this.config.allowedLicenses
                });
            }
            
            // Проверка на copyleft лицензии
            if (this.isCopyleftLicense(license)) {
                result.warnings.push({
                    type: 'COPYLEFT_LICENSE',
                    severity: 'MEDIUM',
                    message: `Package uses copyleft license: ${license}`,
                    license: license,
                    implications: this.getCopyleftImplications(license)
                });
            }
            
            // Проверка на лицензии с патентными ограничениями
            if (this.hasPatentRestrictions(license)) {
                result.warnings.push({
                    type: 'PATENT_RESTRICTIONS',
                    severity: 'LOW',
                    message: `Package license has patent restrictions: ${license}`,
                    license: license
                });
            }
            
            // Проверка на неоднозначные лицензии
            if (this.hasAmbiguousLicense(packageInfo.license)) {
                result.warnings.push({
                    type: 'AMBIGUOUS_LICENSE',
                    severity: 'LOW',
                    message: `Package has ambiguous license specification: ${packageInfo.license}`,
                    original: packageInfo.license,
                    normalized: license
                });
            }
            
            return result;
        } catch (error) {
            return {
                packageName: name,
                version: version,
                compliant: false,
                forbidden: false,
                warnings: [],
                issues: [{
                    type: 'CHECK_FAILED',
                    severity: 'HIGH',
                    message: `Failed to check license: ${error.message}`,
                    error: error.message
                }],
                severity: 'HIGH'
            };
        }
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo) return 'UNKNOWN';
        
        // Извлечение лицензии из различных источников
        let license = packageInfo.license || 
                     packageInfo.licenses?.[0] || 
                     packageInfo.licence || 
                     'UNKNOWN';
        
        if (typeof license === 'object') {
            license = license.type || license.name || 'UNKNOWN';
        }
        
        if (Array.isArray(license)) {
            license = license[0]; // берем первую лицензию
        }
        
        // Нормализация лицензии
        return this.normalizeLicense(license);
    }
    
    normalizeLicense(license) {
        if (!license) return 'UNKNOWN';
        
        // Удаление лишних символов и приведение к стандартному формату
        return license
            .toString()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/\(|\)/g, '')
            .replace(/\s*OR\s*/i, '-')
            .replace(/\s*AND\s*/i, '-')
            .toUpperCase();
    }
    
    isForbiddenLicense(license) {
        return this.config.forbiddenLicenses.includes(license);
    }
    
    isAllowedLicense(license) {
        return this.config.allowedLicenses.includes(license);
    }
    
    isCopyleftLicense(license) {
        return this.licenseDB.copyleft.includes(license) || 
               this.licenseDB.weakCopyleft.includes(license);
    }
    
    hasPatentRestrictions(license) {
        return this.licenseDB.patentLicensed.includes(license);
    }
    
    hasAmbiguousLicense(originalLicense) {
        if (!originalLicense) return false;
        
        const ambiguousPatterns = [
            /see license/i,
            /proprietary/i,
            /custom/i,
            /see readme/i,
            /unspecified/i,
            /multiple licenses/i
        ];
        
        const licenseStr = typeof originalLicense === 'string' ? 
                          originalLicense : 
                          JSON.stringify(originalLicense);
        
        return ambiguousPatterns.some(pattern => pattern.test(licenseStr));
    }
    
    getLicenseType(license) {
        if (this.licenseDB.permissive.includes(license)) return 'PERMISSIVE';
        if (this.licenseDB.copyleft.includes(license)) return 'STRONG_COPYLEFT';
        if (this.licenseDB.weakCopyleft.includes(license)) return 'WEAK_COPYLEFT';
        if (this.licenseDB.forbidden.includes(license)) return 'FORBIDDEN';
        return 'UNKNOWN';
    }
    
    getLicenseDetails(license) {
        const details = {
            spdxId: license,
            isOsiApproved: false,
            isFsfLibre: false,
            requiresAttribution: false,
            allowsCommercialUse: false,
            requiresShareAlike: false,
            requiresDiscloseSource: false
        };
        
        // Установка деталей на основе типа лицензии
        if (this.licenseDB.permissive.includes(license)) {
            details.allowsCommercialUse = true;
            details.requiresAttribution = true;
        } else if (this.licenseDB.copyleft.includes(license)) {
            details.requiresShareAlike = true;
            details.requiresDiscloseSource = true;
        }
        
        return details;
    }
    
    getLicenseImplications(license) {
        return {
            type: this.getLicenseType(license),
            attributionRequired: this.requiresAttribution(license),
            commercialUseAllowed: this.allowsCommercialUse(license),
            sourceCodeRequired: this.requiresSourceCode(license),
            patentProtection: this.hasPatentProtection(license)
        };
    }
    
    requiresAttribution(license) {
        return this.licenseDB.permissive.includes(license) || 
               this.licenseDB.copyleft.includes(license);
    }
    
    allowsCommercialUse(license) {
        return this.licenseDB.permissive.includes(license) || 
               this.licenseDB.weakCopyleft.includes(license);
    }
    
    requiresSourceCode(license) {
        return this.licenseDB.copyleft.includes(license);
    }
    
    hasPatentProtection(license) {
        return this.licenseDB.patentLicensed.includes(license);
    }
    
    async generateComprehensiveReport() {
        const checkResults = await this.checkProjectLicenses();
        
        const report = {
            metadata: {
                timestamp: new Date().toISOString(),
                nodeVersion: process.version,
                projectPath: process.cwd(),
                config: this.config
            },
            licenseCheck: checkResults,
            complianceSummary: this.generateComplianceSummary(checkResults),
            recommendations: this.generateRecommendations(checkResults),
            nextSteps: this.generateNextSteps(checkResults)
        };
        
        return report;
    }
    
    generateComplianceSummary(results) {
        return {
            overallCompliance: results.compliant,
            totalDependencies: results.summary.total,
            compliantDependencies: results.summary.compliant,
            nonCompliantDependencies: results.summary.nonCompliant,
            forbiddenDependencies: results.summary.forbidden,
            warningDependencies: results.summary.warnings,
            complianceRate: results.summary.total > 0 ? 
                (results.summary.compliant / results.summary.total) * 100 : 0,
            byLicenseType: this.countByLicenseType(results.dependencies),
            riskAssessment: this.assessOverallRisk(results)
        };
    }
    
    countByLicenseType(dependencies) {
        const counts = {
            PERMISSIVE: 0,
            STRONG_COPYLEFT: 0,
            WEAK_COPYLEFT: 0,
            FORBIDDEN: 0,
            UNKNOWN: 0
        };
        
        for (const dep of Object.values(dependencies)) {
            counts[dep.licenseType] = (counts[dep.licenseType] || 0) + 1;
        }
        
        return counts;
    }
    
    assessOverallRisk(results) {
        const { summary } = results;
        
        if (summary.forbidden > 0) return 'CRITICAL';
        if (summary.nonCompliant > 5) return 'HIGH';
        if (summary.nonCompliant > 0) return 'MEDIUM';
        if (summary.warnings > 10) return 'MEDIUM';
        if (summary.warnings > 0) return 'LOW';
        return 'ACCEPTABLE';
    }
    
    generateRecommendations(results) {
        const recommendations = [];
        
        if (results.summary.forbidden > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'COMPLIANCE',
                title: 'Remove Forbidden License Dependencies',
                description: `Found ${results.summary.forbidden} dependencies with forbidden licenses`,
                action: 'Remove or replace all forbidden license dependencies immediately',
                affectedPackages: this.getForbiddenPackages(results.dependencies)
            });
        }
        
        if (results.summary.nonCompliant > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'COMPLIANCE',
                title: 'Address Non-Compliant Dependencies',
                description: `Found ${results.summary.nonCompliant} non-compliant dependencies`,
                action: 'Replace with allowed license alternatives or seek legal approval',
                affectedPackages: this.getNonCompliantPackages(results.dependencies)
            });
        }
        
        if (results.summary.warnings > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'REVIEW',
                title: 'Review Warning Dependencies',
                description: `Found ${results.summary.warnings} dependencies with license warnings`,
                action: 'Review copyleft implications and patent restrictions',
                affectedPackages: this.getWarningPackages(results.dependencies)
            });
        }
        
        recommendations.push({
            priority: 'LOW',
            category: 'PROCESS',
            title: 'Improve License Management Process',
            description: 'Implement automated license checking in CI/CD',
            action: 'Add license checks to build pipeline and create approval process for new dependencies'
        });
        
        return recommendations;
    }
    
    getForbiddenPackages(dependencies) {
        return Object.entries(dependencies)
            .filter(([, result]) => result.forbidden)
            .map(([name]) => name);
    }
    
    getNonCompliantPackages(dependencies) {
        return Object.entries(dependencies)
            .filter(([, result]) => !result.compliant && !result.forbidden)
            .map(([name]) => name);
    }
    
    getWarningPackages(dependencies) {
        return Object.entries(dependencies)
            .filter(([, result]) => result.warnings.length > 0)
            .map(([name]) => name);
    }
    
    generateNextSteps(results) {
        const steps = [];
        
        if (results.summary.forbidden > 0) {
            steps.push('1. Identify and replace forbidden license dependencies');
            steps.push('2. Document replacement rationale and alternatives');
            steps.push('3. Update package.json and lock files');
        }
        
        if (results.summary.nonCompliant > 0) {
            steps.push('1. Review non-compliant dependencies for business justification');
            steps.push('2. Seek legal approval for continued use if necessary');
            steps.push('3. Plan migration to compliant alternatives');
        }
        
        steps.push('1. Implement automated license checking in CI/CD pipeline');
        steps.push('2. Create dependency approval process for development team');
        steps.push('3. Monitor for license changes in existing dependencies');
        
        return steps;
    }
    
    async exportReport(format = 'json', outputPath = null) {
        const report = await this.generateComprehensiveReport();
        
        if (format === 'json') {
            const fs = require('fs');
            const output = outputPath || 'license-compliance-report.json';
            fs.writeFileSync(output, JSON.stringify(report, null, 2));
            return output;
        } else if (format === 'html') {
            return this.generateHTMLReport(report, outputPath);
        } else if (format === 'csv') {
            return this.generateCSVReport(report, outputPath);
        } else {
            throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    generateHTMLReport(report, outputPath = 'license-report.html') {
        const fs = require('fs');
        
        const html = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>License Compliance Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f5f5f5; padding: 15px; margin: 10px 0; }
                .issue { border: 1px solid #ddd; margin: 10px 0; padding: 10px; }
                .critical { border-left: 5px solid #d32f2f; }
                .high { border-left: 5px solid #ff9800; }
                .medium { border-left: 5px solid #ffc107; }
                .low { border-left: 5px solid #4caf50; }
                table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f2f2f2; }
            </style>
        </head>
        <body>
            <h1>License Compliance Report</h1>
            <div class="summary">
                <h2>Summary</h2>
                <p>Total Dependencies: ${report.licenseCheck.summary.total}</p>
                <p>Compliant: ${report.licenseCheck.summary.compliant}</p>
                <p>Non-Compliant: ${report.licenseCheck.summary.nonCompliant}</p>
                <p>Forbidden: ${report.licenseCheck.summary.forbidden}</p>
                <p>Compliance Rate: ${(report.complianceSummary.complianceRate).toFixed(2)}%</p>
            </div>
            
            <h2>License Distribution</h2>
            <table>
                <thead>
                    <tr><th>License</th><th>Count</th></tr>
                </thead>
                <tbody>
                    ${Object.entries(report.licenseCheck.licenseBreakdown).map(([license, count]) => 
                        `<tr><td>${license}</td><td>${count}</td></tr>`
                    ).join('')}
                </tbody>
            </table>
            
            <h2>Issues</h2>
            ${report.licenseCheck.issues.map(issue => `
                <div class="issue ${issue.severity.toLowerCase()}">
                    <h3>${issue.package}@${issue.version} - ${issue.license}</h3>
                    <p><strong>Severity:</strong> ${issue.severity}</p>
                    <p><strong>Issues:</strong></p>
                    <ul>
                        ${issue.issues.map(i => `<li>${i.message}</li>`).join('')}
                    </ul>
                </div>
            `).join('')}
        </body>
        </html>
        `;
        
        fs.writeFileSync(outputPath, html);
        return outputPath;
    }
    
    generateCSVReport(report, outputPath = 'license-report.csv') {
        const fs = require('fs');
        
        let csv = 'Package,Version,License,Compliant,Severity,Issues\n';
        
        for (const [packageName, result] of Object.entries(report.licenseCheck.dependencies)) {
            const issues = result.issues.map(i => i.message).join('; ');
            csv += `"${packageName}","${result.version}","${result.normalizedLicense}",` +
                   `"${result.compliant}","${result.severity || 'N/A'}","${issues}"\n`;
        }
        
        fs.writeFileSync(outputPath, csv);
        return outputPath;
    }
    
    async getPackageInfo(name) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            // Попытка получить информацию другим способом
            try {
                const fs = require('fs');
                const packagePath = `node_modules/${name}/package.json`;
                if (fs.existsSync(packagePath)) {
                    return JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                }
            } catch (fsError) {
                // Не удалось получить информацию
            }
            
            throw new Error(`Failed to get package info for ${name}: ${error.message}`);
        }
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        
        try {
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            return {
                dependencies: packageJson.dependencies || {},
                devDependencies: this.config.checkDevDependencies ? 
                                (packageJson.devDependencies || {}) : {}
            };
        } catch (error) {
            throw new Error(`Failed to read package.json: ${error.message}`);
        }
    }
    
    async checkForLicenseChanges() {
        // Проверка изменений лицензий в существующих зависимостях
        const currentLicenses = await this.getCurrentLicenseSnapshot();
        const storedLicenses = await this.getStoredLicenseSnapshot();
        
        const changes = [];
        
        for (const [packageName, currentLicense] of Object.entries(currentLicenses)) {
            const storedLicense = storedLicenses[packageName];
            if (storedLicense && storedLicense !== currentLicense) {
                changes.push({
                    package: packageName,
                    oldLicense: storedLicense,
                    newLicense: currentLicense,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        return changes;
    }
    
    async getCurrentLicenseSnapshot() {
        const dependencies = await this.getProjectDependencies();
        const snapshot = {};
        
        const allDeps = {
            ...dependencies.dependencies,
            ...(this.config.checkDevDependencies ? dependencies.devDependencies : {})
        };
        
        for (const [name] of Object.entries(allDeps)) {
            try {
                const packageInfo = await this.getPackageInfo(name);
                const license = this.extractLicense(packageInfo);
                snapshot[name] = license;
            } catch (error) {
                snapshot[name] = 'UNKNOWN';
            }
        }
        
        return snapshot;
    }
    
    async getStoredLicenseSnapshot() {
        // В реальности загружать из файла или базы данных
        try {
            const fs = require('fs');
            if (fs.existsSync('license-snapshot.json')) {
                const data = fs.readFileSync('license-snapshot.json', 'utf8');
                return JSON.parse(data);
            }
        } catch (error) {
            console.error('Failed to load stored license snapshot:', error);
        }
        
        return {};
    }
    
    async saveLicenseSnapshot(snapshot) {
        // Сохранение снимка лицензий
        const fs = require('fs');
        fs.writeFileSync('license-snapshot.json', JSON.stringify(snapshot, null, 2));
    }
    
    async monitorLicenseChanges() {
        // Мониторинг изменений лицензий
        const changes = await this.checkForLicenseChanges();
        
        if (changes.length > 0) {
            console.log(`License changes detected: ${changes.length} packages`);
            
            for (const change of changes) {
                console.log(`- ${change.package}: ${change.oldLicense} → ${change.newLicense}`);
                
                if (this.isForbiddenLicense(change.newLicense)) {
                    console.error(`CRITICAL: ${change.package} changed to forbidden license: ${change.newLicense}`);
                    // Здесь может быть отправка алерта
                }
            }
            
            // Обновление снимка
            await this.saveLicenseSnapshot(await this.getCurrentLicenseSnapshot());
        }
        
        return changes;
    }
}

// Использование комплексной проверки лицензий
const licenseChecker = new ComprehensiveLicenseChecker({
    allowedLicenses: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],
    forbiddenLicenses: ['AGPL-3.0', 'GPL-2.0', 'GPL-3.0', 'CC-BY-NC-4.0'],
    checkDevDependencies: true
});

// Запуск проверки лицензий
async function runLicenseCheck() {
    try {
        const report = await licenseChecker.generateComprehensiveReport();
        
        console.log('License Compliance Report Generated');
        console.log('Overall Compliance:', report.complianceSummary.overallCompliance);
        console.log('Compliance Rate:', report.complianceSummary.complianceRate.toFixed(2) + '%');
        
        if (report.complianceSummary.nonCompliant > 0) {
            console.error(`Found ${report.complianceSummary.nonCompliant} non-compliant dependencies!`);
            
            // Выход с ошибкой если есть неподчинения
            if (report.complianceSummary.forbidden > 0) {
                process.exit(1);
            }
        }
        
        return report;
    } catch (error) {
        console.error('License check failed:', error);
        process.exit(1);
    }
}
```

### 2. Интеграция с CI/CD

```yaml
# .github/workflows/license-check.yml
name: License Compliance Check

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  license-check:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Check for license compliance
        run: |
          npx license-checker --summary
          npx license-checker --json > licenses.json
          
          # Проверка на запрещенные лицензии
          node scripts/check-licenses.js
          
          # Проверка с помощью других инструментов
          if command -v fossa >/dev/null 2>&1; then
            fossa analyze
          fi
      
      - name: Validate licenses
        run: |
          # Проверка лицензий с использованием нашего скрипта
          node scripts/validate-licenses.js
      
      - name: Generate license report
        run: |
          npm run license-report
          
      - name: Upload license report
        uses: actions/upload-artifact@v3
        with:
          name: license-compliance-report
          path: |
            license-report.json
            license-report.html
            licenses.csv
      
      - name: Fail if non-compliant licenses found
        run: |
          # Проверка результатов и выход с ошибкой при наличии проблем
          if [ -f license-check-results.json ]; then
            non_compliant=$(jq '.summary.nonCompliant' license-check-results.json)
            if [ "$non_compliant" -gt 0 ]; then
              echo "Found $non_compliant non-compliant licenses"
              exit 1
            fi
          fi
```

### 3. Автоматическое одобрение лицензий

```javascript
// Система автоматического одобрения лицензий
class LicenseApprovalSystem {
    constructor() {
        this.approvalRules = new Map();
        this.approvedPackages = new Map();
        this.pendingApprovals = [];
        this.approvalHistory = [];
        
        this.loadApprovalRules();
        this.loadApprovedPackages();
    }
    
    loadApprovalRules() {
        // Загрузка правил одобрения из конфигурации
        const rules = [
            {
                id: 'oss_permissive',
                condition: (license) => ['MIT', 'Apache-2.0', 'BSD-3-Clause'].includes(license),
                action: 'AUTO_APPROVE',
                reason: 'Open source permissive licenses are approved'
            },
            {
                id: 'internal_packages',
                condition: (packageInfo) => packageInfo.name.startsWith('@company/'),
                action: 'AUTO_APPROVE',
                reason: 'Internal company packages are approved'
            },
            {
                id: 'high_trust_developers',
                condition: (packageInfo) => this.isHighTrustDeveloper(packageInfo),
                action: 'AUTO_APPROVE',
                reason: 'Packages from high-trust developers are approved'
            },
            {
                id: 'well_maintained',
                condition: (packageInfo) => this.isWellMaintained(packageInfo),
                action: 'AUTO_APPROVE',
                reason: 'Well-maintained popular packages are approved'
            }
        ];
        
        rules.forEach(rule => this.approvalRules.set(rule.id, rule));
    }
    
    isHighTrustDeveloper(packageInfo) {
        const highTrustDevelopers = [
            'lodash',
            'expressjs', 
            'facebook',
            'google',
            'microsoft',
            'angular',
            'react'
        ];
        
        return highTrustDevelopers.some(trusted => 
            packageInfo.name.includes(trusted) || 
            packageInfo.maintainers?.some(maintainer => 
                typeof maintainer === 'object' ? 
                maintainer.name.includes(trusted) : 
                maintainer.includes(trusted)
            )
        );
    }
    
    isWellMaintained(packageInfo) {
        // Проверка на активное сопровождение
        if (!packageInfo.time) return false;
        
        const versions = Object.keys(packageInfo.time);
        if (versions.length < 5) return false; // мало версий
        
        // Проверка последнего обновления (в пределах 6 месяцев)
        const latestVersion = versions[versions.length - 1];
        const lastUpdate = new Date(packageInfo.time[latestVersion]);
        const sixMonthsAgo = new Date();
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
        
        return lastUpdate > sixMonthsAgo;
    }
    
    async checkPackageApproval(packageName, version, license) {
        const packageInfo = await this.getPackageInfo(packageName);
        
        // Проверка на основе правил
        for (const [ruleId, rule] of this.approvalRules) {
            try {
                if (rule.condition(license) || rule.condition(packageInfo)) {
                    return {
                        approved: true,
                        ruleId,
                        reason: rule.reason,
                        action: rule.action
                    };
                }
            } catch (error) {
                console.error(`Rule ${ruleId} evaluation failed:`, error.message);
            }
        }
        
        // Проверка в белом списке
        const approvedEntry = this.approvedPackages.get(`${packageName}@${version}`);
        if (approvedEntry) {
            return {
                approved: true,
                reason: 'Previously approved',
                approvalId: approvedEntry.approvalId
            };
        }
        
        // Проверка по лицензии
        if (this.isLicenseApproved(license)) {
            return {
                approved: true,
                reason: 'License is pre-approved',
                license: license
            };
        }
        
        // Требуется ручное одобрение
        return {
            approved: false,
            requiresApproval: true,
            reason: 'Package requires manual approval',
            packageInfo: {
                name: packageName,
                version: version,
                license: license
            }
        };
    }
    
    isLicenseApproved(license) {
        const approvedLicenses = [
            'MIT',
            'Apache-2.0', 
            'BSD-3-Clause',
            'ISC',
            'CC0-1.0',
            'Unlicense'
        ];
        
        return approvedLicenses.includes(license);
    }
    
    async requestApproval(packageName, version, license, requester, reason = '') {
        const approvalRequest = {
            id: this.generateApprovalId(),
            packageName,
            version,
            license,
            requester,
            reason,
            requestedAt: new Date().toISOString(),
            status: 'PENDING',
            approvers: [],
            comments: []
        };
        
        this.pendingApprovals.push(approvalRequest);
        
        // Отправка уведомления команде безопасности
        await this.notifySecurityTeam(approvalRequest);
        
        return approvalRequest;
    }
    
    generateApprovalId() {
        return `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async approvePackage(requestId, approver, comment = '') {
        const request = this.pendingApprovals.find(req => req.id === requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not in pending status');
        }
        
        request.status = 'APPROVED';
        request.approvers.push({
            user: approver,
            timestamp: new Date().toISOString(),
            comment: comment
        });
        
        // Добавление в белый список
        this.approvedPackages.set(`${request.packageName}@${request.version}`, {
            approvalId: request.id,
            approvedBy: approver,
            approvedAt: new Date().toISOString(),
            license: request.license
        });
        
        // Добавление в историю
        this.approvalHistory.push({
            ...request,
            approvedBy: approver,
            approvedAt: new Date().toISOString()
        });
        
        return { success: true, request: request };
    }
    
    async rejectPackage(requestId, rejector, reason) {
        const request = this.pendingApprovals.find(req => req.id === requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not in pending status');
        }
        
        request.status = 'REJECTED';
        request.rejector = rejector;
        request.rejectionReason = reason;
        request.rejectedAt = new Date().toISOString();
        
        // Добавление в историю
        this.approvalHistory.push({
            ...request,
            rejectedBy: rejector,
            rejectedAt: new Date().toISOString()
        });
        
        return { success: true, request: request };
    }
    
    async notifySecurityTeam(request) {
        // Отправка уведомления команде безопасности
        console.log(`Approval requested for ${request.packageName}@${request.version}: ${request.license}`);
        
        // В реальности интеграция с системами уведомлений
        if (process.env.SLACK_SECURITY_CHANNEL) {
            try {
                await fetch(process.env.SLACK_SECURITY_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel: process.env.SLACK_SECURITY_CHANNEL,
                        text: `License Approval Request`,
                        attachments: [{
                            color: 'warning',
                            fields: [
                                { title: 'Package', value: request.packageName, short: true },
                                { title: 'Version', value: request.version, short: true },
                                { title: 'License', value: request.license, short: true },
                                { title: 'Requester', value: request.requester, short: true },
                                { title: 'Reason', value: request.reason || 'N/A', short: false }
                            ]
                        }]
                    })
                });
            } catch (error) {
                console.error('Failed to send Slack notification:', error);
            }
        }
    }
    
    getApprovalStatistics() {
        return {
            totalRequests: this.pendingApprovals.length + this.approvalHistory.length,
            pendingApprovals: this.pendingApprovals.length,
            approvedPackages: this.approvalHistory.filter(a => a.status === 'APPROVED').length,
            rejectedPackages: this.approvalHistory.filter(a => a.status === 'REJECTED').length,
            approvalRate: this.approvalHistory.length > 0 ? 
                (this.approvalHistory.filter(a => a.status === 'APPROVED').length / this.approvalHistory.length) * 100 : 0
        };
    }
    
    async getPendingApprovals() {
        return this.pendingApprovals.filter(req => req.status === 'PENDING');
    }
    
    async getApprovalHistory(filters = {}) {
        let history = [...this.approvalHistory];
        
        if (filters.status) {
            history = history.filter(record => record.status === filters.status);
        }
        
        if (filters.package) {
            history = history.filter(record => record.packageName === filters.package);
        }
        
        if (filters.license) {
            history = history.filter(record => record.license === filters.license);
        }
        
        if (filters.dateFrom) {
            history = history.filter(record => new Date(record.requestedAt) >= new Date(filters.dateFrom));
        }
        
        if (filters.dateTo) {
            history = history.filter(record => new Date(record.requestedAt) <= new Date(filters.dateTo));
        }
        
        return history.sort((a, b) => new Date(b.requestedAt) - new Date(a.requestedAt));
    }
    
    async getPackageApprovalStatus(packageName, version) {
        const approvedEntry = this.approvedPackages.get(`${packageName}@${version}`);
        if (approvedEntry) {
            return {
                approved: true,
                approvalId: approvedEntry.approvalId,
                approvedBy: approvedEntry.approvedBy,
                approvedAt: approvedEntry.approvedAt
            };
        }
        
        const pendingRequest = this.pendingApprovals.find(req => 
            req.packageName === packageName && req.version === version
        );
        
        if (pendingRequest) {
            return {
                approved: false,
                status: 'PENDING',
                requestId: pendingRequest.id,
                requestedAt: pendingRequest.requestedAt
            };
        }
        
        return { approved: false, status: 'NOT_REQUESTED' };
    }
    
    async getLicenseApprovalRecommendation(license) {
        // Рекомендации по одобрению лицензии
        const licenseInfo = this.getLicenseInfo(license);
        
        if (!licenseInfo) {
            return {
                recommendation: 'REVIEW_REQUIRED',
                confidence: 'LOW',
                reason: 'Unknown license type'
            };
        }
        
        if (licenseInfo.category === 'permissive') {
            return {
                recommendation: 'APPROVE',
                confidence: 'HIGH',
                reason: 'Permissive license with minimal restrictions'
            };
        }
        
        if (licenseInfo.category === 'copyleft_strong') {
            return {
                recommendation: 'REJECT',
                confidence: 'MEDIUM',
                reason: 'Strong copyleft license may require project relicensing'
            };
        }
        
        if (licenseInfo.category === 'copyleft_weak') {
            return {
                recommendation: 'CASE_BY_CASE',
                confidence: 'MEDIUM',
                reason: 'Weak copyleft license - review usage context'
            };
        }
        
        return {
            recommendation: 'REVIEW_REQUIRED',
            confidence: 'MEDIUM',
            reason: 'License requires case-by-case review'
        };
    }
    
    getLicenseInfo(license) {
        const licenseDatabase = {
            'MIT': { category: 'permissive', risk: 'LOW', restrictions: [] },
            'Apache-2.0': { category: 'permissive', risk: 'LOW', restrictions: ['patent_grant'] },
            'BSD-3-Clause': { category: 'permissive', risk: 'LOW', restrictions: ['endorsement_prohibition'] },
            'GPL-2.0': { category: 'copyleft_strong', risk: 'HIGH', restrictions: ['derivative_works_license'] },
            'GPL-3.0': { category: 'copyleft_strong', risk: 'HIGH', restrictions: ['patent_protection', 'derivative_works_license'] },
            'LGPL-2.1': { category: 'copyleft_weak', risk: 'MEDIUM', restrictions: ['library_modifications_license'] },
            'MPL-2.0': { category: 'copyleft_weak', risk: 'MEDIUM', restrictions: ['file_level_copyleft'] },
            'AGPL-3.0': { category: 'copyleft_strong', risk: 'CRITICAL', restrictions: ['network_use_requires_distribution'] }
        };
        
        return licenseDatabase[license];
    }
}

// Использование системы одобрения
const approvalSystem = new LicenseApprovalSystem();

// Проверка одобрения перед установкой
async function checkAndInstallPackage(packageName, version) {
    const packageInfo = await approvalSystem.getPackageInfo(packageName);
    const license = approvalSystem.extractLicense(packageInfo);
    
    const approval = await approvalSystem.checkPackageApproval(packageName, version, license);
    
    if (approval.approved) {
        console.log(`Package ${packageName}@${version} is approved. Installing...`);
        // Установка пакета
        return { success: true, approved: true };
    } else if (approval.requiresApproval) {
        console.log(`Package ${packageName}@${version} requires approval.`);
        
        // Запрос одобрения
        const request = await approvalSystem.requestApproval(
            packageName, 
            version, 
            license, 
            process.env.USER || 'unknown'
        );
        
        console.log(`Approval requested. Request ID: ${request.id}`);
        
        return { 
            success: false, 
            requiresApproval: true, 
            requestId: request.id 
        };
    } else {
        console.error(`Package ${packageName}@${version} is not approved and cannot be installed.`);
        return { success: false, approved: false };
    }
}
```

## Лучшие практики

### 1. Политики управления лицензиями

```javascript
// Политика управления лицензиями
class LicensePolicyManager {
    constructor() {
        this.policy = {
            // Разрешенные лицензии
            allowedLicenses: [
                'MIT',
                'Apache-2.0', 
                'BSD-2-Clause',
                'BSD-3-Clause',
                'ISC',
                'CC0-1.0'
            ],
            
            // Запрещенные лицензии
            forbiddenLicenses: [
                'AGPL-1.0',
                'AGPL-3.0',
                'GPL-2.0',
                'GPL-3.0',
                'LGPL-2.1',
                'CC-BY-NC-4.0',
                'CC-BY-NC-SA-4.0',
                'EUPL-1.2'
            ],
            
            // Лицензии требующие ручного одобрения
            requiresApproval: [
                'MPL-2.0',
                'EPL-2.0',
                'OSL-3.0',
                'CDDL-1.0'
            ],
            
            // Политики для разных типов проектов
            projectPolicies: {
                openSource: {
                    allowed: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'GPL-3.0', 'MPL-2.0'],
                    forbidden: ['AGPL-3.0', 'CC-BY-NC-4.0']
                },
                proprietary: {
                    allowed: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],
                    forbidden: ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'LGPL-2.1', 'MPL-2.0']
                },
                internal: {
                    allowed: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC', 'internal'],
                    forbidden: []
                }
            },
            
            // Требования к атрибуции
            attributionRequirements: {
                'MIT': ['license notice', 'copyright notice'],
                'Apache-2.0': ['license notice', 'copyright notice', 'notice file'],
                'BSD-3-Clause': ['license notice', 'copyright notice', 'no endorsement']
            },
            
            // Проверка частоты обновлений
            updateFrequency: {
                critical: 30, // дней
                high: 60,     // дней  
                medium: 180   // дней
            }
        };
    }
    
    checkPolicyCompliance(license, projectType = 'proprietary') {
        const projectPolicy = this.policy.projectPolicies[projectType] || 
                             this.policy.projectPolicies.proprietary;
        
        if (this.policy.forbiddenLicenses.includes(license)) {
            return {
                compliant: false,
                reason: 'License is explicitly forbidden',
                severity: 'CRITICAL'
            };
        }
        
        if (projectPolicy.forbidden?.includes(license)) {
            return {
                compliant: false,
                reason: `License forbidden for ${projectType} projects`,
                severity: 'HIGH'
            };
        }
        
        if (this.policy.requiresApproval.includes(license)) {
            return {
                compliant: false,
                reason: 'License requires manual approval',
                severity: 'MEDIUM'
            };
        }
        
        if (projectPolicy.allowed?.includes(license)) {
            return {
                compliant: true,
                reason: 'License is allowed for project type',
                severity: 'INFO'
            };
        }
        
        return {
            compliant: false,
            reason: 'License not explicitly allowed',
            severity: 'MEDIUM'
        };
    }
    
    getAttributionRequirements(license) {
        return this.policy.attributionRequirements[license] || [];
    }
    
    async enforcePolicy() {
        const checker = new ComprehensiveLicenseChecker();
        const results = await checker.checkProjectLicenses();
        
        if (results.summary.nonCompliant > 0) {
            console.error(`Policy enforcement failed: ${results.summary.nonCompliant} non-compliant dependencies`);
            
            const forbidden = results.issues.filter(issue => 
                issue.issues.some(i => i.type === 'FORBIDDEN_LICENSE')
            );
            
            if (forbidden.length > 0) {
                console.error('Forbidden licenses detected:', forbidden.map(f => f.package));
                process.exit(1); // Завершить с ошибкой при запрещенных лицензиях
            }
            
            return { success: false, results };
        }
        
        console.log('All dependencies comply with license policy');
        return { success: true, results };
    }
    
    async generatePolicyReport() {
        const complianceResults = await this.checkProjectCompliance();
        
        return {
            timestamp: new Date().toISOString(),
            policy: this.policy,
            complianceResults,
            recommendations: this.generatePolicyRecommendations(complianceResults),
            nextSteps: this.generateNextSteps(complianceResults)
        };
    }
    
    generatePolicyRecommendations(results) {
        const recommendations = [];
        
        if (results.summary.forbidden > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Remove Forbidden License Dependencies',
                description: `Found ${results.summary.forbidden} dependencies with forbidden licenses`,
                action: 'Immediate removal required'
            });
        }
        
        if (results.summary.nonCompliant > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Non-Compliant Dependencies',
                description: `Found ${results.summary.nonCompliant} non-compliant dependencies`,
                action: 'Replace with compliant alternatives'
            });
        }
        
        if (results.summary.warnings > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Review License Warnings',
                description: `Found ${results.summary.warnings} dependencies with license warnings`,
                action: 'Review copyleft implications'
            });
        }
        
        recommendations.push({
            priority: 'LOW',
            title: 'Improve License Management',
            description: 'Implement automated policy enforcement',
            action: 'Add policy checks to CI/CD pipeline'
        });
        
        return recommendations;
    }
    
    async checkProjectCompliance() {
        const checker = new ComprehensiveLicenseChecker({
            allowedLicenses: this.policy.allowedLicenses,
            forbiddenLicenses: this.policy.forbiddenLicenses
        });
        
        return await checker.checkProjectLicenses();
    }
    
    async getComplianceDashboard() {
        const compliance = await this.checkProjectCompliance();
        
        return {
            summary: compliance.summary,
            licenseDistribution: compliance.licenseBreakdown,
            complianceRate: (compliance.summary.compliant / compliance.summary.total) * 100,
            policyViolations: this.getPolicyViolations(compliance),
            trending: await this.getLicenseTrends()
        };
    }
    
    getPolicyViolations(compliance) {
        return compliance.issues.map(issue => ({
            package: issue.package,
            license: issue.license,
            severity: issue.severity,
            violations: issue.issues.map(i => i.message)
        }));
    }
    
    async getLicenseTrends() {
        // В реальности анализировать исторические данные
        return {
            newDependencies: 0,
            licenseChanges: 0,
            complianceImprovement: 0
        };
    }
}

// Использование менеджера политики
const policyManager = new LicensePolicyManager();

// Пример проверки соответствия
async function checkCompliance() {
    const report = await policyManager.generatePolicyReport();
    console.log('License Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (!report.complianceResults.compliant) {
        process.exit(1); // Не соответствует политике
    }
}

// Запуск проверки соответствия
if (require.main === module) {
    checkCompliance().catch(console.error);
}
```

### 2. Мониторинг и аудит лицензий

```javascript
// Система мониторинга и аудита лицензий
class LicenseAuditSystem {
    constructor() {
        this.auditLog = [];
        this.complianceHistory = [];
        this.licenseDatabase = new LicenseDatabase();
        this.monitoringEnabled = true;
    }
    
    async performLicenseAudit() {
        const audit = {
            id: this.generateAuditId(),
            timestamp: new Date().toISOString(),
            project: await this.getProjectInfo(),
            dependencies: await this.getDependencyLicenses(),
            findings: [],
            compliance: await this.checkCompliance(),
            recommendations: []
        };
        
        audit.findings = await this.analyzeAuditResults(audit);
        audit.recommendations = await this.generateRecommendations(audit);
        
        this.auditLog.push(audit);
        
        // Ограничение размера лога
        if (this.auditLog.length > 1000) {
            this.auditLog = this.auditLog.slice(-1000);
        }
        
        return audit;
    }
    
    async getProjectInfo() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        return {
            name: packageJson.name,
            version: packageJson.version,
            description: packageJson.description,
            license: packageJson.license,
            dependencies: Object.keys({
                ...packageJson.dependencies,
                ...packageJson.devDependencies
            }).length
        };
    }
    
    async getDependencyLicenses() {
        const dependencies = await this.getProjectDependencies();
        const licenseInfo = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            try {
                const packageInfo = await this.getPackageInfo(name);
                const license = this.extractLicense(packageInfo);
                
                licenseInfo[name] = {
                    version: version,
                    license: license,
                    source: packageInfo._resolved || 'registry',
                    size: packageInfo._integrity ? packageInfo._integrity.length : 0,
                    published: packageInfo.time?.[version] || 'unknown'
                };
            } catch (error) {
                licenseInfo[name] = {
                    version: version,
                    license: 'UNKNOWN',
                    error: error.message
                };
            }
        }
        
        return licenseInfo;
    }
    
    async analyzeAuditResults(audit) {
        const findings = [];
        
        // Анализ каждого пакета
        for (const [packageName, packageInfo] of Object.entries(audit.dependencies)) {
            const complianceCheck = await this.checkLicenseCompliance(packageInfo.license);
            
            if (!complianceCheck.compliant) {
                findings.push({
                    type: 'POLICY_VIOLATION',
                    package: packageName,
                    license: packageInfo.license,
                    severity: complianceCheck.severity,
                    reason: complianceCheck.reason,
                    timestamp: audit.timestamp
                });
            }
            
            // Проверка на подозрительные пакеты
            if (await this.isSuspiciousPackage(packageName, packageInfo)) {
                findings.push({
                    type: 'SUSPICIOUS_PACKAGE',
                    package: packageName,
                    license: packageInfo.license,
                    severity: 'MEDIUM',
                    reason: 'Package shows suspicious characteristics',
                    timestamp: audit.timestamp
                });
            }
            
            // Проверка на устаревшие лицензии
            if (await this.isLicenseDeprecated(packageInfo.license)) {
                findings.push({
                    type: 'DEPRECATED_LICENSE',
                    package: packageName,
                    license: packageInfo.license,
                    severity: 'LOW',
                    reason: 'License is deprecated or superseded',
                    timestamp: audit.timestamp
                });
            }
        }
        
        return findings;
    }
    
    async isSuspiciousPackage(packageName, packageInfo) {
        // Проверка на подозрительные характеристики пакета
        const checks = [
            this.hasSuspiciousName(packageName),
            this.hasSuspiciousSize(packageInfo.size),
            this.hasSuspiciousPublishDate(packageInfo.published)
        ];
        
        return checks.some(check => check);
    }
    
    hasSuspiciousName(packageName) {
        // Проверка на подозрительные имена (typosquatting и т.д.)
        const suspiciousPatterns = [
            /keylogger/i,
            /password/i,
            /stealer/i,
            /miner/i,
            /crypto/i,
            /^\.|^_/, // начинается с точки или подчеркивания
            /[-_]{2,}/ // двойные символы
        ];
        
        return suspiciousPatterns.some(pattern => pattern.test(packageName));
    }
    
    hasSuspiciousSize(size) {
        // Проверка на подозрительный размер (слишком большой для утилиты)
        return size > 10000000; // больше 10MB
    }
    
    hasSuspiciousPublishDate(publishedDate) {
        // Проверка на очень недавно опубликованные пакеты
        if (publishedDate === 'unknown') return false;
        
        const publishTime = new Date(publishedDate).getTime();
        const now = Date.now();
        const ageInDays = (now - publishTime) / (1000 * 60 * 60 * 24);
        
        return ageInDays < 7; // опубликовано менее недели назад
    }
    
    async isLicenseDeprecated(license) {
        // Проверка устаревших лицензий
        const deprecatedLicenses = [
            'GPL-1.0',
            'LGPL-2.0',
            'MPL-1.1'
        ];
        
        return deprecatedLicenses.includes(license);
    }
    
    async generateRecommendations(audit) {
        const recommendations = [];
        
        const policyViolations = audit.findings.filter(f => f.type === 'POLICY_VIOLATION');
        if (policyViolations.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'COMPLIANCE',
                title: 'Address License Policy Violations',
                description: `Found ${policyViolations.length} policy violations`,
                action: 'Replace violating packages or seek exceptions',
                affectedPackages: policyViolations.map(v => v.package)
            });
        }
        
        const suspiciousPackages = audit.findings.filter(f => f.type === 'SUSPICIOUS_PACKAGE');
        if (suspiciousPackages.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'SECURITY',
                title: 'Review Suspicious Packages',
                description: `Found ${suspiciousPackages.length} suspicious packages`,
                action: 'Manually review and verify package legitimacy',
                affectedPackages: suspiciousPackages.map(v => v.package)
            });
        }
        
        recommendations.push({
            priority: 'LOW',
            category: 'PROCESS',
            title: 'Improve License Monitoring',
            description: 'Implement continuous license monitoring',
            action: 'Set up automated license audits and alerts'
        });
        
        return recommendations;
    }
    
    async generateAuditReport(auditId) {
        const audit = this.auditLog.find(a => a.id === auditId);
        if (!audit) {
            throw new Error('Audit not found');
        }
        
        return {
            audit: audit,
            summary: this.generateAuditSummary(audit),
            detailedFindings: this.generateDetailedFindings(audit),
            complianceOverview: this.generateComplianceOverview(audit),
            executiveSummary: this.generateExecutiveSummary(audit)
        };
    }
    
    generateAuditSummary(audit) {
        return {
            totalDependencies: Object.keys(audit.dependencies).length,
            compliantDependencies: audit.compliance.compliantCount,
            nonCompliantDependencies: audit.compliance.nonCompliantCount,
            policyViolations: audit.findings.filter(f => f.type === 'POLICY_VIOLATION').length,
            suspiciousPackages: audit.findings.filter(f => f.type === 'SUSPICIOUS_PACKAGE').length,
            complianceRate: (audit.compliance.compliantCount / Object.keys(audit.dependencies).length) * 100
        };
    }
    
    generateDetailedFindings(audit) {
        const bySeverity = {
            CRITICAL: [],
            HIGH: [],
            MEDIUM: [],
            LOW: []
        };
        
        for (const finding of audit.findings) {
            bySeverity[finding.severity].push(finding);
        }
        
        return bySeverity;
    }
    
    generateComplianceOverview(audit) {
        const licenseCounts = {};
        
        for (const [, pkgInfo] of Object.entries(audit.dependencies)) {
            const license = pkgInfo.license;
            licenseCounts[license] = (licenseCounts[license] || 0) + 1;
        }
        
        return {
            licenseDistribution: licenseCounts,
            topLicenses: Object.entries(licenseCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .map(([license, count]) => ({ license, count })),
            complianceStatus: audit.compliance.status
        };
    }
    
    generateExecutiveSummary(audit) {
        return {
            overallRisk: this.calculateOverallRisk(audit),
            criticalIssues: audit.findings.filter(f => f.severity === 'CRITICAL').length,
            highIssues: audit.findings.filter(f => f.severity === 'HIGH').length,
            mediumIssues: audit.findings.filter(f => f.severity === 'MEDIUM').length,
            immediateActions: this.getImmediateActions(audit),
            costImplications: await this.estimateCostImplications(audit)
        };
    }
    
    calculateOverallRisk(audit) {
        const critical = audit.findings.filter(f => f.severity === 'CRITICAL').length;
        const high = audit.findings.filter(f => f.severity === 'HIGH').length;
        const medium = audit.findings.filter(f => f.severity === 'MEDIUM').length;
        
        if (critical > 0) return 'CRITICAL';
        if (high > 5) return 'HIGH';
        if (high > 0) return 'MEDIUM-HIGH';
        if (medium > 10) return 'MEDIUM';
        if (medium > 0) return 'LOW-MEDIUM';
        return 'LOW';
    }
    
    getImmediateActions(audit) {
        const actions = [];
        
        if (audit.findings.some(f => f.severity === 'CRITICAL')) {
            actions.push('Remove all critical license violations immediately');
        }
        
        if (audit.findings.some(f => f.type === 'SUSPICIOUS_PACKAGE')) {
            actions.push('Review and potentially remove suspicious packages');
        }
        
        if (audit.compliance.complianceRate < 80) {
            actions.push('Implement stricter license approval process');
        }
        
        return actions;
    }
    
    async estimateCostImplications(audit) {
        // Оценка потенциальных затрат на несоответствие лицензиям
        const costEstimates = {
            legalFees: 0,
            remediationCost: 0,
            potentialFines: 0,
            total: 0
        };
        
        for (const finding of audit.findings) {
            switch (finding.severity) {
                case 'CRITICAL':
                    costEstimates.legalFees += 50000;
                    costEstimates.potentialFines += 100000;
                    break;
                case 'HIGH':
                    costEstimates.legalFees += 10000;
                    costEstimates.potentialFines += 25000;
                    break;
                case 'MEDIUM':
                    costEstimates.legalFees += 2500;
                    break;
            }
        }
        
        costEstimates.total = costEstimates.legalFees + 
                             costEstimates.remediationCost + 
                             costEstimates.potentialFines;
        
        return costEstimates;
    }
    
    async scheduleRegularAudits(interval = 'weekly') {
        const intervalMs = {
            'daily': 24 * 60 * 60 * 1000,
            'weekly': 7 * 24 * 60 * 60 * 1000,
            'monthly': 30 * 24 * 60 * 60 * 1000
        };
        
        const ms = intervalMs[interval] || intervalMs['weekly'];
        
        setInterval(async () => {
            if (this.monitoringEnabled) {
                try {
                    const audit = await this.performLicenseAudit();
                    console.log(`License audit completed: ${audit.id}`);
                    
                    // Отправка уведомления при критических нарушениях
                    if (audit.findings.some(f => f.severity === 'CRITICAL')) {
                        await this.sendCriticalAlert(audit);
                    }
                } catch (error) {
                    console.error('Scheduled license audit failed:', error);
                }
            }
        }, ms);
    }
    
    generateAuditId() {
        return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async sendCriticalAlert(audit) {
        console.error(`CRITICAL LICENSE VIOLATIONS DETECTED: ${audit.findings.filter(f => f.severity === 'CRITICAL').length} violations`);
        
        // В реальности интеграция с системами уведомлений
        if (process.env.SECURITY_ALERT_WEBHOOK) {
            try {
                await fetch(process.env.SECURITY_ALERT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'LICENSE_AUDIT_CRITICAL_FINDINGS',
                        auditId: audit.id,
                        timestamp: audit.timestamp,
                        violations: audit.findings.filter(f => f.severity === 'CRITICAL')
                    })
                });
            } catch (error) {
                console.error('Failed to send critical alert:', error);
            }
        }
    }
    
    async getAuditHistory(limit = 10) {
        return this.auditLog
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            .slice(0, limit);
    }
    
    async getComplianceTrends() {
        const history = await this.getAuditHistory(50); // последние 50 аудитов
        
        return {
            complianceRateTrend: this.calculateComplianceTrend(history),
            violationTrend: this.calculateViolationTrend(history),
            licenseDiversity: this.calculateLicenseDiversity(history)
        };
    }
    
    calculateComplianceTrend(history) {
        if (history.length < 2) return 'insufficient_data';
        
        const rates = history.map(audit => 
            (audit.compliance.compliantCount / Object.keys(audit.dependencies).length) * 100
        );
        
        const firstRate = rates[rates.length - 1];
        const lastRate = rates[0];
        
        return lastRate > firstRate ? 'improving' : lastRate < firstRate ? 'declining' : 'stable';
    }
    
    calculateViolationTrend(history) {
        if (history.length < 2) return 'insufficient_data';
        
        const violations = history.map(audit => 
            audit.findings.filter(f => f.type === 'POLICY_VIOLATION').length
        );
        
        const firstCount = violations[violations.length - 1];
        const lastCount = violations[0];
        
        return lastCount < firstCount ? 'improving' : lastCount > firstCount ? 'worsening' : 'stable';
    }
    
    calculateLicenseDiversity(history) {
        const allLicenses = new Set();
        
        for (const audit of history) {
            for (const [, pkg] of Object.entries(audit.dependencies)) {
                allLicenses.add(pkg.license);
            }
        }
        
        return {
            totalUniqueLicenses: allLicenses.size,
            mostCommon: this.getMostCommonLicenses(history, 5),
            diversityIndex: allLicenses.size / Object.keys(history[0]?.dependencies || {}).length
        };
    }
    
    getMostCommonLicenses(history, limit = 5) {
        const licenseCounts = {};
        
        for (const audit of history) {
            for (const [, pkg] of Object.entries(audit.dependencies)) {
                licenseCounts[pkg.license] = (licenseCounts[pkg.license] || 0) + 1;
            }
        }
        
        return Object.entries(licenseCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, limit)
            .map(([license, count]) => ({ license, count }));
    }
}

// Использование системы аудита
const auditSystem = new LicenseAuditSystem();

// Запуск регулярных аудитов
auditSystem.scheduleRegularAudits('weekly').catch(console.error);

// Ручной запуск аудита
async function runManualAudit() {
    const audit = await auditSystem.performLicenseAudit();
    console.log('Manual license audit completed:', audit.id);
    return audit;
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Управление-пакетами]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]