---
aliases: ["Управление безопасностью пакетов", "Package Security Management", "Dependency Security Governance"]
tags: ["#security", "#dependency-security", "#package-management", "#security-governance"]
---

# Управление безопасностью пакетов

## Введение

Управление безопасностью пакетов - это комплекс мероприятий, направленных на обеспечение безопасности внешних зависимостей в проекте. Это включает в себя выбор безопасных пакетов, проверку их на уязвимости, контроль версий, управление лицензиями и мониторинг безопасности на протяжении всего жизненного цикла проекта.

## Архитектура системы управления безопасностью пакетов

### 1. Компоненты архитектуры

```javascript
// Архитектура системы управления безопасностью пакетов
class PackageSecurityManagerArchitecture {
    constructor(config) {
        this.config = {
            // Конфигурация системы
            scanning: {
                frequency: config.scanning?.frequency || 'daily',
                depth: config.scanning?.depth || 'full',
                tools: config.scanning?.tools || ['npm-audit', 'snyk', 'osv-scanner']
            },
            policies: {
                allow: config.policies?.allow || [],
                deny: config.policies?.deny || [],
                license: config.policies?.license || 'strict',
                version: config.policies?.version || 'secure'
            },
            monitoring: {
                enabled: config.monitoring?.enabled !== false,
                alerts: config.monitoring?.alerts || ['critical', 'high'],
                notifications: config.monitoring?.notifications || ['email', 'slack']
            },
            governance: {
                approvalRequired: config.governance?.approvalRequired || false,
                approvalThreshold: config.governance?.approvalThreshold || 'high',
                retention: config.governance?.retention || 90
            },
            ...config
        };
        
        this.components = {
            // Компоненты системы
            scanner: new VulnerabilityScanner(this.config.scanning),
            policyEngine: new PolicyEngine(this.config.policies),
            approver: new ApprovalSystem(this.config.governance),
            monitor: new SecurityMonitor(this.config.monitoring),
            reporter: new SecurityReporter(),
            auditor: new SecurityAuditor()
        };
        
        this.state = {
            packages: new Map(),
            vulnerabilities: new Map(),
            policies: new Map(),
            approvals: new Map(),
            metrics: new Map(),
            lastScan: null
        };
        
        this.integrityChecker = new PackageIntegrityChecker();
        this.licenseChecker = new LicenseComplianceChecker();
        this.versionManager = new VersionManager();
    }
    
    async initialize() {
        console.log('Initializing Package Security Management System...');
        
        // Инициализация всех компонентов
        await Promise.all([
            this.components.scanner.initialize(),
            this.components.policyEngine.initialize(),
            this.components.approver.initialize(),
            this.components.monitor.initialize()
        ]);
        
        // Загрузка текущих зависимостей
        await this.loadCurrentDependencies();
        
        // Загрузка политик
        await this.loadSecurityPolicies();
        
        // Запуск мониторинга
        this.startMonitoring();
        
        // Запуск регулярного сканирования
        this.scheduleRegularScans();
        
        console.log('Package Security Management System initialized successfully');
    }
    
    async loadCurrentDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        const allDeps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies,
            ...packageJson.optionalDependencies
        };
        
        for (const [name, version] of Object.entries(allDeps)) {
            const packageInfo = await this.getPackageInfo(name, version);
            this.state.packages.set(name, {
                name,
                version,
                resolvedVersion: packageInfo.version,
                license: packageInfo.license,
                maintainers: packageInfo.maintainers,
                published: packageInfo.time?.[packageInfo.version],
                integrity: packageInfo.dist?.integrity,
                security: await this.checkPackageSecurity(name, version),
                compliance: await this.checkPackageCompliance(name, version),
                status: 'ACTIVE'
            });
        }
    }
    
    async getPackageInfo(name, version) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name}@${version} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
    
    async checkPackageSecurity(name, version) {
        // Проверка безопасности пакета
        const vulnerabilities = await this.components.scanner.checkPackage(name, version);
        
        return {
            hasVulnerabilities: vulnerabilities.length > 0,
            vulnerabilityCount: vulnerabilities.length,
            criticalVulnerabilities: vulnerabilities.filter(v => v.severity === 'critical').length,
            highVulnerabilities: vulnerabilities.filter(v => v.severity === 'high').length,
            mediumVulnerabilities: vulnerabilities.filter(v => v.severity === 'medium').length,
            lowVulnerabilities: vulnerabilities.filter(v => v.severity === 'low').length,
            vulnerabilities: vulnerabilities
        };
    }
    
    async checkPackageCompliance(name, version) {
        // Проверка соответствия лицензионным требованиям
        const packageInfo = await this.getPackageInfo(name, version);
        const license = this.extractLicense(packageInfo);
        
        return {
            licenseCompliant: this.isLicenseCompliant(license),
            license: license,
            securityCompliant: await this.isSecurityCompliant(name, version),
            versionPolicyCompliant: this.isVersionPolicyCompliant(version)
        };
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo) return 'UNKNOWN';
        
        if (typeof packageInfo.license === 'string') {
            return packageInfo.license;
        }
        
        if (typeof packageInfo.license === 'object' && packageInfo.license.type) {
            return packageInfo.license.type;
        }
        
        if (Array.isArray(packageInfo.licenses) && packageInfo.licenses[0]) {
            return typeof packageInfo.licenses[0] === 'string' ? 
                   packageInfo.licenses[0] : 
                   packageInfo.licenses[0].type;
        }
        
        return 'UNKNOWN';
    }
    
    isLicenseCompliant(license) {
        const allowed = this.config.policies.license.allow || [
            'MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'
        ];
        
        const forbidden = this.config.policies.license.deny || [
            'GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'CC-BY-NC-4.0'
        ];
        
        if (forbidden.includes(license)) return false;
        if (allowed.includes(license)) return true;
        
        // Если лицензия не в белом списке и не в черном, проверить через анализ
        return this.analyzeLicenseRisks(license);
    }
    
    isSecurityCompliant(name, version) {
        // Проверка соответствия безопасности (реализация зависит от scanner)
        const securityInfo = this.state.packages.get(name)?.security;
        if (!securityInfo) return false;
        
        return securityInfo.criticalVulnerabilities === 0 && 
               securityInfo.highVulnerabilities === 0;
    }
    
    isVersionPolicyCompliant(version) {
        // Проверка соответствия политике версий
        return !version.includes('beta') && 
               !version.includes('alpha') && 
               !version.includes('rc');
    }
    
    startMonitoring() {
        if (!this.config.monitoring.enabled) return;
        
        // Запуск мониторинга новых уязвимостей
        setInterval(async () => {
            await this.checkForNewVulnerabilities();
        }, this.getScanInterval(this.config.scanning.frequency));
        
        // Запуск мониторинга новых версий
        setInterval(async () => {
            await this.checkForSecurityPatches();
        }, this.getUpdateInterval());
    }
    
    scheduleRegularScans() {
        // Планирование регулярных сканирований
        const scanInterval = this.getScanInterval(this.config.scanning.frequency);
        
        setInterval(async () => {
            await this.performFullSecurityScan();
        }, scanInterval);
    }
    
    getScanInterval(frequency) {
        const intervals = {
            'hourly': 60 * 60 * 1000,
            'daily': 24 * 60 * 60 * 1000,
            'weekly': 7 * 24 * 60 * 60 * 1000,
            'monthly': 30 * 24 * 60 * 60 * 1000
        };
        
        return intervals[frequency] || intervals['daily'];
    }
    
    getUpdateInterval() {
        // Интервал проверки обновлений
        return 6 * 60 * 60 * 1000; // 6 часов
    }
    
    async performFullSecurityScan() {
        const startTime = Date.now();
        
        try {
            // Сканирование всех зависимостей
            const scanResults = await this.components.scanner.scanAllDependencies();
            
            // Обновление состояния
            this.state.lastScan = {
                timestamp: new Date().toISOString(),
                duration: Date.now() - startTime,
                results: scanResults,
                packagesScanned: Object.keys(scanResults).length
            };
            
            // Обновление информации о пакетах
            for (const [name, scanResult] of Object.entries(scanResults)) {
                const packageInfo = this.state.packages.get(name);
                if (packageInfo) {
                    packageInfo.security = scanResult;
                    packageInfo.lastSecurityScan = new Date().toISOString();
                }
            }
            
            // Проверка на необходимость уведомлений
            await this.checkForSecurityAlerts(scanResults);
            
            // Логирование сканирования
            this.logSecurityScan(this.state.lastScan);
            
        } catch (error) {
            console.error('Full security scan failed:', error);
            
            // Отправка уведомления об ошибке сканирования
            await this.components.monitor.sendSystemAlert({
                type: 'SCAN_FAILED',
                severity: 'HIGH',
                message: `Full security scan failed: ${error.message}`,
                timestamp: new Date().toISOString()
            });
        }
    }
    
    async checkForNewVulnerabilities() {
        // Проверка на новые уязвимости в уже установленных пакетах
        const newVulnerabilities = [];
        
        for (const [name, pkgInfo] of this.state.packages) {
            const currentVulns = await this.checkPackageSecurity(name, pkgInfo.version);
            const previousVulns = pkgInfo.security?.vulnerabilities || [];
            
            // Найти новые уязвимости
            const previousIds = new Set(previousVulns.map(v => v.id));
            const newVulns = currentVulns.vulnerabilities.filter(v => !previousIds.has(v.id));
            
            if (newVulns.length > 0) {
                newVulnerabilities.push({
                    package: name,
                    version: pkgInfo.version,
                    newVulnerabilities: newVulns,
                    previousVulnerabilities: previousVulns.length
                });
                
                // Обновить информацию о безопасности
                pkgInfo.security = currentVulns;
                pkgInfo.lastSecurityScan = new Date().toISOString();
            }
        }
        
        if (newVulnerabilities.length > 0) {
            await this.handleNewVulnerabilities(newVulnerabilities);
        }
        
        return newVulnerabilities;
    }
    
    async checkForSecurityPatches() {
        // Проверка наличия патчей безопасности для установленных пакетов
        const securityPatches = [];
        
        for (const [name, pkgInfo] of this.state.packages) {
            if (pkgInfo.security?.hasVulnerabilities) {
                const patchInfo = await this.getSecurityPatchInfo(name, pkgInfo.version);
                
                if (patchInfo.hasPatches) {
                    securityPatches.push({
                        package: name,
                        currentVersion: pkgInfo.version,
                        latestPatchedVersion: patchInfo.latestPatchedVersion,
                        vulnerabilitiesFixed: patchInfo.vulnerabilitiesFixed,
                        patchAvailable: patchInfo.patchAvailable
                    });
                }
            }
        }
        
        if (securityPatches.length > 0) {
            await this.handleSecurityPatches(securityPatches);
        }
        
        return securityPatches;
    }
    
    async getSecurityPatchInfo(name, currentVersion) {
        // Получение информации о патчах безопасности
        try {
            const packageInfo = await this.getPackageInfo(name, 'latest');
            const latestVersion = packageInfo.version;
            
            // Проверка, содержит ли последняя версия исправления
            const currentVulns = await this.checkPackageSecurity(name, currentVersion);
            const latestVulns = await this.checkPackageSecurity(name, latestVersion);
            
            const vulnerabilitiesFixed = currentVulns.vulnerabilities.filter(
                currentVuln => !latestVulns.vulnerabilities.some(
                    latestVuln => latestVuln.id === currentVuln.id
                )
            );
            
            return {
                hasPatches: vulnerabilitiesFixed.length > 0,
                latestPatchedVersion: latestVersion,
                vulnerabilitiesFixed: vulnerabilitiesFixed,
                patchAvailable: this.versionManager.isNewerVersion(latestVersion, currentVersion)
            };
        } catch (error) {
            return { hasPatches: false, error: error.message };
        }
    }
    
    async handleNewVulnerabilities(newVulns) {
        // Обработка обнаруженных новых уязвимостей
        for (const vuln of newVulns) {
            // Проверка тяжести
            const criticalVulns = vuln.newVulnerabilities.filter(v => v.severity === 'critical');
            const highVulns = vuln.newVulnerabilities.filter(v => v.severity === 'high');
            
            if (criticalVulns.length > 0) {
                await this.components.monitor.sendAlert({
                    type: 'CRITICAL_VULNERABILITY_DETECTED',
                    severity: 'CRITICAL',
                    package: vuln.package,
                    version: vuln.version,
                    vulnerabilities: criticalVulns,
                    message: `Critical vulnerability detected in ${vuln.package}@${vuln.version}`
                });
            } else if (highVulns.length > 0) {
                await this.components.monitor.sendAlert({
                    type: 'HIGH_VULNERABILITY_DETECTED',
                    severity: 'HIGH',
                    package: vuln.package,
                    version: vuln.version,
                    vulnerabilities: highVulns,
                    message: `High severity vulnerability detected in ${vuln.package}@${vuln.version}`
                });
            }
            
            // Запись в историю
            this.logNewVulnerability(vuln);
        }
    }
    
    async handleSecurityPatches(patches) {
        // Обработка информации о патчах
        for (const patch of patches) {
            if (this.config.governance.approvalRequired) {
                // Требуется одобрение для обновления
                await this.requestUpdateApproval(patch);
            } else {
                // Автоматическое обновление (если безопасно)
                if (this.isUpdateSafe(patch)) {
                    await this.performAutomatedUpdate(patch);
                }
            }
        }
    }
    
    isUpdateSafe(patch) {
        // Проверка безопасности обновления
        return patch.patchAvailable && 
               this.versionManager.isSecurityPatch(patch.currentVersion, patch.latestPatchedVersion);
    }
    
    async requestUpdateApproval(patch) {
        // Запрос одобрения обновления
        const approvalRequest = {
            id: this.generateApprovalId(),
            type: 'SECURITY_UPDATE',
            package: patch.package,
            fromVersion: patch.currentVersion,
            toVersion: patch.latestPatchedVersion,
            vulnerabilitiesFixed: patch.vulnerabilitiesFixed,
            requestedAt: new Date().toISOString(),
            requestedBy: process.env.USER || 'system',
            status: 'PENDING'
        };
        
        this.state.approvals.set(approvalRequest.id, approvalRequest);
        
        // Отправка запроса на одобрение
        await this.components.approver.submitApprovalRequest(approvalRequest);
        
        return approvalRequest;
    }
    
    async performAutomatedUpdate(patch) {
        // Выполнение автоматического обновления
        try {
            const { execSync } = require('child_process');
            
            // Обновление пакета
            execSync(`npm install ${patch.package}@${patch.latestPatchedVersion}`, {
                stdio: 'inherit',
                cwd: process.cwd()
            });
            
            // Запуск тестов после обновления
            execSync('npm test', { stdio: 'inherit' });
            
            // Обновление информации о пакете
            const pkgInfo = this.state.packages.get(patch.package);
            if (pkgInfo) {
                pkgInfo.version = patch.latestPatchedVersion;
                pkgInfo.lastUpdated = new Date().toISOString();
                pkgInfo.security = await this.checkPackageSecurity(patch.package, patch.latestPatchedVersion);
            }
            
            console.log(`Automated security update completed for ${patch.package}`);
            
        } catch (error) {
            console.error(`Automated update failed for ${patch.package}:`, error.message);
            
            // Отправка уведомления о неудаче
            await this.components.monitor.sendAlert({
                type: 'AUTOMATED_UPDATE_FAILED',
                severity: 'MEDIUM',
                package: patch.package,
                fromVersion: patch.currentVersion,
                toVersion: patch.latestPatchedVersion,
                error: error.message
            });
        }
    }
    
    generateApprovalId() {
        return `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    logSecurityScan(scanInfo) {
        // Логирование результата сканирования
        console.log(`Security scan completed: ${scanInfo.packagesScanned} packages scanned in ${scanInfo.duration}ms`);
    }
    
    logNewVulnerability(vulnerabilityInfo) {
        // Логирование новой уязвимости
        console.warn(`New vulnerability detected: ${vulnerabilityInfo.package}@${vulnerabilityInfo.version}`, {
            newVulnerabilities: vulnerabilityInfo.newVulnerabilities.length,
            previousVulnerabilities: vulnerabilityInfo.previousVulnerabilities
        });
    }
    
    async checkForSecurityAlerts(scanResults) {
        // Проверка результатов сканирования на необходимость алертов
        const alerts = [];
        
        for (const [packageName, scanResult] of Object.entries(scanResults)) {
            if (scanResult.criticalVulnerabilities > 0) {
                alerts.push({
                    type: 'CRITICAL_VULNERABILITY',
                    severity: 'CRITICAL',
                    package: packageName,
                    vulnerabilities: scanResult.vulnerabilities.filter(v => v.severity === 'critical')
                });
            } else if (scanResult.highVulnerabilities > 0) {
                alerts.push({
                    type: 'HIGH_VULNERABILITY',
                    severity: 'HIGH',
                    package: packageName,
                    vulnerabilities: scanResult.vulnerabilities.filter(v => v.severity === 'high')
                });
            }
        }
        
        // Отправка алертов
        for (const alert of alerts) {
            await this.components.monitor.sendAlert(alert);
        }
        
        return alerts;
    }
    
    async getSecurityDashboard() {
        const packages = Array.from(this.state.packages.values());
        
        return {
            timestamp: new Date().toISOString(),
            summary: {
                totalPackages: packages.length,
                securePackages: packages.filter(p => !p.security.hasVulnerabilities).length,
                vulnerablePackages: packages.filter(p => p.security.hasVulnerabilities).length,
                criticalVulnerabilities: packages.reduce((sum, p) => sum + p.security.criticalVulnerabilities, 0),
                highVulnerabilities: packages.reduce((sum, p) => sum + p.security.highVulnerabilities, 0),
                complianceRate: this.calculateComplianceRate(packages),
                securityScore: this.calculateSecurityScore(packages)
            },
            detailed: {
                byLicense: this.countByLicense(packages),
                bySeverity: this.countBySeverity(packages),
                byStatus: this.countByStatus(packages),
                riskyPackages: this.getIdentifyRiskyPackages(packages)
            },
            recommendations: await this.generateSecurityRecommendations(packages),
            nextSteps: this.generateNextSteps()
        };
    }
    
    calculateComplianceRate(packages) {
        const compliant = packages.filter(p => 
            p.compliance.licenseCompliant && 
            p.compliance.securityCompliant
        ).length;
        
        return packages.length > 0 ? (compliant / packages.length) * 100 : 100;
    }
    
    calculateSecurityScore(packages) {
        // Расчет общего балла безопасности
        let totalScore = 0;
        let totalPackages = 0;
        
        for (const pkg of packages) {
            const score = this.calculatePackageSecurityScore(pkg);
            totalScore += score;
            totalPackages++;
        }
        
        return totalPackages > 0 ? totalScore / totalPackages : 100;
    }
    
    calculatePackageSecurityScore(packageInfo) {
        let score = 100;
        
        // Вычет за уязвимости
        score -= packageInfo.security.criticalVulnerabilities * 25;
        score -= packageInfo.security.highVulnerabilities * 15;
        score -= packageInfo.security.mediumVulnerabilities * 5;
        score -= packageInfo.security.lowVulnerabilities * 1;
        
        // Вычет за лицензионные проблемы
        if (!packageInfo.compliance.licenseCompliant) {
            score -= 20;
        }
        
        // Вычет за проблемы с версией
        if (!packageInfo.compliance.versionPolicyCompliant) {
            score -= 10;
        }
        
        return Math.max(0, score); // минимум 0
    }
    
    countByLicense(packages) {
        const counts = {};
        for (const pkg of packages) {
            const license = pkg.compliance.license;
            counts[license] = (counts[license] || 0) + 1;
        }
        return counts;
    }
    
    countBySeverity(packages) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, NONE: 0 };
        
        for (const pkg of packages) {
            if (pkg.security.hasVulnerabilities) {
                counts.CRITICAL += pkg.security.criticalVulnerabilities;
                counts.HIGH += pkg.security.highVulnerabilities;
                counts.MEDIUM += pkg.security.mediumVulnerabilities;
                counts.LOW += pkg.security.lowVulnerabilities;
            } else {
                counts.NONE++;
            }
        }
        
        return counts;
    }
    
    countByStatus(packages) {
        const counts = { ACTIVE: 0, INACTIVE: 0, SUSPENDED: 0 };
        
        for (const pkg of packages) {
            counts[pkg.status] = (counts[pkg.status] || 0) + 1;
        }
        
        return counts;
    }
    
    getIdentifyRiskyPackages(packages) {
        return packages
            .filter(pkg => pkg.security.hasVulnerabilities)
            .sort((a, b) => b.security.criticalVulnerabilities - a.security.criticalVulnerabilities)
            .slice(0, 10); // топ 10 рискованных пакетов
    }
    
    async generateSecurityRecommendations(packages) {
        const recommendations = [];
        
        const vulnerablePackages = packages.filter(p => p.security.hasVulnerabilities);
        if (vulnerablePackages.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Package Vulnerabilities',
                description: `Found ${vulnerablePackages.length} vulnerable packages`,
                action: 'Update vulnerable packages to secure versions',
                affectedPackages: vulnerablePackages.map(p => p.name)
            });
        }
        
        const nonCompliantPackages = packages.filter(p => !p.compliance.licenseCompliant);
        if (nonCompliantPackages.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Fix License Compliance Issues',
                description: `Found ${nonCompliantPackages.length} non-compliant packages`,
                action: 'Replace packages with compliant alternatives or obtain proper licenses',
                affectedPackages: nonCompliantPackages.map(p => p.name)
            });
        }
        
        const outdatedPackages = await this.checkForOutdatedPackages(packages);
        if (outdatedPackages.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Update Outdated Packages',
                description: `Found ${outdatedPackages.length} outdated packages`,
                action: 'Update packages to latest stable versions',
                affectedPackages: outdatedPackages.map(p => p.name)
            });
        }
        
        return recommendations;
    }
    
    async checkForOutdatedPackages(packages) {
        // Проверка на устаревшие пакеты
        const outdated = [];
        
        for (const pkg of packages) {
            try {
                const latestVersion = await this.getLatestVersion(pkg.name);
                if (this.versionManager.isOutdated(pkg.version, latestVersion)) {
                    outdated.push(pkg);
                }
            } catch (error) {
                // Игнорировать ошибки получения последней версии
            }
        }
        
        return outdated;
    }
    
    async getLatestVersion(packageName) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${packageName} version --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
    
    generateNextSteps() {
        return [
            '1. Review and prioritize vulnerable packages',
            '2. Plan security updates for critical vulnerabilities',
            '3. Implement automated security scanning in CI/CD',
            '4. Review and update security policies',
            '5. Train development team on secure package selection'
        ];
    }
    
    async exportSecurityReport(format = 'json') {
        const dashboard = await this.getSecurityDashboard();
        
        switch (format.toLowerCase()) {
            case 'json':
                return JSON.stringify(dashboard, null, 2);
            case 'html':
                return this.generateHTMLReport(dashboard);
            case 'csv':
                return this.generateCSVReport(dashboard);
            case 'sarif':
                return this.generateSARIFReport(dashboard);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    generateHTMLReport(dashboard) {
        return `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Package Security Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f5f5f5; padding: 15px; margin: 10px 0; }
                .package { border: 1px solid #ddd; margin: 10px 0; padding: 10px; }
                .critical { border-left: 5px solid #d32f2f; }
                .high { border-left: 5px solid #f57c00; }
                .medium { border-left: 5px solid #fbc02d; }
                .low { border-left: 5px solid #689f38; }
                .secure { border-left: 5px solid #4caf50; }
            </style>
        </head>
        <body>
            <h1>Package Security Report</h1>
            <div class="summary">
                <h2>Security Summary</h2>
                <p>Total Packages: ${dashboard.summary.totalPackages}</p>
                <p>Secure Packages: ${dashboard.summary.securePackages}</p>
                <p>Vulnerable Packages: ${dashboard.summary.vulnerablePackages}</p>
                <p>Security Score: ${dashboard.summary.securityScore.toFixed(2)}</p>
                <p>Compliance Rate: ${dashboard.summary.complianceRate.toFixed(2)}%</p>
            </div>
            
            <h2>Package Details</h2>
            ${Array.from(this.state.packages.values()).map(pkg => `
                <div class="package ${this.getPackageSecurityClass(pkg)}">
                    <h3>${pkg.name}@${pkg.version}</h3>
                    <p>License: ${pkg.compliance.license}</p>
                    <p>Security: ${pkg.security.vulnerabilityCount} vulnerabilities</p>
                    <p>Status: ${pkg.status}</p>
                    ${pkg.security.hasVulnerabilities ? `
                        <div>
                            <h4>Vulnerabilities:</h4>
                            <ul>
                                ${pkg.security.vulnerabilities.map(v => 
                                    `<li><strong>${v.severity}</strong>: ${v.title}</li>`
                                ).join('')}
                            </ul>
                        </div>
                    ` : '<p><em>No vulnerabilities detected</em></p>'}
                </div>
            `).join('')}
        </body>
        </html>
        `;
    }
    
    getPackageSecurityClass(pkg) {
        if (pkg.security.criticalVulnerabilities > 0) return 'critical';
        if (pkg.security.highVulnerabilities > 0) return 'high';
        if (pkg.security.mediumVulnerabilities > 0) return 'medium';
        if (pkg.security.lowVulnerabilities > 0) return 'low';
        return 'secure';
    }
    
    generateCSVReport(dashboard) {
        let csv = 'Package,Version,License,Severity,Status,Critical,High,Medium,Low\n';
        
        for (const pkg of this.state.packages.values()) {
            csv += `"${pkg.name}","${pkg.version}","${pkg.compliance.license}",` +
                   `"${pkg.security.hasVulnerabilities ? 'VULNERABLE' : 'SECURE'}","${pkg.status}",` +
                   `"${pkg.security.criticalVulnerabilities}","${pkg.security.highVulnerabilities}",` +
                   `"${pkg.security.mediumVulnerabilities}","${pkg.security.lowVulnerabilities}"\n`;
        }
        
        return csv;
    }
    
    generateSARIFReport(dashboard) {
        return {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'Package Security Manager',
                        version: '1.0.0',
                        informationUri: 'https://github.com/your-org/package-security-manager'
                    }
                },
                results: Array.from(this.state.packages.values())
                    .filter(pkg => pkg.security.hasVulnerabilities)
                    .flatMap(pkg => pkg.security.vulnerabilities.map(vuln => ({
                        ruleId: vuln.id,
                        level: this.severityToSARIFLevel(vuln.severity),
                        message: {
                            text: `${vuln.title}: ${vuln.description}`
                        },
                        locations: [{
                            physicalLocation: {
                                artifactLocation: {
                                    uri: `npm://${pkg.name}@${pkg.version}`
                                }
                            }
                        }],
                        properties: {
                            severity: vuln.severity,
                            cvssScore: vuln.cvssScore,
                            cve: vuln.cve,
                            vulnerableVersions: vuln.vulnerableVersions,
                            patchedVersions: vuln.patchedVersions
                        }
                    })))
            }]
        };
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'CRITICAL': 'error',
            'HIGH': 'error',
            'MEDIUM': 'warning',
            'LOW': 'note'
        };
        return mapping[severity] || 'warning';
    }
}

// Использование системы управления безопасностью пакетов
const packageSecurityManager = new PackageSecurityManager({
    scanning: {
        frequency: 'daily',
        tools: ['npm-audit', 'snyk', 'osv-scanner']
    },
    policies: {
        allow: ['MIT', 'Apache-2.0', 'BSD-3-Clause'],
        deny: ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0'],
        license: 'strict',
        version: 'secure'
    },
    monitoring: {
        enabled: true,
        alerts: ['critical', 'high'],
        notifications: ['email', 'slack']
    },
    governance: {
        approvalRequired: true,
        approvalThreshold: 'high'
    }
});

await packageSecurityManager.initialize();
```

## Система управления политиками

### 1. Движок политик безопасности

```javascript
// Движок управления политиками безопасности пакетов
class PolicyEngine {
    constructor(config) {
        this.config = {
            defaultPolicy: config.defaultPolicy || 'secure',
            enforcement: config.enforcement || 'strict',
            overrideMechanism: config.overrideMechanism || 'admin_only',
            ...config
        };
        
        this.policies = new Map();
        this.policyHistory = [];
        this.policyViolations = [];
        this.policyOverrides = new Map();
        
        this.loadPolicies();
    }
    
    async initialize() {
        // Инициализация политики
        await this.loadPolicyDatabase();
        await this.loadPolicyOverrides();
    }
    
    loadPolicies() {
        // Загрузка политик из конфигурации
        const defaultPolicies = [
            {
                id: 'default-security',
                name: 'Default Security Policy',
                description: 'Basic security requirements for all packages',
                conditions: {
                    license: {
                        allowed: this.config.policies.allow || ['MIT', 'Apache-2.0', 'BSD-3-Clause'],
                        forbidden: this.config.policies.deny || ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0']
                    },
                    version: {
                        allowPreRelease: false,
                        allowBeta: false,
                        allowAlpha: false
                    },
                    source: {
                        trustedRegistries: ['https://registry.npmjs.org/'],
                        allowGitDependencies: false,
                        allowTarballDependencies: false
                    },
                    quality: {
                        minDownloads: 1000,
                        minAgeDays: 30,
                        activeMaintainer: true,
                        securityScore: 70
                    }
                },
                actions: {
                    allow: true,
                    requireApproval: false,
                    block: false
                },
                priority: 100,
                enabled: true
            },
            {
                id: 'critical-packages',
                name: 'Critical Packages Policy',
                description: 'Enhanced security for critical packages',
                conditions: {
                    package: {
                        name: ['express', 'react', 'vue', 'angular', 'jquery']
                    },
                    severity: {
                        maxCritical: 0,
                        maxHigh: 0
                    }
                },
                actions: {
                    allow: true,
                    requireApproval: true,
                    requireSecurityReview: true,
                    block: false
                },
                priority: 200,
                enabled: true
            }
        ];
        
        for (const policy of defaultPolicies) {
            this.policies.set(policy.id, policy);
        }
    }
    
    async evaluatePackage(packageInfo) {
        const evaluation = {
            package: packageInfo.name,
            version: packageInfo.version,
            compliant: true,
            policyViolations: [],
            policyRecommendations: [],
            overallScore: 0
        };
        
        // Получение всех активных политик
        const activePolicies = Array.from(this.policies.values())
            .filter(policy => policy.enabled)
            .sort((a, b) => b.priority - a.priority);
        
        for (const policy of activePolicies) {
            const policyResult = await this.evaluateAgainstPolicy(packageInfo, policy);
            
            if (!policyResult.compliant) {
                evaluation.compliant = false;
                evaluation.policyViolations.push({
                    policyId: policy.id,
                    policyName: policy.name,
                    violations: policyResult.violations,
                    severity: this.calculateViolationSeverity(policyResult.violations)
                });
                
                // Применение действий политики
                if (policyResult.actions.block) {
                    evaluation.compliant = false;
                }
            }
            
            // Сбор рекомендаций
            if (policyResult.recommendations.length > 0) {
                evaluation.policyRecommendations.push(...policyResult.recommendations);
            }
        }
        
        // Проверка на разрешения (override)
        const override = this.checkPolicyOverride(packageInfo);
        if (override) {
            evaluation.compliant = true;
            evaluation.overridden = true;
            evaluation.overrideReason = override.reason;
        }
        
        evaluation.overallScore = this.calculateOverallScore(evaluation);
        
        return evaluation;
    }
    
    async evaluateAgainstPolicy(packageInfo, policy) {
        const result = {
            policyId: policy.id,
            compliant: true,
            violations: [],
            recommendations: [],
            actions: { ...policy.actions }
        };
        
        // Проверка лицензии
        if (policy.conditions.license) {
            const licenseCheck = await this.checkLicenseCompliance(
                packageInfo.license, 
                policy.conditions.license
            );
            
            if (!licenseCheck.compliant) {
                result.compliant = false;
                result.violations.push({
                    type: 'LICENSE_COMPLIANCE',
                    field: 'license',
                    expected: policy.conditions.license,
                    actual: packageInfo.license,
                    severity: 'HIGH'
                });
            }
        }
        
        // Проверка версии
        if (policy.conditions.version) {
            const versionCheck = this.checkVersionCompliance(
                packageInfo.version,
                policy.conditions.version
            );
            
            if (!versionCheck.compliant) {
                result.compliant = false;
                result.violations.push({
                    type: 'VERSION_COMPLIANCE',
                    field: 'version',
                    expected: policy.conditions.version,
                    actual: packageInfo.version,
                    severity: 'MEDIUM'
                });
            }
        }
        
        // Проверка источника
        if (policy.conditions.source) {
            const sourceCheck = await this.checkSourceCompliance(
                packageInfo.source,
                policy.conditions.source
            );
            
            if (!sourceCheck.compliant) {
                result.compliant = false;
                result.violations.push({
                    type: 'SOURCE_COMPLIANCE',
                    field: 'source',
                    expected: policy.conditions.source,
                    actual: packageInfo.source,
                    severity: 'HIGH'
                });
            }
        }
        
        // Проверка качества
        if (policy.conditions.quality) {
            const qualityCheck = await this.checkQualityCompliance(
                packageInfo,
                policy.conditions.quality
            );
            
            if (!qualityCheck.compliant) {
                result.compliant = false;
                result.violations.push({
                    type: 'QUALITY_COMPLIANCE',
                    field: 'quality',
                    expected: policy.conditions.quality,
                    actual: qualityCheck.actual,
                    severity: 'MEDIUM'
                });
                
                result.recommendations.push(...qualityCheck.recommendations);
            }
        }
        
        return result;
    }
    
    async checkLicenseCompliance(license, policy) {
        const result = { compliant: true, issues: [] };
        
        if (policy.forbidden && policy.forbidden.includes(license)) {
            result.compliant = false;
            result.issues.push({
                type: 'FORBIDDEN_LICENSE',
                message: `License ${license} is forbidden by policy`
            });
        }
        
        if (policy.allowed && !policy.allowed.includes(license)) {
            result.compliant = false;
            result.issues.push({
                type: 'LICENSE_NOT_ALLOWED',
                message: `License ${license} is not in allowed list`
            });
        }
        
        return result;
    }
    
    checkVersionCompliance(version, policy) {
        const result = { compliant: true, issues: [] };
        
        if (policy.allowPreRelease === false && /-pre|-rc|-beta|-alpha/.test(version)) {
            result.compliant = false;
            result.issues.push({
                type: 'PRE_RELEASE_VERSION',
                message: `Pre-release version not allowed: ${version}`
            });
        }
        
        if (policy.allowBeta === false && /-beta/.test(version)) {
            result.compliant = false;
            result.issues.push({
                type: 'BETA_VERSION',
                message: `Beta version not allowed: ${version}`
            });
        }
        
        if (policy.allowAlpha === false && /-alpha/.test(version)) {
            result.compliant = false;
            result.issues.push({
                type: 'ALPHA_VERSION',
                message: `Alpha version not allowed: ${version}`
            });
        }
        
        return result;
    }
    
    async checkSourceCompliance(source, policy) {
        const result = { compliant: true, issues: [] };
        
        if (policy.trustedRegistries && source) {
            const isTrusted = policy.trustedRegistries.some(registry => 
                source.startsWith(registry)
            );
            
            if (!isTrusted) {
                result.compliant = false;
                result.issues.push({
                    type: 'UNTRUSTED_SOURCE',
                    message: `Package from untrusted source: ${source}`
                });
            }
        }
        
        return result;
    }
    
    async checkQualityCompliance(packageInfo, policy) {
        const result = { 
            compliant: true, 
            issues: [], 
            recommendations: [],
            actual: {}
        };
        
        // Проверка количества скачиваний
        if (policy.minDownloads) {
            const downloads = await this.getDownloadCount(packageInfo.name);
            result.actual.downloads = downloads;
            
            if (downloads < policy.minDownloads) {
                result.compliant = false;
                result.issues.push({
                    type: 'LOW_DOWNLOADS',
                    message: `Package has only ${downloads} downloads, minimum required: ${policy.minDownloads}`
                });
            }
        }
        
        // Проверка возраста
        if (policy.minAgeDays) {
            const age = await this.getPackageAge(packageInfo.name, packageInfo.version);
            result.actual.age = age;
            
            if (age < policy.minAgeDays) {
                result.compliant = false;
                result.issues.push({
                    type: 'NEW_PACKAGE',
                    message: `Package is only ${age} days old, minimum required: ${policy.minAgeDays}`
                });
            }
        }
        
        // Проверка активного сопровождения
        if (policy.activeMaintainer) {
            const hasActiveMaintainer = await this.hasActiveMaintainer(packageInfo.name);
            result.actual.activeMaintainer = hasActiveMaintainer;
            
            if (!hasActiveMaintainer) {
                result.compliant = false;
                result.issues.push({
                    type: 'NO_ACTIVE_MAINTAINER',
                    message: `Package does not have active maintainer`
                });
            }
        }
        
        // Проверка балла безопасности
        if (policy.securityScore) {
            const securityScore = await this.getSecurityScore(packageInfo.name, packageInfo.version);
            result.actual.securityScore = securityScore;
            
            if (securityScore < policy.securityScore) {
                result.compliant = false;
                result.issues.push({
                    type: 'LOW_SECURITY_SCORE',
                    message: `Package security score is ${securityScore}, minimum required: ${policy.securityScore}`
                });
                
                result.recommendations.push({
                    type: 'IMPROVE_SECURITY',
                    message: `Package ${packageInfo.name} has low security score, consider alternatives`
                });
            }
        }
        
        return result;
    }
    
    async getDownloadCount(packageName) {
        // В реальности использовать npm registry API
        // Здесь заглушка
        return Math.floor(Math.random() * 1000000) + 1000; // случайное значение от 1k до 1M
    }
    
    async getPackageAge(packageName, version) {
        // В реальности использовать npm view для получения времени публикации
        try {
            const packageInfo = await this.getPackageInfo(packageName);
            const publishTime = packageInfo.time?.[version];
            
            if (publishTime) {
                const publishDate = new Date(publishTime);
                const now = new Date();
                const ageInDays = Math.floor((now - publishDate) / (1000 * 60 * 60 * 24));
                return ageInDays;
            }
        } catch {
            return 0;
        }
    }
    
    async hasActiveMaintainer(packageName) {
        try {
            const packageInfo = await this.getPackageInfo(packageName);
            const maintainers = packageInfo.maintainers || [];
            
            // Проверка, есть ли сопровождающие
            if (maintainers.length === 0) {
                return false;
            }
            
            // Проверка активности (последнее обновление в последние 6 месяцев)
            const versions = Object.keys(packageInfo.time || {});
            if (versions.length === 0) return false;
            
            const sortedVersions = versions
                .filter(version => packageInfo.time[version])
                .sort((a, b) => new Date(packageInfo.time[b]) - new Date(packageInfo.time[a]));
            
            const latestUpdate = new Date(packageInfo.time[sortedVersions[0]]);
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            
            return latestUpdate > sixMonthsAgo;
        } catch {
            return false;
        }
    }
    
    async getSecurityScore(packageName, version) {
        // В реальности использовать данные из сканирования уязвимостей
        // Здесь заглушка
        const scanResults = await this.getPackageVulnerabilities(packageName, version);
        const totalVulns = scanResults.length;
        
        // Базовая оценка: 100 - (количество уязвимостей * 5)
        return Math.max(0, 100 - (totalVulns * 5));
    }
    
    async getPackageVulnerabilities(packageName, version) {
        // Получение уязвимостей для пакета
        // В реальности использовать npm audit, Snyk или OSV
        return []; // заглушка
    }
    
    checkPolicyOverride(packageInfo) {
        // Проверка на наличие разрешения для конкретного пакета
        const overrideKey = `${packageInfo.name}@${packageInfo.version}`;
        return this.policyOverrides.get(overrideKey);
    }
    
    async addPolicyOverride(packageName, version, reason, approvedBy, expiresAt = null) {
        const override = {
            packageName,
            version,
            reason,
            approvedBy,
            approvedAt: new Date().toISOString(),
            expiresAt,
            active: true
        };
        
        const key = `${packageName}@${version}`;
        this.policyOverrides.set(key, override);
        
        // Сохранение в базу данных или файл
        await this.savePolicyOverride(override);
        
        return override;
    }
    
    async removePolicyOverride(packageName, version) {
        const key = `${packageName}@${version}`;
        const override = this.policyOverrides.get(key);
        
        if (override) {
            override.active = false;
            await this.savePolicyOverride(override);
            this.policyOverrides.delete(key);
            return override;
        }
        
        return null;
    }
    
    calculateViolationSeverity(violations) {
        const severityWeights = {
            'CRITICAL': 5,
            'HIGH': 4,
            'MEDIUM': 3,
            'LOW': 2,
            'INFO': 1
        };
        
        const maxSeverity = violations.reduce((max, violation) => {
            const weight = severityWeights[violation.severity] || 3;
            return weight > max ? weight : max;
        }, 0);
        
        const severityLabels = { 5: 'CRITICAL', 4: 'HIGH', 3: 'MEDIUM', 2: 'LOW', 1: 'INFO' };
        return severityLabels[maxSeverity] || 'MEDIUM';
    }
    
    calculateOverallScore(evaluation) {
        if (evaluation.policyViolations.length === 0) return 100;
        
        // Расчет на основе количества и тяжести нарушений
        let score = 100;
        
        for (const violation of evaluation.policyViolations) {
            const severityPenalty = {
                'CRITICAL': 25,
                'HIGH': 15,
                'MEDIUM': 8,
                'LOW': 3
            }[violation.severity] || 5;
            
            score -= severityPenalty;
        }
        
        return Math.max(0, score);
    }
    
    async getPolicyComplianceReport() {
        const allPackages = Array.from(this.packageSecurityManager.state.packages.values());
        const complianceResults = [];
        
        for (const pkg of allPackages) {
            const evaluation = await this.evaluatePackage(pkg);
            complianceResults.push({
                package: pkg.name,
                version: pkg.version,
                compliant: evaluation.compliant,
                score: evaluation.overallScore,
                violations: evaluation.policyViolations.length,
                override: evaluation.overridden
            });
        }
        
        return {
            timestamp: new Date().toISOString(),
            totalPackages: allPackages.length,
            compliantPackages: complianceResults.filter(r => r.compliant).length,
            nonCompliantPackages: complianceResults.filter(r => !r.compliant).length,
            overriddenPackages: complianceResults.filter(r => r.override).length,
            averageComplianceScore: this.calculateAverageScore(complianceResults),
            byPolicy: this.countByPolicy(complianceResults),
            recommendations: this.generatePolicyRecommendations(complianceResults)
        };
    }
    
    calculateAverageScore(results) {
        if (results.length === 0) return 0;
        const totalScore = results.reduce((sum, r) => sum + r.score, 0);
        return totalScore / results.length;
    }
    
    countByPolicy(results) {
        // Подсчет результатов по политикам
        return { total: results.length, compliant: results.filter(r => r.compliant).length };
    }
    
    generatePolicyRecommendations(results) {
        const recommendations = [];
        
        const nonCompliantCount = results.filter(r => !r.compliant).length;
        if (nonCompliantCount > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Policy Violations',
                description: `Found ${nonCompliantCount} packages with policy violations`,
                action: 'Review and fix policy violations or add appropriate overrides'
            });
        }
        
        const lowScoreCount = results.filter(r => r.score < 70).length;
        if (lowScoreCount > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Package Selection Policy',
                description: `Found ${lowScoreCount} packages with low security scores`,
                action: 'Review package selection criteria and update policies'
            });
        }
        
        return recommendations;
    }
    
    async savePolicyOverride(override) {
        // Сохранение разрешения в базу данных или файл
        const fs = require('fs');
        const path = require('path');
        
        const overridesDir = path.join(process.cwd(), '.security', 'policy-overrides');
        if (!fs.existsSync(overridesDir)) {
            fs.mkdirSync(overridesDir, { recursive: true });
        }
        
        const overrideFile = path.join(overridesDir, `${override.packageName}-${override.version}.json`);
        fs.writeFileSync(overrideFile, JSON.stringify(override, null, 2));
    }
    
    async loadPolicyOverrides() {
        // Загрузка разрешений из файлов
        const fs = require('fs');
        const path = require('path');
        
        const overridesDir = path.join(process.cwd(), '.security', 'policy-overrides');
        if (!fs.existsSync(overridesDir)) return;
        
        const files = fs.readdirSync(overridesDir);
        
        for (const file of files) {
            if (file.endsWith('.json')) {
                try {
                    const override = JSON.parse(fs.readFileSync(path.join(overridesDir, file), 'utf8'));
                    const key = `${override.packageName}@${override.version}`;
                    this.policyOverrides.set(key, override);
                } catch (error) {
                    console.error(`Failed to load override from ${file}:`, error);
                }
            }
        }
    }
    
    async loadPolicyDatabase() {
        // Загрузка базы данных политик
        // В реальности из БД или файловой системы
    }
    
    async getPackageInfo(name) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
}

// Использование движка политик
const policyEngine = new PolicyEngine({
    policies: {
        allow: ['MIT', 'Apache-2.0', 'BSD-3-Clause'],
        deny: ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0']
    }
});

await policyEngine.initialize();
```

## Система одобрения зависимостей

### 1. Управление одобрениями

```javascript
// Система одобрения зависимостей
class ApprovalSystem {
    constructor(config) {
        this.config = {
            approvalThreshold: config.approvalThreshold || 'high',
            approvers: config.approvers || [],
            approvalTimeout: config.approvalTimeout || 7 * 24 * 60 * 60 * 1000, // 7 дней
            ...config
        };
        
        this.approvalQueue = [];
        this.approvedPackages = new Map();
        this.rejectedPackages = new Map();
        this.pendingApprovals = new Map();
    }
    
    async initialize() {
        await this.loadApprovalHistory();
        await this.setupApprovalWorkflow();
    }
    
    async submitApprovalRequest(request) {
        // Валидация запроса
        if (!this.validateApprovalRequest(request)) {
            throw new Error('Invalid approval request');
        }
        
        // Генерация ID запроса
        request.id = this.generateApprovalId();
        request.status = 'PENDING';
        request.createdAt = new Date().toISOString();
        request.submittedBy = request.submittedBy || process.env.USER || 'system';
        
        // Добавление в очередь
        this.approvalQueue.push(request);
        this.pendingApprovals.set(request.id, request);
        
        // Отправка уведомления о новом запросе
        await this.notifyApprovers(request);
        
        return request;
    }
    
    validateApprovalRequest(request) {
        const requiredFields = ['package', 'version', 'reason', 'submittedBy'];
        
        for (const field of requiredFields) {
            if (!request[field]) {
                console.error(`Missing required field: ${field}`);
                return false;
            }
        }
        
        // Проверка, что запрос соответствует политике одобрения
        const severity = this.getPackageSeverity(request.package, request.version);
        const requiresApproval = this.requiresApproval(severity, request);
        
        return requiresApproval;
    }
    
    getPackageSeverity(packageName, version) {
        // Получение тяжести уязвимостей пакета
        // В реальности использовать результаты сканирования
        return 'MEDIUM'; // заглушка
    }
    
    requiresApproval(severity, request) {
        const severityThreshold = this.config.approvalThreshold.toUpperCase();
        const requestSeverity = severity.toUpperCase();
        
        const severityOrder = ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
        const thresholdIndex = severityOrder.indexOf(severityThreshold);
        const requestIndex = severityOrder.indexOf(requestSeverity);
        
        return requestIndex >= thresholdIndex;
    }
    
    async notifyApprovers(request) {
        // Отправка уведомления утверждающим
        const notificationSystem = new NotificationManager();
        
        const message = {
            type: 'PACKAGE_APPROVAL_REQUEST',
            title: `Package Approval Required: ${request.package}@${request.version}`,
            description: `Package ${request.package}@${request.version} requires approval due to security concerns`,
            details: {
                package: request.package,
                version: request.version,
                reason: request.reason,
                requestedBy: request.submittedBy,
                severity: request.severity,
                vulnerabilities: request.vulnerabilities,
                license: request.license
            },
            actionRequired: true,
            requestUrl: `${process.env.APP_URL}/admin/approvals/${request.id}`
        };
        
        // Отправка уведомлений утверждающим
        for (const approver of this.config.approvers) {
            await notificationSystem.sendNotification(approver, message);
        }
    }
    
    async approveRequest(requestId, approvedBy, notes = '') {
        const request = this.pendingApprovals.get(requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not pending approval');
        }
        
        // Проверка прав утверждающего
        if (!this.hasApprovalPermission(approvedBy)) {
            throw new Error('User does not have approval permissions');
        }
        
        // Одобрение запроса
        request.status = 'APPROVED';
        request.approvedBy = approvedBy;
        request.approvedAt = new Date().toISOString();
        request.notes = notes;
        
        // Добавление в одобренные пакеты
        const packageKey = `${request.package}@${request.version}`;
        this.approvedPackages.set(packageKey, {
            ...request,
            approvedAt: request.approvedAt
        });
        
        // Удаление из ожидающих
        this.pendingApprovals.delete(requestId);
        
        // Логирование одобрения
        this.logApprovalAction(request, 'APPROVED');
        
        // Отправка уведомления о одобрении
        await this.notifyApprovalResult(request, 'APPROVED');
        
        return request;
    }
    
    async rejectRequest(requestId, rejectedBy, reason) {
        const request = this.pendingApprovals.get(requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not pending approval');
        }
        
        // Проверка прав
        if (!this.hasApprovalPermission(rejectedBy)) {
            throw new Error('User does not have approval permissions');
        }
        
        // Отклонение запроса
        request.status = 'REJECTED';
        request.rejectedBy = rejectedBy;
        request.rejectedAt = new Date().toISOString();
        request.rejectionReason = reason;
        
        // Добавление в отклоненные
        const packageKey = `${request.package}@${request.version}`;
        this.rejectedPackages.set(packageKey, {
            ...request,
            rejectedAt: request.rejectedAt
        });
        
        // Удаление из ожидающих
        this.pendingApprovals.delete(requestId);
        
        // Логирование отклонения
        this.logApprovalAction(request, 'REJECTED');
        
        // Отправка уведомления об отклонении
        await this.notifyApprovalResult(request, 'REJECTED');
        
        return request;
    }
    
    hasApprovalPermission(user) {
        // Проверка прав утверждающего
        return this.config.approvers.includes(user) || 
               this.config.approvers.some(approver => 
                   typeof approver === 'object' && approver.user === user
               );
    }
    
    logApprovalAction(request, action) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            action: action,
            request: request.id,
            package: request.package,
            version: request.version,
            by: action === 'APPROVED' ? request.approvedBy : request.rejectedBy,
            reason: action === 'REJECTED' ? request.rejectionReason : request.reason
        };
        
        console.log(`Approval ${action}: ${request.package}@${request.version} by ${logEntry.by}`);
        
        // В реальности логировать в систему аудита
        this.approvalHistory.push(logEntry);
    }
    
    async notifyApprovalResult(request, result) {
        const notificationSystem = new NotificationManager();
        
        const message = {
            type: 'PACKAGE_APPROVAL_RESULT',
            title: `Package Approval ${result}: ${request.package}@${request.version}`,
            description: `Package approval request ${result.toLowerCase()} by ${result === 'APPROVED' ? request.approvedBy : request.rejectedBy}`,
            details: {
                package: request.package,
                version: request.version,
                result: result,
                approver: result === 'APPROVED' ? request.approvedBy : request.rejectedBy,
                reason: result === 'REJECTED' ? request.rejectionReason : request.reason
            }
        };
        
        // Уведомление подателя запроса
        await notificationSystem.sendNotification(request.submittedBy, message);
        
        // Уведомление команды безопасности
        for (const approver of this.config.approvers) {
            await notificationSystem.sendNotification(approver, message);
        }
    }
    
    async getApprovalQueue(filters = {}) {
        let queue = [...this.approvalQueue];
        
        if (filters.status) {
            queue = queue.filter(req => req.status === filters.status);
        }
        
        if (filters.package) {
            queue = queue.filter(req => req.package === filters.package);
        }
        
        if (filters.severity) {
            queue = queue.filter(req => req.severity === filters.severity);
        }
        
        return queue.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }
    
    async getApprovalStatistics() {
        const stats = {
            totalRequests: this.approvalQueue.length,
            pending: this.approvalQueue.filter(r => r.status === 'PENDING').length,
            approved: this.approvalQueue.filter(r => r.status === 'APPROVED').length,
            rejected: this.approvalQueue.filter(r => r.status === 'REJECTED').length,
            bySeverity: this.countBySeverity(this.approvalQueue),
            byMonth: this.countByMonth(this.approvalQueue),
            averageApprovalTime: this.calculateAverageApprovalTime(),
            approvalRate: this.calculateApprovalRate()
        };
        
        return stats;
    }
    
    countBySeverity(requests) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
        
        for (const req of requests) {
            counts[req.severity] = (counts[req.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    countByMonth(requests) {
        const counts = {};
        
        for (const req of requests) {
            const month = new Date(req.createdAt).toISOString().slice(0, 7);
            counts[month] = (counts[month] || 0) + 1;
        }
        
        return counts;
    }
    
    calculateAverageApprovalTime() {
        const approved = this.approvalQueue.filter(r => r.status === 'APPROVED' && r.approvedAt);
        
        if (approved.length === 0) return 0;
        
        const totalDuration = approved.reduce((sum, req) => {
            const submitted = new Date(req.createdAt);
            const approved = new Date(req.approvedAt);
            return sum + (approved - submitted);
        }, 0);
        
        return totalDuration / approved.length;
    }
    
    calculateApprovalRate() {
        const total = this.approvalQueue.length;
        const approved = this.approvalQueue.filter(r => r.status === 'APPROVED').length;
        
        return total > 0 ? (approved / total) * 100 : 0;
    }
    
    generateApprovalId() {
        return `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async loadApprovalHistory() {
        // Загрузка истории одобрений из базы данных или файлов
        const fs = require('fs');
        const path = require('path');
        
        const historyDir = path.join(process.cwd(), '.security', 'approvals');
        if (fs.existsSync(historyDir)) {
            const files = fs.readdirSync(historyDir);
            
            for (const file of files) {
                if (file.endsWith('.json')) {
                    try {
                        const approval = JSON.parse(fs.readFileSync(path.join(historyDir, file), 'utf8'));
                        this.approvalQueue.push(approval);
                        
                        if (approval.status === 'APPROVED') {
                            this.approvedPackages.set(`${approval.package}@${approval.version}`, approval);
                        } else if (approval.status === 'REJECTED') {
                            this.rejectedPackages.set(`${approval.package}@${approval.version}`, approval);
                        }
                    } catch (error) {
                        console.error(`Failed to load approval history from ${file}:`, error);
                    }
                }
            }
        }
    }
    
    async setupApprovalWorkflow() {
        // Установка рабочего процесса одобрения
        // Проверка истекших запросов
        setInterval(() => {
            this.checkForExpiredApprovals();
        }, 24 * 60 * 60 * 1000); // раз в день
    }
    
    checkForExpiredApprovals() {
        const now = Date.now();
        const cutoff = now - this.config.approvalTimeout;
        
        for (const [id, request] of this.pendingApprovals) {
            if (new Date(request.createdAt).getTime() < cutoff) {
                // Автоматическое отклонение истекших запросов
                request.status = 'EXPIRED';
                request.expiredAt = new Date().toISOString();
                
                this.pendingApprovals.delete(id);
                
                // Логирование истечения
                this.logApprovalAction(request, 'EXPIRED');
                
                console.warn(`Approval request expired: ${request.package}@${request.version}`);
            }
        }
    }
    
    async getApprovalDashboard() {
        return {
            queue: await this.getApprovalQueue({ status: 'PENDING' }),
            statistics: await this.getApprovalStatistics(),
            recentApprovals: this.approvalQueue.slice(-10),
            approvalTrends: await this.getApprovalTrends(),
            recommendations: await this.getApprovalRecommendations()
        };
    }
    
    async getApprovalTrends() {
        // Получение трендов одобрений
        const monthlyCounts = {};
        const weeklyCounts = {};
        
        for (const req of this.approvalQueue) {
            const month = req.createdAt.slice(0, 7);
            const week = this.getWeekOfYear(new Date(req.createdAt));
            
            monthlyCounts[month] = (monthlyCounts[month] || 0) + 1;
            weeklyCounts[week] = (weeklyCounts[week] || 0) + 1;
        }
        
        return {
            monthly: monthlyCounts,
            weekly: weeklyCounts,
            trend: this.calculateTrend(weeklyCounts)
        };
    }
    
    getWeekOfYear(date) {
        const start = new Date(date.getFullYear(), 0, 1);
        const days = Math.floor((date - start) / (24 * 60 * 60 * 1000));
        return Math.ceil((days + 1) / 7);
    }
    
    calculateTrend(counts) {
        const values = Object.values(counts).slice(-4); // последние 4 недели
        if (values.length < 2) return 'insufficient_data';
        
        const current = values[values.length - 1];
        const previous = values[values.length - 2];
        
        if (current > previous) return 'increasing';
        if (current < previous) return 'decreasing';
        return 'stable';
    }
    
    async getApprovalRecommendations() {
        const stats = await this.getApprovalStatistics();
        const recommendations = [];
        
        if (stats.averageApprovalTime > 24 * 60 * 60 * 1000) { // больше суток
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Approval Turnaround Time',
                description: `Average approval time is ${stats.averageApprovalTime / (1000 * 60 * 60)} hours`,
                action: 'Review approval workflow and consider automating low-risk approvals'
            });
        }
        
        if (stats.approvalRate < 80) { // меньше 80%
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Approval Process Bottleneck',
                description: `Approval rate is only ${stats.approvalRate.toFixed(2)}%`,
                action: 'Investigate reasons for low approval rate and optimize process'
            });
        }
        
        return recommendations;
    }
}

// Использование системы одобрений
const approvalSystem = new ApprovalSystem({
    approvalThreshold: 'high',
    approvers: [
        'security-team@company.com',
        'architecture-board@company.com',
        process.env.CURRENT_USER
    ],
    approvalTimeout: 7 * 24 * 60 * 60 * 1000 // 7 дней
});

await approvalSystem.initialize();
```

## Мониторинг и отчетность

### 1. Система отчетности

```javascript
// Система отчетности по безопасности пакетов
class PackageSecurityReporting {
    constructor(alertingSystem) {
        this.alertingSystem = alertingSystem;
        this.reports = new Map();
        this.reportTemplates = this.loadReportTemplates();
    }
    
    loadReportTemplates() {
        return {
            daily: {
                title: 'Daily Security Report',
                sections: [
                    'executive_summary',
                    'vulnerability_overview',
                    'license_compliance',
                    'new_vulnerabilities',
                    'recent_updates',
                    'recommendations'
                ]
            },
            weekly: {
                title: 'Weekly Security Report',
                sections: [
                    'trend_analysis',
                    'compliance_summary',
                    'vulnerability_breakdown',
                    'license_trends',
                    'top_risky_packages',
                    'improvement_recommendations'
                ]
            },
            monthly: {
                title: 'Monthly Security Report',
                sections: [
                    'comprehensive_analysis',
                    'year_over_year_comparison',
                    'compliance_metrics',
                    'security_improvements',
                    'strategic_recommendations'
                ]
            }
        };
    }
    
    async generateDailyReport() {
        const template = this.reportTemplates.daily;
        const data = await this.collectDailyData();
        
        return {
            type: 'daily',
            title: template.title,
            date: new Date().toISOString(),
            data: data,
            sections: await this.generateSections(data, template.sections),
            summary: this.generateDailySummary(data),
            alerts: await this.getDailyAlerts(),
            recommendations: await this.getDailyRecommendations(data)
        };
    }
    
    async generateWeeklyReport() {
        const template = this.reportTemplates.weekly;
        const data = await this.collectWeeklyData();
        
        return {
            type: 'weekly',
            title: template.title,
            startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
            endDate: new Date().toISOString(),
            data: data,
            sections: await this.generateSections(data, template.sections),
            summary: this.generateWeeklySummary(data),
            trends: await this.getWeeklyTrends(data),
            compliance: await this.getWeeklyCompliance(data)
        };
    }
    
    async generateMonthlyReport() {
        const template = this.reportTemplates.monthly;
        const data = await this.collectMonthlyData();
        
        return {
            type: 'monthly',
            title: template.title,
            startDate: new Date(new Date().setDate(1)).toISOString(), // начало месяца
            endDate: new Date().toISOString(),
            data: data,
            sections: await this.generateSections(data, template.sections),
            summary: this.generateMonthlySummary(data),
            yoyComparison: await this.getYearOverYearComparison(data),
            strategicInsights: await this.getStrategicInsights(data)
        };
    }
    
    async collectDailyData() {
        return {
            packages: await this.getDailyPackageStats(),
            vulnerabilities: await this.getDailyVulnerabilityStats(),
            licenses: await this.getDailyLicenseStats(),
            compliance: await this.getDailyComplianceStats(),
            alerts: await this.getDailyAlertStats(),
            updates: await this.getDailyUpdateStats()
        };
    }
    
    async getDailyPackageStats() {
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        
        return {
            total: allPackages.length,
            vulnerable: allPackages.filter(p => p.security.hasVulnerabilities).length,
            compliant: allPackages.filter(p => p.compliance.licenseCompliant).length,
            nonCompliant: allPackages.filter(p => !p.compliance.licenseCompliant).length,
            newThisWeek: await this.getNewPackagesThisWeek()
        };
    }
    
    async getDailyVulnerabilityStats() {
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        
        return {
            totalVulnerabilities: allPackages.reduce((sum, p) => sum + p.security.vulnerabilityCount, 0),
            bySeverity: {
                critical: allPackages.reduce((sum, p) => sum + p.security.criticalVulnerabilities, 0),
                high: allPackages.reduce((sum, p) => sum + p.security.highVulnerabilities, 0),
                medium: allPackages.reduce((sum, p) => sum + p.security.mediumVulnerabilities, 0),
                low: allPackages.reduce((sum, p) => sum + p.security.lowVulnerabilities, 0)
            },
            newToday: await this.getNewVulnerabilitiesToday(),
            fixedToday: await this.getFixedVulnerabilitiesToday()
        };
    }
    
    async getDailyLicenseStats() {
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        
        const licenseCounts = {};
        for (const pkg of allPackages) {
            const license = pkg.compliance.license;
            licenseCounts[license] = (licenseCounts[license] || 0) + 1;
        }
        
        return {
            total: allPackages.length,
            byLicense: licenseCounts,
            compliant: allPackages.filter(p => p.compliance.licenseCompliant).length,
            nonCompliant: allPackages.filter(p => !p.compliance.licenseCompliant).length
        };
    }
    
    async getDailyComplianceStats() {
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        
        return {
            overallRate: this.calculateComplianceRate(allPackages),
            securityCompliant: allPackages.filter(p => p.compliance.securityCompliant).length,
            licenseCompliant: allPackages.filter(p => p.compliance.licenseCompliant).length,
            versionCompliant: allPackages.filter(p => p.compliance.versionPolicyCompliant).length
        };
    }
    
    async getDailyAlertStats() {
        // Получение статистики по алертам за день
        const alerts = await this.alertingSystem.getActiveAlerts();
        const today = new Date().toISOString().split('T')[0];
        
        const dailyAlerts = alerts.filter(alert => 
            new Date(alert.timestamp).toISOString().split('T')[0] === today
        );
        
        return {
            total: dailyAlerts.length,
            bySeverity: this.countAlertsBySeverity(dailyAlerts),
            byType: this.countAlertsByType(dailyAlerts),
            resolved: dailyAlerts.filter(alert => alert.status === 'RESOLVED').length
        };
    }
    
    countAlertsBySeverity(alerts) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        
        for (const alert of alerts) {
            counts[alert.severity] = (counts[alert.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    countAlertsByType(alerts) {
        const counts = {};
        
        for (const alert of alerts) {
            counts[alert.type] = (counts[alert.type] || 0) + 1;
        }
        
        return counts;
    }
    
    async getDailyUpdateStats() {
        // Получение статистики по обновлениям за день
        return {
            totalUpdates: await this.getUpdateCountForPeriod('daily'),
            securityUpdates: await this.getSecurityUpdateCountForPeriod('daily'),
            packageUpdates: await this.getPackageUpdateCountForPeriod('daily')
        };
    }
    
    generateDailySummary(data) {
        return {
            overallStatus: this.calculateOverallStatus(data),
            criticalIssues: this.countCriticalIssues(data),
            improvement: this.calculateImprovement(data),
            complianceRate: data.compliance.overallRate,
            vulnerabilityTrend: this.calculateVulnerabilityTrend(data),
            nextActions: [
                'Review critical vulnerabilities',
                'Address non-compliant licenses',
                'Plan security updates'
            ]
        };
    }
    
    calculateOverallStatus(data) {
        if (data.vulnerabilities.bySeverity.critical > 0) return 'CRITICAL';
        if (data.vulnerabilities.bySeverity.high > 5) return 'HIGH';
        if (data.vulnerabilities.bySeverity.medium > 10) return 'MEDIUM';
        if (data.licenses.nonCompliant > 0) return 'MEDIUM';
        return 'SECURE';
    }
    
    countCriticalIssues(data) {
        return data.vulnerabilities.bySeverity.critical + 
               data.licenses.nonCompliant;
    }
    
    calculateImprovement(data) {
        // Сравнение с предыдущим днем
        return 0; // заглушка
    }
    
    calculateVulnerabilityTrend(data) {
        // Определение тренда уязвимостей
        return 'stable'; // заглушка
    }
    
    async getDailyAlerts() {
        const recentAlerts = await this.alertingSystem.getActiveAlerts({
            timeRange: '24h'
        });
        
        return recentAlerts.slice(0, 10); // последние 10 алертов
    }
    
    async getDailyRecommendations(data) {
        const recommendations = [];
        
        if (data.vulnerabilities.bySeverity.critical > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Vulnerabilities',
                description: `Found ${data.vulnerabilities.bySeverity.critical} critical vulnerabilities`,
                action: 'Update affected packages immediately',
                affectedPackages: this.getAffectedCriticalPackages(data)
            });
        }
        
        if (data.licenses.nonCompliant > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix License Compliance Issues',
                description: `Found ${data.licenses.nonCompliant} non-compliant packages`,
                action: 'Replace or relicense non-compliant packages',
                affectedPackages: this.getAffectedNonCompliantPackages(data)
            });
        }
        
        if (data.compliance.overallRate < 95) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Overall Compliance',
                description: `Compliance rate is ${data.compliance.overallRate}%`,
                action: 'Review and improve security policies'
            });
        }
        
        return recommendations;
    }
    
    getAffectedCriticalPackages(data) {
        // Получение списка пакетов с критическими уязвимостями
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        return allPackages
            .filter(pkg => pkg.security.criticalVulnerabilities > 0)
            .map(pkg => pkg.name);
    }
    
    getAffectedNonCompliantPackages(data) {
        // Получение списка пакетов с лицензионными нарушениями
        const allPackages = Array.from(this.alertingSystem.state.packages.values());
        return allPackages
            .filter(pkg => !pkg.compliance.licenseCompliant)
            .map(pkg => pkg.name);
    }
    
    async generateSections(data, sectionTypes) {
        const sections = {};
        
        for (const sectionType of sectionTypes) {
            sections[sectionType] = await this.generateSection(data, sectionType);
        }
        
        return sections;
    }
    
    async generateSection(data, sectionType) {
        switch (sectionType) {
            case 'executive_summary':
                return this.generateExecutiveSummary(data);
            case 'vulnerability_overview':
                return this.generateVulnerabilityOverview(data);
            case 'license_compliance':
                return this.generateLicenseComplianceSection(data);
            case 'new_vulnerabilities':
                return this.generateNewVulnerabilitiesSection(data);
            case 'recent_updates':
                return this.generateRecentUpdatesSection(data);
            case 'recommendations':
                return this.generateRecommendationsSection(data);
            case 'trend_analysis':
                return this.generateTrendAnalysisSection(data);
            case 'top_risky_packages':
                return this.generateTopRiskyPackagesSection(data);
            case 'compliance_summary':
                return this.generateComplianceSummarySection(data);
            default:
                return { title: sectionType, content: 'Section not implemented' };
        }
    }
    
    generateExecutiveSummary(data) {
        return {
            title: 'Executive Summary',
            content: `
                Today's security report shows ${data.packages.total} total packages, 
                with ${data.vulnerabilities.totalVulnerabilities} vulnerabilities detected. 
                Compliance rate stands at ${data.compliance.overallRate}%. 
                ${data.vulnerabilities.bySeverity.critical} critical vulnerabilities require immediate attention.
            `,
            keyMetrics: {
                totalPackages: data.packages.total,
                totalVulnerabilities: data.vulnerabilities.totalVulnerabilities,
                criticalVulnerabilities: data.vulnerabilities.bySeverity.critical,
                complianceRate: data.compliance.overallRate
            }
        };
    }
    
    generateVulnerabilityOverview(data) {
        return {
            title: 'Vulnerability Overview',
            content: `
                Vulnerabilities by severity:
                - Critical: ${data.vulnerabilities.bySeverity.critical}
                - High: ${data.vulnerabilities.bySeverity.high}
                - Medium: ${data.vulnerabilities.bySeverity.medium}
                - Low: ${data.vulnerabilities.bySeverity.low}
                
                New vulnerabilities detected today: ${data.vulnerabilities.newToday.length}
                Vulnerabilities fixed today: ${data.vulnerabilities.fixedToday.length}
            `,
            charts: [
                {
                    type: 'bar',
                    data: {
                        labels: ['Critical', 'High', 'Medium', 'Low'],
                        datasets: [{
                            label: 'Vulnerabilities',
                            data: [
                                data.vulnerabilities.bySeverity.critical,
                                data.vulnerabilities.bySeverity.high,
                                data.vulnerabilities.bySeverity.medium,
                                data.vulnerabilities.bySeverity.low
                            ]
                        }]
                    }
                }
            ]
        };
    }
    
    generateLicenseComplianceSection(data) {
        return {
            title: 'License Compliance',
            content: `
                License compliance status:
                - Compliant packages: ${data.licenses.compliant}
                - Non-compliant packages: ${data.licenses.nonCompliant}
                - Total packages: ${data.licenses.total}
                
                Top licenses: ${Object.entries(data.licenses.byLicense)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([license, count]) => `${license} (${count})`)
                    .join(', ')}
            `,
            complianceChart: {
                type: 'pie',
                data: {
                    labels: ['Compliant', 'Non-Compliant'],
                    datasets: [{
                        data: [data.licenses.compliant, data.licenses.nonCompliant]
                    }]
                }
            }
        };
    }
    
    async exportReport(report, format = 'json') {
        switch (format.toLowerCase()) {
            case 'json':
                return this.exportToJSON(report);
            case 'html':
                return this.exportToHTML(report);
            case 'pdf':
                return this.exportToPDF(report);
            case 'csv':
                return this.exportToCSV(report);
            case 'sarif':
                return this.exportToSARIF(report);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    exportToJSON(report) {
        return JSON.stringify(report, null, 2);
    }
    
    exportToHTML(report) {
        return `
        <!DOCTYPE html>
        <html>
        <head>
            <title>${report.title}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background: #f5f5f5; padding: 20px; margin: 20px 0; }
                .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
                .critical { background: #ffebee; border-left: 5px solid #d32f2f; }
                .high { background: #fff3e0; border-left: 5px solid #ff9800; }
                .medium { background: #fff8e1; border-left: 5px solid #ffc107; }
                .low { background: #e8f5e8; border-left: 5px solid #4caf50; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>${report.title}</h1>
                <p>Generated: ${report.date || report.startDate}</p>
            </div>
            
            <div class="section">
                <h2>Summary</h2>
                <p>Compliance Rate: ${report.summary?.complianceRate}%</p>
                <p>Overall Status: ${report.summary?.overallStatus}</p>
            </div>
            
            ${Object.entries(report.sections).map(([sectionName, section]) => `
                <div class="section">
                    <h2>${section.title}</h2>
                    <div>${section.content}</div>
                </div>
            `).join('')}
            
            <div class="section">
                <h2>Recommendations</h2>
                <ul>
                    ${report.recommendations?.map(rec => 
                        `<li class="${rec.priority.toLowerCase()}">
                            <strong>${rec.priority}:</strong> ${rec.title}
                            <br><em>${rec.description}</em>
                        </li>`
                    ).join('') || '<li>No recommendations</li>'}
                </ul>
            </div>
        </body>
        </html>
        `;
    }
    
    exportToCSV(report) {
        let csv = 'Package,Version,License,Severity,Vulnerabilities,Compliant\n';
        
        // В реальности использовать данные из отчета
        return csv;
    }
    
    exportToSARIF(report) {
        return {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'Package Security Reporter',
                        version: '1.0.0',
                        informationUri: 'https://github.com/your-org/package-security-reporter'
                    }
                },
                results: report.data.vulnerabilities.list?.map(vuln => ({
                    ruleId: vuln.id,
                    level: this.severityToSARIFLevel(vuln.severity),
                    message: {
                        text: `${vuln.title}: ${vuln.description}`
                    },
                    locations: [{
                        physicalLocation: {
                            artifactLocation: {
                                uri: `npm://${vuln.packageName}`
                            }
                        }
                    }]
                })) || []
            }]
        };
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'CRITICAL': 'error',
            'HIGH': 'error',
            'MEDIUM': 'warning',
            'LOW': 'note'
        };
        return mapping[severity] || 'warning';
    }
    
    async scheduleRegularReports() {
        // Планирование регулярных отчетов
        const cron = require('node-cron');
        
        // Ежедневные отчеты
        cron.schedule('0 9 * * *', async () => {
            try {
                const report = await this.generateDailyReport();
                await this.sendReport(report, 'daily');
            } catch (error) {
                console.error('Daily report generation failed:', error);
            }
        });
        
        // Еженедельные отчеты
        cron.schedule('0 10 * * 1', async () => {
            try {
                const report = await this.generateWeeklyReport();
                await this.sendReport(report, 'weekly');
            } catch (error) {
                console.error('Weekly report generation failed:', error);
            }
        });
        
        // Ежемесячные отчеты
        cron.schedule('0 11 1 * *', async () => {
            try {
                const report = await this.generateMonthlyReport();
                await this.sendReport(report, 'monthly');
            } catch (error) {
                console.error('Monthly report generation failed:', error);
            }
        });
    }
    
    async sendReport(report, type) {
        // Отправка отчета в соответствующие каналы
        console.log(`Sending ${type} security report...`);
        
        // В реальности интеграция с системами отчетности
        if (process.env.REPORT_WEBHOOK) {
            try {
                await fetch(process.env.REPORT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: `SECURITY_REPORT_${type.toUpperCase()}`,
                        report: report
                    })
                });
            } catch (error) {
                console.error('Failed to send report:', error);
            }
        }
    }
    
    async getHistoricalReports() {
        // Получение исторических отчетов
        return Array.from(this.reports.values())
            .sort((a, b) => new Date(b.date) - new Date(a.date));
    }
    
    async getComplianceTrends() {
        const historicalReports = await this.getHistoricalReports();
        
        return {
            complianceRateTrend: historicalReports.map(report => ({
                date: report.date,
                rate: report.summary?.complianceRate || 0
            })),
            vulnerabilityTrend: historicalReports.map(report => ({
                date: report.date,
                count: report.data?.vulnerabilities?.totalVulnerabilities || 0
            })),
            licenseComplianceTrend: historicalReports.map(report => ({
                date: report.date,
                compliant: report.data?.licenses?.compliant || 0,
                nonCompliant: report.data?.licenses?.nonCompliant || 0
            }))
        };
    }
}

// Использование системы отчетности
const reportingSystem = new PackageSecurityReporting(alertingSystem);

// Генерация отчетов
async function generateReports() {
    const dailyReport = await reportingSystem.generateDailyReport();
    const weeklyReport = await reportingSystem.generateWeeklyReport();
    const monthlyReport = await reportingSystem.generateMonthlyReport();
    
    console.log('Daily Report:', JSON.stringify(dailyReport, null, 2));
    console.log('Weekly Report:', JSON.stringify(weeklyReport, null, 2));
    console.log('Monthly Report:', JSON.stringify(monthlyReport, null, 2));
    
    // Экспорт отчетов
    await reportingSystem.exportReport(dailyReport, 'html');
    await reportingSystem.exportReport(weeklyReport, 'pdf');
    await reportingSystem.exportReport(monthlyReport, 'json');
    
    return { daily: dailyReport, weekly: weeklyReport, monthly: monthlyReport };
}
```

## Лучшие практики управления пакетами

### 1. Политики и процедуры

```javascript
// Политики управления безопасностью пакетов
class PackageSecurityPolicy {
    constructor() {
        this.policies = {
            // Политика выбора пакетов
            selectionPolicy: {
                criteria: {
                    license: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],
                    reputation: {
                        minDownloads: 1000,
                        minAgeDays: 30,
                        activeMaintainer: true,
                        securityScore: 70
                    },
                    quality: {
                        hasTests: true,
                        hasDocumentation: true,
                        lowComplexity: true,
                        reviewedByTeam: true
                    },
                    trust: {
                        knownMaintainers: true,
                        verifiedSource: true,
                        securityHistory: 'clean',
                        peerRecommendations: 2
                    }
                },
                approvalProcess: {
                    requiredFor: ['critical', 'high-risk'],
                    approvers: ['security-team', 'architecture-board'],
                    reviewTime: '24h',
                    exceptions: []
                }
            },
            
            // Политика обновлений
            updatePolicy: {
                frequency: 'weekly',
                automation: {
                    securityPatches: true,
                    minorUpdates: true,
                    majorUpdates: false
                },
                testing: {
                    required: true,
                    types: ['unit', 'integration', 'security'],
                    coverage: 80
                },
                rollback: {
                    enabled: true,
                    criteria: ['testsFailed', 'vulnerabilitiesFound'],
                    timeWindow: '1h'
                }
            },
            
            // Политика мониторинга
            monitoringPolicy: {
                frequency: 'daily',
                coverage: 'all_dependencies',
                alerting: {
                    critical: 'immediate',
                    high: 'within_1h',
                    medium: 'daily_summary',
                    low: 'weekly_summary'
                },
                retention: {
                    logs: '90d',
                    reports: '365d',
                    alerts: '180d'
                }
            }
        };
        
        this.exceptions = new Map(); // исключения для конкретных пакетов
        this.approvalQueue = []; // очередь на одобрение
    }
    
    async validatePackageAgainstPolicy(packageInfo) {
        const validation = {
            license: await this.validateLicensePolicy(packageInfo),
            reputation: await this.validateReputationPolicy(packageInfo),
            quality: await this.validateQualityPolicy(packageInfo),
            trust: await this.validateTrustPolicy(packageInfo),
            overallCompliance: false
        };
        
        validation.overallCompliance = 
            validation.license.compliant &&
            validation.reputation.compliant &&
            validation.quality.compliant &&
            validation.trust.compliant;
        
        return validation;
    }
    
    async validateLicensePolicy(packageInfo) {
        const license = this.extractLicense(packageInfo);
        
        if (!license) {
            return {
                compliant: false,
                issues: ['No license specified'],
                severity: 'HIGH',
                details: { license: 'UNKNOWN' }
            };
        }
        
        if (this.isLicenseForbidden(license)) {
            return {
                compliant: false,
                issues: [`License ${license} is forbidden`],
                severity: 'CRITICAL',
                details: { license: license }
            };
        }
        
        if (this.isLicenseAllowed(license)) {
            return {
                compliant: true,
                issues: [],
                severity: 'INFO',
                details: { license: license }
            };
        }
        
        return {
            compliant: false,
            issues: [`License ${license} is not in approved list`],
            severity: 'MEDIUM',
            details: { license: license }
        };
    }
    
    async validateReputationPolicy(packageInfo) {
        const checks = {
            downloads: await this.checkDownloadCount(packageInfo.name),
            age: await this.checkPackageAge(packageInfo.name, packageInfo.version),
            maintainer: await this.checkMaintainerActivity(packageInfo.name),
            security: await this.checkSecurityHistory(packageInfo.name)
        };
        
        const issues = [];
        
        if (checks.downloads < this.policies.selectionPolicy.criteria.reputation.minDownloads) {
            issues.push(`Package has only ${checks.downloads} downloads, minimum required: ${this.policies.selectionPolicy.criteria.reputation.minDownloads}`);
        }
        
        if (checks.age < this.policies.selectionPolicy.criteria.reputation.minAgeDays) {
            issues.push(`Package is only ${checks.age} days old, minimum required: ${this.policies.selectionPolicy.criteria.reputation.minAgeDays}`);
        }
        
        if (!checks.maintainer) {
            issues.push('Package does not have active maintainer');
        }
        
        if (checks.security.score < this.policies.selectionPolicy.criteria.reputation.securityScore) {
            issues.push(`Package security score is ${checks.security.score}, minimum required: ${this.policies.selectionPolicy.criteria.reputation.securityScore}`);
        }
        
        return {
            compliant: issues.length === 0,
            issues,
            severity: issues.length > 0 ? 'MEDIUM' : 'INFO',
            details: checks
        };
    }
    
    async validateQualityPolicy(packageInfo) {
        const checks = {
            hasTests: await this.checkHasTests(packageInfo),
            hasDocumentation: await this.checkHasDocumentation(packageInfo),
            complexity: await this.assessComplexity(packageInfo),
            peerReview: await this.checkPeerReview(packageInfo)
        };
        
        const issues = [];
        
        if (!checks.hasTests) {
            issues.push('Package does not have tests');
        }
        
        if (!checks.hasDocumentation) {
            issues.push('Package does not have documentation');
        }
        
        if (checks.complexity > 7) { // высокая сложность
            issues.push(`Package has high complexity score: ${checks.complexity}`);
        }
        
        return {
            compliant: issues.length === 0,
            issues,
            severity: issues.length > 0 ? 'LOW' : 'INFO',
            details: checks
        };
    }
    
    async validateTrustPolicy(packageInfo) {
        const checks = {
            knownMaintainers: await this.checkKnownMaintainers(packageInfo),
            verifiedSource: await this.checkVerifiedSource(packageInfo),
            securityHistory: await this.checkSecurityHistory(packageInfo.name),
            peerRecommendations: await this.checkPeerRecommendations(packageInfo)
        };
        
        const issues = [];
        
        if (!checks.knownMaintainers) {
            issues.push('Package maintainers are not known/trusted');
        }
        
        if (!checks.verifiedSource) {
            issues.push('Package source is not verified');
        }
        
        if (checks.securityHistory.risk !== 'clean') {
            issues.push(`Package has security risk history: ${checks.securityHistory.risk}`);
        }
        
        if (checks.peerRecommendations < 2) {
            issues.push(`Package has only ${checks.peerRecommendations} peer recommendations, minimum required: 2`);
        }
        
        return {
            compliant: issues.length === 0,
            issues,
            severity: issues.length > 0 ? 'MEDIUM' : 'INFO',
            details: checks
        };
    }
    
    isLicenseForbidden(license) {
        const forbidden = [
            'GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'LGPL-2.1', 'LGPL-3.0',
            'CC-BY-NC-4.0', 'CC-BY-NC-SA-4.0', 'EUPL-1.2'
        ];
        
        return forbidden.includes(license);
    }
    
    isLicenseAllowed(license) {
        return this.policies.selectionPolicy.criteria.license.includes(license);
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo.license) return null;
        
        if (typeof packageInfo.license === 'string') {
            return packageInfo.license;
        }
        
        if (typeof packageInfo.license === 'object' && packageInfo.license.type) {
            return packageInfo.license.type;
        }
        
        if (Array.isArray(packageInfo.licenses) && packageInfo.licenses[0]) {
            return typeof packageInfo.licenses[0] === 'string' ? 
                   packageInfo.licenses[0] : 
                   packageInfo.licenses[0].type;
        }
        
        return null;
    }
    
    async checkDownloadCount(packageName) {
        try {
            const result = await this.getNPMInfo(packageName);
            return result.downloads?.lastMonth || 0;
        } catch {
            return 0;
        }
    }
    
    async checkPackageAge(packageName, version) {
        try {
            const result = await this.getNPMInfo(packageName);
            const publishTime = result.time?.[version];
            
            if (!publishTime) return 0;
            
            const publishDate = new Date(publishTime);
            const now = new Date();
            return Math.floor((now - publishDate) / (1000 * 60 * 60 * 24)); // в днях
        } catch {
            return 0;
        }
    }
    
    async checkMaintainerActivity(packageName) {
        try {
            const result = await this.getNPMInfo(packageName);
            const versions = Object.keys(result.time || {});
            
            if (versions.length === 0) return false;
            
            const sortedVersions = versions
                .filter(version => result.time[version])
                .sort((a, b) => new Date(result.time[b]) - new Date(result.time[a]));
            
            const latestUpdate = new Date(result.time[sortedVersions[0]]);
            const threeMonthsAgo = new Date();
            threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
            
            return latestUpdate > threeMonthsAgo;
        } catch {
            return false;
        }
    }
    
    async checkSecurityHistory(packageName) {
        // Проверка истории безопасности через npm audit, Snyk и т.д.
        try {
            const vulns = await this.getPackageVulnerabilities(packageName);
            const critical = vulns.filter(v => v.severity === 'critical').length;
            const high = vulns.filter(v => v.severity === 'high').length;
            
            const score = 100 - (critical * 25) - (high * 10);
            
            return {
                score: Math.max(0, score),
                risk: score < 50 ? 'high' : score < 80 ? 'medium' : 'clean',
                vulnerabilities: vulns.length
            };
        } catch {
            return { score: 50, risk: 'unknown', vulnerabilities: 0 };
        }
    }
    
    async checkHasTests(packageInfo) {
        // Проверка наличия тестов
        try {
            const fs = require('fs');
            const path = require('path');
            
            // Проверка наличия test директории или файлов
            const packagePath = path.join(process.cwd(), 'node_modules', packageInfo.name);
            
            if (fs.existsSync(path.join(packagePath, 'test/'))) return true;
            if (fs.existsSync(path.join(packagePath, '__tests__/'))) return true;
            
            // Проверка на тестовые файлы
            const files = fs.readdirSync(packagePath);
            return files.some(file => file.startsWith('test.') || file.endsWith('.test.js'));
        } catch {
            return false;
        }
    }
    
    async checkHasDocumentation(packageInfo) {
        // Проверка наличия документации
        try {
            const fs = require('fs');
            const path = require('path');
            
            const packagePath = path.join(process.cwd(), 'node_modules', packageInfo.name);
            
            const docFiles = [
                'README.md', 'README.txt', 'readme.md',
                'docs/', 'DOCUMENTATION.md', 'API.md'
            ];
            
            return docFiles.some(file => 
                fs.existsSync(path.join(packagePath, file))
            );
        } catch {
            return false;
        }
    }
    
    async assessComplexity(packageInfo) {
        // Оценка сложности пакета (упрощенно)
        try {
            const fs = require('fs');
            const path = require('path');
            
            const packagePath = path.join(process.cwd(), 'node_modules', packageInfo.name);
            const files = fs.readdirSync(packagePath);
            
            let totalLines = 0;
            let fileCount = 0;
            
            for (const file of files) {
                if (file.endsWith('.js') || file.endsWith('.ts')) {
                    const content = fs.readFileSync(path.join(packagePath, file), 'utf8');
                    totalLines += content.split('\n').length;
                    fileCount++;
                }
            }
            
            // Простая оценка сложности
            return Math.min(10, totalLines / 1000); // до 10 баллов
        } catch {
            return 5; // средняя сложность по умолчанию
        }
    }
    
    async checkPeerReview(packageInfo) {
        // Проверка рекомендаций от коллег (упрощенно)
        // В реальности использовать систему внутренних рекомендаций
        return 2; // заглушка
    }
    
    async checkKnownMaintainers(packageInfo) {
        // Проверка, известны ли сопровождающие
        try {
            const result = await this.getNPMInfo(packageInfo.name);
            const maintainers = result.maintainers || [];
            
            // В реальности проверять через белый список известных сопровождающих
            return maintainers.length > 0;
        } catch {
            return false;
        }
    }
    
    async checkVerifiedSource(packageInfo) {
        // Проверка верифицированного источника
        try {
            const result = await this.getNPMInfo(packageInfo.name);
            
            // Проверка на verified publisher (npm 2FA)
            return result.publisher?.name && result.publisher?.email;
        } catch {
            return false;
        }
    }
    
    async checkPeerRecommendations(packageInfo) {
        // Проверка рекомендаций от коллег
        // В реальности использовать внутреннюю систему рекомендаций
        return 2; // заглушка
    }
    
    async getNPMInfo(packageName) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${packageName} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
    
    async getPackageVulnerabilities(packageName) {
        // Получение уязвимостей для пакета
        // В реальности использовать npm audit, Snyk, OSV и т.д.
        return []; // заглушка
    }
    
    async addException(packageName, reason, approver) {
        const exception = {
            id: `exception_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            packageName,
            reason,
            approvedBy: approver,
            approvedAt: new Date().toISOString(),
            expiresAt: null // может быть с датой истечения
        };
        
        this.exceptions.set(packageName, exception);
        
        // Сохранение исключения
        await this.saveExceptions();
        
        return exception;
    }
    
    async saveExceptions() {
        const fs = require('fs');
        const path = require('path');
        
        const exceptionsDir = path.join(process.cwd(), '.security');
        if (!fs.existsSync(exceptionsDir)) {
            fs.mkdirSync(exceptionsDir, { recursive: true });
        }
        
        fs.writeFileSync(
            path.join(exceptionsDir, 'policy-exceptions.json'),
            JSON.stringify(Object.fromEntries(this.exceptions), null, 2)
        );
    }
    
    async loadExceptions() {
        const fs = require('fs');
        const path = require('path');
        
        const exceptionsFile = path.join(process.cwd(), '.security', 'policy-exceptions.json');
        
        if (fs.existsSync(exceptionsFile)) {
            const exceptions = JSON.parse(fs.readFileSync(exceptionsFile, 'utf8'));
            this.exceptions = new Map(Object.entries(exceptions));
        }
    }
    
    async generatePolicyComplianceReport() {
        const analyzer = new DependencyAnalyzer();
        const analysis = await analyzer.analyzeProjectDependencies();
        
        const report = {
            timestamp: new Date().toISOString(),
            policyCompliance: {
                license: this.calculateLicenseCompliance(analysis),
                reputation: this.calculateReputationCompliance(analysis),
                quality: this.calculateQualityCompliance(analysis),
                trust: this.calculateTrustCompliance(analysis)
            },
            overallCompliance: this.calculateOverallCompliance(analysis),
            exceptions: Array.from(this.exceptions.values()),
            recommendations: this.generatePolicyRecommendations(analysis)
        };
        
        return report;
    }
    
    calculateLicenseCompliance(analysis) {
        const total = analysis.dependencies.length;
        const compliant = analysis.dependencies.filter(dep => 
            dep.compliance?.licenseCompliant
        ).length;
        
        return {
            total,
            compliant,
            rate: total > 0 ? (compliant / total) * 100 : 100
        };
    }
    
    calculateReputationCompliance(analysis) {
        const total = analysis.dependencies.length;
        const compliant = analysis.dependencies.filter(dep => 
            dep.compliance?.reputationCompliant
        ).length;
        
        return {
            total,
            compliant,
            rate: total > 0 ? (compliant / total) * 100 : 100
        };
    }
    
    calculateQualityCompliance(analysis) {
        const total = analysis.dependencies.length;
        const compliant = analysis.dependencies.filter(dep => 
            dep.compliance?.qualityCompliant
        ).length;
        
        return {
            total,
            compliant,
            rate: total > 0 ? (compliant / total) * 100 : 100
        };
    }
    
    calculateTrustCompliance(analysis) {
        const total = analysis.dependencies.length;
        const compliant = analysis.dependencies.filter(dep => 
            dep.compliance?.trustCompliant
        ).length;
        
        return {
            total,
            compliant,
            rate: total > 0 ? (compliant / total) * 100 : 100
        };
    }
    
    calculateOverallCompliance(analysis) {
        const licenseRate = this.calculateLicenseCompliance(analysis).rate;
        const reputationRate = this.calculateReputationCompliance(analysis).rate;
        const qualityRate = this.calculateQualityCompliance(analysis).rate;
        const trustRate = this.calculateTrustCompliance(analysis).rate;
        
        return (licenseRate + reputationRate + qualityRate + trustRate) / 4;
    }
    
    generatePolicyRecommendations(analysis) {
        const recommendations = [];
        
        const licenseIssues = analysis.dependencies.filter(dep => 
            !dep.compliance?.licenseCompliant
        ).length;
        
        if (licenseIssues > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address License Compliance Issues',
                description: `Found ${licenseIssues} packages with license compliance issues`,
                action: 'Review and replace non-compliant packages or obtain proper licenses'
            });
        }
        
        const reputationIssues = analysis.dependencies.filter(dep => 
            !dep.compliance?.reputationCompliant
        ).length;
        
        if (reputationIssues > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Improve Package Reputation',
                description: `Found ${reputationIssues} packages with reputation issues`,
                action: 'Replace packages with better reputation scores'
            });
        }
        
        return recommendations;
    }
    
    async validatePolicyConfiguration() {
        const validation = {
            valid: true,
            errors: [],
            warnings: []
        };
        
        // Проверка конфигурации политики
        if (!this.policies.selectionPolicy.criteria.license || 
            this.policies.selectionPolicy.criteria.license.length === 0) {
            validation.errors.push('License policy must include at least one allowed license');
            validation.valid = false;
        }
        
        if (this.policies.selectionPolicy.criteria.reputation.minDownloads < 0) {
            validation.errors.push('Minimum downloads cannot be negative');
            validation.valid = false;
        }
        
        if (this.policies.selectionPolicy.criteria.reputation.minAgeDays < 0) {
            validation.errors.push('Minimum age cannot be negative');
            validation.valid = false;
        }
        
        if (this.policies.selectionPolicy.criteria.reputation.securityScore < 0 || 
            this.policies.selectionPolicy.criteria.reputation.securityScore > 100) {
            validation.errors.push('Security score must be between 0 and 100');
            validation.valid = false;
        }
        
        return validation;
    }
}

// Использование системы политики безопасности
const securityPolicy = new PackageSecurityPolicy();
await securityPolicy.loadExceptions();

async function runPolicyComplianceCheck() {
    const report = await securityPolicy.generatePolicyComplianceReport();
    console.log('Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (report.overallCompliance < 95) { // 95% порог
        console.error('Policy compliance below threshold');
        process.exit(1);
    }
    
    return report;
}
```

### 2. Автоматизация управления пакетами

```javascript
// Система автоматизации управления пакетами
class AutomatedPackageManager {
    constructor(alertingSystem, policyEngine) {
        this.alertingSystem = alertingSystem;
        this.policyEngine = policyEngine;
        this.updateScheduler = new UpdateScheduler();
        this.securityChecker = new SecurityChecker();
        this.complianceMonitor = new ComplianceMonitor();
    }
    
    async initialize() {
        // Инициализация всех компонентов
        await this.updateScheduler.initialize();
        await this.complianceMonitor.initialize();
    }
    
    async runAutomatedPackageManagement() {
        const results = {
            securityScan: await this.performSecurityScan(),
            complianceCheck: await this.performComplianceCheck(),
            updates: await this.performSecurityUpdates(),
            policyEnforcement: await this.enforceSecurityPolicy(),
            summary: null
        };
        
        results.summary = this.generateAutomatedManagementSummary(results);
        
        return results;
    }
    
    async performSecurityScan() {
        // Выполнение автоматического сканирования безопасности
        const scanResults = await this.alertingSystem.performFullSecurityScan();
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: scanResults.totalDependencies,
            vulnerabilitiesFound: scanResults.vulnerabilities.length,
            bySeverity: this.countVulnerabilitiesBySeverity(scanResults.vulnerabilities),
            critical: scanResults.vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
            high: scanResults.vulnerabilities.filter(v => v.severity === 'HIGH').length,
            medium: scanResults.vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
            low: scanResults.vulnerabilities.filter(v => v.severity === 'LOW').length
        };
    }
    
    countVulnerabilitiesBySeverity(vulnerabilities) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
        
        for (const vuln of vulnerabilities) {
            counts[vuln.severity] = (counts[vuln.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    async performComplianceCheck() {
        // Выполнение автоматической проверки соответствия
        const complianceResults = await this.policyEngine.checkProjectLicenseCompliance();
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: complianceResults.totalDependencies,
            compliantDependencies: complianceResults.compliantDependencies,
            nonCompliantDependencies: complianceResults.nonCompliantDependencies,
            complianceRate: complianceResults.complianceRate,
            licenseIssues: complianceResults.licenseIssues,
            policyViolations: complianceResults.policyViolations
        };
    }
    
    async performSecurityUpdates() {
        // Автоматическое выполнение обновлений безопасности
        const updates = {
            planned: [],
            executed: [],
            failed: [],
            skipped: []
        };
        
        // Получение информации о доступных обновлениях безопасности
        const securityPatches = await this.getSecurityPatches();
        
        for (const patch of securityPatches) {
            try {
                const updateResult = await this.performSecurityUpdate(patch);
                
                if (updateResult.success) {
                    updates.executed.push(updateResult);
                } else {
                    updates.failed.push(updateResult);
                }
            } catch (error) {
                updates.failed.push({
                    package: patch.package,
                    version: patch.version,
                    error: error.message,
                    success: false
                });
            }
        }
        
        return updates;
    }
    
    async getSecurityPatches() {
        // Получение информации о доступных патчах безопасности
        const vulnerabilities = await this.securityChecker.scanVulnerabilities();
        const patches = [];
        
        for (const vuln of vulnerabilities) {
            if (vuln.patchedVersions && vuln.patchedVersions.length > 0) {
                const latestPatched = vuln.patchedVersions[0];
                patches.push({
                    package: vuln.packageName,
                    currentVersion: vuln.version,
                    patchedVersion: latestPatched,
                    vulnerability: vuln.id,
                    severity: vuln.severity
                });
            }
        }
        
        return patches;
    }
    
    async performSecurityUpdate(patch) {
        // Выполнение обновления безопасности
        const { execSync } = require('child_process');
        
        try {
            // Проверка соответствия политике
            const policyCheck = await this.policyEngine.checkUpdatePolicy(patch);
            if (!policyCheck.approved) {
                return {
                    package: patch.package,
                    from: patch.currentVersion,
                    to: patch.patchedVersion,
                    success: false,
                    reason: 'Policy not approved',
                    policyCheck
                };
            }
            
            // Обновление пакета
            execSync(`npm install ${patch.package}@${patch.patchedVersion}`, {
                stdio: 'inherit',
                cwd: process.cwd()
            });
            
            // Запуск тестов
            execSync('npm test', { stdio: 'inherit' });
            
            return {
                package: patch.package,
                from: patch.currentVersion,
                to: patch.patchedVersion,
                success: true,
                vulnerabilityFixed: patch.vulnerability,
                severity: patch.severity
            };
        } catch (error) {
            return {
                package: patch.package,
                from: patch.currentVersion,
                to: patch.patchedVersion,
                success: false,
                error: error.message
            };
        }
    }
    
    async enforceSecurityPolicy() {
        // Принудительное применение политики безопасности
        const policyResults = await this.policyEngine.evaluateAllDependencies();
        
        const enforcement = {
            compliant: policyResults.every(result => result.compliant),
            totalDependencies: policyResults.length,
            compliantDependencies: policyResults.filter(result => result.compliant).length,
            nonCompliantDependencies: policyResults.filter(result => !result.compliant).length,
            actionsTaken: [],
            violations: []
        };
        
        for (const result of policyResults) {
            if (!result.compliant) {
                enforcement.violations.push(result);
                
                // Выполнение действий по умолчанию для нарушений
                const action = await this.takeDefaultAction(result);
                enforcement.actionsTaken.push(action);
            }
        }
        
        return enforcement;
    }
    
    async takeDefaultAction(violation) {
        // Выполнение стандартных действий для нарушений политики
        switch (violation.type) {
            case 'FORBIDDEN_LICENSE':
                return await this.removeForbiddenPackage(violation.package);
            case 'CRITICAL_VULNERABILITY':
                return await this.blockCriticalPackage(violation.package);
            case 'POLICY_VIOLATION':
                return await this.flagPolicyViolation(violation.package, violation.reason);
            default:
                return { action: 'FLAGGED', package: violation.package, reason: violation.reason };
        }
    }
    
    async removeForbiddenPackage(packageName) {
        const { execSync } = require('child_process');
        
        try {
            execSync(`npm uninstall ${packageName}`, { stdio: 'inherit' });
            return { action: 'REMOVED', package: packageName, success: true };
        } catch (error) {
            return { action: 'REMOVE_FAILED', package: packageName, error: error.message, success: false };
        }
    }
    
    async blockCriticalPackage(packageName) {
        // Блокировка пакета с критической уязвимостью
        console.warn(`Blocking package ${packageName} due to critical vulnerability`);
        return { action: 'BLOCKED', package: packageName, success: true };
    }
    
    async flagPolicyViolation(packageName, reason) {
        // Пометка пакета как нарушающего политику
        console.warn(`Policy violation flagged for ${packageName}: ${reason}`);
        return { action: 'FLAGGED', package: packageName, reason, success: true };
    }
    
    generateAutomatedManagementSummary(results) {
        return {
            overallStatus: this.calculateOverallStatus(results),
            totalDependencies: results.complianceCheck.totalDependencies,
            securityIssues: results.securityScan.vulnerabilitiesFound,
            complianceIssues: results.complianceCheck.nonCompliantDependencies,
            updatesApplied: results.updates.executed.length,
            complianceRate: results.complianceCheck.complianceRate,
            securityScore: this.calculateSecurityScore(results.securityScan),
            nextActions: this.generateNextActions(results)
        };
    }
    
    calculateOverallStatus(results) {
        const securityCritical = results.securityScan.critical > 0;
        const complianceIssues = results.complianceCheck.nonCompliantDependencies > 0;
        
        if (securityCritical || complianceIssues) return 'UNSECURE';
        if (results.securityScan.high > 0) return 'SECURE_WITH_ISSUES';
        return 'SECURE';
    }
    
    calculateSecurityScore(securityScan) {
        // Расчет общего балла безопасности
        const totalVulns = securityScan.vulnerabilitiesFound;
        const critical = securityScan.critical;
        const high = securityScan.high;
        
        // Простой расчет: 100 - (critical * 25) - (high * 10) - (medium * 3) - (low * 1)
        const score = 100 - (critical * 25) - (high * 10) - 
                     (securityScan.medium * 3) - (securityScan.low * 1);
        
        return Math.max(0, Math.min(100, score));
    }
    
    generateNextActions(results) {
        const actions = [];
        
        if (results.securityScan.critical > 0) {
            actions.push('1. Address critical vulnerabilities immediately');
        }
        
        if (results.complianceCheck.nonCompliantDependencies > 0) {
            actions.push('2. Fix license compliance issues');
        }
        
        if (results.updates.executed.length > 0) {
            actions.push('3. Monitor for regressions after updates');
        }
        
        if (results.policyEnforcement.nonCompliantDependencies > 0) {
            actions.push('4. Review policy violations and take corrective actions');
        }
        
        actions.push('5. Schedule next security scan');
        actions.push('6. Update security policies based on findings');
        
        return actions;
    }
    
    async getAutomatedManagementDashboard() {
        const results = await this.runAutomatedPackageManagement();
        
        return {
            timestamp: new Date().toISOString(),
            summary: results.summary,
            securityScan: results.securityScan,
            complianceCheck: results.complianceCheck,
            updateHistory: await this.getUpdateHistory(),
            policyViolations: await this.getPolicyViolations(),
            recommendations: await this.getAutomatedRecommendations(results)
        };
    }
    
    async getUpdateHistory() {
        // В реальности извлекать из БД или файлов истории обновлений
        return []; // заглушка
    }
    
    async getPolicyViolations() {
        // В реальности извлекать из истории нарушений политики
        return []; // заглушка
    }
    
    async getAutomatedRecommendations(results) {
        const recommendations = [];
        
        if (results.securityScan.critical > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'SECURITY',
                title: 'Immediate Security Fixes Required',
                description: `Found ${results.securityScan.critical} critical vulnerabilities`,
                action: 'Apply security patches immediately and verify fixes'
            });
        }
        
        if (results.complianceCheck.complianceRate < 90) {
            recommendations.push({
                priority: 'HIGH',
                category: 'COMPLIANCE',
                title: 'Improve License Compliance',
                description: `Current compliance rate is ${results.complianceCheck.complianceRate}%`,
                action: 'Review and replace non-compliant packages'
            });
        }
        
        if (results.updates.failed.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'UPDATE',
                title: 'Address Failed Updates',
                description: `Found ${results.updates.failed.length} failed security updates`,
                action: 'Investigate and retry failed updates'
            });
        }
        
        return recommendations;
    }
    
    async scheduleAutomatedTasks() {
        // Планирование автоматических задач
        const cron = require('node-cron');
        
        // Ежедневное сканирование безопасности
        cron.schedule('0 2 * * *', async () => {
            await this.performSecurityScan();
        });
        
        // Еженедельная проверка соответствия
        cron.schedule('0 3 * * 1', async () => {
            await this.performComplianceCheck();
        });
        
        // Ежемесячная проверка политики
        cron.schedule('0 4 1 * *', async () => {
            await this.enforceSecurityPolicy();
        });
    }
}

// Использование автоматического менеджера пакетов
const autoPackageManager = new AutomatedPackageManager(alertingSystem, policyEngine);

async function runAutomatedSecurityManagement() {
    const results = await autoPackageManager.runAutomatedPackageManagement();
    const dashboard = await autoPackageManager.getAutomatedManagementDashboard();
    
    console.log('Automated Package Management Results:', JSON.stringify(results, null, 2));
    console.log('Dashboard:', JSON.stringify(dashboard, null, 2));
    
    return { results, dashboard };
}
```

## Тестирование системы сигнализации

### 1. Автоматизированные тесты

```javascript
// Тесты для системы сигнализации безопасности
describe('Package Security Alerting System', () => {
    let alertingSystem;
    let policyEngine;
    let notificationManager;
    
    beforeEach(() => {
        alertingSystem = new SecurityAlertingSystem({
            scanning: { tools: ['npm-audit'], frequency: 'test' },
            policies: { 
                allow: ['MIT', 'Apache-2.0'], 
                deny: ['GPL-2.0'] 
            }
        });
        
        policyEngine = new PolicyEngine();
        notificationManager = new NotificationManager();
    });
    
    test('should detect critical vulnerabilities', async () => {
        const mockVulnerability = {
            id: 'CVE-2023-1234',
            moduleName: 'vulnerable-package',
            severity: 'critical',
            title: 'Critical Vulnerability',
            description: 'A critical security vulnerability'
        };
        
        // Mock сканирования
        alertingSystem.components.scanner.scanAllDependencies = jest.fn().mockResolvedValue({
            'vulnerable-package': [mockVulnerability]
        });
        
        const results = await alertingSystem.performFullSecurityScan();
        
        expect(results.vulnerabilities).toContainEqual(
            expect.objectContaining({
                id: 'CVE-2023-1234',
                severity: 'critical'
            })
        );
    });
    
    test('should generate appropriate alerts for high severity issues', async () => {
        const mockHighVuln = {
            id: 'CVE-2023-5678',
            moduleName: 'high-risk-package',
            severity: 'high',
            title: 'High Severity Issue',
            description: 'A high severity security issue'
        };
        
        alertingSystem.components.scanner.scanAllDependencies = jest.fn().mockResolvedValue({
            'high-risk-package': [mockHighVuln]
        });
        
        const results = await alertingSystem.performFullSecurityScan();
        
        expect(results.summary.bySeverity.high).toBe(1);
        expect(results.summary.compliant).toBe(false);
    });
    
    test('should validate packages against security policy', async () => {
        const mockPackage = {
            name: 'test-package',
            version: '1.0.0',
            license: 'MIT'
        };
        
        const validation = await policyEngine.validatePackageAgainstPolicy(mockPackage);
        
        expect(validation.overallCompliance).toBe(true);
        expect(validation.license.compliant).toBe(true);
        expect(validation.reputation.compliant).toBe(true);
    });
    
    test('should reject packages with forbidden licenses', async () => {
        const mockPackage = {
            name: 'forbidden-package',
            version: '1.0.0',
            license: 'GPL-2.0'
        };
        
        const validation = await policyEngine.validatePackageAgainstPolicy(mockPackage);
        
        expect(validation.overallCompliance).toBe(false);
        expect(validation.license.compliant).toBe(false);
        expect(validation.license.issues).toContainEqual(
            expect.objectContaining({ type: 'FORBIDDEN_LICENSE' })
        );
    });
    
    test('should handle policy exceptions correctly', async () => {
        const mockPackage = {
            name: 'exception-package',
            version: '1.0.0',
            license: 'GPL-2.0' // forbidden license
        };
        
        // Add exception
        await policyEngine.addException('exception-package', 'Business requirement', 'admin');
        
        const validation = await policyEngine.validatePackageAgainstPolicy(mockPackage);
        
        expect(validation.overallCompliance).toBe(true);
        expect(validation.overridden).toBe(true);
    });
    
    test('should calculate security scores correctly', async () => {
        const mockPackage = {
            name: 'test-package',
            version: '1.0.0',
            license: 'MIT',
            vulnerabilities: [
                { severity: 'critical', count: 1 },
                { severity: 'high', count: 2 }
            ]
        };
        
        const score = policyEngine.calculateSecurityScore(mockPackage);
        
        // Score should be reduced for vulnerabilities
        expect(score).toBeLessThan(100);
    });
    
    test('should generate proper security reports', async () => {
        const report = await reportingSystem.generateComprehensiveReport();
        
        expect(report).toHaveProperty('metadata');
        expect(report).toHaveProperty('licenseCheck');
        expect(report).toHaveProperty('summary');
        expect(report).toHaveProperty('recommendations');
        
        expect(report.metadata).toHaveProperty('timestamp');
        expect(report.summary).toHaveProperty('totalDependencies');
        expect(report.summary).toHaveProperty('compliantDependencies');
        expect(Array.isArray(report.recommendations)).toBe(true);
    });
    
    test('should identify top risky packages', async () => {
        const packages = [
            { name: 'secure-pkg', security: { criticalVulnerabilities: 0, highVulnerabilities: 0 } },
            { name: 'risky-pkg1', security: { criticalVulnerabilities: 2, highVulnerabilities: 3 } },
            { name: 'risky-pkg2', security: { criticalVulnerabilities: 1, highVulnerabilities: 5 } }
        ];
        
        const risky = alertingSystem.getIdentifyRiskyPackages(packages);
        
        expect(risky).toHaveLength(2);
        expect(risky[0].name).toBe('risky-pkg2'); // highest critical count
    });
    
    test('should handle notification channels properly', async () => {
        const alert = {
            type: 'SECURITY_ALERT',
            severity: 'HIGH',
            package: 'test-package',
            description: 'Test security alert'
        };
        
        // Mock notification channels
        notificationManager.sendNotification = jest.fn().mockResolvedValue({ success: true });
        
        await notificationManager.sendAlert(alert);
        
        expect(notificationManager.sendNotification).toHaveBeenCalledWith(
            expect.anything(),
            expect.objectContaining({
                type: 'SECURITY_ALERT',
                severity: 'HIGH'
            })
        );
    });
    
    test('should maintain alert history', async () => {
        const initialCount = alertingSystem.alertHistory.length;
        
        const alert = {
            id: 'test-alert-1',
            type: 'TEST',
            severity: 'MEDIUM',
            timestamp: new Date().toISOString()
        };
        
        alertingSystem.logSecurityAlert(alert);
        
        expect(alertingSystem.alertHistory.length).toBe(initialCount + 1);
        expect(alertingSystem.alertHistory[alertingSystem.alertHistory.length - 1].id).toBe('test-alert-1');
    });
    
    test('should validate complex license expressions', () => {
        const complexLicense = 'MIT OR Apache-2.0';
        const normalized = policyEngine.normalizeLicense(complexLicense);
        
        expect(normalized).toBe('MIT-OR-APACHE-2.0');
    });
    
    test('should detect license compatibility issues', async () => {
        const result = policyEngine.checkLicenseCompatibility('GPL-2.0', 'MIT');
        
        expect(result.compatible).toBe(false);
        expect(result.reason).toContain('not compatible');
    });
    
    test('should handle batch processing of alerts', async () => {
        const batchAlerts = Array.from({ length: 5 }, (_, i) => ({
            id: `batch-alert-${i}`,
            type: 'BATCH_TEST',
            severity: i % 2 === 0 ? 'CRITICAL' : 'HIGH',
            package: `test-pkg-${i}`,
            timestamp: new Date(Date.now() - i * 1000).toISOString()
        }));
        
        const processingPromises = batchAlerts.map(alert => 
            alertingSystem.processSecurityAlert(alert)
        );
        
        const results = await Promise.all(processingPromises);
        
        expect(results.length).toBe(5);
        expect(results.filter(r => r.success).length).toBeGreaterThanOrEqual(3); // majority should succeed
    });
    
    test('should calculate compliance rates accurately', async () => {
        const mockPackages = [
            { name: 'pkg1', compliance: { licenseCompliant: true, securityCompliant: true } },
            { name: 'pkg2', compliance: { licenseCompliant: false, securityCompliant: true } },
            { name: 'pkg3', compliance: { licenseCompliant: true, securityCompliant: false } },
            { name: 'pkg4', compliance: { licenseCompliant: true, securityCompliant: true } }
        ];
        
        const complianceRate = policyEngine.calculateComplianceRate(mockPackages);
        
        // 2 out of 4 packages are fully compliant = 50%
        expect(complianceRate).toBe(50);
    });
    
    test('should handle concurrent security checks', async () => {
        const concurrentChecks = Array.from({ length: 10 }, (_, i) => 
            policyEngine.validatePackageAgainstPolicy({
                name: `concurrent-pkg-${i}`,
                version: '1.0.0',
                license: 'MIT'
            })
        );
        
        const results = await Promise.all(concurrentChecks);
        
        expect(results.length).toBe(10);
        expect(results.every(r => r.overallCompliance === true)).toBe(true);
    });
    
    test('should respect severity thresholds', async () => {
        const mockConfig = {
            severityThreshold: 'high',
            failOnCritical: true
        };
        
        const customAlertingSystem = new SecurityAlertingSystem(mockConfig);
        
        const summary = {
            bySeverity: { 
                critical: 1, 
                high: 0, 
                medium: 0, 
                low: 0 
            }
        };
        
        const compliant = customAlertingSystem.isCompliant(summary);
        
        expect(compliant).toBe(false); // critical vulnerabilities present
    });
    
    test('should generate actionable recommendations', async () => {
        const mockResults = {
            summary: { 
                totalDependencies: 10,
                compliantDependencies: 5,
                nonCompliantDependencies: 5
            },
            packages: Array.from({ length: 10 }, (_, i) => ({
                name: `pkg-${i}`,
                security: { 
                    hasVulnerabilities: i < 3, 
                    criticalVulnerabilities: i === 0 ? 1 : 0 
                },
                compliance: { 
                    licenseCompliant: i < 5 
                }
            }))
        };
        
        const recommendations = policyEngine.generatePolicyRecommendations(mockResults);
        
        expect(recommendations).toHaveLength(2); // license and security issues
        expect(recommendations.some(r => r.priority === 'HIGH')).toBe(true);
    });
    
    test('should handle policy validation correctly', async () => {
        const validation = await policyEngine.validatePolicyConfiguration();
        
        expect(validation).toHaveProperty('valid');
        expect(validation).toHaveProperty('errors');
        expect(validation).toHaveProperty('warnings');
        expect(Array.isArray(validation.errors)).toBe(true);
        expect(Array.isArray(validation.warnings)).toBe(true);
    });
    
    test('should maintain policy exception history', async () => {
        const exception = await policyEngine.addException(
            'test-package', 
            'Business exception', 
            'test-user'
        );
        
        expect(exception).toHaveProperty('id');
        expect(exception).toHaveProperty('packageName', 'test-package');
        expect(exception).toHaveProperty('reason', 'Business exception');
        expect(exception).toHaveProperty('approvedBy', 'test-user');
        
        // Check that exception is stored
        const storedException = policyEngine.policyExceptions.get('test-package');
        expect(storedException).toBeDefined();
        expect(storedException.reason).toBe('Business exception');
    });
});

// Интеграционные тесты
describe('Integration: Package Security Management', () => {
    test('should integrate scanning, policy checking, and alerting', async () => {
        const integrationSystem = new PackageSecurityManager({
            scanning: { tools: ['npm-audit'] },
            policies: { 
                allow: ['MIT', 'Apache-2.0'], 
                deny: ['GPL-2.0'] 
            },
            monitoring: { enabled: true }
        });
        
        await integrationSystem.initialize();
        
        // Mock package with vulnerability
        const mockPackage = {
            name: 'vulnerable-package',
            version: '1.0.0',
            license: 'MIT' // compliant license
        };
        
        // Add mock vulnerability data
        integrationSystem.state.packages.set('vulnerable-package', {
            ...mockPackage,
            security: {
                hasVulnerabilities: true,
                vulnerabilityCount: 1,
                criticalVulnerabilities: 0,
                highVulnerabilities: 1,
                mediumVulnerabilities: 0,
                lowVulnerabilities: 0,
                vulnerabilities: [{
                    id: 'TEST-VULN-001',
                    severity: 'high',
                    title: 'Test Vulnerability',
                    description: 'This is a test vulnerability'
                }]
            },
            compliance: {
                licenseCompliant: true,
                license: 'MIT'
            }
        });
        
        const dashboard = await integrationSystem.getSecurityDashboard();
        
        expect(dashboard.summary.totalVulnerabilities).toBe(1);
        expect(dashboard.summary.bySeverity.HIGH).toBe(1);
        expect(dashboard.recommendations).toHaveLength(1);
        expect(dashboard.recommendations[0].priority).toBe('HIGH');
    });
    
    test('should handle real-world package scanning', async () => {
        // Тестирование с реальными пакетами (ограниченно)
        const realPackages = [
            { name: 'express', version: '4.18.2' },
            { name: 'lodash', version: '4.17.21' },
            { name: 'axios', version: '1.4.0' }
        ];
        
        const results = await Promise.all(
            realPackages.map(async (pkg) => {
                const check = await policyEngine.validatePackageAgainstPolicy(pkg);
                return { ...pkg, check };
            })
        );
        
        expect(results).toHaveLength(3);
        expect(results.every(r => r.check !== undefined)).toBe(true);
    });
    
    test('should maintain data integrity during processing', async () => {
        const originalData = {
            name: 'integrity-test-pkg',
            version: '1.0.0',
            license: 'MIT',
            security: { hasVulnerabilities: false }
        };
        
        // Add to system
        alertingSystem.state.packages.set('integrity-test-pkg', originalData);
        
        // Process through various checks
        const policyCheck = await policyEngine.validatePackageAgainstPolicy(originalData);
        const securityCheck = await alertingSystem.checkPackageSecurity('integrity-test-pkg', '1.0.0');
        
        // Verify original data integrity
        const storedData = alertingSystem.state.packages.get('integrity-test-pkg');
        expect(storedData).toEqual(originalData);
    });
    
    test('should handle system failures gracefully', async () => {
        // Mock a failing scanner
        const failingScanner = {
            scanAllDependencies: jest.fn().mockRejectedValue(new Error('Scanner failed'))
        };
        
        alertingSystem.components.scanner = failingScanner;
        
        await expect(alertingSystem.performFullSecurityScan()).rejects.toThrow();
    });
    
    test('should scale with large dependency trees', async () => {
        // Create mock large dependency tree
        const largeDependencySet = Array.from({ length: 100 }, (_, i) => ({
            name: `mock-package-${i}`,
            version: '1.0.0',
            license: i % 3 === 0 ? 'MIT' : i % 3 === 1 ? 'Apache-2.0' : 'ISC'
        }));
        
        const startTime = Date.now();
        
        const results = await Promise.all(
            largeDependencySet.map(pkg => 
                policyEngine.validatePackageAgainstPolicy(pkg)
            )
        );
        
        const executionTime = Date.now() - startTime;
        
        // Should process 100 packages reasonably quickly
        expect(executionTime).toBeLessThan(30000); // Less than 30 seconds
        expect(results).toHaveLength(100);
    });
    
    test('should generate consistent reports across runs', async () => {
        const firstReport = await reportingSystem.generateComprehensiveReport();
        const secondReport = await reportingSystem.generateComprehensiveReport();
        
        // Reports should have consistent structure
        expect(firstReport).toHaveProperty('metadata');
        expect(firstReport).toHaveProperty('summary');
        expect(firstReport).toHaveProperty('findings');
        
        // Properties should exist in both reports
        expect(firstReport.metadata).toHaveProperty('timestamp');
        expect(secondReport.metadata).toHaveProperty('timestamp');
        
        expect(firstReport.summary).toHaveProperty('totalDependencies');
        expect(secondReport.summary).toHaveProperty('totalDependencies');
    });
});

// Вспомогательные функции для тестов
function createMockPackage(name, version, license = 'MIT', vulnerabilities = []) {
    return {
        name,
        version,
        license,
        vulnerabilities,
        dependencies: {},
        devDependencies: {},
        optionalDependencies: {}
    };
}

function createMockVulnerability(options = {}) {
    return {
        id: options.id || `CVE-${Math.floor(Math.random() * 10000)}`,
        module_name: options.packageName || 'test-package',
        severity: options.severity || 'medium',
        title: options.title || 'Test Vulnerability',
        description: options.description || 'Test vulnerability description',
        recommendation: options.recommendation || 'Update to latest version',
        url: options.url || 'https://example.com/vulnerability',
        cves: options.cves || [],
        vulnerable_versions: options.vulnerableVersions || ['<1.0.5'],
        patched_versions: options.patchedVersions || ['>=1.0.5'],
        ...options
    };
}

function createMockAlert(options = {}) {
    return {
        id: options.id || `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: options.type || 'SECURITY_ALERT',
        severity: options.severity || 'MEDIUM',
        package: options.package || 'test-package',
        version: options.version || '1.0.0',
        description: options.description || 'Test security alert',
        timestamp: options.timestamp || new Date().toISOString(),
        source: options.source || 'test-system',
        ...options
    };
}

// Запуск тестов
if (require.main === module) {
    console.log('Package Security Alerting tests ready to run');
    
    // В реальности запускать через Jest или другую систему тестирования
    console.log('Available test suites: Basic Security Checks, Policy Validation, Integration Tests');
}
```

### 2. Мониторинг производительности

```javascript
// Мониторинг производительности системы сигнализации
class AlertingPerformanceMonitor {
    constructor(alertingSystem) {
        this.alertingSystem = alertingSystem;
        this.metrics = {
            scanPerformance: [],
            processingPerformance: [],
            notificationPerformance: [],
            memoryUsage: [],
            errorRates: []
        };
        
        this.performanceThresholds = {
            maxScanTime: 30000, // 30 секунд
            maxProcessingTime: 5000, // 5 секунд
            maxNotificationTime: 2000, // 2 секунды
            maxMemoryGrowth: 50 * 1024 * 1024, // 50MB
            maxErrorRate: 0.05 // 5%
        };
    }
    
    startMonitoring() {
        // Мониторинг сканирования
        setInterval(() => {
            this.measureScanPerformance();
        }, 60000); // каждую минуту
        
        // Мониторинг обработки
        setInterval(() => {
            this.measureProcessingPerformance();
        }, 30000);
        
        // Мониторинг уведомлений
        setInterval(() => {
            this.measureNotificationPerformance();
        }, 60000);
        
        // Мониторинг памяти
        setInterval(() => {
            this.measureMemoryUsage();
        }, 10000);
        
        console.log('Performance monitoring started for security alerting system');
    }
    
    measureScanPerformance() {
        // Измерение производительности сканирования
        const scanMetrics = {
            timestamp: new Date().toISOString(),
            duration: this.getRecentScanDuration(),
            packagesScanned: this.getRecentScanCount(),
            vulnerabilitiesFound: this.getRecentVulnerabilityCount(),
            memoryBefore: process.memoryUsage().heapUsed,
            memoryAfter: process.memoryUsage().heapUsed
        };
        
        this.metrics.scanPerformance.push(scanMetrics);
        
        // Проверка на превышение порогов
        this.checkPerformanceThresholds('scan', scanMetrics);
        
        // Ограничение истории
        if (this.metrics.scanPerformance.length > 1000) {
            this.metrics.scanPerformance = this.metrics.scanPerformance.slice(-1000);
        }
    }
    
    measureProcessingPerformance() {
        // Измерение производительности обработки алертов
        const processingMetrics = {
            timestamp: new Date().toISOString(),
            alertsProcessed: this.getProcessedAlertCount(),
            averageProcessingTime: this.getAverageProcessingTime(),
            totalProcessingTime: this.getTotalProcessingTime()
        };
        
        this.metrics.processingPerformance.push(processingMetrics);
        
        this.checkPerformanceThresholds('processing', processingMetrics);
        
        if (this.metrics.processingPerformance.length > 1000) {
            this.metrics.processingPerformance = this.metrics.processingPerformance.slice(-1000);
        }
    }
    
    measureNotificationPerformance() {
        // Измерение производительности отправки уведомлений
        const notificationMetrics = {
            timestamp: new Date().toISOString(),
            notificationsSent: this.getSentNotificationCount(),
            averageSendTime: this.getAverageNotificationTime(),
            deliverySuccessRate: this.getNotificationSuccessRate()
        };
        
        this.metrics.notificationPerformance.push(notificationMetrics);
        
        this.checkPerformanceThresholds('notification', notificationMetrics);
        
        if (this.metrics.notificationPerformance.length > 1000) {
            this.metrics.notificationPerformance = this.metrics.notificationPerformance.slice(-1000);
        }
    }
    
    measureMemoryUsage() {
        // Измерение использования памяти
        const memoryMetrics = {
            timestamp: new Date().toISOString(),
            heapUsed: process.memoryUsage().heapUsed,
            heapTotal: process.memoryUsage().heapTotal,
            external: process.memoryUsage().external,
            rss: process.memoryUsage().rss
        };
        
        this.metrics.memoryUsage.push(memoryMetrics);
        
        this.checkPerformanceThresholds('memory', memoryMetrics);
        
        if (this.metrics.memoryUsage.length > 1000) {
            this.metrics.memoryUsage = this.metrics.memoryUsage.slice(-1000);
        }
    }
    
    checkPerformanceThresholds(type, metrics) {
        const alerts = [];
        
        switch (type) {
            case 'scan':
                if (metrics.duration > this.performanceThresholds.maxScanTime) {
                    alerts.push({
                        type: 'SCAN_PERFORMANCE_DEGRADED',
                        severity: 'MEDIUM',
                        message: `Scan took ${metrics.duration}ms, threshold is ${this.performanceThresholds.maxScanTime}ms`,
                        metric: metrics
                    });
                }
                break;
                
            case 'processing':
                if (metrics.averageProcessingTime > this.performanceThresholds.maxProcessingTime) {
                    alerts.push({
                        type: 'PROCESSING_PERFORMANCE_DEGRADED',
                        severity: 'MEDIUM',
                        message: `Average processing time is ${metrics.averageProcessingTime}ms, threshold is ${this.performanceThresholds.maxProcessingTime}ms`,
                        metric: metrics
                    });
                }
                break;
                
            case 'notification':
                if (metrics.averageSendTime > this.performanceThresholds.maxNotificationTime) {
                    alerts.push({
                        type: 'NOTIFICATION_PERFORMANCE_DEGRADED',
                        severity: 'MEDIUM',
                        message: `Average notification time is ${metrics.averageSendTime}ms, threshold is ${this.performanceThresholds.maxNotificationTime}ms`,
                        metric: metrics
                    });
                }
                
                if (metrics.deliverySuccessRate < (1 - this.performanceThresholds.maxErrorRate)) {
                    alerts.push({
                        type: 'NOTIFICATION_ERROR_RATE_HIGH',
                        severity: 'HIGH',
                        message: `Notification success rate is ${metrics.deliverySuccessRate * 100}%, threshold is ${((1 - this.performanceThresholds.maxErrorRate) * 100)}%`,
                        metric: metrics
                    });
                }
                break;
                
            case 'memory':
                if (metrics.heapUsed > this.performanceThresholds.maxMemoryGrowth) {
                    alerts.push({
                        type: 'MEMORY_USAGE_HIGH',
                        severity: 'MEDIUM',
                        message: `Memory usage is ${metrics.heapUsed} bytes, threshold is ${this.performanceThresholds.maxMemoryGrowth}`,
                        metric: metrics
                    });
                }
                break;
        }
        
        if (alerts.length > 0) {
            this.handlePerformanceAlerts(alerts);
        }
    }
    
    handlePerformanceAlerts(alerts) {
        for (const alert of alerts) {
            console.warn(`PERFORMANCE ALERT [${alert.severity}]: ${alert.message}`);
            
            // В реальности отправка в систему мониторинга
            if (process.env.PERFORMANCE_ALERT_WEBHOOK) {
                fetch(process.env.PERFORMANCE_ALERT_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(alert)
                }).catch(console.error);
            }
        }
    }
    
    getRecentScanDuration() {
        // В реальности получать из истории сканирования
        return 5000; // заглушка
    }
    
    getRecentScanCount() {
        // В реальности получать из истории сканирования
        return 50; // заглушка
    }
    
    getRecentVulnerabilityCount() {
        // В реальности получать из истории сканирования
        return 5; // заглушка
    }
    
    getProcessedAlertCount() {
        // В реальности получать из истории обработки
        return 100; // заглушка
    }
    
    getAverageProcessingTime() {
        // В реальности рассчитывать на основе истории
        return 150; // заглушка
    }
    
    getTotalProcessingTime() {
        // В реальности получать из истории
        return 15000; // заглушка
    }
    
    getSentNotificationCount() {
        // В реальности получать из истории уведомлений
        return 50; // заглушка
    }
    
    getAverageNotificationTime() {
        // В реальности рассчитывать на основе истории
        return 200; // заглушка
    }
    
    getNotificationSuccessRate() {
        // В реальности рассчитывать на основе истории
        return 0.98; // заглушка
    }
    
    async getPerformanceReport() {
        return {
            timestamp: new Date().toISOString(),
            scanPerformance: this.calculateScanPerformanceMetrics(),
            processingPerformance: this.calculateProcessingPerformanceMetrics(),
            notificationPerformance: this.calculateNotificationPerformanceMetrics(),
            memoryPerformance: this.calculateMemoryPerformanceMetrics(),
            overallPerformanceScore: this.calculateOverallPerformanceScore(),
            recommendations: this.generatePerformanceRecommendations()
        };
    }
    
    calculateScanPerformanceMetrics() {
        if (this.metrics.scanPerformance.length === 0) return {};
        
        const durations = this.metrics.scanPerformance.map(m => m.duration);
        const avgDuration = durations.reduce((sum, dur) => sum + dur, 0) / durations.length;
        
        return {
            averageDuration: avgDuration,
            minDuration: Math.min(...durations),
            maxDuration: Math.max(...durations),
            totalScans: this.metrics.scanPerformance.length,
            performanceTrend: this.calculateTrend(durations)
        };
    }
    
    calculateProcessingPerformanceMetrics() {
        if (this.metrics.processingPerformance.length === 0) return {};
        
        const times = this.metrics.processingPerformance.map(m => m.averageProcessingTime);
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        
        return {
            averageProcessingTime: avgTime,
            minProcessingTime: Math.min(...times),
            maxProcessingTime: Math.max(...times),
            totalProcessed: this.metrics.processingPerformance.length,
            performanceTrend: this.calculateTrend(times)
        };
    }
    
    calculateNotificationPerformanceMetrics() {
        if (this.metrics.notificationPerformance.length === 0) return {};
        
        const successRates = this.metrics.notificationPerformance.map(m => m.deliverySuccessRate);
        const avgSuccessRate = successRates.reduce((sum, rate) => sum + rate, 0) / successRates.length;
        
        return {
            averageSuccessRate: avgSuccessRate,
            minSuccessRate: Math.min(...successRates),
            maxSuccessRate: Math.max(...successRates),
            totalNotifications: this.metrics.notificationPerformance.length,
            performanceTrend: this.calculateTrend(successRates)
        };
    }
    
    calculateMemoryPerformanceMetrics() {
        if (this.metrics.memoryUsage.length === 0) return {};
        
        const usages = this.metrics.memoryUsage.map(m => m.heapUsed);
        const avgUsage = usages.reduce((sum, usage) => sum + usage, 0) / usages.length;
        
        return {
            averageHeapUsage: avgUsage,
            minHeapUsage: Math.min(...usages),
            maxHeapUsage: Math.max(...usages),
            totalMeasurements: this.metrics.memoryUsage.length,
            growthRate: this.calculateMemoryGrowthRate(usages)
        };
    }
    
    calculateOverallPerformanceScore() {
        // Расчет общего балла производительности
        const scanScore = this.calculatePerformanceScore(this.calculateScanPerformanceMetrics());
        const processingScore = this.calculatePerformanceScore(this.calculateProcessingPerformanceMetrics());
        const notificationScore = this.calculatePerformanceScore(this.calculateNotificationPerformanceMetrics());
        const memoryScore = this.calculateMemoryScore(this.calculateMemoryPerformanceMetrics());
        
        return (scanScore + processingScore + notificationScore + memoryScore) / 4;
    }
    
    calculatePerformanceScore(metrics) {
        // Расчет балла производительности (0-100)
        if (!metrics || !metrics.averageDuration) return 100;
        
        // Чем выше среднее время, тем ниже балл
        const timeScore = Math.max(0, 100 - (metrics.averageDuration / 100)); // предполагаем, что 100ms = 0 баллов
        
        return Math.min(100, Math.max(0, timeScore));
    }
    
    calculateMemoryScore(metrics) {
        if (!metrics || !metrics.averageHeapUsage) return 100;
        
        // Чем выше использование памяти, тем ниже балл
        const memoryScore = Math.max(0, 100 - (metrics.averageHeapUsage / (100 * 1024 * 1024))); // предполагаем, что 100MB = 0 баллов
        
        return Math.min(100, Math.max(0, memoryScore));
    }
    
    calculateTrend(values) {
        if (values.length < 2) return 'insufficient_data';
        
        const first = values[0];
        const last = values[values.length - 1];
        
        if (last > first * 1.1) return 'degrading'; // ухудшение на 10%
        if (last < first * 0.9) return 'improving'; // улучшение на 10%
        return 'stable';
    }
    
    calculateMemoryGrowthRate(usages) {
        if (usages.length < 2) return 0;
        
        const first = usages[0];
        const last = usages[usages.length - 1];
        
        return ((last - first) / first) * 100;
    }
    
    generatePerformanceRecommendations() {
        const recommendations = [];
        
        const scanMetrics = this.calculateScanPerformanceMetrics();
        if (scanMetrics.performanceTrend === 'degrading') {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'PERFORMANCE',
                title: 'Scan Performance Degrading',
                description: 'Package scan performance is degrading over time',
                action: 'Review scanning process and optimize performance'
            });
        }
        
        const memoryMetrics = this.calculateMemoryPerformanceMetrics();
        if (memoryMetrics.growthRate > 10) { // рост более чем на 10%
            recommendations.push({
                priority: 'HIGH',
                category: 'PERFORMANCE',
                title: 'Memory Usage Growing Rapidly',
                description: `Memory usage growing at ${memoryMetrics.growthRate.toFixed(2)}% rate`,
                action: 'Investigate memory leaks and optimize memory usage'
            });
        }
        
        return recommendations;
    }
}

// Использование монитора производительности
const perfMonitor = new AlertingPerformanceMonitor(alertingSystem);
perfMonitor.startMonitoring();

// Получение отчета о производительности
async function getPerformanceReport() {
    const report = await perfMonitor.getPerformanceReport();
    console.log('Performance Report:', JSON.stringify(report, null, 2));
    return report;
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Управление-пакетами]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]