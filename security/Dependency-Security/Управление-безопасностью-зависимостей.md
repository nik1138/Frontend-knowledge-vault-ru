---
aliases: ["Управление безопасностью зависимостей", "Dependency Security Management", "Безопасность пакетов"]
tags: ["#security", "#dependency-security", "#package-management", "#vulnerability-management"]
---

# Управление безопасностью зависимостей

## Введение

Управление безопасностью зависимостей - это комплекс мер, направленных на обеспечение безопасности внешних библиотек и пакетов, используемых в приложениях. Эффективное управление безопасностью зависимостей включает в себя мониторинг уязвимостей, проверку лицензий, управление версиями и автоматизированные процессы реагирования на угрозы.

## Архитектура системы управления безопасностью зависимостей

### 1. Компоненты системы

```javascript
// Архитектура системы управления безопасностью зависимостей
class DependencySecurityManager {
    constructor(config) {
        this.config = {
            // Параметры мониторинга
            monitoring: {
                checkInterval: config.monitoring?.checkInterval || 3600000, // 1 час
                alertThreshold: config.monitoring?.alertThreshold || 5,
                notificationChannels: config.monitoring?.notificationChannels || ['console']
            },
            
            // Параметры сканирования
            scanning: {
                enabled: config.scanning?.enabled !== false,
                tools: config.scanning?.tools || ['npm-audit', 'snyk', 'osv'],
                severityThreshold: config.scanning?.severityThreshold || 'moderate'
            },
            
            // Параметры политики
            policy: {
                allowedLicenses: config.policy?.allowedLicenses || ['MIT', 'Apache-2.0', 'BSD-3-Clause'],
                forbiddenLicenses: config.policy?.forbiddenLicenses || ['AGPL-3.0', 'GPL-2.0'],
                maxAgeDays: config.policy?.maxAgeDays || 365,
                requireSignatures: config.policy?.requireSignatures || false
            },
            
            // Параметры обновлений
            updates: {
                autoUpdate: config.updates?.autoUpdate || false,
                securityOnly: config.updates?.securityOnly || true,
                testBeforeUpdate: config.updates?.testBeforeUpdate || true,
                backupBeforeUpdate: config.updates?.backupBeforeUpdate || true
            },
            
            ...config
        };
        
        this.components = {
            vulnerabilityScanner: new VulnerabilityScanner(this.config.scanning),
            licenseChecker: new LicenseChecker(this.config.policy),
            versionManager: new VersionManager(this.config.updates),
            policyEnforcer: new PolicyEnforcer(this.config.policy),
            notificationSystem: new NotificationSystem(this.config.monitoring),
            backupSystem: new BackupSystem(),
            testRunner: new TestRunner()
        };
        
        this.state = {
            dependencies: new Map(),
            vulnerabilities: new Map(),
            licenseViolations: new Map(),
            updateHistory: [],
            scanHistory: [],
            alerts: [],
            lastScan: null
        };
        
        this.initializeSystem();
    }
    
    async initializeSystem() {
        console.log('Initializing Dependency Security Manager...');
        
        // Загрузка текущих зависимостей
        await this.loadCurrentDependencies();
        
        // Запуск регулярного мониторинга
        this.startMonitoring();
        
        // Запуск регулярного сканирования
        this.startScanning();
        
        console.log('Dependency Security Manager initialized successfully');
    }
    
    async loadCurrentDependencies() {
        try {
            const fs = require('fs');
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            
            // Загрузка зависимостей
            const allDeps = {
                ...packageJson.dependencies,
                ...packageJson.devDependencies,
                ...packageJson.optionalDependencies
            };
            
            for (const [name, version] of Object.entries(allDeps)) {
                this.state.dependencies.set(name, {
                    name,
                    version,
                    installed: await this.getInstalledVersion(name),
                    metadata: await this.getPackageMetadata(name),
                    lastCheck: null,
                    status: 'UNKNOWN'
                });
            }
            
            console.log(`Loaded ${this.state.dependencies.size} dependencies`);
        } catch (error) {
            console.error('Failed to load dependencies:', error.message);
        }
    }
    
    async getInstalledVersion(packageName) {
        try {
            const fs = require('fs');
            const path = require('path');
            
            const packageJsonPath = path.join('node_modules', packageName, 'package.json');
            if (fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                return packageJson.version;
            }
        } catch (error) {
            console.warn(`Could not get installed version for ${packageName}:`, error.message);
        }
        return null;
    }
    
    async getPackageMetadata(packageName) {
        try {
            const { execSync } = require('child_process');
            const result = execSync(`npm view ${packageName} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            console.warn(`Could not get metadata for ${packageName}:`, error.message);
            return null;
        }
    }
    
    startMonitoring() {
        // Запуск регулярного мониторинга
        setInterval(async () => {
            await this.performRegularCheck();
        }, this.config.monitoring.checkInterval);
        
        console.log('Dependency monitoring started');
    }
    
    startScanning() {
        // Запуск регулярного сканирования
        setInterval(async () => {
            await this.performSecurityScan();
        }, this.config.scanning.interval || 24 * 60 * 60 * 1000); // 24 часа
    }
    
    async performRegularCheck() {
        console.log('Performing regular dependency security check...');
        
        const startTime = Date.now();
        
        try {
            // Проверка на новые уязвимости
            await this.checkForNewVulnerabilities();
            
            // Проверка на изменения лицензий
            await this.checkForLicenseChanges();
            
            // Проверка на устаревшие зависимости
            await this.checkForOutdatedDependencies();
            
            // Проверка политики
            await this.enforceSecurityPolicy();
            
            // Обновление статуса
            this.state.lastScan = {
                timestamp: new Date().toISOString(),
                duration: Date.now() - startTime,
                success: true
            };
            
            console.log('Regular check completed successfully');
        } catch (error) {
            console.error('Regular check failed:', error.message);
            
            this.state.lastScan = {
                timestamp: new Date().toISOString(),
                duration: Date.now() - startTime,
                success: false,
                error: error.message
            };
        }
    }
    
    async performSecurityScan() {
        if (!this.config.scanning.enabled) return;
        
        console.log('Performing security scan...');
        
        const scanResults = await this.components.vulnerabilityScanner.scanAllDependencies();
        
        // Обновление уязвимостей
        for (const [packageName, vulnerabilities] of Object.entries(scanResults)) {
            this.state.vulnerabilities.set(packageName, vulnerabilities);
        }
        
        // Отправка алертов при необходимости
        await this.handleVulnerabilityAlerts(scanResults);
        
        // Добавление в историю сканирования
        this.state.scanHistory.push({
            timestamp: new Date().toISOString(),
            results: scanResults,
            summary: this.summarizeScanResults(scanResults)
        });
        
        // Ограничение истории
        if (this.state.scanHistory.length > 100) {
            this.state.scanHistory = this.state.scanHistory.slice(-100);
        }
        
        console.log(`Security scan completed. Found vulnerabilities in ${Object.keys(scanResults).length} packages`);
    }
    
    async checkForNewVulnerabilities() {
        const newVulnerabilities = await this.components.vulnerabilityScanner.checkForNewVulnerabilities();
        
        if (newVulnerabilities.length > 0) {
            console.log(`Found ${newVulnerabilities.length} new vulnerabilities`);
            
            // Обновление состояния зависимостей
            for (const vuln of newVulnerabilities) {
                const dep = this.state.dependencies.get(vuln.package);
                if (dep) {
                    dep.status = 'VULNERABLE';
                    dep.lastVulnerability = vuln;
                }
            }
            
            // Отправка уведомлений
            await this.components.notificationSystem.sendVulnerabilityAlerts(newVulnerabilities);
        }
    }
    
    async checkForLicenseChanges() {
        const changedLicenses = [];
        
        for (const [name, dep] of this.state.dependencies) {
            const currentLicense = await this.components.licenseChecker.checkPackageLicense(name, dep.version);
            
            if (dep.license && dep.license !== currentLicense) {
                changedLicenses.push({
                    package: name,
                    oldLicense: dep.license,
                    newLicense: currentLicense,
                    timestamp: new Date().toISOString()
                });
                
                dep.license = currentLicense;
            }
        }
        
        if (changedLicenses.length > 0) {
            console.log(`Found ${changedLicenses.length} license changes`);
            
            // Проверка новых лицензий на соответствие политике
            for (const change of changedLicenses) {
                const policyCheck = await this.components.policyEnforcer.checkLicenseCompliance(change.package, change.newLicense);
                
                if (!policyCheck.compliant) {
                    this.state.licenseViolations.set(change.package, policyCheck);
                    
                    await this.components.notificationSystem.sendLicenseViolationAlert({
                        package: change.package,
                        oldLicense: change.oldLicense,
                        newLicense: change.newLicense,
                        policyViolation: policyCheck
                    });
                }
            }
        }
    }
    
    async checkForOutdatedDependencies() {
        const outdatedDeps = [];
        
        for (const [name, dep] of this.state.dependencies) {
            const outdated = await this.components.versionManager.checkIfOutdated(name, dep.version);
            
            if (outdated.isOutdated) {
                outdatedDeps.push({
                    package: name,
                    current: dep.version,
                    latest: outdated.latestVersion,
                    age: outdated.age,
                    type: outdated.updateType
                });
            }
        }
        
        if (outdatedDeps.length > 0) {
            console.log(`Found ${outdatedDeps.length} outdated dependencies`);
        }
        
        return outdatedDeps;
    }
    
    async enforceSecurityPolicy() {
        const violations = [];
        
        for (const [name, dep] of this.state.dependencies) {
            const policyCheck = await this.components.policyEnforcer.enforcePolicy(name, dep.version);
            
            if (!policyCheck.compliant) {
                violations.push({
                    package: name,
                    policyViolations: policyCheck.violations,
                    timestamp: new Date().toISOString()
                });
                
                // Обновление статуса зависимости
                dep.status = 'POLICY_VIOLATION';
            }
        }
        
        if (violations.length > 0) {
            console.log(`Found ${violations.length} policy violations`);
            
            await this.components.notificationSystem.sendPolicyViolationAlerts(violations);
        }
        
        return violations;
    }
    
    async handleVulnerabilityAlerts(scanResults) {
        const alertableVulnerabilities = [];
        
        for (const [packageName, vulnerabilities] of Object.entries(scanResults)) {
            const criticalVulns = vulnerabilities.filter(v => 
                this.isCriticalSeverity(v.severity)
            );
            
            if (criticalVulns.length > 0) {
                alertableVulnerabilities.push({
                    package: packageName,
                    vulnerabilities: criticalVulns,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        if (alertableVulnerabilities.length > 0) {
            await this.components.notificationSystem.sendCriticalVulnerabilityAlerts(alertableVulnerabilities);
            
            // Добавление в историю алертов
            this.state.alerts.push(...alertableVulnerabilities);
            
            // Ограничение истории алертов
            if (this.state.alerts.length > 1000) {
                this.state.alerts = this.state.alerts.slice(-1000);
            }
        }
    }
    
    isCriticalSeverity(severity) {
        return ['CRITICAL', 'HIGH'].includes(severity.toUpperCase());
    }
    
    async getSecurityDashboard() {
        return {
            summary: this.getSecuritySummary(),
            dependencies: this.getDependencyStatus(),
            vulnerabilities: this.getVulnerabilitySummary(),
            licenseCompliance: this.getLicenseComplianceSummary(),
            updateStatus: this.getUpdateStatus(),
            scanHistory: this.getRecentScanHistory(),
            recommendations: await this.getSecurityRecommendations()
        };
    }
    
    getSecuritySummary() {
        const total = this.state.dependencies.size;
        const vulnerable = Array.from(this.state.dependencies.values()).filter(d => d.status === 'VULNERABLE').length;
        const policyViolations = Array.from(this.state.dependencies.values()).filter(d => d.status === 'POLICY_VIOLATION').length;
        
        return {
            totalDependencies: total,
            vulnerableDependencies: vulnerable,
            policyViolatingDependencies: policyViolations,
            secureDependencies: total - vulnerable - policyViolations,
            vulnerabilityRate: total > 0 ? (vulnerable / total) * 100 : 0,
            complianceRate: total > 0 ? ((total - policyViolations) / total) * 100 : 0
        };
    }
    
    getDependencyStatus() {
        return Array.from(this.state.dependencies.values()).map(dep => ({
            name: dep.name,
            version: dep.version,
            status: dep.status,
            lastCheck: dep.lastCheck,
            lastVulnerability: dep.lastVulnerability,
            license: dep.license,
            age: dep.age
        }));
    }
    
    getVulnerabilitySummary() {
        const summary = {
            totalVulnerabilities: 0,
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
            byPackage: {},
            affectedPackages: 0
        };
        
        for (const [pkg, vulns] of this.state.vulnerabilities) {
            summary.affectedPackages++;
            
            for (const vuln of vulns) {
                summary.totalVulnerabilities++;
                const severity = vuln.severity.toUpperCase();
                summary.bySeverity[severity] = (summary.bySeverity[severity] || 0) + 1;
            }
            
            summary.byPackage[pkg] = vulns.length;
        }
        
        return summary;
    }
    
    getLicenseComplianceSummary() {
        const total = this.state.dependencies.size;
        const compliant = Array.from(this.state.dependencies.values()).filter(dep => {
            const license = dep.license || this.getLicenseFromPackage(dep.name);
            return this.isLicenseCompliant(license);
        }).length;
        
        return {
            total: total,
            compliant: compliant,
            nonCompliant: total - compliant,
            complianceRate: total > 0 ? (compliant / total) * 100 : 0,
            licenseBreakdown: this.getLicenseBreakdown()
        };
    }
    
    getLicenseBreakdown() {
        const breakdown = {};
        
        for (const dep of this.state.dependencies.values()) {
            const license = dep.license || 'UNKNOWN';
            breakdown[license] = (breakdown[license] || 0) + 1;
        }
        
        return breakdown;
    }
    
    isLicenseCompliant(license) {
        if (!license) return false;
        
        const forbidden = this.config.policy.forbiddenLicenses;
        const allowed = this.config.policy.allowedLicenses;
        
        return !forbidden.includes(license) && allowed.includes(license);
    }
    
    getRecentScanHistory(limit = 10) {
        return this.state.scanHistory.slice(-limit).reverse();
    }
    
    async getSecurityRecommendations() {
        const recommendations = [];
        
        const summary = this.getSecuritySummary();
        
        if (summary.vulnerabilityRate > 10) {
            recommendations.push({
                priority: 'HIGH',
                category: 'VULNERABILITIES',
                title: 'High Vulnerability Rate Detected',
                description: `Vulnerability rate of ${summary.vulnerabilityRate.toFixed(2)}% exceeds recommended threshold of 10%`,
                action: 'Prioritize security updates and vulnerability remediation'
            });
        }
        
        if (summary.complianceRate < 90) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'COMPLIANCE',
                title: 'License Compliance Issues',
                description: `License compliance rate of ${summary.complianceRate.toFixed(2)}% is below 90%`,
                action: 'Review and replace non-compliant packages'
            });
        }
        
        // Рекомендации по конкретным уязвимостям
        for (const [pkg, vulns] of this.state.vulnerabilities) {
            const criticalVulns = vulns.filter(v => v.severity === 'CRITICAL');
            if (criticalVulns.length > 0) {
                recommendations.push({
                    priority: 'CRITICAL',
                    category: 'VULNERABILITIES',
                    title: `Critical Vulnerabilities in ${pkg}`,
                    description: `Found ${criticalVulns.length} critical vulnerabilities in ${pkg}`,
                    action: `Update ${pkg} to patched version immediately`,
                    affectedPackage: pkg
                });
            }
        }
        
        return recommendations;
    }
    
    async updateDependencies(options = {}) {
        if (!this.config.updates.autoUpdate) {
            throw new Error('Auto updates are disabled in configuration');
        }
        
        const updateOptions = {
            securityOnly: options.securityOnly || this.config.updates.securityOnly,
            testBeforeUpdate: options.testBeforeUpdate !== undefined ? 
                            options.testBeforeUpdate : this.config.updates.testBeforeUpdate,
            backupBeforeUpdate: options.backupBeforeUpdate !== undefined ? 
                               options.backupBeforeUpdate : this.config.updates.backupBeforeUpdate,
            ...options
        };
        
        if (updateOptions.backupBeforeUpdate) {
            await this.components.backupSystem.createBackup();
        }
        
        const updates = await this.components.versionManager.getUpdateCandidates(updateOptions);
        
        const results = {
            updates: [],
            failed: [],
            summary: {
                total: updates.length,
                successful: 0,
                failed: 0
            }
        };
        
        for (const update of updates) {
            try {
                if (updateOptions.testBeforeUpdate) {
                    await this.components.testRunner.runTests();
                }
                
                const updateResult = await this.components.versionManager.performUpdate(update);
                results.updates.push(updateResult);
                results.summary.successful++;
                
                // Повторная проверка безопасности после обновления
                await this.checkSecurityAfterUpdate(update.packageName, update.newVersion);
                
            } catch (error) {
                results.failed.push({
                    package: update.packageName,
                    error: error.message,
                    oldVersion: update.currentVersion,
                    newVersion: update.newVersion
                });
                results.summary.failed++;
            }
        }
        
        // Добавление в историю обновлений
        this.state.updateHistory.push({
            timestamp: new Date().toISOString(),
            updates: results.updates,
            failed: results.failed,
            summary: results.summary
        });
        
        // Ограничение истории
        if (this.state.updateHistory.length > 100) {
            this.state.updateHistory = this.state.updateHistory.slice(-100);
        }
        
        return results;
    }
    
    async checkSecurityAfterUpdate(packageName, newVersion) {
        // Проверка безопасности после обновления
        const vulnerabilityCheck = await this.components.vulnerabilityScanner.checkPackage(packageName, newVersion);
        const licenseCheck = await this.components.licenseChecker.checkPackageLicense(packageName, newVersion);
        
        // Обновление состояния зависимости
        const dep = this.state.dependencies.get(packageName);
        if (dep) {
            dep.version = newVersion;
            dep.license = licenseCheck;
            dep.status = vulnerabilityCheck.length === 0 ? 'SECURE' : 'VULNERABLE';
            dep.lastCheck = new Date().toISOString();
        }
        
        // Проверка соответствия политике
        const policyCheck = await this.components.policyEnforcer.enforcePolicy(packageName, newVersion);
        if (!policyCheck.compliant) {
            dep.status = 'POLICY_VIOLATION';
        }
    }
    
    async generateSecurityReport() {
        const dashboard = await this.getSecurityDashboard();
        
        return {
            timestamp: new Date().toISOString(),
            metadata: {
                system: 'Dependency Security Manager',
                version: '1.0.0',
                nodeVersion: process.version
            },
            dashboard: dashboard,
            detailedFindings: {
                vulnerabilities: Array.from(this.state.vulnerabilities.entries()),
                licenseViolations: Array.from(this.state.licenseViolations.entries()),
                policyViolations: await this.getPolicyViolations(),
                outdatedPackages: await this.getOutdatedPackages()
            },
            compliance: await this.getComplianceReport(),
            recommendations: dashboard.recommendations,
            nextSteps: this.generateNextSteps(dashboard)
        };
    }
    
    async getPolicyViolations() {
        const violations = [];
        
        for (const [name, dep] of this.state.dependencies) {
            if (dep.status === 'POLICY_VIOLATION') {
                violations.push({
                    package: name,
                    version: dep.version,
                    status: dep.status,
                    lastCheck: dep.lastCheck
                });
            }
        }
        
        return violations;
    }
    
    async getOutdatedPackages() {
        const outdated = [];
        
        for (const [name, dep] of this.state.dependencies) {
            const isOutdated = await this.components.versionManager.checkIfOutdated(name, dep.version);
            if (isOutdated.isOutdated) {
                outdated.push({
                    package: name,
                    current: dep.version,
                    latest: isOutdated.latestVersion,
                    age: isOutdated.age,
                    updateType: isOutdated.updateType
                });
            }
        }
        
        return outdated;
    }
    
    async getComplianceReport() {
        return {
            overallCompliance: this.getOverallCompliance(),
            licenseCompliance: this.getLicenseComplianceSummary(),
            versionPolicyCompliance: await this.checkVersionPolicyCompliance(),
            securityPolicyCompliance: await this.checkSecurityPolicyCompliance(),
            trend: await this.getComplianceTrend()
        };
    }
    
    getOverallCompliance() {
        const summary = this.getSecuritySummary();
        const licenseSummary = this.getLicenseComplianceSummary();
        
        return Math.min(summary.complianceRate, licenseSummary.complianceRate);
    }
    
    async checkVersionPolicyCompliance() {
        // Проверка соответствия политике версий
        const outdatedCount = await this.getOutdatedPackageCount();
        const totalCount = this.state.dependencies.size;
        
        return {
            compliant: outdatedCount === 0,
            outdatedPackages: outdatedCount,
            totalPackages: totalCount,
            complianceRate: totalCount > 0 ? ((totalCount - outdatedCount) / totalCount) * 100 : 0
        };
    }
    
    async checkSecurityPolicyCompliance() {
        // Проверка соответствия политике безопасности
        const vulnerableCount = Array.from(this.state.dependencies.values())
            .filter(d => d.status === 'VULNERABLE')
            .length;
        const totalCount = this.state.dependencies.size;
        
        return {
            compliant: vulnerableCount === 0,
            vulnerablePackages: vulnerableCount,
            totalPackages: totalCount,
            complianceRate: totalCount > 0 ? ((totalCount - vulnerableCount) / totalCount) * 100 : 0
        };
    }
    
    async getComplianceTrend() {
        // Анализ тренда соответствия политике
        const history = this.state.scanHistory;
        
        if (history.length < 2) return 'insufficient_data';
        
        const recent = history.slice(-10); // последние 10 сканирований
        const complianceRates = recent.map(scan => {
            const total = Object.keys(scan.results).length;
            const secure = Object.entries(scan.results).filter(([, vulns]) => vulns.length === 0).length;
            return total > 0 ? (secure / total) * 100 : 100;
        });
        
        const firstRate = complianceRates[0];
        const lastRate = complianceRates[complianceRates.length - 1];
        
        if (lastRate > firstRate) return 'improving';
        if (lastRate < firstRate) return 'declining';
        return 'stable';
    }
    
    generateNextSteps(dashboard) {
        const steps = [];
        
        if (dashboard.summary.vulnerabilityRate > 0) {
            steps.push('1. Prioritize and fix critical security vulnerabilities');
            steps.push('2. Implement regular security scanning schedule');
            steps.push('3. Review and update security policies');
        }
        
        if (dashboard.summary.complianceRate < 100) {
            steps.push('1. Address license compliance issues');
            steps.push('2. Replace non-compliant packages with alternatives');
            steps.push('3. Update license approval process');
        }
        
        steps.push('1. Automate dependency updates for security patches');
        steps.push('2. Implement security training for development team');
        steps.push('3. Regular security audits and penetration testing');
        
        return steps;
    }
    
    async getDependencyTreeWithSecurityInfo() {
        const tree = await this.getDependencyTree();
        const securityInfo = await this.getSecurityInfoForTree(tree);
        
        return this.mergeTreeWithSecurity(tree, securityInfo);
    }
    
    async getDependencyTree() {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npm ls --json', { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            console.error('Failed to get dependency tree:', error.message);
            return { dependencies: {} };
        }
    }
    
    async getSecurityInfoForTree(tree) {
        const securityInfo = {};
        
        for (const [pkgName, pkgInfo] of Object.entries(tree.dependencies || {})) {
            securityInfo[pkgName] = await this.getSecurityInfoForPackage(pkgName, pkgInfo.version);
        }
        
        return securityInfo;
    }
    
    async getSecurityInfoForPackage(name, version) {
        const vulnerabilityInfo = await this.components.vulnerabilityScanner.checkPackage(name, version);
        const licenseInfo = await this.components.licenseChecker.checkPackageLicense(name, version);
        const policyInfo = await this.components.policyEnforcer.enforcePolicy(name, version);
        
        return {
            vulnerabilities: vulnerabilityInfo,
            license: licenseInfo,
            policyCompliance: policyInfo,
            securityScore: this.calculateSecurityScore(vulnerabilityInfo, licenseInfo, policyInfo)
        };
    }
    
    calculateSecurityScore(vulnerabilities, license, policy) {
        let score = 100;
        
        // Вычет за уязвимости
        score -= vulnerabilities.length * 10;
        
        // Вычет за лицензионные проблемы
        if (!this.isLicenseCompliant(license)) {
            score -= 20;
        }
        
        // Вычет за нарушения политики
        if (!policy.compliant) {
            score -= policy.violations.length * 5;
        }
        
        return Math.max(0, score);
    }
    
    mergeTreeWithSecurity(tree, securityInfo) {
        const merged = JSON.parse(JSON.stringify(tree));
        
        for (const [pkgName, pkgInfo] of Object.entries(merged.dependencies || {})) {
            if (securityInfo[pkgName]) {
                pkgInfo.security = securityInfo[pkgName];
            }
        }
        
        return merged;
    }
}

// Использование менеджера безопасности зависимостей
const depSecurityManager = new DependencySecurityManager({
    monitoring: {
        checkInterval: 3600000, // 1 час
        alertThreshold: 5,
        notificationChannels: ['console', 'email', 'slack']
    },
    scanning: {
        enabled: true,
        tools: ['npm-audit', 'snyk'],
        severityThreshold: 'high'
    },
    policy: {
        allowedLicenses: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],
        forbiddenLicenses: ['AGPL-3.0', 'GPL-2.0', 'CC-BY-NC-4.0'],
        maxAgeDays: 365,
        requireSignatures: true
    },
    updates: {
        autoUpdate: true,
        securityOnly: true,
        testBeforeUpdate: true,
        backupBeforeUpdate: true
    }
});
```

### 2. Сканирование уязвимостей

```javascript
// Система сканирования уязвимостей
class VulnerabilityScanner {
    constructor(config) {
        this.config = config;
        this.scanningTools = new Map();
        this.vulnerabilityDatabase = new VulnerabilityDatabase();
        this.cache = new Map();
        this.cacheExpiry = 3600000; // 1 час
        
        this.initializeScanningTools();
    }
    
    initializeScanningTools() {
        // Инициализация различных инструментов сканирования
        if (this.config.tools.includes('npm-audit')) {
            this.scanningTools.set('npm-audit', new NPMAuditScanner());
        }
        
        if (this.config.tools.includes('snyk')) {
            this.scanningTools.set('snyk', new SnykScanner());
        }
        
        if (this.config.tools.includes('osv')) {
            this.scanningTools.set('osv', new OSVScanner());
        }
        
        if (this.config.tools.includes('owasp')) {
            this.scanningTools.set('owasp', new OWASPScanner());
        }
    }
    
    async scanPackage(packageName, version) {
        const cacheKey = `${packageName}@${version}`;
        
        // Проверка кэша
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheExpiry) {
                return cached.data;
            }
        }
        
        const allResults = [];
        
        for (const [toolName, tool] of this.scanningTools) {
            try {
                const result = await tool.scan(packageName, version);
                allResults.push({
                    tool: toolName,
                    results: result,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.error(`Failed to scan with ${toolName}:`, error.message);
            }
        }
        
        const consolidatedResults = await this.consolidateResults(allResults);
        
        // Кэширование результата
        this.cache.set(cacheKey, {
            data: consolidatedResults,
            timestamp: Date.now()
        });
        
        return consolidatedResults;
    }
    
    async consolidateResults(toolResults) {
        const vulnerabilities = new Map();
        
        for (const toolResult of toolResults) {
            if (toolResult.results?.vulnerabilities) {
                for (const vuln of toolResult.results.vulnerabilities) {
                    const key = `${vuln.id}-${vuln.package}`;
                    
                    if (!vulnerabilities.has(key)) {
                        vulnerabilities.set(key, {
                            id: vuln.id,
                            package: vuln.package,
                            title: vuln.title,
                            severity: this.normalizeSeverity(vuln.severity),
                            description: vuln.description,
                            cvssScore: vuln.cvssScore || vuln.cvss?.score,
                            cve: vuln.cve || vuln.id,
                            patchedVersions: vuln.patchedVersions || [],
                            vulnerableVersions: vuln.vulnerableVersions || [],
                            detectedBy: [toolResult.tool],
                            details: {
                                [toolResult.tool]: vuln
                            }
                        });
                    } else {
                        const existing = vulnerabilities.get(key);
                        existing.detectedBy.push(toolResult.tool);
                        existing.details[toolResult.tool] = vuln;
                    }
                }
            }
        }
        
        return Array.from(vulnerabilities.values());
    }
    
    normalizeSeverity(severity) {
        const severityMap = {
            'critical': 'CRITICAL',
            'high': 'HIGH',
            'medium': 'MEDIUM',
            'low': 'LOW',
            'info': 'INFO',
            'moderate': 'MEDIUM'
        };
        
        return severityMap[severity.toLowerCase()] || severity.toUpperCase();
    }
    
    async scanAllDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        const allDeps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
        
        const results = {};
        
        for (const [name, version] of Object.entries(allDeps)) {
            const vulns = await this.scanPackage(name, version);
            if (vulns.length > 0) {
                results[name] = vulns;
            }
        }
        
        return results;
    }
    
    async checkForNewVulnerabilities() {
        const currentVulns = await this.scanAllDependencies();
        const previousVulns = await this.getPreviousVulnerabilities();
        
        const newVulnerabilities = [];
        
        for (const [pkgName, pkgVulns] of Object.entries(currentVulns)) {
            const prevPkgVulns = previousVulns[pkgName] || [];
            
            for (const vuln of pkgVulns) {
                const exists = prevPkgVulns.some(prevVuln => 
                    prevVuln.id === vuln.id && prevVuln.package === vuln.package
                );
                
                if (!exists) {
                    newVulnerabilities.push({
                        ...vuln,
                        newlyDiscovered: true,
                        discoveryTime: new Date().toISOString()
                    });
                }
            }
        }
        
        return newVulnerabilities;
    }
    
    async getPreviousVulnerabilities() {
        // В реальности загружать из БД или файла
        try {
            const fs = require('fs');
            if (fs.existsSync('vulnerability-cache.json')) {
                return JSON.parse(fs.readFileSync('vulnerability-cache.json', 'utf8'));
            }
        } catch (error) {
            console.error('Failed to load previous vulnerabilities:', error.message);
        }
        
        return {};
    }
    
    async saveCurrentVulnerabilities(vulnerabilities) {
        // Сохранение текущих уязвимостей для последующего сравнения
        try {
            const fs = require('fs');
            fs.writeFileSync('vulnerability-cache.json', JSON.stringify(vulnerabilities, null, 2));
        } catch (error) {
            console.error('Failed to save vulnerabilities:', error.message);
        }
    }
    
    async scanWithSeverityFilter(packageName, version, minSeverity = 'low') {
        const vulnerabilities = await this.scanPackage(packageName, version);
        
        const severityOrder = {
            'INFO': 0,
            'LOW': 1,
            'MEDIUM': 2,
            'HIGH': 3,
            'CRITICAL': 4
        };
        
        const minLevel = severityOrder[minSeverity.toUpperCase()];
        
        return vulnerabilities.filter(vuln => 
            severityOrder[vuln.severity] >= minLevel
        );
    }
    
    async getVulnerabilityDetails(vulnerabilityId) {
        // Получение деталей уязвимости из базы данных
        return await this.vulnerabilityDatabase.getVulnerabilityDetails(vulnerabilityId);
    }
    
    async getRemediationAdvice(vulnerability) {
        // Получение рекомендаций по устранению уязвимости
        return await this.vulnerabilityDatabase.getRemediationAdvice(vulnerability.id);
    }
    
    async getVulnerabilityTrends() {
        // Получение трендов уязвимостей
        return await this.vulnerabilityDatabase.getTrends();
    }
    
    async exportVulnerabilityReport(format = 'json') {
        const vulnerabilities = await this.scanAllDependencies();
        
        switch (format.toLowerCase()) {
            case 'json':
                return this.generateJSONReport(vulnerabilities);
            case 'html':
                return this.generateHTMLReport(vulnerabilities);
            case 'csv':
                return this.generateCSVReport(vulnerabilities);
            case 'sarif':
                return this.generateSARIFReport(vulnerabilities);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    generateJSONReport(vulnerabilities) {
        return {
            timestamp: new Date().toISOString(),
            scanner: 'Dependency Security Scanner',
            results: vulnerabilities,
            summary: this.generateSummary(vulnerabilities)
        };
    }
    
    generateHTMLReport(vulnerabilities) {
        const fs = require('fs');
        
        const html = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Dependency Vulnerability Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f5f5f5; padding: 15px; margin: 10px 0; }
                .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 10px; }
                .critical { border-left: 5px solid #d32f2f; }
                .high { border-left: 5px solid #f57c00; }
                .medium { border-left: 5px solid #fbc02d; }
                .low { border-left: 5px solid #689f38; }
            </style>
        </head>
        <body>
            <h1>Dependency Vulnerability Report</h1>
            <div class="summary">
                <h2>Summary</h2>
                <p>Total Vulnerabilities: ${this.countTotalVulnerabilities(vulnerabilities)}</p>
                <p>Critical: ${this.countBySeverity(vulnerabilities, 'CRITICAL')}</p>
                <p>High: ${this.countBySeverity(vulnerabilities, 'HIGH')}</p>
                <p>Medium: ${this.countBySeverity(vulnerabilities, 'MEDIUM')}</p>
                <p>Low: ${this.countBySeverity(vulnerabilities, 'LOW')}</p>
            </div>
            
            <h2>Vulnerabilities by Package</h2>
            ${Object.entries(vulnerabilities).map(([pkg, vulns]) => `
                <div>
                    <h3>${pkg}</h3>
                    ${vulns.map(vuln => `
                        <div class="vulnerability ${vuln.severity.toLowerCase()}">
                            <h4>${vuln.title} (${vuln.severity})</h4>
                            <p><strong>ID:</strong> ${vuln.id}</p>
                            <p><strong>Description:</strong> ${vuln.description}</p>
                            <p><strong>Detected by:</strong> ${vuln.detectedBy.join(', ')}</p>
                            ${vuln.cvssScore ? `<p><strong>CVSS Score:</strong> ${vuln.cvssScore}</p>` : ''}
                        </div>
                    `).join('')}
                </div>
            `).join('')}
        </body>
        </html>
        `;
        
        const outputPath = `vulnerability-report-${Date.now()}.html`;
        fs.writeFileSync(outputPath, html);
        return outputPath;
    }
    
    countTotalVulnerabilities(vulnerabilities) {
        return Object.values(vulnerabilities)
            .reduce((sum, pkgVulns) => sum + pkgVulns.length, 0);
    }
    
    countBySeverity(vulnerabilities, severity) {
        let count = 0;
        for (const pkgVulns of Object.values(vulnerabilities)) {
            count += pkgVulns.filter(v => v.severity === severity).length;
        }
        return count;
    }
    
    generateSummary(vulnerabilities) {
        const summary = {
            totalPackages: Object.keys(vulnerabilities).length,
            totalVulnerabilities: this.countTotalVulnerabilities(vulnerabilities),
            bySeverity: {
                CRITICAL: this.countBySeverity(vulnerabilities, 'CRITICAL'),
                HIGH: this.countBySeverity(vulnerabilities, 'HIGH'),
                MEDIUM: this.countBySeverity(vulnerabilities, 'MEDIUM'),
                LOW: this.countBySeverity(vulnerabilities, 'LOW')
            },
            affectedPackages: Object.entries(vulnerabilities)
                .filter(([, vulns]) => vulns.length > 0)
                .map(([pkg]) => pkg)
        };
        
        return summary;
    }
    
    async getVulnerabilityRiskAssessment(vulnerabilities) {
        const assessment = {
            overallRisk: 'LOW',
            riskScore: 0,
            criticalPackages: [],
            highRiskPackages: [],
            recommendations: []
        };
        
        let totalRisk = 0;
        
        for (const [pkg, vulns] of Object.entries(vulnerabilities)) {
            let pkgRisk = 0;
            
            for (const vuln of vulns) {
                const severityWeight = this.getSeverityWeight(vuln.severity);
                const exploitability = await this.getExploitabilityScore(vuln);
                
                pkgRisk += severityWeight * exploitability;
            }
            
            totalRisk += pkgRisk;
            
            if (pkgRisk >= 20) {
                assessment.criticalPackages.push({ package: pkg, risk: pkgRisk });
            } else if (pkgRisk >= 10) {
                assessment.highRiskPackages.push({ package: pkg, risk: pkgRisk });
            }
        }
        
        assessment.riskScore = totalRisk;
        assessment.overallRisk = this.calculateOverallRisk(totalRisk);
        
        return assessment;
    }
    
    getSeverityWeight(severity) {
        const weights = {
            'CRITICAL': 10,
            'HIGH': 7,
            'MEDIUM': 4,
            'LOW': 1
        };
        return weights[severity] || 2;
    }
    
    async getExploitabilityScore(vulnerability) {
        // Оценка эксплуатируемости уязвимости
        // В реальности использовать данные из CVE базы
        if (vulnerability.cvssScore >= 9.0) return 1.0; // 100% эксплуатируемость
        if (vulnerability.cvssScore >= 7.0) return 0.8; // 80% эксплуатируемость
        if (vulnerability.cvssScore >= 4.0) return 0.6; // 60% эксплуатируемость
        return 0.3; // 30% эксплуатируемость
    }
    
    calculateOverallRisk(score) {
        if (score >= 50) return 'CRITICAL';
        if (score >= 30) return 'HIGH';
        if (score >= 15) return 'MEDIUM';
        if (score >= 5) return 'LOW';
        return 'INFO';
    }
    
    async getVulnerabilityTimeline() {
        // В реальности использовать исторические данные
        return {
            trend: 'stable',
            monthlyAvg: 5,
            severityDistribution: { critical: 0, high: 2, medium: 3, low: 10 }
        };
    }
}

// Сканировщик через npm audit
class NPMAuditScanner {
    async scan(packageName, version) {
        const { execSync } = require('child_process');
        
        try {
            // Создание временного проекта для сканирования конкретного пакета
            const tempDir = `./temp-scan-${Date.now()}`;
            const fs = require('fs');
            
            fs.mkdirSync(tempDir, { recursive: true });
            
            // Создание временного package.json
            const tempPackageJson = {
                name: 'temp-scan',
                version: '1.0.0',
                dependencies: {
                    [packageName]: version
                }
            };
            
            fs.writeFileSync(`${tempDir}/package.json`, JSON.stringify(tempPackageJson, null, 2));
            
            // Установка зависимостей
            execSync(`cd ${tempDir} && npm install`, { stdio: 'pipe' });
            
            // Сканирование
            const result = execSync(`cd ${tempDir} && npm audit --json`, { encoding: 'utf8' });
            const audit = JSON.parse(result);
            
            // Очистка
            fs.rmSync(tempDir, { recursive: true, force: true });
            
            if (audit.advisories) {
                return {
                    vulnerabilities: Object.values(audit.advisories).map(advisory => ({
                        id: advisory.id.toString(),
                        package: advisory.module_name,
                        title: advisory.title,
                        severity: advisory.severity,
                        description: advisory.overview,
                        cvssScore: advisory.cvss?.score,
                        cve: advisory.cves?.[0],
                        patchedVersions: advisory.patched_versions,
                        vulnerableVersions: advisory.vulnerable_versions
                    }))
                };
            }
            
            return { vulnerabilities: [] };
        } catch (error) {
            if (error.stdout) {
                try {
                    const audit = JSON.parse(error.stdout);
                    if (audit.advisories) {
                        return {
                            vulnerabilities: Object.values(audit.advisories).map(advisory => ({
                                id: advisory.id.toString(),
                                package: advisory.module_name,
                                title: advisory.title,
                                severity: advisory.severity,
                                description: advisory.overview,
                                cvssScore: advisory.cvss?.score,
                                cve: advisory.cves?.[0],
                                patchedVersions: advisory.patched_versions,
                                vulnerableVersions: advisory.vulnerable_versions
                            }))
                        };
                    }
                } catch {
                    // Если не удалось распарсить, возвращаем пустой массив
                }
            }
            return { vulnerabilities: [] };
        }
    }
}

// Сканировщик через Snyk
class SnykScanner {
    constructor() {
        this.apiToken = process.env.SNYK_TOKEN;
    }
    
    async scan(packageName, version) {
        if (!this.apiToken) {
            console.warn('Snyk API token not configured, skipping Snyk scan');
            return { vulnerabilities: [] };
        }
        
        try {
            const { execSync } = require('child_process');
            
            // Создание временного проекта
            const tempDir = `./temp-snyk-scan-${Date.now()}`;
            const fs = require('fs');
            
            fs.mkdirSync(tempDir, { recursive: true });
            
            const tempPackageJson = {
                name: 'temp-snyk-scan',
                version: '1.0.0',
                dependencies: { [packageName]: version }
            };
            
            fs.writeFileSync(`${tempDir}/package.json`, JSON.stringify(tempPackageJson, null, 2));
            
            // Сканирование через Snyk
            const result = execSync(`cd ${tempDir} && npx snyk test --json`, { 
                encoding: 'utf8',
                env: { ...process.env, SNYK_TOKEN: this.apiToken }
            });
            
            const snykResult = JSON.parse(result);
            
            // Очистка
            fs.rmSync(tempDir, { recursive: true, force: true });
            
            if (snykResult.vulnerabilities) {
                return {
                    vulnerabilities: snykResult.vulnerabilities.map(vuln => ({
                        id: vuln.id,
                        package: vuln.from?.[1] || vuln.packageName,
                        title: vuln.title,
                        severity: vuln.severity,
                        description: vuln.description,
                        cvssScore: vuln.cvssScore,
                        cve: vuln.cve?.[0],
                        patchedVersions: vuln.semver?.patched || [],
                        vulnerableVersions: vuln.semver?.vulnerable || []
                    }))
                };
            }
            
            return { vulnerabilities: [] };
        } catch (error) {
            console.error('Snyk scan failed:', error.message);
            return { vulnerabilities: [] };
        }
    }
}

// Использование сканера
const vulnerabilityScanner = new VulnerabilityScanner({
    tools: ['npm-audit', 'snyk'],
    severityThreshold: 'moderate'
});
```

## Интеграция с CI/CD

### 1. Pipeline безопасности зависимостей

```yaml
# .github/workflows/dependency-security.yml
name: Dependency Security Check

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  security-check:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run dependency security scan
        run: |
          npm audit --audit-level moderate
          npx snyk test --severity-threshold=medium
          
          # Проверка лицензий
          npx license-checker --summary
          
      - name: Generate security report
        run: |
          npm audit --json > npm-audit-report.json
          npx snyk test --json > snyk-report.json
          
      - name: Parse security results
        run: |
          # Подсчет уязвимостей
          critical_count=$(jq '.metadata.vulnerabilities.critical // 0' npm-audit-report.json)
          high_count=$(jq '.metadata.vulnerabilities.high // 0' npm-audit-report.json)
          
          echo "Critical vulnerabilities: $critical_count"
          echo "High vulnerabilities: $high_count"
          
          # Блокировка сборки при критических уязвимостях
          if [ "$critical_count" -gt 0 ]; then
            echo "Critical vulnerabilities detected, failing build"
            exit 1
          fi
          
          if [ "$high_count" -gt 5 ]; then
            echo "Too many high vulnerabilities, failing build"
            exit 1
          fi
          
      - name: Upload security reports
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            npm-audit-report.json
            snyk-report.json
            license-checker-report.json
      
      - name: Post security summary to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const npmReport = JSON.parse(fs.readFileSync('npm-audit-report.json', 'utf8'));
            const snykReport = JSON.parse(fs.readFileSync('snyk-report.json', 'utf8'));
            
            const comment = `
            ## Dependency Security Check
            
            ### NPM Audit
            - Critical: ${npmReport.metadata?.vulnerabilities?.critical || 0}
            - High: ${npmReport.metadata?.vulnerabilities?.high || 0}
            - Moderate: ${npmReport.metadata?.vulnerabilities?.moderate || 0}
            - Low: ${npmReport.metadata?.vulnerabilities?.low || 0}
            
            ### Snyk Scan
            - Total issues: ${snykReport.issues?.length || 0}
            - Critical: ${snykReport.issues?.filter(i => i.severity === 'critical')?.length || 0}
            - High: ${snykReport.issues?.filter(i => i.severity === 'high')?.length || 0}
            
            ${
              (npmReport.metadata?.vulnerabilities?.critical || 0) > 0 || 
              (snykReport.issues?.filter(i => i.severity === 'critical')?.length || 0) > 0 ? 
              ':x: **BUILD BLOCKED** - Critical vulnerabilities detected' : 
              ':white_check_mark: No critical vulnerabilities found'
            }
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

### 2. GitLab CI интеграция

```yaml
# .gitlab-ci.yml
stages:
  - security
  - test
  - build

dependency-security:
  stage: security
  image: node:18
  script:
    - npm ci
    - npm audit --audit-level moderate
    - |
      if [ -n "$SNYK_TOKEN" ]; then
        npx snyk test --severity-threshold=medium
      fi
    - |
      # Проверка лицензий
      npx license-checker --summary
      if [ $? -ne 0 ]; then
        echo "License check failed"
        exit 1
      fi
    - |
      # Генерация отчета
      npm audit --json > npm-audit.json
      npx snyk test --json > snyk-results.json
      
      # Подсчет уязвимостей
      critical=$(jq '.metadata.vulnerabilities.critical // 0' npm-audit.json)
      if [ "$critical" -gt 0 ]; then
        echo "Critical vulnerabilities found: $critical"
        exit 1
      fi
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scan.json
    paths:
      - npm-audit.json
      - snyk-results.json
  allow_failure: false
```

## Лучшие практики управления зависимостями

### 1. Политики безопасности

```javascript
// Политика безопасности зависимостей
class SecurityPolicyManager {
    constructor() {
        this.policies = {
            versionPolicy: {
                allowMajorUpdates: false,
                requireSecurityPatches: true,
                maxAgeDays: 365,
                requireSignedPackages: true
            },
            
            licensePolicy: {
                allowedLicenses: [
                    'MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC', 'CC0-1.0'
                ],
                forbiddenLicenses: [
                    'GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'CC-BY-NC-4.0'
                ],
                requireApproval: [
                    'MPL-2.0', 'EPL-2.0', 'OSL-3.0'
                ]
            },
            
            sourcePolicy: {
                trustedRegistries: [
                    'https://registry.npmjs.org/',
                    'https://pkgs.dev.azure.com/',
                    process.env.NPM_REGISTRY_URL
                ],
                allowGitDependencies: false,
                allowTarballDependencies: false
            },
            
            qualityPolicy: {
                minDownloads: 1000,
                minAgeDays: 30,
                requireDocumentation: true,
                requireTests: true
            }
        };
        
        this.exceptions = new Map(); // Исключения для конкретных пакетов
        this.approvalQueue = []; // Очередь на одобрение
    }
    
    async validatePackage(packageInfo) {
        const validation = {
            version: await this.validateVersionPolicy(packageInfo),
            license: await this.validateLicensePolicy(packageInfo),
            source: await this.validateSourcePolicy(packageInfo),
            quality: await this.validateQualityPolicy(packageInfo),
            overallCompliance: false
        };
        
        validation.overallCompliance = 
            validation.version.compliant &&
            validation.license.compliant &&
            validation.source.compliant &&
            validation.quality.compliant;
        
        return validation;
    }
    
    async validateVersionPolicy(packageInfo) {
        const result = { compliant: true, issues: [] };
        
        // Проверка на мажорные обновления
        if (this.policies.versionPolicy.allowMajorUpdates === false) {
            const isMajorUpdate = await this.isMajorUpdate(packageInfo);
            if (isMajorUpdate) {
                result.compliant = false;
                result.issues.push({
                    type: 'MAJOR_UPDATE_DENIED',
                    severity: 'MEDIUM',
                    message: 'Major version updates are not allowed by policy'
                });
            }
        }
        
        // Проверка возраста пакета
        const age = await this.getPackageAge(packageInfo.name, packageInfo.version);
        if (age > this.policies.versionPolicy.maxAgeDays) {
            result.compliant = false;
            result.issues.push({
                type: 'PACKAGE_TOO_OLD',
                severity: 'LOW',
                message: `Package is ${age} days old, exceeds maximum age of ${this.policies.versionPolicy.maxAgeDays} days`
            });
        }
        
        // Проверка подписи (если требуется)
        if (this.policies.versionPolicy.requireSignedPackages) {
            const isSigned = await this.isPackageSigned(packageInfo.name, packageInfo.version);
            if (!isSigned) {
                result.compliant = false;
                result.issues.push({
                    type: 'UNSIGNED_PACKAGE',
                    severity: 'MEDIUM',
                    message: 'Package is not signed but signing is required by policy'
                });
            }
        }
        
        return result;
    }
    
    async validateLicensePolicy(packageInfo) {
        const result = { compliant: true, issues: [] };
        
        const license = await this.getPackageLicense(packageInfo.name);
        
        if (!license) {
            result.compliant = false;
            result.issues.push({
                type: 'NO_LICENSE',
                severity: 'HIGH',
                message: 'Package has no license specified'
            });
            return result;
        }
        
        // Проверка на запрещенные лицензии
        if (this.policies.licensePolicy.forbiddenLicenses.includes(license)) {
            result.compliant = false;
            result.issues.push({
                type: 'FORBIDDEN_LICENSE',
                severity: 'CRITICAL',
                message: `Package uses forbidden license: ${license}`
            });
            return result;
        }
        
        // Проверка на лицензии, требующие одобрения
        if (this.policies.licensePolicy.requireApproval.includes(license)) {
            if (!this.isPackageApproved(packageInfo.name, license)) {
                result.compliant = false;
                result.issues.push({
                    type: 'LICENSE_REQUIRES_APPROVAL',
                    severity: 'MEDIUM',
                    message: `License ${license} requires manual approval`
                });
            }
        }
        
        // Проверка на разрешенные лицензии
        if (!this.policies.licensePolicy.allowedLicenses.includes(license)) {
            result.compliant = false;
            result.issues.push({
                type: 'LICENSE_NOT_ALLOWED',
                severity: 'HIGH',
                message: `Package uses license not in allowed list: ${license}`
            });
        }
        
        return result;
    }
    
    async validateSourcePolicy(packageInfo) {
        const result = { compliant: true, issues: [] };
        
        // Проверка источника пакета
        const source = await this.getPackageSource(packageInfo.name);
        
        if (!this.policies.sourcePolicy.trustedRegistries.includes(source)) {
            result.compliant = false;
            result.issues.push({
                type: 'UNTRUSTED_SOURCE',
                severity: 'HIGH',
                message: `Package from untrusted source: ${source}`,
                source: source
            });
        }
        
        // Проверка типа зависимости
        if (packageInfo.specification.startsWith('git+') && !this.policies.sourcePolicy.allowGitDependencies) {
            result.compliant = false;
            result.issues.push({
                type: 'GIT_DEPENDENCY_DENIED',
                severity: 'MEDIUM',
                message: 'Git dependencies are not allowed by policy'
            });
        }
        
        if (packageInfo.specification.startsWith('file:') && !this.policies.sourcePolicy.allowTarballDependencies) {
            result.compliant = false;
            result.issues.push({
                type: 'TARBALL_DEPENDENCY_DENIED',
                severity: 'MEDIUM',
                message: 'Tarball dependencies are not allowed by policy'
            });
        }
        
        return result;
    }
    
    async validateQualityPolicy(packageInfo) {
        const result = { compliant: true, issues: [] };
        
        const packageMetadata = await this.getPackageMetadata(packageInfo.name);
        
        // Проверка количества скачиваний
        if (packageMetadata.downloads && packageMetadata.downloads < this.policies.qualityPolicy.minDownloads) {
            result.compliant = false;
            result.issues.push({
                type: 'LOW_DOWNLOADS',
                severity: 'MEDIUM',
                message: `Package has only ${packageMetadata.downloads} downloads, minimum required: ${this.policies.qualityPolicy.minDownloads}`
            });
        }
        
        // Проверка возраста
        if (packageMetadata.age && packageMetadata.age < this.policies.qualityPolicy.minAgeDays) {
            result.compliant = false;
            result.issues.push({
                type: 'NEW_PACKAGE',
                severity: 'LOW',
                message: `Package is only ${packageMetadata.age} days old, minimum required: ${this.policies.qualityPolicy.minAgeDays} days`
            });
        }
        
        // Проверка наличия документации
        if (this.policies.qualityPolicy.requireDocumentation && !packageMetadata.hasDocumentation) {
            result.compliant = false;
            result.issues.push({
                type: 'NO_DOCUMENTATION',
                severity: 'LOW',
                message: 'Package does not have documentation'
            });
        }
        
        // Проверка наличия тестов
        if (this.policies.qualityPolicy.requireTests && !packageMetadata.hasTests) {
            result.compliant = false;
            result.issues.push({
                type: 'NO_TESTS',
                severity: 'MEDIUM',
                message: 'Package does not have tests'
            });
        }
        
        return result;
    }
    
    async isMajorUpdate(packageInfo) {
        // Проверка, является ли обновление мажорным
        const currentVersion = await this.getCurrentInstalledVersion(packageInfo.name);
        const targetVersion = packageInfo.version;
        
        if (!currentVersion) return true; // Новый пакет
        
        const [cMajor, cMinor, cPatch] = currentVersion.replace('^', '').replace('~', '').split('.').map(Number);
        const [tMajor, tMinor, tPatch] = targetVersion.split('.').map(Number);
        
        return tMajor > cMajor;
    }
    
    async getPackageAge(name, version) {
        // Получение возраста пакета
        const metadata = await this.getPackageMetadata(name);
        if (!metadata.publishTime || !metadata['dist-tags']?.[version]) {
            return 0;
        }
        
        const publishDate = new Date(metadata.time[version]);
        const now = new Date();
        const diffTime = Math.abs(now - publishDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        return diffDays;
    }
    
    async isPackageSigned(name, version) {
        // Проверка подписи пакета
        // В реальности использовать npm sigstore или подобное
        return true; // Заглушка
    }
    
    async getPackageLicense(name) {
        const metadata = await this.getPackageMetadata(name);
        const license = metadata.license || metadata.licenses?.[0];
        
        if (typeof license === 'string') {
            return license;
        }
        
        if (typeof license === 'object' && license.type) {
            return license.type;
        }
        
        return null;
    }
    
    async getPackageSource(name) {
        // Получение источника пакета
        const metadata = await this.getPackageMetadata(name);
        return metadata._resolved || metadata._from || 'unknown';
    }
    
    async getPackageMetadata(name) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            return {};
        }
    }
    
    isPackageApproved(name, license) {
        // Проверка, одобрен ли пакет
        const approval = this.approvedPackages.get(`${name}:${license}`);
        return approval && approval.approved;
    }
    
    async requestPackageApproval(packageInfo, reason) {
        const approvalRequest = {
            id: `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            package: packageInfo.name,
            version: packageInfo.version,
            license: await this.getPackageLicense(packageInfo.name),
            reason: reason,
            requestedBy: process.env.USER || 'unknown',
            requestedAt: new Date().toISOString(),
            status: 'PENDING'
        };
        
        this.approvalQueue.push(approvalRequest);
        
        // Отправка запроса на одобрение
        await this.notifyForApproval(approvalRequest);
        
        return approvalRequest;
    }
    
    async approvePackage(requestId, approvedBy) {
        const request = this.approvalQueue.find(req => req.id === requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not pending approval');
        }
        
        request.status = 'APPROVED';
        request.approvedBy = approvedBy;
        request.approvedAt = new Date().toISOString();
        
        // Добавление в одобренные пакеты
        this.approvedPackages.set(`${request.package}:${request.license}`, {
            approved: true,
            approvedBy: approvedBy,
            approvedAt: request.approvedAt,
            reason: request.reason
        });
        
        return request;
    }
    
    async getPolicyComplianceReport() {
        const dependencies = await this.getProjectDependencies();
        const results = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            results[`${name}@${version}`] = await this.validatePackage({ name, version });
        }
        
        const compliantCount = Object.values(results).filter(r => r.overallCompliance).length;
        const total = Object.keys(results).length;
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: total,
            compliantDependencies: compliantCount,
            nonCompliantDependencies: total - compliantCount,
            complianceRate: total > 0 ? (compliantCount / total) * 100 : 0,
            detailedResults: results,
            summary: this.generateComplianceSummary(results)
        };
    }
    
    generateComplianceSummary(results) {
        const summary = {
            byPolicy: {
                version: { compliant: 0, nonCompliant: 0 },
                license: { compliant: 0, nonCompliant: 0 },
                source: { compliant: 0, nonCompliant: 0 },
                quality: { compliant: 0, nonCompliant: 0 }
            },
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
            topIssues: []
        };
        
        for (const result of Object.values(results)) {
            // Подсчет по политикам
            if (result.version.compliant) summary.byPolicy.version.compliant++;
            else summary.byPolicy.version.nonCompliant++;
            
            if (result.license.compliant) summary.byPolicy.license.compliant++;
            else summary.byPolicy.license.nonCompliant++;
            
            if (result.source.compliant) summary.byPolicy.source.compliant++;
            else summary.byPolicy.source.nonCompliant++;
            
            if (result.quality.compliant) summary.byPolicy.quality.compliant++;
            else summary.byPolicy.quality.nonCompliant++;
            
            // Подсчет по тяжести
            for (const issue of [...result.version.issues, ...result.license.issues, 
                                ...result.source.issues, ...result.quality.issues]) {
                summary.bySeverity[issue.severity] = (summary.bySeverity[issue.severity] || 0) + 1;
            }
        }
        
        // Топ проблем
        const allIssues = Object.values(results).flatMap(result => [
            ...result.version.issues, ...result.license.issues,
            ...result.source.issues, ...result.quality.issues
        ]);
        
        const issueCounts = {};
        allIssues.forEach(issue => {
            issueCounts[issue.type] = (issueCounts[issue.type] || 0) + 1;
        });
        
        summary.topIssues = Object.entries(issueCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([type, count]) => ({ type, count }));
        
        return summary;
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        return {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
    }
    
    async notifyForApproval(request) {
        // Отправка уведомления о запросе одобрения
        console.log(`Approval requested for ${request.package}: ${request.reason}`);
        
        // В реальности интеграция с системами уведомлений
        if (process.env.APPROVAL_WEBHOOK) {
            try {
                await fetch(process.env.APPROVAL_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'PACKAGE_APPROVAL_REQUEST',
                        request: request
                    })
                });
            } catch (error) {
                console.error('Failed to send approval notification:', error);
            }
        }
    }
}

// Использование менеджера политики
const policyManager = new SecurityPolicyManager();

async function runPolicyComplianceCheck() {
    const report = await policyManager.getPolicyComplianceReport();
    console.log('Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (report.complianceRate < 95) { // 95% порог соответствия
        console.error('Policy compliance check failed');
        process.exit(1);
    }
    
    return report;
}
```

### 2. Автоматическое обновление зависимостей

```javascript
// Система автоматического обновления зависимостей
class AutomatedDependencyUpdater {
    constructor(config) {
        this.config = {
            autoUpdate: config.autoUpdate || false,
            updateSchedule: config.updateSchedule || 'daily',
            securityOnly: config.securityOnly || true,
            testBeforeUpdate: config.testBeforeUpdate || true,
            backupBeforeUpdate: config.backupBeforeUpdate || true,
            dryRun: config.dryRun || false,
            ...config
        };
        
        this.updateHistory = [];
        this.securityChecker = new SecurityChecker();
        this.testRunner = new TestRunner();
        this.backupManager = new BackupManager();
        this.notificationManager = new NotificationManager();
    }
    
    async scheduleUpdates() {
        if (!this.config.autoUpdate) return;
        
        const interval = this.getUpdateInterval(this.config.updateSchedule);
        
        setInterval(async () => {
            await this.performScheduledUpdate();
        }, interval);
    }
    
    getUpdateInterval(schedule) {
        const intervals = {
            'hourly': 60 * 60 * 1000,
            'daily': 24 * 60 * 60 * 1000,
            'weekly': 7 * 24 * 60 * 60 * 1000,
            'monthly': 30 * 24 * 60 * 60 * 1000
        };
        
        return intervals[schedule] || intervals['daily'];
    }
    
    async performScheduledUpdate() {
        console.log('Starting scheduled dependency update...');
        
        try {
            // Создание бэкапа
            if (this.config.backupBeforeUpdate) {
                await this.backupManager.createBackup();
            }
            
            // Проверка обновлений
            const updates = await this.checkForUpdates();
            
            // Фильтрация обновлений по политике
            const updatesToApply = this.filterUpdates(updates);
            
            if (updatesToApply.length > 0) {
                console.log(`Found ${updatesToApply.length} updates to apply`);
                
                for (const update of updatesToApply) {
                    await this.applyUpdate(update);
                }
                
                // Запуск тестов после обновлений
                if (this.config.testBeforeUpdate) {
                    const testsPassed = await this.testRunner.runTests();
                    if (!testsPassed) {
                        console.error('Tests failed after updates, rolling back...');
                        await this.rollbackUpdates();
                        return;
                    }
                }
                
                // Фиксация обновлений
                await this.commitUpdates(updatesToApply);
                
                // Отправка уведомлений
                await this.notificationManager.sendUpdateNotification(updatesToApply);
            } else {
                console.log('No updates to apply');
            }
            
        } catch (error) {
            console.error('Scheduled update failed:', error);
            await this.handleUpdateError(error);
        }
    }
    
    async checkForUpdates() {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npm outdated --json', { encoding: 'utf8' });
            const outdated = JSON.parse(result);
            
            const updates = [];
            
            for (const [name, info] of Object.entries(outdated)) {
                const updateType = this.getUpdateType(info.current, info.wanted);
                
                // Проверка безопасности обновления
                const securityUpdate = await this.securityChecker.hasSecurityUpdate(name, info.current, info.wanted);
                
                updates.push({
                    name: name,
                    current: info.current,
                    wanted: info.wanted,
                    latest: info.latest,
                    updateType: updateType,
                    securityUpdate: securityUpdate,
                    critical: securityUpdate.critical > 0,
                    high: securityUpdate.high > 0
                });
            }
            
            return updates;
        } catch (error) {
            console.error('Failed to check for updates:', error.message);
            return [];
        }
    }
    
    getUpdateType(current, wanted) {
        const [cMajor, cMinor, cPatch] = current.replace('^', '').replace('~', '').split('.').map(Number);
        const [wMajor, wMinor, wPatch] = wanted.split('.').map(Number);
        
        if (wMajor > cMajor) return 'major';
        if (wMinor > cMinor) return 'minor';
        if (wPatch > cPatch) return 'patch';
        return 'unknown';
    }
    
    filterUpdates(updates) {
        if (this.config.securityOnly) {
            // Только обновления безопасности
            return updates.filter(update => update.securityUpdate.total > 0);
        }
        
        // Все обновления, соответствующие политике
        return updates.filter(update => {
            if (update.updateType === 'major' && !this.config.allowMajorUpdates) {
                return false;
            }
            if (update.updateType === 'minor' && !this.config.allowMinorUpdates) {
                return false;
            }
            if (update.updateType === 'patch' && !this.config.allowPatchUpdates) {
                return false;
            }
            
            return true;
        });
    }
    
    async applyUpdate(update) {
        if (this.config.dryRun) {
            console.log(`[DRY RUN] Would update ${update.name} from ${update.current} to ${update.wanted}`);
            return;
        }
        
        console.log(`Updating ${update.name} from ${update.current} to ${update.wanted}...`);
        
        try {
            const { execSync } = require('child_process');
            execSync(`npm install ${update.name}@${update.wanted}`, {
                stdio: 'inherit',
                cwd: process.cwd()
            });
            
            // Логирование обновления
            this.logUpdate(update, true);
            
            console.log(`Successfully updated ${update.name}`);
            
        } catch (error) {
            console.error(`Failed to update ${update.name}:`, error.message);
            this.logUpdate(update, false, error.message);
            throw error;
        }
    }
    
    async commitUpdates(updates) {
        if (this.config.dryRun) {
            console.log('[DRY RUN] Would commit updates:', updates.length);
            return;
        }
        
        const { execSync } = require('child_process');
        
        try {
            // Обновление package-lock.json
            execSync('git add package-lock.json', { stdio: 'inherit' });
            
            // Коммит обновлений
            const updateSummary = updates.map(u => 
                `${u.name}: ${u.current} → ${u.wanted}`
            ).join(', ');
            
            execSync(`git commit -m "security: Update dependencies for security fixes - ${updateSummary}"`, {
                stdio: 'inherit'
            });
            
            // Пуш изменений
            execSync('git push', { stdio: 'inherit' });
            
            console.log('Updates committed and pushed successfully');
        } catch (error) {
            console.error('Failed to commit updates:', error.message);
            throw error;
        }
    }
    
    logUpdate(update, success, error = null) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            package: update.name,
            from: update.current,
            to: update.wanted,
            updateType: update.updateType,
            securityUpdate: update.securityUpdate.total > 0,
            success: success,
            error: error
        };
        
        this.updateHistory.push(logEntry);
        
        // Ограничение истории
        if (this.updateHistory.length > 1000) {
            this.updateHistory = this.updateHistory.slice(-1000);
        }
    }
    
    async rollbackUpdates() {
        if (this.config.dryRun) {
            console.log('[DRY RUN] Would rollback updates');
            return;
        }
        
        try {
            const { execSync } = require('child_process');
            
            // Восстановление из бэкапа
            await this.backupManager.restoreLatestBackup();
            
            // Откат git коммитов
            execSync('git reset --hard HEAD~1', { stdio: 'inherit' });
            
            console.log('Updates rolled back successfully');
        } catch (error) {
            console.error('Rollback failed:', error.message);
            throw error;
        }
    }
    
    async handleUpdateError(error) {
        console.error('Update error occurred:', error.message);
        
        // Отправка уведомления об ошибке
        await this.notificationManager.sendUpdateErrorNotification(error);
    }
    
    async getUpdateStatistics() {
        const stats = {
            totalUpdates: this.updateHistory.length,
            successfulUpdates: this.updateHistory.filter(u => u.success).length,
            failedUpdates: this.updateHistory.filter(u => !u.success).length,
            securityUpdates: this.updateHistory.filter(u => u.securityUpdate).length,
            byType: {
                major: this.updateHistory.filter(u => u.updateType === 'major').length,
                minor: this.updateHistory.filter(u => u.updateType === 'minor').length,
                patch: this.updateHistory.filter(u => u.updateType === 'patch').length
            },
            successRate: this.updateHistory.length > 0 ? 
                (this.updateHistory.filter(u => u.success).length / this.updateHistory.length) * 100 : 0
        };
        
        return stats;
    }
    
    async generateUpdateReport() {
        const stats = await this.getUpdateStatistics();
        const recentUpdates = this.updateHistory.slice(-20);
        
        return {
            timestamp: new Date().toISOString(),
            statistics: stats,
            recentUpdates,
            recommendations: this.generateUpdateRecommendations(stats)
        };
    }
    
    generateUpdateRecommendations(stats) {
        const recommendations = [];
        
        if (stats.successRate < 80) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Low Update Success Rate',
                description: `Only ${stats.successRate.toFixed(2)}% of updates succeed`,
                action: 'Investigate and fix update process issues'
            });
        }
        
        if (stats.failedUpdates > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Update Failures Detected',
                description: `${stats.failedUpdates} update failures recorded`,
                action: 'Review failed updates and improve process'
            });
        }
        
        if (stats.securityUpdates === 0 && this.config.securityOnly) {
            recommendations.push({
                priority: 'LOW',
                title: 'No Security Updates Applied',
                description: 'No security updates were applied in the period',
                action: 'Verify security update detection is working'
            });
        }
        
        return recommendations;
    }
}

// Использование автоматического обновлятора
const autoUpdater = new AutomatedDependencyUpdater({
    autoUpdate: true,
    updateSchedule: 'daily',
    securityOnly: true,
    testBeforeUpdate: true,
    backupBeforeUpdate: true
});

// Запуск автоматических обновлений
autoUpdater.scheduleUpdates().catch(console.error);
```

## Мониторинг и алертинг

### 1. Система уведомлений

```javascript
// Система уведомлений для управления зависимостями
class DependencyNotificationManager {
    constructor(config) {
        this.config = {
            channels: config.channels || ['console'],
            severityThresholds: {
                critical: 0,
                high: 5,
                medium: 10
            },
            notificationCooldown: config.notificationCooldown || 300000, // 5 минут
            ...config
        };
        
        this.lastNotifications = new Map();
        this.initializeChannels();
    }
    
    initializeChannels() {
        this.channels = new Map();
        
        if (this.config.channels.includes('console')) {
            this.channels.set('console', new ConsoleNotificationChannel());
        }
        
        if (this.config.channels.includes('email') && this.config.email) {
            this.channels.set('email', new EmailNotificationChannel(this.config.email));
        }
        
        if (this.config.channels.includes('slack') && this.config.slack) {
            this.channels.set('slack', new SlackNotificationChannel(this.config.slack));
        }
        
        if (this.config.channels.includes('webhook') && this.config.webhook) {
            this.channels.set('webhook', new WebhookNotificationChannel(this.config.webhook));
        }
    }
    
    async sendAlert(alert) {
        const now = Date.now();
        const cooldownKey = `${alert.type}:${alert.severity}`;
        
        // Проверка кулдауна
        const lastNotification = this.lastNotifications.get(cooldownKey);
        if (lastNotification && (now - lastNotification) < this.config.notificationCooldown) {
            console.log(`Alert cooldown active for ${cooldownKey}`);
            return;
        }
        
        // Отправка уведомления во все каналы
        const promises = [];
        for (const channel of this.channels.values()) {
            promises.push(channel.send(alert));
        }
        
        try {
            await Promise.allSettled(promises);
            this.lastNotifications.set(cooldownKey, now);
        } catch (error) {
            console.error('Failed to send alert:', error);
        }
    }
    
    async sendVulnerabilityAlert(vulnerability) {
        const alert = {
            type: 'VULNERABILITY_DETECTED',
            severity: vulnerability.severity,
            title: `Security Vulnerability in ${vulnerability.package}`,
            description: vulnerability.title || vulnerability.description,
            package: vulnerability.package,
            version: vulnerability.version,
            cve: vulnerability.cve,
            cvssScore: vulnerability.cvssScore,
            timestamp: new Date().toISOString(),
            source: 'dependency-scanner'
        };
        
        await this.sendAlert(alert);
    }
    
    async sendLicenseViolationAlert(violation) {
        const alert = {
            type: 'LICENSE_VIOLATION',
            severity: 'MEDIUM',
            title: `License Violation in ${violation.package}`,
            description: `Package uses non-compliant license: ${violation.license}`,
            package: violation.package,
            license: violation.license,
            timestamp: new Date().toISOString(),
            source: 'license-checker'
        };
        
        await this.sendAlert(alert);
    }
    
    async sendCriticalAlert(alert) {
        // Отправка критического алерта с повышенным приоритетом
        alert.priority = 'CRITICAL';
        alert.urgency = 'HIGH';
        
        // Дополнительные каналы для критических алертов
        if (this.config.criticalChannels) {
            for (const channelName of this.config.criticalChannels) {
                const channel = this.channels.get(channelName);
                if (channel) {
                    await channel.sendCritical(alert);
                }
            }
        }
        
        await this.sendAlert(alert);
    }
    
    async sendUpdateNotification(updates) {
        const alert = {
            type: 'DEPENDENCY_UPDATES_APPLIED',
            severity: 'INFO',
            title: `Applied ${updates.length} dependency updates`,
            description: `Updated packages: ${updates.map(u => u.name).join(', ')}`,
            updates: updates,
            timestamp: new Date().toISOString(),
            source: 'dependency-updater'
        };
        
        await this.sendAlert(alert);
    }
    
    async sendUpdateErrorNotification(error) {
        const alert = {
            type: 'UPDATE_ERROR',
            severity: 'HIGH',
            title: 'Dependency Update Failed',
            description: error.message,
            error: error,
            timestamp: new Date().toISOString(),
            source: 'dependency-updater'
        };
        
        await this.sendCriticalAlert(alert);
    }
    
    async sendPolicyViolationAlert(violation) {
        const alert = {
            type: 'POLICY_VIOLATION',
            severity: violation.severity || 'MEDIUM',
            title: `Policy Violation: ${violation.type}`,
            description: violation.message,
            details: violation,
            timestamp: new Date().toISOString(),
            source: 'policy-enforcer'
        };
        
        await this.sendAlert(alert);
    }
}

// Канал уведомлений для Slack
class SlackNotificationChannel {
    constructor(config) {
        this.webhookUrl = config.webhookUrl;
        this.channel = config.channel || '#security-alerts';
        this.username = config.username || 'Security Bot';
    }
    
    async send(alert) {
        if (!this.webhookUrl) {
            console.warn('Slack webhook URL not configured');
            return;
        }
        
        const message = {
            channel: this.channel,
            username: this.username,
            icon_emoji: this.getEmojiForSeverity(alert.severity),
            attachments: [{
                color: this.getColorForSeverity(alert.severity),
                fields: [
                    { title: 'Type', value: alert.type, short: true },
                    { title: 'Severity', value: alert.severity, short: true },
                    { title: 'Package', value: alert.package || 'N/A', short: true },
                    { title: 'Time', value: new Date(alert.timestamp).toLocaleString(), short: true }
                ],
                text: alert.description,
                footer: 'Dependency Security System',
                ts: Math.floor(Date.now() / 1000)
            }]
        };
        
        try {
            await fetch(this.webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(message)
            });
        } catch (error) {
            console.error('Failed to send Slack notification:', error);
        }
    }
    
    getColorForSeverity(severity) {
        const colors = {
            'CRITICAL': '#FF0000',
            'HIGH': '#FF4500',
            'MEDIUM': '#FFA500',
            'LOW': '#4CAF50',
            'INFO': '#2196F3'
        };
        return colors[severity] || '#808080';
    }
    
    getEmojiForSeverity(severity) {
        const emojis = {
            'CRITICAL': ':boom:',
            'HIGH': ':warning:',
            'MEDIUM': ':exclamation:',
            'LOW': ':information_source:',
            'INFO': ':bulb:'
        };
        return emojis[severity] || ':question:';
    }
    
    async sendCritical(alert) {
        // Критические алерты с упоминанием
        const criticalMessage = {
            channel: this.channel,
            username: this.username,
            icon_emoji: ':rotating_light:',
            text: `<!here> CRITICAL SECURITY ALERT: ${alert.title}`,
            attachments: [{
                color: 'danger',
                fields: [
                    { title: 'Type', value: alert.type, short: true },
                    { title: 'Severity', value: alert.severity, short: true },
                    { title: 'Package', value: alert.package || 'N/A', short: true },
                    { title: 'Time', value: new Date(alert.timestamp).toLocaleString(), short: true }
                ],
                text: alert.description,
                footer: 'URGENT - IMMEDIATE ACTION REQUIRED',
                ts: Math.floor(Date.now() / 1000)
            }]
        };
        
        try {
            await fetch(this.webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(criticalMessage)
            });
        } catch (error) {
            console.error('Failed to send critical Slack notification:', error);
        }
    }
}

// Канал уведомлений для email
class EmailNotificationChannel {
    constructor(config) {
        this.smtpConfig = config.smtp;
        this.recipients = config.recipients;
        this.sender = config.sender;
    }
    
    async send(alert) {
        if (!this.smtpConfig) {
            console.warn('SMTP configuration not provided');
            return;
        }
        
        const nodemailer = require('nodemailer');
        const transporter = nodemailer.createTransporter(this.smtpConfig);
        
        const mailOptions = {
            from: this.sender,
            to: this.recipients,
            subject: `[SECURITY] ${alert.severity} - ${alert.title}`,
            html: this.generateAlertEmailHTML(alert)
        };
        
        try {
            await transporter.sendMail(mailOptions);
        } catch (error) {
            console.error('Failed to send email notification:', error);
        }
    }
    
    generateAlertEmailHTML(alert) {
        return `
            <html>
            <body style="font-family: Arial, sans-serif;">
                <div style="border-left: 5px solid ${this.getEmailColor(alert.severity)}; padding: 20px; background: #f9f9f9;">
                    <h2 style="color: ${this.getEmailColor(alert.severity)};">${alert.title}</h2>
                    <p><strong>Type:</strong> ${alert.type}</p>
                    <p><strong>Severity:</strong> ${alert.severity}</p>
                    <p><strong>Package:</strong> ${alert.package || 'N/A'}</p>
                    <p><strong>Time:</strong> ${new Date(alert.timestamp).toLocaleString()}</p>
                    <p><strong>Description:</strong></p>
                    <p>${alert.description}</p>
                </div>
            </body>
            </html>
        `;
    }
    
    getEmailColor(severity) {
        const colors = {
            'CRITICAL': '#d32f2f',
            'HIGH': '#f57c00',
            'MEDIUM': '#fbc02d',
            'LOW': '#689f38',
            'INFO': '#1976d2'
        };
        return colors[severity] || '#757575';
    }
}

// Использование системы уведомлений
const notificationManager = new DependencyNotificationManager({
    channels: ['console', 'slack', 'email'],
    slack: {
        webhookUrl: process.env.SLACK_SECURITY_WEBHOOK,
        channel: '#security-alerts'
    },
    email: {
        smtp: {
            host: process.env.SMTP_HOST,
            port: process.env.SMTP_PORT,
            auth: {
                user: process.env.SMTP_USER,
                pass: process.env.SMTP_PASS
            }
        },
        recipients: ['security-team@company.com'],
        sender: 'security@company.com'
    },
    severityThresholds: {
        critical: 0,
        high: 3,
        medium: 10
    }
});
```

## Тестирование безопасности зависимостей

### 1. Автоматизированные тесты

```javascript
// Тесты для системы управления зависимостями
describe('Dependency Security Management', () => {
    let securityManager;
    let policyManager;
    
    beforeEach(() => {
        securityManager = new DependencySecurityManager({
            monitoring: { checkInterval: 1000 },
            scanning: { enabled: false }, // отключаем для тестов
            policy: {
                allowedLicenses: ['MIT', 'Apache-2.0'],
                forbiddenLicenses: ['GPL-2.0', 'AGPL-3.0']
            }
        });
        
        policyManager = new SecurityPolicyManager();
    });
    
    test('should validate secure package correctly', async () => {
        const packageInfo = {
            name: 'secure-package',
            version: '1.0.0'
        };
        
        const result = await policyManager.validatePackage(packageInfo);
        
        expect(result.overallCompliance).toBe(true);
        expect(result.version.compliant).toBe(true);
        expect(result.license.compliant).toBe(true);
    });
    
    test('should reject package with forbidden license', async () => {
        const packageInfo = {
            name: 'forbidden-license-package',
            version: '1.0.0'
        };
        
        // Mock для получения запрещенной лицензии
        policyManager.getPackageLicense = jest.fn().mockResolvedValue('GPL-2.0');
        
        const result = await policyManager.validatePackage(packageInfo);
        
        expect(result.overallCompliance).toBe(false);
        expect(result.license.compliant).toBe(false);
        expect(result.license.issues).toContainEqual(
            expect.objectContaining({ type: 'FORBIDDEN_LICENSE' })
        );
    });
    
    test('should detect major version updates', async () => {
        const packageInfo = {
            name: 'test-package',
            version: '2.0.0'
        };
        
        // Mock для получения текущей версии
        policyManager.getCurrentInstalledVersion = jest.fn().mockResolvedValue('1.5.0');
        
        const result = await policyManager.validateVersionPolicy(packageInfo);
        
        expect(result.compliant).toBe(false);
        expect(result.issues).toContainEqual(
            expect.objectContaining({ type: 'MAJOR_UPDATE_DENIED' })
        );
    });
    
    test('should validate package source correctly', async () => {
        const packageInfo = {
            name: 'trusted-package',
            version: '1.0.0',
            specification: 'trusted-package@^1.0.0'
        };
        
        // Mock для получения доверенного источника
        policyManager.getPackageSource = jest.fn().mockResolvedValue('https://registry.npmjs.org/');
        
        const result = await policyManager.validateSourcePolicy(packageInfo);
        
        expect(result.compliant).toBe(true);
    });
    
    test('should reject package from untrusted source', async () => {
        const packageInfo = {
            name: 'untrusted-package',
            version: '1.0.0',
            specification: 'git+https://github.com/untrusted/repo.git'
        };
        
        // Mock для получения недоверенного источника
        policyManager.getPackageSource = jest.fn().mockResolvedValue('https://evil-registry.com/');
        
        const result = await policyManager.validateSourcePolicy(packageInfo);
        
        expect(result.compliant).toBe(false);
        expect(result.issues).toContainEqual(
            expect.objectContaining({ type: 'UNTRUSTED_SOURCE' })
        );
    });
    
    test('should handle policy exceptions', async () => {
        const packageInfo = {
            name: 'exception-package',
            version: '1.0.0'
        };
        
        // Добавление исключения
        policyManager.addException('exception-package', 'GPL-2.0', 'Business necessity');
        
        const result = await policyManager.validatePackage(packageInfo);
        
        expect(result.overallCompliance).toBe(true);
    });
    
    test('should generate policy compliance report', async () => {
        const report = await policyManager.getPolicyComplianceReport();
        
        expect(report).toHaveProperty('timestamp');
        expect(report).toHaveProperty('totalDependencies');
        expect(report).toHaveProperty('compliantDependencies');
        expect(report).toHaveProperty('nonCompliantDependencies');
        expect(report).toHaveProperty('complianceRate');
        expect(report).toHaveProperty('detailedResults');
        expect(report).toHaveProperty('summary');
    });
    
    test('should calculate compliance statistics correctly', async () => {
        const mockResults = {
            'secure-package@1.0.0': { overallCompliance: true },
            'vulnerable-package@1.0.0': { overallCompliance: false }
        };
        
        const summary = policyManager.generateComplianceSummary(mockResults);
        
        expect(summary.byPolicy.version.compliant).toBeGreaterThanOrEqual(0);
        expect(summary.bySeverity.CRITICAL).toBeGreaterThanOrEqual(0);
        expect(summary.topIssues).toBeInstanceOf(Array);
    });
    
    test('should handle package approval workflow', async () => {
        const packageInfo = {
            name: 'approval-needed-package',
            version: '1.0.0'
        };
        
        // Mock для получения лицензии, требующей одобрения
        policyManager.getPackageLicense = jest.fn().mockResolvedValue('MPL-2.0');
        
        const result = await policyManager.validateLicensePolicy(packageInfo);
        
        expect(result.compliant).toBe(false);
        expect(result.issues).toContainEqual(
            expect.objectContaining({ type: 'LICENSE_REQUIRES_APPROVAL' })
        );
    });
    
    test('should process approval request', async () => {
        const approvalRequest = await policyManager.requestPackageApproval(
            { name: 'test-package', version: '1.0.0' },
            'Business requirement'
        );
        
        expect(approvalRequest).toHaveProperty('id');
        expect(approvalRequest).toHaveProperty('package', 'test-package');
        expect(approvalRequest).toHaveProperty('status', 'PENDING');
    });
    
    test('should approve package', async () => {
        const request = await policyManager.requestPackageApproval(
            { name: 'test-package', version: '1.0.0' },
            'Business requirement'
        );
        
        const approvedRequest = await policyManager.approvePackage(request.id, 'admin');
        
        expect(approvedRequest.status).toBe('APPROVED');
        expect(approvedRequest.approvedBy).toBe('admin');
    });
    
    test('should maintain update history', async () => {
        securityManager.logUpdate(
            { name: 'test-package', current: '1.0.0', wanted: '1.1.0', updateType: 'minor' },
            true
        );
        
        expect(securityManager.updateHistory.length).toBe(1);
        expect(securityManager.updateHistory[0].success).toBe(true);
    });
    
    test('should calculate update statistics', async () => {
        // Добавление нескольких записей об обновлениях
        securityManager.logUpdate(
            { name: 'package1', current: '1.0.0', wanted: '1.1.0', updateType: 'minor' },
            true
        );
        securityManager.logUpdate(
            { name: 'package2', current: '1.0.0', wanted: '2.0.0', updateType: 'major' },
            false,
            'Failed to update'
        );
        
        const stats = await securityManager.getUpdateStatistics();
        
        expect(stats.totalUpdates).toBe(2);
        expect(stats.successfulUpdates).toBe(1);
        expect(stats.failedUpdates).toBe(1);
        expect(stats.successRate).toBe(50);
    });
    
    test('should generate comprehensive update report', async () => {
        const report = await securityManager.generateUpdateReport();
        
        expect(report).toHaveProperty('timestamp');
        expect(report).toHaveProperty('statistics');
        expect(report).toHaveProperty('recentUpdates');
        expect(report).toHaveProperty('recommendations');
    });
    
    test('should handle notification system', async () => {
        const alert = {
            type: 'TEST_ALERT',
            severity: 'INFO',
            title: 'Test Alert',
            description: 'This is a test alert',
            package: 'test-package',
            timestamp: new Date().toISOString()
        };
        
        await notificationManager.sendAlert(alert);
        
        // Проверка, что уведомление было отправлено
        expect(notificationManager.lastNotifications.size).toBeGreaterThan(0);
    });
    
    test('should send vulnerability alerts', async () => {
        const vulnerability = {
            package: 'vulnerable-package',
            version: '1.0.0',
            severity: 'CRITICAL',
            title: 'Remote Code Execution',
            description: 'Critical RCE vulnerability detected',
            cve: 'CVE-2023-1234',
            cvssScore: 9.8
        };
        
        await notificationManager.sendVulnerabilityAlert(vulnerability);
        
        // Проверка отправки уведомления
        expect(notificationManager.lastNotifications.size).toBeGreaterThan(0);
    });
    
    test('should respect notification cooldown', async () => {
        const alert = {
            type: 'TEST_ALERT',
            severity: 'INFO',
            title: 'Test Alert',
            description: 'This is a test alert',
            timestamp: new Date().toISOString()
        };
        
        // Отправка двух уведомлений подряд
        await notificationManager.sendAlert(alert);
        await notificationManager.sendAlert(alert);
        
        // Проверка, что второе уведомление было проигнорировано из-за кулдауна
        // (в тестах кулдаун можно уменьшить для проверки)
    });
});

// Интеграционные тесты
describe('Integration: Dependency Security Pipeline', () => {
    test('should run complete security pipeline', async () => {
        const pipeline = new SecurityPipeline({
            scanning: { enabled: false }, // отключаем для тестов
            policy: { allowedLicenses: ['MIT'], forbiddenLicenses: ['GPL-2.0'] }
        });
        
        const results = await pipeline.runCompleteSecurityCheck();
        
        expect(results).toHaveProperty('validation');
        expect(results).toHaveProperty('vulnerabilityCheck');
        expect(results).toHaveProperty('licenseCheck');
        expect(results).toHaveProperty('policyEnforcement');
        expect(results).toHaveProperty('finalReport');
    });
    
    test('should handle security incidents properly', async () => {
        const incidentHandler = new SecurityIncidentHandler();
        
        const incident = {
            type: 'SECURITY_VULNERABILITY',
            package: 'compromised-package',
            severity: 'CRITICAL',
            timestamp: new Date().toISOString()
        };
        
        const response = await incidentHandler.handleIncident(incident);
        
        expect(response).toHaveProperty('status');
        expect(response).toHaveProperty('actionsTaken');
        expect(response.status).toBe('RESOLVED');
    });
    
    test('should generate comprehensive security report', async () => {
        const reporter = new SecurityReporter();
        
        const report = await reporter.generateComprehensiveReport();
        
        expect(report).toHaveProperty('metadata');
        expect(report).toHaveProperty('findings');
        expect(report).toHaveProperty('recommendations');
        expect(report).toHaveProperty('compliance');
        expect(report.metadata).toHaveProperty('timestamp');
        expect(report.findings).toHaveProperty('total');
        expect(report.recommendations).toHaveProperty('length');
    });
});

// Тестирование производительности
describe('Performance: Dependency Security Operations', () => {
    test('should validate large number of packages efficiently', async () => {
        const policyManager = new SecurityPolicyManager();
        
        // Симуляция большого количества пакетов
        const largePackageList = Array.from({ length: 100 }, (_, i) => ({
            name: `package-${i}`,
            version: '1.0.0'
        }));
        
        const startTime = Date.now();
        
        const validationPromises = largePackageList.map(pkg => 
            policyManager.validatePackage(pkg)
        );
        
        const results = await Promise.all(validationPromises);
        
        const executionTime = Date.now() - startTime;
        
        // Проверка, что время выполнения разумное
        expect(executionTime).toBeLessThan(30000); // 30 секунд для 100 пакетов
        
        // Проверка, что все результаты валидны
        expect(results.length).toBe(100);
        expect(results.every(r => r !== undefined)).toBe(true);
    });
    
    test('should handle concurrent security checks', async () => {
        const securityChecker = new SecurityChecker();
        
        const concurrentChecks = Array.from({ length: 10 }, (_, i) => 
            securityChecker.checkPackage(`test-package-${i}`, '1.0.0')
        );
        
        const results = await Promise.allSettled(concurrentChecks);
        
        const successful = results.filter(r => r.status === 'fulfilled').length;
        const failed = results.filter(r => r.status === 'rejected').length;
        
        expect(successful + failed).toBe(10);
        expect(successful).toBeGreaterThanOrEqual(5); // хотя бы половина должна пройти
    });
    
    test('should manage memory efficiently during bulk operations', async () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        // Выполнение массовой проверки
        const largeCheck = new LargeScaleSecurityChecker();
        await largeCheck.performBulkCheck(500); // 500 пакетов
        
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryGrowth = finalMemory - initialMemory;
        
        // Рост памяти не должен быть чрезмерным
        expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024); // 50MB
    });
});

// Вспомогательные функции для тестов
function createMockPackageInfo(name, version, license = 'MIT') {
    return {
        name,
        version,
        license,
        downloads: 10000,
        age: 30,
        maintainers: ['maintainer@example.com'],
        repository: { url: `https://github.com/example/${name}` }
    };
}

function simulateVulnerablePackage() {
    return {
        name: 'vulnerable-package',
        version: '1.0.0',
        vulnerabilities: [
            {
                id: 'CVE-2023-1234',
                severity: 'CRITICAL',
                title: 'Remote Code Execution',
                description: 'Arbitrary code execution vulnerability'
            }
        ]
    };
}

function simulateForbiddenLicense() {
    return {
        name: 'forbidden-license-package',
        version: '1.0.0',
        license: 'AGPL-3.0'
    };
}
```

## Лучшие практики

### 1. Политики и процедуры

```javascript
// Политики безопасности зависимостей
class SecurityPolicyAndProcedures {
    constructor() {
        this.policies = {
            // Политика выбора зависимостей
            selectionPolicy: {
                criteria: [
                    'License compatibility',
                    'Security audit history',
                    'Active maintenance',
                    'Community support',
                    'Download count threshold',
                    'Code quality metrics'
                ],
                approvalProcess: 'mandatory_review_for_high_risk_packages',
                exceptions: 'business_case_required'
            },
            
            // Политика обновлений
            updatePolicy: {
                frequency: 'weekly_security_patches',
                testingRequirement: 'full_regression_suite',
                rollbackProcedure: 'automatic_on_test_failure',
                communication: 'team_notification_required'
            },
            
            // Политика мониторинга
            monitoringPolicy: {
                coverage: 'all_production_dependencies',
                frequency: 'daily',
                escalation: 'immediate_for_critical_vulns',
                reporting: 'weekly_security_reviews'
            },
            
            // Политика реагирования
            responsePolicy: {
                critical: { timeframe: 'within_4_hours', action: 'immediate_patch' },
                high: { timeframe: 'within_24_hours', action: 'scheduled_patch' },
                medium: { timeframe: 'within_7_days', action: 'planned_fix' },
                low: { timeframe: 'within_30_days', action: 'consider_fix' }
            }
        };
        
        this.procedures = {
            // Процедура оценки новых зависимостей
            newDependencyAssessment: [
                'License compliance check',
                'Security vulnerability scan',
                'Code quality review',
                'Maintenance activity check',
                'Community reputation assessment',
                'Dependency tree analysis',
                'Business justification review',
                'Security team approval'
            ],
            
            // Процедура обновления зависимостей
            dependencyUpdate: [
                'Backup current state',
                'Run security scan on new version',
                'Execute regression tests',
                'Deploy to staging',
                'Monitor for issues',
                'Deploy to production',
                'Monitor production'
            ],
            
            // Процедура реагирования на уязвимости
            vulnerabilityResponse: [
                'Assess vulnerability impact',
                'Determine affected systems',
                'Plan remediation approach',
                'Test fix in isolated environment',
                'Deploy to production',
                'Verify fix effectiveness',
                'Document incident'
            ]
        };
    }
    
    async validateNewDependency(packageInfo) {
        const validation = {
            policyChecks: {},
            compliance: true,
            recommendations: [],
            approvalRequired: false
        };
        
        // Проверка лицензии
        validation.policyChecks.license = await this.checkLicensePolicy(packageInfo);
        if (!validation.policyChecks.license.compliant) {
            validation.compliance = false;
            validation.approvalRequired = true;
        }
        
        // Проверка безопасности
        validation.policyChecks.security = await this.checkSecurityPolicy(packageInfo);
        if (!validation.policyChecks.security.compliant) {
            validation.compliance = false;
            validation.approvalRequired = true;
        }
        
        // Проверка качества
        validation.policyChecks.quality = await this.checkQualityPolicy(packageInfo);
        if (!validation.policyChecks.quality.compliant) {
            validation.compliance = false;
            validation.recommendations.push({
                category: 'QUALITY',
                message: 'Package quality does not meet standards',
                severity: 'MEDIUM'
            });
        }
        
        // Проверка поддержки
        validation.policyChecks.maintenance = await this.checkMaintenancePolicy(packageInfo);
        if (!validation.policyChecks.maintenance.compliant) {
            validation.compliance = false;
            validation.recommendations.push({
                category: 'MAINTENANCE',
                message: 'Package is not actively maintained',
                severity: 'LOW'
            });
        }
        
        return validation;
    }
    
    async checkLicensePolicy(packageInfo) {
        const license = await this.getPackageLicense(packageInfo.name);
        
        if (this.policies.forbiddenLicenses.includes(license)) {
            return {
                compliant: false,
                reason: `License ${license} is forbidden`,
                severity: 'CRITICAL'
            };
        }
        
        if (!this.policies.allowedLicenses.includes(license)) {
            return {
                compliant: false,
                reason: `License ${license} is not in allowed list`,
                severity: 'HIGH'
            };
        }
        
        return { compliant: true, severity: 'INFO' };
    }
    
    async checkSecurityPolicy(packageInfo) {
        const vulnerabilities = await this.checkPackageVulnerabilities(packageInfo.name, packageInfo.version);
        
        if (vulnerabilities.some(v => v.severity === 'CRITICAL')) {
            return {
                compliant: false,
                reason: 'Package has critical vulnerabilities',
                severity: 'CRITICAL',
                vulnerabilities: vulnerabilities.filter(v => v.severity === 'CRITICAL')
            };
        }
        
        if (vulnerabilities.length > 0) {
            return {
                compliant: false,
                reason: `Package has ${vulnerabilities.length} vulnerabilities`,
                severity: 'MEDIUM',
                vulnerabilities: vulnerabilities
            };
        }
        
        return { compliant: true, severity: 'INFO' };
    }
    
    async checkQualityPolicy(packageInfo) {
        const metadata = await this.getPackageMetadata(packageInfo.name);
        
        const qualityChecks = {
            downloadCount: metadata.downloads >= this.policies.minDownloadCount,
            age: metadata.age >= this.policies.minAgeDays,
            hasTests: metadata.hasTests,
            hasDocumentation: metadata.hasDocumentation,
            hasSecurityPolicy: metadata.hasSecurityPolicy
        };
        
        const compliant = Object.values(qualityChecks).every(check => check);
        
        if (!compliant) {
            const failedChecks = Object.entries(qualityChecks)
                .filter(([, passed]) => !passed)
                .map(([check]) => check);
                
            return {
                compliant: false,
                reason: `Quality checks failed: ${failedChecks.join(', ')}`,
                severity: 'MEDIUM',
                failedChecks
            };
        }
        
        return { compliant: true, severity: 'INFO' };
    }
    
    async checkMaintenancePolicy(packageInfo) {
        const metadata = await this.getPackageMetadata(packageInfo.name);
        
        const maintenanceChecks = {
            recentUpdates: metadata.lastUpdateWithinDays <= 90,
            activeIssues: metadata.openIssues < 50,
            contributorActivity: metadata.contributorActivity > 0
        };
        
        const compliant = Object.values(maintenanceChecks).some(check => check);
        
        return {
            compliant,
            reason: compliant ? 'Package is actively maintained' : 'Package shows signs of abandonment',
            severity: compliant ? 'INFO' : 'LOW'
        };
    }
    
    async getPackageLicense(name) {
        // В реальности использовать npm API
        return 'MIT'; // заглушка
    }
    
    async checkPackageVulnerabilities(name, version) {
        // В реальности использовать npm audit или другие инструменты
        return []; // заглушка
    }
    
    async getPackageMetadata(name) {
        // В реальности использовать npm API
        return {
            downloads: 100000,
            age: 365,
            hasTests: true,
            hasDocumentation: true,
            hasSecurityPolicy: true,
            lastUpdateWithinDays: 30,
            openIssues: 5,
            contributorActivity: 10
        }; // заглушка
    }
    
    async createApprovalWorkflow(validationResult, packageInfo) {
        const workflow = {
            id: this.generateWorkflowId(),
            package: packageInfo,
            validation: validationResult,
            status: 'PENDING_REVIEW',
            reviewers: this.getRequiredReviewers(validationResult),
            timeline: {
                submitted: new Date().toISOString(),
                dueDate: this.calculateDueDate(validationResult),
                completed: null
            },
            decisions: [],
            finalDecision: null
        };
        
        await this.sendForReview(workflow);
        
        return workflow;
    }
    
    getRequiredReviewers(validationResult) {
        const reviewers = ['security-team'];
        
        if (validationResult.policyChecks.license?.severity === 'CRITICAL') {
            reviewers.push('legal-team');
        }
        
        if (validationResult.policyChecks.security?.severity === 'CRITICAL') {
            reviewers.push('architect-team');
        }
        
        if (validationResult.approvalRequired) {
            reviewers.push('engineering-leads');
        }
        
        return [...new Set(reviewers)]; // уникальные значения
    }
    
    calculateDueDate(validationResult) {
        const maxSeverity = this.getMaxSeverity(validationResult);
        
        const daysToAdd = {
            'CRITICAL': 1,
            'HIGH': 3,
            'MEDIUM': 7,
            'LOW': 14
        };
        
        const dueDate = new Date();
        dueDate.setDate(dueDate.getDate() + (daysToAdd[maxSeverity] || 7));
        
        return dueDate.toISOString();
    }
    
    getMaxSeverity(validationResult) {
        const severities = Object.values(validationResult.policyChecks)
            .filter(check => check.severity)
            .map(check => check.severity);
        
        const severityOrder = ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
        return severities.sort((a, b) => severityOrder.indexOf(b) - severityOrder.indexOf(a))[0] || 'INFO';
    }
    
    generateWorkflowId() {
        return `approval-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async sendForReview(workflow) {
        // Отправка запроса на рассмотрение
        console.log(`Sending approval request for ${workflow.package.name} to reviewers:`, workflow.reviewers);
        
        // В реальности интеграция с системами управления задачами
        if (process.env.APPROVAL_WEBHOOK) {
            try {
                await fetch(process.env.APPROVAL_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'DEPENDENCY_APPROVAL_REQUEST',
                        workflow: workflow
                    })
                });
            } catch (error) {
                console.error('Failed to send approval request:', error);
            }
        }
    }
    
    async generatePolicyComplianceReport() {
        const dependencies = await this.getProjectDependencies();
        const results = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            results[`${name}@${version}`] = await this.validateNewDependency({ name, version });
        }
        
        const compliantCount = Object.values(results).filter(r => r.compliance).length;
        const total = Object.keys(results).length;
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: total,
            compliantDependencies: compliantCount,
            nonCompliantDependencies: total - compliantCount,
            complianceRate: total > 0 ? (compliantCount / total) * 100 : 0,
            detailedResults: results,
            summary: this.generateComplianceSummary(results),
            recommendations: this.generatePolicyRecommendations(results)
        };
    }
    
    generateComplianceSummary(results) {
        const summary = {
            byPolicy: {
                license: { compliant: 0, nonCompliant: 0 },
                security: { compliant: 0, nonCompliant: 0 },
                quality: { compliant: 0, nonCompliant: 0 },
                maintenance: { compliant: 0, nonCompliant: 0 }
            },
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 },
            topIssues: [],
            approvalQueue: 0
        };
        
        for (const result of Object.values(results)) {
            // Подсчет по политикам
            if (result.policyChecks.license.compliant) summary.byPolicy.license.compliant++;
            else summary.byPolicy.license.nonCompliant++;
            
            if (result.policyChecks.security.compliant) summary.byPolicy.security.compliant++;
            else summary.byPolicy.security.nonCompliant++;
            
            if (result.policyChecks.quality.compliant) summary.byPolicy.quality.compliant++;
            else summary.byPolicy.quality.nonCompliant++;
            
            if (result.policyChecks.maintenance.compliant) summary.byPolicy.maintenance.compliant++;
            else summary.byPolicy.maintenance.nonCompliant++;
            
            // Подсчет по тяжести
            for (const [policyName, policyCheck] of Object.entries(result.policyChecks)) {
                summary.bySeverity[policyCheck.severity] = 
                    (summary.bySeverity[policyCheck.severity] || 0) + 1;
            }
            
            // Подсчет требующих одобрения
            if (result.approvalRequired) {
                summary.approvalQueue++;
            }
        }
        
        // Топ проблем
        const allIssues = Object.values(results).flatMap(result => 
            Object.values(result.policyChecks).filter(check => !check.compliant)
        );
        
        const issueCounts = {};
        allIssues.forEach(issue => {
            issueCounts[issue.reason] = (issueCounts[issue.reason] || 0) + 1;
        });
        
        summary.topIssues = Object.entries(issueCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([reason, count]) => ({ reason, count }));
        
        return summary;
    }
    
    generatePolicyRecommendations(results) {
        const recommendations = [];
        
        const nonCompliant = Object.values(results).filter(r => !r.compliance);
        if (nonCompliant.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'COMPLIANCE',
                title: 'Address Non-Compliant Dependencies',
                description: `Found ${nonCompliant.length} non-compliant dependencies`,
                action: 'Review and replace non-compliant packages or obtain approvals'
            });
        }
        
        const criticalVulns = nonCompliant.filter(r => 
            r.policyChecks.security?.vulnerabilities?.some(v => v.severity === 'CRITICAL')
        );
        if (criticalVulns.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'SECURITY',
                title: 'Remove Critical Vulnerability Dependencies',
                description: `Found ${criticalVulns.length} packages with critical vulnerabilities`,
                action: 'Remove or update packages with critical vulnerabilities immediately'
            });
        }
        
        const licenseIssues = nonCompliant.filter(r => 
            r.policyChecks.license?.severity === 'CRITICAL'
        );
        if (licenseIssues.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'LICENSE',
                title: 'Address License Compliance Issues',
                description: `Found ${licenseIssues.length} packages with forbidden licenses`,
                action: 'Replace packages with compliant alternatives'
            });
        }
        
        return recommendations;
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        return {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
    }
}

// Использование системы политик
const policySystem = new SecurityPolicyAndProcedures();

async function runPolicyComplianceCheck() {
    const report = await policySystem.generatePolicyComplianceReport();
    console.log('Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (report.complianceRate < 95) {
        console.error('Policy compliance below threshold');
        process.exit(1);
    }
    
    return report;
}
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Инструменты-аудита-безопасности]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]