---
aliases: ["Инструменты аудита безопасности", "Security Audit Tools", "Dependency Audit"]
tags: ["#security", "#dependency-security", "#audit-tools", "#vulnerability-scanning"]
---

# Инструменты аудита безопасности

## Введение

Инструменты аудита безопасности зависимостей - это специализированные решения, предназначенные для автоматического обнаружения уязвимостей, проблем с лицензиями и других проблем безопасности в используемых внешних библиотеках и пакетах. Эти инструменты играют ключевую роль в обеспечении безопасности современных приложений, где значительная часть кода представлена внешними зависимостями.

## Классификация инструментов аудита

### 1. Инструменты статического анализа зависимостей (SDAST)

```javascript
// Класс для работы с инструментами статического анализа зависимостей
class SDASTScanner {
    constructor(config) {
        this.config = {
            tools: config.tools || ['npm-audit', 'snyk', 'osv-scanner'],
            severityThreshold: config.severityThreshold || 'moderate',
            failOnCritical: config.failOnCritical !== false,
            includeDevDependencies: config.includeDevDependencies || false,
            ...config
        };
        
        this.scanners = this.initializeScanners();
        this.vulnerabilityDatabase = new VulnerabilityDatabase();
    }
    
    initializeScanners() {
        const scanners = new Map();
        
        if (this.config.tools.includes('npm-audit')) {
            scanners.set('npm-audit', new NPMAuditScanner(this.config.npmAudit));
        }
        
        if (this.config.tools.includes('snyk')) {
            scanners.set('snyk', new SnykScanner(this.config.snyk));
        }
        
        if (this.config.tools.includes('osv-scanner')) {
            scanners.set('osv-scanner', new OSVScanner(this.config.osv));
        }
        
        if (this.config.tools.includes('oss-index')) {
            scanners.set('oss-index', new OSSIndexScanner(this.config.ossIndex));
        }
        
        return scanners;
    }
    
    async runAudit() {
        const results = {
            metadata: {
                timestamp: new Date().toISOString(),
                toolsUsed: Array.from(this.scanners.keys()),
                dependenciesScanned: await this.countDependencies(),
                config: this.config
            },
            findings: [],
            summary: {
                totalVulnerabilities: 0,
                bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
                byTool: {},
                compliant: true
            },
            recommendations: []
        };
        
        // Запуск всех сканеров параллельно
        const scannerResults = await Promise.allSettled(
            Array.from(this.scanners.entries()).map(async ([toolName, scanner]) => {
                try {
                    const result = await scanner.scan();
                    return { tool: toolName, result };
                } catch (error) {
                    return { tool: toolName, error: error.message };
                }
            })
        );
        
        // Обработка результатов
        for (const scannerResult of scannerResults) {
            if (scannerResult.status === 'fulfilled') {
                const { tool, result } = scannerResult.value;
                
                if (result && result.vulnerabilities) {
                    results.findings.push(...result.vulnerabilities.map(vuln => ({
                        ...vuln,
                        detectedBy: tool
                    })));
                    
                    // Обновление статистики по инструменту
                    results.summary.byTool[tool] = result.vulnerabilities.length;
                    
                    // Обновление статистики по тяжести
                    for (const vuln of result.vulnerabilities) {
                        const severity = this.normalizeSeverity(vuln.severity);
                        results.summary.bySeverity[severity] = 
                            (results.summary.bySeverity[severity] || 0) + 1;
                        results.summary.totalVulnerabilities++;
                    }
                }
            } else {
                console.error(`Scanner failed:`, scannerResult.reason);
            }
        }
        
        // Оценка соответствия
        results.summary.compliant = this.isCompliant(results.summary);
        
        // Генерация рекомендаций
        results.recommendations = await this.generateRecommendations(results);
        
        return results;
    }
    
    normalizeSeverity(severity) {
        const mapping = {
            'critical': 'CRITICAL',
            'high': 'HIGH', 
            'moderate': 'MEDIUM',
            'medium': 'MEDIUM',
            'low': 'LOW',
            'info': 'INFO'
        };
        
        return mapping[severity.toLowerCase()] || severity.toUpperCase();
    }
    
    async countDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        const deps = {
            prod: Object.keys(packageJson.dependencies || {}),
            dev: Object.keys(packageJson.devDependencies || {})
        };
        
        return {
            total: deps.prod.length + (this.config.includeDevDependencies ? deps.dev.length : 0),
            production: deps.prod.length,
            development: this.config.includeDevDependencies ? deps.dev.length : 0
        };
    }
    
    isCompliant(summary) {
        if (this.config.failOnCritical && summary.bySeverity.CRITICAL > 0) {
            return false;
        }
        
        // Проверка на основе порога тяжести
        const thresholdSeverity = this.config.severityThreshold.toUpperCase();
        const severityOrder = ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
        const thresholdIndex = severityOrder.indexOf(thresholdSeverity);
        
        for (let i = thresholdIndex; i < severityOrder.length; i++) {
            const severity = severityOrder[i];
            if (summary.bySeverity[severity] > 0) {
                return false;
            }
        }
        
        return true;
    }
    
    async generateRecommendations(results) {
        const recommendations = [];
        
        // Рекомендации по критическим уязвимостям
        const criticalVulns = results.findings.filter(v => 
            this.normalizeSeverity(v.severity) === 'CRITICAL'
        );
        
        if (criticalVulns.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'VULNERABILITIES',
                title: 'Address Critical Vulnerabilities Immediately',
                description: `Found ${criticalVulns.length} critical vulnerabilities`,
                action: 'Update affected packages to patched versions immediately',
                affectedPackages: [...new Set(criticalVulns.map(v => v.packageName))],
                estimatedEffort: 'HIGH'
            });
        }
        
        // Рекомендации по высоким уязвимостям
        const highVulns = results.findings.filter(v => 
            this.normalizeSeverity(v.severity) === 'HIGH'
        );
        
        if (highVulns.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'VULNERABILITIES',
                title: 'Fix High Severity Vulnerabilities',
                description: `Found ${highVulns.length} high severity vulnerabilities`,
                action: 'Plan updates for affected packages',
                affectedPackages: [...new Set(highVulns.map(v => v.packageName))],
                estimatedEffort: 'MEDIUM'
            });
        }
        
        // Рекомендации по лицензиям
        const licenseIssues = await this.checkLicenseCompliance();
        if (licenseIssues.nonCompliant > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'LICENSE',
                title: 'Address License Compliance Issues',
                description: `Found ${licenseIssues.nonCompliant} non-compliant packages`,
                action: 'Review and replace non-compliant packages',
                affectedPackages: licenseIssues.nonCompliantPackages,
                estimatedEffort: 'MEDIUM'
            });
        }
        
        // Рекомендации по устаревшим пакетам
        const outdatedPackages = await this.checkForOutdatedPackages();
        if (outdatedPackages.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'MAINTENANCE',
                title: 'Update Outdated Packages',
                description: `Found ${outdatedPackages.length} outdated packages`,
                action: 'Update packages to latest stable versions',
                affectedPackages: outdatedPackages,
                estimatedEffort: 'LOW'
            });
        }
        
        return recommendations;
    }
    
    async checkLicenseCompliance() {
        // Проверка соответствия лицензиям
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        const allDeps = {
            ...packageJson.dependencies,
            ...(this.config.includeDevDependencies ? packageJson.devDependencies : {})
        };
        
        let nonCompliant = 0;
        const nonCompliantPackages = [];
        
        for (const [name, version] of Object.entries(allDeps)) {
            const packageInfo = await this.getPackageInfo(name);
            const license = this.extractLicense(packageInfo);
            
            if (!this.isLicenseCompliant(license)) {
                nonCompliant++;
                nonCompliantPackages.push({ name, version, license });
            }
        }
        
        return { nonCompliant, nonCompliantPackages };
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo) return 'UNKNOWN';
        
        if (typeof packageInfo.license === 'string') {
            return packageInfo.license;
        }
        
        if (typeof packageInfo.license === 'object' && packageInfo.license.type) {
            return packageInfo.license.type;
        }
        
        if (Array.isArray(packageInfo.licenses) && packageInfo.licenses[0]) {
            return typeof packageInfo.licenses[0] === 'string' ? 
                   packageInfo.licenses[0] : 
                   packageInfo.licenses[0].type;
        }
        
        return 'UNKNOWN';
    }
    
    isLicenseCompliant(license) {
        const compliantLicenses = [
            'MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 'ISC', 'CC0-1.0'
        ];
        
        const nonCompliantLicenses = [
            'GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'LGPL-2.1', 'EUPL-1.2'
        ];
        
        return compliantLicenses.includes(license) && 
               !nonCompliantLicenses.includes(license);
    }
    
    async checkForOutdatedPackages() {
        const { execSync } = require('child_process');
        
        try {
            const outdatedResult = execSync('npm outdated --json', { encoding: 'utf8' });
            const outdated = JSON.parse(outdatedResult);
            
            return Object.entries(outdated).map(([name, info]) => ({
                name,
                current: info.current,
                wanted: info.wanted,
                latest: info.latest
            }));
        } catch (error) {
            if (error.stdout) {
                const outdated = JSON.parse(error.stdout);
                return Object.entries(outdated).map(([name, info]) => ({
                    name,
                    current: info.current,
                    wanted: info.wanted,
                    latest: info.latest
                }));
            }
            return [];
        }
    }
    
    async getPackageInfo(name) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${name} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            return null;
        }
    }
    
    async generateConsolidatedReport(results) {
        const report = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            metadata: results.metadata,
            summary: results.summary,
            detailedFindings: this.consolidateFindings(results.findings),
            recommendations: results.recommendations,
            compliance: await this.checkComplianceStatus(results),
            trends: await this.getVulnerabilityTrends()
        };
        
        return report;
    }
    
    consolidateFindings(findings) {
        // Объединение находок из разных инструментов
        const consolidated = new Map();
        
        for (const finding of findings) {
            const key = `${finding.packageName}-${finding.id}`;
            
            if (!consolidated.has(key)) {
                consolidated.set(key, {
                    id: finding.id,
                    packageName: finding.packageName,
                    severity: finding.severity,
                    title: finding.title,
                    description: finding.description,
                    detectedBy: [finding.detectedBy],
                    sources: [finding],
                    firstDetected: finding.timestamp || new Date().toISOString(),
                    lastDetected: finding.timestamp || new Date().toISOString()
                });
            } else {
                const existing = consolidated.get(key);
                existing.detectedBy.push(finding.detectedBy);
                existing.sources.push(finding);
                existing.lastDetected = finding.timestamp || new Date().toISOString();
            }
        }
        
        return Array.from(consolidated.values());
    }
    
    async checkComplianceStatus(results) {
        return {
            overall: results.summary.compliant,
            byCategory: {
                security: this.calculateSecurityCompliance(results),
                license: await this.calculateLicenseCompliance(),
                version: await this.calculateVersionCompliance()
            },
            score: this.calculateOverallScore(results)
        };
    }
    
    calculateSecurityCompliance(results) {
        const critical = results.summary.bySeverity.CRITICAL || 0;
        const high = results.summary.bySeverity.HIGH || 0;
        
        if (critical > 0) return 'NON_COMPLIANT';
        if (high > 5) return 'PARTIALLY_COMPLIANT';
        if (high > 0) return 'MAINLY_COMPLIANT';
        return 'COMPLIANT';
    }
    
    async calculateLicenseCompliance() {
        const licenseCheck = await this.checkLicenseCompliance();
        const total = await this.countDependencies();
        
        const complianceRate = total.total > 0 ? 
            ((total.total - licenseCheck.nonCompliant) / total.total) * 100 : 100;
            
        if (complianceRate === 100) return 'COMPLIANT';
        if (complianceRate >= 95) return 'MAINLY_COMPLIANT';
        if (complianceRate >= 80) return 'PARTIALLY_COMPLIANT';
        return 'NON_COMPLIANT';
    }
    
    calculateOverallScore(results) {
        const totalVulns = results.summary.totalVulnerabilities;
        const criticalVulns = results.summary.bySeverity.CRITICAL || 0;
        
        // Простой расчет балла (в реальности более сложный)
        let score = 100;
        
        score -= criticalVulns * 25; // 25 баллов за критическую уязвимость
        score -= (results.summary.bySeverity.HIGH || 0) * 15; // 15 баллов за высокую
        score -= (results.summary.bySeverity.MEDIUM || 0) * 5; // 5 баллов за среднюю
        
        return Math.max(0, Math.min(100, score));
    }
    
    async getVulnerabilityTrends() {
        // В реальности использовать исторические данные
        return {
            trend: 'stable', // или increasing/decreasing
            weeklyAvg: 2.5,
            monthlyAvg: 11.2,
            peak: 15
        };
    }
}

// Использование SDAST сканера
const sdastScanner = new SDASTScanner({
    tools: ['npm-audit', 'snyk'],
    severityThreshold: 'high',
    failOnCritical: true,
    includeDevDependencies: true
});

async function runDependencyAudit() {
    const results = await sdastScanner.runAudit();
    const report = await sdastScanner.generateConsolidatedReport(results);
    
    console.log('Dependency Security Audit Results:', JSON.stringify(report, null, 2));
    
    if (!results.summary.compliant) {
        console.error('Dependency audit failed compliance check');
        process.exit(1);
    }
    
    return report;
}
```

### 2. npm audit

```javascript
// Обертка для npm audit
class NPMAuditScanner {
    constructor(config = {}) {
        this.config = {
            registry: config.registry || 'https://registry.npmjs.org/',
            auditLevel: config.auditLevel || 'moderate',
            omit: config.omit || ['dev'],
            ...config
        };
    }
    
    async scan() {
        const { execSync } = require('child_process');
        
        try {
            // Подготовка аргументов для npm audit
            const args = [
                'npm', 'audit',
                '--json',
                `--audit-level=${this.config.auditLevel}`,
                ...(this.config.omit.length > 0 ? [`--omit=${this.config.omit.join(',')}`] : [])
            ];
            
            const command = args.join(' ');
            const result = execSync(command, { encoding: 'utf8' });
            const audit = JSON.parse(result);
            
            return this.processAuditResults(audit);
        } catch (error) {
            // npm audit может завершиться с ошибкой при наличии уязвимостей
            if (error.stdout) {
                try {
                    const audit = JSON.parse(error.stdout);
                    return this.processAuditResults(audit);
                } catch (parseError) {
                    throw new Error(`Failed to parse npm audit output: ${parseError.message}`);
                }
            }
            throw error;
        }
    }
    
    processAuditResults(audit) {
        const vulnerabilities = [];
        
        if (audit.advisories) {
            for (const [id, advisory] of Object.entries(audit.advisories)) {
                vulnerabilities.push({
                    id: id,
                    packageName: advisory.module_name,
                    severity: advisory.severity,
                    title: advisory.title,
                    description: advisory.overview,
                    recommendation: advisory.recommendation,
                    url: advisory.url,
                    cves: advisory.cves,
                    foundBy: advisory.found_by,
                    reportedBy: advisory.reported_by,
                    created: advisory.created,
                    updated: advisory.updated,
                    deleted: advisory.deleted,
                    vulnerableVersions: advisory.vulnerable_versions,
                    patchedVersions: advisory.patched_versions,
                    cvssScore: advisory.cvss?.score,
                    access: advisory.access,
                    severityNumeric: this.severityToNumeric(advisory.severity),
                    exploitability: advisory.exploitability
                });
            }
        }
        
        return {
            vulnerabilities: vulnerabilities,
            metadata: {
                totalVulnerabilities: audit.metadata?.vulnerabilities?.total || 0,
                critical: audit.metadata?.vulnerabilities?.critical || 0,
                high: audit.metadata?.vulnerabilities?.high || 0,
                moderate: audit.metadata?.vulnerabilities?.moderate || 0,
                low: audit.metadata?.vulnerabilities?.low || 0,
                info: audit.metadata?.vulnerabilities?.info || 0,
                dependencies: audit.metadata?.totalDependencies || 0,
                vulnerableDependencies: audit.metadata?.vulnerableDependencies || 0
            },
            advisories: audit.advisories || {}
        };
    }
    
    severityToNumeric(severity) {
        const numericMap = {
            'info': 1,
            'low': 2,
            'moderate': 3,
            'high': 4,
            'critical': 5
        };
        return numericMap[severity] || 0;
    }
    
    async generateNPMReport() {
        const results = await this.scan();
        
        return {
            tool: 'npm audit',
            version: await this.getNPMVersion(),
            results: results,
            summary: this.generateNPMsummary(results),
            recommendations: this.generateNPMRecommendations(results)
        };
    }
    
    async getNPMVersion() {
        const { execSync } = require('child_process');
        try {
            const result = execSync('npm --version', { encoding: 'utf8' });
            return result.trim();
        } catch {
            return 'unknown';
        }
    }
    
    generateNPMsummary(results) {
        return {
            totalVulnerabilities: results.metadata.totalVulnerabilities,
            bySeverity: {
                critical: results.metadata.critical,
                high: results.metadata.high,
                moderate: results.metadata.moderate,
                low: results.metadata.low,
                info: results.metadata.info
            },
            vulnerableDependencies: results.metadata.vulnerableDependencies,
            totalDependencies: results.metadata.dependencies,
            compliance: results.metadata.critical === 0
        };
    }
    
    generateNPMRecommendations(results) {
        const recommendations = [];
        
        if (results.metadata.critical > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Vulnerabilities',
                description: `Found ${results.metadata.critical} critical vulnerabilities`,
                action: 'Run: npm audit fix --force to address critical issues'
            });
        }
        
        if (results.metadata.high > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix High Severity Issues',
                description: `Found ${results.metadata.high} high severity vulnerabilities`,
                action: 'Run: npm audit fix to address high severity issues'
            });
        }
        
        if (results.metadata.moderate > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Address Moderate Issues',
                description: `Found ${results.metadata.moderate} moderate severity vulnerabilities`,
                action: 'Review and update affected packages'
            });
        }
        
        return recommendations;
    }
    
    async fixVulnerabilities(options = {}) {
        const { execSync } = require('child_process');
        
        try {
            const fixCommand = options.forceFix ? 
                'npm audit fix --force' : 
                'npm audit fix';
                
            const result = execSync(fixCommand, { 
                encoding: 'utf8', 
                stdio: 'pipe' 
            });
            
            return {
                success: true,
                output: result,
                fixedVulnerabilities: this.parseFixResults(result)
            };
        } catch (error) {
            return {
                success: false,
                error: error.message,
                output: error.stdout || error.stderr
            };
        }
    }
    
    parseFixResults(output) {
        // Парсинг результата npm audit fix
        const lines = output.split('\n');
        const summaryLine = lines.find(line => line.includes('fixed'));
        
        if (summaryLine) {
            const match = summaryLine.match(/(\d+)\s+packages? fixed/);
            if (match) {
                return parseInt(match[1]);
            }
        }
        
        return 0;
    }
    
    async getDetailedAdvisory(advisoryId) {
        const results = await this.scan();
        return results.advisories[advisoryId] || null;
    }
    
    async exportToSARIF() {
        const results = await this.scan();
        
        const sarifReport = {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'npm audit',
                        version: await this.getNPMVersion(),
                        informationUri: 'https://docs.npmjs.com/cli/v9/commands/npm-audit'
                    }
                },
                results: results.vulnerabilities.map(vuln => ({
                    ruleId: vuln.id,
                    level: this.severityToSARIFLevel(vuln.severity),
                    message: {
                        text: `${vuln.title}: ${vuln.description}`
                    },
                    locations: [{
                        physicalLocation: {
                            artifactLocation: {
                                uri: `npm://${vuln.packageName}`
                            }
                        }
                    }],
                    properties: {
                        severity: vuln.severity,
                        cves: vuln.cves,
                        vulnerableVersions: vuln.vulnerableVersions,
                        patchedVersions: vuln.patchedVersions
                    }
                }))
            }]
        };
        
        return sarifReport;
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'critical': 'error',
            'high': 'error',
            'moderate': 'warning',
            'medium': 'warning',
            'low': 'note',
            'info': 'note'
        };
        return mapping[severity] || 'warning';
    }
    
    async createRemediationPlan() {
        const results = await this.scan();
        
        const plan = {
            immediateActions: [],
            shortTerm: [],
            longTerm: [],
            dependencies: {}
        };
        
        // Немедленные действия для критических уязвимостей
        const criticalVulns = results.vulnerabilities.filter(v => v.severity === 'critical');
        for (const vuln of criticalVulns) {
            plan.immediateActions.push({
                package: vuln.packageName,
                action: `Update to ${vuln.patchedVersions[0]} or later`,
                priority: 'CRITICAL',
                estimatedTime: '24 hours'
            });
        }
        
        // Краткосрочные действия для высоких уязвимостей
        const highVulns = results.vulnerabilities.filter(v => v.severity === 'high');
        for (const vuln of highVulns) {
            plan.shortTerm.push({
                package: vuln.packageName,
                action: `Update to ${vuln.patchedVersions[0]} or later`,
                priority: 'HIGH',
                estimatedTime: '1 week'
            });
        }
        
        // Долгосрочные действия
        const moderateVulns = results.vulnerabilities.filter(v => v.severity === 'moderate');
        for (const vuln of moderateVulns) {
            plan.longTerm.push({
                package: vuln.packageName,
                action: `Review and update if possible`,
                priority: 'MEDIUM',
                estimatedTime: '1 month'
            });
        }
        
        return plan;
    }
}

// Использование npm audit сканера
const npmAuditScanner = new NPMAuditScanner({
    auditLevel: 'moderate',
    omit: ['dev']
});

async function runNPMAudit() {
    const report = await npmAuditScanner.generateNPMReport();
    console.log('NPM Audit Report:', JSON.stringify(report, null, 2));
    
    // Создание плана устранения
    const remediationPlan = await npmAuditScanner.createRemediationPlan();
    console.log('Remediation Plan:', JSON.stringify(remediationPlan, null, 2));
    
    return { report, remediationPlan };
}
```

### 3. Snyk

```javascript
// Обертка для Snyk
class SnykScanner {
    constructor(config = {}) {
        this.config = {
            token: config.token || process.env.SNYK_TOKEN,
            org: config.org || process.env.SNYK_ORG,
            severityThreshold: config.severityThreshold || 'medium',
            allProjects: config.allProjects || false,
            ...config
        };
        
        if (!this.config.token) {
            console.warn('Snyk token not configured - scans will not work');
        }
    }
    
    async scan() {
        if (!this.config.token) {
            throw new Error('Snyk token is required for scanning');
        }
        
        const { execSync } = require('child_process');
        
        try {
            const args = [
                'npx', 'snyk', 'test',
                '--json',
                `--severity-threshold=${this.config.severityThreshold}`
            ];
            
            if (this.config.org) {
                args.push(`--org=${this.config.org}`);
            }
            
            if (this.config.allProjects) {
                args.push('--all-projects');
            }
            
            const command = args.join(' ');
            const result = execSync(command, { encoding: 'utf8' });
            const snykResult = JSON.parse(result);
            
            return this.processSnykResults(snykResult);
        } catch (error) {
            if (error.stdout) {
                try {
                    const snykResult = JSON.parse(error.stdout);
                    return this.processSnykResults(snykResult);
                } catch (parseError) {
                    throw new Error(`Failed to parse Snyk output: ${parseError.message}`);
                }
            }
            throw error;
        }
    }
    
    processSnykResults(snykResult) {
        const vulnerabilities = [];
        
        if (snykResult.vulnerabilities) {
            for (const vuln of snykResult.vulnerabilities) {
                vulnerabilities.push({
                    id: vuln.id,
                    packageName: vuln.from?.[1] || vuln.packageName,
                    severity: vuln.severity,
                    title: vuln.title,
                    description: vuln.description,
                    exploitMaturity: vuln.exploit,
                    credit: vuln.credit,
                    semver: vuln.semver,
                    from: vuln.from,
                    patchedIn: vuln.patched?.[0] || null,
                    legalInstructions: vuln.legalInstructions,
                    severityNumeric: this.severityToNumeric(vuln.severity),
                    cvssScore: vuln.cvssScore,
                    cves: vuln.cves,
                    cwe: vuln.cwe,
                    id: vuln.id,
                    title: vuln.title,
                    severity: vuln.severity,
                    url: vuln.url,
                    description: vuln.description,
                    identifiers: vuln.identifiers,
                    credit: vuln.credit,
                    exploitation: vuln.exploit,
                    patches: vuln.patches || [],
                    nearestFixedInVersion: vuln.nearestFixedInVersion
                });
            }
        }
        
        return {
            vulnerabilities: vulnerabilities,
            summary: {
                totalIssues: snykResult.issues?.summary?.total || 0,
                vulnerabilities: snykResult.issues?.vulnerabilities?.length || 0,
                licenses: snykResult.issues?.licenses?.length || 0,
                critical: snykResult.issues?.vulnerabilities?.filter(v => v.severity === 'critical').length || 0,
                high: snykResult.issues?.vulnerabilities?.filter(v => v.severity === 'high').length || 0,
                medium: snykResult.issues?.vulnerabilities?.filter(v => v.severity === 'medium').length || 0,
                low: snykResult.issues?.vulnerabilities?.filter(v => v.severity === 'low').length || 0
            },
            projectType: snykResult.projectType,
            packageManager: snykResult.packageManager,
            targetFile: snykResult.targetFile,
            displayTargetFile: snykResult.displayTargetFile
        };
    }
    
    severityToNumeric(severity) {
        const numericMap = {
            'low': 1,
            'medium': 2,
            'high': 3,
            'critical': 4
        };
        return numericMap[severity] || 0;
    }
    
    async testAllProjects() {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npx snyk test --all-projects --json', { encoding: 'utf8' });
            const allProjectsResult = JSON.parse(result);
            
            // Обработка результатов для всех проектов
            const aggregatedResults = {
                totalVulnerabilities: 0,
                byProject: {},
                aggregatedVulnerabilities: []
            };
            
            for (const [projectName, projectResult] of Object.entries(allProjectsResult)) {
                if (projectResult.vulnerabilities) {
                    aggregatedResults.totalVulnerabilities += projectResult.vulnerabilities.length;
                    aggregatedResults.byProject[projectName] = projectResult.vulnerabilities.length;
                    aggregatedResults.aggregatedVulnerabilities.push(...projectResult.vulnerabilities);
                }
            }
            
            return aggregatedResults;
        } catch (error) {
            if (error.stdout) {
                const allProjectsResult = JSON.parse(error.stdout);
                // Обработка результата с ошибками (когда найдены уязвимости)
                const aggregatedResults = {
                    totalVulnerabilities: 0,
                    byProject: {},
                    aggregatedVulnerabilities: []
                };
                
                for (const [projectName, projectResult] of Object.entries(allProjectsResult)) {
                    if (projectResult.vulnerabilities) {
                        aggregatedResults.totalVulnerabilities += projectResult.vulnerabilities.length;
                        aggregatedResults.byProject[projectName] = projectResult.vulnerabilities.length;
                        aggregatedResults.aggregatedVulnerabilities.push(...projectResult.vulnerabilities);
                    }
                }
                
                return aggregatedResults;
            }
            throw error;
        }
    }
    
    async getProjectInfo() {
        if (!this.config.token) {
            throw new Error('Snyk token is required');
        }
        
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npx snyk monitor --json', { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
    
    async generateSnykReport() {
        const results = await this.scan();
        
        return {
            tool: 'Snyk',
            version: await this.getSnykVersion(),
            results: results,
            summary: this.generateSnykSummary(results),
            recommendations: this.generateSnykRecommendations(results)
        };
    }
    
    async getSnykVersion() {
        const { execSync } = require('child_process');
        try {
            const result = execSync('npx snyk --version', { encoding: 'utf8' });
            return result.trim();
        } catch {
            return 'unknown';
        }
    }
    
    generateSnykSummary(results) {
        return {
            totalIssues: results.summary.totalIssues,
            totalVulnerabilities: results.summary.vulnerabilities,
            bySeverity: {
                critical: results.summary.critical,
                high: results.summary.high,
                medium: results.summary.medium,
                low: results.summary.low
            },
            licenseIssues: results.summary.licenses,
            projectType: results.projectType,
            packageManager: results.packageManager,
            compliance: results.summary.critical === 0
        };
    }
    
    generateSnykRecommendations(results) {
        const recommendations = [];
        
        if (results.summary.critical > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Address Critical Vulnerabilities',
                description: `Found ${results.summary.critical} critical vulnerabilities`,
                action: 'Update packages immediately using: npx snyk wizard'
            });
        }
        
        if (results.summary.high > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Fix High Severity Issues',
                description: `Found ${results.summary.high} high severity vulnerabilities`,
                action: 'Review and fix high severity vulnerabilities'
            });
        }
        
        if (results.summary.licenses > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Address License Issues',
                description: `Found ${results.summary.licenses} license issues`,
                action: 'Review license compliance and replace problematic packages'
            });
        }
        
        return recommendations;
    }
    
    async createSnykMonitor() {
        if (!this.config.token) {
            throw new Error('Snyk token is required for monitoring');
        }
        
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npx snyk monitor --json', { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            if (error.stdout) {
                return JSON.parse(error.stdout);
            }
            throw error;
        }
    }
    
    async getMonitorReport(orgId, projectId) {
        if (!this.config.token) {
            throw new Error('Snyk token is required');
        }
        
        const response = await fetch(
            `https://snyk.io/api/v1/org/${orgId}/project/${projectId}/aggregated-issues`,
            {
                headers: {
                    'Authorization': `token ${this.config.token}`,
                    'Content-Type': 'application/json'
                }
            }
        );
        
        if (!response.ok) {
            throw new Error(`Snyk API request failed: ${response.status}`);
        }
        
        return await response.json();
    }
    
    async exportToSARIF() {
        const results = await this.scan();
        
        const sarifReport = {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'Snyk',
                        version: await this.getSnykVersion(),
                        informationUri: 'https://snyk.io/docs/'
                    }
                },
                results: results.vulnerabilities.map(vuln => ({
                    ruleId: vuln.id,
                    level: this.severityToSARIFLevel(vuln.severity),
                    message: {
                        text: `${vuln.title}: ${vuln.description}`
                    },
                    locations: [{
                        physicalLocation: {
                            artifactLocation: {
                                uri: `npm://${vuln.packageName}`
                            }
                        }
                    }],
                    properties: {
                        severity: vuln.severity,
                        exploitMaturity: vuln.exploitMaturity,
                        cvssScore: vuln.cvssScore,
                        cves: vuln.cves,
                        cwe: vuln.cwe,
                        patches: vuln.patches
                    }
                }))
            }]
        };
        
        return sarifReport;
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'critical': 'error',
            'high': 'error',
            'medium': 'warning',
            'low': 'note'
        };
        return mapping[severity] || 'warning';
    }
    
    async generateRemediationGuide(results) {
        const guide = {
            immediateActions: [],
            shortTerm: [],
            longTerm: [],
            packageSpecific: {}
        };
        
        for (const vuln of results.vulnerabilities) {
            const action = {
                vulnerabilityId: vuln.id,
                packageName: vuln.packageName,
                severity: vuln.severity,
                title: vuln.title,
                patchedVersion: vuln.patchedIn,
                description: vuln.description
            };
            
            if (vuln.severity === 'critical') {
                guide.immediateActions.push(action);
            } else if (vuln.severity === 'high') {
                guide.shortTerm.push(action);
            } else if (vuln.severity === 'medium') {
                guide.longTerm.push(action);
            }
            
            // Группировка по пакетам
            if (!guide.packageSpecific[vuln.packageName]) {
                guide.packageSpecific[vuln.packageName] = [];
            }
            guide.packageSpecific[vuln.packageName].push(action);
        }
        
        return guide;
    }
}

// Использование Snyk сканера
const snykScanner = new SnykScanner({
    token: process.env.SNYK_TOKEN,
    org: process.env.SNYK_ORG,
    severityThreshold: 'high'
});

async function runSnykScan() {
    const report = await snykScanner.generateSnykReport();
    console.log('Snyk Scan Report:', JSON.stringify(report, null, 2));
    
    const remediationGuide = await snykScanner.generateRemediationGuide(report.results);
    console.log('Remediation Guide:', JSON.stringify(remediationGuide, null, 2));
    
    return { report, remediationGuide };
}
```

## Современные инструменты аудита

### 1. OSV Scanner

```javascript
// Обертка для OSV (Open Source Vulnerabilities) Scanner
class OSVScanner {
    constructor(config = {}) {
        this.config = {
            apiKey: config.apiKey || process.env.OSV_API_KEY,
            ecosystem: config.ecosystem || 'npm',
            ...config
        };
    }
    
    async scan() {
        // OSV Scanner использует API для проверки уязвимостей
        const packageManifest = await this.readPackageManifest();
        const dependencies = await this.extractDependencies(packageManifest);
        
        const results = {
            vulnerabilities: [],
            scannedDependencies: dependencies.length,
            metadata: {
                ecosystem: this.config.ecosystem,
                timestamp: new Date().toISOString()
            }
        };
        
        for (const dep of dependencies) {
            const vulns = await this.checkPackageVulnerabilities(dep.name, dep.version);
            results.vulnerabilities.push(...vulns);
        }
        
        return results;
    }
    
    async readPackageManifest() {
        const fs = require('fs');
        const path = require('path');
        
        const manifestFiles = [
            'package.json',
            'package-lock.json',
            'yarn.lock',
            'npm-shrinkwrap.json'
        ];
        
        for (const file of manifestFiles) {
            if (fs.existsSync(file)) {
                return JSON.parse(fs.readFileSync(file, 'utf8'));
            }
        }
        
        throw new Error('No package manifest found');
    }
    
    async extractDependencies(manifest) {
        const dependencies = [];
        
        // Извлечение production зависимостей
        if (manifest.dependencies) {
            for (const [name, version] of Object.entries(manifest.dependencies)) {
                dependencies.push({ name, version, type: 'production' });
            }
        }
        
        // Извлечение dev зависимостей (если включены)
        if (manifest.devDependencies) {
            for (const [name, version] of Object.entries(manifest.devDependencies)) {
                dependencies.push({ name, version, type: 'development' });
            }
        }
        
        return dependencies;
    }
    
    async checkPackageVulnerabilities(packageName, version) {
        const url = `https://api.osv.dev/v1/query`;
        
        const requestBody = {
            version: version,
            package: {
                name: packageName,
                ecosystem: this.config.ecosystem
            }
        };
        
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                if (response.status === 404) {
                    // Пакет не найден в базе - нет уязвимостей
                    return [];
                }
                throw new Error(`OSV API request failed: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.vulns) {
                return data.vulns.map(vuln => ({
                    id: vuln.id,
                    packageName: packageName,
                    version: version,
                    severity: this.assessSeverity(vuln),
                    summary: vuln.summary,
                    details: vuln.details,
                    affected: vuln.affected,
                    references: vuln.references,
                    severityScore: this.calculateSeverityScore(vuln),
                    published: vuln.published,
                    modified: vuln.modified,
                    withdrawn: vuln.withdrawn
                }));
            }
        } catch (error) {
            console.error(`Failed to check ${packageName}@${version}:`, error.message);
        }
        
        return [];
    }
    
    assessSeverity(vulnerability) {
        // Оценка тяжести на основе CVSS или других метрик
        if (vulnerability.severity) {
            const cvssSeverity = vulnerability.severity.find(s => s.type === 'CVSS_V3');
            if (cvssSeverity) {
                const score = parseFloat(cvssSeverity.score);
                if (score >= 9.0) return 'CRITICAL';
                if (score >= 7.0) return 'HIGH';
                if (score >= 4.0) return 'MEDIUM';
                if (score >= 0.1) return 'LOW';
            }
        }
        
        // Если нет CVSS, используем другие метрики
        if (vulnerability.affected?.[0]?.database_specific?.severity) {
            return vulnerability.affected[0].database_specific.severity;
        }
        
        return 'UNKNOWN';
    }
    
    calculateSeverityScore(vulnerability) {
        if (vulnerability.severity) {
            const cvss = vulnerability.severity.find(s => s.type === 'CVSS_V3');
            if (cvss) {
                return parseFloat(cvss.score) || 0;
            }
        }
        
        // Расчет на основе других метрик
        return 0; // заглушка
    }
    
    async getVulnerabilityDetails(vulnId) {
        const response = await fetch(`https://api.osv.dev/v1/vulns/${vulnId}`);
        
        if (!response.ok) {
            throw new Error(`Failed to get vulnerability details: ${response.status}`);
        }
        
        return await response.json();
    }
    
    async generateOSVReport() {
        const results = await this.scan();
        
        return {
            tool: 'OSV Scanner',
            ecosystem: this.config.ecosystem,
            results: results,
            summary: this.generateOSVSummary(results),
            recommendations: this.generateOSVRecommendations(results)
        };
    }
    
    generateOSVSummary(results) {
        const summary = {
            totalVulnerabilities: results.vulnerabilities.length,
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 },
            scannedDependencies: results.scannedDependencies,
            vulnerabilityRate: results.scannedDependencies > 0 ? 
                (results.vulnerabilities.length / results.scannedDependencies) * 100 : 0
        };
        
        for (const vuln of results.vulnerabilities) {
            summary.bySeverity[vuln.severity] = (summary.bySeverity[vuln.severity] || 0) + 1;
        }
        
        return summary;
    }
    
    generateOSVRecommendations(results) {
        const recommendations = [];
        
        if (results.vulnerabilities.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Identified Vulnerabilities',
                description: `OSV found ${results.vulnerabilities.length} vulnerabilities`,
                action: 'Review OSV vulnerability details and apply appropriate fixes'
            });
        }
        
        // Рекомендации по конкретным уязвимостям
        const criticalVulns = results.vulnerabilities.filter(v => v.severity === 'CRITICAL');
        if (criticalVulns.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Critical Vulnerabilities Found',
                description: `Found ${criticalVulns.length} critical vulnerabilities`,
                action: 'Update affected packages immediately'
            });
        }
        
        return recommendations;
    }
    
    async exportToSARIF() {
        const results = await this.scan();
        
        const sarifReport = {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'OSV Scanner',
                        version: '1.0.0',
                        informationUri: 'https://osv.dev/'
                    }
                },
                results: results.vulnerabilities.map(vuln => ({
                    ruleId: vuln.id,
                    level: this.severityToSARIFLevel(vuln.severity),
                    message: {
                        text: `${vuln.summary || vuln.id}: ${vuln.details}`
                    },
                    locations: [{
                        physicalLocation: {
                            artifactLocation: {
                                uri: `osv://${vuln.id}`
                            }
                        }
                    }],
                    properties: {
                        severity: vuln.severity,
                        severityScore: vuln.severityScore,
                        published: vuln.published,
                        modified: vuln.modified,
                        affected: vuln.affected,
                        references: vuln.references
                    }
                }))
            }]
        };
        
        return sarifReport;
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'CRITICAL': 'error',
            'HIGH': 'error',
            'MEDIUM': 'warning',
            'LOW': 'note',
            'INFO': 'note'
        };
        return mapping[severity] || 'warning';
    }
}

// Использование OSV Scanner
const osvScanner = new OSVScanner({
    ecosystem: 'npm'
});

async function runOSVScan() {
    const report = await osvScanner.generateOSVReport();
    console.log('OSV Scan Report:', JSON.stringify(report, null, 2));
    
    return report;
}
```

### 2. OWASP Dependency Check

```javascript
// Интеграция с OWASP Dependency Check
class OWASPDependencyCheckScanner {
    constructor(config = {}) {
        this.config = {
            installPath: config.installPath || '/opt/dependency-check',
            dataDirectory: config.dataDirectory || './data',
            format: config.format || 'JSON',
            scanPath: config.scanPath || '.',
            ...config
        };
    }
    
    async scan() {
        const { execSync } = require('child_process');
        
        try {
            const args = [
                `${this.config.installPath}/bin/dependency-check.sh`,
                `--scan ${this.config.scanPath}`,
                `--format ${this.config.format}`,
                `--out ./reports/`,
                `--project "${this.config.projectName || 'Security Audit'}"`,
                ...(this.config.dataDirectory ? [`--data ${this.config.dataDirectory}`] : [])
            ];
            
            const command = args.join(' ');
            const result = execSync(command, { encoding: 'utf8' });
            
            // Чтение результата из файла
            const fs = require('fs');
            const reportFile = `./reports/dependency-check-report.json`;
            
            if (fs.existsSync(reportFile)) {
                const reportContent = fs.readFileSync(reportFile, 'utf8');
                return this.processOWSAPReport(JSON.parse(reportContent));
            } else {
                throw new Error('OWASP Dependency Check report file not found');
            }
        } catch (error) {
            console.error('OWASP Dependency Check failed:', error);
            throw error;
        }
    }
    
    processOWSAPReport(report) {
        const vulnerabilities = [];
        
        if (report.dependencies) {
            for (const dependency of report.dependencies) {
                if (dependency.vulnerabilities) {
                    for (const vuln of dependency.vulnerabilities) {
                        vulnerabilities.push({
                            id: vuln.name,
                            packageName: dependency.fileName || dependency.name,
                            severity: this.cvssToSeverity(vuln.cvssV2?.score || vuln.cvssV3?.baseScore),
                            title: vuln.name,
                            description: vuln.description,
                            cvssScore: vuln.cvssV2?.score || vuln.cvssV3?.baseScore,
                            cvssVector: vuln.cvssV2?.accessVector || vuln.cvssV3?.vectorString,
                            cwe: vuln.cwe,
                            cve: vuln.vulnerabilityIds?.find(id => id.id.startsWith('CVE')),
                            severityNumeric: vuln.cvssV2?.score || vuln.cvssV3?.baseScore || 0,
                            published: vuln.published,
                            modified: vuln.modified,
                            vulnerableVersions: this.extractVulnerableVersions(dependency),
                            evidence: dependency.evidenceCollected
                        });
                    }
                }
            }
        }
        
        return {
            vulnerabilities: vulnerabilities,
            summary: {
                dependenciesScanned: report.dependencies?.length || 0,
                vulnerabilitiesFound: vulnerabilities.length,
                suppressed: report.suppressed?.length || 0,
                reportDate: report.scanInfo?.reportDate,
                engineVersion: report.scanInfo?.engineVersion
            },
            dependencies: report.dependencies || []
        };
    }
    
    cvssToSeverity(score) {
        if (score >= 9.0) return 'CRITICAL';
        if (score >= 7.0) return 'HIGH';
        if (score >= 4.0) return 'MEDIUM';
        if (score >= 0.1) return 'LOW';
        return 'INFO';
    }
    
    extractVulnerableVersions(dependency) {
        // Извлечение информации о уязвимых версиях из зависимости
        if (dependency.vulnerabilityIds) {
            return dependency.vulnerabilityIds
                .filter(id => id.id.startsWith('CVE'))
                .map(id => id.id);
        }
        return [];
    }
    
    async generateOWSAPReport() {
        const results = await this.scan();
        
        return {
            tool: 'OWASP Dependency Check',
            version: await this.getOWSAPVersion(),
            results: results,
            summary: this.generateOWSAPSummary(results),
            recommendations: this.generateOWSAPRecommendations(results)
        };
    }
    
    async getOWSAPVersion() {
        const { execSync } = require('child_process');
        try {
            const result = execSync(`${this.config.installPath}/bin/dependency-check.sh --version`, { encoding: 'utf8' });
            return result.trim();
        } catch {
            return 'unknown';
        }
    }
    
    generateOWSAPSummary(results) {
        return {
            totalDependencies: results.summary.dependenciesScanned,
            totalVulnerabilities: results.summary.vulnerabilitiesFound,
            suppressed: results.summary.suppressed,
            vulnerabilityRate: results.summary.dependenciesScanned > 0 ? 
                (results.summary.vulnerabilitiesFound / results.summary.dependenciesScanned) * 100 : 0,
            bySeverity: this.countVulnerabilitiesBySeverity(results.vulnerabilities),
            compliance: results.summary.vulnerabilitiesFound === 0
        };
    }
    
    countVulnerabilitiesBySeverity(vulnerabilities) {
        const counts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFO: 0 };
        
        for (const vuln of vulnerabilities) {
            counts[vuln.severity] = (counts[vuln.severity] || 0) + 1;
        }
        
        return counts;
    }
    
    generateOWSAPRecommendations(results) {
        const recommendations = [];
        
        if (results.summary.vulnerabilitiesFound > 0) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Address Dependency Vulnerabilities',
                description: `OWASP Dependency Check found ${results.summary.vulnerabilitiesFound} vulnerabilities`,
                action: 'Review and update vulnerable dependencies'
            });
        }
        
        const criticalVulns = results.vulnerabilities.filter(v => v.severity === 'CRITICAL');
        if (criticalVulns.length > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                title: 'Critical Vulnerabilities Detected',
                description: `Found ${criticalVulns.length} critical vulnerabilities`,
                action: 'Update dependencies immediately to address critical vulnerabilities'
            });
        }
        
        return recommendations;
    }
    
    async exportToSARIF() {
        const results = await this.scan();
        
        const sarifReport = {
            $schema: 'https://json.schemastore.org/sarif-2.1.0.json',
            version: '2.1.0',
            runs: [{
                tool: {
                    driver: {
                        name: 'OWASP Dependency Check',
                        version: await this.getOWSAPVersion(),
                        informationUri: 'https://owasp.org/www-project-dependency-check/'
                    }
                },
                results: results.vulnerabilities.map(vuln => ({
                    ruleId: vuln.id,
                    level: this.severityToSARIFLevel(vuln.severity),
                    message: {
                        text: `${vuln.title}: ${vuln.description}`
                    },
                    locations: [{
                        physicalLocation: {
                            artifactLocation: {
                                uri: vuln.packageName
                            }
                        }
                    }],
                    properties: {
                        severity: vuln.severity,
                        cvssScore: vuln.cvssScore,
                        cwe: vuln.cwe,
                        cve: vuln.cve,
                        vulnerableVersions: vuln.vulnerableVersions
                    }
                }))
            }]
        };
        
        return sarifReport;
    }
    
    severityToSARIFLevel(severity) {
        const mapping = {
            'CRITICAL': 'error',
            'HIGH': 'error',
            'MEDIUM': 'warning',
            'LOW': 'note',
            'INFO': 'note'
        };
        return mapping[severity] || 'warning';
    }
    
    async getVulnerabilityDetails(vulnerabilityId) {
        // Получение детальной информации об уязвимости
        // В реальности использовать OWASP DC API или базу данных
        return {
            vulnerabilityId,
            details: 'Vulnerability details from OWASP DC database',
            references: [],
            solutions: []
        };
    }
    
    async generateComplianceReport() {
        const results = await this.scan();
        
        return {
            standard: 'OWASP Dependency Check',
            timestamp: new Date().toISOString(),
            results: results,
            compliance: {
                owaspTop10: this.checkOWASPCompliance(results),
                cweTop25: this.checkCWETop25(results),
                overall: results.summary.vulnerabilitiesFound === 0
            }
        };
    }
    
    checkOWASPCompliance(results) {
        // Проверка соответствия OWASP Top 10
        const owaspCategories = {
            'A01:2021-Broken Access Control': 0,
            'A02:2021-Cryptographic Failures': 0,
            'A03:2021-Injection': 0,
            'A04:2021-Insecure Design': 0,
            'A05:2021-Security Misconfiguration': 0,
            'A06:2021-Vulnerable and Outdated Components': 0,
            'A07:2021-Identification and Authentication Failures': 0,
            'A08:2021-Software and Data Integrity Failures': 0,
            'A09:2021-Security Logging and Monitoring Failures': 0,
            'A10:2021-Server-Side Request Forgery': 0
        };
        
        // Подсчет уязвимостей по категориям OWASP
        for (const vuln of results.vulnerabilities) {
            if (vuln.cwe) {
                // Простое сопоставление CWE с OWASP категориями
                if (vuln.cwe.includes('CWE-79') || vuln.cwe.includes('CWE-89')) {
                    owaspCategories['A03:2021-Injection']++;
                }
                if (vuln.cwe.includes('CWE-200') || vuln.cwe.includes('CWE-287')) {
                    owaspCategories['A07:2021-Identification and Authentication Failures']++;
                }
                if (vuln.cwe.includes('CWE-22') || vuln.cwe.includes('CWE-284')) {
                    owaspCategories['A01:2021-Broken Access Control']++;
                }
            }
        }
        
        return {
            categories: owaspCategories,
            compliant: Object.values(owaspCategories).every(count => count === 0)
        };
    }
    
    checkCWETop25(results) {
        // Проверка соответствия CWE Top 25
        const cweTop25 = [
            'CWE-79', 'CWE-89', 'CWE-125', 'CWE-20', 'CWE-119',
            'CWE-416', 'CWE-22', 'CWE-78', 'CWE-502', 'CWE-287',
            'CWE-476', 'CWE-284', 'CWE-434', 'CWE-352', 'CWE-200',
            'CWE-190', 'CWE-306', 'CWE-862', 'CWE-787', 'CWE-276',
            'CWE-295', 'CWE-400', 'CWE-522', 'CWE-732', 'CWE-426'
        ];
        
        const foundInTop25 = results.vulnerabilities.filter(vuln => 
            vuln.cwe && cweTop25.includes(vuln.cwe)
        );
        
        return {
            count: foundInTop25.length,
            compliant: foundInTop25.length === 0,
            top25Vulnerabilities: foundInTop25.map(v => ({
                id: v.id,
                cwe: v.cwe,
                severity: v.severity
            }))
        };
    }
}

// Использование OWASP Dependency Check
const owaspScanner = new OWASPDependencyCheckScanner({
    installPath: process.env.DEPENDENCY_CHECK_PATH || '/opt/dependency-check',
    scanPath: './',
    projectName: 'My Secure Project'
});

async function runOWSAPScan() {
    const report = await owaspScanner.generateOWSAPReport();
    console.log('OWASP Dependency Check Report:', JSON.stringify(report, null, 2));
    
    const complianceReport = await owaspScanner.generateComplianceReport();
    console.log('Compliance Report:', JSON.stringify(complianceReport, null, 2));
    
    return { report, complianceReport };
}
```

## Интеграция с CI/CD

### 1. Pipeline безопасности

```yaml
# .github/workflows/security-audit.yml
name: Security Dependency Audit

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  dependency-audit:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run npm audit
        run: |
          npm audit --audit-level moderate
          npm audit --json > npm-audit-report.json
          
          # Проверка на критические уязвимости
          critical=$(jq '.metadata.vulnerabilities.critical // 0' npm-audit-report.json)
          if [ "$critical" -gt 0 ]; then
            echo "Critical vulnerabilities found: $critical"
            exit 1
          fi
      
      - name: Run Snyk test
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --json > snyk-report.json
          
          # Проверка на критические уязвимости
          critical=$(jq '.issues.vulnerabilities[] | select(.severity=="critical")' snyk-report.json | wc -l)
          if [ "$critical" -gt 0 ]; then
            echo "Critical vulnerabilities found in Snyk: $critical"
            exit 1
          fi
      
      - name: Run OSV scan
        run: |
          # Установка OSV Scanner
          go install github.com/google/osv-scanner/cmd/osv-scanner@latest
          
          # Запуск сканирования
          ~/go/bin/osv-scanner --lockfile=./package-lock.json > osv-report.json
          
          # Проверка результатов
          if jq -e '.results[] | select(.packages[].vulnerabilities | length > 0)' osv-report.json > /dev/null 2>&1; then
            echo "Vulnerabilities found by OSV Scanner"
            jq '.' osv-report.json
            exit 1
          fi
      
      - name: Run OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'Dependency Security Audit'
          scanPath: '.'
          format: 'JSON'
          out: 'reports'
      
      - name: Consolidate reports
        run: |
          node scripts/consolidate-security-reports.js
          
      - name: Upload security reports
        uses: actions/upload-artifact@v3
        with:
          name: security-audit-reports
          path: |
            npm-audit-report.json
            snyk-report.json
            osv-report.json
            reports/
      
      - name: Post security summary to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const npmReport = JSON.parse(fs.readFileSync('npm-audit-report.json', 'utf8'));
            const snykReport = JSON.parse(fs.readFileSync('snyk-report.json', 'utf8'));
            
            const comment = `
            ## Security Audit Summary
            
            ### NPM Audit
            - Critical: ${npmReport.metadata?.vulnerabilities?.critical || 0}
            - High: ${npmReport.metadata?.vulnerabilities?.high || 0}
            - Moderate: ${npmReport.metadata?.vulnerabilities?.moderate || 0}
            
            ### Snyk Scan
            - Critical: ${snykReport.issues?.vulnerabilities?.filter(v => v.severity === 'critical')?.length || 0}
            - High: ${snykReport.issues?.vulnerabilities?.filter(v => v.severity === 'high')?.length || 0}
            
            ${
              (npmReport.metadata?.vulnerabilities?.critical || 0) > 0 || 
              (snykReport.issues?.vulnerabilities?.filter(v => v.severity === 'critical')?.length || 0) > 0 ? 
              ':x: **BUILD BLOCKED** - Critical vulnerabilities detected' : 
              ':white_check_mark: No critical vulnerabilities found'
            }
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

### 2. GitLab CI интеграция

```yaml
# .gitlab-ci.yml
stages:
  - security
  - test
  - build

security-audit:
  stage: security
  image: node:18
  variables:
    SNYK_TOKEN: $SNYK_TOKEN
  script:
    - npm ci
    - npm audit --audit-level moderate --json > npm-audit.json
    - npx snyk test --json --severity-threshold=high > snyk-results.json
    - |
      # Проверка на критические уязвимости
      critical_npm=$(jq '.metadata.vulnerabilities.critical // 0' npm-audit.json)
      critical_snyk=$(jq '[.vulnerabilities[] | select(.severity=="critical")] | length' snyk-results.json)
      
      if [ "$critical_npm" -gt 0 ] || [ "$critical_snyk" -gt 0 ]; then
        echo "Critical vulnerabilities detected:"
        echo "NPM: $critical_npm"
        echo "Snyk: $critical_snyk"
        exit 1
      fi
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scan.json
    paths:
      - npm-audit.json
      - snyk-results.json
  allow_failure: false
```

### 3. Jenkins Pipeline

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    tools {
        nodejs 'NodeJS-18'
    }
    
    environment {
        SNYK_TOKEN = credentials('snyk-token')
        NPM_TOKEN = credentials('npm-token')
    }
    
    stages {
        stage('Security Audit') {
            parallel {
                stage('NPM Audit') {
                    steps {
                        script {
                            sh 'npm ci'
                            sh 'npm audit --audit-level moderate --json > npm-audit.json'
                            
                            // Проверка результатов
                            def npmAudit = readJSON file: 'npm-audit.json'
                            if (npmAudit.metadata.vulnerabilities.critical > 0) {
                                error "Critical vulnerabilities found in NPM audit: ${npmAudit.metadata.vulnerabilities.critical}"
                            }
                        }
                    }
                }
                
                stage('Snyk Scan') {
                    steps {
                        script {
                            sh 'npx snyk test --json --severity-threshold=high > snyk-report.json'
                            
                            def snykReport = readJSON file: 'snyk-report.json'
                            if (snykReport.issues?.vulnerabilities?.any { it.severity == 'critical' }) {
                                error "Critical vulnerabilities found in Snyk scan"
                            }
                        }
                    }
                }
                
                stage('License Check') {
                    steps {
                        script {
                            sh 'npx license-checker --json --out license-check.json'
                            
                            def licenseCheck = readJSON file: 'license-check.json'
                            def forbiddenLicenses = ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0']
                            
                            def violations = []
                            licenseCheck.each { name, info ->
                                if (forbiddenLicenses.contains(info.licenses)) {
                                    violations.add(name)
                                }
                            }
                            
                            if (violations.size() > 0) {
                                error "Forbidden licenses detected: ${violations.join(', ')}"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            publishHTML([
                allowMissing: true,
                includes: 'security-reports/*',
                title: 'Security Audit Reports'
            ])
        }
        
        success {
            script {
                echo "All security audits passed successfully"
            }
        }
        
        failure {
            script {
                def npmReport = readJSON file: 'npm-audit.json'
                def snykReport = readJSON file: 'snyk-report.json'
                
                def criticalNpm = npmReport.metadata.vulnerabilities.critical
                def criticalSnyk = snykReport.issues.vulnerabilities?.count { it.severity == 'critical' } ?: 0
                
                if (criticalNpm > 0 || criticalSnyk > 0) {
                    echo "CRITICAL VULNERABILITIES DETECTED - BUILD FAILED"
                }
            }
        }
    }
}
```

## Автоматизированные обновления зависимостей

### 1. Безопасные обновления

```javascript
// Система безопасных обновлений зависимостей
class SecureDependencyUpdater {
    constructor(scanner) {
        this.scanner = scanner;
        this.updateHistory = [];
        this.backupManager = new BackupManager();
    }
    
    async performSecurityUpdate() {
        // Получение текущих уязвимостей
        const currentScan = await this.scanner.scan();
        
        if (currentScan.vulnerabilities.length === 0) {
            console.log('No vulnerabilities found, no updates needed');
            return { success: true, updated: 0, vulnerabilities: 0 };
        }
        
        // Группировка уязвимостей по пакетам
        const vulnerabilitiesByPackage = this.groupVulnerabilitiesByPackage(currentScan.vulnerabilities);
        
        // Создание бэкапа
        const backup = await this.backupManager.createBackup();
        
        try {
            let updatedCount = 0;
            
            for (const [packageName, packageVulns] of Object.entries(vulnerabilitiesByPackage)) {
                const updateResult = await this.updatePackageSecurely(packageName, packageVulns);
                
                if (updateResult.success) {
                    updatedCount++;
                    
                    // Повторная проверка безопасности после обновления
                    await this.verifySecurityAfterUpdate(packageName, updateResult.newVersion);
                }
                
                this.updateHistory.push({
                    timestamp: new Date().toISOString(),
                    package: packageName,
                    fromVersion: updateResult.oldVersion,
                    toVersion: updateResult.newVersion,
                    vulnerabilitiesFixed: packageVulns.length,
                    success: updateResult.success,
                    error: updateResult.error
                });
            }
            
            // Проверка, остались ли уязвимости
            const postUpdateScan = await this.scanner.scan();
            const remainingVulnerabilities = postUpdateScan.vulnerabilities.length;
            
            return {
                success: true,
                updated: updatedCount,
                fixedVulnerabilities: currentScan.vulnerabilities.length - remainingVulnerabilities,
                remainingVulnerabilities: remainingVulnerabilities,
                updateHistory: this.updateHistory.slice(-10) // последние 10 обновлений
            };
            
        } catch (error) {
            // Восстановление из бэкапа при ошибке
            await this.backupManager.restoreFromBackup(backup);
            throw error;
        }
    }
    
    groupVulnerabilitiesByPackage(vulnerabilities) {
        const grouped = {};
        
        for (const vuln of vulnerabilities) {
            const packageName = vuln.packageName;
            if (!grouped[packageName]) {
                grouped[packageName] = [];
            }
            grouped[packageName].push(vuln);
        }
        
        return grouped;
    }
    
    async updatePackageSecurely(packageName, vulnerabilities) {
        // Определение минимальной безопасной версии
        const safeVersion = await this.findMinimumSafeVersion(packageName, vulnerabilities);
        
        if (!safeVersion) {
            return {
                success: false,
                error: 'No safe version found for package',
                oldVersion: await this.getCurrentPackageVersion(packageName)
            };
        }
        
        try {
            const oldVersion = await this.getCurrentPackageVersion(packageName);
            
            // Обновление пакета
            const { execSync } = require('child_process');
            execSync(`npm install ${packageName}@${safeVersion}`, { stdio: 'inherit' });
            
            // Проверка после обновления
            await this.runPostUpdateChecks(packageName, safeVersion);
            
            return {
                success: true,
                oldVersion: oldVersion,
                newVersion: safeVersion
            };
        } catch (error) {
            return {
                success: false,
                error: error.message,
                oldVersion: await this.getCurrentPackageVersion(packageName)
            };
        }
    }
    
    async findMinimumSafeVersion(packageName, vulnerabilities) {
        // Найти минимальную версию, которая исправляет все уязвимости
        const packageInfo = await this.getPackageInfo(packageName);
        
        // Получение информации о патчах из уязвимостей
        const requiredPatches = vulnerabilities.map(vuln => 
            vuln.patchedIn || this.findPatchForVulnerability(vuln)
        ).filter(Boolean);
        
        if (requiredPatches.length === 0) {
            // Если нет информации о патчах, используем последнюю версию
            return packageInfo['dist-tags']?.latest;
        }
        
        // Найти версию, которая включает все необходимые патчи
        const versions = Object.keys(packageInfo.versions).sort((a, b) => 
            this.compareVersions(a, b)
        );
        
        for (const version of versions) {
            if (this.versionMeetsAllPatches(version, requiredPatches)) {
                return version;
            }
        }
        
        return null; // Не найдена безопасная версия
    }
    
    compareVersions(v1, v2) {
        const [major1, minor1, patch1] = v1.split('.').map(Number);
        const [major2, minor2, patch2] = v2.split('.').map(Number);
        
        if (major1 !== major2) return major1 - major2;
        if (minor1 !== minor2) return minor1 - minor2;
        return patch1 - patch2;
    }
    
    versionMeetsAllPatches(version, requiredPatches) {
        return requiredPatches.every(patch => 
            this.compareVersions(version, patch) >= 0
        );
    }
    
    async runPostUpdateChecks(packageName, newVersion) {
        // Проверка безопасности после обновления
        const postUpdateScan = await this.scanner.scan();
        
        const remainingVulns = postUpdateScan.vulnerabilities.filter(
            vuln => vuln.packageName === packageName
        );
        
        if (remainingVulns.length > 0) {
            throw new Error(`Security vulnerabilities remain in ${packageName}@${newVersion}`);
        }
        
        // Проверка функциональности
        await this.runRegressionTests();
        
        console.log(`Successfully updated ${packageName} to ${newVersion}, no vulnerabilities detected`);
    }
    
    async runRegressionTests() {
        // Запуск регрессионных тестов после обновления
        const { execSync } = require('child_process');
        
        try {
            execSync('npm test', { stdio: 'inherit' });
            console.log('Regression tests passed after update');
        } catch (error) {
            throw new Error(`Regression tests failed after update: ${error.message}`);
        }
    }
    
    async getCurrentPackageVersion(packageName) {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        const allDeps = {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
        
        return allDeps[packageName];
    }
    
    async getPackageInfo(packageName) {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync(`npm view ${packageName} --json`, { encoding: 'utf8' });
            return JSON.parse(result);
        } catch (error) {
            throw new Error(`Failed to get package info for ${packageName}: ${error.message}`);
        }
    }
    
    findPatchForVulnerability(vulnerability) {
        // Найти патч для конкретной уязвимости
        // В реальности использовать базу данных уязвимостей
        return null; // заглушка
    }
    
    async getUpdateStatistics() {
        return {
            totalUpdates: this.updateHistory.length,
            successfulUpdates: this.updateHistory.filter(u => u.success).length,
            failedUpdates: this.updateHistory.filter(u => !u.success).length,
            vulnerabilitiesFixed: this.updateHistory.reduce((sum, update) => 
                sum + (update.vulnerabilitiesFixed || 0), 0),
            successRate: this.updateHistory.length > 0 ? 
                (this.updateHistory.filter(u => u.success).length / this.updateHistory.length) * 100 : 0
        };
    }
    
    async generateUpdateReport() {
        const stats = await this.getUpdateStatistics();
        
        return {
            timestamp: new Date().toISOString(),
            statistics: stats,
            recentUpdates: this.updateHistory.slice(-10),
            recommendations: this.generateUpdateRecommendations(stats)
        };
    }
    
    generateUpdateRecommendations(stats) {
        const recommendations = [];
        
        if (stats.successRate < 90) {
            recommendations.push({
                priority: 'HIGH',
                title: 'Low Update Success Rate',
                description: `Only ${stats.successRate.toFixed(2)}% of updates succeeded`,
                action: 'Investigate update process issues'
            });
        }
        
        if (stats.failedUpdates > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Update Failures Detected',
                description: `${stats.failedUpdates} update failures recorded`,
                action: 'Review failed updates and fix underlying issues'
            });
        }
        
        if (stats.vulnerabilitiesFixed === 0) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'No Vulnerabilities Fixed',
                description: 'Recent updates did not fix any vulnerabilities',
                action: 'Verify vulnerability detection and update process'
            });
        }
        
        return recommendations;
    }
}

// Использование безопасного обновлятора
const secureUpdater = new SecureDependencyUpdater(osvScanner);

async function runSecureUpdate() {
    const result = await secureUpdater.performSecurityUpdate();
    console.log('Secure Update Result:', JSON.stringify(result, null, 2));
    
    const report = await secureUpdater.generateUpdateReport();
    console.log('Update Report:', JSON.stringify(report, null, 2));
    
    return result;
}
```

## Лучшие практики

### 1. Политики управления зависимостями

```javascript
// Политики управления зависимостями
class DependencySecurityPolicy {
    constructor() {
        this.policy = {
            // Политики лицензий
            licensePolicy: {
                allowed: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'],
                forbidden: ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0', 'CC-BY-NC-4.0'],
                requireApproval: ['MPL-2.0', 'EPL-2.0', 'OSL-3.0']
            },
            
            // Политики версий
            versionPolicy: {
                allowMajorUpdates: false,
                requireSecurityPatches: true,
                maxAgeDays: 365,
                requireSignedPackages: false
            },
            
            // Политики источников
            sourcePolicy: {
                trustedRegistries: [
                    'https://registry.npmjs.org/',
                    'https://pkgs.dev.azure.com/',
                    process.env.NPM_REGISTRY_URL
                ],
                allowGitDependencies: false,
                allowTarballDependencies: false
            },
            
            // Политики безопасности
            securityPolicy: {
                maxCriticalVulnerabilities: 0,
                maxHighVulnerabilities: 5,
                auditLevel: 'moderate'
            },
            
            // Политики качества
            qualityPolicy: {
                minDownloads: 1000,
                minAgeDays: 30,
                requireDocumentation: true,
                requireTests: true
            }
        };
        
        this.exceptions = new Map(); // Исключения для конкретных пакетов
        this.approvalQueue = []; // Очередь на одобрение
    }
    
    async validatePackageAgainstPolicy(packageInfo) {
        const validation = {
            license: await this.validateLicensePolicy(packageInfo),
            version: await this.validateVersionPolicy(packageInfo),
            source: await this.validateSourcePolicy(packageInfo),
            security: await this.validateSecurityPolicy(packageInfo),
            quality: await this.validateQualityPolicy(packageInfo),
            overallCompliance: false
        };
        
        validation.overallCompliance = 
            validation.license.compliant &&
            validation.version.compliant &&
            validation.source.compliant &&
            validation.security.compliant &&
            validation.quality.compliant;
        
        return validation;
    }
    
    async validateLicensePolicy(packageInfo) {
        const license = this.extractLicense(packageInfo);
        
        if (!license) {
            return {
                compliant: false,
                issues: [{ type: 'NO_LICENSE', severity: 'HIGH', message: 'No license specified' }],
                license: null
            };
        }
        
        if (this.policy.licensePolicy.forbidden.includes(license)) {
            return {
                compliant: false,
                issues: [{ type: 'FORBIDDEN_LICENSE', severity: 'CRITICAL', message: `License ${license} is forbidden` }],
                license: license
            };
        }
        
        if (this.policy.licensePolicy.requireApproval.includes(license)) {
            if (!this.isPackageApproved(packageInfo.name, license)) {
                return {
                    compliant: false,
                    issues: [{ type: 'LICENSE_REQUIRES_APPROVAL', severity: 'MEDIUM', message: `License ${license} requires approval` }],
                    license: license
                };
            }
        }
        
        if (!this.policy.licensePolicy.allowed.includes(license)) {
            return {
                compliant: false,
                issues: [{ type: 'LICENSE_NOT_ALLOWED', severity: 'MEDIUM', message: `License ${license} is not in allowed list` }],
                license: license
            };
        }
        
        return { compliant: true, issues: [], license: license };
    }
    
    async validateVersionPolicy(packageInfo) {
        // Проверка политики версий
        const currentVersion = packageInfo.version;
        const latestVersion = await this.getLatestVersion(packageInfo.name);
        
        const versionDiff = this.getVersionDifference(currentVersion, latestVersion);
        
        if (versionDiff.major && !this.policy.versionPolicy.allowMajorUpdates) {
            return {
                compliant: false,
                issues: [{ type: 'MAJOR_UPDATE_BLOCKED', severity: 'MEDIUM', message: 'Major version updates not allowed' }],
                version: currentVersion
            };
        }
        
        // Проверка возраста пакета
        const age = await this.getPackageAge(packageInfo.name, currentVersion);
        if (age > this.policy.versionPolicy.maxAgeDays) {
            return {
                compliant: false,
                issues: [{ type: 'PACKAGE_TOO_OLD', severity: 'LOW', message: `Package is ${age} days old` }],
                version: currentVersion
            };
        }
        
        return { compliant: true, issues: [], version: currentVersion };
    }
    
    async validateSourcePolicy(packageInfo) {
        const source = await this.getPackageSource(packageInfo.name);
        
        if (!this.isTrustedSource(source)) {
            return {
                compliant: false,
                issues: [{ type: 'UNTRUSTED_SOURCE', severity: 'HIGH', message: `Package from untrusted source: ${source}` }],
                source: source
            };
        }
        
        // Проверка типа зависимости
        if (packageInfo.specification.startsWith('git+') && !this.policy.sourcePolicy.allowGitDependencies) {
            return {
                compliant: false,
                issues: [{ type: 'GIT_DEPENDENCY_DENIED', severity: 'MEDIUM', message: 'Git dependencies not allowed' }],
                source: source
            };
        }
        
        return { compliant: true, issues: [], source: source };
    }
    
    async validateSecurityPolicy(packageInfo) {
        const vulnerabilities = await this.checkVulnerabilities(packageInfo.name, packageInfo.version);
        
        const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
        const highVulns = vulnerabilities.filter(v => v.severity === 'HIGH').length;
        
        if (criticalVulns > this.policy.securityPolicy.maxCriticalVulnerabilities) {
            return {
                compliant: false,
                issues: [{ type: 'CRITICAL_VULNERABILITIES', severity: 'CRITICAL', message: `Found ${criticalVulns} critical vulnerabilities` }],
                vulnerabilities: vulnerabilities
            };
        }
        
        if (highVulns > this.policy.securityPolicy.maxHighVulnerabilities) {
            return {
                compliant: false,
                issues: [{ type: 'HIGH_VULNERABILITIES', severity: 'HIGH', message: `Found ${highVulns} high vulnerabilities` }],
                vulnerabilities: vulnerabilities
            };
        }
        
        return { compliant: true, issues: [], vulnerabilities: vulnerabilities };
    }
    
    async validateQualityPolicy(packageInfo) {
        const metadata = await this.getPackageMetadata(packageInfo.name);
        
        const issues = [];
        
        // Проверка количества скачиваний
        if (metadata.downloads < this.policy.qualityPolicy.minDownloads) {
            issues.push({
                type: 'LOW_DOWNLOADS',
                severity: 'MEDIUM',
                message: `Package has only ${metadata.downloads} downloads, minimum required: ${this.policy.qualityPolicy.minDownloads}`
            });
        }
        
        // Проверка возраста
        if (metadata.age < this.policy.qualityPolicy.minAgeDays) {
            issues.push({
                type: 'NEW_PACKAGE',
                severity: 'LOW',
                message: `Package is only ${metadata.age} days old, minimum required: ${this.policy.qualityPolicy.minAgeDays}`
            });
        }
        
        // Проверка документации
        if (this.policy.qualityPolicy.requireDocumentation && !metadata.hasDocumentation) {
            issues.push({
                type: 'NO_DOCUMENTATION',
                severity: 'LOW',
                message: 'Package lacks documentation'
            });
        }
        
        // Проверка тестов
        if (this.policy.qualityPolicy.requireTests && !metadata.hasTests) {
            issues.push({
                type: 'NO_TESTS',
                severity: 'MEDIUM',
                message: 'Package lacks tests'
            });
        }
        
        return {
            compliant: issues.length === 0,
            issues: issues,
            metadata: metadata
        };
    }
    
    extractLicense(packageInfo) {
        if (!packageInfo.license) return null;
        
        if (typeof packageInfo.license === 'string') {
            return packageInfo.license;
        }
        
        if (typeof packageInfo.license === 'object' && packageInfo.license.type) {
            return packageInfo.license.type;
        }
        
        return null;
    }
    
    isTrustedSource(source) {
        return this.policy.sourcePolicy.trustedRegistries.some(registry => 
            source.startsWith(registry)
        );
    }
    
    isPackageApproved(name, license) {
        const approval = this.approvedPackages.get(`${name}:${license}`);
        return approval && approval.approved;
    }
    
    async requestPackageApproval(packageInfo, reason) {
        const approvalRequest = {
            id: this.generateRequestId(),
            package: packageInfo.name,
            version: packageInfo.version,
            license: await this.getPackageLicense(packageInfo.name),
            reason: reason,
            requestedBy: process.env.USER || 'unknown',
            requestedAt: new Date().toISOString(),
            status: 'PENDING',
            approvers: []
        };
        
        this.approvalQueue.push(approvalRequest);
        
        // Отправка запроса на одобрение
        await this.notifyForApproval(approvalRequest);
        
        return approvalRequest;
    }
    
    async approvePackage(requestId, approver) {
        const request = this.approvalQueue.find(req => req.id === requestId);
        if (!request) {
            throw new Error('Approval request not found');
        }
        
        if (request.status !== 'PENDING') {
            throw new Error('Request is not pending approval');
        }
        
        request.status = 'APPROVED';
        request.approvers.push({
            user: approver,
            approvedAt: new Date().toISOString()
        });
        
        // Добавление в одобренные пакеты
        this.approvedPackages.set(`${request.package}:${request.license}`, {
            approved: true,
            approvedBy: approver,
            approvedAt: new Date().toISOString(),
            reason: request.reason
        });
        
        return request;
    }
    
    generateRequestId() {
        return `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    async notifyForApproval(request) {
        // Отправка уведомления о запросе одобрения
        console.log(`Approval requested for ${request.package}: ${request.reason}`);
        
        // В реальности интеграция с системами уведомлений
        if (process.env.APPROVAL_WEBHOOK) {
            try {
                await fetch(process.env.APPROVAL_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'PACKAGE_APPROVAL_REQUEST',
                        request: request
                    })
                });
            } catch (error) {
                console.error('Failed to send approval notification:', error);
            }
        }
    }
    
    async getPolicyComplianceReport() {
        const dependencies = await this.getProjectDependencies();
        const results = {};
        
        for (const [name, version] of Object.entries(dependencies)) {
            results[`${name}@${version}`] = await this.validatePackageAgainstPolicy({
                name,
                version,
                specification: `${name}@${version}`
            });
        }
        
        const compliantCount = Object.values(results).filter(r => r.overallCompliance).length;
        const total = Object.keys(results).length;
        
        return {
            timestamp: new Date().toISOString(),
            totalDependencies: total,
            compliantDependencies: compliantCount,
            nonCompliantDependencies: total - compliantCount,
            complianceRate: total > 0 ? (compliantCount / total) * 100 : 0,
            detailedResults: results,
            summary: this.generatePolicySummary(results)
        };
    }
    
    generatePolicySummary(results) {
        const summary = {
            byPolicy: {
                license: { compliant: 0, nonCompliant: 0 },
                version: { compliant: 0, nonCompliant: 0 },
                source: { compliant: 0, nonCompliant: 0 },
                security: { compliant: 0, nonCompliant: 0 },
                quality: { compliant: 0, nonCompliant: 0 }
            },
            bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
            topIssues: []
        };
        
        for (const result of Object.values(results)) {
            // Подсчет по политикам
            if (result.license.compliant) summary.byPolicy.license.compliant++;
            else summary.byPolicy.license.nonCompliant++;
            
            if (result.version.compliant) summary.byPolicy.version.compliant++;
            else summary.byPolicy.version.nonCompliant++;
            
            if (result.source.compliant) summary.byPolicy.source.compliant++;
            else summary.byPolicy.source.nonCompliant++;
            
            if (result.security.compliant) summary.byPolicy.security.compliant++;
            else summary.byPolicy.security.nonCompliant++;
            
            if (result.quality.compliant) summary.byPolicy.quality.compliant++;
            else summary.byPolicy.quality.nonCompliant++;
            
            // Подсчет по тяжести
            for (const issue of [
                ...result.license.issues, 
                ...result.version.issues, 
                ...result.source.issues, 
                ...result.security.issues, 
                ...result.quality.issues
            ]) {
                summary.bySeverity[issue.severity] = (summary.bySeverity[issue.severity] || 0) + 1;
            }
        }
        
        // Топ проблем
        const allIssues = Object.values(results).flatMap(result => [
            ...result.license.issues,
            ...result.version.issues,
            ...result.source.issues,
            ...result.security.issues,
            ...result.quality.issues
        ]);
        
        const issueCounts = {};
        allIssues.forEach(issue => {
            issueCounts[issue.type] = (issueCounts[issue.type] || 0) + 1;
        });
        
        summary.topIssues = Object.entries(issueCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 5)
            .map(([type, count]) => ({ type, count }));
        
        return summary;
    }
    
    async getProjectDependencies() {
        const fs = require('fs');
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        return {
            ...packageJson.dependencies,
            ...packageJson.devDependencies
        };
    }
}

// Использование политики безопасности
const securityPolicy = new DependencySecurityPolicy();

async function validateProjectCompliance() {
    const report = await securityPolicy.getPolicyComplianceReport();
    console.log('Policy Compliance Report:', JSON.stringify(report, null, 2));
    
    if (report.complianceRate < 100) {
        console.error('Policy compliance check failed');
        process.exit(1);
    }
    
    return report;
}
```

### 2. Мониторинг обновлений

```javascript
// Система мониторинга обновлений зависимостей
class DependencyUpdateMonitor {
    constructor(config) {
        this.config = {
            checkInterval: config.checkInterval || 86400000, // 24 часа
            notifyOnUpdates: config.notifyOnUpdates !== false,
            autoUpdateSecurity: config.autoUpdateSecurity || false,
            ...config
        };
        
        this.updateHistory = [];
        this.securityUpdater = new SecureDependencyUpdater();
    }
    
    async startMonitoring() {
        console.log('Starting dependency update monitoring...');
        
        // Немедленная проверка
        await this.performCheck();
        
        // Установка регулярной проверки
        setInterval(async () => {
            await this.performCheck();
        }, this.config.checkInterval);
    }
    
    async performCheck() {
        try {
            const updates = await this.checkForUpdates();
            
            if (updates.securityUpdates.length > 0) {
                console.log(`Found ${updates.securityUpdates.length} security updates`);
                
                if (this.config.autoUpdateSecurity) {
                    await this.securityUpdater.performSecurityUpdate();
                } else if (this.config.notifyOnUpdates) {
                    await this.notifySecurityUpdates(updates.securityUpdates);
                }
            }
            
            if (updates.normalUpdates.length > 0 && this.config.notifyOnUpdates) {
                await this.notifyNormalUpdates(updates.normalUpdates);
            }
            
            this.updateHistory.push({
                timestamp: new Date().toISOString(),
                securityUpdates: updates.securityUpdates.length,
                normalUpdates: updates.normalUpdates.length,
                totalUpdates: updates.securityUpdates.length + updates.normalUpdates.length
            });
            
            // Ограничение истории
            if (this.updateHistory.length > 100) {
                this.updateHistory = this.updateHistory.slice(-100);
            }
            
        } catch (error) {
            console.error('Dependency update check failed:', error);
        }
    }
    
    async checkForUpdates() {
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('npm outdated --json', { encoding: 'utf8' });
            const outdated = JSON.parse(result);
            
            const securityUpdates = [];
            const normalUpdates = [];
            
            for (const [name, info] of Object.entries(outdated)) {
                // Проверка, связаны ли обновления с безопасностью
                const hasSecurityFix = await this.hasSecurityFix(name, info.current, info.wanted);
                
                const updateInfo = {
                    name: name,
                    current: info.current,
                    wanted: info.wanted,
                    latest: info.latest,
                    type: this.getUpdateType(info.current, info.wanted),
                    securityFix: hasSecurityFix
                };
                
                if (hasSecurityFix) {
                    securityUpdates.push(updateInfo);
                } else {
                    normalUpdates.push(updateInfo);
                }
            }
            
            return {
                securityUpdates,
                normalUpdates,
                total: securityUpdates.length + normalUpdates.length
            };
        } catch (error) {
            if (error.stdout) {
                const outdated = JSON.parse(error.stdout);
                // Обработка случая, когда есть устаревшие зависимости (код 1)
                // ... аналогично выше
            }
            return { securityUpdates: [], normalUpdates: [], total: 0 };
        }
    }
    
    async hasSecurityFix(packageName, currentVersion, targetVersion) {
        // Проверка, связано ли обновление с исправлением безопасности
        // В реальности использовать базы данных уязвимостей
        try {
            const vulnsCurrent = await this.checkVulnerabilities(packageName, currentVersion);
            const vulnsTarget = await this.checkVulnerabilities(packageName, targetVersion);
            
            return vulnsCurrent.length > vulnsTarget.length;
        } catch {
            return false; // Если не удалось проверить, предполагаем, что нет
        }
    }
    
    getUpdateType(current, target) {
        const [cMajor, cMinor, cPatch] = current.replace('^', '').replace('~', '').split('.').map(Number);
        const [tMajor, tMinor, tPatch] = target.split('.').map(Number);
        
        if (tMajor > cMajor) return 'major';
        if (tMinor > cMinor) return 'minor';
        if (tPatch > cPatch) return 'patch';
        return 'unknown';
    }
    
    async notifySecurityUpdates(updates) {
        console.log(`SECURITY UPDATES AVAILABLE: ${updates.length} packages`);
        
        for (const update of updates) {
            console.log(`- ${update.name}: ${update.current} → ${update.wanted} (security fix)`);
        }
        
        // В реальности отправка уведомлений в Slack, email и т.д.
        if (process.env.SECURITY_UPDATE_WEBHOOK) {
            try {
                await fetch(process.env.SECURITY_UPDATE_WEBHOOK, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'SECURITY_UPDATES_AVAILABLE',
                        updates: updates,
                        timestamp: new Date().toISOString()
                    })
                });
            } catch (error) {
                console.error('Failed to send security update notification:', error);
            }
        }
    }
    
    async notifyNormalUpdates(updates) {
        console.log(`NORMAL UPDATES AVAILABLE: ${updates.length} packages`);
        
        // В реальности отправка менее приоритетных уведомлений
    }
    
    async getUpdateMetrics() {
        const totalUpdates = this.updateHistory.reduce((sum, check) => sum + check.totalUpdates, 0);
        const securityUpdates = this.updateHistory.reduce((sum, check) => sum + check.securityUpdates, 0);
        const normalUpdates = this.updateHistory.reduce((sum, check) => sum + check.normalUpdates, 0);
        
        const recentChecks = this.updateHistory.slice(-30); // последние 30 проверок
        
        return {
            totalChecks: this.updateHistory.length,
            totalUpdates,
            securityUpdates,
            normalUpdates,
            securityUpdateRate: totalUpdates > 0 ? (securityUpdates / totalUpdates) * 100 : 0,
            averageSecurityUpdatesPerCheck: recentChecks.length > 0 ? 
                recentChecks.reduce((sum, check) => sum + check.securityUpdates, 0) / recentChecks.length : 0,
            updateTrend: this.calculateUpdateTrend(recentChecks)
        };
    }
    
    calculateUpdateTrend(recentChecks) {
        if (recentChecks.length < 2) return 'insufficient_data';
        
        const first = recentChecks[0];
        const last = recentChecks[recentChecks.length - 1];
        
        if (last.securityUpdates > first.securityUpdates) return 'increasing';
        if (last.securityUpdates < first.securityUpdates) return 'decreasing';
        return 'stable';
    }
    
    async generateUpdateDashboard() {
        const metrics = await this.getUpdateMetrics();
        const recentUpdates = this.updateHistory.slice(-10);
        
        return {
            metrics,
            recentChecks: recentUpdates,
            recommendations: this.generateUpdateRecommendations(metrics),
            nextCheck: new Date(Date.now() + this.config.checkInterval).toISOString()
        };
    }
    
    generateUpdateRecommendations(metrics) {
        const recommendations = [];
        
        if (metrics.securityUpdateRate > 30) {
            recommendations.push({
                priority: 'HIGH',
                title: 'High Security Update Frequency',
                description: `Security updates represent ${metrics.securityUpdateRate.toFixed(2)}% of all updates`,
                action: 'Review dependency selection criteria for security posture'
            });
        }
        
        if (metrics.averageSecurityUpdatesPerCheck > 5) {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Frequent Security Updates Needed',
                description: `Average ${metrics.averageSecurityUpdatesPerCheck.toFixed(2)} security updates per check`,
                action: 'Consider updating dependencies more frequently'
            });
        }
        
        if (metrics.updateTrend === 'increasing') {
            recommendations.push({
                priority: 'MEDIUM',
                title: 'Increasing Security Update Trend',
                description: 'Security update frequency is increasing',
                action: 'Investigate root cause and improve dependency security practices'
            });
        }
        
        return recommendations;
    }
}

// Использование монитора обновлений
const updateMonitor = new DependencyUpdateMonitor({
    checkInterval: 3600000, // 1 час
    notifyOnUpdates: true,
    autoUpdateSecurity: false
});

// Запуск мониторинга
updateMonitor.startMonitoring().catch(console.error);
```

## Связанные темы

- [[Сканирование-зависимостей]]
- [[Управление-пакетами]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]
- [[Аудит-безопасности]]