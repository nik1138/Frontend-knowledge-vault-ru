---
aliases: [Client-Side Validation, Проверка на клиенте, Валидация на клиенте]
tags: [security, validation, frontend, spa]
---

# Проверка-на-стороне-клиента

## Обзор

Проверка на стороне клиента (client-side validation) - это процесс валидации данных на стороне пользователя перед их отправкой на сервер. Хотя проверка на клиенте не заменяет серверную валидацию и не обеспечивает полную безопасность, она играет важную роль в создании удобного пользовательского интерфейса и первичной фильтрации недопустимых данных.

## Роль проверки на клиенте в безопасности

### 1. Первоначальная защита

Проверка на клиенте служит первым уровнем защиты, предотвращая отправку заведомо недопустимых данных на сервер:

```javascript
// Пример базовой проверки на клиенте
function validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

function validatePassword(password) {
    // Проверка длины и сложности пароля
    return password.length >= 8 && 
           /[A-Z]/.test(password) && 
           /[a-z]/.test(password) && 
           /[0-9]/.test(password);
}

// Комплексная проверка формы
function validateRegistrationForm(formData) {
    const errors = [];
    
    if (!validateEmail(formData.email)) {
        errors.push('Неверный формат email');
    }
    
    if (!validatePassword(formData.password)) {
        errors.push('Пароль должен содержать не менее 8 символов, включая заглавные, строчные буквы и цифры');
    }
    
    if (formData.password !== formData.confirmPassword) {
        errors.push('Пароли не совпадают');
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
}
```

> [!warning] Важно
> Проверка на стороне клиента никогда не должна быть единственным уровнем защиты. Сервер всегда должен проводить собственную валидацию полученных данных.

### 2. Защита от простых атак

Клиентская проверка может предотвратить отправку очевидно вредоносных данных:

```javascript
// Защита от простых XSS-атак
function sanitizeInput(input) {
    // Удаление потенциально опасных тегов
    return input
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
        .replace(/javascript:/gi, '')
        .replace(/on\w+\s*=/gi, '');
}

// Проверка на потенциально опасные символы
function hasDangerousChars(input) {
    const dangerousPatterns = [
        /<script/i,
        /javascript:/i,
        /vbscript:/i,
        /on\w+\s*=/i,
        /<iframe/i,
        /<object/i,
        /<embed/i
    ];
    
    return dangerousPatterns.some(pattern => pattern.test(input));
}
```

## Типы проверки на клиенте

### 1. Проверка форм

```javascript
// Комплексная система проверки форм
class FormValidator {
    constructor() {
        this.rules = new Map();
    }
    
    addRule(fieldName, validatorFn, errorMessage) {
        if (!this.rules.has(fieldName)) {
            this.rules.set(fieldName, []);
        }
        this.rules.get(fieldName).push({
            validator: validatorFn,
            message: errorMessage
        });
    }
    
    validate(fieldName, value) {
        const fieldRules = this.rules.get(fieldName);
        if (!fieldRules) return { isValid: true, errors: [] };
        
        const errors = [];
        
        for (const rule of fieldRules) {
            if (!rule.validator(value)) {
                errors.push(rule.message);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    
    validateAll(formData) {
        const results = {};
        let isFormValid = true;
        
        for (const [fieldName, value] of Object.entries(formData)) {
            const fieldResult = this.validate(fieldName, value);
            results[fieldName] = fieldResult;
            
            if (!fieldResult.isValid) {
                isFormValid = false;
            }
        }
        
        return {
            isValid: isFormValid,
            fields: results
        };
    }
}

// Использование системы проверки форм
const validator = new FormValidator();

validator.addRule('email', 
    (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    'Введите корректный email'
);

validator.addRule('password',
    (value) => value.length >= 8,
    'Пароль должен содержать не менее 8 символов'
);

validator.addRule('password',
    (value) => /[A-Z]/.test(value),
    'Пароль должен содержать заглавную букву'
);
```

### 2. Проверка типов данных

```javascript
// Проверка типов данных
class TypeValidator {
    static isString(value) {
        return typeof value === 'string';
    }
    
    static isNumber(value) {
        return typeof value === 'number' && !isNaN(value);
    }
    
    static isInteger(value) {
        return Number.isInteger(value);
    }
    
    static isArray(value) {
        return Array.isArray(value);
    }
    
    static isObject(value) {
        return typeof value === 'object' && value !== null && !Array.isArray(value);
    }
    
    static isBoolean(value) {
        return typeof value === 'boolean';
    }
    
    static validateStructure(data, schema) {
        for (const [key, expectedType] of Object.entries(schema)) {
            const value = data[key];
            
            switch (expectedType) {
                case 'string':
                    if (!this.isString(value)) return { valid: false, error: `Поле ${key} должно быть строкой` };
                    break;
                case 'number':
                    if (!this.isNumber(value)) return { valid: false, error: `Поле ${key} должно быть числом` };
                    break;
                case 'integer':
                    if (!this.isInteger(value)) return { valid: false, error: `Поле ${key} должно быть целым числом` };
                    break;
                case 'array':
                    if (!this.isArray(value)) return { valid: false, error: `Поле ${key} должно быть массивом` };
                    break;
                case 'object':
                    if (!this.isObject(value)) return { valid: false, error: `Поле ${key} должно быть объектом` };
                    break;
                case 'boolean':
                    if (!this.isBoolean(value)) return { valid: false, error: `Поле ${key} должно быть булевым значением` };
                    break;
            }
        }
        
        return { valid: true };
    }
}
```

### 3. Проверка формата данных

```javascript
// Проверка формата различных типов данных
class FormatValidator {
    static phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
    static urlRegex = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
    static creditCardRegex = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})$/;
    
    static isPhone(phone) {
        return this.phoneRegex.test(phone);
    }
    
    static isURL(url) {
        return this.urlRegex.test(url);
    }
    
    static isCreditCard(cardNumber) {
        // Удаление пробелов и дефисов
        const cleanNumber = cardNumber.replace(/[\s-]/g, '');
        return this.creditCardRegex.test(cleanNumber) && this.luhnCheck(cleanNumber);
    }
    
    static luhnCheck(cardNumber) {
        let sum = 0;
        let isEven = false;
        
        for (let i = cardNumber.length - 1; i >= 0; i--) {
            let digit = parseInt(cardNumber.charAt(i));
            
            if (isEven) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            
            sum += digit;
            isEven = !isEven;
        }
        
        return sum % 10 === 0;
    }
    
    static isDate(dateString) {
        const date = new Date(dateString);
        return date instanceof Date && !isNaN(date);
    }
    
    static isPostalCode(code, country = 'US') {
        switch (country) {
            case 'US':
                return /^\d{5}(-\d{4})?$/.test(code);
            case 'UK':
                return /^[A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2}$/.test(code);
            case 'CA':
                return /^[A-Za-z]\d[A-Za-z]\s?\d[A-Za-z]\d$/.test(code);
            default:
                return /^[A-Za-z0-9\s\-]{3,10}$/.test(code);
        }
    }
}
```

## Реализация проверки в разных фреймворках

### 1. React с использованием хуков

```javascript
import { useState, useEffect } from 'react';

function useFormValidation(initialState, validationRules) {
    const [values, setValues] = useState(initialState);
    const [errors, setErrors] = useState({});
    const [isSubmitting, setIsSubmitting] = useState(false);

    useEffect(() => {
        if (isSubmitting) {
            const noErrors = Object.keys(errors).length === 0;
            if (noErrors) {
                // Форма валидна, можно отправлять
                handleSubmit();
            } else {
                setIsSubmitting(false);
            }
        }
    }, [errors, isSubmitting]);

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setValues({
            ...values,
            [name]: value
        });
        
        // Валидация при изменении поля
        if (validationRules[name]) {
            const error = validationRules[name](value);
            setErrors({
                ...errors,
                [name]: error || null
            });
        }
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        setIsSubmitting(true);
        
        // Валидация всех полей
        const newErrors = {};
        for (const [fieldName, validator] of Object.entries(validationRules)) {
            const error = validator(values[fieldName]);
            if (error) {
                newErrors[fieldName] = error;
            }
        }
        
        setErrors(newErrors);
    };

    return {
        values,
        errors,
        isSubmitting,
        handleInputChange,
        handleSubmit
    };
}

// Использование хука в компоненте
function RegistrationForm() {
    const validationRules = {
        email: (value) => {
            if (!value) return 'Email обязателен';
            if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) return 'Неверный формат email';
            return null;
        },
        password: (value) => {
            if (!value) return 'Пароль обязателен';
            if (value.length < 8) return 'Пароль должен содержать не менее 8 символов';
            if (!/[A-Z]/.test(value)) return 'Пароль должен содержать заглавную букву';
            if (!/[a-z]/.test(value)) return 'Пароль должен содержать строчную букву';
            if (!/[0-9]/.test(value)) return 'Пароль должен содержать цифру';
            return null;
        }
    };

    const { values, errors, handleInputChange, handleSubmit } = useFormValidation(
        { email: '', password: '' },
        validationRules
    );

    return (
        <form onSubmit={handleSubmit}>
            <div>
                <input
                    type="email"
                    name="email"
                    value={values.email}
                    onChange={handleInputChange}
                    placeholder="Email"
                />
                {errors.email && <span className="error">{errors.email}</span>}
            </div>
            <div>
                <input
                    type="password"
                    name="password"
                    value={values.password}
                    onChange={handleInputChange}
                    placeholder="Пароль"
                />
                {errors.password && <span className="error">{errors.password}</span>}
            </div>
            <button type="submit">Зарегистрироваться</button>
        </form>
    );
}
```

### 2. Проверка при вводе (Real-time validation)

```javascript
// Компонент с проверкой в реальном времени
class RealTimeValidator {
    constructor(inputElement, validationRules) {
        this.input = inputElement;
        this.validationRules = validationRules;
        this.errorElement = this.createErrorElement();
        this.debounceTimer = null;
        
        this.setupValidation();
    }
    
    setupValidation() {
        // Проверка при вводе с задержкой
        this.input.addEventListener('input', (e) => {
            clearTimeout(this.debounceTimer);
            this.debounceTimer = setTimeout(() => {
                this.validate();
            }, 300); // 300ms debounce
        });
        
        // Проверка при потере фокуса
        this.input.addEventListener('blur', () => {
            this.validate();
        });
    }
    
    validate() {
        const value = this.input.value;
        let isValid = true;
        let errorMessage = '';
        
        for (const rule of this.validationRules) {
            if (!rule.validator(value)) {
                isValid = false;
                errorMessage = rule.message;
                break;
            }
        }
        
        this.showValidationResult(isValid, errorMessage);
        return isValid;
    }
    
    showValidationResult(isValid, message) {
        if (isValid) {
            this.input.classList.remove('invalid');
            this.input.classList.add('valid');
            this.errorElement.textContent = '';
            this.errorElement.style.display = 'none';
        } else {
            this.input.classList.remove('valid');
            this.input.classList.add('invalid');
            this.errorElement.textContent = message;
            this.errorElement.style.display = 'block';
        }
    }
    
    createErrorElement() {
        const errorElement = document.createElement('div');
        errorElement.className = 'validation-error';
        errorElement.style.color = 'red';
        errorElement.style.fontSize = '0.8em';
        errorElement.style.display = 'none';
        
        this.input.parentNode.insertBefore(errorElement, this.input.nextSibling);
        return errorElement;
    }
}

// Использование
const emailInput = document.getElementById('email');
const emailValidator = new RealTimeValidator(emailInput, [
    {
        validator: (value) => value.length > 0,
        message: 'Email обязателен'
    },
    {
        validator: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
        message: 'Неверный формат email'
    }
]);
```

## Защита от обхода клиентской валидации

### 1. Обнаружение отключенной валидации

```javascript
// Обнаружение попыток обхода клиентской валидации
class ValidationBypassDetector {
    constructor() {
        this.originalValidate = null;
        this.isTampered = false;
    }
    
    // Защита функций валидации от переопределения
    protectValidationFunction(funcName, func) {
        const self = this;
        
        // Создание защищенной версии функции
        const protectedFunc = function(...args) {
            // Дополнительные проверки целостности
            if (self.isTampered) {
                // Логирование подозрительной активности
                self.logTamperingAttempt();
                return false;
            }
            
            return func.apply(this, args);
        };
        
        // Установка функции как неперезаписываемой
        Object.defineProperty(window, funcName, {
            value: protectedFunc,
            writable: false,
            configurable: false
        });
    }
    
    // Обнаружение отключения проверок
    detectValidationDisabling() {
        // Проверка, не были ли отключены проверки
        const forms = document.querySelectorAll('form');
        
        forms.forEach(form => {
            // Проверка атрибута novalidate
            if (form.hasAttribute('novalidate')) {
                this.logTamperingAttempt('novalidate attribute detected');
            }
            
            // Проверка на удаление обработчиков событий
            const formEvents = $._data ? $._data(form, 'events') : null;
            if (formEvents && !formEvents.submit) {
                this.logTamperingAttempt('submit handler removed');
            }
        });
    }
    
    logTamperingAttempt(details = '') {
        console.warn('Potential validation bypass attempt detected:', details);
        
        // Отправка уведомления на сервер
        fetch('/api/security/validation-bypass', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                timestamp: new Date().toISOString(),
                details,
                userAgent: navigator.userAgent,
                url: window.location.href
            })
        }).catch(err => console.error('Failed to report bypass attempt:', err));
    }
}

const bypassDetector = new ValidationBypassDetector();
```

### 2. Контроль целостности валидации

```javascript
// Контроль целостности клиентской валидации
class ValidationIntegrityChecker {
    constructor() {
        this.originalFunctions = new Map();
        this.setupIntegrityMonitoring();
    }
    
    // Сохранение оригинальных функций валидации
    registerValidationFunction(name, func) {
        this.originalFunctions.set(name, func.toString());
        window[name] = func;
    }
    
    // Периодическая проверка целостности
    setupIntegrityMonitoring() {
        setInterval(() => {
            this.checkIntegrity();
        }, 5000); // проверка каждые 5 секунд
    }
    
    checkIntegrity() {
        for (const [name, originalString] of this.originalFunctions) {
            const currentFunc = window[name];
            if (typeof currentFunc === 'function') {
                const currentString = currentFunc.toString();
                
                if (originalString !== currentString) {
                    console.error(`Validation function ${name} has been modified!`);
                    this.handleIntegrityViolation(name, originalString, currentString);
                }
            }
        }
    }
    
    handleIntegrityViolation(name, original, current) {
        // Восстановление оригинальной функции
        eval(`${name} = ${original}`);
        
        // Логирование инцидента
        this.logIntegrityViolation(name, original, current);
    }
    
    logIntegrityViolation(name, original, current) {
        fetch('/api/security/integrity-violation', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                type: 'validation_function_modified',
                functionName: name,
                original: original.substring(0, 200) + '...', // обрезаем для безопасности
                modified: current.substring(0, 200) + '...',
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent
            })
        });
    }
}

const integrityChecker = new ValidationIntegrityChecker();
```

## Совместимость с серверной валидацией

### 1. Синхронизация правил валидации

```javascript
// Система синхронизации правил валидации
class ValidationRuleSync {
    constructor() {
        this.clientRules = new Map();
        this.serverRules = new Map();
    }
    
    // Загрузка правил валидации с сервера
    async loadServerRules() {
        try {
            const response = await fetch('/api/validation-rules');
            const rules = await response.json();
            
            for (const [field, rule] of Object.entries(rules)) {
                this.serverRules.set(field, rule);
            }
            
            // Синхронизация с клиентскими правилами
            this.syncRules();
        } catch (error) {
            console.error('Failed to load server validation rules:', error);
        }
    }
    
    // Синхронизация правил
    syncRules() {
        for (const [field, serverRule] of this.serverRules) {
            const clientRule = this.clientRules.get(field);
            
            if (!clientRule) {
                // Добавление серверного правила как клиентского
                this.addClientRule(field, this.convertServerRule(serverRule));
            } else {
                // Проверка соответствия правил
                if (!this.rulesMatch(clientRule, serverRule)) {
                    console.warn(`Validation rule mismatch for field ${field}`);
                    // Использование более строгого правила
                    this.updateClientRule(field, this.getStricterRule(clientRule, serverRule));
                }
            }
        }
    }
    
    convertServerRule(serverRule) {
        // Конвертация серверного правила в клиентскую функцию
        switch (serverRule.type) {
            case 'email':
                return (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
            case 'minLength':
                return (value) => value.length >= serverRule.value;
            case 'maxLength':
                return (value) => value.length <= serverRule.value;
            case 'pattern':
                return (value) => new RegExp(serverRule.value).test(value);
            default:
                return () => true; // по умолчанию - проходит проверку
        }
    }
    
    rulesMatch(clientRule, serverRule) {
        // Проверка соответствия правил
        return true; // упрощенная реализация
    }
    
    addClientRule(field, validator) {
        this.clientRules.set(field, validator);
    }
    
    validateField(field, value) {
        const rule = this.clientRules.get(field);
        return rule ? rule(value) : true;
    }
}
```

### 2. Обработка ошибок серверной валидации

```javascript
// Обработка ошибок серверной валидации
class ValidationErrorHandler {
    constructor() {
        this.fieldMap = new Map(); // сопоставление серверных и клиентских полей
    }
    
    // Обработка ошибок валидации от сервера
    handleServerValidationErrors(errors) {
        // Очистка предыдущих ошибок
        this.clearClientErrors();
        
        // Отображение ошибок на соответствующих полях
        for (const [serverField, errorMessages] of Object.entries(errors)) {
            const clientField = this.fieldMap.get(serverField) || serverField;
            this.displayFieldError(clientField, errorMessages);
        }
    }
    
    clearClientErrors() {
        // Очистка всех клиентских ошибок валидации
        const errorElements = document.querySelectorAll('.validation-error');
        errorElements.forEach(el => {
            el.textContent = '';
            el.style.display = 'none';
        });
        
        const inputElements = document.querySelectorAll('input, textarea, select');
        inputElements.forEach(el => {
            el.classList.remove('invalid');
        });
    }
    
    displayFieldError(field, errors) {
        const inputElement = document.querySelector(`[name="${field}"]`);
        if (!inputElement) return;
        
        // Добавление класса ошибки
        inputElement.classList.add('invalid');
        
        // Поиск или создание элемента ошибки
        let errorElement = inputElement.parentNode.querySelector('.validation-error');
        if (!errorElement) {
            errorElement = document.createElement('div');
            errorElement.className = 'validation-error';
            errorElement.style.color = 'red';
            errorElement.style.fontSize = '0.8em';
            inputElement.parentNode.insertBefore(errorElement, inputElement.nextSibling);
        }
        
        // Отображение сообщений об ошибках
        errorElement.textContent = Array.isArray(errors) ? errors.join(', ') : errors;
        errorElement.style.display = 'block';
    }
    
    // Интеграция с отправкой формы
    async submitForm(formData, endpoint) {
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(formData)
            });
            
            if (response.ok) {
                // Успешная отправка
                this.clearClientErrors();
                return await response.json();
            } else if (response.status === 422) {
                // Ошибки валидации
                const errorData = await response.json();
                this.handleServerValidationErrors(errorData.errors);
                return null;
            } else {
                // Другие ошибки
                throw new Error(`Server error: ${response.status}`);
            }
        } catch (error) {
            console.error('Form submission error:', error);
            throw error;
        }
    }
}
```

## Мониторинг и аудит клиентской валидации

### 1. Логирование событий валидации

```javascript
// Служба логирования событий валидации
class ValidationLogger {
    constructor() {
        this.logs = [];
        this.isEnabled = true;
    }
    
    logValidationEvent(eventType, field, value, result, timestamp = Date.now()) {
        if (!this.isEnabled) return;
        
        const logEntry = {
            eventType, // 'validation_start', 'validation_success', 'validation_error'
            field,
            value: this.sanitizeValue(value), // очистка чувствительных данных
            result,
            timestamp,
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        
        this.logs.push(logEntry);
        
        // Отправка логов на сервер для анализа
        this.sendToServer(logEntry);
    }
    
    sanitizeValue(value) {
        // Удаление чувствительных данных из логов
        if (typeof value === 'string') {
            // Замена потенциально чувствительных данных
            return value
                .replace(/\d{3}-\d{2}-\d{4}/g, '***-**-****') // SSN
                .replace(/\d{16}/g, '****-****-****-****') // credit card
                .replace(/\d{10,}/g, '***-phone-number***'); // phone numbers
        }
        return value;
    }
    
    async sendToServer(logEntry) {
        try {
            await fetch('/api/validation-logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(logEntry)
            });
        } catch (error) {
            console.error('Failed to send validation log:', error);
        }
    }
    
    getLogs() {
        return this.logs;
    }
    
    clearLogs() {
        this.logs = [];
    }
}

const validationLogger = new ValidationLogger();
```

### 2. Анализ эффективности валидации

```javascript
// Система анализа эффективности клиентской валидации
class ValidationAnalytics {
    constructor() {
        this.metrics = {
            totalValidations: 0,
            successfulValidations: 0,
            failedValidations: 0,
            averageValidationTime: 0,
            validationBypassAttempts: 0
        };
        
        this.validationTimes = [];
    }
    
    recordValidation(startTime, result) {
        const validationTime = Date.now() - startTime;
        
        this.metrics.totalValidations++;
        this.validationTimes.push(validationTime);
        
        if (result) {
            this.metrics.successfulValidations++;
        } else {
            this.metrics.failedValidations++;
        }
        
        // Обновление среднего времени валидации
        this.metrics.averageValidationTime = 
            this.validationTimes.reduce((a, b) => a + b, 0) / this.validationTimes.length;
    }
    
    recordBypassAttempt() {
        this.metrics.validationBypassAttempts++;
    }
    
    getMetrics() {
        return {
            ...this.metrics,
            successRate: this.metrics.totalValidations > 0 ? 
                (this.metrics.successfulValidations / this.metrics.totalValidations) * 100 : 0
        };
    }
    
    generateReport() {
        const metrics = this.getMetrics();
        
        return `
            Отчет о клиентской валидации:
            - Всего проверок: ${metrics.totalValidations}
            - Успешных проверок: ${metrics.successfulValidations}
            - Неуспешных проверок: ${metrics.failedValidations}
            - Процент успеха: ${metrics.successRate.toFixed(2)}%
            - Среднее время проверки: ${metrics.averageValidationTime.toFixed(2)}ms
            - Попыток обхода: ${metrics.validationBypassAttempts}
        `;
    }
}

const validationAnalytics = new ValidationAnalytics();
```

## Заключение

Проверка на стороне клиента играет важную роль в создании удобного пользовательского интерфейса и первичной фильтрации данных, но она не должна рассматриваться как основной уровень безопасности. Клиентская валидация должна дополнять, а не заменять серверную валидацию.

Эффективная система клиентской валидации включает в себя комплексный подход с использованием различных методов проверки, защиты от обхода, синхронизации с серверными правилами и мониторинга эффективности.

## См. также

- [[Проверка-ввода]]
- [[XSS-защита]]
- [[Безопасность-в-SPA]]
- [[Безопасная-работа-с-API]]
- [[Санитизация-ввода]]