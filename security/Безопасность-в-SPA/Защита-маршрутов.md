---
aliases: [Route Protection, Защита маршрутов, Защита навигации в SPA]
tags: [security, spa, routing, authentication]
---

# Защита-маршрутов

## Обзор

Защита маршрутов в одностраничных приложениях (SPA) - это критически важный аспект безопасности, который предотвращает несанкционированный доступ к защищенным частям приложения. В традиционных веб-приложениях защита маршрутов обычно реализуется на сервере, но в SPA значительная часть логики защиты должна быть реализована на клиенте с дополнительной серверной проверкой.

## Принципы защиты маршрутов

### 1. Двойная проверка

Защита маршрутов должна включать как клиентскую, так и серверную проверку:

- Клиентская проверка: предотвращает доступ к защищенным компонентам
- Серверная проверка: окончательная проверка при выполнении запросов к API

### 2. Централизованное управление

Реализуйте централизованную систему управления доступом к маршрутам:

```javascript
// Пример централизованной системы управления маршрутами
const routeConfig = [
    {
        path: '/',
        component: Home,
        requiresAuth: false
    },
    {
        path: '/dashboard',
        component: Dashboard,
        requiresAuth: true,
        roles: ['user', 'admin']
    },
    {
        path: '/admin',
        component: AdminPanel,
        requiresAuth: true,
        roles: ['admin']
    },
    {
        path: '/profile/:id',
        component: UserProfile,
        requiresAuth: true,
        permissions: ['view_profile']
    }
];
```

## Реализация защиты маршрутов

### 1. Защита на уровне роутера (React Router)

```javascript
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';

// Компонент защищенного маршрута
function ProtectedRoute({ children, requiredRole = null }) {
    const { isAuthenticated, userRole } = useAuth();
    const location = useLocation();

    // Проверка аутентификации
    if (!isAuthenticated) {
        // Перенаправление на страницу входа с сохранением целевого маршрута
        return <Navigate to="/login" state={{ from: location }} replace />;
    }

    // Проверка ролей (если требуется)
    if (requiredRole && userRole !== requiredRole) {
        return <Navigate to="/unauthorized" replace />;
    }

    return children;
}

// Использование защищенного маршрута
function App() {
    return (
        <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/login" element={<Login />} />
            
            <Route 
                path="/dashboard" 
                element={
                    <ProtectedRoute>
                        <Dashboard />
                    </ProtectedRoute>
                } 
            />
            
            <Route 
                path="/admin" 
                element={
                    <ProtectedRoute requiredRole="admin">
                        <AdminPanel />
                    </ProtectedRoute>
                } 
            />
        </Routes>
    );
}
```

### 2. Проверка прав доступа к маршрутам

```javascript
// Система управления разрешениями
class PermissionManager {
    constructor() {
        this.permissions = new Map();
    }

    setPermissions(role, permissions) {
        this.permissions.set(role, permissions);
    }

    hasPermission(userRole, requiredPermission) {
        const userPermissions = this.permissions.get(userRole);
        return userPermissions && userPermissions.includes(requiredPermission);
    }

    canAccessRoute(userRole, routePermissions) {
        if (!routePermissions || routePermissions.length === 0) {
            return true; // маршрут не требует специальных разрешений
        }

        return routePermissions.every(permission => 
            this.hasPermission(userRole, permission)
        );
    }
}

// Использование в защите маршрутов
const permissionManager = new PermissionManager();
permissionManager.setPermissions('admin', ['read', 'write', 'delete', 'manage_users']);
permissionManager.setPermissions('user', ['read', 'update_profile']);

function RouteGuard({ children, requiredPermissions = [] }) {
    const { userRole } = useAuth();
    
    if (!permissionManager.canAccessRoute(userRole, requiredPermissions)) {
        return <Navigate to="/forbidden" replace />;
    }
    
    return children;
}
```

### 3. Динамическая загрузка компонентов

```javascript
// Защита динамически загружаемых компонентов
const LazyProtectedRoute = ({ component: Component, ...props }) => {
    const { isAuthenticated, checkPermission } = useAuth();
    
    useEffect(() => {
        if (!isAuthenticated) {
            navigate('/login');
            return;
        }
        
        if (props.requiredPermission && !checkPermission(props.requiredPermission)) {
            navigate('/unauthorized');
        }
    }, [isAuthenticated, props.requiredPermission]);
    
    if (!isAuthenticated) {
        return <LoadingSpinner />;
    }
    
    return <Component {...props} />;
};

// Использование с динамической загрузкой
const ProtectedDashboard = lazy(() => 
    import('./components/Dashboard').then(module => ({
        default: () => (
            <LazyProtectedRoute 
                component={module.default} 
                requiredPermission="view_dashboard" 
            />
        )
    }))
);
```

## Проверка сеанса при навигации

### 1. Middleware для проверки сеанса

```javascript
// Проверка сеанса перед навигацией
class SessionChecker {
    constructor(authService) {
        this.authService = authService;
    }

    async checkSession() {
        try {
            // Проверка актуальности токена
            const isValid = await this.authService.validateToken();
            
            if (!isValid) {
                // Токен истек, попытка обновления
                const refreshed = await this.authService.refreshToken();
                
                if (!refreshed) {
                    // Обновление не удалось, перенаправление на вход
                    this.redirectToLogin();
                    return false;
                }
            }
            
            return true;
        } catch (error) {
            console.error('Ошибка проверки сеанса:', error);
            this.redirectToLogin();
            return false;
        }
    }

    redirectToLogin() {
        window.location.href = '/login';
    }
}

// Интеграция с системой роутинга
const sessionChecker = new SessionChecker(authService);

// Пример для Vue Router
router.beforeEach(async (to, from, next) => {
    if (to.meta.requiresAuth) {
        const sessionValid = await sessionChecker.checkSession();
        if (sessionValid) {
            next();
        } else {
            next('/login');
        }
    } else {
        next();
    }
});
```

### 2. Защита с учетом срока действия сеанса

```javascript
// Служба управления сеансом
class SessionManager {
    constructor() {
        this.sessionTimeout = 30 * 60 * 1000; // 30 минут
        this.warningTime = 5 * 60 * 1000; // 5 минут до истечения
        this.lastActivity = Date.now();
        this.warningShown = false;
    }

    recordActivity() {
        this.lastActivity = Date.now();
        this.warningShown = false;
    }

    isSessionExpired() {
        return (Date.now() - this.lastActivity) > this.sessionTimeout;
    }

    shouldShowWarning() {
        const timeSinceLastActivity = Date.now() - this.lastActivity;
        return !this.warningShown && 
               timeSinceLastActivity > (this.sessionTimeout - this.warningTime);
    }

    async checkSessionBeforeRoute(to, from, next) {
        if (this.isSessionExpired()) {
            // Сеанс истек, перенаправление на страницу входа
            next('/login?expired=1');
            return;
        }

        if (this.shouldShowWarning()) {
            this.warningShown = true;
            // Показ предупреждения пользователю
            const extendSession = await this.showSessionWarning();
            if (extendSession) {
                this.recordActivity();
                next();
            } else {
                next('/login?expired=1');
            }
            return;
        }

        this.recordActivity();
        next();
    }

    async showSessionWarning() {
        return new Promise(resolve => {
            // Показ модального окна с предупреждением
            const modal = document.createElement('div');
            modal.innerHTML = `
                <div class="session-warning-modal">
                    <p>Ваш сеанс скоро истечет. Продлить сеанс?</p>
                    <button onclick="resolve(true)">Продлить</button>
                    <button onclick="resolve(false)">Выйти</button>
                </div>
            `;
            document.body.appendChild(modal);
        });
    }
}
```

## Защита чувствительных маршрутов

### 1. Защита на основе атрибутов пользователя

```javascript
// Проверка атрибутов пользователя для доступа к маршрутам
function AttributeBasedRouteGuard({ children, requiredAttributes = {} }) {
    const { user } = useAuth();

    const hasRequiredAttributes = () => {
        for (const [attr, value] of Object.entries(requiredAttributes)) {
            if (user[attr] !== value) {
                return false;
            }
        }
        return true;
    };

    if (!hasRequiredAttributes()) {
        return <Navigate to="/access-denied" replace />;
    }

    return children;
}

// Использование
<Route 
    path="/premium-content" 
    element={
        <AttributeBasedRouteGuard requiredAttributes={{ isPremium: true }}>
            <PremiumContent />
        </AttributeBasedRouteGuard>
    } 
/>
```

### 2. Защита на основе идентичности пользователя

```javascript
// Защита маршрутов на основе идентичности пользователя
function OwnerRouteGuard({ children, ownerId }) {
    const { userId } = useAuth();

    if (userId !== ownerId) {
        return <Navigate to="/unauthorized" replace />;
    }

    return children;
}

// Пример для профиля пользователя
<Route 
    path="/profile/:id" 
    element={
        <RouteGuard>
            <UserProfile />
        </RouteGuard>
    } 
/>
```

## Серверная проверка при навигации

### 1. Проверка разрешений на сервере

```javascript
// Пример серверной проверки при загрузке данных маршрута
app.get('/api/route-data/:routeId', async (req, res) => {
    try {
        // Проверка аутентификации
        const user = await authenticateUser(req);
        if (!user) {
            return res.status(401).json({ error: 'Неавторизованный доступ' });
        }

        // Проверка разрешений для конкретного маршрута
        const routeId = req.params.routeId;
        const hasPermission = await checkRoutePermission(user.id, routeId);
        
        if (!hasPermission) {
            return res.status(403).json({ error: 'Доступ запрещен' });
        }

        // Возврат данных для маршрута
        const routeData = await getRouteData(routeId);
        res.json(routeData);
    } catch (error) {
        console.error('Ошибка проверки маршрута:', error);
        res.status(500).json({ error: 'Внутренняя ошибка сервера' });
    }
});
```

### 2. Проверка на уровне API-вызовов

```javascript
// Клиентская обертка для проверки доступа к маршрутам
class SecureRouteClient {
    constructor(baseURL) {
        this.baseURL = baseURL;
    }

    async checkRouteAccess(routeId) {
        try {
            const response = await fetch(`${this.baseURL}/api/route-access/${routeId}`, {
                headers: {
                    'Authorization': `Bearer ${getAuthToken()}`
                }
            });

            if (response.status === 401) {
                // Перенаправление на страницу входа
                window.location.href = '/login';
                return false;
            }

            if (response.status === 403) {
                // Доступ запрещен
                window.location.href = '/unauthorized';
                return false;
            }

            return response.ok;
        } catch (error) {
            console.error('Ошибка проверки доступа к маршруту:', error);
            return false;
        }
    }
}
```

## Обработка ошибок доступа

### 1. Страницы ошибок доступа

```javascript
// Компоненты страниц ошибок
function UnauthorizedPage() {
    return (
        <div className="error-page">
            <h1>401 - Неавторизованный доступ</h1>
            <p>Вам нужно войти в систему для доступа к этой странице.</p>
            <Link to="/login">Войти</Link>
        </div>
    );
}

function ForbiddenPage() {
    return (
        <div className="error-page">
            <h1>403 - Доступ запрещен</h1>
            <p>У вас недостаточно прав для доступа к этой странице.</p>
            <Link to="/">На главную</Link>
        </div>
    );
}

function NotFoundPage() {
    return (
        <div className="error-page">
            <h1>404 - Страница не найдена</h1>
            <p>Запрашиваемая страница не существует.</p>
            <Link to="/">На главную</Link>
        </div>
    );
}
```

### 2. Глобальная обработка ошибок доступа

```javascript
// Глобальный обработчик ошибок доступа
class AccessErrorHandler {
    constructor() {
        this.errorHandlers = new Map();
    }

    registerHandler(errorCode, handler) {
        this.errorHandlers.set(errorCode, handler);
    }

    handleError(errorCode, errorData) {
        const handler = this.errorHandlers.get(errorCode);
        if (handler) {
            handler(errorData);
        } else {
            this.defaultErrorHandler(errorCode, errorData);
        }
    }

    defaultErrorHandler(errorCode, errorData) {
        switch (errorCode) {
            case 401:
                window.location.href = '/login';
                break;
            case 403:
                window.location.href = '/forbidden';
                break;
            case 404:
                window.location.href = '/not-found';
                break;
            default:
                console.error('Неизвестная ошибка:', errorCode, errorData);
        }
    }
}

const accessErrorHandler = new AccessErrorHandler();
```

## Мониторинг и аудит доступа к маршрутам

### 1. Логирование попыток доступа

```javascript
// Служба логирования доступа к маршрутам
class RouteAccessLogger {
    constructor() {
        this.logs = [];
    }

    logAccessAttempt(route, userId, timestamp, result) {
        const logEntry = {
            route,
            userId: userId || 'anonymous',
            timestamp,
            result, // 'granted', 'denied', 'error'
            userAgent: navigator.userAgent,
            ip: null // будет заполнено на сервере
        };

        this.logs.push(logEntry);

        // Отправка логов на сервер для аудита
        this.sendToAuditServer(logEntry);
    }

    async sendToAuditServer(logEntry) {
        try {
            await fetch('/api/audit/access', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(logEntry)
            });
        } catch (error) {
            console.error('Ошибка отправки лога доступа:', error);
        }
    }
}

const routeAccessLogger = new RouteAccessLogger();
```

### 2. Анализ аномального поведения

```javascript
// Система обнаружения аномального поведения
class AnomalyDetector {
    constructor() {
        this.accessPatterns = new Map();
    }

    recordAccess(userId, route, timestamp) {
        if (!this.accessPatterns.has(userId)) {
            this.accessPatterns.set(userId, []);
        }

        const userAccesses = this.accessPatterns.get(userId);
        userAccesses.push({ route, timestamp });

        // Удаление старых записей (например, старше 1 часа)
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        const recentAccesses = userAccesses.filter(access => 
            access.timestamp > oneHourAgo
        );
        
        this.accessPatterns.set(userId, recentAccesses);

        // Проверка на аномальное поведение
        if (this.detectAnomaly(userId, recentAccesses)) {
            this.reportAnomaly(userId, recentAccesses);
        }
    }

    detectAnomaly(userId, accesses) {
        // Проверка на чрезмерное количество запросов
        if (accesses.length > 100) { // больше 100 запросов за час
            return true;
        }

        // Проверка на доступ к подозрительным маршрутам
        const suspiciousRoutes = accesses.filter(access => 
            access.route.includes('admin') || access.route.includes('config')
        );

        if (suspiciousRoutes.length > 10) { // больше 10 попыток доступа к админке
            return true;
        }

        return false;
    }

    reportAnomaly(userId, accesses) {
        console.warn(`Обнаружена аномальная активность для пользователя ${userId}:`, accesses);
        // Отправка уведомления в систему безопасности
        sendSecurityAlert({
            type: 'anomalous-access',
            userId,
            accesses,
            timestamp: Date.now()
        });
    }
}

const anomalyDetector = new AnomalyDetector();
```

## Заключение

Защита маршрутов в SPA - это многоуровневый процесс, требующий как клиентской, так и серверной проверки. Эффективная защита включает в себя проверку аутентификации, авторизацию на основе ролей и разрешений, а также мониторинг подозрительной активности.

Реализация надежной системы защиты маршрутов требует комплексного подхода, включающего централизованное управление доступом, проверку сеанса, обработку ошибок и аудит попыток доступа.

## См. также

- [[Безопасность-в-SPA]]
- [[Управление-сессиями-и-аутентификацией]]
- [[Управление-доступом]]
- [[CSRF-защита]]
- [[XSS-защита]]