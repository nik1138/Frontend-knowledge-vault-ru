---
aliases: ["Защита локальных данных", "Безопасность локальных данных"]
tags: ["#security", "#local-storage", "#encryption", "#web-security"]
---

# Защита локальных данных в приложениях с оффлайн-режимом

## Введение в защиту локальных данных

Защита локальных данных в приложениях с оффлайн-режимом является критически важным аспектом безопасности веб-приложений. В условиях, когда данные хранятся непосредственно на устройстве пользователя, разработчики сталкиваются с уникальными вызовами, связанными с обеспечением конфиденциальности, целостности и доступности информации. Локальное хранение данных позволяет приложениям работать автономно, улучшая пользовательский опыт, но одновременно увеличивает поверхность атаки, если данные не защищены должным образом.

В отличие от традиционных веб-приложений, где данные хранятся на сервере под контролем разработчика, оффлайн-приложения полагаются на клиентские технологии хранения, такие как [[IndexedDB]], [[localStorage]], [[sessionStorage]] и файловая система. Эти технологии создают новые векторы атак, включая манипуляции с данными, кражу информации при физическом доступе к устройству и уязвимости, связанные с XSS-атаками. Поэтому разработчики должны применять комплексный подход к защите локальных данных, включающий шифрование, аутентификацию и стратегии управления ключами.

## Типы локальных данных

Локальные данные в приложениях с оффлайн-режимом можно классифицировать по нескольким критериям, включая чувствительность, тип и продолжительность хранения. Понимание этих типов помогает выбрать наиболее подходящие методы защиты.

### Чувствительные персональные данные

К этой категории относятся данные, раскрывающие личность пользователя, такие как имя, адрес, номер телефона, адрес электронной почты, идентификаторы сессий, токены аутентификации и другая информация, которая может быть использована для идентификации или отслеживания пользователя. Такие данные требуют максимального уровня защиты, включая шифрование и ограничение доступа.

### Финансовая информация

Финансовые данные, такие как данные кредитных карт, банковские реквизиты, история транзакций, представляют собой высокую ценность для злоумышленников. Даже если приложение не хранит полные номера кредитных карт, временные токены или частичные данные могут быть использованы в мошеннических целях. Эти данные должны храниться в зашифрованном виде и не должны кэшироваться без необходимости.

### Данные аутентификации

К этой категории относятся пароли, хэши паролей, токены доступа, ключи API и другие данные, используемые для аутентификации и авторизации. Хранение таких данных в открытом виде или с недостаточным уровнем защиты может привести к компрометации аккаунта пользователя. Важно использовать безопасные методы хранения, такие как шифрование с использованием ключей, полученных из мастер-пароля или биометрических данных пользователя.

### Контент пользователя

Контент, созданный или загруженный пользователем, такой как документы, изображения, заметки, может содержать конфиденциальную информацию. Хотя эти данные могут быть менее чувствительными, чем данные аутентификации, их все равно следует защищать от несанкционированного доступа, особенно если пользователь ожидает конфиденциальности.

### Временные и кэшированные данные

Временные файлы, кэшированные ресурсы и другие вспомогательные данные также могут содержать информацию, полезную для злоумышленников. Например, кэшированные API-ответы могут содержать персональные данные или внутренние идентификаторы. Важно управлять сроком жизни таких данных и обеспечивать их безопасное удаление.

## Методы хранения данных

В веб-приложениях с оффлайн-режимом существует несколько методов хранения данных на клиенте, каждый из которых имеет свои особенности, преимущества и ограничения с точки зрения безопасности.

### localStorage и sessionStorage

[[localStorage]] и [[sessionStorage]] предоставляют простой способ хранения строковых данных в браузере. localStorage сохраняет данные до тех пор, пока они не будут явно удалены пользователем или приложением, а sessionStorage сохраняет данные только на время сессии браузера. Оба метода хранения доступны через JavaScript, что делает их уязвимыми для XSS-атак. Данные хранятся в открытом виде и не защищены шифрованием по умолчанию.

### IndexedDB

[[IndexedDB]] — это низкоуровневое API для хранения больших объемов структурированных данных, включая файлы и объекты Blob. Он поддерживает транзакции и позволяет приложениям работать с большими объемами данных офлайн. Однако, как и другие клиентские хранилища, IndexedDB не шифрует данные по умолчанию и может быть доступен из любого JavaScript-кода в том же домене.

### File System Access API

[[File System Access API]] позволяет веб-приложениям читать и записывать файлы в локальной файловой системе пользователя с его явного разрешения. Это более мощный метод, который может использоваться для хранения больших объемов данных или файлов, но также требует особого внимания к безопасности, особенно при обработке пользовательских файлов и предотвращении выхода за пределы разрешенных директорий.

### WebSQL (устаревший)

WebSQL был доступен в некоторых браузерах, но теперь считается устаревшим и не рекомендуется к использованию. Он предоставлял SQL-интерфейс для локального хранения данных, но был заменен IndexedDB.

## Уязвимости локального хранения

Локальные хранилища данных подвержены различным видам уязвимостей, которые могут быть использованы злоумышленниками для получения несанкционированного доступа к информации или манипуляции с ней.

### XSS-атаки

Cross-Site Scripting (XSS) — одна из наиболее распространенных уязвимостей, влияющих на локальные хранилища. Если приложение уязвимо к XSS, злоумышленник может внедрить вредоносный скрипт, который будет выполняться в контексте приложения и получать доступ к данным, хранящимся в localStorage, sessionStorage или IndexedDB. Даже если данные зашифрованы, злоумышленник может получить доступ к ключам шифрования, если они хранятся в открытом виде или легко извлекаемы.

### Уязвимости при физическом доступе

Если злоумышленник получает физический доступ к устройству пользователя, он может получить доступ к локальным данным, если они не защищены должным образом. Это особенно актуально для мобильных устройств, которые легко могут быть украдены или потеряны. Данные в браузере хранятся в файлах на диске, и при определенных условиях злоумышленник может извлечь их с помощью специализированных инструментов.

### Неправильная очистка данных

Приложения могут оставлять следы конфиденциальных данных после удаления или выхода пользователя из системы, если не реализована надлежащая очистка локальных хранилищ. Это может привести к утечке информации, если устройством пользуется другой пользователь или если данные не были удалены должным образом при деинсталляции приложения.

### Отсутствие шифрования

Многие приложения хранят данные в открытом виде, что делает их доступными для любого, кто имеет доступ к файлам браузера или может выполнить JavaScript-код в контексте приложения. Это особенно опасно для чувствительных данных, таких как токены аутентификации или персональная информация.

## Шифрование локальных данных

Шифрование является ключевым методом защиты локальных данных от несанкционированного доступа. Оно преобразует данные в форму, которую невозможно прочитать без соответствующего ключа, обеспечивая конфиденциальность даже в случае компрометации хранилища.

### Симметричное шифрование

Симметричное шифрование использует один и тот же ключ для шифрования и дешифрования данных. Оно быстро и эффективно, но требует безопасного хранения ключа. В веб-приложениях ключ может быть получен из мастер-пароля пользователя или сгенерирован на основе биометрических данных. Однако, если ключ хранится в открытом виде в JavaScript-коде, он может быть скомпрометирован при XSS-атаке.

### Асимметричное шифрование

Асимметричное шифрование использует пару ключей — открытый и закрытый. Оно может быть использовано для шифрования сессионных ключей или для обеспечения конфиденциальности в коммуникациях, но редко используется для шифрования больших объемов данных из-за вычислительной сложности.

### Web Cryptography API

[[Web Cryptography API]] предоставляет набор криптографических функций, доступных в браузере, включая генерацию ключей, шифрование, дешифрование, хэширование и подпись. Она позволяет реализовать надежное шифрование локальных данных, используя современные криптографические алгоритмы, такие как AES-GCM. Однако важно правильно реализовать управление ключами и избегать распространенных ошибок, таких как использование слабых ключей или неправильная генерация случайных чисел.

### Практические рекомендации по шифрованию

При шифровании локальных данных рекомендуется использовать аутентифицированное шифрование, такое как AES-GCM, которое обеспечивает как конфиденциальность, так и целостность данных. Ключи шифрования должны генерироваться криптографически безопасным образом и не должны храниться в открытом виде в коде приложения. Также важно учитывать, что шифрование не защищает от всех атак, особенно от XSS, если ключи доступны из JavaScript.

## Управление криптографическими ключами

Управление криптографическими ключами — это критический аспект безопасности, который часто является самой слабой частью криптографической системы. Неправильное управление ключами может свести на нет все усилия по шифрованию данных.

### Хранение ключей

Ключи не должны храниться в открытом виде в коде приложения или в локальных хранилищах. Вместо этого можно использовать мастер-ключ, который генерируется на основе пароля пользователя (например, с помощью PBKDF2, scrypt или Argon2), или использовать биометрические данные для получения ключа. В мобильных приложениях можно использовать системные хранилища ключей, такие как Android Keystore или iOS Keychain.

### Деривация ключей

Для генерации ключей шифрования из пароля пользователя следует использовать криптографически стойкие функции деривации ключей (KDF), такие как PBKDF2, scrypt или Argon2. Эти функции замедляют процесс генерации ключа, делая атаки методом перебора менее эффективными. Важно использовать случайную соль для каждого ключа, чтобы предотвратить атаки с использованием радужных таблиц.

### Смена ключей

В идеале, ключи должны периодически меняться для снижения риска компрометации. Однако в оффлайн-приложениях это может быть сложно реализовать, так как нет централизованного управления ключами. Тем не менее, можно реализовать механизм обновления ключей при следующем онлайн-соединении или при изменении пароля пользователя.

### Защита ключей от XSS

Даже если ключи защищены, XSS-атака может получить к ним доступ, если они хранятся в памяти JavaScript. Чтобы минимизировать риск, можно использовать изолированные iframe или Web Workers для выполнения криптографических операций, хотя это не обеспечивает полной защиты. Также можно использовать Hardware Security Modules (HSM) или Trusted Platform Module (TPM), если они доступны на устройстве пользователя, хотя это редко реализуемо в веб-приложениях.

## Аутентификация для доступа к данным

Контроль доступа к локальным данным должен быть реализован на уровне приложения, чтобы гарантировать, что только авторизованные пользователи могут получить доступ к своим данным.

### Аутентификация на основе сессии

Приложения могут использовать токены сессии для аутентификации пользователя и предоставления доступа к зашифрованным данным. Эти токены должны быть краткосрочными и обновляться регулярно. Однако в оффлайн-режиме невозможно проверить валидность токена на сервере, поэтому важно реализовать надежное хранение и шифрование токенов.

### Биометрическая аутентификация

Биометрические данные, такие как отпечатки пальцев или распознавание лица, могут быть использованы для аутентификации пользователя и получения доступа к зашифрованным данным. В браузерах это может быть реализовано с помощью Web Authentication API (WebAuthn), хотя поддержка может варьироваться. В мобильных приложениях можно использовать системные API для биометрической аутентификации.

### Мастер-пароль

Пользователь может вводить мастер-пароль при запуске приложения, который используется для деривации ключа шифрования. Этот подход обеспечивает высокий уровень безопасности, но может быть неудобен для пользователей, особенно если они часто открывают приложение.

### Многофакторная аутентификация (MFA)

Хотя MFA в оффлайн-режиме может быть ограничена, можно использовать офлайн-токены или заранее сгенерированные коды для дополнительного уровня аутентификации. Это может быть полезно для доступа к особенно чувствительным данным.

## Доступ к данным из разных источников

Приложения могут загружать и использовать данные из различных источников, включая локальные файлы, удаленные API и другие веб-сайты. Каждый из этих источников может представлять потенциальную угрозу безопасности.

### Загрузка данных из внешних источников

При загрузке данных из внешних источников важно проверять их целостность и происхождение. Использование подписей или хэшей может помочь убедиться, что данные не были изменены. Также важно избегать выполнения кода из внешних источников, чтобы предотвратить XSS и другие атаки.

### CORS и политика безопасности

Cross-Origin Resource Sharing (CORS) и Content Security Policy (CSP) должны быть правильно настроены, чтобы предотвратить доступ к локальным данным из ненадежных источников. CSP может ограничить выполнение JavaScript и загрузку ресурсов, что снижает риск XSS-атак.

### Обработка пользовательских файлов

Если приложение позволяет пользователям загружать файлы, важно проверять их тип, размер и содержимое, чтобы предотвратить выполнение вредоносного кода. Файлы не должны выполняться или интерпретироваться как код, и должны быть изолированы от остальной части приложения.

## Защита от физического доступа

Физический доступ к устройству пользователя может привести к компрометации локальных данных, если они не защищены должным образом. Это особенно актуально для мобильных устройств и ноутбуков.

### Шифрование файловой системы

Операционная система может обеспечивать шифрование всей файловой системы, что защищает данные даже в случае физического доступа к устройству. Однако это не всегда включено по умолчанию и может быть отключено пользователем.

### Блокировка экрана и аутентификация

Использование PIN-кода, пароля или биометрической аутентификации для разблокировки устройства значительно усложняет доступ к данным для злоумышленника. Приложения также могут требовать аутентификацию при каждом запуске или после периода бездействия.

### Защита данных браузера

Данные, хранящиеся в браузере, могут быть защищены с помощью шифрования на уровне браузера, хотя это зависит от реализации конкретного браузера. Некоторые браузеры предлагают функции, такие как защищенные сессии или изолированные контейнеры, которые могут улучшить безопасность.

## Безопасность IndexedDB

[[IndexedDB]] — это мощное хранилище, но оно требует особого внимания к безопасности, особенно при хранении чувствительных данных.

### Ограничения безопасности IndexedDB

IndexedDB подчиняется политике одного источника (same-origin policy), что означает, что данные одного домена недоступны из другого. Однако все данные доступны из любого JavaScript-кода в том же домене, что делает их уязвимыми для XSS-атак.

### Шифрование данных в IndexedDB

Для защиты данных, хранящихся в IndexedDB, рекомендуется использовать шифрование перед сохранением. Это может быть реализовано с помощью Web Cryptography API. Данные должны быть зашифрованы на стороне клиента перед сохранением, и ключи шифрования должны быть защищены от несанкционированного доступа.

### Очистка IndexedDB

При выходе пользователя из системы или удалении приложения важно очищать IndexedDB от конфиденциальных данных. Это можно сделать с помощью метода `deleteDatabase` или путем удаления конкретных записей. Также важно убедиться, что данные действительно удалены и не могут быть восстановлены.

## Безопасность localStorage

[[localStorage]] — это простое хранилище, но оно имеет серьезные ограничения с точки зрения безопасности.

### Уязвимость к XSS

Как и другие клиентские хранилища, localStorage уязвим к XSS-атакам. Любые данные, хранящиеся в localStorage, могут быть прочитаны или изменены вредоносным скриптом. Поэтому не рекомендуется хранить в localStorage чувствительные данные, такие как токены аутентификации или персональная информация.

### Отсутствие шифрования

Данные в localStorage хранятся в открытом виде и могут быть легко прочитаны любым JavaScript-кодом или даже через инструменты разработчика. Это делает его непригодным для хранения конфиденциальной информации без дополнительных мер защиты.

### Очистка localStorage

localStorage не очищается автоматически при закрытии вкладки или браузера, что может привести к утечке данных, если пользователь не вышел из системы. Приложения должны реализовывать механизм очистки localStorage при выходе пользователя или по истечении срока действия сессии.

## Безопасность файловой системы

При использовании [[File System Access API]] или других методов доступа к файловой системе важно учитывать специфические риски и меры безопасности.

### Разрешения и изоляция

Приложения должны запрашивать минимально необходимые разрешения для доступа к файлам. Пользователь должен быть информирован о том, какие файлы доступны приложению, и иметь возможность контролировать этот доступ. Также важно изолировать файлы приложения от других файлов пользователя, чтобы предотвратить несанкционированный доступ или изменение.

### Защита от path traversal

Приложения должны проверять пути к файлам, чтобы предотвратить атаки типа path traversal, когда злоумышленник пытается получить доступ к файлам за пределами разрешенной директории. Все пути должны быть нормализованы и проверяться на соответствие разрешенным директориям.

### Обработка файлов

Файлы, загружаемые или создаваемые приложением, должны быть проверены на наличие вредоносного содержимого. Это особенно важно для исполняемых файлов или файлов, которые могут быть интерпретированы как код. Также важно шифровать чувствительные файлы перед сохранением на диск.

## Очистка локальных данных

Безопасная очистка локальных данных необходима для предотвращения утечки информации при выходе пользователя из системы, удалении приложения или деинсталляции браузера.

### Очистка localStorage и sessionStorage

При выходе пользователя из системы приложение должно очищать localStorage и sessionStorage от всех конфиденциальных данных. Это можно сделать с помощью методов `localStorage.clear()` и `sessionStorage.clear()`, или путем удаления конкретных ключей. Важно также учитывать, что sessionStorage автоматически очищается при закрытии вкладки.

### Очистка IndexedDB

Для очистки IndexedDB можно использовать метод `deleteDatabase` или удалять конкретные записи из базы данных. Важно убедиться, что все базы данных, используемые приложением, очищаются должным образом. Также можно использовать транзакции для атомарного удаления данных.

### Очистка файлов

Если приложение создает файлы в локальной файловой системе, важно удалять их при выходе пользователя или удалении приложения. Это можно сделать с помощью File System Access API или других методов доступа к файловой системе. Также важно убедиться, что файлы действительно удалены и не могут быть восстановлены.

### Управление кэшем

Кэшированные данные, такие как изображения, скрипты или API-ответы, также могут содержать конфиденциальную информацию. Приложения должны управлять сроком жизни кэша и очищать его при необходимости. Это можно сделать с помощью Cache API или других механизмов кэширования.

## Лучшие практики

Следование лучшим практикам по защите локальных данных помогает минимизировать риски и обеспечить высокий уровень безопасности приложения.

### Минимизация объема хранимых данных

Не храните больше данных, чем необходимо. Удаляйте временные и ненужные данные как можно скорее. Это снижает вероятность утечки информации и упрощает управление безопасностью.

### Использование HTTPS

Все взаимодействие с сервером должно происходить по защищенному протоколу HTTPS, чтобы предотвратить перехват данных при передаче. Это особенно важно для токенов аутентификации и других чувствительных данных.

### Регулярное обновление зависимостей

Используйте последние версии библиотек и фреймворков, чтобы избежать известных уязвимостей. Регулярно проверяйте зависимости на наличие уязвимостей с помощью инструментов, таких как npm audit или dependabot.

### Тестирование на уязвимости

Регулярно тестируйте приложение на наличие XSS, CSRF и других уязвимостей. Используйте инструменты автоматического сканирования и проводите ручное тестирование. Также важно обучать разработчиков безопасному кодированию.

### Документирование и аудит

Ведите документацию по архитектуре безопасности приложения и проводите регулярные аудиты. Это помогает выявлять потенциальные проблемы и обеспечивает прозрачность процесса разработки.

## Ссылки на другие связанные файлы

- [[Cross-Site-Scripting]]
- [[Content-Security-Policy]]
- [[Web-Cryptography-API]]
- [[IndexedDB]]
- [[localStorage]]
- [[File-System-Access-API]]
- [[Authentication-Methods]]
- [[Session-Management]]
- [[Data-Encryption-Standards]]
- [[Mobile-Security-Best-Practices]]
- [[Browser-Security-Features]]
- [[Secure-Coding-Guidelines]]

## Теги

#security #local-storage #encryption #web-security #data-protection #authentication #xss #csp #indexeddb #localstorage #files #mobile-security #secure-coding