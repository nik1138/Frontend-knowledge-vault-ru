---
aliases: ["Шифрование в реальном времени", "Real-time Encryption", "RT Encryption"]
tags: [security, encryption, real-time, web-security]
---

# Реальное время шифрование

## Введение

Шифрование в реальном времени — это критически важный аспект безопасности современных веб-приложений, особенно в системах, где данные передаются и обрабатываются с минимальной задержкой. В отличие от традиционного шифрования, которое может быть выполнено до хранения или передачи данных, шифрование в реальном времени должно происходить мгновенно, без заметной задержки для пользователя. Это требует специфических подходов и оптимизаций для обеспечения как безопасности, так и производительности.

## Основные концепции шифрования в реальном времени

### Что такое шифрование в реальном времени

Шифрование в реальном времени — это процесс защиты данных, который происходит мгновенно при передаче или обработке информации в системах с минимальной задержкой. Это включает:

- Шифрование сообщений в чатах и мессенджерах
- Защита финансовых транзакций в реальном времени
- Шифрование данных сенсоров IoT
- Защита потокового контента
- Шифрование данных в играх и приложениях реального времени

### Уникальные вызовы шифрования в реальном времени

1. **Производительность** — шифрование не должно замедлять передачу данных
2. **Масштабируемость** — система должна обрабатывать большое количество операций
3. **Безопасность ключей** — управление ключами в динамической среде
4. **Синхронизация** — обеспечение согласованности зашифрованных данных
5. **Совместимость** — поддержка различных клиентов и платформ

## Алгоритмы шифрования для реального времени

### Симметричное шифрование

Симметричное шифрование наиболее подходит для реального времени из-за своей высокой скорости:

```javascript
// Реализация AES-GCM для шифрования в реальном времени
class RealTimeEncryption {
  constructor() {
    this.algorithms = {
      'AES-GCM': {
        name: 'AES-GCM',
        length: 256
      },
      'ChaCha20-Poly1305': {
        name: 'ChaCha20-Poly1305',
        length: 256
      }
    };
  }

  async generateKey(algorithm = 'AES-GCM') {
    const keyAlgorithm = this.algorithms[algorithm];
    if (!keyAlgorithm) {
      throw new Error(`Неподдерживаемый алгоритм: ${algorithm}`);
    }

    return await crypto.subtle.generateKey(
      {
        name: keyAlgorithm.name,
        length: keyAlgorithm.length
      },
      true,
      ['encrypt', 'decrypt']
    );
  }

  async encrypt(data, key, additionalData = null) {
    // Генерируем случайный IV для каждого шифрования
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV для AES-GCM
    
    // Подготавливаем данные для шифрования
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    
    try {
      const encryptedData = await crypto.subtle.encrypt(
        {
          name: key.algorithm.name,
          iv: iv,
          additionalData: additionalData ? new TextEncoder().encode(additionalData) : null
        },
        key,
        encodedData
      );

      // Возвращаем зашифрованные данные с IV
      return {
        encrypted: Array.from(new Uint8Array(encryptedData)),
        iv: Array.from(iv),
        algorithm: key.algorithm.name
      };
    } catch (error) {
      throw new Error(`Ошибка шифрования: ${error.message}`);
    }
  }

  async decrypt(encryptedPackage, key) {
    const iv = new Uint8Array(encryptedPackage.iv);
    const data = new Uint8Array(encryptedPackage.encrypted);
    
    try {
      const decryptedData = await crypto.subtle.decrypt(
        {
          name: key.algorithm.name,
          iv: iv
        },
        key,
        data
      );

      const decoder = new TextDecoder();
      return JSON.parse(decoder.decode(decryptedData));
    } catch (error) {
      throw new Error(`Ошибка расшифровки: ${error.message}`);
    }
  }
}

// Пример использования
const rte = new RealTimeEncryption();
const key = await rte.generateKey('AES-GCM');

const originalData = { message: 'Секретное сообщение', timestamp: Date.now() };
const encrypted = await rte.encrypt(originalData, key);
const decrypted = await rte.decrypt(encrypted, key);

console.log('Оригинал:', originalData);
console.log('Расшифровано:', decrypted);
```

### Асимметричное шифрование для ключей

Для безопасного обмена симметричными ключами используется асимметричное шифрование:

```javascript
// Обмен ключами с использованием ECDH
class KeyExchangeManager {
  constructor() {
    this.keyPairs = new Map();
  }

  async generateKeyPair() {
    return await crypto.subtle.generateKey(
      {
        name: 'ECDH',
        namedCurve: 'P-256'
      },
      true,
      ['deriveKey']
    );
  }

  async exportPublicKey(keyPair) {
    const exported = await crypto.subtle.exportKey('jwk', keyPair.publicKey);
    return JSON.stringify(exported);
  }

  async importPublicKey(publicKeyJWK) {
    const jwk = JSON.parse(publicKeyJWK);
    return await crypto.subtle.importKey(
      'jwk',
      jwk,
      {
        name: 'ECDH',
        namedCurve: 'P-256'
      },
      true,
      []
    );
  }

  async deriveSharedKey(privateKey, peerPublicKey) {
    const sharedSecret = await crypto.subtle.deriveKey(
      {
        name: 'ECDH',
        public: peerPublicKey
      },
      privateKey,
      {
        name: 'AES-GCM',
        length: 256
      },
      true,
      ['encrypt', 'decrypt']
    );

    return sharedSecret;
  }

  async secureKeyExchange(localPublicKey, peerPublicKey) {
    // Импортируем публичный ключ партнера
    const importedPeerKey = await this.importPublicKey(peerPublicKey);
    
    // Получаем нашу пару ключей
    const localKeyPair = await this.generateKeyPair();
    
    // Выводим общий ключ для шифрования
    const sharedKey = await this.deriveSharedKey(localKeyPair.privateKey, importedPeerKey);
    
    return {
      sharedKey,
      localPublicKey: await this.exportPublicKey(localKeyPair)
    };
  }
}
```

## Реализация шифрования для различных сценариев

### Шифрование сообщений в чате

```javascript
// Менеджер шифрования для чат-приложения
class ChatEncryptionManager {
  constructor() {
    this.roomKeys = new Map(); // roomId -> key
    this.userKeys = new Map(); // userId -> key
    this.encryption = new RealTimeEncryption();
  }

  async initializeRoom(roomId, participants) {
    // Генерируем общий ключ для комнаты
    const roomKey = await this.encryption.generateKey();
    this.roomKeys.set(roomId, roomKey);

    // Можем также сгенерировать индивидуальные ключи для участников
    for (const userId of participants) {
      const userKey = await this.encryption.generateKey();
      this.userKeys.set(userId, userKey);
    }
  }

  async encryptMessage(message, roomId, senderId) {
    const roomKey = this.roomKeys.get(roomId);
    if (!roomKey) {
      throw new Error(`Ключ для комнаты ${roomId} не найден`);
    }

    // Добавляем метаданные к сообщению
    const messageWithMetadata = {
      content: message.content,
      senderId,
      timestamp: Date.now(),
      messageId: crypto.randomUUID()
    };

    return await this.encryption.encrypt(messageWithMetadata, roomKey);
  }

  async decryptMessage(encryptedMessage, roomId) {
    const roomKey = this.roomKeys.get(roomId);
    if (!roomKey) {
      throw new Error(`Ключ для комнаты ${roomId} не найден`);
    }

    return await this.encryption.decrypt(encryptedMessage, roomKey);
  }

  // Шифрование для конкретного пользователя (DM)
  async encryptDirectMessage(message, senderId, recipientId) {
    // Используем ключ получателя
    const recipientKey = this.userKeys.get(recipientId);
    if (!recipientKey) {
      throw new Error(`Ключ для пользователя ${recipientId} не найден`);
    }

    const messageWithMetadata = {
      content: message,
      senderId,
      timestamp: Date.now(),
      type: 'direct'
    };

    return await this.encryption.encrypt(messageWithMetadata, recipientKey);
  }

  // Групповое шифрование с разными ключами для разных пользователей
  async encryptForMultipleRecipients(message, senderId, recipientIds) {
    const encryptedMessages = new Map();

    for (const recipientId of recipientIds) {
      const recipientKey = this.userKeys.get(recipientId);
      if (recipientKey) {
        const encrypted = await this.encryptDirectMessage(message, senderId, recipientId);
        encryptedMessages.set(recipientId, encrypted);
      }
    }

    return encryptedMessages;
  }
}
```

### Шифрование финансовых транзакций

```javascript
// Шифрование финансовых данных в реальном времени
class FinancialEncryption {
  constructor() {
    this.encryption = new RealTimeEncryption();
    this.transactionKeys = new Map(); // transactionId -> key
  }

  async encryptTransaction(transaction) {
    // Создаем уникальный ключ для каждой транзакции
    const transactionKey = await this.encryption.generateKey();
    const transactionId = transaction.id || crypto.randomUUID();
    
    this.transactionKeys.set(transactionId, transactionKey);

    // Чувствительные данные для шифрования
    const sensitiveData = {
      amount: transaction.amount,
      accountNumber: transaction.accountNumber,
      cardNumber: transaction.cardNumber,
      cvv: transaction.cvv,
      timestamp: transaction.timestamp || Date.now()
    };

    // Оставляем только ненуждающиеся в шифровании данные открытыми
    const publicData = {
      transactionId,
      status: 'pending',
      currency: transaction.currency
    };

    const encryptedSensitive = await this.encryption.encrypt(sensitiveData, transactionKey);

    return {
      ...publicData,
      encryptedData: encryptedSensitive,
      requiresDecryption: true
    };
  }

  async decryptTransaction(encryptedTransaction, transactionId) {
    const transactionKey = this.transactionKeys.get(transactionId);
    if (!transactionKey) {
      throw new Error(`Ключ для транзакции ${transactionId} не найден`);
    }

    const decryptedData = await this.encryption.decrypt(encryptedTransaction.encryptedData, transactionKey);
    
    // Возвращаем полные данные транзакции
    return {
      ...encryptedTransaction,
      ...decryptedData,
      requiresDecryption: false
    };
  }

  // Шифрование с аутентификацией
  async encryptWithAuthentication(transaction, authData) {
    const sensitiveData = {
      ...transaction,
      auth: authData,
      authTimestamp: Date.now()
    };

    const key = await this.encryption.generateKey();
    return await this.encryption.encrypt(sensitiveData, key, JSON.stringify(authData));
  }
}
```

### Шифрование данных IoT-устройств

```javascript
// Шифрование данных от IoT-устройств в реальном времени
class IoTDataEncryption {
  constructor() {
    this.deviceKeys = new Map(); // deviceId -> key
    this.encryption = new RealTimeEncryption();
  }

  async registerDevice(deviceId, devicePublicKey) {
    // Генерируем сессионный ключ для устройства
    const sessionKey = await this.encryption.generateKey();
    this.deviceKeys.set(deviceId, sessionKey);

    // Можем также выполнить обмен ключами
    return sessionKey;
  }

  async encryptDeviceData(deviceId, sensorData) {
    const deviceKey = this.deviceKeys.get(deviceId);
    if (!deviceKey) {
      throw new Error(`Ключ для устройства ${deviceId} не найден`);
    }

    // Добавляем метаданные датчика
    const dataWithMetadata = {
      deviceId,
      sensorData,
      timestamp: Date.now(),
      sequenceNumber: this.generateSequenceNumber(deviceId)
    };

    return await this.encryption.encrypt(dataWithMetadata, deviceKey);
  }

  async decryptDeviceData(encryptedData, deviceId) {
    const deviceKey = this.deviceKeys.get(deviceId);
    if (!deviceKey) {
      throw new Error(`Ключ для устройства ${deviceId} не найден`);
    }

    return await this.encryption.decrypt(encryptedData, deviceKey);
  }

  generateSequenceNumber(deviceId) {
    if (!this.sequenceNumbers) this.sequenceNumbers = new Map();
    
    const current = this.sequenceNumbers.get(deviceId) || 0;
    this.sequenceNumbers.set(deviceId, current + 1);
    return current;
  }

  // Шифрование с проверкой целостности
  async encryptWithIntegrity(deviceId, sensorData) {
    const deviceKey = this.deviceKeys.get(deviceId);
    if (!deviceKey) {
      throw new Error(`Ключ для устройства ${deviceId} не найден`);
    }

    // Создаем хэш данных для проверки целостности
    const dataString = JSON.stringify(sensorData);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(dataString));
    const hash = Array.from(new Uint8Array(hashBuffer));

    const dataWithIntegrity = {
      ...sensorData,
      integrityHash: hash
    };

    return await this.encryption.encrypt(dataWithIntegrity, deviceKey);
  }
}
```

## Оптимизация производительности

### Кэширование ключей

```javascript
// Менеджер кэширования ключей для оптимизации производительности
class KeyCacheManager {
  constructor(maxSize = 1000, ttl = 3600000) { // 1 час
    this.cache = new Map();
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  async getOrCreateKey(identifier, keyGenerator) {
    const cached = this.cache.get(identifier);
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.key;
    }

    // Удаляем устаревшие ключи при необходимости
    if (this.cache.size >= this.maxSize) {
      this.cleanupCache();
    }

    // Генерируем новый ключ
    const key = await keyGenerator();
    
    this.cache.set(identifier, {
      key,
      timestamp: Date.now()
    });

    return key;
  }

  cleanupCache() {
    const now = Date.now();
    for (const [identifier, cached] of this.cache) {
      if (now - cached.timestamp >= this.ttl) {
        this.cache.delete(identifier);
      }
    }

    // Если все еще превышаем размер, удаляем старейшие
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
  }

  removeKey(identifier) {
    this.cache.delete(identifier);
  }

  clear() {
    this.cache.clear();
  }
}

// Использование кэширования ключей
class OptimizedRealTimeEncryption {
  constructor() {
    this.keyCache = new KeyCacheManager();
    this.encryption = new RealTimeEncryption();
  }

  async encryptWithCachedKey(data, identifier) {
    const key = await this.keyCache.getOrCreateKey(identifier, () => {
      return this.encryption.generateKey();
    });

    return await this.encryption.encrypt(data, key);
  }

  async decryptWithCachedKey(encryptedData, identifier) {
    const cached = this.keyCache.cache.get(identifier);
    if (!cached) {
      throw new Error(`Ключ для ${identifier} не найден в кэше`);
    }

    return await this.encryption.decrypt(encryptedData, cached.key);
  }
}
```

### Пакетная обработка

```javascript
// Пакетное шифрование для повышения производительности
class BatchEncryptionProcessor {
  constructor(batchSize = 100, delay = 10) { // 100 элементов, 10мс задержка
    this.batchSize = batchSize;
    this.delay = delay;
    this.pendingItems = [];
    this.encryption = new RealTimeEncryption();
  }

  async addToBatch(item, key) {
    return new Promise((resolve, reject) => {
      this.pendingItems.push({
        item,
        key,
        resolve,
        reject
      });

      // Если достигли размера пакета, обрабатываем
      if (this.pendingItems.length >= this.batchSize) {
        this.processBatch();
      } else {
        // Или ждем немного перед обработкой
        setTimeout(() => {
          if (this.pendingItems.length > 0) {
            this.processBatch();
          }
        }, this.delay);
      }
    });
  }

  async processBatch() {
    const items = [...this.pendingItems];
    this.pendingItems = [];

    try {
      // Обрабатываем все элементы пакета
      const results = await Promise.all(
        items.map(async (item) => {
          try {
            const encrypted = await this.encryption.encrypt(item.item, item.key);
            return { success: true, encrypted, original: item };
          } catch (error) {
            return { success: false, error, original: item };
          }
        })
      );

      // Возвращаем результаты
      results.forEach((result, index) => {
        if (result.success) {
          items[index].resolve(result.encrypted);
        } else {
          items[index].reject(result.error);
        }
      });
    } catch (error) {
      // Если вся пачка не удалась, отклоняем все
      items.forEach(item => item.reject(error));
    }
  }
}
```

## Управление ключами в реальном времени

### Динамическое управление ключами

```javascript
// Система управления ключами в реальном времени
class DynamicKeyManager {
  constructor() {
    this.keys = new Map();
    this.keyRotationInterval = 24 * 60 * 60 * 1000; // 24 часа
    this.startKeyRotation();
  }

  async createKey(identifier, algorithm = 'AES-GCM') {
    const key = await this.generateKey(algorithm);
    
    this.keys.set(identifier, {
      key,
      createdAt: Date.now(),
      algorithm,
      rotationTime: Date.now() + this.keyRotationInterval
    });

    return key;
  }

  async rotateKey(identifier) {
    const oldKeyData = this.keys.get(identifier);
    if (!oldKeyData) {
      throw new Error(`Ключ для ${identifier} не найден`);
    }

    // Создаем новый ключ
    const newKey = await this.generateKey(oldKeyData.algorithm);
    
    // Обновляем данные ключа
    this.keys.set(identifier, {
      key: newKey,
      createdAt: Date.now(),
      algorithm: oldKeyData.algorithm,
      rotationTime: Date.now() + this.keyRotationInterval,
      oldKey: oldKeyData.key // Сохраняем старый ключ для расшифровки старых данных
    });

    return newKey;
  }

  async generateKey(algorithm) {
    switch (algorithm) {
      case 'AES-GCM':
        return await crypto.subtle.generateKey(
          { name: 'AES-GCM', length: 256 },
          true,
          ['encrypt', 'decrypt']
        );
      case 'ChaCha20-Poly1305':
        return await crypto.subtle.generateKey(
          { name: 'ChaCha20-Poly1305', length: 256 },
          true,
          ['encrypt', 'decrypt']
        );
      default:
        throw new Error(`Неподдерживаемый алгоритм: ${algorithm}`);
    }
  }

  getKey(identifier) {
    const keyData = this.keys.get(identifier);
    return keyData ? keyData.key : null;
  }

  async encrypt(data, identifier) {
    let keyData = this.keys.get(identifier);
    
    // Проверяем, нужно ли обновить ключ
    if (keyData && Date.now() > keyData.rotationTime) {
      await this.rotateKey(identifier);
      keyData = this.keys.get(identifier);
    }

    if (!keyData) {
      throw new Error(`Ключ для ${identifier} не найден и не может быть создан`);
    }

    return await this.encryptWithKey(data, keyData.key);
  }

  async decrypt(encryptedData, identifier) {
    const keyData = this.keys.get(identifier);
    if (!keyData) {
      throw new Error(`Ключ для ${identifier} не найден`);
    }

    return await this.decryptWithKey(encryptedData, keyData.key);
  }

  async encryptWithKey(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    
    const encryptedData = await crypto.subtle.encrypt(
      { name: key.algorithm.name, iv },
      key,
      encodedData
    );

    return {
      encrypted: Array.from(new Uint8Array(encryptedData)),
      iv: Array.from(iv),
      algorithm: key.algorithm.name
    };
  }

  async decryptWithKey(encryptedPackage, key) {
    const iv = new Uint8Array(encryptedPackage.iv);
    const data = new Uint8Array(encryptedPackage.encrypted);
    
    const decryptedData = await crypto.subtle.decrypt(
      { name: key.algorithm.name, iv },
      key,
      data
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedData));
  }

  startKeyRotation() {
    setInterval(() => {
      const now = Date.now();
      for (const [identifier, keyData] of this.keys) {
        if (now > keyData.rotationTime) {
          this.rotateKey(identifier).catch(console.error);
        }
      }
    }, this.keyRotationInterval / 10); // Проверяем каждые 2.4 часа
  }

  async revokeKey(identifier) {
    this.keys.delete(identifier);
  }
}
```

## Интеграция с WebSocket и SSE

### Шифрование WebSocket-сообщений

```javascript
// Шифрование сообщений через WebSocket
class SecureWebSocket {
  constructor(ws, encryptionManager) {
    this.ws = ws;
    this.encryptionManager = encryptionManager;
    this.connectionId = crypto.randomUUID();
    
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.ws.on('message', async (data) => {
      try {
        // Данные могут быть зашифрованы
        const message = await this.decryptMessage(data);
        this.handleDecryptedMessage(message);
      } catch (error) {
        console.error('Ошибка обработки сообщения:', error);
        this.handleErrorMessage(error);
      }
    });
  }

  async sendEncryptedMessage(message, recipientId = null) {
    try {
      // Шифруем сообщение
      const encryptedMessage = await this.encryptionManager.encrypt(
        message,
        recipientId || this.connectionId
      );

      // Отправляем зашифрованное сообщение
      this.ws.send(JSON.stringify({
        type: 'encrypted_message',
        data: encryptedMessage,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.error('Ошибка отправки зашифрованного сообщения:', error);
    }
  }

  async decryptMessage(data) {
    const parsedData = JSON.parse(data.toString());

    if (parsedData.type === 'encrypted_message') {
      // Расшифровываем сообщение
      return await this.encryptionManager.decrypt(
        parsedData.data,
        this.connectionId
      );
    }

    // Если сообщение не зашифровано, возвращаем как есть
    return parsedData;
  }

  handleDecryptedMessage(message) {
    // Обрабатываем расшифрованное сообщение
    console.log('Получено расшифрованное сообщение:', message);
    
    // Здесь можно вызвать соответствующий обработчик
    this.dispatchMessage(message);
  }

  handleErrorMessage(error) {
    this.ws.send(JSON.stringify({
      type: 'error',
      message: 'Ошибка расшифровки сообщения'
    }));
  }

  dispatchMessage(message) {
    // Диспетчеризация сообщений по типам
    switch (message.type) {
      case 'chat':
        this.handleChatMessage(message);
        break;
      case 'file':
        this.handleFileMessage(message);
        break;
      default:
        console.warn('Неизвестный тип сообщения:', message.type);
    }
  }

  handleChatMessage(message) {
    // Обработка чат-сообщения
    console.log('Чат-сообщение:', message.content);
  }

  handleFileMessage(message) {
    // Обработка файлового сообщения
    console.log('Файловое сообщение:', message.fileInfo);
  }
}
```

### Шифрование SSE-данных

```javascript
// Шифрование данных для Server-Sent Events
class SecureSSEServer {
  constructor(app, encryptionManager) {
    this.app = app;
    this.encryptionManager = encryptionManager;
    this.connections = new Map();
  }

  setupSecureSSEEndpoint(path = '/secure-sse') {
    this.app.get(path, async (req, res) => {
      // Проверяем аутентификацию
      if (!await this.authenticateRequest(req)) {
        res.status(401).send('Unauthorized');
        return;
      }

      const userId = req.user.id;
      
      // Устанавливаем безопасные заголовки
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*'
      });

      const connectionId = crypto.randomUUID();
      const connection = {
        userId,
        res,
        lastActivity: Date.now()
      };

      this.connections.set(connectionId, connection);

      // Отправляем зашифрованное подтверждение подключения
      const connectionData = { 
        type: 'connected', 
        connectionId, 
        userId 
      };
      
      const encryptedConnectionData = await this.encryptionManager.encrypt(
        connectionData, 
        userId
      );
      
      this.sendSecureSSEEvent(res, 'connection', encryptedConnectionData);

      // Обработка закрытия соединения
      req.on('close', () => {
        this.connections.delete(connectionId);
      });
    });
  }

  async sendSecureEvent(userId, eventType, data) {
    // Шифруем данные перед отправкой
    const encryptedData = await this.encryptionManager.encrypt(data, userId);

    for (const [connectionId, connection] of this.connections) {
      if (connection.userId === userId && connection.res.writable) {
        this.sendSecureSSEEvent(connection.res, eventType, encryptedData);
        connection.lastActivity = Date.now();
      }
    }
  }

  sendSecureSSEEvent(res, eventType, encryptedData) {
    try {
      if (res.writable) {
        res.write(`event: ${eventType}\n`);
        res.write(`data: ${JSON.stringify(encryptedData)}\n\n`);
      }
    } catch (error) {
      console.error('Ошибка отправки SSE-события:', error);
    }
  }

  async authenticateRequest(req) {
    // Реализация аутентификации запроса
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return false;
    }

    const token = authHeader.substring(7);
    const user = await this.verifyToken(token);
    req.user = user;
    
    return !!user;
  }

  async verifyToken(token) {
    // Проверка JWT-токена
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return decoded;
    } catch (error) {
      return null;
    }
  }
}
```

## Мониторинг и аудит шифрования

### Система аудита шифрования

```javascript
// Система аудита операций шифрования
class EncryptionAuditSystem {
  constructor() {
    this.events = [];
    this.maxEvents = 10000;
    this.alertThresholds = {
      encryptionFailures: 5, // 5 ошибок в минуту
      suspiciousPatterns: 0.8 // 80% подозрительных операций
    };
  }

  logEvent(operation, details, context) {
    const event = {
      id: crypto.randomUUID(),
      operation, // 'encrypt', 'decrypt', 'key_generation', etc.
      details,
      context,
      timestamp: new Date().toISOString(),
      severity: this.calculateSeverity(operation, details)
    };

    this.events.push(event);

    // Ограничиваем размер лога
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(-this.maxEvents);
    }

    // Проверяем на подозрительные паттерны
    this.checkForAnomalies(event);

    // Логируем в консоль (в реальном приложении - в систему логирования)
    console.log(`Encryption Audit: ${operation}`, details);
  }

  calculateSeverity(operation, details) {
    if (details.error) {
      return 'HIGH';
    }

    if (operation === 'key_generation' && details.frequent) {
      return 'MEDIUM';
    }

    return 'LOW';
  }

  checkForAnomalies(event) {
    switch (event.operation) {
      case 'encrypt_failure':
      case 'decrypt_failure':
        if (this.isFrequentFailure(event.context.userId)) {
          this.triggerSecurityAlert('FREQUENT_ENCRYPTION_FAILURES', event.context);
        }
        break;
        
      case 'key_access':
        if (this.isSuspiciousKeyAccess(event.context)) {
          this.triggerSecurityAlert('SUSPICIOUS_KEY_ACCESS', event.context);
        }
        break;
    }
  }

  isFrequentFailure(userId) {
    const recentFailures = this.events.filter(
      event => event.context.userId === userId && 
               event.operation.includes('failure') && 
               Date.now() - new Date(event.timestamp).getTime() < 60000 // За последнюю минуту
    );
    
    return recentFailures.length >= this.alertThresholds.encryptionFailures;
  }

  isSuspiciousKeyAccess(context) {
    // Проверяем, например, доступ к ключам из разных IP
    const sameKeyAccesses = this.events.filter(
      event => event.context.keyId === context.keyId
    );
    
    const uniqueIPs = new Set(sameKeyAccesses.map(e => e.context.ip));
    return uniqueIPs.size > 1; // Ключ используется с разных IP
  }

  triggerSecurityAlert(type, context) {
    console.warn(`Security Alert: ${type}`, context);
    
    // Здесь можно отправить уведомление администратору
    this.sendSecurityNotification(type, context);
  }

  sendSecurityNotification(type, context) {
    // Реализация отправки уведомлений
    console.log(`Отправка уведомления безопасности: ${type}`, context);
  }

  getEncryptionStatistics() {
    const totalEvents = this.events.length;
    const successCount = this.events.filter(e => !e.details.error).length;
    const failureCount = totalEvents - successCount;
    
    return {
      totalOperations: totalEvents,
      successRate: totalEvents > 0 ? (successCount / totalEvents * 100).toFixed(2) + '%' : '0%',
      failureCount,
      recentFailures: this.events.filter(e => e.details.error).slice(-10)
    };
  }

  getRecentEvents(userId = null, limit = 100) {
    let events = this.events;

    if (userId) {
      events = events.filter(event => event.context.userId === userId);
    }

    return events.slice(-limit).reverse();
  }
}
```

## Практические рекомендации

### Лучшие практики шифрования в реальном времени

1. **Используйте современные алгоритмы** — AES-GCM, ChaCha20-Poly1305
2. **Регулярно обновляйте ключи** — реализуйте ротацию ключей
3. **Ограничивайте время жизни ключей** — не используйте долгоживущие ключи
4. **Реализуйте аутентификацию** — проверяйте подлинность данных
5. **Мониторьте производительность** — следите за задержками
6. **Логируйте операции** — ведите аудит всех операций шифрования

### Обработка ошибок и исключений

```javascript
// Централизованная обработка ошибок шифрования
class EncryptionErrorHandler {
  static handleEncryptionError(error, context) {
    const errorEvent = {
      type: 'ENCRYPTION_ERROR',
      error: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    };

    console.error('Ошибка шифрования:', errorEvent);

    // Логируем в систему аудита
    auditSystem.logEvent('encryption_failure', errorEvent, context);

    // В зависимости от типа ошибки принимаем меры
    if (error.message.includes('key')) {
      this.handleKeyError(context);
    } else if (error.message.includes('algorithm')) {
      this.handleAlgorithmError(context);
    } else if (error.message.includes('IV')) {
      this.handleIVError(context);
    }
  }

  static handleKeyError(context) {
    // Возможная компрометация ключа
    console.warn('Возможная проблема с ключом:', context);
    // Здесь можно инициировать ротацию ключа
  }

  static handleAlgorithmError(context) {
    // Проблема с алгоритмом шифрования
    console.error('Ошибка алгоритма шифрования:', context);
  }

  static handleIVError(context) {
    // Повторное использование IV - критическая ошибка
    console.error('Повторное использование IV:', context);
    // Необходимо срочно принять меры
  }
}
```

## Связь с другими аспектами безопасности

Реальное время шифрование тесно связано с:
- [[Безопасность-данных-в-реальном-времени]] — общие принципы безопасности реального времени
- [[Безопасность-SSE]] — шифрование Server-Sent Events
- [[Шифрование-на-клиенте]] — клиентское шифрование данных
- [[Управление-ключами]] — управление криптографическими ключами
- [[Secure-Storage]] — безопасное хранение ключей

## Заключение

Шифрование в реальном времени — это сложная, но критически важная задача для современных веб-приложений. Успешная реализация требует баланса между безопасностью, производительностью и удобством использования. Ключевыми элементами являются: выбор подходящих алгоритмов, эффективное управление ключами, оптимизация производительности и надежный мониторинг. При правильной архитектуре и реализации системы шифрования в реальном времени могут обеспечить высокий уровень безопасности без значительного влияния на пользовательский опыт.

## Дополнительные ресурсы

- Web Cryptography API Documentation
- Real-Time Encryption Standards
- AES-GCM Security Guidelines
- Performance Optimization for Cryptography