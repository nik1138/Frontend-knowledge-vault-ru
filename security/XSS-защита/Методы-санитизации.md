---
aliases: ["Санитизация данных", "Очистка ввода", "Фильтрация данных"]
tags: [security, sanitization, web-security, input-filtering]
---

# Методы санитизации

## Введение

Санитизация данных — это процесс очистки входных данных от потенциально опасного содержимого перед их обработкой или отображением. Это важный метод защиты от инъекций, XSS, HTML-инъекций и других типов атак, связанных с обработкой пользовательского ввода.

## Основные принципы санитизации

### 1. Принцип минимальной трансформации

Санитизация должна удалять только действительно опасные элементы, сохраняя при этом полезное содержимое настолько, насколько это возможно.

### 2. Использование проверенных библиотек

Для санитизации рекомендуется использовать проверенные библиотеки, а не писать собственные реализации, которые могут содержать ошибки.

### 3. Комбинирование методов

Санитизация наиболее эффективна в сочетании с другими методами: валидацией ввода, кодированием вывода и Content Security Policy.

## Типы санитизации

### 1. HTML-санитизация

Удаление или экранирование потенциально опасных HTML-тегов и атрибутов.

#### Использование DOMPurify

```javascript
const DOMPurify = require('isomorphic-dompurify');

// Простая санитизация
const userInput = '<p>Safe text</p><script>alert("XSS")</script>';
const sanitized = DOMPurify.sanitize(userInput);
// Результат: '<p>Safe text</p>'

// Санитизация с настройками
const sanitizedWithConfig = DOMPurify.sanitize(userInput, {
  ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
  ALLOWED_ATTR: ['class']
});
```

#### Использование sanitize-html

```javascript
const sanitizeHtml = require('sanitize-html');

const dirty = '<p>Safe text</p><script>alert("XSS")</script><a href="javascript:alert()">Link</a>';
const clean = sanitizeHtml(dirty, {
  allowedTags: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
  allowedAttributes: {
    'a': ['href', 'title'],
    'img': ['src', 'alt']
  },
  allowedSchemes: ['http', 'https', 'mailto'],
  // Запрет на javascript: и другие опасные схемы
  allowProtocolRelative: false
});
```

### 2. Санитизация CSS

Очистка CSS-кода от потенциально опасных свойств и значений.

```javascript
const sanitizeCss = require('sanitize-css');

function sanitizeStylesheet(css) {
  // Проверка и очистка CSS
  const dangerousPatterns = [
    /expression\s*\(/gi,
    /javascript\s*:/gi,
    /vbscript\s*:/gi,
    /data\s*:/gi  // Может быть использован для XSS
  ];
  
  let sanitized = css;
  dangerousPatterns.forEach(pattern => {
    sanitized = sanitized.replace(pattern, '');
  });
  
  return sanitized;
}
```

### 3. Санитизация URL

Очистка URL от опасных схем и содержимого.

```javascript
function sanitizeUrl(url) {
  try {
    const parsedUrl = new URL(url);
    
    // Проверка протокола
    if (!['http:', 'https:', 'mailto:', 'tel:'].includes(parsedUrl.protocol)) {
      throw new Error('Invalid protocol');
    }
    
    // Возврат безопасного URL
    return parsedUrl.href;
  } catch (error) {
    // Возврат безопасного значения по умолчанию
    return '#';
  }
}
```

## Методы санитизации

### 1. Белый список (Whitelist) против Черного списка (Blacklist)

> [!tip] Используйте белые списки
> Санитизация с использованием белого списка (разрешение только известных безопасных элементов) более безопасна, чем черный список (блокировка известных опасных элементов).

```javascript
// Плохо: черный список
function naiveSanitize(html) {
  return html
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/on\w+\s*=/gi, '');
}

// Хорошо: белый список с проверенной библиотекой
const clean = sanitizeHtml(dirty, {
  allowedTags: ['p', 'br', 'strong', 'em'], // Только разрешенные теги
  allowedAttributes: {} // Без атрибутов
});
```

### 2. Санитизация с сохранением форматирования

Иногда необходимо сохранить форматирование текста, разрешив при этом только безопасные HTML-теги.

```javascript
const sanitizeHtml = require('sanitize-html');

function sanitizeRichText(html) {
  return sanitizeHtml(html, {
    allowedTags: [
      'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'blockquote', 'code', 'pre'
    ],
    allowedAttributes: {
      'a': ['href', 'title', 'rel'],
      'img': ['src', 'alt', 'title', 'width', 'height'],
      'code': ['class']
    },
    allowedSchemes: ['http', 'https', 'mailto'],
    // Добавление rel="noopener noreferrer" для внешних ссылок
    transformTags: {
      'a': function(tagName, attribs) {
        if (attribs.href) {
          const link = attribs.href;
          if (link.startsWith('http')) {
            attribs.rel = 'noopener noreferrer';
          }
        }
        return { tagName, attribs };
      }
    }
  });
}
```

### 3. Санитизация файлов

При загрузке файлов необходимо санитизировать их содержимое и метаданные.

```javascript
const fs = require('fs');
const path = require('path');
const FileType = require('file-type');

async function sanitizeFileUpload(fileBuffer, originalName) {
  // Проверка MIME-типа
  const fileType = await FileType.fromBuffer(fileBuffer);
  if (!fileType) {
    throw new Error('Could not determine file type');
  }
  
  // Проверка расширения
  const ext = path.extname(originalName).toLowerCase();
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.pdf', '.doc', '.docx'];
  
  if (!allowedExtensions.includes(ext)) {
    throw new Error('File type not allowed');
  }
  
  // Санитизация имени файла
  const sanitizedName = originalName
    .replace(/[^a-zA-Z0-9._-]/g, '_')
    .substring(0, 100); // Ограничение длины
  
  return {
    buffer: fileBuffer,
    name: sanitizedName,
    mimeType: fileType.mime
  };
}
```

## Санитизация в разных контекстах

### Санитизация в формах

```javascript
// Санитизация данных формы
function sanitizeFormData(formData) {
  const sanitized = {};
  
  for (const [key, value] of Object.entries(formData)) {
    if (typeof value === 'string') {
      // Определение контекста и применение соответствующей санитизации
      if (key.includes('html') || key.includes('content')) {
        sanitized[key] = sanitizeHtml(value);
      } else if (key.includes('url') || key.includes('link')) {
        sanitized[key] = sanitizeUrl(value);
      } else {
        // Простое экранирование для обычных полей
        sanitized[key] = escapeHtml(value);
      }
    } else {
      sanitized[key] = value; // Не строки не санитизируются
    }
  }
  
  return sanitized;
}
```

### Санитизация в API

```javascript
// Middleware для санитизации API-запросов
const express = require('express');
const sanitize = require('sanitize-html');

function sanitizeMiddleware(req, res, next) {
  // Санитизация тела запроса
  if (req.body && typeof req.body === 'object') {
    req.body = sanitizeObject(req.body);
  }
  
  // Санитизация параметров запроса
  if (req.query) {
    req.query = sanitizeObject(req.query);
  }
  
  next();
}

function sanitizeObject(obj) {
  const result = {};
  
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      result[key] = sanitize(value, {
        allowedTags: [], // Для параметров - только текст
        allowedAttributes: {}
      });
    } else if (typeof value === 'object' && value !== null) {
      result[key] = sanitizeObject(value);
    } else {
      result[key] = value;
    }
  }
  
  return result;
}

// Использование
app.use(sanitizeMiddleware);
```

## Продвинутые методы санитизации

### Санитизация с сохранением структуры

Иногда нужно сохранить структуру HTML, но удалить опасные элементы:

```javascript
const cheerio = require('cheerio');

function advancedSanitize(html) {
  const $ = cheerio.load(html);
  
  // Удаление всех скриптов
  $('script').remove();
  $('style').remove();
  
  // Удаление опасных атрибутов
  $('*').each(function() {
    const element = $(this);
    const attributes = element.attr();
    
    for (const attr in attributes) {
      if (attr.toLowerCase().startsWith('on')) {
        // Удаление событийных атрибутов (onclick, onload и т.д.)
        element.removeAttr(attr);
      }
    }
  });
  
  // Возврат очищенного HTML
  return $.html();
}
```

### Санитизация JSON

При работе с JSON-данными, полученными от пользователей:

```javascript
function sanitizeJson(jsonString) {
  try {
    // Парсинг JSON
    const data = JSON.parse(jsonString);
    
    // Рекурсивная санитизация
    return sanitizeObjectRecursively(data);
  } catch (error) {
    throw new Error('Invalid JSON format');
  }
}

function sanitizeObjectRecursively(obj) {
  if (typeof obj === 'string') {
    // Санитизация строк
    return sanitizeHtml(obj, {
      allowedTags: [],
      allowedAttributes: {}
    });
  } else if (Array.isArray(obj)) {
    return obj.map(item => sanitizeObjectRecursively(item));
  } else if (typeof obj === 'object' && obj !== null) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = sanitizeObjectRecursively(value);
    }
    return result;
  }
  return obj;
}
```

## Санитизация в реальных сценариях

### Комментарии пользователей

```javascript
function sanitizeUserComment(comment) {
  return sanitizeHtml(comment, {
    allowedTags: ['p', 'br', 'strong', 'em', 'blockquote'],
    allowedAttributes: {},
    textFilter: function(text) {
      // Дополнительная фильтрация текста
      return text.replace(/\u0000/g, ''); // Удаление null-байтов
    }
  });
}
```

### Профили пользователей

```javascript
function sanitizeUserProfile(profileData) {
  return {
    username: sanitizeHtml(profileData.username, {
      allowedTags: [],
      allowedAttributes: {}
    }),
    bio: sanitizeHtml(profileData.bio, {
      allowedTags: ['p', 'br', 'strong', 'em'],
      allowedAttributes: {}
    }),
    website: profileData.website ? sanitizeUrl(profileData.website) : null
  };
}
```

## Лучшие практики санитизации

> [!tip] Лучшие практики
> 1. Используйте проверенные библиотеки для санитизации
> 2. Применяйте санитизацию на сервере, а не только на клиенте
> 3. Используйте белые списки разрешенных элементов
> 4. Тестируйте санитизацию с известными XSS-векторами
> 5. Комбинируйте санитизацию с другими методами защиты

### Тестирование санитизации

```javascript
// Пример тестов для санитизации
const testVectors = [
  '<script>alert("XSS")</script>',
  'javascript:alert("XSS")',
  '<img src="x" onerror="alert(\'XSS\')">',
  '<svg onload="alert(\'XSS\')">'
];

function testSanitization() {
  testVectors.forEach(vector => {
    const sanitized = sanitizeHtml(vector);
    console.log(`Input: ${vector}`);
    console.log(`Output: ${sanitized}`);
    console.log(`Safe: ${!sanitized.includes('script') && !sanitized.includes('alert')}`);
    console.log('---');
  });
}
```

## Ограничения санитизации

> [!warning] Ограничения
> - Санитизация не заменяет другие методы безопасности
> - Даже санитизированный HTML может содержать логические уязвимости
> - Санитизация может изменить исходное содержимое
> - Нужно учитывать производительность при обработке больших объемов данных

## Связь с другими аспектами безопасности

Методы санитизации тесно связаны с:
- [[Проверка-ввода]] — первый уровень защиты
- [[Кодирование-вывода]] — дополнительный уровень защиты
- [[Типы-XSS]] — предотвращение XSS-атак
- [[Распространенные-уязвимости]] — защита от инъекций
- [[Тестирование-безопасности]] — методы проверки эффективности

## Заключение

Санитизация данных — важный компонент комплексной защиты веб-приложений. Правильная реализация санитизации требует понимания контекста использования данных, выбора подходящих методов и библиотек, а также регулярного тестирования на уязвимости. Только в сочетании с другими методами безопасности санитизация может обеспечить надежную защиту от инъекций и других атак.

## Дополнительные ресурсы

- OWASP Sanitization
- DOMPurify Documentation
- Sanitize.css Documentation
- XSS Prevention Cheat Sheet