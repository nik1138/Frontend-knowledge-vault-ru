---
aliases: ["CSRF Double Submit Cookie", "Метод Double Submit Cookie", "Защита от CSRF через cookies"]
tags: 
  - security
  - csrf
  - web-security
  - authentication
  - authorization
---

# Метод Double Submit Cookie для защиты от CSRF-атак

## Введение в метод Double Submit Cookie

Метод **Double Submit Cookie** - это один из подходов к защите веб-приложений от межсайтовой поддельной подделки запросов (CSRF). Он основывается на принципе, что атакующий сайт не может прочитать содержимое cookies, установленных другим доменом, из-за Same-Origin Policy, действующей в веб-браузерах.

Метод получил своё название, потому что токен отправляется дважды: один раз в cookie, а второй раз в теле запроса или в заголовке. Сервер затем сравнивает оба значения и позволяет запрос только в случае их совпадения.

## Как работает метод Double Submit Cookie

Метод Double Submit Cookie реализует следующую логику:

1. При аутентификации пользователя сервер генерирует уникальный токен CSRF и устанавливает его в cookie, который отправляется клиенту.
2. При каждом защищенном запросе (обычно POST, PUT, DELETE), клиент должен отправить тот же токен в теле запроса или в заголовке.
3. Сервер проверяет, что токен в cookie совпадает с токеном в теле/заголовке запроса.
4. Если токены совпадают, запрос считается легитимным и обрабатывается. В противном случае запрос отклоняется.

Этот метод эффективен, потому что:
- Атакующий не может прочитать cookie, установленный целевым доменом, из-за Same-Origin Policy.
- Атакующий не может принудительно установить токен в заголовке или теле запроса, соответствующий значению cookie, поскольку он не знает его значения.

## Реализация метода

Реализация метода Double Submit Cookie включает в себя:

### На стороне сервера:

1. **Генерация токена**: При аутентификации пользователя или при необходимости (например, перед отправкой формы), сервер генерирует случайный токен CSRF.
2. **Установка cookie**: Токен устанавливается в HTTP-only cookie с флагами `Secure`, `HttpOnly` и `SameSite=Strict` (или `Lax`, в зависимости от требований).
3. **Проверка токена**: При получении защищенного запроса сервер извлекает токен из cookie и из тела/заголовка запроса и сравнивает их.

### На стороне клиента:

1. **Получение токена**: Токен доступен из cookie, установленного сервером.
2. **Отправка токена**: При отправке защищенного запроса токен должен быть включен в тело запроса (например, как hidden input в HTML-форме) или в заголовок (например, `X-CSRF-Token`).

## Достоинства и недостатки подхода

### Достоинства:

- **Простота реализации**: Не требует хранения токенов на сервере, как в методе Synchronizer Token Pattern.
- **Автоматическая отправка cookies**: Браузер автоматически отправляет cookies вместе с запросами, что упрощает клиентскую реализацию.
- **Совместимость**: Работает с различными типами запросов (AJAX, формы и т.д.).

### Недостатки:

- **Зависимость от Same-Origin Policy**: Уязвим к атакам, если есть XSS-уязвимости (атакующий может получить токен через XSS).
- **Нарушение принципа разделения полномочий**: Токен отправляется дважды, что теоретически может быть проблемой при определенных условиях.
- **Ограничения при использовании JSON Web Tokens (JWT)**: В архитектурах, использующих JWT в заголовках, реализация может быть сложнее.

## Сравнение с другими методами защиты

| Метод | Хранение токена | Проверка | Уязвимости | Сложность |
|-------|----------------|----------|------------|-----------|
| Double Submit Cookie | В cookie | Сравнение с телом/заголовком | XSS, поддомены | Средняя |
| Synchronizer Token Pattern | На сервере (сессия) | Сравнение с сохранённым значением | XSS, утечка токенов | Высокая |
| SameSite Cookies | В cookie | Установка SameSite флага | Совместимость с браузерами | Низкая |
| Referer Header | В заголовке | Проверка источника | Подмена Referer | Низкая |

## Практические рекомендации по реализации

При реализации метода Double Submit Cookie рекомендуется:

- Использовать криптографически стойкий генератор случайных чисел для создания токенов.
- Устанавливать флаги `Secure`, `HttpOnly` и `SameSite=Strict` для cookie с токеном.
- Обновлять токен при аутентификации или через определенные интервалы времени.
- Не отправлять токен в заголовках при GET-запросах.
- Использовать HTTPS для всех защищенных соединений.
- Обрабатывать ошибки проверки токенов корректно, не раскрывая лишнюю информацию.

## Примеры кода для различных языков/фреймворков

### Node.js (Express.js)

```javascript
const express = require('express');
const csrf = require('csurf');
const cookieParser = require('cookie-parser');

const app = express();
app.use(cookieParser());
app.use(express.urlencoded({ extended: true }));

// Установка middleware для CSRF
const csrfProtection = csrf({ cookie: true });

// GET-маршрут для отображения формы
app.get('/form', csrfProtection, (req, res) => {
    res.send(`
        <form action="/process" method="POST">
            <input type="hidden" name="_csrf" value="${req.csrfToken()}">
            <input type="text" name="data">
            <button type="submit">Отправить</button>
        </form>
    `);
});

// POST-маршрут для обработки данных
app.post('/process', csrfProtection, (req, res) => {
    res.send('Данные успешно обработаны!');
});
```

### Python (Django)

```python
from django.views.decorators.csrf import csrf_protect
from django.http import HttpResponse
from django.shortcuts import render

@csrf_protect
def my_view(request):
    if request.method == 'POST':
        # Обработка данных формы
        data = request.POST.get('data')
        return HttpResponse('Данные успешно обработаны!')
    else:
        # Отображение формы
        return render(request, 'my_form.html')
```

### PHP (Laravel)

```php
// В контроллере
public function showForm()
{
    return view('form');
}

public function processForm(Request $request)
{
    // Laravel автоматически проверяет CSRF-токен
    $data = $request->validate([
        'data' => 'required|string'
    ]);
    
    return response()->json(['message' => 'Данные успешно обработаны!']);
}
```

## Ограничения и уязвимости метода

Метод Double Submit Cookie имеет несколько ограничений и потенциальных уязвимостей:

- **XSS-атаки**: Если в приложении есть уязвимости XSS, атакующий может получить доступ к токену через JavaScript и использовать его для выполнения CSRF-атак.
- **Атаки на поддомены**: Если злоумышленник может получить контроль над поддоменом, он может установить cookie с флагом `domain`, который будет доступен для основного домена.
- **Слабая генерация токенов**: Использование предсказуемых токенов делает защиту бессмысленной.
- **Проблемы с кросс-доменными запросами**: В архитектурах с несколькими доменами реализация может быть сложной.

## Возможные атаки на реализацию

- **Подделка токенов**: Если токены генерируются предсказуемо, атакующий может попытаться угадать или вычислить правильный токен.
- **Уязвимости в обработке токенов**: Неправильная проверка токенов может привести к обходу защиты.
- **Атаки с использованием XSS**: Как уже упоминалось, XSS-уязвимости позволяют атакующему получить токен и использовать его в своих целях.
- **Неправильная настройка SameSite**: Неправильное использование флага SameSite может ослабить защиту.

## Альтернативы и дополнительные меры

В дополнение к методу Double Submit Cookie или в качестве альтернативы можно использовать:

- **SameSite Cookies**: Современный подход, встроенный в браузеры, который автоматически предотвращает отправку cookies в кросс-сайтовых контекстах.
- **Synchronizer Token Pattern**: Более традиционный подход, при котором токены хранятся на сервере и сопоставляются с запросами.
- **Double Cookie Submit Pattern**: Вариант метода, при котором токен отправляется в двух разных cookies.
- **Origin Header Verification**: Проверка заголовка Origin для подтверждения источника запроса.
- **Referer Header Verification**: Аналогично, проверка заголовка Referer (хотя этот метод менее надежен).

## Связанные концепции

- [[CSRF-атаки]]
- [[SameSite Cookies]]
- [[XSS-атаки]]
- [[Synchronizer Token Pattern]]
- [[Web Security Best Practices]]
- [[HTTP Security Headers]]
- [[Session Management]]
- [[Authentication vs Authorization]]
- [[JWT Security]]
- [[CORS Policy]]

## Заключение

Метод Double Submit Cookie остается важным инструментом в арсенале защиты веб-приложений от CSRF-атак. При правильной реализации и соблюдении всех мер предосторожности он может обеспечить надежную защиту. Однако важно понимать его ограничения и сочетать с другими методами безопасности для создания многоуровневой защиты.

Для современных веб-приложений рекомендуется использовать комбинацию методов, включая SameSite Cookies, надежную проверку источника запросов и защиту от XSS-атак, чтобы обеспечить максимальную безопасность.