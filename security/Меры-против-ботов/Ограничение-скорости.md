---
aliases: ["Ограничение скорости", "Rate Limiting", "Rate Control"]
tags: [security, bot-protection, rate-limiting, performance]
created: 2024-11-18
updated: 2024-11-18
type: security
---

# Ограничение-скорости

## Введение

Ограничение скорости (rate limiting) - это важная мера безопасности, предназначенная для предотвращения чрезмерного использования ресурсов веб-приложения. Эта техника ограничивает количество запросов, которые могут быть сделаны за определенный период времени, что помогает предотвратить атаки типа "отказ в обслуживании" (DoS/DDoS), брутфорс и другие формы злоупотребления.

## Принципы работы

Ограничение скорости работает по принципу ограничения количества запросов, которые может сделать клиент за определенный период времени. Это может быть реализовано на различных уровнях: на уровне сети, веб-сервера, приложения или базы данных.

## Типы ограничения скорости

### 1. По IP-адресу

Самый распространенный метод, который ограничивает количество запросов с одного IP-адреса:

```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');

// Ограничение для общего использования
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 100, // ограничение на 100 запросов за 15 минут
  message: 'Слишком много запросов с вашего IP, попробуйте позже',
  standardHeaders: true, // Возвращает информацию о лимитах в заголовках
  legacyHeaders: false, // Отключает устаревшие заголовки X-RateLimit
});

// Ограничение для чувствительных операций
const sensitiveLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 5, // только 5 запросов к чувствительным операциям
  message: 'Слишком много попыток доступа к чувствительной операции',
  skipSuccessfulRequests: false,
});

const app = express();
app.use(generalLimiter);
app.use('/api/sensitive', sensitiveLimiter);
```

### 2. По пользовательским сессиям

Ограничение на основе идентификатора сессии пользователя:

```javascript
const sessionLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: (req, res) => {
    // Разные лимиты для разных типов пользователей
    if (req.session && req.session.user) {
      if (req.session.user.role === 'admin') {
        return 1000; // администраторы имеют более высокие лимиты
      } else if (req.session.user.role === 'premium') {
        return 200; // премиум-пользователи
      }
    }
    return 50; // стандартные пользователи
  },
  keyGenerator: (req) => {
    // Использовать ID сессии как ключ
    return req.sessionID || req.ip;
  }
});
```

### 3. По API-ключам

Для API с аутентификацией на основе ключей:

```javascript
const apiKeyLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 минута
  max: (req, res) => {
    const apiKey = req.headers['x-api-key'];
    if (!apiKey) return 5; // без API-ключа - низкий лимит
    
    // Определить лимит на основе типа API-ключа
    const apiKeyInfo = getApiKeyInfo(apiKey);
    return apiKeyInfo.rateLimit || 100;
  },
  keyGenerator: (req) => {
    return req.headers['x-api-key'] || req.ip;
  }
});
```

## Алгоритмы ограничения скорости

### 1. Token Bucket (Ведро с токенами)

Алгоритм, при котором клиент получает "жетоны" с определенной скоростью, и каждый запрос "сжигает" жетон:

```javascript
class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;      // максимальное количество токенов
    this.tokens = capacity;        // текущее количество токенов
    this.refillRate = refillRate;  // количество токенов в секунду
    this.lastRefill = Date.now();
  }

  allow() {
    this.refill();
    
    if (this.tokens >= 1) {
      this.tokens--;
      return true;
    }
    return false;
  }

  refill() {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000; // в секундах
    const tokensToAdd = timePassed * this.refillRate;
    
    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  tokensAvailable() {
    this.refill();
    return Math.floor(this.tokens);
  }
}

// Пример использования
const bucket = new TokenBucket(10, 1); // 10 токенов, 1 токен в секунду

// Проверка разрешения запроса
if (bucket.allow()) {
  console.log('Запрос разрешен');
} else {
  console.log('Слишком много запросов');
}
```

### 2. Leaky Bucket (Протекающее ведро)

Алгоритм, при котором запросы "поступают" в ведро с определенной скоростью, и ведро "протекает" с постоянной скоростью:

```javascript
class LeakyBucket {
  constructor(rate, capacity) {
    this.rate = rate;           // скорость "утечки" (запросов в секунду)
    this.capacity = capacity;   // максимальная емкость ведра
    this.currentLevel = 0;      // текущий уровень "воды" в ведре
    this.lastUpdate = Date.now();
  }

  async allowRequest() {
    const now = Date.now();
    const timePassed = (now - this.lastUpdate) / 1000;
    
    // "Вытечет" часть запросов
    this.currentLevel = Math.max(0, this.currentLevel - timePassed * this.rate);
    this.lastUpdate = now;
    
    if (this.currentLevel < this.capacity) {
      this.currentLevel += 1; // добавить запрос в ведро
      return true;
    }
    
    return false; // ведро переполнено
  }
}
```

### 3. Fixed Window Counter (Счетчик фиксированного окна)

Простой алгоритм, который сбрасывает счетчик в начале каждого окна:

```javascript
class FixedWindowCounter {
  constructor(windowMs, maxRequests) {
    this.windowMs = windowMs;
    this.maxRequests = maxRequests;
    this.count = 0;
    this.windowStart = Date.now();
  }

  allow() {
    const now = Date.now();
    
    if (now - this.windowStart >= this.windowMs) {
      // Сброс окна
      this.count = 1;
      this.windowStart = now;
      return true;
    }
    
    if (this.count < this.maxRequests) {
      this.count++;
      return true;
    }
    
    return false;
  }
}
```

## Реализация на основе Redis

Для распределенных систем рекомендуется использовать Redis для хранения состояния ограничения скорости:

```javascript
const redis = require('redis');

class RedisRateLimiter {
  constructor(redisClient, options = {}) {
    this.redis = redisClient;
    this.windowMs = options.windowMs || 15 * 60 * 1000; // 15 минут по умолчанию
    this.maxRequests = options.maxRequests || 100;
  }

  async check(key, increment = 1) {
    const currentWindow = Math.floor(Date.now() / this.windowMs);
    const windowKey = `rate_limit:${key}:${currentWindow}`;
    
    // Получить текущий счетчик
    let count = await this.redis.get(windowKey);
    count = count ? parseInt(count) : 0;
    
    if (count + increment > this.maxRequests) {
      // Превышено ограничение
      const ttl = await this.redis.ttl(windowKey);
      return {
        allowed: false,
        resetTime: Date.now() + (ttl > 0 ? ttl * 1000 : this.windowMs),
        current: count,
        limit: this.maxRequests
      };
    }
    
    // Увеличить счетчик с TTL
    await this.redis.incrby(windowKey, increment);
    await this.redis.expire(windowKey, Math.ceil(this.windowMs / 1000));
    
    return {
      allowed: true,
      current: count + increment,
      limit: this.maxRequests,
      resetTime: Date.now() + this.windowMs
    };
  }
}

// Использование с Express
const redisRateLimiter = new RedisRateLimiter(redisClient, {
  windowMs: 60 * 1000, // 1 минута
  maxRequests: 10
});

const rateLimitMiddleware = async (req, res, next) => {
  const key = req.ip; // или req.sessionID, или req.headers['x-api-key']
  
  try {
    const result = await redisRateLimiter.check(key);
    
    // Установить заголовки для информации о лимитах
    res.setHeader('X-RateLimit-Limit', result.limit);
    res.setHeader('X-RateLimit-Remaining', result.allowed ? result.limit - result.current : 0);
    
    if (!result.allowed) {
      res.status(429).json({
        error: 'Слишком много запросов',
        resetTime: new Date(result.resetTime)
      });
      return;
    }
    
    next();
  } catch (error) {
    console.error('Ошибка ограничения скорости:', error);
    res.status(500).json({ error: 'Внутренняя ошибка сервера' });
  }
};
```

## Продвинутые техники

### 1. Адаптивное ограничение

Лимиты, которые адаптируются на основе нагрузки системы:

```javascript
class AdaptiveRateLimiter {
  constructor(baseLimiter) {
    this.baseLimiter = baseLimiter;
    this.systemLoad = 0;
    this.baseLimit = 100;
  }

  async adjustLimit() {
    // Получить текущую нагрузку на систему
    this.systemLoad = await this.getSystemLoad();
    
    // Адаптировать лимит на основе нагрузки
    const adjustmentFactor = 1 - (this.systemLoad / 100); // 0-100% нагрузка
    const adjustedLimit = Math.max(10, Math.floor(this.baseLimit * adjustmentFactor));
    
    return adjustedLimit;
  }

  async getSystemLoad() {
    // Имитация получения нагрузки системы
    // На практике это может быть CPU, память, задержка базы данных и т.д.
    return Math.random() * 100;
  }
}
```

### 2. Каскадное ограничение

Разные уровни ограничений для разных типов операций:

```javascript
const rateLimiters = {
  // Общее ограничение для всех запросов
  global: rateLimit({
    windowMs: 15 * 60 * 1000, // 15 минут
    max: 1000,
    message: 'Глобальное ограничение превышено'
  }),
  
  // Ограничение для аутентификации
  auth: rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 5, // всего 5 попыток входа
    message: 'Слишком много попыток входа'
  }),
  
  // Ограничение для регистрации
  registration: rateLimit({
    windowMs: 60 * 60 * 1000, // 1 час
    max: 3, // только 3 регистрации с IP в час
    message: 'Слишком много регистраций'
  }),
  
  // Ограничение для API
  api: rateLimit({
    windowMs: 1 * 60 * 1000, // 1 минута
    max: 60, // 60 запросов в минуту
    message: 'Превышено ограничение API'
  })
};

// Применение к маршрутам
app.use('/api/', rateLimiters.api);
app.use('/auth/login', rateLimiters.auth);
app.use('/auth/register', rateLimiters.registration);
app.use(rateLimiters.global);
```

## Обработка превышения лимита

### 1. Экспоненциальная задержка

Увеличение задержки при превышении лимита:

```javascript
class ExponentialBackoffLimiter {
  constructor(baseDelay = 1000, maxDelay = 60000) {
    this.baseDelay = baseDelay;
    this.maxDelay = maxDelay;
    this.attempts = new Map();
  }

  async checkAndDelay(key) {
    const attempts = this.attempts.get(key) || 0;
    
    if (attempts > 0) {
      // Рассчитать задержку по экспоненциальному закону
      const delay = Math.min(
        this.baseDelay * Math.pow(2, attempts),
        this.maxDelay
      );
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    // Увеличить счетчик попыток
    this.attempts.set(key, attempts + 1);
    
    return {
      delay: Math.min(this.baseDelay * Math.pow(2, attempts), this.maxDelay),
      attempts: attempts + 1
    };
  }

  reset(key) {
    this.attempts.delete(key);
  }
}
```

### 2. Частичное обслуживание

Обслуживание запросов с пониженным приоритетом при превышении лимита:

```javascript
const lowPriorityLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,
  max: 10,
  skipSuccessfulRequests: true, // пропускать успешные запросы
  message: 'Сервис временно перегружен'
});

app.use('/api/data', (req, res, next) => {
  // Проверить, является ли запрос приоритетным
  if (req.headers['x-priority'] === 'high') {
    // Высокоприоритетные запросы проходят без ограничений
    next();
  } else {
    // Обычные запросы подвергаются ограничению
    lowPriorityLimiter(req, res, next);
  }
});
```

## Лучшие практики

1. **Разумные лимиты** - установка баланса между безопасностью и удобством использования
2. **Мониторинг и логирование** - отслеживание попыток превысить лимиты
3. **Гибкие настройки** - разные лимиты для разных типов пользователей
4. **Обработка ошибок** - корректное сообщение пользователям при превышении лимитов

## Связанные темы

- [[Обнаружение-ботов]]
- [[Реализация-CAPTCHA]]
- [[Анализ-поведения]]

## Внешние ресурсы

- [OWASP Rate Limiting Guidelines](https://owasp.org/www-community/controls/Rate_Limiting)
- [Rate Limiting Best Practices](https://www.cloudflare.com/learning/bots/rate-limiting/)

> [!warning]
> Слишком строгие ограничения могут негативно сказаться на пользовательском опыте. Найдите баланс между безопасностью и доступностью.

> [!tip]
> Используйте заголовки `X-RateLimit-*` для информирования клиентов о текущем состоянии ограничений скорости.