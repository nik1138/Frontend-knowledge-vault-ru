---
aliases: ["Обнаружение ботов", "Bot Detection", "Bot Identification"]
tags: [security, bot-protection, detection]
created: 2024-11-18
updated: 2024-11-18
type: security
---

# Обнаружение-ботов

## Введение

Обнаружение ботов - это критический аспект веб-безопасности, направленный на идентификацию автоматизированных скриптов, которые пытаются имитировать поведение реальных пользователей. Боты могут использоваться как в легитимных целях (например, поисковые роботы), так и в злонамеренных (спам, скрапинг, атаки).

## Методы обнаружения ботов

### 1. Поведенческий анализ

Поведенческий анализ основывается на паттернах взаимодействия пользователя с интерфейсом:

```javascript
// Пример отслеживания поведения пользователя
class BehaviorTracker {
  constructor() {
    this.events = [];
    this.startTime = Date.now();
  }

  trackEvent(eventType, data) {
    this.events.push({
      type: eventType,
      timestamp: Date.now(),
      data: data
    });
  }

  analyzeBehavior() {
    const duration = Date.now() - this.startTime;
    const eventCount = this.events.length;
    
    // Если события происходят слишком быстро - вероятно бот
    if (duration > 0 && eventCount / duration > 0.1) { // более 1 события в 10 секунд
      return { isBot: true, confidence: 0.8 };
    }
    
    return { isBot: false, confidence: 0.9 };
  }
}
```

### 2. Анализ заголовков HTTP

Проверка HTTP-заголовков на наличие признаков автоматизации:

```javascript
function detectBotFromHeaders(req) {
  const userAgent = req.headers['user-agent'];
  const acceptHeaders = req.headers['accept'];
  
  // Часто используемые бот-агенты
  const botPatterns = [
    /bot/i,
    /crawl/i,
    /spider/i,
    /selenium/i,
    /phantomjs/i,
    /headless/i
  ];
  
  for (const pattern of botPatterns) {
    if (pattern.test(userAgent)) {
      return true;
    }
  }
  
  // Проверка на подозрительные заголовки
  if (!req.headers['accept-language'] || !req.headers['accept-encoding']) {
    return true; // боты часто не отправляют эти заголовки
  }
  
  return false;
}
```

### 3. Техники на основе JavaScript

Боты, не поддерживающие JavaScript, могут быть выявлены через клиентские проверки:

```html
<script>
// Установка флага, что JavaScript работает
window.jsEnabled = true;

// Проверка, что страница загружена нормально (не через headless браузер)
setTimeout(() => {
  if (!window.jsEnabled) {
    // Отправка сигнала на сервер о подозрительной активности
    fetch('/api/bot-detected', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ reason: 'js-disabled' })
    });
  }
}, 1000);

// Отслеживание поведения мыши и клавиатуры
let mouseMoved = false;
let keyTyped = false;

document.addEventListener('mousemove', () => mouseMoved = true);
document.addEventListener('keydown', () => keyTyped = true);

// Проверка через 3 секунды после загрузки
setTimeout(() => {
  if (!mouseMoved && !keyTyped) {
    // Подозрение на бота
    fetch('/api/suspicious-activity', {
      method: 'POST',
      body: JSON.stringify({ 
        type: 'no-interaction',
        mouseMoved,
        keyTyped
      })
    });
  }
}, 3000);
</script>
```

## Современные подходы к обнаружению

### 1. Device Fingerprinting

Создание уникального "отпечатка" устройства пользователя:

```javascript
class DeviceFingerprinter {
  static getFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('Device fingerprinting test', 2, 2);
    
    return {
      userAgent: navigator.userAgent,
      language: navigator.language,
      platform: navigator.platform,
      hardwareConcurrency: navigator.hardwareConcurrency,
      screenResolution: `${screen.width}x${screen.height}`,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      canvas: canvas.toDataURL(),
      webgl: this.getWebGLFingerprint(),
      fonts: this.getAvailableFonts()
    };
  }
  
  static getWebGLFingerprint() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return null;
    
    try {
      const renderer = gl.getParameter(gl.RENDERER);
      const vendor = gl.getParameter(gl.VENDOR);
      return `${renderer} - ${vendor}`;
    } catch (e) {
      return 'error';
    }
  }
  
  static getAvailableFonts() {
    // Проверка доступных шрифтов
    const testFonts = ['Arial', 'Times New Roman', 'Courier New', 'Helvetica'];
    const available = [];
    
    for (const font of testFonts) {
      if (this.isFontAvailable(font)) {
        available.push(font);
      }
    }
    
    return available;
  }
  
  static isFontAvailable(fontName) {
    // Реализация проверки доступности шрифта
    const testText = 'abcdefghijklmnopqrstuvwxyz0123456789';
    const testElement = document.createElement('span');
    testElement.style.position = 'absolute';
    testElement.style.left = '-9999px';
    testElement.style.fontSize = '72px';
    testElement.innerHTML = testText;
    
    const defaultWidth = testElement.offsetWidth;
    testElement.style.fontFamily = fontName;
    document.body.appendChild(testElement);
    
    const hasFont = testElement.offsetWidth !== defaultWidth;
    document.body.removeChild(testElement);
    
    return hasFont;
  }
}
```

### 2. Machine Learning для обнаружения ботов

Использование ML-моделей для анализа паттернов поведения:

```javascript
// Пример простой модели оценки подозрительности
class BotDetectionML {
  static analyzeUserSession(sessionData) {
    const features = {
      // Временные признаки
      avgTimePerPage: this.calculateAvgTimePerPage(sessionData),
      pageVisitRate: this.calculatePageVisitRate(sessionData),
      
      // Поведенческие признаки
      mouseMovementPattern: this.analyzeMouseMovement(sessionData),
      scrollPattern: this.analyzeScrollPattern(sessionData),
      
      // Технические признаки
      userAgentConsistency: this.checkUserAgentConsistency(sessionData),
      deviceConsistency: this.checkDeviceConsistency(sessionData)
    };
    
    // Простая модель (в реальности - натренированная ML модель)
    let score = 0;
    
    if (features.avgTimePerPage < 2) score += 0.3; // слишком быстро
    if (features.pageVisitRate > 10) score += 0.2; // слишком много страниц
    if (features.mouseMovementPattern === 'linear') score += 0.4; // прямолинейные движения
    if (features.userAgentConsistency === false) score += 0.1;
    
    return {
      isBot: score > 0.5,
      confidence: score,
      features: features
    };
  }
  
  static calculateAvgTimePerPage(sessionData) {
    let totalTime = 0;
    let pageVisits = 0;
    
    for (let i = 1; i < sessionData.pageViews.length; i++) {
      const timeDiff = sessionData.pageViews[i].timestamp - sessionData.pageViews[i-1].timestamp;
      totalTime += timeDiff;
      pageVisits++;
    }
    
    return totalTime / pageVisits / 1000; // в секундах
  }
  
  // Другие методы анализа...
}
```

## Интеграция с серверной частью

Пример серверной реализации обнаружения ботов:

```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();

// Промежуточное ПО для детекции ботов
app.use('/api/', (req, res, next) => {
  // Проверка на подозрительные заголовки
  if (detectBotFromHeaders(req)) {
    req.botScore = 0.8;
  } else {
    req.botScore = 0.1;
  }
  
  // Проверка скорости запросов
  const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const requestCount = getRequestCountForIP(clientIP, 60); // за последние 60 секунд
  
  if (requestCount > 10) {
    req.botScore += 0.3; // подозрительно высокая активность
  }
  
  // Если вероятность бота высока
  if (req.botScore > 0.7) {
    res.status(429).json({ error: 'Too many requests - possible bot detected' });
    return;
  }
  
  next();
});

// Ограничение скорости для подозрительных пользователей
const suspiciousRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 5, // только 5 запросов
  skipSuccessfulRequests: false,
  message: { error: 'Rate limit exceeded - possible bot detected' },
  keyGenerator: (req) => {
    // Использовать IP или сессию как ключ
    return req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  }
});

app.use('/api/sensitive-endpoint', suspiciousRateLimit);
```

## Лучшие практики

1. **Комбинированный подход** - использование нескольких методов детекции
2. **Минимизация ложных срабатываний** - тщательная настройка порогов
3. **Регулярное обновление** - адаптация к новым методам обхода ботов
4. **Анонимность данных** - соблюдение правил конфиденциальности при сборе данных

## Связанные темы

- [[Ограничение-скорости]]
- [[Реализация-CAPTCHA]]
- [[Анализ-поведения]]
- [[Защита-исходного-кода]]

## Внешние ресурсы

- [OWASP Bot Mitigation](https://owasp.org/www-project-proactive-controls/)
- [Bot Detection Best Practices](https://www.imperva.com/learn/application-security/bot-detection/)

> [!warning]
> Не полагайтесь только на один метод детекции. Современные боты могут обходить большинство отдельных методов.

> [!tip]
> Регулярно анализируйте логи для выявления новых паттернов поведения ботов и адаптируйте свои методы детекции.