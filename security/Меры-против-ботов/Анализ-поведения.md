---
aliases: ["Анализ поведения", "Behavior Analysis", "User Behavior Monitoring"]
tags: [security, bot-protection, behavior-analysis, detection]
created: 2024-11-18
updated: 2024-11-18
type: security
---

# Анализ-поведения

## Введение

Анализ поведения - это метод обнаружения аномалий и потенциально вредоносной активности на основе анализа паттернов поведения пользователей. В контексте веб-безопасности, это включает в себя мониторинг действий пользователей, чтобы отличить нормальное поведение человека от автоматизированных действий ботов.

## Основные концепции

Анализ поведения основывается на идее, что люди и боты ведут себя по-разному. Люди имеют непредсказуемое поведение, совершают ошибки, делают паузы, перемещают мышь случайным образом, тогда как боты следуют строгим алгоритмам.

### Поведенческие индикаторы

Существует множество поведенческих признаков, которые могут указывать на автоматизированную активность:

1. **Скорость взаимодействия** - боты работают быстрее людей
2. **Паттерны движения мыши** - боты могут двигать мышь по прямой линии
3. **Последовательность действий** - боты следуют предсказуемым сценариям
4. **Временные интервалы** - боты могут действовать с постоянным интервалом

## Реализация клиентской аналитики поведения

### 1. Мониторинг движений мыши

```javascript
class MouseBehaviorAnalyzer {
  constructor() {
    this.events = [];
    this.mousePath = [];
    this.startTime = Date.now();
    
    this.initEventListeners();
  }
  
  initEventListeners() {
    // Отслеживание движений мыши
    document.addEventListener('mousemove', (e) => {
      this.trackMouseEvent(e);
    });
    
    // Отслеживание кликов
    document.addEventListener('click', (e) => {
      this.trackClickEvent(e);
    });
    
    // Отслеживание нажатий клавиш
    document.addEventListener('keydown', (e) => {
      this.trackKeyboardEvent(e);
    });
  }
  
  trackMouseEvent(e) {
    const event = {
      type: 'mousemove',
      x: e.clientX,
      y: e.clientY,
      timestamp: Date.now(),
      pageX: e.pageX,
      pageY: e.pageY
    };
    
    this.events.push(event);
    this.mousePath.push({x: event.x, y: event.y});
  }
  
  trackClickEvent(e) {
    const event = {
      type: 'click',
      x: e.clientX,
      y: e.clientY,
      target: e.target.tagName,
      timestamp: Date.now()
    };
    
    this.events.push(event);
  }
  
  trackKeyboardEvent(e) {
    const event = {
      type: 'keydown',
      key: e.key,
      keyCode: e.keyCode,
      timestamp: Date.now()
    };
    
    this.events.push(event);
  }
  
  analyzeMousePath() {
    if (this.mousePath.length < 3) return { isLinear: false, complexity: 0 };
    
    let totalDistance = 0;
    let linearDistance = 0;
    
    // Рассчитать общее расстояние пути
    for (let i = 1; i < this.mousePath.length; i++) {
      const dx = this.mousePath[i].x - this.mousePath[i-1].x;
      const dy = this.mousePath[i].y - this.mousePath[i-1].y;
      totalDistance += Math.sqrt(dx * dx + dy * dy);
    }
    
    // Рассчитать расстояние от начальной до конечной точки
    const startX = this.mousePath[0].x;
    const startY = this.mousePath[0].y;
    const endX = this.mousePath[this.mousePath.length - 1].x;
    const endY = this.mousePath[this.mousePath.length - 1].y;
    
    linearDistance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    
    // Если пройденное расстояние близко к линейному, это может быть бот
    const linearity = linearDistance / totalDistance;
    const complexity = 1 - linearity; // чем выше, тем более сложный путь
    
    return {
      isLinear: linearity > 0.8, // если 80% пути - прямая линия
      complexity: complexity,
      totalDistance: totalDistance,
      linearDistance: linearDistance
    };
  }
  
  analyzeTiming() {
    if (this.events.length < 2) return { isUniform: false, avgInterval: 0 };
    
    const intervals = [];
    for (let i = 1; i < this.events.length; i++) {
      const interval = this.events[i].timestamp - this.events[i-1].timestamp;
      intervals.push(interval);
    }
    
    if (intervals.length === 0) return { isUniform: false, avgInterval: 0 };
    
    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
    const variance = intervals.reduce((acc, interval) => acc + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
    const stdDev = Math.sqrt(variance);
    
    // Если стандартное отклонение маленькое, поведение более равномерное (как у бота)
    const isUniform = stdDev < 50; // 50мс порог
    
    return {
      isUniform: isUniform,
      avgInterval: avgInterval,
      stdDev: stdDev,
      variance: variance
    };
  }
  
  generateBehaviorReport() {
    const mouseAnalysis = this.analyzeMousePath();
    const timingAnalysis = this.analyzeTiming();
    
    // Оценка бот-подобности (0-1, где 1 - максимально похоже на бота)
    let botScore = 0;
    
    if (mouseAnalysis.isLinear) botScore += 0.3;
    if (timingAnalysis.isUniform) botScore += 0.4;
    if (timingAnalysis.avgInterval < 100) botScore += 0.3; // слишком быстро
    
    // Поведение выглядит как бот, если бот-оценка выше 0.6
    const isBot = botScore > 0.6;
    
    return {
      isBot: isBot,
      botScore: botScore,
      mouseAnalysis: mouseAnalysis,
      timingAnalysis: timingAnalysis,
      eventCount: this.events.length,
      duration: Date.now() - this.startTime
    };
  }
}

// Инициализация анализатора поведения
const behaviorAnalyzer = new MouseBehaviorAnalyzer();

// Отправка отчета о поведении на сервер каждые 30 секунд
setInterval(() => {
  const report = behaviorAnalyzer.generateBehaviorReport();
  
  if (report.eventCount > 10) { // только если достаточно данных
    fetch('/api/behavior-analysis', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(report)
    }).catch(console.error);
  }
}, 30000);
```

### 2. Анализ скроллинга и взаимодействия со страницей

```javascript
class ScrollBehaviorAnalyzer {
  constructor() {
    this.scrollEvents = [];
    this.scrollPattern = {
      directionChanges: 0,
      speedChanges: 0,
      smoothness: 1
    };
    
    this.initScrollListener();
  }
  
  initScrollListener() {
    let lastScrollTop = 0;
    let lastTimestamp = Date.now();
    
    window.addEventListener('scroll', () => {
      const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const currentTime = Date.now();
      const timeDiff = currentTime - lastTimestamp;
      
      const event = {
        scrollTop: currentScrollTop,
        timestamp: currentTime,
        scrollDelta: currentScrollTop - lastScrollTop,
        speed: timeDiff > 0 ? Math.abs(currentScrollTop - lastScrollTop) / timeDiff : 0
      };
      
      this.scrollEvents.push(event);
      
      // Анализ паттернов
      if (event.scrollDelta !== 0) {
        if ((currentScrollTop > lastScrollTop && lastScrollTop !== 0) || 
            (currentScrollTop < lastScrollTop && lastScrollTop !== 0)) {
          this.scrollPattern.directionChanges++;
        }
      }
      
      // Измерение изменений скорости
      if (this.scrollEvents.length > 1) {
        const prevSpeed = this.scrollEvents[this.scrollEvents.length - 2].speed;
        if (Math.abs(event.speed - prevSpeed) > 0.5) {
          this.scrollPattern.speedChanges++;
        }
      }
      
      lastScrollTop = currentScrollTop;
      lastTimestamp = currentTime;
    });
  }
  
  analyzeScrollBehavior() {
    if (this.scrollEvents.length < 5) {
      return { humanLike: true, score: 0.8 };
    }
    
    // Человеческий скролл обычно имеет изменения направления и скорости
    const directionChangeFrequency = this.scrollPattern.directionChanges / this.scrollEvents.length;
    const speedChangeFrequency = this.scrollPattern.speedChanges / this.scrollEvents.length;
    
    // Боты обычно скроллят более равномерно
    const humanLikeness = 
      (directionChangeFrequency * 0.4) + 
      (speedChangeFrequency * 0.4) + 
      (this.scrollPattern.smoothness * 0.2);
    
    return {
      humanLike: humanLikeness > 0.5,
      score: humanLikeness,
      directionChanges: this.scrollPattern.directionChanges,
      speedChanges: this.scrollPattern.speedChanges,
      totalEvents: this.scrollEvents.length
    };
  }
}
```

### 3. Комплексный анализ поведения

```javascript
class ComprehensiveBehaviorAnalyzer {
  constructor() {
    this.mouseAnalyzer = new MouseBehaviorAnalyzer();
    this.scrollAnalyzer = new ScrollBehaviorAnalyzer();
    this.typingAnalyzer = new TypingBehaviorAnalyzer();
    this.sessionData = {
      startTime: Date.now(),
      pageViews: [],
      formInteractions: []
    };
  }
  
  addPageView(url) {
    this.sessionData.pageViews.push({
      url: url,
      timestamp: Date.now(),
      referrer: document.referrer
    });
  }
  
  trackFormInteraction(formId, field, value) {
    this.sessionData.formInteractions.push({
      formId: formId,
      field: field,
      value: value ? '***' : '', // не сохранять значения для конфиденциальности
      timestamp: Date.now()
    });
  }
  
  generateComprehensiveReport() {
    const mouseReport = this.mouseAnalyzer.generateBehaviorReport();
    const scrollReport = this.scrollAnalyzer.analyzeScrollBehavior();
    const typingReport = this.typingAnalyzer.analyzeTypingPatterns();
    
    // Комбинированная оценка
    const combinedScore = (
      mouseReport.botScore * 0.4 +
      (1 - scrollReport.score) * 0.3 +  // инвертировать, так как высокий score = human-like
      typingReport.botScore * 0.3
    );
    
    return {
      overallBotScore: combinedScore,
      isBot: combinedScore > 0.6,
      mouseAnalysis: mouseReport,
      scrollAnalysis: scrollReport,
      typingAnalysis: typingReport,
      sessionData: {
        duration: Date.now() - this.sessionData.startTime,
        pageViews: this.sessionData.pageViews.length,
        formInteractions: this.sessionData.formInteractions.length
      }
    };
  }
}

// Пример TypingBehaviorAnalyzer
class TypingBehaviorAnalyzer {
  constructor() {
    this.typingEvents = [];
    this.initTypingListeners();
  }
  
  initTypingListeners() {
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        this.typingEvents.push({
          key: e.key,
          timestamp: Date.now(),
          target: e.target.type
        });
      }
    });
  }
  
  analyzeTypingPatterns() {
    if (this.typingEvents.length < 10) {
      return { botScore: 0.2, humanLike: true };
    }
    
    // Анализ интервалов между нажатиями клавиш
    const intervals = [];
    for (let i = 1; i < this.typingEvents.length; i++) {
      intervals.push(
        this.typingEvents[i].timestamp - this.typingEvents[i-1].timestamp
      );
    }
    
    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const variance = intervals.reduce((acc, interval) => 
      acc + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
    
    // Люди имеют более высокую вариативность в интервалах нажатия клавиш
    const consistency = Math.sqrt(variance) / avgInterval;
    const botScore = consistency < 0.5 ? 0.7 : 0.2; // низкая вариативность = бот
    
    return {
      botScore: botScore,
      humanLike: consistency > 0.5,
      avgInterval: avgInterval,
      consistency: consistency,
      totalKeypresses: this.typingEvents.length
    };
  }
}
```

## Серверная реализация анализа поведения

### 1. Хранение и анализ данных поведения

```javascript
const crypto = require('crypto');
const redis = require('redis');

class ServerBehaviorAnalyzer {
  constructor(redisClient) {
    this.redis = redisClient;
    this.sessionTimeout = 3600; // 1 час
  }
  
  async storeBehaviorData(sessionId, behaviorData) {
    const key = `behavior:${sessionId}`;
    
    // Сохранить данные поведения с TTL
    await this.redis.setex(
      key, 
      this.sessionTimeout, 
      JSON.stringify(behaviorData)
    );
    
    // Также сохранить в историю для анализа трендов
    await this.redis.lpush(
      `behavior_history:${this.getHourKey()}`,
      JSON.stringify({
        ...behaviorData,
        sessionId: sessionId,
        timestamp: Date.now()
      })
    );
    
    // Ограничить размер истории
    await this.redis.ltrim(`behavior_history:${this.getHourKey()}`, 0, 10000);
  }
  
  async analyzeBehavior(sessionId) {
    const key = `behavior:${sessionId}`;
    const data = await this.redis.get(key);
    
    if (!data) {
      throw new Error('Данные поведения не найдены');
    }
    
    const behavior = JSON.parse(data);
    
    // Анализ различных аспектов поведения
    const analysis = {
      botProbability: this.calculateBotProbability(behavior),
      riskLevel: this.determineRiskLevel(behavior),
      recommendations: this.generateRecommendations(behavior)
    };
    
    return analysis;
  }
  
  calculateBotProbability(behavior) {
    let score = 0;
    
    // Оценка по различным параметрам
    if (behavior.mouseAnalysis?.isLinear) score += 0.25;
    if (behavior.timingAnalysis?.isUniform) score += 0.2;
    if (behavior.timingAnalysis?.avgInterval < 100) score += 0.15;
    if (behavior.typingAnalysis?.consistency < 0.3) score += 0.2;
    if (behavior.sessionData?.duration < 5000) score += 0.1; // менее 5 секунд на сайте
    if (behavior.sessionData?.formInteractions > 10 && behavior.sessionData?.pageViews < 2) score += 0.1; // много форм, мало страниц
    
    // Нормализовать в диапазон 0-1
    return Math.min(1, score);
  }
  
  determineRiskLevel(behavior) {
    const probability = this.calculateBotProbability(behavior);
    
    if (probability > 0.8) return 'high';
    if (probability > 0.5) return 'medium';
    if (probability > 0.2) return 'low';
    return 'none';
  }
  
  generateRecommendations(behavior) {
    const recommendations = [];
    const probability = this.calculateBotProbability(behavior);
    
    if (probability > 0.6) {
      recommendations.push('Требуется дополнительная проверка пользователя');
      recommendations.push('Рассмотрите показ CAPTCHA');
    }
    
    if (behavior.mouseAnalysis?.isLinear) {
      recommendations.push('Обнаружено линейное движение мыши - признак автоматизации');
    }
    
    if (behavior.timingAnalysis?.isUniform) {
      recommendations.push('Равномерные интервалы действий - признак бота');
    }
    
    if (behavior.sessionData?.duration < 10000) {
      recommendations.push('Слишком короткая сессия - возможный бот');
    }
    
    return recommendations;
  }
  
  getHourKey() {
    const now = new Date();
    return `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}-${now.getHours()}`;
  }
}
```

### 2. Интеграция с системой безопасности

```javascript
// Middleware для анализа поведения
const behaviorAnalysisMiddleware = async (req, res, next) => {
  const sessionId = req.sessionID || generateSessionId(req);
  
  // Получить данные поведения от клиента
  if (req.body.behaviorData) {
    try {
      const analyzer = new ServerBehaviorAnalyzer(redisClient);
      await analyzer.storeBehaviorData(sessionId, req.body.behaviorData);
      
      // Если высокий риск, применить дополнительные проверки
      const analysis = await analyzer.analyzeBehavior(sessionId);
      
      if (analysis.riskLevel === 'high') {
        // Установить флаг высокого риска для последующих проверок
        req.highRisk = true;
        req.botProbability = analysis.botProbability;
      }
    } catch (error) {
      console.error('Ошибка анализа поведения:', error);
      // Не блокировать запрос из-за ошибки анализа
    }
  }
  
  next();
};

// Генерация уникального ID сессии
function generateSessionId(req) {
  return crypto
    .createHash('sha256')
    .update(req.ip + req.headers['user-agent'] + Date.now())
    .digest('hex');
}

// Применение к чувствительным маршрутам
app.use('/api/sensitive-operation', behaviorAnalysisMiddleware, (req, res, next) => {
  if (req.highRisk) {
    // Требовать дополнительную проверку для высокорисковых сессий
    return res.status(429).json({
      error: 'Обнаружена подозрительная активность. Пожалуйста, пройдите дополнительную проверку.',
      retryAfter: 300 // 5 минут
    });
  }
  
  next();
});
```

## Машинное обучение для анализа поведения

### 1. Простая модель на основе правил

```javascript
class RuleBasedBehaviorClassifier {
  constructor() {
    this.rules = [
      { condition: (data) => data.mouseAnalysis.isLinear, weight: 0.25, name: 'linear_mouse' },
      { condition: (data) => data.timingAnalysis.isUniform, weight: 0.2, name: 'uniform_timing' },
      { condition: (data) => data.timingAnalysis.avgInterval < 50, weight: 0.15, name: 'fast_actions' },
      { condition: (data) => data.sessionData.duration < 5000, weight: 0.1, name: 'short_session' },
      { condition: (data) => data.typingAnalysis.consistency > 0.8, weight: 0.15, name: 'robotic_typing' },
      { condition: (data) => data.mouseAnalysis.complexity < 0.3, weight: 0.15, name: 'simple_path' }
    ];
  }
  
  classify(behaviorData) {
    let score = 0;
    const triggeredRules = [];
    
    for (const rule of this.rules) {
      if (rule.condition(behaviorData)) {
        score += rule.weight;
        triggeredRules.push({
          name: rule.name,
          weight: rule.weight
        });
      }
    }
    
    return {
      isBot: score > 0.5,
      confidence: score,
      triggeredRules: triggeredRules,
      score: score
    };
  }
}
```

### 2. Адаптивное обучение

```javascript
class AdaptiveBehaviorModel {
  constructor() {
    this.model = {
      weights: {
        mouse_linearity: 0.25,
        timing_uniformity: 0.2,
        interaction_speed: 0.15,
        session_duration: 0.1,
        typing_consistency: 0.15,
        path_complexity: 0.15
      },
      learningRate: 0.01
    };
  }
  
  predict(behaviorFeatures) {
    let score = 0;
    
    score += behaviorFeatures.mouseLinearity * this.model.weights.mouse_linearity;
    score += behaviorFeatures.timingUniformity * this.model.weights.timing_uniformity;
    score += behaviorFeatures.interactionSpeed * this.model.weights.interaction_speed;
    score += (1 - behaviorFeatures.normalizedDuration) * this.model.weights.session_duration;
    score += behaviorFeatures.typingConsistency * this.model.weights.typing_consistency;
    score += (1 - behaviorFeatures.pathComplexity) * this.model.weights.path_complexity;
    
    return Math.min(1, Math.max(0, score));
  }
  
  updateWeights(features, actualLabel, prediction) {
    const error = actualLabel - prediction;
    
    // Обновить веса с использованием градиентного спуска
    this.model.weights.mouse_linearity += this.model.learningRate * error * features.mouseLinearity;
    this.model.weights.timing_uniformity += this.model.learningRate * error * features.timingUniformity;
    this.model.weights.interaction_speed += this.model.learningRate * error * features.interactionSpeed;
    this.model.weights.session_duration += this.model.learningRate * error * (1 - features.normalizedDuration);
    this.model.weights.typing_consistency += this.model.learningRate * error * features.typingConsistency;
    this.model.weights.path_complexity += this.model.learningRate * error * (1 - features.pathComplexity);
    
    // Ограничить веса в разумных пределах
    Object.keys(this.model.weights).forEach(key => {
      this.model.weights[key] = Math.min(1, Math.max(0, this.model.weights[key]));
    });
  }
}
```

## Лучшие практики

1. **Конфиденциальность данных** - не хранить чувствительную информацию о пользователях
2. **Баланс безопасности и удобства** - избегать ложных срабатываний
3. **Регулярное обновление моделей** - адаптация к новым методам ботов
4. **Мониторинг эффективности** - отслеживание точности детекции

## Связанные темы

- [[Обнаружение-ботов]]
- [[Реализация-CAPTCHA]]
- [[Ограничение-скорости]]

## Внешние ресурсы

- [Behavioral Biometrics in Security](https://owasp.org/www-community/controls/Behavioral_Biometrics)
- [User Behavior Analytics](https://www.sans.org/white-papers/38433/)

> [!warning]
> Следите за конфиденциальностью пользовательских данных при сборе и анализе поведения. Соблюдайте требования GDPR и других нормативных актов.

> [!tip]
> Используйте анализ поведения в сочетании с другими методами защиты, такими как [[Ограничение-скорости]] и [[Реализация-CAPTCHA]], для создания многоуровневой защиты.