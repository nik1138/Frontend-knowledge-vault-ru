---
aliases: ["Ограничение ресурсов", "Ограничение потребления ресурсов", "Resource Limiting"]
tags: [security, resource-limiting, rate-limiting, web-security]
---

# Ограничение ресурсов

## Введение

Ограничение ресурсов — это важная стратегия безопасности, направленная на предотвращение чрезмерного потребления системных ресурсов веб-приложения. Эта практика помогает защитить приложения от различных атак, таких как DoS (Denial of Service) и злоупотреблений, когда пользователи или боты чрезмерно используют функции приложения.

## Основные концепции

### Что такое ограничение ресурсов

Ограничение ресурсов — это метод контроля использования системных ресурсов (CPU, памяти, пропускной способности, API-вызовов и т.д.) с целью:

- Предотвращения перегрузки сервера
- Обеспечения стабильной работы приложения
- Защиты от атак типа "отказ в обслуживании"
- Управления качеством обслуживания для пользователей

### Типы ресурсов, подлежащих ограничению

1. **Вычислительные ресурсы** (CPU, память)
2. **Сетевые ресурсы** (пропускная способность)
3. **API-запросы** (ограничение частоты вызовов)
4. **Файловые ресурсы** (размер загружаемых файлов, количество файлов)
5. **Базы данных** (количество запросов, объем данных)
6. **Кэш-ресурсы** (ограничение использования кэша)

## Ограничение ресурсов в браузере

### Ограничение использования CPU и памяти

Браузеры имеют встроенные механизмы ограничения ресурсов:

```javascript
// Пример ограничения сложных вычислений
function performHeavyCalculation(data) {
  // Ограничиваем количество итераций
  const maxIterations = 1000;
  let iterations = 0;
  
  for (let i = 0; i < data.length && iterations < maxIterations; i++) {
    // Выполняем вычисления
    processItem(data[i]);
    iterations++;
    
    // Позволяем браузеру обработать другие задачи
    if (iterations % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
}
```

### Ограничение выполнения JavaScript

Современные браузеры могут ограничивать выполнение JavaScript в следующих аспектах:

- Количество циклов в синхронном коде
- Размер стека вызовов
- Объем используемой памяти

> [!warning] Важно
> Слишком интенсивный JavaScript-код может быть остановлен браузером для защиты от зависания.

### Ограничение доступа к ресурсам через Web Workers

Web Workers позволяют выполнять тяжелые вычисления в фоновых потоках:

```javascript
// main.js
const worker = new Worker('heavy-computation.js');

worker.postMessage({ data: largeDataset });

worker.onmessage = function(e) {
  console.log('Результат вычислений:', e.data);
  worker.terminate(); // Завершаем воркер для освобождения ресурсов
};

// heavy-computation.js
self.onmessage = function(e) {
  const result = performComputation(e.data);
  self.postMessage(result);
  self.close(); // Закрываем воркер
};
```

## Ограничение ресурсов на клиентской стороне

### Ограничение сетевых запросов

```javascript
class RequestLimiter {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.currentRequests = 0;
    this.queue = [];
  }

  async makeRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
      const request = { url, options, resolve, reject };
      
      if (this.currentRequests < this.maxConcurrent) {
        this.executeRequest(request);
      } else {
        this.queue.push(request);
      }
    });
  }

  async executeRequest(request) {
    this.currentRequests++;
    
    try {
      const response = await fetch(request.url, request.options);
      request.resolve(response);
    } catch (error) {
      request.reject(error);
    } finally {
      this.currentRequests--;
      
      // Обрабатываем следующий запрос из очереди
      if (this.queue.length > 0) {
        const nextRequest = this.queue.shift();
        this.executeRequest(nextRequest);
      }
    }
  }
}

// Использование
const limiter = new RequestLimiter(3);
```

### Ограничение использования кэша

```javascript
class CacheLimiter {
  constructor(maxSize = 10 * 1024 * 1024) { // 10 МБ
    this.maxSize = maxSize;
    this.currentSize = 0;
    this.cache = new Map();
  }

  set(key, value) {
    const serializedValue = JSON.stringify(value);
    const size = new Blob([serializedValue]).size;

    if (this.currentSize + size > this.maxSize) {
      this.clearOldestEntries(size);
    }

    this.cache.set(key, { value, size, timestamp: Date.now() });
    this.currentSize += size;
  }

  get(key) {
    const item = this.cache.get(key);
    return item ? item.value : null;
  }

  clearOldestEntries(requiredSize) {
    const entries = Array.from(this.cache.entries())
      .map(([key, item]) => ({ key, item }))
      .sort((a, b) => a.item.timestamp - b.item.timestamp);

    for (const entry of entries) {
      this.cache.delete(entry.key);
      this.currentSize -= entry.item.size;

      if (this.currentSize + requiredSize <= this.maxSize) {
        break;
      }
    }
  }
}
```

### Ограничение обработки файлов

```javascript
class FileProcessor {
  constructor(maxFileSize = 10 * 1024 * 1024) { // 10 МБ
    this.maxFileSize = maxFileSize;
  }

  async processFile(file) {
    // Проверяем размер файла
    if (file.size > this.maxFileSize) {
      throw new Error(`Файл слишком большой: ${file.size} байт. Максимум: ${this.maxFileSize} байт`);
    }

    // Ограничиваем использование памяти при обработке
    const reader = new FileReader();
    
    return new Promise((resolve, reject) => {
      reader.onload = (event) => {
        // Обработка содержимого файла
        const result = this.processContent(event.target.result);
        resolve(result);
      };
      
      reader.onerror = () => reject(new Error('Ошибка чтения файла'));
      reader.readAsArrayBuffer(file.slice(0, this.maxFileSize)); // Ограничиваем размер
    });
  }

  processContent(content) {
    // Обработка содержимого с учетом ограничений
    return new Uint8Array(content);
  }
}
```

## Ограничение ресурсов на серверной стороне

### Ограничение частоты запросов (Rate Limiting)

```javascript
// Пример реализации ограничения частоты запросов
class RateLimiter {
  constructor(options = {}) {
    this.maxRequests = options.maxRequests || 100;
    this.windowMs = options.windowMs || 15 * 60 * 1000; // 15 минут
    this.clients = new Map();
  }

  isAllowed(clientId) {
    const now = Date.now();
    const client = this.clients.get(clientId) || { requests: [], resetTime: now + this.windowMs };

    // Удаляем старые запросы
    client.requests = client.requests.filter(time => time > now - this.windowMs);

    if (client.requests.length >= this.maxRequests) {
      return false; // Лимит превышен
    }

    // Добавляем новый запрос
    client.requests.push(now);
    this.clients.set(clientId, client);

    return true;
  }

  getResetTime(clientId) {
    const client = this.clients.get(clientId);
    return client ? client.resetTime : Date.now() + this.windowMs;
  }
}

// Использование в Express.js
const rateLimiter = new RateLimiter({ maxRequests: 100, windowMs: 15 * 60 * 1000 });

app.use('/api/', (req, res, next) => {
  const clientId = req.ip; // или req.session.id
  
  if (!rateLimiter.isAllowed(clientId)) {
    const resetTime = rateLimiter.getResetTime(clientId);
    res.status(429).json({
      error: 'Превышено количество запросов',
      resetTime: new Date(resetTime)
    });
    return;
  }
  
  next();
});
```

### Ограничение использования памяти

```javascript
// Проверка использования памяти (Node.js)
function checkMemoryUsage() {
  const usage = process.memoryUsage();
  const heapUsed = usage.heapUsed;
  const heapTotal = usage.heapTotal;
  
  const memoryThreshold = 500 * 1024 * 1024; // 500 МБ
  
  if (heapUsed > memoryThreshold) {
    console.warn('Превышено использование памяти:', heapUsed);
    // Выполнить очистку или ограничение
    return false;
  }
  
  return true;
}

// Пример использования
setInterval(() => {
  if (!checkMemoryUsage()) {
    // Ограничить выполнение новых операций
    global.memoryLimitExceeded = true;
  } else {
    global.memoryLimitExceeded = false;
  }
}, 1000);
```

## Практические рекомендации

### Установка разумных лимитов

1. **Анализ нагрузки**: Изучите нормальное использование ресурсов вашим приложением
2. **Градация лимитов**: Установите разные лимиты для разных типов пользователей
3. **Мониторинг**: Регулярно отслеживайте использование ресурсов
4. **Гибкость**: Позвольте администраторам настраивать лимиты

### Обработка превышения лимитов

```javascript
// Пример обработки превышения лимитов
function handleResourceLimitExceeded(resourceType, limit, currentUsage) {
  console.warn(`Превышен лимит ресурса ${resourceType}: ${currentUsage}/${limit}`);
  
  // Логирование события
  logSecurityEvent({
    type: 'RESOURCE_LIMIT_EXCEEDED',
    resource: resourceType,
    limit: limit,
    usage: currentUsage,
    timestamp: new Date().toISOString()
  });
  
  // Возврат ошибки пользователю
  throw new Error(`Превышен лимит ресурса: ${resourceType}`);
}
```

### Уведомления и алерты

```javascript
class ResourceMonitor {
  constructor(thresholds) {
    this.thresholds = thresholds; // { cpu: 80, memory: 85, network: 90 }
    this.alerts = [];
  }

  checkResources() {
    const usage = this.getCurrentUsage();
    
    Object.keys(this.thresholds).forEach(resource => {
      if (usage[resource] > this.thresholds[resource]) {
        this.sendAlert(resource, usage[resource], this.thresholds[resource]);
      }
    });
  }

  sendAlert(resource, current, threshold) {
    const alert = {
      resource,
      current,
      threshold,
      timestamp: new Date(),
      severity: current > threshold * 1.2 ? 'HIGH' : 'MEDIUM'
    };
    
    this.alerts.push(alert);
    this.notifyAdmins(alert);
  }
}
```

## Связь с другими аспектами безопасности

Ограничение ресурсов тесно связано с:
- [[Предотвращение-злоупотреблений]] — предотвращение неправомерного использования ресурсов
- [[Управление-квотами]] — контроль за использованием ресурсов
- [[Обнаружение-и-предотвращение-брутфорса]] — защита от атак методом подбора
- [[Меры-против-ботов]] — защита от автоматизированных злоупотреблений
- [[Ограничение-скорости]] — контроль частоты запросов

## Заключение

Ограничение ресурсов — это важная часть стратегии безопасности веб-приложений. Оно помогает защитить приложения от перегрузки, обеспечивает стабильную работу и предотвращает злоупотребления. Правильная реализация ограничений требует баланса между безопасностью и удобством использования.

## Дополнительные ресурсы

- OWASP Resource Limiting Guidelines
- Rate Limiting Best Practices
- Browser Resource Management Documentation