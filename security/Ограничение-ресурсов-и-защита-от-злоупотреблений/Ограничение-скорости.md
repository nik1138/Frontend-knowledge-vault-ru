---
aliases: ["Rate Limiting", "Ограничение частоты запросов", "Защита от DDoS"]
tags: [security, api, rate-limiting, performance]
---

# Ограничение скорости (Rate Limiting)

## Обзор

Ограничение скорости (Rate Limiting) - это техника, используемая для контроля частоты запросов, которые могут быть отправлены пользователем или IP-адресом к API или веб-приложению за определенный период времени. Эта мера безопасности предотвращает злоупотребление сервисом и защищает от различных атак, включая DDoS (Distributed Denial of Service).

## Зачем нужна система ограничения скорости

### Предотвращение перегрузки сервера

Без системы ограничения скорости злонамеренные пользователи могут отправлять большое количество запросов, что приведет к:

- Перегрузке сервера
- Потере производительности
- Отказу в обслуживании для других пользователей

### Защита от атак

Ограничение скорости помогает предотвратить:

- Атаки методом перебора (brute force)
- DDoS-атаки
- Сканирование уязвимостей
- Атаки на аутентификацию

## Типы ограничений скорости

### По IP-адресу

Самый распространенный метод - ограничение количества запросов с одного IP-адреса. Это помогает предотвратить злоупотребление, но может быть проблематичным в случаях:

- Совместного использования IP-адреса (например, в корпоративных сетях)
- Использования прокси-серверов

### По пользовательским токенам

Более точный метод - ограничение на основе пользовательских токенов или API-ключей. Это позволяет:

- Устанавливать индивидуальные лимиты для разных пользователей
- Отслеживать активность конкретных пользователей
- Применять дифференцированные политики для разных тарифных планов

### По эндпоинтам

Различные эндпоинты могут иметь разные ограничения:

- GET-запросы: 1000 запросов в час
- POST-запросы: 100 запросов в час
- Аутентификационные эндпоинты: 5 запросов в минуту

## Алгоритмы ограничения скорости

### Token Bucket (Ведро токенов)

Алгоритм работает следующим образом:

1. Создается "ведро", которое может содержать определенное количество "токенов"
2. Токены добавляются в ведро с постоянной скоростью
3. Каждый запрос требует один токен
4. Если токенов нет, запрос отклоняется

```javascript
class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;
    this.tokens = capacity;
    this.refillRate = refillRate; // токенов в секунду
    this.lastRefill = Date.now();
  }

  consume(tokens = 1) {
    this.refill();
    
    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true; // запрос разрешен
    }
    return false; // запрос отклонен
  }

  refill() {
    const now = Date.now();
    const tokensToAdd = Math.floor((now - this.lastRefill) * this.refillRate / 1000);
    
    if (tokensToAdd > 0) {
      this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
      this.lastRefill = now;
    }
  }
}
```

### Leaky Bucket (Протекающее ведро)

Алгоритм сглаживает поток запросов:

1. Запросы помещаются в ведро с фиксированной скоростью
2. Если ведро заполнено, новые запросы отклоняются
3. Ведро "протекает" с постоянной скоростью

### Fixed Window Counter (Счетчик с фиксированным окном)

Простой алгоритм, который:

1. Устанавливает фиксированный временной интервал (например, 1 час)
2. Считает количество запросов в этом интервале
3. Отклоняет запросы, если лимит превышен

### Sliding Window Counter (Счетчик со скользящим окном)

Более точный метод, который:

1. Использует два временных окна: текущее и предыдущее
2. Интерполирует количество запросов между окнами
3. Обеспечивает более точное ограничение

## Реализация в Node.js

### Простая реализация с использованием Redis

```javascript
const redis = require('redis');
const client = redis.createClient();

async function checkRateLimit(identifier, limit, window) {
  const key = `rate_limit:${identifier}`;
  const now = Date.now();
  const windowStart = now - window;

  // Удаляем старые записи
  await client.zremrangebyscore(key, 0, windowStart);
  
  // Получаем количество запросов в текущем окне
  const count = await client.zcard(key);
  
  if (count >= limit) {
    return { allowed: false, retryAfter: windowStart + window - now };
  }
  
  // Добавляем текущий запрос
  await client.zadd(key, now, `${now}:${Math.random()}`);
  await client.expire(key, Math.ceil(window / 1000));
  
  return { allowed: true, remaining: limit - count - 1 };
}
```

### Использование Express с middleware

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 100, // ограничение на 100 запросов за 15 минут
  message: 'Слишком много запросов с этого IP, попробуйте позже',
  standardHeaders: true, // возвращать информацию о лимитах в заголовках
  legacyHeaders: false, // отключить заголовки X-RateLimit
});

app.use('/api/', limiter);
```

## Лучшие практики

### Гибкие лимиты

Устанавливайте разные лимиты для разных типов пользователей:

- Анонимные пользователи: 10 запросов в минуту
- Зарегистрированные пользователи: 100 запросов в минуту
- Платные пользователи: 1000 запросов в минуту

### Уведомления о лимитах

Возвращайте информацию о лимитах в заголовках HTTP:

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 99
X-RateLimit-Reset: 1632521200
```

### Обработка исключений

Учитывайте случаи, когда ограничение может быть слишком строгим:

- Административные запросы
- Внутренние сервисы
- Тестирование

## Мониторинг и аналитика

### Метрики для отслеживания

- Частота срабатывания ограничений
- Среднее количество запросов на пользователя
- Распределение запросов по времени
- Аномалии в поведении пользователей

### Алертинг

Настройте уведомления о:

- Частых срабатываниях ограничений
- Подозрительной активности
- Неожиданных паттернах запросов

## Заключение

Эффективное ограничение скорости - важная часть безопасности и производительности API. Правильная реализация помогает предотвратить злоупотребления, защитить ресурсы и обеспечить стабильную работу сервиса для всех пользователей.

## Связанные темы

- [[Лучшие-практики-безопасности-API]]
- [[Тестирование-безопасности]]
- [[Методы-тестирования-безопасности]]
- [[Автоматизированное-тестирование-безопасности]]