---
aliases: ["Управление квотами", "Квотирование ресурсов", "Resource Quotas"]
tags: [security, quotas, resource-management, web-security]
---

# Управление квотами

## Введение

Управление квотами — это стратегия контроля и распределения ресурсов веб-приложения среди пользователей или сервисов. Квоты позволяют ограничить использование определенных ресурсов или функций, обеспечивая справедливое распределение и предотвращая перегрузку системы. Эффективное управление квотами является важным аспектом безопасности и стабильности веб-приложений.

## Основные концепции квотирования

### Что такое квота

Квота — это ограниченное количество ресурсов или операций, которое может быть использовано пользователем, приложением или системой в определенный период времени. Квоты могут быть установлены на:

- Количество API-запросов
- Объем передаваемых данных
- Количество загружаемых файлов
- Количество создаваемых объектов
- Использование вычислительных ресурсов

### Типы квот

1. **Временные квоты** — ограничения, действующие в течение определенного периода
2. **Объемные квоты** — ограничения на общий объем использования
3. **Комбинированные квоты** — сочетание временных и объемных ограничений

## Реализация квот на клиентской стороне

### Клиентская система квотирования

```javascript
class ClientQuotaManager {
  constructor() {
    this.quotas = new Map();
    this.usage = new Map();
  }

  // Установка квоты для конкретного ресурса
  setQuota(resource, limit, period = 'daily') {
    this.quotas.set(resource, {
      limit,
      period,
      resetTime: this.calculateResetTime(period)
    });
  }

  // Проверка, можно ли использовать ресурс
  canUse(resource, amount = 1) {
    const currentUsage = this.getCurrentUsage(resource);
    const quota = this.quotas.get(resource);
    
    if (!quota) {
      return true; // Если квота не установлена, разрешаем
    }

    // Проверяем, нужно ли сбросить квоту
    if (Date.now() > quota.resetTime) {
      this.resetUsage(resource, quota.period);
    }

    const newUsage = currentUsage + amount;
    return newUsage <= quota.limit;
  }

  // Использование ресурса (если квота позволяет)
  use(resource, amount = 1) {
    if (!this.canUse(resource, amount)) {
      throw new Error(`Превышена квота для ресурса: ${resource}`);
    }

    const currentUsage = this.getCurrentUsage(resource);
    this.usage.set(resource, currentUsage + amount);
    
    return true;
  }

  // Получение текущего использования
  getCurrentUsage(resource) {
    const usage = this.usage.get(resource) || { count: 0, lastReset: Date.now() };
    
    const quota = this.quotas.get(resource);
    if (quota && Date.now() > quota.resetTime) {
      // Квота истекла, сбрасываем использование
      this.resetUsage(resource, quota.period);
      return 0;
    }

    return usage.count;
  }

  // Получение оставшегося количества
  getRemaining(resource) {
    const quota = this.quotas.get(resource);
    if (!quota) return Infinity;

    return quota.limit - this.getCurrentUsage(resource);
  }

  // Сброс использования
  resetUsage(resource, period) {
    this.usage.set(resource, {
      count: 0,
      lastReset: Date.now()
    });
    
    const quota = this.quotas.get(resource);
    if (quota) {
      quota.resetTime = this.calculateResetTime(period);
    }
  }

  // Расчет времени сброса квоты
  calculateResetTime(period) {
    const now = Date.now();
    
    switch (period) {
      case 'hourly':
        return now + 60 * 60 * 1000; // 1 час
      case 'daily':
        // Сброс в полночь
        const tomorrow = new Date();
        tomorrow.setHours(24, 0, 0, 0);
        return tomorrow.getTime();
      case 'weekly':
        // Сброс в понедельник
        const nextMonday = new Date();
        nextMonday.setDate(nextMonday.getDate() + (1 + 7 - nextMonday.getDay()) % 7);
        nextMonday.setHours(0, 0, 0, 0);
        return nextMonday.getTime();
      case 'monthly':
        // Сброс в первый день следующего месяца
        const nextMonth = new Date();
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        nextMonth.setDate(1);
        nextMonth.setHours(0, 0, 0, 0);
        return nextMonth.getTime();
      default:
        return now + 24 * 60 * 60 * 1000; // По умолчанию - 24 часа
    }
  }
}

// Использование
const quotaManager = new ClientQuotaManager();

// Устанавливаем квоты
quotaManager.setQuota('api_calls', 100, 'daily'); // 100 вызовов API в день
quotaManager.setQuota('file_uploads', 10, 'daily'); // 10 загрузок файлов в день
quotaManager.setQuota('data_transfer', 100 * 1024 * 1024, 'monthly'); // 100 МБ в месяц
```

### Интеграция с API-запросами

```javascript
class QuotaAwareAPIClient {
  constructor(quotaManager) {
    this.quotaManager = quotaManager;
    this.baseURL = process.env.API_BASE_URL;
  }

  async makeRequest(endpoint, options = {}) {
    // Проверяем квоту на API-вызовы
    if (!this.quotaManager.canUse('api_calls')) {
      throw new Error('Превышена дневная квота на API-вызовы');
    }

    try {
      // Используем квоту
      this.quotaManager.use('api_calls');
      
      // Выполняем запрос
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        headers: {
          ...options.headers,
          'X-Quota-Remaining': this.quotaManager.getRemaining('api_calls')
        }
      });

      return response;
    } catch (error) {
      if (error.message.includes('Превышена квота')) {
        // Обработка превышения квоты
        this.handleQuotaExceeded('api_calls');
      }
      throw error;
    }
  }

  async uploadFile(file) {
    // Проверяем квоту на загрузку файлов
    if (!this.quotaManager.canUse('file_uploads')) {
      throw new Error('Превышена дневная квота на загрузку файлов');
    }

    // Проверяем квоту на передачу данных
    if (!this.quotaManager.canUse('data_transfer', file.size)) {
      throw new Error('Превышена месячная квота на передачу данных');
    }

    try {
      // Используем квоты
      this.quotaManager.use('file_uploads');
      this.quotaManager.use('data_transfer', file.size);

      // Выполняем загрузку
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${this.baseURL}/upload`, {
        method: 'POST',
        body: formData
      });

      return response;
    } catch (error) {
      if (error.message.includes('Превышена квота')) {
        this.handleQuotaExceeded('file_uploads');
      }
      throw error;
    }
  }

  handleQuotaExceeded(resource) {
    // Показываем пользователю уведомление о превышении квоты
    showQuotaExceededNotification(resource, this.quotaManager.getResetTime(resource));
  }
}
```

### Хранение квот в локальном хранилище

```javascript
class PersistentQuotaManager extends ClientQuotaManager {
  constructor() {
    super();
    this.storageKey = 'app_quotas';
    this.loadFromStorage();
  }

  // Загрузка квот из локального хранилища
  loadFromStorage() {
    try {
      const storedData = localStorage.getItem(this.storageKey);
      if (storedData) {
        const data = JSON.parse(storedData);
        
        // Восстанавливаем квоты
        if (data.quotas) {
          for (const [resource, quota] of Object.entries(data.quotas)) {
            this.quotas.set(resource, quota);
          }
        }
        
        // Восстанавливаем использование
        if (data.usage) {
          for (const [resource, usage] of Object.entries(data.usage)) {
            this.usage.set(resource, usage);
          }
        }
      }
    } catch (error) {
      console.warn('Ошибка при загрузке квот из локального хранилища:', error);
    }
  }

  // Сохранение квот в локальное хранилище
  saveToStorage() {
    try {
      const data = {
        quotas: Object.fromEntries(this.quotas),
        usage: Object.fromEntries(this.usage),
        lastUpdated: Date.now()
      };
      
      localStorage.setItem(this.storageKey, JSON.stringify(data));
    } catch (error) {
      console.warn('Ошибка при сохранении квот в локальное хранилище:', error);
    }
  }

  // Переопределение методов для автоматического сохранения
  setQuota(resource, limit, period = 'daily') {
    super.setQuota(resource, limit, period);
    this.saveToStorage();
  }

  use(resource, amount = 1) {
    const result = super.use(resource, amount);
    this.saveToStorage();
    return result;
  }

  resetUsage(resource, period) {
    super.resetUsage(resource, period);
    this.saveToStorage();
  }
}
```

## Реализация квот на серверной стороне

### Серверный менеджер квот

```javascript
class ServerQuotaManager {
  constructor(dbConnection) {
    this.db = dbConnection;
  }

  // Проверка квоты пользователя
  async checkUserQuota(userId, resource) {
    const quota = await this.getUserQuota(userId, resource);
    const usage = await this.getUserUsage(userId, resource);
    
    if (!quota) {
      return { allowed: true, remaining: Infinity, limit: Infinity };
    }

    const remaining = quota.limit - usage.count;
    const allowed = remaining > 0;
    
    return {
      allowed,
      remaining: Math.max(0, remaining),
      limit: quota.limit,
      used: usage.count,
      resetTime: quota.resetTime
    };
  }

  // Использование ресурса пользователем
  async useResource(userId, resource, amount = 1) {
    const quotaCheck = await this.checkUserQuota(userId, resource);
    
    if (!quotaCheck.allowed) {
      throw new Error(`Превышена квота для ресурса: ${resource}`);
    }

    // Обновляем использование
    await this.updateUserUsage(userId, resource, amount);
    
    return quotaCheck.remaining - amount;
  }

  // Получение квоты пользователя
  async getUserQuota(userId, resource) {
    const query = `
      SELECT resource, limit, period, reset_time 
      FROM user_quotas 
      WHERE user_id = ? AND resource = ?
    `;
    
    const result = await this.db.query(query, [userId, resource]);
    return result.length > 0 ? result[0] : null;
  }

  // Получение использования пользователем
  async getUserUsage(userId, resource) {
    const query = `
      SELECT resource, SUM(amount) as count
      FROM user_usage 
      WHERE user_id = ? AND resource = ? AND timestamp > ?
    `;
    
    // Получаем время сброса квоты
    const quota = await this.getUserQuota(userId, resource);
    const resetTime = quota ? quota.reset_time : this.calculateResetTime(quota.period);
    
    const result = await this.db.query(query, [userId, resource, resetTime]);
    return { resource, count: parseInt(result[0]?.count || 0) };
  }

  // Обновление использования
  async updateUserUsage(userId, resource, amount) {
    const query = `
      INSERT INTO user_usage (user_id, resource, amount, timestamp) 
      VALUES (?, ?, ?, ?)
    `;
    
    await this.db.query(query, [userId, resource, amount, new Date()]);
  }

  // Расчет времени сброса
  calculateResetTime(period) {
    const now = new Date();
    
    switch (period) {
      case 'hourly':
        now.setMinutes(0, 0, 0);
        now.setHours(now.getHours() + 1);
        break;
      case 'daily':
        now.setHours(24, 0, 0, 0);
        break;
      case 'weekly':
        const dayToAdd = (1 + 7 - now.getDay()) % 7;
        now.setDate(now.getDate() + dayToAdd);
        now.setHours(0, 0, 0, 0);
        break;
      case 'monthly':
        now.setMonth(now.getMonth() + 1);
        now.setDate(1);
        now.setHours(0, 0, 0, 0);
        break;
    }
    
    return now;
  }
}
```

### Middleware для проверки квот

```javascript
// Express.js middleware для проверки квот
function quotaMiddleware(quotaManager) {
  return async (req, res, next) => {
    const userId = req.user?.id; // Предполагаем, что пользователь аутентифицирован
    const resource = req.originalUrl; // Используем URL как ресурс
    
    if (!userId) {
      // Для анонимных пользователей можем использовать IP
      const ip = req.ip;
      // Здесь можно реализовать квоты для анонимных пользователей
      return next();
    }

    try {
      // Проверяем квоту на API-вызовы
      const quotaCheck = await quotaManager.checkUserQuota(userId, 'api_calls');
      
      if (!quotaCheck.allowed) {
        return res.status(429).json({
          error: 'Превышена квота на API-вызовы',
          resetTime: quotaCheck.resetTime,
          limit: quotaCheck.limit
        });
      }

      // Используем квоту
      await quotaManager.useResource(userId, 'api_calls');
      
      // Добавляем информацию о квоте в заголовки
      res.setHeader('X-RateLimit-Limit', quotaCheck.limit);
      res.setHeader('X-RateLimit-Remaining', quotaCheck.remaining - 1);
      res.setHeader('X-RateLimit-Reset', quotaCheck.resetTime);
      
      next();
    } catch (error) {
      if (error.message.includes('Превышена квота')) {
        return res.status(429).json({
          error: 'Превышена квота на использование ресурса'
        });
      }
      next(error);
    }
  };
}

// Использование middleware
app.use('/api/', quotaMiddleware(quotaManager));
```

### Квоты для конкретных функций

```javascript
class FeatureQuotaManager extends ServerQuotaManager {
  // Квота на отправку сообщений
  async canSendMessage(userId, messageLength) {
    // Проверяем количество сообщений
    const messageQuota = await this.checkUserQuota(userId, 'messages');
    if (!messageQuota.allowed) {
      return { allowed: false, reason: 'Превышено количество сообщений' };
    }

    // Проверяем объем данных
    const dataQuota = await this.checkUserQuota(userId, 'data_transfer');
    if (!dataQuota.allowed || dataQuota.remaining < messageLength) {
      return { allowed: false, reason: 'Превышена квота на передачу данных' };
    }

    return { allowed: true };
  }

  // Квота на загрузку файлов
  async canUploadFile(userId, fileSize) {
    // Проверяем количество загрузок
    const uploadQuota = await this.checkUserQuota(userId, 'file_uploads');
    if (!uploadQuota.allowed) {
      return { allowed: false, reason: 'Превышено количество загрузок файлов' };
    }

    // Проверяем объем данных
    const storageQuota = await this.checkUserQuota(userId, 'storage_space');
    if (!storageQuota.allowed || storageQuota.remaining < fileSize) {
      return { allowed: false, reason: 'Недостаточно места в хранилище' };
    }

    return { allowed: true };
  }

  // Квота на создание проектов
  async canCreateProject(userId) {
    const projectQuota = await this.checkUserQuota(userId, 'projects');
    return { allowed: projectQuota.allowed };
  }

  // Использование квоты для отправки сообщения
  async sendMessage(userId, message) {
    const canSend = await this.canSendMessage(userId, message.length);
    
    if (!canSend.allowed) {
      throw new Error(canSend.reason);
    }

    // Используем квоты
    await this.useResource(userId, 'messages');
    await this.useResource(userId, 'data_transfer', message.length);

    // Отправляем сообщение
    return await this.sendActualMessage(userId, message);
  }

  // Использование квоты для загрузки файла
  async uploadFile(userId, file) {
    const canUpload = await this.canUploadFile(userId, file.size);
    
    if (!canUpload.allowed) {
      throw new Error(canUpload.reason);
    }

    // Используем квоты
    await this.useResource(userId, 'file_uploads');
    await this.useResource(userId, 'storage_space', file.size);

    // Загружаем файл
    return await this.storeFile(userId, file);
  }
}
```

## Управление квотами для разных типов пользователей

### Ролевая система квот

```javascript
class RoleBasedQuotaManager {
  constructor() {
    this.roleQuotas = {
      'free': {
        'api_calls': { limit: 100, period: 'daily' },
        'file_uploads': { limit: 10, period: 'daily' },
        'storage_space': { limit: 100 * 1024 * 1024, period: 'monthly' } // 100 МБ
      },
      'premium': {
        'api_calls': { limit: 1000, period: 'daily' },
        'file_uploads': { limit: 100, period: 'daily' },
        'storage_space': { limit: 1024 * 1024 * 1024, period: 'monthly' } // 1 ГБ
      },
      'enterprise': {
        'api_calls': { limit: 10000, period: 'daily' },
        'file_uploads': { limit: 1000, period: 'daily' },
        'storage_space': { limit: 10 * 1024 * 1024 * 1024, period: 'monthly' } // 10 ГБ
      }
    };
  }

  getQuotasForRole(role) {
    return this.roleQuotas[role] || this.roleQuotas['free'];
  }

  async initializeUserQuotas(userId, role) {
    const quotas = this.getQuotasForRole(role);
    
    for (const [resource, quota] of Object.entries(quotas)) {
      await this.setQuotaForUser(userId, resource, quota.limit, quota.period);
    }
  }

  async setQuotaForUser(userId, resource, limit, period) {
    // Установка квоты для конкретного пользователя
    const query = `
      INSERT INTO user_quotas (user_id, resource, limit, period) 
      VALUES (?, ?, ?, ?)
      ON DUPLICATE KEY UPDATE limit = ?, period = ?
    `;
    
    await this.db.query(query, [userId, resource, limit, period, limit, period]);
  }

  // Обновление роли пользователя и соответствующих квот
  async updateUserRole(userId, newRole) {
    // Удаляем текущие квоты
    await this.db.query('DELETE FROM user_quotas WHERE user_id = ?', [userId]);
    
    // Устанавливаем новые квоты
    await this.initializeUserQuotas(userId, newRole);
  }
}
```

## Мониторинг и аналитика квот

### Система мониторинга квот

```javascript
class QuotaMonitoring {
  constructor() {
    this.alertThreshold = 0.9; // 90% от лимита
    this.alerts = [];
  }

  // Проверка приближения к лимиту
  async checkQuotaAlerts(userId, resource) {
    const quotaCheck = await this.quotaManager.checkUserQuota(userId, resource);
    
    if (quotaCheck.limit === Infinity) {
      return; // Для неограниченных квот не проверяем
    }

    const usagePercentage = quotaCheck.used / quotaCheck.limit;
    
    if (usagePercentage >= this.alertThreshold) {
      await this.sendQuotaAlert(userId, resource, usagePercentage, quotaCheck);
    }
  }

  async sendQuotaAlert(userId, resource, usagePercentage, quotaDetails) {
    const alert = {
      userId,
      resource,
      usagePercentage: Math.round(usagePercentage * 100),
      limit: quotaDetails.limit,
      used: quotaDetails.used,
      remaining: quotaDetails.remaining,
      timestamp: new Date().toISOString()
    };

    this.alerts.push(alert);
    
    // Отправляем уведомление пользователю
    await this.notifyUser(userId, alert);
    
    // Логируем событие
    console.log('Квота почти исчерпана:', alert);
  }

  async notifyUser(userId, alert) {
    // Здесь можно реализовать отправку уведомления пользователю
    // через email, push-уведомления или внутриприложениее сообщение
    console.log(`Уведомление пользователю ${userId}: квота на ${alert.resource} почти исчерпана (${alert.usagePercentage}%)`);
  }

  // Получение статистики по квотам
  async getQuotaStatistics() {
    const stats = await this.db.query(`
      SELECT 
        resource,
        AVG(usage_percentage) as avg_usage,
        MAX(usage_percentage) as max_usage,
        COUNT(*) as total_users
      FROM (
        SELECT 
          uq.resource,
          (uu.count * 100.0 / uq.limit) as usage_percentage
        FROM user_quotas uq
        JOIN user_usage uu ON uq.user_id = uu.user_id AND uq.resource = uu.resource
        WHERE uu.timestamp > DATE_SUB(NOW(), INTERVAL 1 DAY)
      ) as daily_usage
      GROUP BY resource
    `);

    return stats;
  }
}
```

## Практические рекомендации

### Установка разумных лимитов

1. **Анализ использования**: Изучите нормальное использование ресурсов пользователями
2. **Градация лимитов**: Установите разные лимиты для разных типов пользователей
3. **Мягкие ограничения**: Используйте предупреждения до жестких ограничений
4. **Гибкость**: Позвольте администраторам настраивать лимиты

### Обработка превышения квот

```javascript
// Централизованная обработка превышения квот
function handleQuotaExceeded(error, req, res, next) {
  if (error.message.includes('Превышена квота')) {
    const resource = error.message.match(/ресурс: (\w+)/)?.[1] || 'неизвестный';
    
    // Логируем событие
    logSecurityEvent({
      type: 'QUOTA_EXCEEDED',
      resource,
      userId: req.user?.id || req.ip,
      endpoint: req.originalUrl,
      timestamp: new Date().toISOString()
    });

    // Возвращаем соответствующий ответ
    return res.status(429).json({
      error: 'Превышена квота на использование ресурса',
      resource,
      retryAfter: calculateRetryTime(resource)
    });
  }
  
  next(error);
}

// Мiddleware для обработки ошибок квот
app.use(handleQuotaExceeded);
```

### Пользовательский интерфейс для квот

```javascript
// Компонент отображения квот в пользовательском интерфейсе
class QuotaDisplay {
  constructor(quotaManager) {
    this.quotaManager = quotaManager;
  }

  async renderQuotaInfo() {
    const quotas = await this.getUserQuotas();
    
    const quotaElements = quotas.map(quota => {
      const percentage = Math.round((quota.used / quota.limit) * 100);
      
      return `
        <div class="quota-item">
          <div class="quota-header">
            <span class="quota-name">${this.getReadableResourceName(quota.resource)}</span>
            <span class="quota-usage">${quota.used} / ${quota.limit}</span>
          </div>
          <div class="quota-bar">
            <div class="quota-progress" style="width: ${percentage}%"></div>
          </div>
          <div class="quota-info">
            <span class="quota-percentage">${percentage}%</span>
            <span class="quota-reset">Сброс: ${this.formatResetTime(quota.resetTime)}</span>
          </div>
        </div>
      `;
    });

    return `
      <div class="quotas-container">
        <h3>Ваши квоты</h3>
        ${quotaElements.join('')}
      </div>
    `;
  }

  async getUserQuotas() {
    // Получаем информацию о квотах пользователя
    return [
      await this.quotaManager.checkUserQuota('api_calls'),
      await this.quotaManager.checkUserQuota('file_uploads'),
      await this.quotaManager.checkUserQuota('storage_space')
    ];
  }

  getReadableResourceName(resource) {
    const names = {
      'api_calls': 'API-вызовы',
      'file_uploads': 'Загрузки файлов',
      'storage_space': 'Место в хранилище'
    };
    return names[resource] || resource;
  }

  formatResetTime(resetTime) {
    return new Date(resetTime).toLocaleString();
  }
}
```

## Связь с другими аспектами безопасности

Управление квотами тесно связано с:
- [[Ограничение-ресурсов]] — контроль использования ресурсов
- [[Предотвращение-злоупотреблений]] — защита от неправомерного использования
- [[Обнаружение-и-предотвращение-брутфорса]] — ограничение попыток аутентификации
- [[Ограничение-скорости]] — контроль частоты запросов
- [[Меры-против-ботов]] — защита от автоматизированных злоупотреблений

## Заключение

Управление квотами — это важный инструмент для обеспечения стабильности, безопасности и справедливого распределения ресурсов в веб-приложениях. Эффективная система квотирования требует баланса между защитой системы и удобством использования для легитимных пользователей. При правильной реализации квоты помогают предотвратить перегрузку системы и злоупотребления, обеспечивая устойчивую работу приложения.

## Дополнительные ресурсы

- OWASP Rate Limiting Guidelines
- Resource Quotas in Web Applications
- Best Practices for API Rate Limiting