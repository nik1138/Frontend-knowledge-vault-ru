---
aliases: ["Кодирование вывода", "Output Encoding", "Экранирование данных", "HTML-экранирование"]
tags: ["#security", "#output-encoding", "#secure-coding", "#xss-prevention"]
---

# Кодирование вывода

## Введение

Кодирование вывода (output encoding) - это процесс преобразования специальных символов в их безопасные эквиваленты перед отображением в веб-странице. Это одна из ключевых мер защиты от XSS-атак, предотвращающая выполнение вредоносного скрипта в браузере пользователя.

## Почему необходимо кодирование вывода

Когда данные, полученные от пользователей, отображаются в веб-странице без должной обработки, они могут быть интерпретированы браузером как часть HTML или JavaScript, что создает уязвимость XSS.

**Пример уязвимости:**
```html
<!-- Небезопасный код -->
<p>Привет, <?php echo $_GET['name']; ?>!</p>

<!-- При URL: /page.php?name=<script>alert('XSS')</script> -->
<p>Привет, <script>alert('XSS')</script>!</p>
```

## Контексты кодирования

Кодирование должно быть адаптировано к контексту, в котором будут отображаться данные:

### 1. HTML-контекст (HTML Body)

Преобразование специальных HTML-символов в их HTML-сущности:

```javascript
// Пример функции экранирования для HTML-контекста
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;',
        '/': '&#x2F;'
    };
    
    return text.replace(/[&<>"'\/]/g, function(s) {
        return map[s];
    });
}

// Использование
const userInput = '<script>alert("XSS")</script>';
const safeOutput = escapeHtml(userInput);
// Результат: &lt;script&gt;alert("XSS")&lt;/script&gt;

// Более надежная реализация
function secureEscapeHtml(text) {
    if (typeof text !== 'string') {
        return text;
    }
    
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
```

### 2. Атрибуты HTML

Дополнительное экранирование для использования в HTML-атрибутах:

```javascript
function escapeHtmlAttribute(text) {
    if (typeof text !== 'string') {
        return text;
    }
    
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;',
        '`': '&#x60;',
        '=': '&#x3D;'
    };
    
    return text.replace(/[&<>"'`=\/]/g, function(s) {
        return map[s];
    });
}

// Использование в атрибутах
const userInput = '"><script>alert(1)</script>';
const safeOutput = escapeHtmlAttribute(userInput);
// Результат: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
```

### 3. JavaScript-контекст

Кодирование для использования внутри JavaScript-строк:

```javascript
function escapeJsString(text) {
    if (typeof text !== 'string') {
        return text;
    }
    
    return text
        .replace(/\\/g, '\\\\')      // Экранирование обратного слеша
        .replace(/'/g, "\\'")        // Экранирование одинарных кавычек
        .replace(/"/g, '\\"')        // Экранирование двойных кавычек
        .replace(/\n/g, '\\n')       // Экранирование новой строки
        .replace(/\r/g, '\\r')       // Экранирование возврата каретки
        .replace(/\t/g, '\\t')       // Экранирование табуляции
        .replace(/\0/g, '\\0')       // Экранирование null-байта
        .replace(/\</g, '\\u003c')   // Экранирование угловой скобки (предотвращает закрытие тегов)
        .replace(/\>/g, '\\u003e');  // Экранирование угловой скобки (предотвращает закрытие тегов)
}

// Использование в JavaScript
const userInput = '"; alert("XSS"); "';
const safeOutput = escapeJsString(userInput);
// Результат: \"; alert(\"XSS\"); \"
```

### 4. CSS-контекст

Кодирование для использования в CSS:

```javascript
function escapeCss(text) {
    if (typeof text !== 'string') {
        return text;
    }
    
    // Удаление или кодирование потенциально опасных CSS-конструкций
    return text
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')  // Удаление управляющих символов
        .replace(/[\\"']/g, '\\$&')  // Экранирование кавычек и обратного слеша
        .replace(/</g, '\\3C ')      // Экранирование угловых скобок
        .replace(/>/g, '\\3E ')      // Экранирование угловых скобок
        .replace(/javascript:/gi, 'java script:')  // Предотвращение JS в CSS
        .replace(/expression\s*\(/gi, 'expression ('); // Предотвращение CSS expression
}

// Использование в CSS
const userInput = 'red; color: expression(alert("XSS"))';
const safeOutput = escapeCss(userInput);
// Безопасный CSS без вредоносного кода
```

### 5. URL-контекст

Кодирование для использования в URL:

```javascript
function escapeUrl(text) {
    return encodeURIComponent(text);
}

// Или для полного URL
function escapeFullUrl(url) {
    return encodeURI(url);
}

// Использование в URL
const userInput = 'javascript:alert("XSS")';
const safeOutput = escapeUrl(userInput);
// Результат: javascript%3Aalert%28%22XSS%22%29
```

## Реализация в различных языках

### JavaScript/Node.js

```javascript
// Встроенные методы
const htmlEscaped = escapeHtml(userInput);
const urlEncoded = encodeURIComponent(userInput);

// Использование библиотек
const he = require('he');
const escaped = he.escape(userInput);

// Более продвинутая библиотека для экранирования
const validator = require('validator');
const escapedText = validator.escape(userInput);

// DOMPurify для очистки HTML
const DOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');

const window = new JSDOM('').window;
const purify = DOMPurify(window);

const clean = purify.sanitize(dirtyInput, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    FORBID_TAGS: ['script', 'iframe', 'object', 'embed']
});
```

### PHP

```php
// Экранирование для HTML
echo htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');

// Экранирование для JavaScript
echo json_encode($userInput, JSON_HEX_TAG | JSON_HEX_AMP);

// Экранирование для URL
echo urlencode($userInput);

// Экранирование для HTML-атрибутов
echo htmlspecialchars($userInput, ENT_QUOTES | ENT_HTML5, 'UTF-8');
```

### Java

```java
// Использование Apache Commons Text
String escapedHtml = StringEscapeUtils.escapeHtml4(userInput);
String escapedJs = StringEscapeUtils.escapeEcmaScript(userInput);
String escapedXml = StringEscapeUtils.escapeXml11(userInput);

// Использование OWASP Java Encoder
import org.owasp.encoder.Encode;

String safeHtml = Encode.forHtml(userInput);
String safeJs = Encode.forJavaScript(userInput);
String safeCss = Encode.forCssString(userInput);
String safeUri = Encode.forUriComponent(userInput);
```

### Python

```python
import html
import urllib.parse

# Экранирование HTML
escaped_html = html.escape(userInput)

# Экранирование URL
escaped_url = urllib.parse.quote(userInput)

# Использование Jinja2 (автоматическое экранирование)
# В шаблонах Jinja2 переменные автоматически экранируются
# {{ variable }} - экранировано
# {{ variable|safe }} - не экранировано
```

## Современные подходы

### Шаблонизаторы с автоматическим экранированием

```javascript
// Пример с Handlebars
// Автоматически экранирует {{variable}}
// Для отключения экранирования используйте {{{unescaped}}}

// Пример с React
function Greeting({ name }) {
    // React автоматически экранирует переменные
    return <div>Привет, {name}!</div>;
}

// Для вставки HTML используйте dangerouslySetInnerHTML
function DangerousGreeting({ htmlContent }) {
    return <div dangerouslySetInnerHTML={{__html: htmlContent}} />;
}

// Пример с Vue.js
<template>
    <!-- Автоматическое экранирование -->
    <div>{{ userInput }}</div>
    
    <!-- Без экранирования (использовать осторожно) -->
    <div v-html="htmlContent"></div>
</template>
```

### Content Security Policy (CSP)

```html
<!-- CSP может ограничить выполнение встроенных скриптов -->
<meta http-equiv="Content-Security-Policy" 
      content="script-src 'self' 'unsafe-inline'; object-src 'none';">
```

## Практические примеры

### Пример 1: Безопасный рендеринг комментариев

```javascript
// Небезопасный код
function renderComment(comment) {
    return `<div class="comment">${comment.text}</div>`;
}

// Безопасный код
function renderComment(comment) {
    const escapedText = escapeHtml(comment.text);
    return `<div class="comment">${escapedText}</div>`;
}

// Более безопасный подход с DOM API
function renderCommentSafe(comment) {
    const div = document.createElement('div');
    div.className = 'comment';
    div.textContent = comment.text; // Автоматическое экранирование
    return div.outerHTML;
}
```

### Пример 2: Безопасное формирование URL

```javascript
// Небезопасный код
function buildSearchUrl(query) {
    return `/search?q=${query}`;
}

// Безопасный код
function buildSearchUrl(query) {
    const encodedQuery = encodeURIComponent(query);
    return `/search?q=${encodedQuery}`;
}

// Более безопасный подход
function buildSearchUrlSafe(query) {
    const url = new URL('/search', window.location.origin);
    url.searchParams.set('q', query);
    return url.toString();
}
```

### Пример 3: Безопасная вставка в JavaScript

```javascript
// Небезопасный код
function insertUserData(userData) {
    const script = `
        var user = {
            name: "${userData.name}",
            email: "${userData.email}"
        };
    `;
    document.getElementById('data').innerHTML = `<script>${script}</script>`;
}

// Безопасный код
function insertUserData(userData) {
    const escapedName = escapeJsString(userData.name);
    const escapedEmail = escapeJsString(userData.email);
    
    const script = `
        var user = {
            name: "${escapedName}",
            email: "${escapedEmail}"
        };
    `;
    document.getElementById('data').innerHTML = `<script>${script}</script>`;
}

// Еще более безопасный подход - использование JSON
function insertUserDataSafe(userData) {
    const script = document.createElement('script');
    script.textContent = `window.userData = ${JSON.stringify(userData)};`;
    document.head.appendChild(script);
}
```

### Пример 4: Безопасная вставка в атрибуты

```javascript
// Небезопасный код
function setImage(src) {
    return `<img src="${src}" alt="image">`;
}

// Безопасный код
function setImage(src) {
    const escapedSrc = escapeHtmlAttribute(src);
    return `<img src="${escapedSrc}" alt="image">`;
}

// Использование DOM API
function setImageSafe(src) {
    const img = document.createElement('img');
    img.src = src; // Автоматическая проверка и безопасное присвоение
    img.alt = 'image';
    return img.outerHTML;
}
```

## Инструменты автоматического кодирования

### Библиотеки для экранирования

```javascript
// DOMPurify - для очистки HTML
const clean = DOMPurify.sanitize(dirty);

// Lodash
import { escape } from 'lodash';
const escaped = escape(userInput);

// validator.js
const validator = require('validator');
const escaped = validator.escape(userInput);

// he.js - для HTML-экранирования
const he = require('he');
const decoded = he.decode('&lt;script&gt;');
const encoded = he.encode('<script>');
```

## Лучшие практики

### 1. Контекстно-зависимое кодирование

Всегда учитывайте контекст, в котором будут отображаться данные, и используйте соответствующий метод кодирования.

```javascript
class ContextualEncoder {
    static encodeForContext(text, context) {
        switch (context) {
            case 'html':
                return this.encodeForHtml(text);
            case 'html-attribute':
                return this.encodeForHtmlAttribute(text);
            case 'javascript':
                return this.encodeForJavaScript(text);
            case 'css':
                return this.encodeForCss(text);
            case 'url':
                return this.encodeForUrl(text);
            case 'xml':
                return this.encodeForXml(text);
            default:
                return this.encodeForHtml(text);
        }
    }
    
    static encodeForHtml(text) {
        if (typeof text !== 'string') return text;
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
    
    static encodeForHtmlAttribute(text) {
        return this.encodeForHtml(text);
    }
    
    static encodeForJavaScript(text) {
        if (typeof text !== 'string') return text;
        return text
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
    }
    
    static encodeForCss(text) {
        if (typeof text !== 'string') return text;
        return text.replace(/[^a-zA-Z0-9]/g, match => {
            return '\\' + match.charCodeAt(0).toString(16) + ' ';
        });
    }
    
    static encodeForUrl(text) {
        return encodeURIComponent(text);
    }
    
    static encodeForXml(text) {
        return this.encodeForHtml(text);
    }
}
```

### 2. Использование проверенных библиотек

Предпочтительно использовать проверенные библиотеки экранирования, а не писать свои реализации.

```javascript
// Хорошо - использование проверенной библиотеки
const sanitized = DOMPurify.sanitize(userInput, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    FORBID_TAGS: ['script', 'iframe']
});

// Плохо - самодельное экранирование
function badEscape(text) {
    return text.replace('<', '&lt;').replace('>', '&gt;'); // Неполное!
}
```

### 3. Комбинирование методов

```javascript
// Комбинированная защита
function processUserInput(input) {
    // 1. Валидация
    if (!isValidInput(input)) {
        throw new Error('Invalid input');
    }
    
    // 2. Санитизация
    const sanitized = sanitizeInput(input);
    
    // 3. Кодирование вывода
    const encoded = escapeHtml(sanitized);
    
    return encoded;
}

// Комплексная проверка
class SecureOutputProcessor {
    constructor() {
        this.validator = new InputValidator();
        this.sanitizer = new InputSanitizer();
        this.encoder = new ContextualEncoder();
    }
    
    process(input, context) {
        // Валидация
        if (!this.validator.validate(input)) {
            throw new Error('Invalid input');
        }
        
        // Санитизация
        const sanitized = this.sanitizer.sanitize(input);
        
        // Кодирование для конкретного контекста
        return this.encoder.encodeForContext(sanitized, context);
    }
}
```

### 4. Обновление и тестирование

Регулярно обновляйте библиотеки экранирования и тестируйте их работу.

```javascript
// Тестирование кодирования вывода
function testEscapeHtml() {
    const testCases = [
        { input: '<script>', expected: '&lt;script&gt;' },
        { input: '" onclick="alert(1)"', expected: '&quot; onclick=&quot;alert(1)&quot;' },
        { input: '&', expected: '&amp;' },
        { input: '<img src=x onerror=alert(1)>', expected: '&lt;img src=x onerror=alert(1)&gt;' }
    ];
    
    testCases.forEach(({ input, expected }, index) => {
        const result = escapeHtml(input);
        console.assert(result === expected, 
            `Test ${index + 1} failed: expected "${expected}", got "${result}"`);
    });
    
    console.log('HTML escaping tests completed');
}
```

## Распространенные ошибки

### 1. Однократное кодирование

```javascript
// Плохо - двойное экранирование может быть проблемой
function doubleEncoded(input) {
    return escapeHtml(escapeHtml(input)); // Может привести к двойному экранированию
}

// Хорошо - однократное кодирование
function singleEncoded(input) {
    return escapeHtml(input);
}
```

### 2. Неправильный контекст

```javascript
// Плохо - использование HTML-экранирования в JavaScript-контексте
const jsCode = `var name = '${escapeHtml(userInput)}';`; // Опасно!

// Хорошо - использование правильного экранирования
const jsCode = `var name = '${escapeJsString(userInput)}';`;
```

### 3. Пропуск кодирования

```javascript
// Плохо - отсутствие кодирования
document.getElementById('output').innerHTML = userInput;

// Хорошо - с использованием экранирования
document.getElementById('output').innerHTML = escapeHtml(userInput);

// Лучше - с использованием DOM API
document.getElementById('output').textContent = userInput;
```

### 4. Неправильное использование DOM API

```javascript
// Плохо - innerHTML может быть опасным
div.innerHTML = userInput;

// Хорошо - textContent безопасно
div.textContent = userInput;

// При необходимости вставки HTML используйте безопасные методы
const tempDiv = document.createElement('div');
tempDiv.innerHTML = userInput;
// Дополнительная проверка и очистка содержимого
safeDiv.appendChild(tempDiv);
```

## Кодирование в разных фреймворках

### Express.js с шаблонами

```javascript
// Использование EJS с автоматическим экранированием
// views/user-profile.ejs
/*
<h1>Профиль пользователя: <%- name %></h1>  <!-- Неэкранированный вывод -->
<p>Имя: <%= name %></p>                     <!-- Экранированный вывод -->
*/

// Использование Pug с автоматическим экранированием
// views/user-profile.pug
/*
h1 Профиль пользователя: !{name}  // Неэкранированный вывод
p Имя: #{name}                    // Экранированный вывод
*/
```

### Angular

```typescript
// Angular автоматически экранирует выражения
@Component({
  template: `
    <p>Имя: {{userName}}</p>  <!-- Автоматически экранировано -->
    <div [innerHTML]="htmlContent"></div>  <!-- Опасно, использовать с осторожностью -->
  `
})
export class UserProfileComponent {
  userName = '<script>alert("XSS")</script>';  // Будет безопасно экранировано
  htmlContent = '<p>Безопасный HTML</p>';     // Нуждается в дополнительной проверке
}
```

### React

```jsx
function UserProfile({ user }) {
  return (
    <div>
      {/* Автоматически экранировано */}
      <h1>Привет, {user.name}</h1>
      
      {/* Опасно - использовать только с доверенным содержимым */}
      <div dangerouslySetInnerHTML={{__html: user.bio}} />
      
      {/* Безопасная альтернатива для HTML */}
      <BioContent html={user.bio} />
    </div>
  );
}

// Компонент для безопасного рендеринга HTML
function BioContent({ html }) {
  const sanitizedHtml = DOMPurify.sanitize(html);
  return <div dangerouslySetInnerHTML={{__html: sanitizedHtml}} />;
}
```

## Тестирование кодирования вывода

### Автоматизированное тестирование

```javascript
// Пример теста для функции экранирования
function testEscapeHtml() {
    const testCases = [
        { input: '<script>alert("XSS")</script>', expected: '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;' },
        { input: 'Hello & "World"', expected: 'Hello &amp; &quot;World&quot;' },
        { input: '<img src="x" onerror="alert(1)">', expected: '&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;' }
    ];
    
    testCases.forEach(({ input, expected }, index) => {
        const result = escapeHtml(input);
        if (result !== expected) {
            console.error(`Test ${index + 1} failed:`);
            console.error(`  Input:    "${input}"`);
            console.error(`  Expected: "${expected}"`);
            console.error(`  Got:      "${result}"`);
        } else {
            console.log(`Test ${index + 1} passed`);
        }
    });
}

// Тестирование различных контекстов
function testContextualEncoding() {
    const userInput = '<script>alert("XSS")</script>';
    
    console.log('HTML context:', escapeHtml(userInput));
    console.log('JS context:', escapeJsString(userInput));
    console.log('URL context:', encodeURIComponent(userInput));
    console.log('Attribute context:', escapeHtmlAttribute(userInput));
}

// Запуск тестов
testEscapeHtml();
testContextualEncoding();
```

### Интеграционные тесты

```javascript
// Тестирование с использованием Puppeteer
const puppeteer = require('puppeteer');

async function testXSSProtection() {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    // Установка страницы с пользовательским вводом
    await page.setContent(`
        <div id="output"></div>
        <script>
            const userInput = '<script>alert("XSS")</script>';
            document.getElementById('output').innerHTML = userInput;
        </script>
    `);
    
    // Проверка, что скрипт не выполнился
    const output = await page.$eval('#output', el => el.innerHTML);
    console.log('Output:', output);
    
    // Проверка, что алерт не был вызван
    let alertCalled = false;
    page.on('dialog', () => {
        alertCalled = true;
    });
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    if (alertCalled) {
        console.error('XSS vulnerability detected!');
    } else {
        console.log('XSS protection working correctly');
    }
    
    await browser.close();
}
```

## Мониторинг и аудит

### Логирование небезопасного вывода

```javascript
// Система логирования небезопасного вывода
class OutputSecurityLogger {
    static logUnsafeOutput(output, context, userInput) {
        console.warn('POTENTIALLY UNSAFE OUTPUT:', {
            timestamp: new Date().toISOString(),
            context,
            userInput: this.sanitizeForLog(userInput),
            output: this.sanitizeForLog(output),
            stack: new Error().stack
        });
    }
    
    static sanitizeForLog(data) {
        if (typeof data === 'string') {
            // Обрезка длинных строк
            return data.length > 100 ? data.substring(0, 100) + '...' : data;
        }
        return data;
    }
}

// Обертка для безопасного вывода с логированием
function safeOutputWithLogging(content, context) {
    const safeContent = ContextualEncoder.encodeForContext(content, context);
    
    // Проверка на подозрительное содержимое
    if (this.containsSuspiciousPatterns(content)) {
        OutputSecurityLogger.logUnsafeOutput(safeContent, context, content);
    }
    
    return safeContent;
}
```

## Связанные темы

- [[Проверка-ввода]]
- [[Методы-санитизации]]
- [[Руководство-по-безопасному-коду]]
- [[Тестирование-безопасности]]
- [[Мониторинг-безопасности]]