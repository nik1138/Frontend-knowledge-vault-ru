---
aliases: ["Secure Coding Guidelines", "Руководство по безопасному коду", "Безопасное программирование"]
tags: [security, coding, best-practices, secure-development]
---

# Руководство по безопасному коду

## Обзор

Безопасное программирование - это практика разработки программного обеспечения с учетом потенциальных угроз безопасности. Это включает в себя написание кода, который устойчив к различным видам атак, таких как внедрение кода, переполнение буфера, атаки типа "человек посередине" и другие. Это руководство предоставляет комплексный подход к написанию безопасного кода.

## Принципы безопасного программирования

### Принцип наименьших привилегий

Программные компоненты должны иметь только минимально необходимые права для выполнения своих функций:

```javascript
// НЕБЕЗОПАСНО
const adminUser = getUserById(userId); // Получаем все данные пользователя
const userData = adminUser; // Используем все данные, включая привилегии

// БЕЗОПАСНО
const userData = getUserProfile(userId); // Получаем только необходимые данные
const limitedUserData = {
  name: userData.name,
  email: userData.email,
  avatar: userData.avatar
  // Не включаем привилегии администратора
};
```

### Принцип "всё, что не разрешено - запрещено"

Явно определяйте, что разрешено, а не то, что запрещено:

```javascript
// НЕБЕЗОПАСНО - черный список
function validateInput(input) {
  const dangerousChars = ['<', '>', '"', "'", '&'];
  return !dangerousChars.some(char => input.includes(char));
}

// БЕЗОПАСНО - белый список
function validateInput(input) {
  // Разрешаем только буквы, цифры и пробелы
  const allowedPattern = /^[a-zA-Z0-9\s]+$/;
  return allowedPattern.test(input);
}
```

### Защита на границах

Всегда проверяйте и санитизируйте данные на границах приложения:

```javascript
// Пример middleware для Express.js
function inputValidationMiddleware(req, res, next) {
  // Проверка длины строк
  for (const [key, value] of Object.entries(req.body)) {
    if (typeof value === 'string' && value.length > 1000) {
      return res.status(400).json({ error: `Поле ${key} слишком длинное` });
    }
  }
  
  // Санитизация ввода
  req.body = sanitizeInput(req.body);
  next();
}

function sanitizeInput(data) {
  if (typeof data === 'string') {
    // Удаление потенциально опасных символов
    return data.replace(/[<>'"&]/g, '');
  } else if (typeof data === 'object') {
    const sanitized = {};
    for (const [key, value] of Object.entries(data)) {
      sanitized[key] = sanitizeInput(value);
    }
    return sanitized;
  }
  return data;
}
```

## Обработка пользовательского ввода

### Проверка типов и формата

```javascript
function validateUserData(userData) {
  const errors = [];
  
  // Проверка email
  if (!userData.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(userData.email)) {
    errors.push('Некорректный email');
  }
  
  // Проверка возраста
  if (!userData.age || typeof userData.age !== 'number' || userData.age < 0 || userData.age > 150) {
    errors.push('Некорректный возраст');
  }
  
  // Проверка имени
  if (!userData.name || typeof userData.name !== 'string' || userData.name.length > 50) {
    errors.push('Некорректное имя');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

### Защита от внедрения кода

```javascript
// НЕБЕЗОПАСНО
function executeUserCommand(command) {
  return eval(command); // Потенциальная уязвимость
}

// БЕЗОПАСНО
function executeUserCommand(command) {
  // Используем белый список разрешенных команд
  const allowedCommands = ['status', 'version', 'help'];
  
  if (!allowedCommands.includes(command)) {
    throw new Error('Команда не разрешена');
  }
  
  // Выполняем только предопределенные команды
  switch(command) {
    case 'status':
      return getStatus();
    case 'version':
      return getVersion();
    case 'help':
      return getHelp();
    default:
      throw new Error('Неизвестная команда');
  }
}
```

## Работа с базами данных

### Защита от SQL-инъекций

```javascript
// НЕБЕЗОПАСНО
function getUserById(id) {
  const query = `SELECT * FROM users WHERE id = ${id}`;
  return db.query(query);
}

// БЕЗОПАСНО - с использованием параметризованных запросов
function getUserById(id) {
  const query = 'SELECT * FROM users WHERE id = ?';
  return db.query(query, [id]);
}

// БЕЗОПАСНО - с использованием ORM
async function getUserById(id) {
  return await User.findByPk(id, {
    attributes: ['id', 'name', 'email'] // Явно указываем нужные поля
  });
}
```

### Валидация запросов к БД

```javascript
function buildQuery(filters) {
  const allowedFilters = ['name', 'email', 'created_at'];
  const queryParts = [];
  const params = [];
  
  for (const [key, value] of Object.entries(filters)) {
    if (!allowedFilters.includes(key)) {
      throw new Error(`Фильтр ${key} не разрешен`);
    }
    
    // Проверка типа и формата значения
    if (typeof value !== 'string' && typeof value !== 'number') {
      throw new Error(`Некорректное значение для фильтра ${key}`);
    }
    
    queryParts.push(`${key} = ?`);
    params.push(value);
  }
  
  const query = `SELECT * FROM users WHERE ${queryParts.join(' AND ')}`;
  return { query, params };
}
```

## Работа с файлами и системой

### Безопасная загрузка файлов

```javascript
const path = require('path');
const fs = require('fs');
const mime = require('mime-types');

function validateAndSaveFile(file, uploadDir) {
  // Проверка типа файла
  const allowedMimeTypes = [
    'image/jpeg',
    'image/png',
    'application/pdf',
    'text/plain'
  ];
  
  if (!allowedMimeTypes.includes(file.mimetype)) {
    throw new Error('Тип файла не разрешен');
  }
  
  // Проверка размера файла
  if (file.size > 5 * 1024 * 1024) { // 5MB
    throw new Error('Файл слишком большой');
  }
  
  // Безопасное имя файла
  const extension = mime.extension(file.mimetype);
  const safeFileName = generateSafeFileName(file.originalname, extension);
  const filePath = path.join(uploadDir, safeFileName);
  
  // Проверка пути для предотвращения path traversal
  if (!filePath.startsWith(path.resolve(uploadDir))) {
    throw new Error('Некорректный путь к файлу');
  }
  
  // Сохранение файла
  fs.writeFileSync(filePath, file.buffer);
  return filePath;
}

function generateSafeFileName(originalName, extension) {
  // Удаляем потенциально опасные символы
  const cleanName = originalName.replace(/[^a-zA-Z0-9._-]/g, '_');
  const timestamp = Date.now();
  const randomString = Math.random().toString(36).substring(2, 8);
  
  return `${timestamp}_${randomString}.${extension}`;
}
```

### Безопасная работа с файловой системой

```javascript
const fs = require('fs');
const path = require('path');

function safeReadFile(filePath, allowedBaseDir) {
  // Резолвим абсолютный путь
  const absolutePath = path.resolve(filePath);
  const absoluteBaseDir = path.resolve(allowedBaseDir);
  
  // Проверяем, что файл находится в разрешенной директории
  if (!absolutePath.startsWith(absoluteBaseDir)) {
    throw new Error('Попытка доступа вне разрешенной директории');
  }
  
  // Проверяем существование файла
  if (!fs.existsSync(absolutePath)) {
    throw new Error('Файл не найден');
  }
  
  // Проверяем, что это файл, а не директория
  const stats = fs.statSync(absolutePath);
  if (!stats.isFile()) {
    throw new Error('Путь указывает не на файл');
  }
  
  return fs.readFileSync(absolutePath, 'utf8');
}
```

## Защита сеанса и аутентификации

### Безопасная генерация токенов

```javascript
const crypto = require('crypto');
const jwt = require('jsonwebtoken');

function generateSecureToken() {
  // Используем криптографически безопасный генератор
  return crypto.randomBytes(32).toString('hex');
}

function generateJWT(payload, secret) {
  return jwt.sign(
    { 
      ...payload,
      iat: Math.floor(Date.now() / 1000), // время создания
      exp: Math.floor(Date.now() / 1000) + (60 * 60) // срок действия 1 час
    },
    secret,
    { 
      algorithm: 'HS256',
      // Добавляем дополнительные требования безопасности
      header: { typ: 'JWT' }
    }
  );
}
```

### Управление сессиями

```javascript
class SessionManager {
  constructor() {
    this.sessions = new Map();
  }
  
  createSession(userId) {
    const sessionId = generateSecureToken();
    const session = {
      userId,
      createdAt: new Date(),
      lastAccessed: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 часа
    };
    
    this.sessions.set(sessionId, session);
    return sessionId;
  }
  
  validateSession(sessionId) {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return false;
    }
    
    // Проверяем срок действия
    if (new Date() > session.expiresAt) {
      this.sessions.delete(sessionId);
      return false;
    }
    
    // Обновляем время последнего доступа
    session.lastAccessed = new Date();
    return true;
  }
  
  destroySession(sessionId) {
    this.sessions.delete(sessionId);
  }
}
```

## Обработка ошибок

### Безопасная обработка ошибок

```javascript
function safeErrorHandler(error, req, res) {
  // Логируем полную информацию об ошибке
  console.error('Ошибка:', {
    message: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id,
    timestamp: new Date().toISOString()
  });
  
  // Возвращаем общее сообщение пользователю
  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({
      error: 'Произошла внутренняя ошибка сервера',
      timestamp: new Date().toISOString()
    });
  } else {
    // В режиме разработки можно возвращать больше информации
    res.status(500).json({
      error: error.message,
      stack: error.stack
    });
  }
}

// Пример использования в middleware
app.use((error, req, res, next) => {
  safeErrorHandler(error, req, res);
});
```

## Криптография

### Использование безопасных алгоритмов

```javascript
const crypto = require('crypto');

// Хеширование паролей
function hashPassword(password, salt) {
  return crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
}

function generateSalt() {
  return crypto.randomBytes(32).toString('hex');
}

// Шифрование чувствительных данных
function encryptData(data, key) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher('aes-256-cbc', key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  return {
    iv: iv.toString('hex'),
    encryptedData: encrypted
  };
}

function decryptData(encryptedData, iv, key) {
  const decipher = crypto.createDecipher('aes-256-cbc', key);
  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}
```

## Безопасность веб-интерфейсов

### Защита от XSS

```javascript
// Экранирование вывода
function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  
  return text.replace(/[&<>"']/g, m => map[m]);
}

// Content Security Policy
app.use((req, res, next) => {
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline' https://trusted-cdn.com; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "font-src 'self'; " +
    "connect-src 'self'"
  );
  next();
});
```

### Защита от CSRF

```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

// Применение CSRF защиты
app.use(csrfProtection);

app.get('/form', (req, res) => {
  // Передаем токен CSRF в шаблон
  res.render('form', { csrfToken: req.csrfToken() });
});

// Проверка токена в POST запросах
app.post('/process', (req, res) => {
  // CSRF токен автоматически проверяется middleware
  // Если токен недействителен, будет ошибка 403
  processFormData(req.body);
  res.send('Форма обработана');
});
```

## Тестирование безопасности

### Модульное тестирование безопасности

```javascript
// Пример теста для проверки валидации ввода
const { validateUserData } = require('./validation');

describe('Валидация пользовательских данных', () => {
  test('должна отклонять некорректный email', () => {
    const userData = { email: 'invalid-email' };
    const result = validateUserData(userData);
    expect(result.isValid).toBe(false);
    expect(result.errors).toContain('Некорректный email');
  });
  
  test('должна принимать корректный email', () => {
    const userData = { email: 'user@example.com' };
    const result = validateUserData(userData);
    expect(result.isValid).toBe(true);
  });
  
  test('должна отклонять слишком длинные строки', () => {
    const longName = 'a'.repeat(51); // 51 символ, больше лимита
    const userData = { name: longName };
    const result = validateUserData(userData);
    expect(result.isValid).toBe(false);
    expect(result.errors).toContain('Некорректное имя');
  });
});
```

## Лучшие практики

### 1. Обновление зависимостей

Регулярно обновляйте зависимости и проверяйте на уязвимости:

```bash
# Проверка уязвимостей
npm audit

# Автоматическое исправление
npm audit fix
```

### 2. Использование безопасных конфигураций

```javascript
// Конфигурация безопасности
const securityConfig = {
  // Время жизни сессии
  sessionTimeout: 24 * 60 * 60 * 1000, // 24 часа
  
  // Максимальный размер загружаемого файла
  maxFileSize: 5 * 1024 * 1024, // 5MB
  
  // Разрешенные MIME-типы
  allowedMimeTypes: [
    'image/jpeg',
    'image/png',
    'application/pdf',
    'text/plain'
  ],
  
  // Параметры хеширования
  hashIterations: 10000,
  saltLength: 32,
  
  // Настройки CORS
  cors: {
    allowedOrigins: ['https://trusted-domain.com'],
    allowCredentials: true
  }
};
```

### 3. Логирование и мониторинг

```javascript
// Безопасное логирование
function secureLog(level, message, metadata = {}) {
  // Не логируем чувствительные данные
  const safeMetadata = { ...metadata };
  delete safeMetadata.password;
  delete safeMetadata.token;
  delete safeMetadata.creditCard;
  
  console.log(`[${level}] ${message}`, safeMetadata);
}
```

## Заключение

Безопасное программирование требует постоянного внимания к деталям и понимания потенциальных угроз. Следование этим принципам и регулярное обновление знаний о новых уязвимостях поможет создавать более защищенные приложения.

## Связанные темы

- [[Проверка-ввода]]
- [[Кодирование-вывода]]
- [[Лучшие-практики-безопасности-API]]
- [[Сканирование-зависимостей]]
- [[Инструменты-аудита-безопасности]]
- [[Тестирование-безопасности]]