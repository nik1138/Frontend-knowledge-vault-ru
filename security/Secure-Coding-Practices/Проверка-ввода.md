---
aliases: ["Input Validation", "Проверка ввода", "Валидация данных"]
tags: [security, input-validation, data-validation, web-security]
---

# Проверка ввода

## Обзор

Проверка ввода (input validation) - это критически важный процесс проверки и санитизации данных, полученных от пользователей или внешних источников, перед их обработкой приложением. Неправильная проверка ввода является одной из основных причин уязвимостей безопасности, таких как SQL-инъекции, межсайтовый скриптинг (XSS), внедрение команд и другие.

## Зачем нужна проверка ввода

### Основные угрозы

- **SQL-инъекции**: Внедрение вредоносного SQL-кода в запросы к базе данных
- **XSS (Cross-Site Scripting)**: Внедрение вредоносного JavaScript-кода
- **Command injection**: Выполнение нежелательных команд на сервере
- **Path traversal**: Доступ к файлам вне разрешенной директории
- **Buffer overflow**: Переполнение буфера ввода

### Принципы проверки ввода

- **Проверка на границах**: Проверяйте все входящие данные на границах приложения
- **Белый список**: Разрешайте только известные безопасные значения
- **Проверка типов**: Убедитесь, что данные соответствуют ожидаемому типу
- **Проверка формата**: Проверяйте формат данных с помощью регулярных выражений
- **Проверка диапазона**: Ограничивайте размер и диапазон значений

## Типы проверки ввода

### Клиентская проверка

Клиентская проверка улучшает UX, но не обеспечивает безопасности:

```html
<!-- HTML5 валидация -->
<form>
  <input type="email" name="email" required pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$">
  <input type="number" name="age" min="1" max="120" required>
  <input type="text" name="username" maxlength="20" required>
  <button type="submit">Отправить</button>
</form>
```

```javascript
// JavaScript валидация на клиенте
function validateForm(formData) {
  const errors = [];
  
  // Проверка email
  if (!formData.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
    errors.push('Некорректный email');
  }
  
  // Проверка возраста
  if (!formData.age || formData.age < 1 || formData.age > 120) {
    errors.push('Возраст должен быть от 1 до 120');
  }
  
  // Проверка имени пользователя
  if (!formData.username || formData.username.length < 3 || formData.username.length > 20) {
    errors.push('Имя пользователя должно быть от 3 до 20 символов');
  }
  
  // Проверка на недопустимые символы
  if (/[^a-zA-Z0-9_]/.test(formData.username)) {
    errors.push('Имя пользователя может содержать только буквы, цифры и подчеркивание');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

### Серверная проверка

Серверная проверка обязательна для обеспечения безопасности:

```javascript
// Middleware для проверки ввода в Express.js
function inputValidationMiddleware(req, res, next) {
  // Проверка размера тела запроса
  if (req.body && JSON.stringify(req.body).length > 10000) { // 10KB
    return res.status(400).json({ error: 'Слишком большой размер запроса' });
  }
  
  // Проверка и очистка данных
  req.body = validateAndSanitizeInput(req.body);
  
  if (req.body.errors && req.body.errors.length > 0) {
    return res.status(400).json({ 
      error: 'Некорректные данные', 
      details: req.body.errors 
    });
  }
  
  // Удаляем ошибки из объекта данных
  delete req.body.errors;
  
  next();
}

function validateAndSanitizeInput(data) {
  // Добавляем массив для ошибок
  const errors = [];
  
  // Рекурсивная проверка и санитизация
  function processValue(value, path = '') {
    if (typeof value === 'string') {
      // Проверка длины строки
      if (value.length > 1000) {
        errors.push(`Поле ${path} слишком длинное`);
        return value.substring(0, 1000);
      }
      
      // Санитизация потенциально опасных символов
      return value.replace(/[<>'"&]/g, '');
    } else if (Array.isArray(value)) {
      return value.map((item, index) => processValue(item, `${path}[${index}]`));
    } else if (typeof value === 'object' && value !== null) {
      const result = {};
      for (const [key, val] of Object.entries(value)) {
        result[key] = processValue(val, path ? `${path}.${key}` : key);
      }
      return result;
    }
    return value;
  }
  
  const sanitizedData = processValue(data);
  sanitizedData.errors = errors;
  
  return sanitizedData;
}
```

## Практические примеры проверки

### Проверка пользовательских данных

```javascript
class UserDataValidator {
  static validateRegistration(userData) {
    const errors = [];
    
    // Проверка email
    if (!userData.email) {
      errors.push('Email обязателен');
    } else if (!this.isValidEmail(userData.email)) {
      errors.push('Некорректный формат email');
    }
    
    // Проверка пароля
    if (!userData.password) {
      errors.push('Пароль обязателен');
    } else if (!this.isValidPassword(userData.password)) {
      errors.push('Пароль должен содержать не менее 8 символов, включая заглавную букву, строчную букву и цифру');
    }
    
    // Проверка имени пользователя
    if (!userData.username) {
      errors.push('Имя пользователя обязательно');
    } else if (!this.isValidUsername(userData.username)) {
      errors.push('Имя пользователя должно содержать от 3 до 20 символов и состоять только из букв, цифр и подчеркивания');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  static isValidEmail(email) {
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return emailRegex.test(email);
  }
  
  static isValidPassword(password) {
    // Минимум 8 символов, содержит заглавную, строчную буквы и цифру
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  }
  
  static isValidUsername(username) {
    // 3-20 символов, только буквы, цифры и подчеркивание
    const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
    return usernameRegex.test(username);
  }
}

// Использование
const userData = {
  email: 'user@example.com',
  password: 'SecurePass123',
  username: 'user_123'
};

const validation = UserDataValidator.validateRegistration(userData);
if (!validation.isValid) {
  console.log('Ошибки валидации:', validation.errors);
} else {
  console.log('Данные валидны');
}
```

### Проверка файлов

```javascript
const path = require('path');
const fs = require('fs');

class FileValidator {
  static validateUpload(file, options = {}) {
    const errors = [];
    
    // Проверка размера файла
    const maxSize = options.maxSize || 5 * 1024 * 1024; // 5MB по умолчанию
    if (file.size > maxSize) {
      errors.push(`Файл слишком большой. Максимальный размер: ${maxSize / (1024 * 1024)}MB`);
    }
    
    // Проверка типа файла
    const allowedTypes = options.allowedTypes || [
      'image/jpeg',
      'image/png',
      'application/pdf',
      'text/plain'
    ];
    
    if (!allowedTypes.includes(file.mimetype)) {
      errors.push(`Тип файла не разрешен. Разрешенные типы: ${allowedTypes.join(', ')}`);
    }
    
    // Проверка расширения файла
    const allowedExtensions = options.allowedExtensions || ['.jpg', '.jpeg', '.png', '.pdf', '.txt'];
    const ext = path.extname(file.originalname).toLowerCase();
    
    if (!allowedExtensions.includes(ext)) {
      errors.push(`Расширение файла не разрешено. Разрешенные: ${allowedExtensions.join(', ')}`);
    }
    
    // Проверка имени файла на потенциально опасные символы
    const fileName = path.basename(file.originalname, ext);
    if (!/^[a-zA-Z0-9_-]+$/.test(fileName)) {
      errors.push('Имя файла содержит недопустимые символы');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  static validateFilePath(filePath, allowedBaseDir) {
    const errors = [];
    
    // Резолвим абсолютные пути
    const absolutePath = path.resolve(filePath);
    const absoluteBaseDir = path.resolve(allowedBaseDir);
    
    // Проверяем, что путь находится в разрешенной директории (защита от path traversal)
    if (!absolutePath.startsWith(absoluteBaseDir)) {
      errors.push('Попытка доступа вне разрешенной директории');
    }
    
    // Проверяем, что файл существует
    if (!fs.existsSync(absolutePath)) {
      errors.push('Файл не найден');
    } else {
      // Проверяем, что это файл, а не директория
      const stats = fs.statSync(absolutePath);
      if (!stats.isFile()) {
        errors.push('Путь указывает не на файл');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

## Регулярные выражения для проверки

### Часто используемые паттерны

```javascript
const validationPatterns = {
  // Email
  email: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  
  // Телефон (международный формат)
  phone: /^\+?[1-9]\d{1,14}$/,
  
  // URL
  url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
  
  // IP-адрес (IPv4)
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  
  // IP-адрес (IPv6) - упрощенный
  ipv6: /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/,
  
  // Номер кредитной карты
  creditCard: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3[0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})$/,
  
  // Имя пользователя
  username: /^[a-zA-Z0-9_]{3,20}$/,
  
  // Пароль (минимум 8 символов, заглавная, строчная, цифра)
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/
};

// Функция для проверки с использованием паттернов
function validateByPattern(value, patternName) {
  const pattern = validationPatterns[patternName];
  if (!pattern) {
    throw new Error(`Паттерн ${patternName} не найден`);
  }
  
  return pattern.test(value);
}

// Пример использования
console.log(validateByPattern('user@example.com', 'email')); // true
console.log(validateByPattern('weakpass', 'password')); // false
```

## Проверка сложных структур данных

### Проверка JSON-объектов

```javascript
class SchemaValidator {
  constructor(schema) {
    this.schema = schema;
  }
  
  validate(data) {
    const errors = [];
    
    // Проверка обязательных полей
    for (const [field, rules] of Object.entries(this.schema)) {
      if (rules.required && (data[field] === undefined || data[field] === null)) {
        errors.push(`Поле ${field} обязательно`);
        continue;
      }
      
      if (data[field] !== undefined) {
        // Проверка типа
        if (rules.type && typeof data[field] !== rules.type) {
          errors.push(`Поле ${field} должно быть типа ${rules.type}`);
          continue;
        }
        
        // Проверка длины строки
        if (rules.type === 'string' && rules.minLength && data[field].length < rules.minLength) {
          errors.push(`Поле ${field} должно содержать не менее ${rules.minLength} символов`);
        }
        
        if (rules.type === 'string' && rules.maxLength && data[field].length > rules.maxLength) {
          errors.push(`Поле ${field} должно содержать не более ${rules.maxLength} символов`);
        }
        
        // Проверка числового диапазона
        if (rules.type === 'number' && rules.min !== undefined && data[field] < rules.min) {
          errors.push(`Поле ${field} должно быть не менее ${rules.min}`);
        }
        
        if (rules.type === 'number' && rules.max !== undefined && data[field] > rules.max) {
          errors.push(`Поле ${field} должно быть не более ${rules.max}`);
        }
        
        // Проверка с помощью регулярного выражения
        if (rules.pattern && !new RegExp(rules.pattern).test(data[field])) {
          errors.push(`Поле ${field} не соответствует требуемому формату`);
        }
        
        // Проверка на принадлежность списку
        if (rules.enum && !rules.enum.includes(data[field])) {
          errors.push(`Поле ${field} должно быть одним из: ${rules.enum.join(', ')}`);
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Пример использования
const userSchema = new SchemaValidator({
  email: {
    type: 'string',
    required: true,
    pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
  },
  age: {
    type: 'number',
    required: true,
    min: 18,
    max: 120
  },
  role: {
    type: 'string',
    required: true,
    enum: ['user', 'admin', 'moderator']
  },
  isActive: {
    type: 'boolean',
    required: false
  }
});

const userData = {
  email: 'user@example.com',
  age: 25,
  role: 'user'
};

const validation = userSchema.validate(userData);
console.log(validation);
```

## Защита от атак переполнения

### Проверка размера данных

```javascript
class InputSizeValidator {
  static validateSize(data, maxSize = 10000) { // 10KB по умолчанию
    const size = JSON.stringify(data).length;
    return size <= maxSize;
  }
  
  static validateStringLength(data, maxLength = 1000) {
    if (typeof data === 'string') {
      return data.length <= maxLength;
    } else if (typeof data === 'object') {
      for (const [key, value] of Object.entries(data)) {
        if (typeof value === 'string' && value.length > maxLength) {
          return false;
        } else if (typeof value === 'object') {
          if (!this.validateStringLength(value, maxLength)) {
            return false;
          }
        }
      }
      return true;
    }
    return true;
  }
  
  static validateArraySize(data, maxItems = 100) {
    if (Array.isArray(data)) {
      return data.length <= maxItems;
    }
    return true;
  }
}
```

## Лучшие практики

### 1. Используйте белые списки

```javascript
// НЕБЕЗОПАСНО - черный список
function sanitizeInput(input) {
  return input.replace(/<script>/gi, '').replace(/javascript:/gi, '');
}

// БЕЗОПАСНО - белый список
function validateInput(input) {
  // Разрешаем только определенные символы
  return /^[a-zA-Z0-9\s_@.-]+$/.test(input);
}
```

### 2. Проверяйте данные на границах

```javascript
// Middleware для Express.js
function boundaryValidation(req, res, next) {
  // Проверяем все входящие данные
  if (req.body) {
    req.body = sanitizeInput(req.body);
  }
  
  if (req.query) {
    req.query = sanitizeInput(req.query);
  }
  
  if (req.params) {
    req.params = sanitizeInput(req.params);
  }
  
  next();
}
```

### 3. Используйте параметризованные запросы

```javascript
// НЕБЕЗОПАСНО
const query = `SELECT * FROM users WHERE id = ${userId}`;

// БЕЗОПАСНО
const query = 'SELECT * FROM users WHERE id = ?';
const result = db.query(query, [userId]);
```

### 4. Регулярное обновление правил валидации

```javascript
// Конфигурация валидации
const validationConfig = {
  // Регулярно обновляемые правила
  emailPattern: /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  passwordMinLength: 8,
  allowedFileTypes: [
    'image/jpeg',
    'image/png',
    'application/pdf',
    'text/plain'
  ],
  maxFileSize: 5 * 1024 * 1024 // 5MB
};
```

## Заключение

Проверка ввода - фундаментальный элемент безопасности приложения. Она должна быть реализована как на клиентской, так и на серверной стороне, с использованием белых списков, регулярных выражений и других методов. Регулярное обновление и тестирование правил валидации помогает предотвратить большинство распространенных атак.

## Связанные темы

- [[Кодирование-вывода]]
- [[Санитизация-ввода]]
- [[Лучшие-практики-безопасности-API]]
- [[Руководство-по-безопасному-коду]]
- [[Тестирование-безопасности]]
- [[Безопасность-форм]]