---
aliases: ["Social Engineering Prevention", "Social Engineering Defense"]
tags: [security, social-engineering, user-awareness, fraud-prevention]
---

# Предотвращение-социальной-инженерии

## Введение

Социальная инженерия - это метод манипуляции людьми с целью получения конфиденциальной информации, доступа к системам или выполнения действий, которые могут нанести ущерб. В контексте веб-безопасности социальная инженерия может использоваться для получения логинов, паролей, данных кредитных карт и другой чувствительной информации.

## Типы атак социальной инженерии

### Фишинг
- Отправка поддельных электронных писем, имитирующих легитимные организации
- Создание фальшивых веб-сайтов для кражи учетных данных
- Использование срочных или пугающих сообщений для ускорения реакции

### Претензия на личность (Impersonation)
- Выдача себя за представителя доверенной организации
- Использование информации из социальных сетей для персонализации атак
- Телефонные звонки с просьбой предоставить учетные данные

### Приманка (Baiting)
- Предложение заманчивых вознаграждений или скидок
- Использование психологических триггеров для мотивации действий
- Распространение вредоносных файлов под видом полезных

### Принуждение (Quid Pro Quo)
- Предложение услуг или информации в обмен на конфиденциальные данные
- Создание видимости легитимности через официальные документы или формы

## Защита на уровне веб-приложения

### Проверка подлинности запросов

```javascript
// Пример проверки подлинности запросов от пользователей
class RequestAuthenticator {
    static verifyRequestIntegrity(request) {
        // Проверка referer заголовка
        const referer = request.headers.referer;
        const origin = request.headers.origin;
        const host = request.headers.host;
        
        // Проверка соответствия доменов
        if (referer && !this.isValidReferer(referer, host)) {
            return { valid: false, reason: 'Invalid referer' };
        }
        
        if (origin && !this.isValidOrigin(origin, host)) {
            return { valid: false, reason: 'Invalid origin' };
        }
        
        // Проверка CSRF токена
        const csrfToken = request.body.csrfToken || request.headers['x-csrf-token'];
        if (!this.isValidCSRFToken(csrfToken, request.session)) {
            return { valid: false, reason: 'Invalid CSRF token' };
        }
        
        return { valid: true };
    }
    
    static isValidReferer(referer, host) {
        try {
            const refererUrl = new URL(referer);
            return refererUrl.hostname === host;
        } catch {
            return false;
        }
    }
    
    static isValidOrigin(origin, host) {
        try {
            const originUrl = new URL(origin);
            return originUrl.hostname === host;
        } catch {
            return false;
        }
    }
    
    static isValidCSRFToken(token, session) {
        return token && session.csrfToken && token === session.csrfToken;
    }
}
```

### Защита от поддельных форм

```javascript
// Пример создания защищенной формы с защитой от поддельных запросов
class SecureFormGenerator {
    static generateSecureForm(action, fields, options = {}) {
        const csrfToken = this.generateCSRFToken();
        const timestamp = Date.now();
        const nonce = this.generateNonce();
        
        // Сохранение токена в сессии пользователя
        // (в реальном приложении это будет сделано на сервере)
        
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = action;
        form.className = 'secure-form';
        
        // Добавление скрытого поля с CSRF токеном
        const csrfInput = document.createElement('input');
        csrfInput.type = 'hidden';
        csrfInput.name = 'csrf_token';
        csrfInput.value = csrfToken;
        form.appendChild(csrfInput);
        
        // Добавление временной метки для проверки актуальности формы
        const timestampInput = document.createElement('input');
        timestampInput.type = 'hidden';
        timestampInput.name = 'timestamp';
        timestampInput.value = timestamp;
        form.appendChild(timestampInput);
        
        // Добавление nonce для дополнительной защиты
        const nonceInput = document.createElement('input');
        nonceInput.type = 'hidden';
        nonceInput.name = 'nonce';
        nonceInput.value = nonce;
        form.appendChild(nonceInput);
        
        // Добавление полей формы
        fields.forEach(field => {
            const input = document.createElement('input');
            input.type = field.type || 'text';
            input.name = field.name;
            input.placeholder = field.placeholder;
            input.required = field.required || false;
            
            if (field.type === 'password') {
                input.autocomplete = 'new-password';
            } else if (field.type === 'email') {
                input.autocomplete = 'email';
            }
            
            form.appendChild(input);
        });
        
        // Добавление кнопки отправки
        const submitButton = document.createElement('button');
        submitButton.type = 'submit';
        submitButton.textContent = options.submitText || 'Отправить';
        form.appendChild(submitButton);
        
        return form;
    }
    
    static generateCSRFToken() {
        // Генерация криптографически безопасного CSRF токена
        const array = new Uint8Array(32);
        window.crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }
    
    static generateNonce() {
        return Math.random().toString(36).substring(2, 15) + 
               Math.random().toString(36).substring(2, 15);
    }
}
```

### Обнаружение подозрительной активности

```javascript
// Система обнаружения подозрительной активности
class SuspiciousActivityDetector {
    constructor() {
        this.activityLog = new Map(); // Хранит активность пользователей
        this.suspiciousThreshold = 5; // Порог подозрительной активности
    }
    
    async analyzeUserActivity(userId, activity) {
        const userActivities = this.activityLog.get(userId) || [];
        userActivities.push({
            timestamp: Date.now(),
            activity: activity,
            ip: activity.ip,
            userAgent: activity.userAgent
        });
        
        // Удаляем старые записи (старше 1 часа)
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        const recentActivities = userActivities.filter(
            act => act.timestamp > oneHourAgo
        );
        
        this.activityLog.set(userId, recentActivities);
        
        // Проверяем различные признаки подозрительной активности
        const checks = [
            this.checkRapidActivity(userId, recentActivities),
            this.checkMultipleIPs(userId, recentActivities),
            this.checkUnusualTimes(userId, recentActivities),
            this.checkUnusualLocations(userId, recentActivities)
        ];
        
        const suspiciousActivities = await Promise.all(checks);
        const suspiciousCount = suspiciousActivities.filter(check => check.isSuspicious).length;
        
        return {
            isSuspicious: suspiciousCount >= this.suspiciousThreshold,
            alerts: suspiciousActivities.filter(check => check.isSuspicious),
            riskLevel: this.calculateRiskLevel(suspiciousCount)
        };
    }
    
    checkRapidActivity(userId, activities) {
        // Проверка на слишком частые действия
        const recentActions = activities.filter(
            act => Date.now() - act.timestamp < 5000 // за последние 5 секунд
        );
        
        return {
            isSuspicious: recentActions.length > 10,
            type: 'rapid-activity',
            description: `Обнаружено ${recentActions.length} действий за 5 секунд`
        };
    }
    
    checkMultipleIPs(userId, activities) {
        // Проверка на использование нескольких IP-адресов
        const uniqueIPs = new Set(activities.map(act => act.ip));
        
        return {
            isSuspicious: uniqueIPs.size > 3,
            type: 'multiple-ips',
            description: `Обнаружено использование ${uniqueIPs.size} различных IP-адресов`
        };
    }
    
    checkUnusualTimes(userId, activities) {
        // Проверка активности в необычное время
        const now = new Date();
        const hour = now.getHours();
        
        // Подозрительно, если активность в 2-5 часов утра
        const unusualTime = hour >= 2 && hour < 5;
        
        return {
            isSuspicious: unusualTime,
            type: 'unusual-time',
            description: `Активность в необычное время: ${hour}:00`
        };
    }
    
    calculateRiskLevel(suspiciousCount) {
        if (suspiciousCount >= 8) return 'very-high';
        if (suspiciousCount >= 5) return 'high';
        if (suspiciousCount >= 3) return 'medium';
        return 'low';
    }
}
```

## Защита пользовательского интерфейса

### Уведомления о безопасности

```javascript
// Компонент уведомлений о безопасности
class SecurityNotification {
    constructor(container) {
        this.container = container;
        this.notificationId = null;
    }
    
    showSecurityWarning(message, options = {}) {
        this.hideNotification(); // Скрываем предыдущее уведомление
        
        const notification = document.createElement('div');
        notification.className = `security-notification warning ${options.type || 'general'}`;
        notification.innerHTML = `
            <div class="notification-icon">⚠️</div>
            <div class="notification-content">
                <h4>Предупреждение безопасности</h4>
                <p>${message}</p>
                ${options.action ? `<button class="notification-action">${options.action}</button>` : ''}
            </div>
            <button class="notification-close" onclick="this.parentElement.remove()">×</button>
        `;
        
        // Добавляем обработчики событий
        if (options.onAction) {
            const actionButton = notification.querySelector('.notification-action');
            if (actionButton) {
                actionButton.addEventListener('click', options.onAction);
            }
        }
        
        this.container.appendChild(notification);
        this.notificationId = setTimeout(() => {
            this.hideNotification();
        }, options.duration || 10000); // По умолчанию 10 секунд
        
        return notification;
    }
    
    hideNotification() {
        if (this.notificationId) {
            clearTimeout(this.notificationId);
            this.notificationId = null;
        }
        
        const existingNotification = this.container.querySelector('.security-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
    }
}
```

### Защита от поддельных уведомлений

```javascript
// Система проверки подлинности уведомлений
class NotificationAuthenticator {
    static trustedDomains = [
        'yourdomain.com',
        'secure.yourdomain.com',
        'notifications.yourdomain.com'
    ];
    
    static verifyNotification(notificationData) {
        // Проверка цифровой подписи уведомления (в реальном приложении)
        if (!this.verifySignature(notificationData)) {
            return { valid: false, reason: 'Invalid signature' };
        }
        
        // Проверка времени действия уведомления
        const now = Date.now();
        if (notificationData.timestamp < now - 24 * 60 * 60 * 1000) { // 24 часа
            return { valid: false, reason: 'Notification expired' };
        }
        
        // Проверка отправителя
        if (!this.isTrustedSender(notificationData.sender)) {
            return { valid: false, reason: 'Untrusted sender' };
        }
        
        return { valid: true };
    }
    
    static verifySignature(data) {
        // Реализация проверки цифровой подписи
        // В реальном приложении это будет более сложной процедурой
        return !!data.signature; // Упрощенная проверка
    }
    
    static isTrustedSender(sender) {
        try {
            const url = new URL(sender);
            return this.trustedDomains.includes(url.hostname);
        } catch {
            return false;
        }
    }
}
```

## Образовательные элементы

### Интерактивные тренинги по безопасности

```javascript
// Интерактивный тренинг по распознаванию фишинга
class PhishingTraining {
    constructor(container) {
        this.container = container;
        this.currentScenario = 0;
        this.score = 0;
        this.scenarios = [
            {
                type: 'email',
                content: `
                    <h3>Письмо от: support@paypal-security.com</h3>
                    <p>Уважаемый клиент!</p>
                    <p>Мы обнаружили подозрительную активность на вашем аккаунте PayPal.</p>
                    <p>Для безопасности вашего аккаунта, пожалуйста, подтвердите свою личность, перейдя по ссылке ниже:</p>
                    <p><a href="#" class="suspicious-link">Подтвердить личность</a></p>
                    <p>Если вы не совершали недавних транзакций, немедленно свяжитесь с нами.</p>
                `,
                isPhishing: true,
                explanation: 'Это фишинговое письмо. PayPal никогда не отправляет письма с просьбой подтвердить личность через ссылку. Обратите внимание на подозрительный адрес отправителя.'
            },
            {
                type: 'email',
                content: `
                    <h3>Письмо от: billing@yourbank.com</h3>
                    <p>Здравствуйте, [ИМЯ КЛИЕНТА]</p>
                    <p>Ваша карта заблокирована из-за подозрительных операций.</p>
                    <p>Для разблокировки, пожалуйста, подтвердите вашу личность на нашем безопасном сайте:</p>
                    <p><a href="https://secure-bank-login.com">Разблокировать карту</a></p>
                    <p>С уважением, Служба поддержки банка</p>
                `,
                isPhishing: true,
                explanation: 'Фишинговое письмо. Обратите внимание на подозрительный домен (secure-bank-login.com) и отсутствие вашего имени в письме.'
            }
        ];
    }
    
    start() {
        this.renderScenario();
    }
    
    renderScenario() {
        const scenario = this.scenarios[this.currentScenario];
        
        this.container.innerHTML = `
            <div class="training-scenario">
                <div class="scenario-content">
                    ${scenario.content}
                </div>
                <div class="scenario-actions">
                    <button class="btn-safe" onclick="training.markAsSafe()">Это безопасно</button>
                    <button class="btn-suspicious" onclick="training.markAsSuspicious()">Это подозрительно</button>
                </div>
                <div class="scenario-counter">Сценарий ${this.currentScenario + 1} из ${this.scenarios.length}</div>
            </div>
        `;
    }
    
    markAsSafe() {
        const scenario = this.scenarios[this.currentScenario];
        if (!scenario.isPhishing) {
            this.score++;
            this.showResult('Правильно! Это безопасное сообщение.', 'success');
        } else {
            this.showResult(`Неправильно. ${scenario.explanation}`, 'error');
        }
        
        this.nextScenario();
    }
    
    markAsSuspicious() {
        const scenario = this.scenarios[this.currentScenario];
        if (scenario.isPhishing) {
            this.score++;
            this.showResult('Правильно! Это фишинговое сообщение.', 'success');
        } else {
            this.showResult('Неправильно. Это безопасное сообщение.', 'error');
        }
        
        this.nextScenario();
    }
    
    nextScenario() {
        setTimeout(() => {
            this.currentScenario++;
            if (this.currentScenario < this.scenarios.length) {
                this.renderScenario();
            } else {
                this.showResults();
            }
        }, 3000);
    }
    
    showResult(message, type) {
        const resultDiv = document.createElement('div');
        resultDiv.className = `result-message ${type}`;
        resultDiv.textContent = message;
        this.container.appendChild(resultDiv);
    }
    
    showResults() {
        this.container.innerHTML = `
            <div class="training-results">
                <h2>Результаты тренинга</h2>
                <p>Ваш счет: ${this.score} из ${this.scenarios.length}</p>
                <p>Уровень: ${this.getLevel()}</p>
                <button onclick="training.restart()">Пройти снова</button>
            </div>
        `;
    }
    
    getLevel() {
        const percentage = (this.score / this.scenarios.length) * 100;
        if (percentage >= 80) return 'Эксперт';
        if (percentage >= 60) return 'Продвинутый';
        if (percentage >= 40) return 'Начинающий';
        return 'Нуждается в тренировке';
    }
    
    restart() {
        this.currentScenario = 0;
        this.score = 0;
        this.start();
    }
}
```

## Интеграция с системами безопасности

### Проверка URL-адресов

```javascript
// Система проверки URL-адресов на безопасность
class URLSecurityChecker {
    static suspiciousPatterns = [
        /secure-login/,
        /verify-account/,
        /confirm-identity/,
        /banking-security/,
        /paypal-verify/,
        /\.tk$/,
        /\.ml$/,
        /\.ga$/,
        /\.cf$/,
        /login.*[0-9]/, // login1, login2, etc.
        /www\d+\./ // www1, www2, etc.
    ];
    
    static async checkURLSafety(url) {
        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();
            const pathname = urlObj.pathname.toLowerCase();
            const fullUrl = url.toLowerCase();
            
            // Проверка на подозрительные паттерны
            const suspiciousMatches = this.suspiciousPatterns.filter(pattern => 
                pattern.test(hostname) || pattern.test(pathname) || pattern.test(fullUrl)
            );
            
            // Проверка длины домена (часто длинные домены - подозрительные)
            const domainLength = hostname.length;
            
            // Проверка количества поддоменов
            const subdomainCount = hostname.split('.').length - 2;
            
            return {
                isSafe: suspiciousMatches.length === 0 && domainLength < 50 && subdomainCount < 3,
                suspiciousFactors: suspiciousMatches.map(pattern => pattern.toString()),
                riskScore: this.calculateRiskScore(suspiciousMatches, domainLength, subdomainCount),
                details: {
                    hostname: hostname,
                    domainLength: domainLength,
                    subdomainCount: subdomainCount,
                    suspiciousMatches: suspiciousMatches.length
                }
            };
        } catch (error) {
            return {
                isSafe: false,
                error: 'Invalid URL',
                riskScore: 10
            };
        }
    }
    
    static calculateRiskScore(suspiciousMatches, domainLength, subdomainCount) {
        let score = 0;
        
        // За каждый подозрительный паттерн
        score += suspiciousMatches.length * 2;
        
        // За длину домена (подозрительно, если > 30 символов)
        if (domainLength > 30) {
            score += Math.floor((domainLength - 30) / 10);
        }
        
        // За количество поддоменов (подозрительно, если > 2)
        if (subdomainCount > 2) {
            score += (subdomainCount - 2) * 3;
        }
        
        return Math.min(score, 10); // Максимум 10 баллов риска
    }
}
```

## Заключение

Предотвращение социальной инженерии требует комплексного подхода, включающего технические меры защиты, образовательные программы и постоянное повышение осведомленности пользователей. Важно сочетать автоматические системы обнаружения с обучением пользователей распознаванию мошеннических попыток.

> [!warning] Важно
> Социальная инженерия остается одной из самых эффективных форм атак, потому что эксплуатирует человеческий фактор, который труднее всего защитить технически.

> [!tip] Совет
> Регулярно проводите тренинги по безопасности для пользователей и внедряйте системы проверки подозрительных действий.

Связанные темы: [[Обучение-осведомленности-пользователей]], [[Проверка-идентичности]], [[Защита-от-фишинга]]