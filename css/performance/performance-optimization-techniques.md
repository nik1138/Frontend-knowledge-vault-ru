# Оптимизация производительности CSS

## Введение

Оптимизация CSS играет критическую роль в обеспечении быстрой загрузки веб-страниц и плавного пользовательского интерфейса. Понимание производительности CSS позволяет разработчикам создавать более быстрые и отзывчивые веб-приложения.

## Конвейер рендеринга

Конвейер рендеринга браузера состоит из нескольких этапов:

1. **Создание DOM-дерева** - разбор HTML
2. **Создание CSSOM** - разбор CSS и создание объектной модели стилей
3. **Создание Render-дерева** - объединение DOM и CSSOM
4. **Layout (компоновка)** - вычисление геометрии элементов
5. **Paint (отрисовка)** - отрисовка пикселей на экране
6. **Composite (композитинг)** - объединение слоев

Понимание этих этапов позволяет оптимизировать производительность CSS. Подробнее о конвейере рендеринга можно прочитать в статье [[rendering-pipeline]].

## Критический путь рендеринга

Критический путь рендеринга - это последовательность шагов, необходимых для отображения содержимого вьюпорта. Ключевые элементы:

- **Критические ресурсы** - файлы, которые блокируют рендеринг
- **Критические рендеринговые пути** - количество шагов, необходимых для отображения контента
- **Критические байты** - общее количество байтов, необходимых для отображения первой страницы

Для оптимизации критического пути рендеринга рекомендуется:
- Минимизировать количество критических ресурсов
- Уменьшить объем критических байтов
- Сократить продолжительность критических путей

## Производительность CSS-селекторов

Селекторы CSS обрабатываются справа налево, что влияет на производительность. Более специфичные селекторы требуют больше времени на обработку.

```css
/* Медленно */
div#container > ul.listing li.item a:hover

/* Быстрее */
.item a:hover
```

### Рекомендации по селекторам:
- Избегайте чрезмерной специфичности
- Используйте классы вместо тегов, когда это возможно
- Минимизируйте использование селекторов атрибутов
- Избегайте чрезмерного использования селекторов потомков

## Эффективные анимации

CSS-анимации могут быть выполнены с высокой производительностью при правильном подходе. Ключевые принципы:

- Анимируйте свойства `transform` и `opacity` для GPU-ускорения
- Используйте `will-change` для подготовки к анимации
- Избегайте анимации свойств, вызывающих layout или paint

```css
/* Хорошо - GPU-ускоренная анимация */
.animated-element {
  will-change: transform;
  transition: transform 0.3s ease;
}

.animated-element:hover {
  transform: translateX(100px);
}

/* Плохо - вызывает layout и paint */
.bad-animation {
  transition: width 0.3s ease;
}
```

## Оптимизации Paint и Layout

### Layout Thrashing
Избегайте частых переключений между чтением и записью свойств DOM:

```javascript
// Плохо
element.style.left = element.offsetLeft + 10 + 'px';
element.style.top = element.offsetTop + 10 + 'px';
element.style.left = element.offsetLeft + 10 + 'px';

// Хорошо
const currentLeft = element.offsetLeft;
const currentTop = element.offsetTop;
element.style.left = currentLeft + 10 + 'px';
element.style.top = currentTop + 10 + 'px';
```

### Использование CSS Containment
CSS Containment позволяет изолировать элементы и улучшить производительность:

```css
.container {
  contain: layout style paint;
}
```

## Уменьшение размера CSS-файлов

### Устранение неиспользуемого CSS

- Используйте инструменты вроде PurgeCSS или UnCSS
- Удаляйте неиспользуемые стили вручную
- Регулярно проводите аудит CSS-кода

### Сжатие и минификация CSS

```css
/* До минификации */
.header {
  background-color: #ffffff;
  padding: 10px;
  margin: 0 auto;
  border-radius: 5px;
}

/* После минификации */
.header{background-color:#fff;padding:10px;margin:0 auto;border-radius:5px}
```

Используйте инструменты сборки для автоматической минификации, такие как [[css-build-tools]].

## Извлечение критического CSS

Критический CSS - это минимальный набор стилей, необходимый для отображения видимой части страницы. Это позволяет ускорить начальную загрузку:

```html
<head>
  <!-- Встроенный критический CSS -->
  <style>
    .header { background: #fff; }
    .hero { height: 400px; }
  </style>
  <!-- Асинхронная загрузка остальных стилей -->
  <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
</head>
```

## Стратегии загрузки

### Асинхронная загрузка CSS

```html
<!-- Загрузка CSS без блокировки рендеринга -->
<link rel="preload" href="non-critical.css" as="style" onload="this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="non-critical.css"></noscript>
```

### Использование media-атрибутов

```html
<!-- Загрузка стилей только при необходимости -->
<link rel="stylesheet" href="print.css" media="print">
<link rel="stylesheet" href="mobile.css" media="(max-width: 768px)">
```

## Ресурсы, блокирующие рендеринг

CSS-файлы по умолчанию блокируют рендеринг. Для улучшения производительности:

- Встраивайте критические стили
- Асинхронно загружайте некритичные стили
- Используйте `preload` для важных ресурсов

## GPU против CPU рендеринга

Некоторые CSS-свойства могут быть обработаны GPU, что приводит к более плавной анимации:

- **GPU-ускоренные свойства**: `transform`, `opacity`
- **CPU-обрабатываемые свойства**: `width`, `height`, `top`, `left`, `background`

```css
/* GPU-ускорение */
.element {
  transform: translateZ(0); /* Активирует GPU-ускорение */
}
```

## Оптимизации Transform и Opacity

Анимации, использующие `transform` и `opacity`, выполняются на GPU и не вызывают layout или paint:

```css
.smooth-animation {
  transform: translateX(0);
  opacity: 1;
  transition: transform 0.3s, opacity 0.3s;
}

.smooth-animation:hover {
  transform: translateX(100px);
  opacity: 0.5;
}
```

## Paint Flashing

Paint flashing - это визуализация областей, которые перерисовываются браузером. Используйте инструменты разработчика для выявления проблемных участков.

## Containment

CSS Containment позволяет изолировать элементы и улучшить производительность:

- `contain: layout` - указывает, что внутренние элементы не влияют на внешние
- `contain: paint` - указывает, что содержимое не выходит за границы элемента
- `contain: size` - указывает, что размер элемента не зависит от его содержимого

```css
.isolated-widget {
  contain: layout paint;
}
```

## Свойство will-change

Свойство `will-change` позволяет заранее указать браузеру, какие свойства будут изменяться:

```css
.element {
  will-change: transform, opacity;
}

/* Не забудьте удалить после анимации */
.element.animation-complete {
  will-change: auto;
}
```

## Заключение

Оптимизация CSS производительности требует понимания конвейера рендеринга, эффективного использования селекторов и свойств, а также правильных стратегий загрузки. Регулярный аудит и тестирование производительности помогают поддерживать высокую скорость работы веб-сайтов.

## Связанные темы

- [[css-selectors]]
- [[css-animations]]
- [[rendering-pipeline]]
- [[css-build-tools]]
- [[css-architecture]]

## Теги

#css #performance #optimization #frontend #web-development #rendering #animations #selectors