---
aliases: ["Производительность псевдоклассов", "Оптимизация селекторов с псевдоклассами", "CSS производительность псевдоклассов"]
tags: [css/pseudo-classes, css-performance, css-selectors, optimization]
---

# Псевдоклассы и производительность: оптимизация сложных селекторов

## Введение

Псевдоклассы - мощный инструмент CSS, позволяющий создавать интерактивные и динамические интерфейсы. Однако неправильное использование псевдоклассов может негативно сказаться на производительности веб-страницы. В этом документе мы подробно рассмотрим, как псевдоклассы влияют на производительность и как оптимизировать сложные селекторы с их использованием.

## Влияние псевдоклассов на производительность

### Основы CSS-производительности

Каждый CSS-селектор требует от браузера вычислений для определения, соответствует ли элемент селектору. Псевдоклассы могут увеличивать сложность этих вычислений:

```css
/* Простой селектор - быстрый */
.item { color: blue; }

/* Селектор с псевдоклассом - немного медленнее */
.item:hover { color: red; }

/* Сложный селектор с несколькими псевдоклассами - медленнее */
.item:nth-child(odd):hover:focus { color: purple; }
```

### Категории псевдоклассов по производительности

#### Быстрые псевдоклассы
- `:hover`, `:focus`, `:active` - состояния элементов
- `:not()` - с простыми селекторами
- `:first-child`, `:last-child` - простые структурные

#### Средние по производительности
- `:nth-child()`, `:nth-of-type()` - требуют вычислений
- `:target` - требует проверки URL
- `:lang()` - требует проверки атрибута

#### Медленные псевдоклассы
- `:nth-child(an+b)` - сложные вычисления
- `:has()` - особенно медленный в текущих реализациях
- Сложные комбинации нескольких псевдоклассов

## Сложные селекторы и производительность

### Проблемы с производительностью

```css
/* МЕДЛЕННЫЙ селектор */
ul li:nth-child(odd):not(.special):hover + li:nth-child(even) { 
  background-color: yellow; 
}

/* БОЛЕЕ БЫСТРЫЙ подход */
.fast-selector:nth-child(odd) { background-color: yellow; }
```

### Селекторы с :not()

```css
/* Медленный: :not() с комплексным селектором */
.items li:not(.active):not(.disabled):hover { 
  background-color: blue; 
}

/* Быстрее: более конкретные селекторы */
.items li:hover { background-color: blue; }
.items li.active:hover,
.items li.disabled:hover { background-color: inherit; }
```

### Селекторы с :nth-child()

```css
/* Медленные nth-child выражения */
.slow-nth:nth-child(3n+1) { color: red; }
.very-slow:nth-child(5n+2):hover:focus { background: blue; }

/* Быстрые альтернативы */
.fast-alternative:nth-child(odd) { color: red; }
/* Или использовать классы в JavaScript */
```

## Оптимизация сложных селекторов

### 1. Использование классов вместо сложных псевдоклассов

```css
/* Медленный подход */
.data-table tr:nth-child(even):not(.highlighted) td:first-child:hover {
  background-color: yellow;
}

/* Быстрый подход */
.data-table .even-row:not(.highlighted) .first-cell:hover {
  background-color: yellow;
}
```

### 2. Упрощение сложных выражений

```css
/* Сложный селектор */
.complex-selector:nth-child(3n+1):not(.disabled):hover:focus {
  transform: scale(1.1);
}

/* Разделение на несколько простых селекторов */
.complex-selector:nth-child(3n+1) { transition: transform 0.3s; }
.complex-selector:not(.disabled):hover:focus { transform: scale(1.1); }
```

### 3. Использование CSS-переменных для динамических стилей

```css
/* Вместо переключения сложных псевдоклассов */
.dynamic-element {
  background-color: var(--bg-color, #fff);
  transition: background-color 0.3s;
}

/* JavaScript управляет переменной */
.element.style.setProperty('--bg-color', 'red');
```

## Практические примеры оптимизации

### Пример 1: Оптимизация сетки карточек

```html
<!-- НЕОПТИМИЗИРОВАННЫЙ ПОДХОД -->
<div class="card-grid">
  <div class="card">Карточка 1</div>
  <div class="card">Карточка 2</div>
  <div class="card">Карточка 3</div>
  <!-- и т.д. -->
</div>
```

```css
/* Медленные селекторы */
.card-grid .card:nth-child(odd):not(.featured):hover {
  transform: scale(1.05);
}

.card-grid .card:nth-child(even):not(.featured):focus {
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* ОПТИМИЗИРОВАННЫЙ ПОДХОД */
.card-grid .card {
  transition: transform 0.3s, box-shadow 0.3s;
}

.card-grid .card.odd:not(.featured):hover {
  transform: scale(1.05);
}

.card-grid .card.even:not(.featured):focus {
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
```

```javascript
// JavaScript для добавления классов
document.querySelectorAll('.card-grid .card').forEach((card, index) => {
  if (index % 2 === 0) {
    card.classList.add('even');
  } else {
    card.classList.add('odd');
  }
});
```

### Пример 2: Оптимизация навигации

```html
<nav class="main-nav">
  <ul>
    <li><a href="#" class="nav-link">Главная</a></li>
    <li><a href="#" class="nav-link active">О нас</a></li>
    <li><a href="#" class="nav-link">Услуги</a></li>
  </ul>
</nav>
```

```css
/* Медленный подход */
.main-nav ul li:nth-child(2n+1) a:hover:focus,
.main-nav ul li:not(.special) a:active {
  background-color: #007bff;
  color: white;
}

/* Быстрый подход */
.main-nav .nav-link:hover,
.main-nav .nav-link:focus {
  background-color: #007bff;
  color: white;
}

.main-nav .nav-link:nth-child(odd).odd-index {
  /* Добавляем класс через JS для нечетных элементов */
}
```

```javascript
// Добавляем классы для нечетных элементов
document.querySelectorAll('.main-nav .nav-link:nth-child(odd)').forEach(link => {
  link.classList.add('odd-index');
});
```

### Пример 3: Оптимизация формы с валидацией

```html
<form class="validation-form">
  <input type="text" class="form-input" required>
  <input type="email" class="form-input" required>
</form>
```

```css
/* Медленный подход */
.validation-form input:required:valid:focus,
.validation-form input:required:invalid:focus,
.validation-form input:not(:placeholder-shown):valid,
.validation-form input:not(:placeholder-shown):invalid {
  border: 2px solid #28a745;
}

/* Оптимизированный подход */
.form-input {
  transition: border-color 0.3s;
}

.form-input.valid { border-color: #28a745; }
.form-input.invalid { border-color: #dc3545; }
.form-input.focused { box-shadow: 0 0 0 2px rgba(0,123,255,0.25); }
```

```javascript
// JavaScript для управления классами
document.querySelectorAll('.form-input').forEach(input => {
  input.addEventListener('focus', () => {
    input.classList.add('focused');
  });
  
  input.addEventListener('blur', () => {
    input.classList.remove('focused');
  });
  
  input.addEventListener('input', () => {
    if (input.validity.valid) {
      input.classList.add('valid');
      input.classList.remove('invalid');
    } else {
      input.classList.add('invalid');
      input.classList.remove('valid');
    }
  });
});
```

## Использование современных оптимизаций

### CSS :is() и :where() для оптимизации

```css
/* Вместо повторения селекторов */
.nav-item:first-child,
.nav-item:last-child,
.nav-item:hover,
.nav-item:focus {
  background-color: #007bff;
}

/* Используем :is() */
.nav-item:is(:first-child, :last-child, :hover, :focus) {
  background-color: #007bff;
}

/* :where() имеет нулевую специфичность */
.nav-item:where(:hover, :focus) {
  background-color: #007bff;
}
```

### Использование CSS-контейнеров для изоляции

```css
.card-container {
  container-type: inline-size;
}

@container (min-width: 400px) {
  .card:is(:hover, :focus) {
    transform: scale(1.05);
  }
}
```

## Измерение производительности

### Использование инструментов разработчика

```javascript
// Простая функция для измерения времени рендеринга
function measureStylePerformance(selector) {
  const start = performance.now();
  
  // Принудительно вызываем перерасчет стилей
  const elements = document.querySelectorAll(selector);
  for (let i = 0; i < elements.length; i++) {
    // Получаем вычисленный стиль - вызывает перерасчет
    window.getComputedStyle(elements[i]).color;
  }
  
  const end = performance.now();
  console.log(`Селектор "${selector}" занял ${end - start} миллисекунд`);
}

// Использование
measureStylePerformance('.slow-selector:nth-child(3n+1):hover');
measureStylePerformance('.fast-selector.hover-state');
```

### Профилирование в DevTools

1. Откройте Chrome DevTools
2. Перейдите на вкладку "Performance"
3. Запишите взаимодействие с элементами
4. Проверьте время, затраченное на "Recalculate Style"

## Лучшие практики оптимизации

### 1. Минимизация сложных псевдоклассов

```css
/* Плохо: слишком сложный селектор */
.complex-grid .item:nth-child(3n+1):not(.special):hover:focus:active {
  /* стили */
}

/* Хорошо: разделение на несколько простых */
.item.complex:nth-child(odd) { /* стили для позиции */ }
.item:hover { /* стили для hover */ }
.item.focused { /* стили для фокуса - управляется JS */ }
```

### 2. Использование делегирования событий

```javascript
// Вместо добавления обработчиков каждому элементу
document.querySelector('.container').addEventListener('mouseenter', (e) => {
  if (e.target.matches('.item')) {
    e.target.classList.add('hovered');
  }
});

document.querySelector('.container').addEventListener('mouseleave', (e) => {
  if (e.target.matches('.item')) {
    e.target.classList.remove('hovered');
  }
});
```

### 3. Кэширование результатов вычислений

```javascript
// Кэшируем результаты сложных вычислений
const elementStates = new Map();

function getElementState(element) {
  const key = element.dataset.cacheKey || (element.dataset.cacheKey = Math.random().toString(36));
  
  if (!elementStates.has(key)) {
    // Выполняем сложные вычисления
    const state = {
      isEven: element.parentElement.children.length % 2 === 0,
      isSpecial: element.classList.contains('special'),
      // другие вычисления
    };
    elementStates.set(key, state);
  }
  
  return elementStates.get(key);
}
```

### 4. Использование GPU для анимаций

```css
/* Используем свойства, которые активируют GPU */
.optimized-animation {
  /* Вместо изменения layout свойств */
  transform: translateX(100px); /* GPU-ускоренное свойство */
  opacity: 0.5; /* GPU-ускоренное свойство */
}

/* Избегаем изменений, вызывающих перерисовку */
.avoid-repaint {
  /* border, background-color, width, height - избегаем */
}
```

## Совместимость и полифиллы

### Современные псевдоклассы и браузеры

```css
/* Проверка поддержки и резервные решения */
@supports not selector(:has(*)) {
  /* Резервное решение для :has() */
  .fallback-style { 
    /* Альтернативные стили */
  }
}

@supports selector(:is(*)) {
  .modern-approach:is(:hover, :focus) {
    /* Современные стили */
  }
}
```

## Заключение

Оптимизация псевдоклассов и сложных селекторов критически важна для производительности современных веб-приложений. Ключевые рекомендации:

1. Избегайте чрезмерно сложных комбинаций псевдоклассов
2. Используйте классы вместо сложных псевдоклассов при возможности
3. Применяйте :is() и :where() для упрощения повторяющихся селекторов
4. Используйте JavaScript для управления сложными состояниями
5. Тестируйте производительность в реальных условиях
6. Учитывайте специфичность при создании селекторов
7. Используйте GPU-ускоренные свойства для анимаций

Правильная оптимизация псевдоклассов позволяет создавать быстрые, отзывчивые интерфейсы без потери функциональности.

## См. также

- [[Псевдоклассы и их приоритеты: как браузер определяет порядок]]
- [[Псевдоклассы в анимациях: практические примеры]]
- [[Оптимизация селекторов для лучшей производительности]]
- [[Производительность CSS: оптимизация и лучшие практики]]
- [[Современные CSS-селекторы: :has(), :is(), :where(), :not()]]