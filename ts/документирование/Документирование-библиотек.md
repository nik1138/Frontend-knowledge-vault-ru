---
aliases: [Документирование библиотек TypeScript, Библиотека документации]
tags: [typescript, documentation, libraries, npm-package]
---

# Документирование TypeScript библиотек

## Обзор

Документирование TypeScript библиотек требует особого подхода, так как библиотеки предназначены для использования другими разработчиками. Качественная документация библиотеки критически важна для ее успешного принятия и использования сообществом. В этом руководстве мы рассмотрим ключевые аспекты документирования TypeScript библиотек, включая структуру, содержание и лучшие практики.

## Структура документации библиотеки

### 1. README файл

README является первым документом, который видят пользователи библиотеки:

```markdown
# My TypeScript Library

[![npm version](https://badge.fury.io/js/my-library.svg)](https://badge.fury.io/js/my-library)
[![Build Status](https://travis-ci.org/user/my-library.svg?branch=master)](https://travis-ci.org/user/my-library)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Краткое описание библиотеки и ее основного назначения.

## Установка

```bash
npm install my-library
```

## Быстрый старт

```typescript
import { MyClass } from 'my-library';

const instance = new MyClass();
const result = instance.doSomething();
console.log(result);
```

## Особенности

- Особенность 1
- Особенность 2
- Особенность 3

## Лицензия

MIT
```

### 2. Документация API

API документация должна быть тщательно проработана с использованием TSDoc:

```typescript
/**
 * Главный класс библиотеки для работы с данными
 * 
 * Предоставляет методы для:
 * - Загрузки данных из различных источников
 * - Преобразования и валидации данных
 * - Кэширования результатов операций
 * 
 * @example
 * ```ts
 * import { DataManager } from 'my-library';
 * 
 * const manager = new DataManager();
 * const data = await manager.load('https://api.example.com/data');
 * console.log(data);
 * ```
 * 
 * @public
 */
export class DataManager {
    /**
     * Загружает данные из указанного источника
     * 
     * Поддерживаемые источники:
     * - URL (HTTP/HTTPS)
     * - Путь к файлу (локальный)
     * - Объект конфигурации для базы данных
     * 
     * @param source - Источник данных для загрузки
     * @param options - Опции загрузки (необязательно)
     * @returns Promise, разрешающийся загруженными данными
     * 
     * @throws {DataLoadError} Если загрузка данных не удалась
     * @throws {ValidationError} Если источник данных некорректен
     * 
     * @public
     */
    async load(
        source: DataSource, 
        options?: LoadOptions
    ): Promise<Data> {
        // реализация
    }
    
    /**
     * Преобразует данные в указанный формат
     * 
     * @param data - Входные данные для преобразования
     * @param format - Целевой формат
     * @returns Преобразованные данные
     * 
     * @public
     */
    transform(data: unknown, format: DataFormat): TransformedData {
        // реализация
    }
}
```

## Документирование основных компонентов библиотеки

### 1. Публичные интерфейсы и типы

```typescript
/**
 * Определяет источник данных для загрузки
 * 
 * @public
 */
export type DataSource = 
    | string           // URL или путь к файлу
    | DatabaseConfig   // Конфигурация базы данных
    | DataStream;      // Поток данных

/**
 * Конфигурация подключения к базе данных
 * 
 * @public
 */
export interface DatabaseConfig {
    /** Тип базы данных */
    type: 'mysql' | 'postgresql' | 'sqlite';
    
    /** Адрес сервера базы данных */
    host: string;
    
    /** Номер порта */
    port: number;
    
    /** Имя базы данных */
    database: string;
    
    /** Имя пользователя */
    username: string;
    
    /** Пароль */
    password: string;
}

/**
 * Опции для операции загрузки данных
 * 
 * @public
 */
export interface LoadOptions {
    /**
     * Время ожидания запроса в миллисекундах
     * @defaultValue 30000
     */
    timeout?: number;
    
    /**
     * Максимальное количество повторных попыток при ошибке
     * @defaultValue 3
     */
    maxRetries?: number;
    
    /**
     * Функция для преобразования данных после загрузки
     */
    transform?: (data: unknown) => unknown;
    
    /**
     * Функция валидации данных
     * @returns true если данные корректны, иначе ошибка
     */
    validate?: (data: unknown) => asserts data is ValidData;
}
```

### 2. Классы и их методы

```typescript
/**
 * Менеджер кэширования данных
 * 
 * Использует LRU (Least Recently Used) алгоритм для управления кэшем
 * 
 * @public
 */
export class CacheManager {
    private cache: Map<string, CacheEntry>;
    private maxSize: number;
    
    /**
     * @param maxSize - Максимальный размер кэша (по умолчанию 100)
     */
    constructor(maxSize: number = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
    }
    
    /**
     * Получает значение из кэша по ключу
     * 
     * @param key - Ключ для поиска значения
     * @returns Значение из кэша или undefined, если ключ отсутствует
     *          или срок действия истек
     * 
     * @public
     */
    get<T>(key: string): T | undefined {
        const entry = this.cache.get(key);
        if (!entry) {
            return undefined;
        }
        
        // Проверяем срок действия
        if (Date.now() > entry.expiry) {
            this.cache.delete(key);
            return undefined;
        }
        
        // Обновляем порядок использования (LRU)
        this.cache.delete(key);
        this.cache.set(key, entry);
        
        return entry.value as T;
    }
    
    /**
     * Сохраняет значение в кэше
     * 
     * Если кэш превышает максимальный размер, удаляет наименее 
     * используемый элемент (LRU алгоритм)
     * 
     * @param key - Ключ для сохранения
     * @param value - Значение для сохранения
     * @param ttl - Время жизни в миллисекундах (по умолчанию 300000 - 5 минут)
     * 
     * @public
     */
    set<T>(key: string, value: T, ttl: number = 300000): void {
        // Удаляем при необходимости, чтобы освободить место
        if (this.cache.size >= this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        const expiry = Date.now() + ttl;
        this.cache.set(key, { value, expiry });
    }
    
    /**
     * Удаляет элемент из кэша
     * 
     * @param key - Ключ элемента для удаления
     * @returns true, если элемент был удален, иначе false
     * 
     * @public
     */
    delete(key: string): boolean {
        return this.cache.delete(key);
    }
    
    /**
     * Очищает весь кэш
     * 
     * @public
     */
    clear(): void {
        this.cache.clear();
    }
}
```

### 3. Функции утилит

```typescript
/**
 * Проверяет, является ли значение валидным JSON
 * 
 * @param value - Значение для проверки
 * @returns true, если значение является валидным JSON, иначе false
 * 
 * @example
 * ```ts
 * isValidJSON('{"name": "John"}'); // true
 * isValidJSON('invalid json');     // false
 * ```
 * 
 * @public
 */
export function isValidJSON(value: string): boolean {
    try {
        JSON.parse(value);
        return true;
    } catch {
        return false;
    }
}

/**
 * Глубокое слияние объектов
 * 
 * @param target - Целевой объект
 * @param sources - Объекты-источники для слияния
 * @returns Новый объект с объединенными свойствами
 * 
 * @example
 * ```ts
 * const obj1 = { a: 1, b: { c: 2 } };
 * const obj2 = { b: { d: 3 }, e: 4 };
 * const result = deepMerge(obj1, obj2);
 * // Результат: { a: 1, b: { c: 2, d: 3 }, e: 4 }
 * ```
 * 
 * @public
 */
export function deepMerge<T extends object>(target: T, ...sources: Partial<T>[]): T {
    // реализация
}
```

## Примеры использования

### Простые примеры

```typescript
/**
 * Функция для форматирования числа как валюты
 * 
 * @param amount - Сумма для форматирования
 * @param currency - Код валюты (по умолчанию 'USD')
 * @returns Отформатированная строка валюты
 * 
 * @example
 * ```ts
 * formatCurrency(1234.5); // '$1,234.50'
 * formatCurrency(1234.5, 'EUR'); // '€1,234.50'
 * ```
 * 
 * @public
 */
export function formatCurrency(amount: number, currency: string = 'USD'): string {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency
    }).format(amount);
}
```

### Комплексные примеры

```typescript
/**
 * Клиент для работы с REST API
 * 
 * @example
 * ```ts
 * // Создание клиента
 * import { ApiClient } from 'my-library';
 * 
 * const client = new ApiClient({
 *   baseUrl: 'https://api.example.com',
 *   apiKey: 'your-api-key',
 *   timeout: 5000
 * });
 * 
 * // Использование клиента
 * async function fetchUserData(userId: string) {
 *   try {
 *     const user = await client.get(`/users/${userId}`);
 *     return user;
 *   } catch (error) {
 *     console.error('Ошибка при получении данных пользователя:', error);
 *     throw error;
 *   }
 * }
 * 
 * // Использование с опциями
 * const result = await client.post('/users', {
 *   name: 'John Doe',
 *   email: 'john@example.com'
 * }, {
 *   headers: { 'Content-Type': 'application/json' }
 * });
 * ```
 * 
 * @public
 */
export class ApiClient {
    // реализация
}
```

## Документирование ошибок и исключений

### Создание пользовательских ошибок

```typescript
/**
 * Ошибка, возникающая при проблемах с загрузкой данных
 * 
 * @public
 */
export class DataLoadError extends Error {
    /**
     * @param message - Сообщение об ошибке
     * @param source - Источник, вызвавший ошибку
     * @param originalError - Исходная ошибка, если была
     */
    constructor(
        message: string,
        public source?: string,
        public originalError?: Error
    ) {
        super(message);
        this.name = 'DataLoadError';
    }
}

/**
 * Ошибка валидации данных
 * 
 * @public
 */
export class ValidationError extends Error {
    /**
     * @param message - Подробное сообщение об ошибке валидации
     * @param field - Поле, в котором произошла ошибка (опционально)
     * @param value - Значение, которое не прошло валидацию (опционально)
     */
    constructor(
        message: string,
        public field?: string,
        public value?: unknown
    ) {
        super(message);
        this.name = 'ValidationError';
    }
}
```

### Документирование возможных ошибок

```typescript
/**
 * Асинхронно загружает и валидирует конфигурацию
 * 
 * @param source - Источник конфигурации
 * @returns Promise с валидной конфигурацией
 * 
 * @throws {DataLoadError} Если загрузка конфигурации не удалась
 * @throws {ValidationError} Если конфигурация не соответствует схеме
 * @throws {SecurityError} Если конфигурация содержит небезопасные значения
 * 
 * @public
 */
export async function loadConfig(source: ConfigSource): Promise<ValidConfig> {
    try {
        const rawConfig = await loadRawConfig(source);
        validateConfig(rawConfig);
        return rawConfig as ValidConfig;
    } catch (error) {
        if (error instanceof ValidationError) {
            throw new ValidationError(
                `Невалидная конфигурация: ${error.message}`,
                error.field,
                error.value
            );
        }
        throw new DataLoadError(
            `Ошибка загрузки конфигурации из ${source}`,
            source,
            error as Error
        );
    }
}
```

## Документирование миграций и изменений

### Файл CHANGELOG

```markdown
# Changelog

Все значимые изменения в этой библиотеке будут задокументированы в этом файле.

## [2.1.0] - 2023-10-15

### Добавлено
- Новый метод `DataManager.transform()` для преобразования данных
- Поддержка кэширования с помощью `CacheManager`
- Новые типы ошибок: `ValidationError`, `SecurityError`

### Изменено
- Обновлена сигнатура метода `loadConfig()` - теперь возвращает `Promise<ValidConfig>`
- Улучшена производительность `deepMerge()` функции

### Устарело
- Метод `DataManager.legacyLoad()` помечен как устаревший, используйте `load()` вместо этого

## [2.0.0] - 2023-08-20

### Изменено (Критические изменения)
- Переписана система типов для лучшей совместимости с TypeScript 5.0
- Изменена структура конфигурации - см. руководство по миграции

### Удалено
- Удалена поддержка Node.js < 14
```

### Документирование устаревших API

```typescript
/**
 * @deprecated Используйте {@link DataManager.load} вместо этого метода
 * 
 * Старый метод загрузки данных, будет удален в версии 3.0
 * 
 * @param url - URL для загрузки данных
 * @returns Загруженные данные
 * 
 * @throws {DataLoadError} Если загрузка не удалась
 */
public legacyLoad(url: string): Promise<unknown> {
    // реализация
}
```

## Настройка инструментов документации

### TypeDoc конфигурация

```json
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["src/index.ts"],
  "out": "docs/api",
  "name": "My TypeScript Library",
  "readme": "README.md",
  "theme": "default",
  "excludeNotExported": true,
  "includeDeclarations": true,
  "excludeInternal": true,
  "excludePrivate": true,
  "excludeProtected": true,
  "categorizeByGroup": true,
  "categoryOrder": [
    "Getting Started",
    "Core Classes",
    "Utilities",
    "Types",
    "Errors",
    "*"
  ]
}
```

### Package.json документация

```json
{
  "name": "my-typescript-library",
  "version": "2.1.0",
  "description": "Комплексная TypeScript библиотека для работы с данными",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/**/*",
    "README.md",
    "CHANGELOG.md",
    "LICENSE"
  ],
  "scripts": {
    "docs": "typedoc",
    "docs:watch": "typedoc --watch"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/user/my-typescript-library.git"
  },
  "keywords": [
    "typescript",
    "data",
    "validation",
    "utility"
  ],
  "author": "Your Name",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/user/my-typescript-library/issues"
  },
  "homepage": "https://github.com/user/my-typescript-library#readme"
}
```

## Лучшие практики документирования библиотек

### 1. Пишите для пользователей

Документация должна быть понятной для разработчиков, которые будут использовать вашу библиотеку:

```typescript
/**
 * Преобразует строку в безопасный URL slug
 * 
 * Полезно для генерации URL из заголовков или других текстов
 * 
 * @param text - Входная строка для преобразования
 * @returns Строка, подходящая для использования в URL
 * 
 * @example
 * ```ts
 * // Для генерации URL из заголовка статьи
 * const title = 'Как создать TypeScript библиотеку';
 * const slug = toSlug(title); // 'kak-sozdat-typescript-biblioteku'
 * 
 * // Использование в маршрутах
 * const route = `/articles/${slug}`;
 * ```
 * 
 * @public
 */
export function toSlug(text: string): string {
    // реализация
}
```

### 2. Используйте систему тегов TSDoc

```typescript
/**
 * Асинхронно загружает и кэширует данные
 * 
 * @typeParam T - Тип ожидаемых данных
 * @param key - Уникальный ключ для идентификации данных
 * @param loader - Функция для загрузки данных
 * @param options - Опции кэширования
 * 
 * @returns Promise с загруженными данными
 * 
 * @throws {DataLoadError} Если загрузка данных не удалась
 * @throws {ValidationError} Если данные не прошли валидацию
 * 
 * @remarks
 * Данные будут кэшированы на 5 минут по умолчанию.
 * Для изменения времени жизни используйте опцию `ttl` в параметрах.
 * 
 * @beta - Этот метод находится на стадии бета-тестирования
 * 
 * @public
 */
export async function cachedLoad<T>(
    key: string,
    loader: () => Promise<T>,
    options?: CacheOptions
): Promise<T> {
    // реализация
}
```

### 3. Документируйте граничные случаи

```typescript
/**
 * Разбивает массив на части заданного размера
 * 
 * @param array - Массив для разбиения
 * @param chunkSize - Размер каждой части
 * @returns Массив, содержащий части оригинального массива
 * 
 * @example
 * ```ts
 * chunk([1, 2, 3, 4, 5], 2); // [[1, 2], [3, 4], [5]]
 * chunk([1, 2, 3, 4, 5], 0); // [] (пустой массив при chunkSize <= 0)
 * chunk([], 2);              // [] (пустой массив при пустом входе)
 * ```
 * 
 * @throws {Error} Если chunkSize отрицательный
 * 
 * @remarks
 * Если размер части больше длины массива, возвращается массив с одним элементом,
 * содержащим все элементы оригинального массива.
 * 
 * Если размер части равен 0 или отрицательный, возвращается пустой массив.
 * 
 * @public
 */
export function chunk<T>(array: T[], chunkSize: number): T[][] {
    if (chunkSize <= 0) {
        return [];
    }
    
    const result: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        result.push(array.slice(i, i + chunkSize));
    }
    return result;
}
```

## Связанные темы

- [[JSDoc]] - Классический подход к документированию JavaScript
- [[TSDoc]] - Современный стандарт документирования TypeScript
- [[Комментарии-в-коде]] - Принципы написания качественных комментариев
- [[Документация-API]] - Подробное руководство по документированию API