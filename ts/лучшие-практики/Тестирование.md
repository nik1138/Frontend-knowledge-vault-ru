---
aliases: ["Тестирование TypeScript", "Тестирование в TypeScript", "Testing Best Practices"]
tags: [typescript, testing, unit-testing, integration-testing, best-practices]
---

# Тестирование TypeScript

## Обзор

Тестирование в TypeScript играет ключевую роль в обеспечении качества, надежности и поддерживаемости кода. TypeScript, благодаря своей системе типов, уже предоставляет часть гарантий, но автоматизированное тестирование остается необходимым для проверки бизнес-логики, интеграции компонентов и предотвращения регрессий.

## Основные типы тестирования

### Модульное тестирование (Unit Testing)

Модульное тестирование проверяет отдельные компоненты (модули) системы изолированно:

```typescript
// src/services/user-service.ts
export class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUserById(id: string): Promise<User | null> {
    if (!id) {
      throw new Error('ID пользователя обязателен');
    }
    return await this.userRepository.findById(id);
  }
  
  async createUser(userData: UserInput): Promise<User> {
    if (!userData.email || !userData.name) {
      throw new ValidationError('Имя и email обязательны');
    }
    
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new Error('Пользователь с таким email уже существует');
    }
    
    return await this.userRepository.create(userData);
  }
}

// src/services/__tests__/user-service.test.ts
import { UserService } from '../user-service';
import { UserRepository } from '../../repositories/user-repository';
import { ValidationError } from '../../errors/validation-error';

describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;
  
  beforeEach(() => {
    mockUserRepository = {
      findById: jest.fn(),
      findByEmail: jest.fn(),
      create: jest.fn(),
    } as jest.Mocked<UserRepository>;
    
    userService = new UserService(mockUserRepository);
  });
  
  describe('getUserById', () => {
    it('должен вернуть пользователя по ID', async () => {
      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };
      mockUserRepository.findById.mockResolvedValue(mockUser);
      
      const result = await userService.getUserById('1');
      
      expect(result).toEqual(mockUser);
      expect(mockUserRepository.findById).toHaveBeenCalledWith('1');
    });
    
    it('должен выбросить ошибку, если ID не предоставлен', async () => {
      await expect(userService.getUserById('')).rejects.toThrow('ID пользователя обязателен');
    });
  });
  
  describe('createUser', () => {
    it('должен создать пользователя, если данные корректны', async () => {
      const userInput = { name: 'John', email: 'john@example.com' };
      const mockUser = { id: '1', ...userInput };
      
      mockUserRepository.findByEmail.mockResolvedValue(null);
      mockUserRepository.create.mockResolvedValue(mockUser);
      
      const result = await userService.createUser(userInput);
      
      expect(result).toEqual(mockUser);
      expect(mockUserRepository.create).toHaveBeenCalledWith(userInput);
    });
    
    it('должен выбросить ValidationError, если имя не предоставлено', async () => {
      const userInput = { email: 'john@example.com' } as any;
      
      await expect(userService.createUser(userInput)).rejects.toThrow(ValidationError);
    });
    
    it('должен выбросить ошибку, если пользователь с таким email уже существует', async () => {
      const userInput = { name: 'John', email: 'john@example.com' };
      const existingUser = { id: '2', name: 'Jane', email: 'john@example.com' };
      
      mockUserRepository.findByEmail.mockResolvedValue(existingUser);
      
      await expect(userService.createUser(userInput)).rejects.toThrow('Пользователь с таким email уже существует');
    });
  });
});
```

### Интеграционное тестирование (Integration Testing)

Интеграционное тестирование проверяет взаимодействие между несколькими модулями:

```typescript
// src/integration/__tests__/user-registration.test.ts
import { UserService } from '../../services/user-service';
import { EmailService } from '../../services/email-service';
import { UserRepository } from '../../repositories/user-repository';
import { InMemoryUserRepository } from '../../repositories/in-memory-user-repository';
import { InMemoryEmailService } from '../../services/in-memory-email-service';

describe('Регистрация пользователя (интеграционный тест)', () => {
  let userService: UserService;
  let userRepository: UserRepository;
  let emailService: EmailService;
  
  beforeEach(() => {
    userRepository = new InMemoryUserRepository();
    emailService = new InMemoryEmailService();
    userService = new UserService(userRepository, emailService);
  });
  
  it('должен создать пользователя и отправить приветственное письмо', async () => {
    const userData = { name: 'John', email: 'john@example.com' };
    
    const user = await userService.registerUser(userData);
    
    // Проверяем, что пользователь был создан
    expect(user).toBeDefined();
    expect(user.name).toBe('John');
    expect(user.email).toBe('john@example.com');
    
    // Проверяем, что пользователь сохранен в репозитории
    const savedUser = await userRepository.findByEmail('john@example.com');
    expect(savedUser).toBeDefined();
    expect(savedUser?.name).toBe('John');
    
    // Проверяем, что письмо было отправлено
    const sentEmails = (emailService as InMemoryEmailService).getSentEmails();
    expect(sentEmails).toHaveLength(1);
    expect(sentEmails[0].to).toBe('john@example.com');
    expect(sentEmails[0].subject).toBe('Добро пожаловать!');
  });
});
```

### E2E тестирование (End-to-End)

E2E тестирование проверяет полный пользовательский сценарий:

```typescript
// src/e2e/__tests__/user-login.test.ts
import { test, expect } from '@playwright/test';

test.describe('Вход пользователя', () => {
  test('пользователь может войти в систему с корректными учетными данными', async ({ page }) => {
    // Переход на страницу входа
    await page.goto('/login');
    
    // Заполнение формы
    await page.fill('[data-testid="email-input"]', 'user@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    
    // Нажатие кнопки входа
    await page.click('[data-testid="login-button"]');
    
    // Проверка, что пользователь вошел
    await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
    await expect(page).toHaveURL('/dashboard');
  });
  
  test('показывает ошибку при входе с неправильными учетными данными', async ({ page }) => {
    await page.goto('/login');
    
    await page.fill('[data-testid="email-input"]', 'wrong@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');
    await page.click('[data-testid="login-button"]');
    
    await expect(page.locator('[data-testid="error-message"]')).toContainText('Неверные учетные данные');
  });
});
```

## Инструменты тестирования

### Jest

Jest - популярный фреймворк для тестирования JavaScript/TypeScript:

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.+(ts|tsx|js)', '**/?(*.)+(spec|test).+(ts|tsx|js)'],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/index.ts'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts']
};

// src/test-setup.ts
import { jest } from '@jest/globals';

// Глобальные настройки для тестов
jest.setTimeout(10000);
```

### Testing Library

Testing Library фокусируется на тестировании с точки зрения пользователя:

```typescript
// src/components/__tests__/UserProfile.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { UserProfile } from '../UserProfile';
import { UserService } from '../../services/user-service';

// Мокаем сервис
jest.mock('../../services/user-service');

describe('UserProfile', () => {
  const mockUser = { id: '1', name: 'John Doe', email: 'john@example.com' };
  
  beforeEach(() => {
    (UserService.prototype.getUserById as jest.Mock).mockResolvedValue(mockUser);
  });
  
  it('отображает информацию о пользователе', async () => {
    render(<UserProfile userId="1" />);
    
    expect(screen.getByText(/загрузка/i)).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
  });
  
  it('показывает сообщение об ошибке при ошибке загрузки', async () => {
    (UserService.prototype.getUserById as jest.Mock).mockRejectedValue(new Error('Network error'));
    
    render(<UserProfile userId="1" />);
    
    await waitFor(() => {
      expect(screen.getByText(/ошибка загрузки/i)).toBeInTheDocument();
    });
  });
});
```

## Паттерны тестирования

### Arrange-Act-Assert (AAA)

Структура теста:
- **Arrange**: Подготовка тестовых данных
- **Act**: Выполнение тестируемого действия
- **Assert**: Проверка результатов

```typescript
describe('Calculator', () => {
  it('should add two numbers correctly', () => {
    // Arrange
    const calculator = new Calculator();
    const a = 5;
    const b = 3;
    
    // Act
    const result = calculator.add(a, b);
    
    // Assert
    expect(result).toBe(8);
  });
});
```

### Given-When-Then (GWT)

Альтернативная структура, часто используемая в BDD:

```typescript
describe('Shopping Cart', () => {
  it('should calculate total price correctly', () => {
    // Given
    const cart = new ShoppingCart();
    cart.addItem({ name: 'Item 1', price: 10 });
    cart.addItem({ name: 'Item 2', price: 20 });
    
    // When
    const totalPrice = cart.getTotalPrice();
    
    // Then
    expect(totalPrice).toBe(30);
  });
});
```

## Мокирование и стабирование

### Мокирование зависимостей

```typescript
// src/services/__tests__/order-service.test.ts
import { OrderService } from '../order-service';
import { PaymentService } from '../../payment/payment-service';
import { EmailService } from '../../notifications/email-service';

describe('OrderService', () => {
  let orderService: OrderService;
  let mockPaymentService: jest.Mocked<PaymentService>;
  let mockEmailService: jest.Mocked<EmailService>;
  
  beforeEach(() => {
    mockPaymentService = {
      processPayment: jest.fn(),
      refundPayment: jest.fn(),
    } as jest.Mocked<PaymentService>;
    
    mockEmailService = {
      sendEmail: jest.fn(),
    } as jest.Mocked<EmailService>;
    
    orderService = new OrderService(mockPaymentService, mockEmailService);
  });
  
  it('должен обработать заказ и отправить уведомление', async () => {
    const orderData = { userId: '1', items: [{ productId: 'p1', quantity: 2 }] };
    mockPaymentService.processPayment.mockResolvedValue({ success: true, transactionId: 't1' });
    
    await orderService.processOrder(orderData);
    
    expect(mockPaymentService.processPayment).toHaveBeenCalledWith(
      expect.objectContaining({ amount: expect.any(Number) })
    );
    expect(mockEmailService.sendEmail).toHaveBeenCalledWith(
      expect.any(String),
      'Заказ подтвержден',
      expect.any(String)
    );
  });
});
```

### Мокирование асинхронных операций

```typescript
// src/services/__tests__/data-fetcher.test.ts
import { DataFetcher } from '../data-fetcher';

describe('DataFetcher', () => {
  it('должен обработать успешный ответ', async () => {
    const mockFetch = jest.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ data: 'test data' })
    });
    
    // Заменяем глобальный fetch
    global.fetch = mockFetch as any;
    
    const fetcher = new DataFetcher();
    const result = await fetcher.fetchData('https://api.example.com/data');
    
    expect(result).toEqual({ data: 'test data' });
    expect(mockFetch).toHaveBeenCalledWith('https://api.example.com/data');
  });
  
  it('должен выбросить ошибку при неудачном ответе', async () => {
    const mockFetch = jest.fn().mockResolvedValue({
      ok: false,
      status: 404,
      statusText: 'Not Found'
    });
    
    global.fetch = mockFetch as any;
    
    const fetcher = new DataFetcher();
    
    await expect(fetcher.fetchData('https://api.example.com/data')).rejects.toThrow('HTTP 404: Not Found');
  });
});
```

## Тестирование асинхронного кода

### Тестирование Promise

```typescript
// src/services/__tests__/async-service.test.ts
describe('AsyncService', () => {
  it('должен корректно обработать асинхронную операцию', async () => {
    const service = new AsyncService();
    
    const result = await service.processAsyncData('test');
    
    expect(result).toBe('processed: test');
  });
  
  it('должен обработать ошибку в асинхронной операции', async () => {
    const service = new AsyncService();
    
    await expect(service.processAsyncData('error')).rejects.toThrow('Simulated error');
  });
  
  // Использование done callback (устаревший подход)
  it('должен обработать асинхронную операцию с done callback', (done) => {
    const service = new AsyncService();
    
    service.processAsyncDataWithCallback('test', (result) => {
      expect(result).toBe('processed: test');
      done();
    });
  });
});
```

### Тестирование с использованием fake timers

```typescript
// src/services/__tests__/scheduler-service.test.ts
describe('SchedulerService', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });
  
  afterEach(() => {
    jest.useRealTimers();
  });
  
  it('должен выполнить задачу после задержки', () => {
    const service = new SchedulerService();
    const mockCallback = jest.fn();
    
    service.scheduleTask(mockCallback, 1000);
    
    // Проверяем, что задача не выполнена до истечения времени
    expect(mockCallback).not.toHaveBeenCalled();
    
    // Пропускаем время
    jest.advanceTimersByTime(1000);
    
    // Проверяем, что задача выполнена
    expect(mockCallback).toHaveBeenCalledTimes(1);
  });
});
```

## Покрытие кода

### Настройка покрытия кода

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --coverageReporters=text-lcov | coveralls"
  }
}
```

### Минимальные требования к покрытию

```javascript
// jest.config.js
module.exports = {
  // ... другие настройки
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

## Тестирование типов (Type Testing)

### Проверка типов с помощью dts-jest

```typescript
// src/types/__tests__/user-types.test.ts
import { expectType } from 'tsd';
import { User, UserRole } from '../user-types';

// Проверяем, что User имеет ожидаемые свойства
const user: User = {
  id: '1',
  name: 'John',
  email: 'john@example.com',
  role: 'user' as UserRole
};

// Проверяем типы
expectType<string>(user.id);
expectType<string>(user.name);
expectType<string>(user.email);
expectType<UserRole>(user.role);

// Проверяем, что роль может быть только определенными значениями
const adminRole: UserRole = 'admin';
const userRole: UserRole = 'user';
const guestRole: UserRole = 'guest';
```

## Лучшие практики тестирования

### Именование тестов

```typescript
// Хорошо: понятное именование тестов
describe('UserService', () => {
  describe('getUserById', () => {
    it('should return user when valid id is provided', async () => {
      // тест
    });
    
    it('should throw error when empty id is provided', async () => {
      // тест
    });
    
    it('should return null when user does not exist', async () => {
      // тест
    });
  });
});

// Плохо: неинформативные имена
describe('Test', () => {
  it('works', () => {
    // тест
  });
  
  it('doesn\'t work', () => {
    // тест
  });
});
```

### Тестирование граничных условий

```typescript
// src/utils/__tests__/array-utilities.test.ts
describe('Array utilities', () => {
  describe('getFirstElement', () => {
    it('should return first element when array has elements', () => {
      expect(getFirstElement([1, 2, 3])).toBe(1);
    });
    
    it('should return undefined when array is empty', () => {
      expect(getFirstElement([])).toBeUndefined();
    });
    
    it('should return first element when array has one element', () => {
      expect(getFirstElement([42])).toBe(42);
    });
  });
});
```

### Использование фикстур и фабрик

```typescript
// src/test-helpers/user-factory.ts
import { User, UserRole } from '../types/user';

export const createUser = (overrides: Partial<User> = {}): User => ({
  id: overrides.id || '1',
  name: overrides.name || 'Test User',
  email: overrides.email || 'test@example.com',
  role: (overrides.role as UserRole) || 'user',
  createdAt: overrides.createdAt || new Date(),
  isActive: overrides.isActive ?? true,
  ...overrides
});

// src/test-helpers/fixtures.ts
export const FIXTURES = {
  VALID_USER: createUser(),
  ADMIN_USER: createUser({ role: 'admin' }),
  INACTIVE_USER: createUser({ isActive: false }),
  USERS: [
    createUser({ id: '1', name: 'User 1' }),
    createUser({ id: '2', name: 'User 2' }),
    createUser({ id: '3', name: 'User 3' })
  ]
};

// src/services/__tests__/user-service.test.ts
import { FIXTURES } from '../../test-helpers/fixtures';

describe('UserService', () => {
  it('should handle admin user correctly', async () => {
    const adminUser = FIXTURES.ADMIN_USER;
    // тест с использованием фикстуры
  });
});
```

## CI/CD и тестирование

### GitHub Actions для тестирования TypeScript

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16.x, 18.x]

    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test
    - run: npm run test:coverage
```

## Заключение

Тестирование TypeScript кода требует комплексного подхода, включающего модульное, интеграционное и E2E тестирование. Правильное тестирование помогает выявлять ошибки на ранних стадиях, обеспечивает уверенность при рефакторинге и улучшает качество конечного продукта.

Следование лучшим практикам тестирования, использование соответствующих инструментов и поддержание высокого уровня покрытия кода тестами являются ключевыми факторами успешной разработки на TypeScript.

Для дополнительной информации см. также:
- [[Стиль-кода]]
- [[Именование]]
- [[Организация-структуры]]
- [[Документирование]]
- [[Лучшие практики TypeScript]]

#typescript #testing #unit-testing #integration-testing #best-practices