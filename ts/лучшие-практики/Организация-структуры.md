---
aliases: ["Организация структуры TypeScript", "Архитектура проекта TypeScript", "Project Structure"]
tags: [typescript, architecture, project-structure, best-practices]
---

# Организация структуры TypeScript

## Обзор

Правильная организация структуры проекта TypeScript имеет критическое значение для поддерживаемости, масштабируемости и понимания кода. Хорошо организованная структура помогает разработчикам быстро находить нужные файлы, понимать зависимости и эффективно вносить изменения.

## Основные принципы организации

- **Модульность**: Разделение кода на логические модули
- **Согласованность**: Единообразная структура для всех компонентов
- **Изолированность**: Минимизация зависимостей между модулями
- **Масштабируемость**: Возможность легко добавлять новые функции

## Типичная структура проекта

```
src/
├── assets/                 # Статические ресурсы
├── components/            # Компоненты пользовательского интерфейса
├── services/              # Сервисы бизнес-логики
├── utils/                 # Вспомогательные функции
├── types/                 # Общие типы и интерфейсы
├── models/                # Модели данных
├── constants/             # Константы
├── hooks/                 # Пользовательские хуки (для React)
├── pages/                 # Страницы приложения
├── routes/                # Определения маршрутов
├── store/                 # Управление состоянием (Redux, Zustand и т.д.)
├── config/                # Конфигурационные файлы
├── tests/                 # Тесты
├── styles/                # Стили
└── index.ts               # Входная точка приложения
```

## Организация по функциональности

### Feature-first подход

Организация файлов по функциональности (feature-first) группирует все файлы, связанные с определенной функцией, в одной папке:

```
src/
├── features/
│   ├── user/
│   │   ├── components/
│   │   │   ├── UserProfile.tsx
│   │   │   └── UserAvatar.tsx
│   │   ├── services/
│   │   │   └── user-service.ts
│   │   ├── types/
│   │   │   └── user-types.ts
│   │   ├── hooks/
│   │   │   └── use-user.ts
│   │   ├── utils/
│   │   │   └── user-helpers.ts
│   │   └── index.ts
│   └── auth/
│       ├── components/
│       ├── services/
│       ├── types/
│       ├── hooks/
│       └── index.ts
├── shared/
│   ├── components/
│   ├── utils/
│   └── types/
└── app/
    ├── layout.tsx
    └── providers.tsx
```

### Преимущества feature-first подхода:

- **Локализация функциональности**: Все, что связано с одной функцией, находится в одном месте
- **Легкость рефакторинга**: Изменения в функции не затрагивают другие функции
- **Упрощение тестирования**: Тесты находятся рядом с кодом

## Организация по типу

### Type-first подход

Организация файлов по типу (type-first) группирует файлы по их типу:

```
src/
├── components/
│   ├── ui/
│   │   ├── Button.tsx
│   │   ├── Input.tsx
│   │   └── Modal.tsx
│   ├── common/
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   └── feature-specific/
│       ├── UserProfile.tsx
│       └── UserList.tsx
├── services/
│   ├── user-service.ts
│   ├── auth-service.ts
│   └── api-service.ts
├── models/
│   ├── User.ts
│   ├── Post.ts
│   └── Comment.ts
├── types/
│   ├── user-types.ts
│   ├── post-types.ts
│   └── common-types.ts
└── utils/
    ├── date-helpers.ts
    ├── string-helpers.ts
    └── validation.ts
```

## Лучшие практики организации

### Использование barrel-файлов

Создавайте `index.ts` файлы для экспорта из модулей:

```typescript
// src/services/index.ts
export { UserService } from './user-service';
export { AuthService } from './auth-service';
export { ApiService } from './api-service';

// src/types/index.ts
export type { User, UserInput } from './user-types';
export type { Post, PostInput } from './post-types';
```

Теперь можно импортировать так:

```typescript
import { UserService, AuthService } from './services';
import { User, Post } from './types';
```

### Группировка по слоям

Разделяйте код на слои архитектуры:

```
src/
├── domain/                # Бизнес-логика
│   ├── entities/          # Сущности
│   ├── repositories/      # Интерфейсы репозиториев
│   └── use-cases/         # Сценарии использования
├── application/           # Прикладной слой
│   ├── dtos/              # Объекты передачи данных
│   └── services/          # Прикладные сервисы
├── infrastructure/        # Инфраструктурный слой
│   ├── persistence/       # Хранилище данных
│   ├── external-api/      # Внешние API
│   └── config/            # Конфигурация
└── presentation/          # Слой представления
    ├── controllers/       # Контроллеры (для API)
    ├── views/             # Представления
    └── components/        # Компоненты UI
```

### Именование файлов

Следуйте последовательным правилам именования файлов:

```typescript
// Компоненты: PascalCase
UserProfile.tsx
UserList.tsx

// Службы: camelCase с суффиксом
userService.ts
apiService.ts

// Типы: camelCase с суффиксом
userTypes.ts
commonTypes.ts

// Модели: PascalCase
User.ts
Post.ts

// Тесты: соответствуют имени тестируемого файла
userService.test.ts
userProfile.test.tsx
```

## Модули и экспорты

### Экспорт по умолчанию vs именованный экспорт

Используйте именованные экспорты для нескольких связанных элементов:

```typescript
// src/utils/date-helpers.ts
export const formatDate = (date: Date): string => {
  return date.toLocaleDateString();
};

export const parseDate = (dateString: string): Date => {
  return new Date(dateString);
};

export const isDateValid = (date: Date): boolean => {
  return date instanceof Date && !isNaN(date.getTime());
};
```

Используйте экспорт по умолчанию для одного основного элемента:

```typescript
// src/components/UserProfile.tsx
import React from 'react';

const UserProfile: React.FC<UserProfileProps> = ({ user }) => {
  // реализация
};

export default UserProfile;
```

### Публичные API модулей

Ограничьте публичный API каждого модуля:

```typescript
// src/services/user-service/internal.ts (внутренние вспомогательные функции)
export const validateUserInput = (input: UserInput): boolean => {
  // внутренняя валидация
  return true;
};

// src/services/user-service/index.ts (публичный API)
import { validateUserInput } from './internal';

export class UserService {
  async createUser(input: UserInput): Promise<User> {
    if (!validateUserInput(input)) {
      throw new Error('Invalid user input');
    }
    // реализация
  }
  
  async getUser(id: string): Promise<User> {
    // реализация
  }
}
```

## Структура конфигурации

### Организация конфигурационных файлов

```typescript
// src/config/environment.ts
export const ENVIRONMENT = {
  isDevelopment: process.env.NODE_ENV === 'development',
  isProduction: process.env.NODE_ENV === 'production',
  apiUrl: process.env.REACT_APP_API_URL || 'http://localhost:3000/api'
};

// src/config/validation.ts
import { ENVIRONMENT } from './environment';

export const VALIDATION_CONFIG = {
  maxUsernameLength: 30,
  minPasswordLength: 8,
  emailPattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
};

// src/config/index.ts
export * from './environment';
export * from './validation';
```

## Структура тестов

### Организация тестов

Размещайте тесты рядом с тестируемым кодом:

```
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   └── Button.test.tsx
│   └── Input/
│       ├── Input.tsx
│       └── Input.test.tsx
├── services/
│   ├── userService.ts
│   └── userService.test.ts
└── utils/
    ├── dateHelpers.ts
    └── dateHelpers.test.ts
```

### Тестовые утилиты

Создайте общие тестовые утилиты:

```
src/
├── tests/
│   ├── utils/
│   │   ├── renderWithProviders.tsx
│   │   ├── createMockUser.ts
│   │   └── setupTests.ts
│   └── fixtures/
│       ├── users.ts
│       └── posts.ts
```

## Управление зависимостями

### Избегайте циклических зависимостей

Организуйте зависимости в направленной иерархии:

```typescript
// Плохо: циклическая зависимость
// user-service.ts
import { orderService } from './order-service';

// order-service.ts
import { userService } from './user-service';

// Хорошо: общая зависимость
// shared/types.ts
export interface User { id: string; name: string; }
export interface Order { id: string; userId: string; }

// user-service.ts
import { User, Order } from './shared/types';

// order-service.ts
import { User, Order } from './shared/types';

// business-logic.ts (верхний уровень)
import { userService } from './user-service';
import { orderService } from './order-service';
```

### Использование абстракций

Используйте интерфейсы для абстракции зависимостей:

```typescript
// src/types/repository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<User>;
  update(id: string, updates: Partial<User>): Promise<User>;
}

// src/services/user-service.ts
import { UserRepository } from '../types/repository';

export class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUser(id: string): Promise<User | null> {
    return await this.userRepository.findById(id);
  }
}
```

## Структура для разных типов проектов

### Frontend проекты (React, Vue, Angular)

```
src/
├── components/            # Переиспользуемые компоненты
├── pages/                 # Страницы приложения
├── hooks/                 # Пользовательские хуки
├── context/               # Контексты (React)
├── routes/                # Маршрутизация
├── assets/                # Статические ресурсы
├── styles/                # Стили
├── services/              # Сервисы API
├── store/                 # Управление состоянием
└── utils/                 # Вспомогательные функции
```

### Backend проекты (Node.js, Express, NestJS)

```
src/
├── controllers/           # Контроллеры API
├── services/              # Бизнес-логика
├── models/                # Модели данных
├── middleware/            # Промежуточное ПО
├── routes/                # Определения маршрутов
├── utils/                 # Вспомогательные функции
├── config/                # Конфигурация
├── database/              # Работа с базой данных
├── types/                 # Общие типы
└── validation/            # Валидация данных
```

## Заключение

Правильная организация структуры проекта TypeScript является фундаментальной частью разработки качественного программного обеспечения. Выбор подходящей структуры зависит от размера проекта, команды и специфики приложения.

Следование этим лучшим практикам поможет создать поддерживаемую, масштабируемую и понятную кодовую базу.

Для дополнительной информации см. также:
- [[Стиль-кода]]
- [[Именование]]
- [[Документирование]]
- [[Тестирование]]
- [[Архитектура TypeScript]]

#typescript #project-structure #architecture #best-practices