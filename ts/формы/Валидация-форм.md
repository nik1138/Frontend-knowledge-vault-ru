---
aliases: ["Валидация форм в TypeScript", "Form Validation"]
tags: ["#typescript", "#forms", "#validation", "#security"]
---

# Валидация-форм

Валидация форм — это процесс проверки данных, введенных пользователем, на соответствие заданным правилам. Правильная валидация обеспечивает целостность данных и защищает приложение от некорректного ввода.

## Основные принципы валидации

### Клиентская и серверная валидация

- **Клиентская валидация**: Улучшает UX, обеспечивает мгновенную обратную связь
- **Серверная валидация**: Обеспечивает безопасность и целостность данных

> [!warning] Важно
> Клиентская валидация не заменяет серверную — всегда проверяйте данные на сервере!

### Типы валидации

1. **Синтаксическая**: Проверка формата данных (email, телефон и т.д.)
2. **Семантическая**: Проверка логики (например, дата рождения не может быть в будущем)
3. **Бизнес-логика**: Проверка по правилам приложения (например, уникальность имени пользователя)

## Реализация валидации в TypeScript

### Интерфейсы для валидации

```typescript
interface ValidationRule<T> {
  validator: (value: T) => boolean;
  message: string;
}

interface FieldValidationConfig<T> {
  [fieldName: string]: ValidationRule<T[keyof T]>[];
}

interface ValidationResult {
  isValid: boolean;
  errors: Record<string, string[]>;
}
```

### Базовый валидатор

```typescript
class FormValidator<T extends Record<string, any>> {
  private rules: FieldValidationConfig<T>;

  constructor(rules: FieldValidationConfig<T>) {
    this.rules = rules;
  }

  validate(data: T): ValidationResult {
    const errors: Record<string, string[]> = {};
    let isValid = true;

    for (const fieldName in this.rules) {
      const fieldRules = this.rules[fieldName];
      const value = data[fieldName];
      const fieldErrors: string[] = [];

      for (const rule of fieldRules) {
        if (!rule.validator(value)) {
          fieldErrors.push(rule.message);
          isValid = false;
        }
      }

      if (fieldErrors.length > 0) {
        errors[fieldName] = fieldErrors;
      }
    }

    return { isValid, errors };
  }
}
```

### Пример использования

```typescript
interface UserRegistrationForm {
  username: string;
  email: string;
  password: string;
  age: number;
  termsAccepted: boolean;
}

const validationRules: FieldValidationConfig<UserRegistrationForm> = {
  username: [
    {
      validator: (value: string) => value.length >= 3,
      message: 'Имя пользователя должно содержать не менее 3 символов'
    },
    {
      validator: (value: string) => /^[a-zA-Z0-9_]+$/.test(value),
      message: 'Имя пользователя может содержать только буквы, цифры и символ подчеркивания'
    }
  ],
  email: [
    {
      validator: (value: string) => /\S+@\S+\.\S+/.test(value),
      message: 'Email должен быть валидным'
    }
  ],
  password: [
    {
      validator: (value: string) => value.length >= 8,
      message: 'Пароль должен содержать не менее 8 символов'
    },
    {
      validator: (value: string) => /[A-Z]/.test(value),
      message: 'Пароль должен содержать хотя бы одну заглавную букву'
    },
    {
      validator: (value: string) => /[0-9]/.test(value),
      message: 'Пароль должен содержать хотя бы одну цифру'
    }
  ],
  age: [
    {
      validator: (value: number) => value >= 13,
      message: 'Возраст должен быть не менее 13 лет'
    },
    {
      validator: (value: number) => value <= 120,
      message: 'Возраст должен быть не более 120 лет'
    }
  ],
  termsAccepted: [
    {
      validator: (value: boolean) => value === true,
      message: 'Необходимо принять условия использования'
    }
  ]
};

const userValidator = new FormValidator<UserRegistrationForm>(validationRules);

// Пример использования
const formData: UserRegistrationForm = {
  username: 'ab',
  email: 'invalid-email',
  password: 'short',
  age: 10,
  termsAccepted: false
};

const result = userValidator.validate(formData);
console.log(result);
// { 
//   isValid: false, 
//   errors: { 
//     username: ['Имя пользователя должно содержать не менее 3 символов'], 
//     email: ['Email должен быть валидным'], 
//     password: ['Пароль должен содержать не менее 8 символов', 'Пароль должен содержать хотя бы одну заглавную букву', 'Пароль должен содержать хотя бы одну цифру'], 
//     age: ['Возраст должен быть не менее 13 лет'], 
//     termsAccepted: ['Необходимо принять условия использования'] 
//   } 
// }
```

## Асинхронная валидация

Для проверки уникальности данных (например, имени пользователя или email) требуется асинхронная валидация:

```typescript
interface AsyncValidationRule<T> {
  validator: (value: T) => Promise<boolean>;
  message: string;
}

class AsyncFormValidator<T extends Record<string, any>> {
  private rules: FieldValidationConfig<T>;
  private asyncRules: Partial<Record<keyof T, AsyncValidationRule<T[keyof T]>[]>>;

  constructor(
    rules: FieldValidationConfig<T>,
    asyncRules: Partial<Record<keyof T, AsyncValidationRule<T[keyof T]>[]>> = {}
  ) {
    this.rules = rules;
    this.asyncRules = asyncRules;
  }

  async validate(data: T): Promise<ValidationResult> {
    const errors: Record<string, string[]> = {};
    let isValid = true;

    // Синхронная валидация
    for (const fieldName in this.rules) {
      const fieldRules = this.rules[fieldName];
      const value = data[fieldName];
      const fieldErrors: string[] = [];

      for (const rule of fieldRules) {
        if (!rule.validator(value)) {
          fieldErrors.push(rule.message);
          isValid = false;
        }
      }

      if (fieldErrors.length > 0) {
        errors[fieldName] = fieldErrors;
      }
    }

    // Асинхронная валидация
    for (const fieldName in this.asyncRules) {
      const fieldAsyncRules = this.asyncRules[fieldName];
      const value = data[fieldName];

      if (fieldAsyncRules) {
        for (const asyncRule of fieldAsyncRules) {
          try {
            const isValidAsync = await asyncRule.validator(value);
            if (!isValidAsync) {
              if (!errors[fieldName]) {
                errors[fieldName] = [];
              }
              errors[fieldName].push(asyncRule.message);
              isValid = false;
            }
          } catch (error) {
            // Обработка ошибок асинхронной валидации
            if (!errors[fieldName]) {
              errors[fieldName] = [];
            }
            errors[fieldName].push('Ошибка при проверке значения');
            isValid = false;
          }
        }
      }
    }

    return { isValid, errors };
  }
}
```

## Валидация на основе схем

Для сложных форм можно использовать библиотеки валидации на основе схем, такие как Zod или Yup:

### Использование Zod

```typescript
import { z } from 'zod';

const userRegistrationSchema = z.object({
  username: z.string()
    .min(3, 'Имя пользователя должно содержать не менее 3 символов')
    .max(30, 'Имя пользователя должно содержать не более 30 символов')
    .regex(/^[a-zA-Z0-9_]+$/, 'Имя пользователя может содержать только буквы, цифры и символ подчеркивания'),
  email: z.string().email('Email должен быть валидным'),
  password: z.string()
    .min(8, 'Пароль должен содержать не менее 8 символов')
    .regex(/[A-Z]/, 'Пароль должен содержать хотя бы одну заглавную букву')
    .regex(/[0-9]/, 'Пароль должен содержать хотя бы одну цифру'),
  age: z.number()
    .min(13, 'Возраст должен быть не менее 13 лет')
    .max(120, 'Возраст должен быть не более 120 лет'),
  termsAccepted: z.boolean().refine(value => value === true, {
    message: 'Необходимо принять условия использования'
  })
});

type UserRegistrationData = z.infer<typeof userRegistrationSchema>;

// Использование схемы для валидации
const formData = {
  username: 'testuser',
  email: 'test@example.com',
  password: 'MyPassword123',
  age: 25,
  termsAccepted: true
};

try {
  const validatedData = userRegistrationSchema.parse(formData);
  console.log('Данные валидны:', validatedData);
} catch (error) {
  if (error instanceof z.ZodError) {
    console.log('Ошибки валидации:', error.errors);
  }
}
```

## Лучшие практики валидации

- Валидируйте данные как на клиенте, так и на сервере
- Используйте понятные сообщения об ошибках
- Показывайте ошибки валидации в реальном времени
- Не храните чувствительные данные в открытом виде
- Используйте типизированные схемы для сложных форм
- Обрабатывайте асинхронные проверки с учетом производительности

## Связанные темы

- [[Управление-формами]]
- [[Формы-в-React]]
- [[Формы-в-Vue]]
- [[Формы-в-Angular]]
- [[Безопасность-веб-приложений]]