---
aliases: ["Управление формами в TypeScript", "Form Management"]
tags: ["#typescript", "#forms", "#state-management", "#validation"]
---

# Управление-формами

Управление формами в TypeScript-приложениях — это критический аспект разработки пользовательского интерфейса. Правильная организация управления состоянием формы, обработки событий и валидации данных обеспечивает надежность и удобство использования приложения.

## Основные концепции

### Состояние формы

Состояние формы включает в себя:
- Значения полей ввода
- Состояния валидации (валидна/невалидна)
- Состояния отправки (загрузка/ошибка/успех)
- Метаданные (например, изменение полей пользователем)

В TypeScript мы можем строго типизировать это состояние:

```typescript
interface FormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isSubmitting: boolean;
  isValid: boolean;
}

interface LoginFormValues {
  email: string;
  password: string;
  rememberMe: boolean;
}
```

### Типы управления формами

Существует несколько подходов к управлению формами:

1. **Управляемые компоненты** (Controlled Components)
2. **Неуправляемые компоненты** (Uncontrolled Components)
3. **Гибридный подход**

## Практические примеры

### Базовое управление формой

```typescript
import { useState } from 'react';

interface UserFormValues {
  name: string;
  email: string;
  age: number;
}

const UserForm: React.FC = () => {
  const [formState, setFormState] = useState<FormState<UserFormValues>>({
    values: { name: '', email: '', age: 0 },
    errors: {},
    touched: {},
    isSubmitting: false,
    isValid: true
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormState(prev => ({
      ...prev,
      values: {
        ...prev.values,
        [name]: value
      },
      touched: {
        ...prev.touched,
        [name]: true
      }
    }));
  };

  const validate = (values: UserFormValues): Partial<UserFormValues> => {
    const errors: Partial<UserFormValues> = {};
    
    if (!values.name) {
      errors.name = 'Имя обязательно';
    }
    
    if (!values.email) {
      errors.email = 'Email обязателен';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email некорректен';
    }
    
    if (values.age < 0 || values.age > 120) {
      errors.age = 'Возраст должен быть от 0 до 120';
    }
    
    return errors;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const errors = validate(formState.values);
    setFormState(prev => ({
      ...prev,
      errors,
      isValid: Object.keys(errors).length === 0,
      isSubmitting: true
    }));

    if (Object.keys(errors).length === 0) {
      // Отправка данных формы
      console.log('Форма отправлена:', formState.values);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="name"
          value={formState.values.name}
          onChange={handleChange}
          onBlur={handleChange}
        />
        {formState.errors.name && <span>{formState.errors.name}</span>}
      </div>
      
      <div>
        <input
          type="email"
          name="email"
          value={formState.values.email}
          onChange={handleChange}
          onBlur={handleChange}
        />
        {formState.errors.email && <span>{formState.errors.email}</span>}
      </div>
      
      <div>
        <input
          type="number"
          name="age"
          value={formState.values.age}
          onChange={handleChange}
          onBlur={handleChange}
        />
        {formState.errors.age && <span>{formState.errors.age}</span>}
      </div>
      
      <button type="submit" disabled={formState.isSubmitting}>
        Отправить
      </button>
    </form>
  );
};
```

## Продвинутые паттерны

### Использование кастомного хука

Для повторного использования логики управления формой можно создать кастомный хук:

```typescript
import { useState, useCallback } from 'react';

interface UseFormProps<T> {
  initialValues: T;
  validate: (values: T) => Partial<T>;
  onSubmit: (values: T) => void;
}

export const useForm = <T extends Record<string, any>>({
  initialValues,
  validate,
  onSubmit
}: UseFormProps<T>) => {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<T>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    if (touched[name]) {
      const newErrors = validate({ ...values, [name]: value });
      setErrors(newErrors);
    }
  }, [touched, validate, values]);

  const handleBlur = useCallback((name: keyof T) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    const newErrors = validate(values);
    setErrors(newErrors);
  }, [validate, values]);

  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    const newErrors = validate(values);
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      setIsSubmitting(true);
      onSubmit(values);
    }
  }, [onSubmit, validate, values]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit
  };
};
```

## Лучшие практики

- Используйте строгую типизацию для значений формы
- Централизуйте логику валидации
- Обрабатывайте различные состояния формы (загрузка, ошибка)
- Используйте кастомные хуки для повторного использования
- Обеспечьте доступность (accessibility) формы

## Связанные темы

- [[Валидация-форм]]
- [[Формы-в-React]]
- [[Формы-в-Vue]]
- [[Формы-в-Angular]]
- [[Состояние-приложения]]