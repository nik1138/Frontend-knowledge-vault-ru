---
aliases: ["DOM Узлы", "Узлы DOM", "TypeScript Узлы"]
tags: [typescript, dom, узлы, типизация]
---

# DOM Узлы в TypeScript

## Обзор

DOM узлы в TypeScript представлены иерархией типов, которая отражает структуру документа. Узлы являются основой DOM дерева и включают элементы, текстовые узлы, комментарии и другие типы содержимого. TypeScript предоставляет богатую систему типов для работы с узлами, обеспечивая безопасность типов при манипуляциях с DOM деревом.

## Иерархия типов узлов

### Базовые типы узлов

- `Node` - базовый тип для всех узлов DOM
- `Document` - узел документа
- `Element` - узлы элементов
- `Text` - текстовые узлы
- `Comment` - комментарии
- `DocumentFragment` - фрагменты документа
- `DocumentType` - объявления типа документа

### Структура наследования

```
EventTarget
├── Node
│   ├── Document
│   ├── Element
│   │   ├── HTMLElement
│   │   └── SVGElement
│   ├── Text
│   ├── Comment
│   └── DocumentFragment
```

## Основные свойства и методы узлов

### Общие свойства узлов

```typescript
const node = document.querySelector('*');

if (node) {
  // Базовые свойства узла
  console.log('Тип узла:', node.nodeType);
  console.log('Имя узла:', node.nodeName);
  console.log('Текстовое содержимое:', node.textContent);
  console.log('Владелец документа:', node.ownerDocument);
  
  // Связи с другими узлами
  console.log('Родительский узел:', node.parentNode);
  console.log('Первый дочерний узел:', node.firstChild);
  console.log('Последний дочерний узел:', node.lastChild);
  console.log('Предыдущий соседний узел:', node.previousSibling);
  console.log('Следующий соседний узел:', node.nextSibling);
}
```

### Общие методы узлов

```typescript
const parent = document.querySelector('div');
const child = document.querySelector('p');

if (parent && child) {
  // Добавление узла
  parent.appendChild(child);
  
  // Проверка связи узлов
  console.log('parent содержит child:', parent.contains(child));
  
  // Клонирование узла
  const clonedNode = child.cloneNode(true); // true для глубокого клонирования
  
  // Удаление узла
  child.remove();
}
```

## Типизация конкретных видов узлов

### Text узлы

```typescript
// Создание текстового узла
const textNode = document.createTextNode('Это текстовый узел');

// Работа с текстовыми узлами
console.log('Содержимое текстового узла:', textNode.textContent);
textNode.textContent = 'Новое содержимое';

// Получение текстового узла из DOM
const element = document.querySelector('p');
if (element) {
  const childNodes = element.childNodes;
  for (let i = 0; i < childNodes.length; i++) {
    const node = childNodes[i];
    if (node.nodeType === Node.TEXT_NODE) {
      // Это текстовый узел
      const textNode = node as Text;
      console.log('Текстовое содержимое:', textNode.textContent);
    }
  }
}
```

### Comment узлы

```typescript
// Создание комментария
const commentNode = document.createComment('Это комментарий');

// Работа с комментариями
console.log('Содержимое комментария:', commentNode.textContent);
commentNode.textContent = 'Новое содержимое комментария';

// Поиск комментариев в DOM
function findComments(node: Node): Comment[] {
  const comments: Comment[] = [];
  
  if (node.nodeType === Node.COMMENT_NODE) {
    comments.push(node as Comment);
  }
  
  // Рекурсивный поиск в дочерних узлах
  if (node.hasChildNodes()) {
    for (let i = 0; i < node.childNodes.length; i++) {
      comments.push(...findComments(node.childNodes[i]));
    }
  }
  
  return comments;
}
```

### DocumentFragment

```typescript
// Создание фрагмента документа
const fragment = document.createDocumentFragment();

// Добавление элементов во фрагмент
for (let i = 0; i < 5; i++) {
  const div = document.createElement('div');
  div.textContent = `Элемент ${i + 1}`;
  fragment.appendChild(div);
}

// Добавление фрагмента в DOM (все элементы добавляются за одну операцию)
const container = document.querySelector('#container');
if (container) {
  container.appendChild(fragment);
}
```

## Работа с деревом узлов

### Обход дерева узлов

```typescript
// Рекурсивный обход всех узлов
function traverseNodes(node: Node, callback: (node: Node) => void) {
  callback(node);
  
  if (node.hasChildNodes()) {
    for (let i = 0; i < node.childNodes.length; i++) {
      traverseNodes(node.childNodes[i], callback);
    }
  }
}

// Пример использования
const root = document.body;
if (root) {
  traverseNodes(root, (node) => {
    console.log(`Тип узла: ${node.nodeType}, Имя: ${node.nodeName}`);
  });
}
```

### Поиск узлов по типу

```typescript
// Функция для поиска всех элементов в DOM
function findElements(node: Node): Element[] {
  const elements: Element[] = [];
  
  if (node.nodeType === Node.ELEMENT_NODE) {
    elements.push(node as Element);
  }
  
  if (node.hasChildNodes()) {
    for (let i = 0; i < node.childNodes.length; i++) {
      elements.push(...findElements(node.childNodes[i]));
    }
  }
  
  return elements;
}

// Функция для поиска всех текстовых узлов
function findTextNodes(node: Node): Text[] {
  const textNodes: Text[] = [];
  
  if (node.nodeType === Node.TEXT_NODE) {
    textNodes.push(node as Text);
  }
  
  if (node.hasChildNodes()) {
    for (let i = 0; i < node.childNodes.length; i++) {
      textNodes.push(...findTextNodes(node.childNodes[i]));
    }
  }
  
  return textNodes;
}
```

## Типизация для конкретных задач

### Работа с деревом элементов

```typescript
// Тип для представления узла дерева
interface TreeNode {
  element: HTMLElement;
  children: TreeNode[];
  parent: TreeNode | null;
}

// Создание дерева из DOM элемента
function createTree(element: HTMLElement, parent: TreeNode | null = null): TreeNode {
  const treeNode: TreeNode = {
    element,
    children: [],
    parent
  };
  
  // Добавление дочерних элементов
  for (let i = 0; i < element.children.length; i++) {
    const childElement = element.children[i] as HTMLElement;
    treeNode.children.push(createTree(childElement, treeNode));
  }
  
  return treeNode;
}
```

### Проверка типов узлов

```typescript
// Type guards для различных типов узлов
function isElementNode(node: Node): node is Element {
  return node.nodeType === Node.ELEMENT_NODE;
}

function isTextNode(node: Node): node is Text {
  return node.nodeType === Node.TEXT_NODE;
}

function isCommentNode(node: Node): node is Comment {
  return node.nodeType === Node.COMMENT_NODE;
}

function isDocumentFragment(node: Node): node is DocumentFragment {
  return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}

// Использование type guards
const node = document.querySelector('*');

if (node) {
  if (isElementNode(node)) {
    console.log('Это элемент:', node.tagName);
  } else if (isTextNode(node)) {
    console.log('Это текстовый узел:', node.textContent);
  } else if (isCommentNode(node)) {
    console.log('Это комментарий:', node.textContent);
  } else if (isDocumentFragment(node)) {
    console.log('Это фрагмент документа');
  }
}
```

## Практические рекомендации

### Оптимизация операций с DOM

```typescript
// Использование DocumentFragment для эффективного добавления множества элементов
function addManyElements(container: HTMLElement, count: number) {
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < count; i++) {
    const div = document.createElement('div');
    div.textContent = `Элемент ${i + 1}`;
    fragment.appendChild(div);
  }
  
  container.appendChild(fragment); // Одна операция вставки
}
```

### Работа с узлами без приведения типов

```typescript
// Использование instanceof для проверки типа
function processNode(node: Node) {
  if (node instanceof Element) {
    console.log('Это элемент:', node.tagName);
  } else if (node instanceof Text) {
    console.log('Это текст:', node.textContent);
  } else if (node instanceof Comment) {
    console.log('Это комментарий:', node.textContent);
  }
}
```

### Создание безопасных функций работы с узлами

```typescript
// Функция для безопасного добавления узла
function safeAppendChild(parent: Node, child: Node): boolean {
  try {
    parent.appendChild(child);
    return true;
  } catch (error) {
    console.error('Ошибка при добавлении узла:', error);
    return false;
  }
}

// Функция для безопасного удаления узла
function safeRemoveChild(node: Node): boolean {
  try {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
      return true;
    }
    return false;
  } catch (error) {
    console.error('Ошибка при удалении узла:', error);
    return false;
  }
}
```

## Заключение

Типизация DOM узлов в TypeScript обеспечивает безопасность типов при работе с деревом документа. Понимание иерархии типов узлов и использование соответствующих методов и свойств позволяет создавать надежный и эффективный код для манипуляций с DOM.

См. также:
- [[Типы-DOM]]
- [[Элементы]]
- [[События]]
- [[Атрибуты]]