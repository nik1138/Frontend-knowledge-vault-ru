---
aliases: ["Доступные пользовательские интерфейсы", "Доступные UI-компоненты", "Инклюзивные компоненты"]
tags: ["#web-accessibility", "#components", "#typescript", "#react"]
---

# Доступные компоненты

## Обзор

Создание доступных компонентов - ключевой аспект разработки веб-приложений, особенно при использовании TypeScript и современных фреймворков, таких как React. Доступные компоненты обеспечивают равный доступ к функциональности для всех пользователей, включая тех, кто использует вспомогательные технологии.

## Основные принципы доступных компонентов

### 1. Клавиатурная навигация

```typescript
// Пример компонента с поддержкой клавиатурной навигации
interface AccessibleButtonProps {
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
  className?: string;
}

const AccessibleButton: React.FC<AccessibleButtonProps> = ({ 
  onClick, 
  children, 
  disabled = false,
  className = '' 
}) => {
  const handleClick = () => {
    if (!disabled) {
      onClick();
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;
    
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      onClick();
    }
  };

  return (
    <button
      className={className}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      disabled={disabled}
      tabIndex={disabled ? -1 : 0}
      aria-disabled={disabled}
    >
      {children}
    </button>
  );
};

// Компонент с поддержкой клавиатурной навигации внутри себя
interface AccessibleMenuProps {
  items: { id: string; label: string; onClick: () => void }[];
  isOpen: boolean;
  onClose: () => void;
}

const AccessibleMenu: React.FC<AccessibleMenuProps> = ({ items, isOpen, onClose }) => {
  if (!isOpen) return null;

  const menuRef = React.useRef<HTMLDivElement>(null);
  
  React.useEffect(() => {
    if (isOpen && menuRef.current) {
      menuRef.current.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Escape':
        onClose();
        break;
      case 'ArrowDown':
        e.preventDefault();
        // Логика перемещения вниз по меню
        break;
      case 'ArrowUp':
        e.preventDefault();
        // Логика перемещения вверх по меню
        break;
      default:
        break;
    }
  };

  return (
    <div
      ref={menuRef}
      role="menu"
      tabIndex={-1}
      onKeyDown={handleKeyDown}
      aria-label="Меню навигации"
    >
      {items.map((item, index) => (
        <div
          key={item.id}
          role="menuitem"
          tabIndex={-1}
          onClick={item.onClick}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              item.onClick();
            }
          }}
        >
          {item.label}
        </div>
      ))}
    </div>
  );
};
```

### 2. Управление фокусом

```typescript
// Пример компонента с управлением фокусом
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
  const modalRef = React.useRef<HTMLDivElement>(null);
  const firstFocusableRef = React.useRef<HTMLElement>(null);
  const lastFocusableRef = React.useRef<HTMLElement>(null);

  // Фокусировка при открытии модального окна
  React.useEffect(() => {
    if (isOpen && modalRef.current) {
      // Поиск первого фокусируемого элемента
      const focusableElements = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length > 0) {
        firstFocusableRef.current = focusableElements[0] as HTMLElement;
        lastFocusableRef.current = focusableElements[focusableElements.length - 1] as HTMLElement;
        
        // Установка фокуса на первый элемент
        firstFocusableRef.current.focus();
      } else {
        // Если нет фокусируемых элементов, фокус на контейнер
        modalRef.current.focus();
      }
    }
  }, [isOpen]);

  // Обработка клавиатурной навигации для ограничения фокуса
  React.useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        if (!modalRef.current) return;
        
        const focusableElements = modalRef.current.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
        
        if (e.shiftKey && document.activeElement === firstElement) {
          // Перейти к последнему элементу при Shift+Tab на первом элементе
          lastElement.focus();
          e.preventDefault();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          // Перейти к первому элементу при Tab на последнем элементе
          firstElement.focus();
          e.preventDefault();
        }
      } else if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      // Ограничение фокуса на body при открытии модального окна
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        className="modal"
        onClick={(e) => e.stopPropagation()}
        tabIndex={-1}
      >
        <header className="modal-header">
          <h2 id="modal-title">{title}</h2>
          <button
            aria-label="Закрыть модальное окно"
            onClick={onClose}
            className="close-button"
          >
            ×
          </button>
        </header>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>
  );
};
```

### 3. Адаптация для вспомогательных технологий

```typescript
// Пример компонента с поддержкой скринридеров
interface ProgressBarProps {
  value: number;
  max: number;
  label: string;
  description?: string;
}

const ProgressBar: React.FC<ProgressBarProps> = ({ value, max, label, description }) => {
  const progressId = React.useId();
  const descriptionId = React.useId();

  return (
    <div className="progress-container">
      <div 
        role="progressbar"
        aria-labelledby={progressId}
        aria-describedby={description ? descriptionId : undefined}
        aria-valuenow={value}
        aria-valuemin={0}
        aria-valuemax={max}
        style={{ width: `${(value / max) * 100}%` }}
        className="progress-bar"
      />
      <div id={progressId} className="progress-label">
        {label}: {Math.round((value / max) * 100)}%
      </div>
      {description && (
        <div id={descriptionId} className="progress-description">
          {description}
        </div>
      )}
    </div>
  );
};

// Компонент уведомления с поддержкой скринридеров
interface AlertProps {
  children: React.ReactNode;
  type?: 'info' | 'success' | 'warning' | 'error';
  autoDismiss?: boolean;
  duration?: number;
}

const Alert: React.FC<AlertProps> = ({ 
  children, 
  type = 'info', 
  autoDismiss = false, 
  duration = 5000 
}) => {
  const [visible, setVisible] = React.useState(true);

  React.useEffect(() => {
    if (autoDismiss) {
      const timer = setTimeout(() => {
        setVisible(false);
      }, duration);

      return () => clearTimeout(timer);
    }
  }, [autoDismiss, duration]);

  if (!visible) return null;

  return (
    <div
      role="alert"
      aria-live="assertive"
      className={`alert alert-${type}`}
    >
      {children}
    </div>
  );
};
```

## Практические примеры доступных компонентов

### Доступный аккордеон

```typescript
// Типы для аккордеона
interface AccordionItem {
  id: string;
  title: string;
  content: React.ReactNode;
}

interface AccordionProps {
  items: AccordionItem[];
  multiple?: boolean;
  className?: string;
}

const Accordion: React.FC<AccordionProps> = ({ items, multiple = false, className = '' }) => {
  const [openItems, setOpenItems] = React.useState<string[]>([]);

  const toggleItem = (id: string) => {
    if (multiple) {
      setOpenItems(prev => 
        prev.includes(id) 
          ? prev.filter(item => item !== id) 
          : [...prev, id]
      );
    } else {
      setOpenItems(prev => 
        prev.includes(id) ? [] : [id]
      );
    }
  };

  return (
    <div className={`accordion ${className}`}>
      {items.map(item => (
        <div key={item.id} className="accordion-item">
          <h3>
            <button
              className="accordion-header"
              aria-expanded={openItems.includes(item.id)}
              aria-controls={`accordion-panel-${item.id}`}
              onClick={() => toggleItem(item.id)}
            >
              {item.title}
              <span 
                className={`accordion-icon ${openItems.includes(item.id) ? 'open' : ''}`}
                aria-hidden="true"
              >
                ▼
              </span>
            </button>
          </h3>
          <div
            id={`accordion-panel-${item.id}`}
            role="region"
            aria-labelledby={`accordion-header-${item.id}`}
            className={`accordion-panel ${openItems.includes(item.id) ? 'open' : ''}`}
            hidden={!openItems.includes(item.id)}
          >
            <div className="accordion-content">
              {item.content}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};
```

### Доступный таб-компонент

```typescript
// Типы для табов
interface TabItem {
  id: string;
  label: string;
  content: React.ReactNode;
}

interface TabsProps {
  items: TabItem[];
  defaultActiveId?: string;
  className?: string;
}

const Tabs: React.FC<TabsProps> = ({ items, defaultActiveId, className = '' }) => {
  const [activeTab, setActiveTab] = React.useState(defaultActiveId || items[0]?.id);

  const handleKeyDown = (e: React.KeyboardEvent, tabId: string) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
        e.preventDefault();
        setActiveTab(tabId);
        break;
      case 'ArrowRight':
        e.preventDefault();
        const nextIndex = (items.findIndex(t => t.id === tabId) + 1) % items.length;
        setActiveTab(items[nextIndex].id);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        const prevIndex = (items.findIndex(t => t.id === tabId) - 1 + items.length) % items.length;
        setActiveTab(items[prevIndex].id);
        break;
      case 'Home':
        e.preventDefault();
        setActiveTab(items[0].id);
        break;
      case 'End':
        e.preventDefault();
        setActiveTab(items[items.length - 1].id);
        break;
    }
  };

  return (
    <div className={`tabs ${className}`}>
      <div 
        role="tablist" 
        className="tab-list"
        aria-label="Навигация по вкладкам"
      >
        {items.map(item => (
          <button
            key={item.id}
            role="tab"
            aria-selected={activeTab === item.id}
            aria-controls={`panel-${item.id}`}
            id={`tab-${item.id}`}
            className={`tab ${activeTab === item.id ? 'active' : ''}`}
            onClick={() => setActiveTab(item.id)}
            onKeyDown={(e) => handleKeyDown(e, item.id)}
            tabIndex={activeTab === item.id ? 0 : -1}
          >
            {item.label}
          </button>
        ))}
      </div>
      
      {items.map(item => (
        <div
          key={item.id}
          role="tabpanel"
          id={`panel-${item.id}`}
          aria-labelledby={`tab-${item.id}`}
          className={`tab-panel ${activeTab === item.id ? 'active' : ''}`}
          hidden={activeTab !== item.id}
        >
          {item.content}
        </div>
      ))}
    </div>
  );
};
```

### Доступный селект

```typescript
// Типы для селекта
interface SelectOption {
  value: string;
  label: string;
}

interface SelectProps {
  options: SelectOption[];
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  label: string;
  className?: string;
}

const Select: React.FC<SelectProps> = ({ 
  options, 
  value, 
  onChange, 
  placeholder, 
  label, 
  className = '' 
}) => {
  const [isOpen, setIsOpen] = React.useState(false);
  const [focusedOptionIndex, setFocusedOptionIndex] = React.useState(-1);
  const selectRef = React.useRef<HTMLDivElement>(null);

  const selectedOption = options.find(option => option.value === value);

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (option: SelectOption) => {
    onChange(option.value);
    setIsOpen(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
        e.preventDefault();
        if (isOpen) {
          if (focusedOptionIndex >= 0) {
            handleSelect(options[focusedOptionIndex]);
          }
        } else {
          setIsOpen(true);
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        if (!isOpen) {
          setIsOpen(true);
        } else {
          setFocusedOptionIndex(prev => 
            prev < options.length - 1 ? prev + 1 : 0
          );
        }
        break;
      case 'ArrowUp':
        e.preventDefault();
        if (!isOpen) {
          setIsOpen(true);
        } else {
          setFocusedOptionIndex(prev => 
            prev > 0 ? prev - 1 : options.length - 1
          );
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setFocusedOptionIndex(-1);
        break;
      case 'Home':
        e.preventDefault();
        setFocusedOptionIndex(0);
        break;
      case 'End':
        e.preventDefault();
        setFocusedOptionIndex(options.length - 1);
        break;
      default:
        break;
    }
  };

  // Закрытие селекта при клике вне его
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (selectRef.current && !selectRef.current.contains(e.target as Node)) {
        setIsOpen(false);
        setFocusedOptionIndex(-1);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className={`select-container ${className}`} ref={selectRef}>
      <label id={`select-label-${label}`}>{label}</label>
      <div
        role="combobox"
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        aria-owns="select-listbox"
        aria-labelledby={`select-label-${label}`}
        className={`select-trigger ${isOpen ? 'open' : ''}`}
        onClick={handleToggle}
        onKeyDown={handleKeyDown}
        tabIndex={0}
      >
        <span className="select-value">
          {selectedOption ? selectedOption.label : placeholder}
        </span>
        <span className="select-arrow" aria-hidden="true">▼</span>
      </div>
      
      {isOpen && (
        <ul
          id="select-listbox"
          role="listbox"
          className="select-listbox"
          aria-labelledby={`select-label-${label}`}
        >
          {options.map((option, index) => (
            <li
              key={option.value}
              role="option"
              aria-selected={value === option.value}
              className={`select-option ${focusedOptionIndex === index ? 'focused' : ''} ${value === option.value ? 'selected' : ''}`}
              onClick={() => handleSelect(option)}
              onMouseEnter={() => setFocusedOptionIndex(index)}
            >
              {option.label}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

## TypeScript-типы для доступных компонентов

```typescript
// Общие типы для доступных компонентов
interface AccessibleComponentProps {
  className?: string;
  id?: string;
}

interface AriaAttributes {
  'aria-label'?: string;
  'aria-labelledby'?: string;
  'aria-describedby'?: string;
  'aria-hidden'?: boolean;
  'aria-expanded'?: boolean;
  'aria-controls'?: string;
  'aria-selected'?: boolean;
  'aria-current'?: boolean | 'page' | 'step' | 'location' | 'date' | 'time';
  'aria-disabled'?: boolean;
  'aria-invalid'?: boolean;
  'aria-required'?: boolean;
  'aria-live'?: 'off' | 'polite' | 'assertive';
  'role'?: string;
}

interface KeyboardNavigationProps {
  onKeyDown?: (e: React.KeyboardEvent) => void;
  onKeyUp?: (e: React.KeyboardEvent) => void;
}

interface FocusManagementProps {
  autoFocus?: boolean;
  tabIndex?: number;
}

type AccessibleProps = AccessibleComponentProps & 
  AriaAttributes & 
  KeyboardNavigationProps & 
  FocusManagementProps;

// Базовый компонент с доступностью
const AccessibleDiv: React.FC<AccessibleProps & { children?: React.ReactNode }> = ({
  children,
  className = '',
  ...ariaProps
}) => {
  return (
    <div className={className} {...ariaProps}>
      {children}
    </div>
  );
};
```

## Проверка доступности компонентов

```typescript
// Утилита для проверки доступности компонентов
class AccessibilityChecker {
  static checkButtonAccessibility(element: HTMLElement): {
    hasProperRole: boolean;
    hasLabel: boolean;
    isKeyboardAccessible: boolean;
    isValid: boolean;
  } {
    const role = element.getAttribute('role');
    const hasAriaLabel = element.hasAttribute('aria-label') || element.hasAttribute('aria-labelledby');
    const hasInnerText = element.textContent && element.textContent.trim().length > 0;
    const hasTitle = element.hasAttribute('title');
    const tabIndex = element.getAttribute('tabindex');
    
    const hasProperRole = role === 'button' || element.tagName === 'BUTTON';
    const hasLabel = hasAriaLabel || hasInnerText || hasTitle;
    const isKeyboardAccessible = element.tagName === 'BUTTON' || 
                                element.tagName === 'INPUT' || 
                                tabIndex === '0' || 
                                tabIndex === '-1';
    
    return {
      hasProperRole,
      hasLabel,
      isKeyboardAccessible,
      isValid: hasProperRole && hasLabel && isKeyboardAccessible
    };
  }
  
  static checkFormAccessibility(form: HTMLFormElement): {
    hasLabels: boolean;
    hasProperStructure: boolean;
    hasAccessibleControls: boolean;
    isValid: boolean;
  } {
    const inputs = Array.from(form.querySelectorAll('input, select, textarea'));
    const labels = Array.from(form.querySelectorAll('label'));
    
    const hasLabels = inputs.every(input => {
      const id = input.getAttribute('id');
      if (!id) return false;
      
      return labels.some(label => label.getAttribute('for') === id);
    });
    
    const hasProperStructure = form.querySelector('fieldset') !== null || 
                              form.querySelector('legend') !== null;
    
    const hasAccessibleControls = inputs.every(input => {
      const ariaLabel = input.hasAttribute('aria-label');
      const ariaLabelledBy = input.hasAttribute('aria-labelledby');
      const placeholder = input.hasAttribute('placeholder');
      const title = input.hasAttribute('title');
      
      return ariaLabel || ariaLabelledBy || placeholder || title;
    });
    
    return {
      hasLabels,
      hasProperStructure,
      hasAccessibleControls,
      isValid: hasLabels && hasAccessibleControls
    };
  }
}
```

## Практические рекомендации

1. **Всегда обеспечивайте клавиатурную навигацию** для интерактивных элементов
2. **Используйте семантически правильные HTML-элементы** по возможности
3. **Добавляйте ARIA-атрибуты** только когда семантических элементов недостаточно
4. **Тестируйте компоненты с помощью вспомогательных технологий**
5. **Управляйте фокусом** при изменении состояния компонента

## Связанные темы

- [[WCAG-стандарты]]
- [[ARIA-атрибуты]]
- [[Семантический-HTML]]
- [[Тестирование-доступности]]
- [[React с TypeScript]]

## Внешние ресурсы

- [A11Y Project - Руководство по доступным компонентам](https://www.a11yproject.com/)
- [Inclusive Components](https://inclusive-components.design/)
- [Практическое руководство по ARIA](https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/)
