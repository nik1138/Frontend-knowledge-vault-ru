---
aliases: ["Тестирование на доступность", "Проверка доступности", "Валидация доступности"]
tags: ["#web-accessibility", "#testing", "#a11y", "#typescript"]
---

# Тестирование доступности

## Обзор

Тестирование доступности - это процесс проверки того, насколько веб-контент и приложения доступны для людей с ограниченными возможностями. Это включает в себя как автоматизированные, так и ручные методы тестирования, а также использование вспомогательных технологий. При разработке с использованием TypeScript важно интегрировать тестирование доступности в процесс разработки.

## Типы тестирования доступности

### 1. Автоматизированное тестирование

```typescript
// Пример: Утилита для автоматизированной проверки доступности
interface AccessibilityRule {
  id: string;
  description: string;
  category: 'html' | 'css' | 'javascript' | 'content';
  level: 'A' | 'AA' | 'AAA';
  test: (element: HTMLElement) => boolean;
}

interface AccessibilityResult {
  ruleId: string;
  element: HTMLElement;
  message: string;
  severity: 'error' | 'warning' | 'notice';
}

class AccessibilityScanner {
  private rules: AccessibilityRule[] = [
    {
      id: 'image-alt',
      description: 'Все изображения должны иметь атрибут alt',
      category: 'html',
      level: 'A',
      test: (element) => {
        if (element.tagName === 'IMG') {
          return element.hasAttribute('alt');
        }
        return true;
      }
    },
    {
      id: 'heading-hierarchy',
      description: 'Заголовки должны следовать правильной иерархии',
      category: 'html',
      level: 'A',
      test: (element) => {
        // Проверка иерархии заголовков будет выполнена отдельно
        return true;
      }
    },
    {
      id: 'color-contrast',
      description: 'Цветовой контраст должен соответствовать требованиям WCAG',
      category: 'css',
      level: 'AA',
      test: (element) => {
        const bgColor = this.getBackgroundColor(element);
        const textColor = this.getTextColor(element);
        const contrast = this.calculateContrastRatio(bgColor, textColor);
        return contrast >= 4.5; // Для нормального текста
      }
    }
  ];

  private getBackgroundColor(element: HTMLElement): string {
    let bgColor = window.getComputedStyle(element).backgroundColor;
    while (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent') {
      element = element.parentElement as HTMLElement;
      if (!element) break;
      bgColor = window.getComputedStyle(element).backgroundColor;
    }
    return bgColor;
  }

  private getTextColor(element: HTMLElement): string {
    return window.getComputedStyle(element).color;
  }

  private calculateContrastRatio(color1: string, color2: string): number {
    // Конвертация цветов в RGB
    const rgb1 = this.hexToRgb(this.colorToHex(color1)) || { r: 0, g: 0, b: 0 };
    const rgb2 = this.hexToRgb(this.colorToHex(color2)) || { r: 0, g: 0, b: 0 };
    
    // Расчет относительной яркости
    const l1 = this.relativeLuminance(rgb1);
    const l2 = this.relativeLuminance(rgb2);
    
    // Расчет коэффициента контрастности
    return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
  }

  private colorToHex(color: string): string {
    // Конвертация rgba/named colors в hex
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
    ctx.fillStyle = color;
    return ctx.fillStyle;
  }

  private hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  private relativeLuminance(color: { r: number; g: number; b: number }): number {
    const rsrgb = color.r / 255;
    const gsrgb = color.g / 255;
    const bsrgb = color.b / 255;

    const r = rsrgb <= 0.03928 ? rsrgb / 12.92 : Math.pow((rsrgb + 0.055) / 1.055, 2.4);
    const g = gsrgb <= 0.03928 ? gsrgb / 12.92 : Math.pow((gsrgb + 0.055) / 1.055, 2.4);
    const b = bsrgb <= 0.03928 ? bsrgb / 12.92 : Math.pow((bsrgb + 0.055) / 1.055, 2.4);

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  scan(element: HTMLElement): AccessibilityResult[] {
    const results: AccessibilityResult[] = [];
    const allElements = [element, ...Array.from(element.querySelectorAll('*'))];

    for (const el of allElements) {
      for (const rule of this.rules) {
        try {
          if (!rule.test(el)) {
            results.push({
              ruleId: rule.id,
              element: el,
              message: rule.description,
              severity: 'error'
            });
          }
        } catch (e) {
          results.push({
            ruleId: rule.id,
            element: el,
            message: `Ошибка при проверке правила: ${e.message}`,
            severity: 'error'
          });
        }
      }
    }

    return results;
  }
}
```

### 2. Ручное тестирование

```typescript
// Пример: Утилита для ручного тестирования доступности
interface ManualTest {
  id: string;
  title: string;
  description: string;
  category: 'navigation' | 'screen-reader' | 'keyboard' | 'visual' | 'forms';
  instructions: string[];
  expectedResult: string;
}

class ManualAccessibilityTester {
  static tests: ManualTest[] = [
    {
      id: 'keyboard-navigation',
      title: 'Навигация с клавиатуры',
      description: 'Проверка возможности навигации по всем интерактивным элементам с помощью клавиатуры',
      category: 'keyboard',
      instructions: [
        'Используйте клавишу Tab для навигации по странице',
        'Проверьте, что все интерактивные элементы получают фокус',
        'Убедитесь, что порядок фокуса логичен',
        'Проверьте работу клавиш Enter и Space для активации элементов',
        'Проверьте специальные клавиши для сложных компонентов (стрелки для меню и т.д.)'
      ],
      expectedResult: 'Все интерактивные элементы доступны с клавиатуры и имеют видимый индикатор фокуса'
    },
    {
      id: 'screen-reader',
      title: 'Совместимость со скринридерами',
      description: 'Проверка корректного воспроизведения контента скринридерами',
      category: 'screen-reader',
      instructions: [
        'Запустите скринридер (например, NVDA или JAWS)',
        'Перейдите к каждому элементу интерфейса',
        'Проверьте, что содержимое читается корректно',
        'Убедитесь, что названия, роли и состояния элементов передаются правильно',
        'Проверьте динамически изменяющийся контент'
      ],
      expectedResult: 'Весь контент читается скринридером корректно, включая названия, роли и состояния элементов'
    },
    {
      id: 'focus-indicator',
      title: 'Видимый индикатор фокуса',
      description: 'Проверка наличия видимого индикатора фокуса для всех элементов',
      category: 'navigation',
      instructions: [
        'Перейдите по всем интерактивным элементам с помощью клавиатуры',
        'Проверьте, что индикатор фокуса виден и отличается от обычного состояния',
        'Убедитесь, что индикатор не скрывается стилями'
      ],
      expectedResult: 'У всех элементов управления есть четко видимый индикатор фокуса'
    }
  ];

  static runTest(testId: string, element?: HTMLElement): boolean {
    const test = this.tests.find(t => t.id === testId);
    if (!test) {
      throw new Error(`Тест с ID ${testId} не найден`);
    }

    // В реальной реализации здесь будет логика выполнения теста
    console.log(`Выполнение теста: ${test.title}`);
    console.log(`Инструкции:`, test.instructions);
    
    // Для примера возвращаем true, в реальной системе это будет результат выполнения теста
    return true;
  }
}
```

## Тестирование с использованием TypeScript

```typescript
// Типы для тестирования доступности
interface AccessibilityTestResult {
  id: string;
  name: string;
  passed: boolean;
  message?: string;
  elements?: HTMLElement[];
  details?: Record<string, any>;
}

interface AccessibilityTest {
  id: string;
  name: string;
  description: string;
  run: (element: HTMLElement) => AccessibilityTestResult;
}

// Базовый класс для тестов доступности
abstract class AccessibilityTestBase implements AccessibilityTest {
  abstract id: string;
  abstract name: string;
  abstract description: string;
  
  abstract run(element: HTMLElement): AccessibilityTestResult;
  
  protected createResult(
    passed: boolean, 
    message?: string, 
    elements?: HTMLElement[],
    details?: Record<string, any>
  ): AccessibilityTestResult {
    return {
      id: this.id,
      name: this.name,
      passed,
      message,
      elements,
      details
    };
  }
}

// Пример конкретного теста
class ImageAltTest extends AccessibilityTestBase {
  id = 'image-alt-test';
  name = 'Проверка атрибута alt у изображений';
  description = 'Проверяет, что все изображения имеют атрибут alt';

  run(element: HTMLElement): AccessibilityTestResult {
    const images = element.querySelectorAll('img');
    const missingAlt: HTMLElement[] = [];
    
    images.forEach(img => {
      if (!img.hasAttribute('alt')) {
        missingAlt.push(img);
      }
    });
    
    if (missingAlt.length === 0) {
      return this.createResult(true, 'Все изображения имеют атрибут alt');
    } else {
      return this.createResult(
        false, 
        `Найдено ${missingAlt.length} изображений без атрибута alt`,
        missingAlt
      );
    }
  }
}

// Менеджер тестов
class AccessibilityTestManager {
  private tests: AccessibilityTest[] = [];
  
  addTest(test: AccessibilityTest): void {
    this.tests.push(test);
  }
  
  runAll(element: HTMLElement): AccessibilityTestResult[] {
    return this.tests.map(test => test.run(element));
  }
  
  runSpecific(element: HTMLElement, testIds: string[]): AccessibilityTestResult[] {
    const specificTests = this.tests.filter(test => testIds.includes(test.id));
    return specificTests.map(test => test.run(element));
  }
}
```

## Интеграция с Jest для автоматизированного тестирования

```typescript
// Пример тестов доступности с использованием Jest
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';

// Утилита для проверки доступности
const checkAccessibility = (container: HTMLElement): { errors: string[]; warnings: string[] } => {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Проверка наличия alt у изображений
  const images = container.querySelectorAll('img');
  images.forEach((img, index) => {
    if (!img.hasAttribute('alt')) {
      errors.push(`Изображение ${index} не имеет атрибута alt`);
    }
  });
  
  // Проверка наличия label у полей ввода
  const inputs = container.querySelectorAll('input, textarea, select');
  inputs.forEach((input, index) => {
    const id = input.getAttribute('id');
    if (id) {
      const label = container.querySelector(`label[for="${id}"]`);
      if (!label) {
        warnings.push(`Поле ввода ${index} (id: ${id}) не имеет связанного label`);
      }
    }
  });
  
  return { errors, warnings };
};

// Тестирование компонента на доступность
describe('Доступность компонента формы', () => {
  it('должен иметь все необходимые атрибуты доступности', () => {
    const { container } = render(
      <form>
        <label htmlFor="username">Имя пользователя</label>
        <input id="username" type="text" />
        
        <label htmlFor="email">Email</label>
        <input id="email" type="email" />
        
        <button type="submit">Отправить</button>
      </form>
    );
    
    const { errors, warnings } = checkAccessibility(container);
    
    expect(errors).toHaveLength(0);
    expect(warnings).toHaveLength(0);
  });
  
  it('должен быть доступен с клавиатуры', () => {
    const { container } = render(
      <div>
        <button>Кнопка 1</button>
        <button>Кнопка 2</button>
        <input type="text" />
      </div>
    );
    
    const buttons = container.querySelectorAll('button');
    const input = container.querySelector('input');
    
    // Проверяем, что элементы получают фокус
    fireEvent.focus(buttons[0]);
    expect(buttons[0]).toHaveFocus();
    
    fireEvent.focus(buttons[1]);
    expect(buttons[1]).toHaveFocus();
    
    fireEvent.focus(input as Element);
    expect(input).toHaveFocus();
  });
});

// Тестирование компонента с ARIA-атрибутами
describe('Доступность компонента с ARIA', () => {
  it('должен правильно использовать ARIA-атрибуты', () => {
    const { container } = render(
      <div role="dialog" aria-modal="true" aria-labelledby="dialog-title">
        <h2 id="dialog-title">Заголовок диалога</h2>
        <p>Содержимое диалога</p>
        <button aria-label="Закрыть">×</button>
      </div>
    );
    
    const dialog = screen.getByRole('dialog');
    expect(dialog).toHaveAttribute('aria-modal', 'true');
    expect(dialog).toHaveAttribute('aria-labelledby', 'dialog-title');
    
    const title = screen.getByText('Заголовок диалога');
    expect(title).toHaveAttribute('id', 'dialog-title');
  });
});
```

## Инструменты для тестирования доступности

### axe-core интеграция

```typescript
// Пример интеграции axe-core с TypeScript
import axe, { AxeResults, ElementContext } from 'axe-core';

interface AxeTestOptions {
  runOptions?: axe.RunOptions;
  config?: axe.Spec;
}

class AxeAccessibilityTester {
  static async run(
    context: ElementContext = 'html', 
    options: AxeTestOptions = {}
  ): Promise<AxeResults> {
    return new Promise((resolve, reject) => {
      axe.run(context, options, (err, results) => {
        if (err) {
          reject(err);
        } else {
          resolve(results);
        }
      });
    });
  }
  
  static async runPartial(
    context: ElementContext = 'html',
    options: AxeTestOptions = {}
  ): Promise<axe.AxeResultsPartial> {
    return axe.runPartial(context, options);
  }
  
  static async finishRun(results: axe.AxeResultsPartial): Promise<AxeResults> {
    return axe.finishRun(results);
  }
  
  static async analyzeAccessibility(
    element: HTMLElement
  ): Promise<{
    violations: axe.Result[];
    passes: axe.Result[];
    incomplete: axe.Result[];
  }> {
    const results = await this.run(element);
    
    return {
      violations: results.violations,
      passes: results.passes,
      incomplete: results.incomplete
    };
  }
}

// Использование в компонентных тестах
describe('Компонент с axe-core', () => {
  it('не должен иметь нарушений доступности', async () => {
    const { container } = render(<MyAccessibleComponent />);
    
    const { violations } = await AxeAccessibilityTester.analyzeAccessibility(container);
    
    if (violations.length > 0) {
      console.error('Найдены нарушения доступности:', violations);
    }
    
    expect(violations).toHaveLength(0);
  });
});
```

### Puppeteer для тестирования с вспомогательными технологиями

```typescript
// Пример использования Puppeteer для тестирования доступности
import puppeteer, { Browser, Page } from 'puppeteer';

interface AccessibilityAuditConfig {
  pageUrl: string;
  axeCorePath?: string;
  additionalRules?: any[];
}

class BrowserAccessibilityTester {
  private browser: Browser | null = null;
  
  async initialize(): Promise<void> {
    this.browser = await puppeteer.launch({ headless: true });
  }
  
  async auditPage(config: AccessibilityAuditConfig): Promise<axe.AxeResults> {
    if (!this.browser) {
      throw new Error('Browser not initialized. Call initialize() first.');
    }
    
    const page = await this.browser.newPage();
    await page.goto(config.pageUrl);
    
    // Загрузка axe-core
    if (config.axeCorePath) {
      await page.addScriptTag({ path: config.axeCorePath });
    } else {
      await page.addScriptTag({
        content: `(${axe.source})()`
      });
    }
    
    // Выполнение проверки доступности
    const results = await page.evaluate(() => {
      return new Promise((resolve) => {
        (window as any).axe.run((err: Error, results: axe.AxeResults) => {
          if (err) {
            console.error('Ошибка при выполнении axe:', err);
            resolve({
              violations: [],
              passes: [],
              incomplete: [],
              url: '',
              timestamp: new Date().toISOString(),
              userAgent: '',
              toolOptions: {},
              violations: []
            });
          } else {
            resolve(results);
          }
        });
      });
    });
    
    await page.close();
    return results;
  }
  
  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
    }
  }
}
```

## Практические рекомендации

### 1. Создание пользовательских хуков для доступности

```typescript
// Пользовательский хук для проверки фокуса
function useFocusManagement(ref: React.RefObject<HTMLElement>, isOpen: boolean) {
  React.useEffect(() => {
    if (isOpen && ref.current) {
      // Сохраняем текущий элемент фокуса
      const previousActiveElement = document.activeElement as HTMLElement;
      
      // Устанавливаем фокус на первый фокусируемый элемент
      const focusableElements = ref.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length > 0) {
        (focusableElements[0] as HTMLElement).focus();
      } else {
        ref.current.focus();
      }
      
      // Восстанавливаем фокус при закрытии
      return () => {
        previousActiveElement?.focus();
      };
    }
  }, [isOpen]);
}

// Пользовательский хук для проверки контрастности
function useColorContrast(foregroundColor: string, backgroundColor: string) {
  const [isValid, setIsValid] = React.useState(true);
  
  React.useEffect(() => {
    const ratio = calculateContrastRatio(foregroundColor, backgroundColor);
    setIsValid(ratio >= 4.5); // AA уровень
  }, [foregroundColor, backgroundColor]);
  
  return isValid;
}

// Вспомогательная функция для расчета контрастности
function calculateContrastRatio(color1: string, color2: string): number {
  const luminance1 = getRelativeLuminance(hexToRgb(color1));
  const luminance2 = getRelativeLuminance(hexToRgb(color2));
  
  const lighter = Math.max(luminance1, luminance2);
  const darker = Math.min(luminance1, luminance2);
  
  return (lighter + 0.05) / (darker + 0.05);
}

function getRelativeLuminance(rgb: { r: number; g: number; b: number }): number {
  const [r, g, b] = [rgb.r, rgb.g, rgb.b].map(c => {
    const s = c / 255;
    return s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

function hexToRgb(hex: string): { r: number; g: number; b: number } {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : { r: 0, g: 0, b: 0 };
}
```

### 2. Создание системы отчетности

```typescript
// Интерфейсы для отчетов о доступности
interface AccessibilityReport {
  id: string;
  timestamp: string;
  url: string;
  results: AccessibilityTestResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    errors: number;
    warnings: number;
  };
}

interface AccessibilityReporter {
  generateReport(results: AccessibilityTestResult[], url: string): AccessibilityReport;
  exportReport(report: AccessibilityReport, format: 'json' | 'html' | 'csv'): string;
  saveReport(report: AccessibilityReport, path: string): Promise<void>;
}

class DefaultAccessibilityReporter implements AccessibilityReporter {
  generateReport(results: AccessibilityTestResult[], url: string): AccessibilityReport {
    const passed = results.filter(r => r.passed).length;
    const failed = results.filter(r => !r.passed).length;
    
    return {
      id: `a11y-report-${Date.now()}`,
      timestamp: new Date().toISOString(),
      url,
      results,
      summary: {
        total: results.length,
        passed,
        failed,
        errors: results.filter(r => r.message?.includes('error')).length,
        warnings: results.filter(r => r.message?.includes('warning')).length
      }
    };
  }
  
  exportReport(report: AccessibilityReport, format: 'json' | 'html' | 'csv'): string {
    switch (format) {
      case 'json':
        return JSON.stringify(report, null, 2);
      case 'html':
        return this.generateHtmlReport(report);
      case 'csv':
        return this.generateCsvReport(report);
      default:
        throw new Error(`Формат ${format} не поддерживается`);
    }
  }
  
  private generateHtmlReport(report: AccessibilityReport): string {
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Отчет о доступности - ${report.url}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .summary { background: #f5f5f5; padding: 15px; margin: 10px 0; }
            .result { margin: 10px 0; padding: 10px; border-left: 4px solid; }
            .passed { border-color: #4caf50; background: #e8f5e8; }
            .failed { border-color: #f44336; background: #ffebee; }
          </style>
        </head>
        <body>
          <h1>Отчет о доступности</h1>
          <div class="summary">
            <h2>Сводка</h2>
            <p>URL: ${report.url}</p>
            <p>Дата: ${new Date(report.timestamp).toLocaleString()}</p>
            <p>Всего тестов: ${report.summary.total}</p>
            <p>Пройдено: ${report.summary.passed}</p>
            <p>Провалено: ${report.summary.failed}</p>
          </div>
          <h2>Результаты тестов</h2>
          ${report.results.map(result => `
            <div class="result ${result.passed ? 'passed' : 'failed'}">
              <h3>${result.name}</h3>
              <p>ID: ${result.id}</p>
              <p>Статус: ${result.passed ? 'Пройден' : 'Провален'}</p>
              ${result.message ? `<p>Сообщение: ${result.message}</p>` : ''}
            </div>
          `).join('')}
        </body>
      </html>
    `;
  }
  
  private generateCsvReport(report: AccessibilityReport): string {
    const headers = ['ID', 'Name', 'Passed', 'Message'];
    const rows = report.results.map(result => [
      result.id,
      `"${result.name}"`,
      result.passed,
      result.message ? `"${result.message}"` : ''
    ]);
    
    return [headers, ...rows]
      .map(row => row.join(','))
      .join('\n');
  }
  
  async saveReport(report: AccessibilityReport, path: string): Promise<void> {
    // В Node.js среде можно использовать fs
    // import fs from 'fs';
    // await fs.promises.writeFile(path, JSON.stringify(report, null, 2));
    console.log(`Отчет сохранен в ${path}`);
  }
}
```

## Распространенные ошибки и как их избежать

1. **Игнорирование автоматизированных тестов** - всегда включайте проверки доступности в CI/CD
2. **Недостаточное ручное тестирование** - сочетайте автоматизированные и ручные методы
3. **Отсутствие тестирования с вспомогательными технологиями** - регулярно тестируйте с использованием скринридеров

## Связанные темы

- [[WCAG-стандарты]]
- [[ARIA-атрибуты]]
- [[Семантический-HTML]]
- [[Доступные-компоненты]]
- [[Тестирование в TypeScript]]

## Внешние ресурсы

- [axe-core документация](https://github.com/dequelabs/axe-core)
- [WebAIM инструменты для проверки доступности](https://webaim.org/resources/)
- [MDN руководство по тестированию доступности](https://developer.mozilla.org/ru/docs/Web/Accessibility/Testing)
- [Практическое руководство по тестированию доступности](https://www.w3.org/WAI/test-evaluate/)
