---
aliases: [Обучение в браузере, Browser Training, ML Training in Browser]
tags: [typescript, machine-learning, browser-ml, tensorflowjs, training, neural-networks, online-learning]
---

# Обучение моделей машинного обучения в браузере

## Введение

Обучение моделей машинного обучения непосредственно в браузере открывает возможности для адаптивных приложений, которые могут обучаться на данных пользователя без передачи этих данных на сервер. TypeScript обеспечивает строгую типизацию, что особенно важно при разработке сложных процессов обучения.

## Возможности обучения в браузере

### Преимущества
- **Конфиденциальность данных**: обучение происходит локально на устройстве пользователя
- **Адаптивность**: модели могут адаптироваться к предпочтениям конкретного пользователя
- **Отсутствие серверной инфраструктуры**: обучение происходит на стороне клиента
- **Реальное время**: возможность обучения в реальном времени по мере получения новых данных

### Ограничения
- **Ограниченные вычислительные ресурсы**: производительность зависит от устройства пользователя
- **Ограниченная память**: необходимо учитывать ограничения браузера
- **Время обучения**: сложные модели могут обучаться медленно

## Подготовка данных для обучения

### Создание тензоров из данных

```typescript
import * as tf from '@tensorflow/tfjs';

// Преобразование данных в тензоры
function createTensorsFromData(
  features: number[][], 
  labels: number[][]
): { xs: tf.Tensor2D, ys: tf.Tensor2D } {
  const xs = tf.tensor2d(features, [features.length, features[0].length]);
  const ys = tf.tensor2d(labels, [labels.length, labels[0].length]);
  
  return { xs, ys };
}

// Нормализация данных
function normalizeTensor(tensor: tf.Tensor2D): tf.Tensor2D {
  const mean = tensor.mean(0);
  const std = tensor.sub(mean).pow(2).mean(0).sqrt();
  
  // Избегаем деления на ноль
  const stdClipped = std.clipByValue(1e-7, Infinity);
  
  return tensor.sub(mean).div(stdClipped);
}
```

### Аугментация данных

```typescript
// Класс для аугментации изображений
class ImageAugmenter {
  private probability: number;
  
  constructor(probability: number = 0.5) {
    this.probability = probability;
  }
  
  // Изменение яркости
  adjustBrightness(image: tf.Tensor4D, factor: number): tf.Tensor4D {
    return tf.tidy(() => {
      return image.mul(factor);
    });
  }
  
  // Изменение контраста
  adjustContrast(image: tf.Tensor4D, factor: number): tf.Tensor4D {
    return tf.tidy(() => {
      const mean = image.mean([1, 2], true);
      return image.sub(mean).mul(factor).add(mean);
    });
  }
  
  // Случайный поворот
  randomRotation(image: tf.Tensor4D, maxAngle: number): tf.Tensor4D {
    const angle = (Math.random() * 2 - 1) * maxAngle * Math.PI / 180;
    return tf.image.rotateWithOffset(image, angle, 0, [0.5, 0.5]);
  }
  
  // Случайное отражение
  randomFlipLeftRight(image: tf.Tensor4D): tf.Tensor4D {
    if (Math.random() < this.probability) {
      return tf.image.flipLeftRight(image);
    }
    return image;
  }
  
  // Комплексная аугментация
  augment(image: tf.Tensor4D): tf.Tensor4D {
    return tf.tidy(() => {
      let augmented = image;
      
      if (Math.random() < this.probability) {
        augmented = this.adjustBrightness(augmented, 0.8 + Math.random() * 0.4);
      }
      
      if (Math.random() < this.probability) {
        augmented = this.adjustContrast(augmented, 0.8 + Math.random() * 0.4);
      }
      
      if (Math.random() < this.probability) {
        augmented = this.randomRotation(augmented, 15);
      }
      
      augmented = this.randomFlipLeftRight(augmented);
      
      return augmented.clipByValue(0, 1);
    });
  }
}
```

## Создание моделей для обучения

### Простая модель для обучения

```typescript
// Создание простой модели для обучения
function createSimpleModel(inputShape: [number, number, number]): tf.Sequential {
  const model = tf.sequential();
  
  // Сверточный слой
  model.add(tf.layers.conv2d({
    inputShape,
    filters: 32,
    kernelSize: 3,
    activation: 'relu'
  }));
  
  // Слой подвыборки
  model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
  
  // Еще один сверточный слой
  model.add(tf.layers.conv2d({
    filters: 64,
    kernelSize: 3,
    activation: 'relu'
  }));
  
  // Еще один слой подвыборки
  model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
  
  // Плоский слой
  model.add(tf.layers.flatten());
  
  // Полносвязный слой
  model.add(tf.layers.dense({
    units: 64,
    activation: 'relu'
  }));
  
  // Выходной слой
  model.add(tf.layers.dense({
    units: 10, // для задачи классификации на 10 классов
    activation: 'softmax'
  }));
  
  return model;
}
```

### Компиляция модели

```typescript
// Типизированный интерфейс для конфигурации модели
interface ModelConfig {
  optimizer: 'sgd' | 'adam' | 'adagrad' | string;
  learningRate?: number;
  loss: 'categoricalCrossentropy' | 'meanSquaredError' | 'binaryCrossentropy' | string;
  metrics: string[];
}

// Компиляция модели с типизацией
function compileModel(model: tf.Sequential, config: ModelConfig): void {
  let optimizer: tf.Optimizer;
  
  switch (config.optimizer) {
    case 'adam':
      optimizer = config.learningRate 
        ? tf.train.adam(config.learningRate) 
        : tf.train.adam();
      break;
    case 'sgd':
      optimizer = config.learningRate 
        ? tf.train.sgd(config.learningRate) 
        : tf.train.sgd();
      break;
    case 'adagrad':
      optimizer = config.learningRate 
        ? tf.train.adagrad(config.learningRate) 
        : tf.train.adagrad();
      break;
    default:
      optimizer = tf.train.adam(); // по умолчанию
  }
  
  model.compile({
    optimizer,
    loss: config.loss,
    metrics: config.metrics
  });
}
```

## Процесс обучения

### Обучение с колбэками

```typescript
// Интерфейс для результатов обучения
interface TrainingResult {
  history: tf.History;
  finalLoss: number;
  finalAccuracy?: number;
}

// Типизированный класс для обучения модели
class ModelTrainer {
  private model: tf.Sequential;
  private history: tf.History | null;
  
  constructor(model: tf.Sequential) {
    this.model = model;
    this.history = null;
  }
  
  async train(
    xs: tf.Tensor,
    ys: tf.Tensor,
    epochs: number,
    batchSize: number = 32,
    validationSplit: number = 0.1
  ): Promise<TrainingResult> {
    return new Promise((resolve, reject) => {
      const callbacks: tf.CustomCallbackArgs = {
        onEpochEnd: async (epoch, logs) => {
          console.log(`Эпоха ${epoch}: потеря = ${logs?.loss?.toFixed(4)}, точность = ${logs?.acc?.toFixed(4)}`);
          
          // Возможность остановки обучения
          if (logs && logs.loss < 0.01) {
            console.log('Обучение остановлено: потеря достигла порога');
            this.model.stopTraining = true;
          }
        },
        onTrainEnd: async () => {
          console.log('Обучение завершено');
        }
      };
      
      this.model.fit(xs, ys, {
        epochs,
        batchSize,
        validationSplit,
        callbacks
      }).then(history => {
        this.history = history;
        
        const result: TrainingResult = {
          history,
          finalLoss: history.history.loss[history.history.loss.length - 1] as number,
        };
        
        if (history.history.acc) {
          result.finalAccuracy = history.history.acc[history.history.acc.length - 1] as number;
        }
        
        resolve(result);
      }).catch(error => {
        reject(error);
      });
    });
  }
  
  // Онлайн-обучение (обучение на новых данных)
  async trainOnBatch(xs: tf.Tensor, ys: tf.Tensor): Promise<number[]> {
    const result = this.model.trainOnBatch(xs, ys) as tf.Scalar[];
    const lossValues = await Promise.all(result.map(s => s.data()));
    return lossValues.map(arr => arr[0]);
  }
}
```

### Ранняя остановка

```typescript
// Класс для реализации ранней остановки
class EarlyStopping {
  private patience: number;
  private minDelta: number;
  private bestValue: number | null;
  private wait: number;
  private stoppedEpoch: number;
  
  constructor(patience: number = 5, minDelta: number = 0) {
    this.patience = patience;
    this.minDelta = minDelta;
    this.bestValue = null;
    this.wait = 0;
    this.stoppedEpoch = 0;
  }
  
  check(loss: number, epoch: number, model: tf.Sequential): boolean {
    const improved = this.bestValue === null || 
                    (loss + this.minDelta < this.bestValue);
    
    if (improved) {
      this.bestValue = loss;
      this.wait = 0;
    } else {
      this.wait++;
    }
    
    if (this.wait >= this.patience) {
      this.stoppedEpoch = epoch;
      model.stopTraining = true;
      console.log(`Ранняя остановка на эпохе ${epoch}`);
      return true; // обучение остановлено
    }
    
    return false; // обучение продолжается
  }
}
```

## Сохранение и загрузка моделей

### Сохранение модели

```typescript
// Интерфейс для информации о модели
interface ModelInfo {
  name: string;
  description: string;
  createdAt: Date;
  trainingParams: {
    epochs: number;
    batchSize: number;
    optimizer: string;
    loss: string;
  };
}

// Класс для управления моделью
class ManagedModel {
  private model: tf.Sequential;
  private info: ModelInfo;
  
  constructor(model: tf.Sequential, info: ModelInfo) {
    this.model = model;
    this.info = info;
  }
  
  // Сохранение модели с метаданными
  async save(modelPath: string): Promise<void> {
    // Сохранение модели
    await this.model.save(modelPath);
    
    // Сохранение метаданных
    const metadata = {
      ...this.info,
      createdAt: this.info.createdAt.toISOString()
    };
    
    const metadataStr = JSON.stringify(metadata, null, 2);
    const metadataBlob = new Blob([metadataStr], { type: 'application/json' });
    
    // В зависимости от типа сохранения, сохраняем метаданные
    if (modelPath.startsWith('downloads://')) {
      // Для скачивания создаем ссылку
      const url = URL.createObjectURL(metadataBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'model-metadata.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } else if (modelPath.startsWith('localstorage://')) {
      // Сохраняем в localStorage
      localStorage.setItem(`${modelPath}-metadata`, metadataStr);
    }
  }
  
  // Загрузка модели с метаданными
  static async load(modelPath: string): Promise<ManagedModel> {
    const model = await tf.loadLayersModel(modelPath);
    
    // Загрузка метаданных
    let metadata: ModelInfo | null = null;
    
    if (modelPath.startsWith('localstorage://')) {
      const metadataStr = localStorage.getItem(`${modelPath}-metadata`);
      if (metadataStr) {
        const parsed = JSON.parse(metadataStr);
        parsed.createdAt = new Date(parsed.createdAt);
        metadata = parsed as ModelInfo;
      }
    }
    
    if (!metadata) {
      // Создаем базовые метаданные, если не найдены
      metadata = {
        name: 'Загруженная модель',
        description: 'Модель, загруженная из браузера',
        createdAt: new Date(),
        trainingParams: {
          epochs: 0,
          batchSize: 32,
          optimizer: 'unknown',
          loss: 'unknown'
        }
      };
    }
    
    return new ManagedModel(model as tf.Sequential, metadata);
  }
  
  getModel(): tf.Sequential {
    return this.model;
  }
  
  getInfo(): ModelInfo {
    return this.info;
  }
}
```

## Практические примеры

### Пример: Персонализированная рекомендательная система

```typescript
// Класс для персонализированного обучения
class PersonalizedTrainer {
  private model: tf.Sequential;
  private userId: string;
  private userPreferences: UserPreferences;
  
  constructor(userId: string) {
    this.userId = userId;
    this.userPreferences = this.loadUserPreferences();
    this.model = this.createRecommendationModel();
  }
  
  private createRecommendationModel(): tf.Sequential {
    const model = tf.sequential();
    
    // Входной слой для признаков пользователя
    model.add(tf.layers.dense({
      inputShape: [20], // например, 20 признаков пользователя
      units: 128,
      activation: 'relu'
    }));
    
    // Скрытые слои
    model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
    model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
    
    // Выходной слой для оценки релевантности 100 элементов
    model.add(tf.layers.dense({ units: 100, activation: 'sigmoid' }));
    
    model.compile({
      optimizer: tf.train.adam(0.001),
      loss: 'binaryCrossentropy',
      metrics: ['accuracy']
    });
    
    return model;
  }
  
  // Обучение на действиях пользователя
  async learnFromInteraction(itemFeatures: number[], liked: boolean): Promise<void> {
    // Подготовка данных
    const userFeatures = this.getUserFeatures();
    const input = [...userFeatures, ...itemFeatures];
    
    // Создание метки (1 для понравившегося, 0 для непонравившегося)
    const label = liked ? 1 : 0;
    
    // Обучение на одном примере
    const xs = tf.tensor2d([input], [1, input.length]);
    const ys = tf.tensor2d([[label]], [1, 1]);
    
    await this.model.trainOnBatch(xs, ys);
    
    // Освобождение памяти
    xs.dispose();
    ys.dispose();
    
    // Сохранение обновленной модели
    await this.saveModel();
  }
  
  private getUserFeatures(): number[] {
    // Возвращает вектор признаков пользователя
    // В реальном приложении это будет более сложной логикой
    return Array(20).fill(0.5); // заглушка
  }
  
  private loadUserPreferences(): UserPreferences {
    // Загрузка предпочтений пользователя из localStorage
    const prefsStr = localStorage.getItem(`user-prefs-${this.userId}`);
    if (prefsStr) {
      return JSON.parse(prefsStr);
    }
    
    // Возвращаем значения по умолчанию
    return {
      categories: [],
      preferredTimeOfDay: 'any',
      interactionHistory: []
    };
  }
  
  private async saveModel(): Promise<void> {
    // Сохранение модели для конкретного пользователя
    await this.model.save(`localstorage://user-model-${this.userId}`);
  }
  
  // Получение рекомендаций
  async getRecommendations(itemFeaturesList: number[][]): Promise<Recommendation[]> {
    const userFeatures = this.getUserFeatures();
    const inputs = itemFeaturesList.map(features => [...userFeatures, ...features]);
    
    const xs = tf.tensor2d(inputs, [inputs.length, inputs[0].length]);
    const predictions = this.model.predict(xs) as tf.Tensor;
    const probabilities = await predictions.data();
    
    // Преобразование в список рекомендаций
    const recommendations: Recommendation[] = itemFeaturesList.map((features, index) => ({
      itemFeatures: features,
      probability: probabilities[index],
      itemId: index.toString() // в реальном приложении будет реальный ID
    }));
    
    // Сортировка по вероятности
    recommendations.sort((a, b) => b.probability - a.probability);
    
    // Освобождение памяти
    xs.dispose();
    predictions.dispose();
    
    return recommendations.slice(0, 10); // возвращаем топ-10
  }
}

interface UserPreferences {
  categories: string[];
  preferredTimeOfDay: 'morning' | 'afternoon' | 'evening' | 'any';
  interactionHistory: Interaction[];
}

interface Interaction {
  itemId: string;
  liked: boolean;
  timestamp: Date;
}

interface Recommendation {
  itemId: string;
  probability: number;
  itemFeatures: number[];
}
```

### Пример: Онлайн-обучение для распознавания жестов

```typescript
// Класс для онлайн-обучения распознавания жестов
class GestureTrainer {
  private model: tf.Sequential;
  private gestureClasses: string[];
  private dataBuffer: DataBuffer;
  private isTraining: boolean;
  
  constructor(gestureClasses: string[]) {
    this.gestureClasses = gestureClasses;
    this.dataBuffer = new DataBuffer(1000); // буфер на 1000 примеров
    this.isTraining = false;
    this.model = this.createGestureModel();
  }
  
  private createGestureModel(): tf.Sequential {
    const model = tf.sequential();
    
    // Вход: 63 значения (21 точка * 3 координаты для MediaPipe Hands)
    model.add(tf.layers.dense({
      inputShape: [63],
      units: 128,
      activation: 'relu'
    }));
    
    model.add(tf.layers.dropout({ rate: 0.2 }));
    
    model.add(tf.layers.dense({
      units: 64,
      activation: 'relu'
    }));
    
    model.add(tf.layers.dropout({ rate: 0.2 }));
    
    model.add(tf.layers.dense({
      units: this.gestureClasses.length,
      activation: 'softmax'
    }));
    
    model.compile({
      optimizer: tf.train.adam(0.001),
      loss: 'categoricalCrossentropy',
      metrics: ['accuracy']
    });
    
    return model;
  }
  
  // Добавление данных для обучения
  addTrainingData(landmarks: number[], gestureLabel: string): void {
    const labelIndex = this.gestureClasses.indexOf(gestureLabel);
    if (labelIndex === -1) {
      console.error(`Неизвестный жест: ${gestureLabel}`);
      return;
    }
    
    // Преобразование метки в one-hot вектор
    const oneHotLabel = Array(this.gestureClasses.length).fill(0);
    oneHotLabel[labelIndex] = 1;
    
    this.dataBuffer.add(landmarks, oneHotLabel);
  }
  
  // Запуск онлайн-обучения
  async startOnlineTraining(): Promise<void> {
    this.isTraining = true;
    
    while (this.isTraining) {
      if (this.dataBuffer.size() >= 32) { // минимальный размер батча
        await this.trainOnBatch();
      }
      
      // Небольшая задержка, чтобы не перегружать процессор
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  private async trainOnBatch(): Promise<void> {
    const { inputs, labels } = this.dataBuffer.getBatch(32);
    
    const xs = tf.tensor2d(inputs, [inputs.length, inputs[0].length]);
    const ys = tf.tensor2d(labels, [labels.length, labels[0].length]);
    
    const lossValues = await this.model.trainOnBatch(xs, ys) as tf.Scalar;
    const loss = await lossValues.data();
    
    console.log(`Потеря на батче: ${loss[0].toFixed(4)}`);
    
    // Освобождение памяти
    xs.dispose();
    ys.dispose();
    lossValues.dispose();
  }
  
  // Остановка обучения
  stopTraining(): void {
    this.isTraining = false;
  }
  
  // Предсказание жеста
  async predictGesture(landmarks: number[]): Promise<GesturePrediction> {
    const input = tf.tensor2d([landmarks], [1, landmarks.length]);
    const prediction = this.model.predict(input) as tf.Tensor;
    const probabilities = await prediction.data();
    
    // Находим класс с максимальной вероятностью
    let maxIndex = 0;
    let maxProb = probabilities[0];
    for (let i = 1; i < probabilities.length; i++) {
      if (probabilities[i] > maxProb) {
        maxProb = probabilities[i];
        maxIndex = i;
      }
    }
    
    // Освобождение памяти
    input.dispose();
    prediction.dispose();
    
    return {
      gesture: this.gestureClasses[maxIndex],
      confidence: maxProb,
      allProbabilities: Array.from(probabilities)
    };
  }
}

// Класс для буферизации данных
class DataBuffer {
  private inputs: number[][];
  private labels: number[][];
  private maxSize: number;
  
  constructor(maxSize: number) {
    this.inputs = [];
    this.labels = [];
    this.maxSize = maxSize;
  }
  
  add(input: number[], label: number[]): void {
    this.inputs.push(input);
    this.labels.push(label);
    
    // Ограничение размера буфера
    if (this.inputs.length > this.maxSize) {
      this.inputs.shift();
      this.labels.shift();
    }
  }
  
  getBatch(batchSize: number): { inputs: number[][]; labels: number[][] } {
    const actualBatchSize = Math.min(batchSize, this.inputs.length);
    
    const batchInputs = this.inputs.slice(-actualBatchSize);
    const batchLabels = this.labels.slice(-actualBatchSize);
    
    // Удаляем использованные данные
    this.inputs = this.inputs.slice(0, -actualBatchSize);
    this.labels = this.labels.slice(0, -actualBatchSize);
    
    return { inputs: batchInputs, labels: batchLabels };
  }
  
  size(): number {
    return this.inputs.length;
  }
}

interface GesturePrediction {
  gesture: string;
  confidence: number;
  allProbabilities: number[];
}
```

## Оптимизация производительности

### Управление памятью

```typescript
// Класс для мониторинга и управления памятью во время обучения
class TrainingMemoryManager {
  private initialMemory: number;
  private maxMemoryUsage: number;
  
  constructor(maxMemoryMB: number = 500) {
    this.maxMemoryUsage = maxMemoryMB * 1024 * 1024; // преобразуем в байты
    this.initialMemory = this.getUsedMemory();
  }
  
  getUsedMemory(): number {
    if ((performance as any).memory) {
      return (performance as any).memory.usedJSHeapSize;
    }
    return 0;
  }
  
  checkMemoryUsage(): boolean {
    const currentMemory = this.getUsedMemory();
    const totalUsed = currentMemory - this.initialMemory;
    
    if (totalUsed > this.maxMemoryUsage) {
      console.warn('Превышено ограничение памяти, очистка тензоров...');
      tf.disposeVariables(); // очистка неиспользуемых переменных
      return false;
    }
    
    return true;
  }
  
  logMemoryUsage(): void {
    const current = this.getUsedMemory();
    const diff = current - this.initialMemory;
    console.log(`Использование памяти: ${(current / 1024 / 1024).toFixed(2)} MB (${diff > 0 ? '+' : ''}${(diff / 1024 / 1024).toFixed(2)} MB)`);
  }
}
```

## Заключение

Обучение моделей машинного обучения в браузере открывает новые возможности для создания адаптивных и персонализированных веб-приложений. TypeScript обеспечивает строгую типизацию, что особенно важно при разработке сложных процессов обучения, помогая избежать ошибок и улучшая качество кода.

## См. также

- [[TensorFlow-js]]
- [[Модели-в-браузере]]
- [[Инференс]]
- [[Онлайн-обучение-и-адаптация]]
- [[Оптимизация-производительности-в-браузере]]