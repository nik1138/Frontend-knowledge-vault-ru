---
aliases: ["Офлайн-функциональность", "Работа без интернета", "Offline Support"]
tags: ["#pwa", "#typescript", "#web", "#offline", "#caching", "#service-workers"]
---

# Офлайн-работа

Офлайн-работа - одна из ключевых возможностей Progressive Web Apps (PWA), позволяющая пользователям использовать приложение даже при отсутствии подключения к интернету. Это достигается за счет использования Service Workers, стратегий кэширования и правильной архитектуры приложения.

## Основные принципы офлайн-работы

Для обеспечения корректной работы PWA в офлайн-режиме необходимо:

1. **Кэшировать статические ресурсы**: HTML, CSS, JavaScript, изображения и другие файлы, необходимые для работы приложения.
2. **Кэшировать динамические данные**: API-ответы, пользовательские данные и другие изменяемые элементы.
3. **Обрабатывать сетевые ошибки**: При отсутствии подключения возвращать кэшированные данные или альтернативное содержимое.
4. **Синхронизировать данные при восстановлении подключения**: Обновлять кэш и отправлять отложенные запросы.

## Стратегии кэширования

### 1. Cache First (Кэш первым)

Стратегия, при которой сначала проверяется кэш, и только если ресурс отсутствует, делается сетевой запрос. Используется для статических ресурсов, которые редко изменяются.

```typescript
// sw.ts (Service Worker)
const CACHE_NAME = 'static-v1';
const STATIC_ASSETS = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png'
];

self.addEventListener('install', (event: ExtendableEvent) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(STATIC_ASSETS))
  );
});

self.addEventListener('fetch', (event: FetchEvent) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});
```

### 2. Network First (Сеть первым)

Стратегия, при которой сначала делается сетевой запрос, и только при его неудаче возвращается кэшированный ресурс. Используется для часто изменяемых данных.

```typescript
// sw.ts (Service Worker)
const NETWORK_FIRST_CACHE = 'network-first-v1';

self.addEventListener('fetch', (event: FetchEvent) => {
  event.respondWith(
    fetch(event.request)
      .then((networkResponse) => {
        // Кэшируем успешный сетевой ответ
        caches.open(NETWORK_FIRST_CACHE)
          .then((cache) => {
            cache.put(event.request, networkResponse.clone());
          });
        return networkResponse;
      })
      .catch(() => {
        // Возвращаем кэшированный ресурс при ошибке сети
        return caches.match(event.request);
      })
  );
});
```

### 3. Stale-While-Revalidate (Устаревшее при обновлении)

Возвращается кэшированный ресурс, но параллельно делается сетевой запрос для обновления кэша. Используется для часто запрашиваемых данных, где приемлемо небольшое устаревание.

```typescript
// sw.ts (Service Worker)
self.addEventListener('fetch', (event: FetchEvent) => {
  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        const networkRequest = fetch(event.request)
          .then((networkResponse) => {
            // Кэшируем сетевой ответ
            caches.open(NETWORK_FIRST_CACHE)
              .then((cache) => {
                cache.put(event.request, networkResponse.clone());
              });
            return networkResponse;
          });

        return cachedResponse || networkRequest;
      })
  );
});
```

### 4. Cache with Network Fallback and Update

Комбинация кэширования и сетевых запросов с обновлением кэша при наличии подключения.

```typescript
// sw.ts (Service Worker)
self.addEventListener('fetch', (event: FetchEvent) => {
  event.respondWith(
    caches.open(NETWORK_FIRST_CACHE)
      .then((cache) => {
        return fetch(event.request)
          .then((networkResponse) => {
            // Обновляем кэш
            cache.put(event.request, networkResponse.clone());
            return networkResponse;
          })
          .catch(() => {
            // Возвращаем кэшированную версию при ошибке
            return cache.match(event.request)
              .then((cachedResponse) => {
                if (cachedResponse) {
                  return cachedResponse;
                }
                // Возвращаем оффлайн-страницу
                return caches.match('/offline.html');
              });
          });
      })
  );
});
```

## Обработка офлайн-состояния в приложении

Для улучшения пользовательского опыта важно информировать пользователя о состоянии подключения к интернету и адаптировать интерфейс соответственно.

### Определение статуса подключения

```typescript
// app.ts
class OfflineManager {
  private isOnline: boolean = navigator.onLine;
  
  constructor() {
    this.init();
  }
  
  private init(): void {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.handleConnectionChange();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.handleConnectionChange();
    });
  }
  
  private handleConnectionChange(): void {
    if (this.isOnline) {
      console.log('Соединение восстановлено');
      // Выполнить синхронизацию данных
      this.syncPendingRequests();
    } else {
      console.log('Подключение к интернету отсутствует');
      // Показать уведомление пользователю
      this.showOfflineNotification();
    }
  }
  
  public getOnlineStatus(): boolean {
    return this.isOnline;
  }
  
  private showOfflineNotification(): void {
    // Реализация уведомления о статусе офлайн
    const notification = document.getElementById('offline-notification');
    if (notification) {
      notification.style.display = 'block';
    }
  }
  
  private syncPendingRequests(): void {
    // Синхронизация отложенных запросов
    const pendingRequests = this.getPendingRequests();
    pendingRequests.forEach(request => {
      this.sendRequest(request);
    });
  }
  
  private getPendingRequests(): any[] {
    // Получение отложенных запросов из localStorage или IndexedDB
    const requests = localStorage.getItem('pendingRequests');
    return requests ? JSON.parse(requests) : [];
  }
  
  private sendRequest(request: any): void {
    // Отправка отложенного запроса
    fetch(request.url, request.options)
      .then(response => {
        if (response.ok) {
          // Удаление запроса из очереди при успешной отправке
          this.removePendingRequest(request.id);
        }
      })
      .catch(error => {
        console.error('Ошибка отправки запроса:', error);
      });
  }
  
  private removePendingRequest(requestId: string): void {
    // Удаление запроса из очереди
    const pendingRequests = this.getPendingRequests();
    const updatedRequests = pendingRequests.filter(req => req.id !== requestId);
    localStorage.setItem('pendingRequests', JSON.stringify(updatedRequests));
  }
}

// Инициализация менеджера офлайн-состояния
const offlineManager = new OfflineManager();
```

## Кэширование динамических данных

Для кэширования API-ответов и пользовательских данных рекомендуется использовать IndexedDB или localStorage в дополнение к кэшу Service Worker.

```typescript
// data-cache.ts
interface CacheEntry {
  data: any;
  timestamp: number;
  expiry: number; // Время жизни в миллисекундах
}

class DataCache {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly defaultExpiry: number = 5 * 60 * 1000; // 5 минут по умолчанию
  
  public set(key: string, data: any, expiry?: number): void {
    const cacheEntry: CacheEntry = {
      data,
      timestamp: Date.now(),
      expiry: expiry || this.defaultExpiry
    };
    this.cache.set(key, cacheEntry);
  }
  
  public get(key: string): any | null {
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }
    
    // Проверяем, не истекло ли время жизни
    if (Date.now() - entry.timestamp > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data;
  }
  
  public has(key: string): boolean {
    const entry = this.cache.get(key);
    if (!entry) {
      return false;
    }
    
    // Проверяем, не истекло ли время жизни
    if (Date.now() - entry.timestamp > entry.expiry) {
      this.cache.delete(key);
      return false;
    }
    
    return true;
  }
  
  public clear(): void {
    this.cache.clear();
  }
  
  public remove(key: string): boolean {
    return this.cache.delete(key);
  }
}

// Использование кэша данных
const dataCache = new DataCache();

// Пример использования
const fetchUserData = async (userId: string): Promise<any> => {
  const cacheKey = `user-${userId}`;
  
  // Проверяем кэш
  let userData = dataCache.get(cacheKey);
  if (userData) {
    console.log('Данные пользователя получены из кэша');
    return userData;
  }
  
  // Делаем сетевой запрос
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    userData = await response.json();
    
    // Кэшируем данные на 10 минут
    dataCache.set(cacheKey, userData, 10 * 60 * 1000);
    return userData;
  } catch (error) {
    console.error('Ошибка получения данных пользователя:', error);
    
    // Возвращаем кэшированные данные, если они есть
    const cachedData = dataCache.get(cacheKey);
    if (cachedData) {
      console.log('Возвращаем устаревшие данные из кэша');
      return cachedData;
    }
    
    throw error;
  }
};
```

## Офлайн-страницы

Создание специальной страницы для отображения в случае отсутствия подключения к интернету улучшает пользовательский опыт.

```html
<!-- offline.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Офлайн - Мое PWA</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 50px;
      background-color: #f5f5f5;
    }
    .offline-container {
      max-width: 600px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .offline-icon {
      font-size: 60px;
      color: #ccc;
      margin-bottom: 20px;
    }
    .reconnect-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="offline-container">
    <div class="offline-icon">✈️</div>
    <h1>Вы в офлайн-режиме</h1>
    <p>К сожалению, вы не подключены к интернету. Некоторые функции могут быть недоступны.</p>
    <p>При подключении к интернету вы автоматически вернетесь к приложению.</p>
    <button class="reconnect-btn" onclick="checkConnection()">Проверить подключение</button>
  </div>

  <script>
    function checkConnection() {
      if (navigator.onLine) {
        window.location.href = '/';
      } else {
        alert('Подключение к интернету все еще отсутствует');
      }
    }
    
    // Проверяем подключение каждые 5 секунд
    setInterval(() => {
      if (navigator.onLine) {
        window.location.href = '/';
      }
    }, 5000);
  </script>
</body>
</html>
```

## Тестирование офлайн-функциональности

Для тестирования офлайн-функциональности в браузере Chrome:

1. Откройте DevTools (F12)
2. Перейдите на вкладку "Application"
3. Выберите "Service Workers" в левой панели
4. Включите "Offline" для симуляции отсутствия подключения
5. Перезагрузите страницу и проверьте работу приложения

Также можно использовать вкладку "Network" и выбрать "Offline" или "Fast 3G" для симуляции различных условий подключения.

## Полезные ресурсы

- [[Service-Workers]] - для понимания основ кэширования
- [[Web-App-Manifest]] - для полной настройки PWA
- [[Push-уведомления]] - для улучшения взаимодействия с пользователем
- [[Установка-PWA]] - для понимания полного цикла PWA
- [Google Developers - Offline UX Design Guide](https://developers.google.com/web/fundamentals/instant-and-offline/offline-ux)
- [MDN - Using the Cache API](https://developer.mozilla.org/ru/docs/Web/API/Cache)

## Заключение

Офлайн-работа - важная часть Progressive Web Apps, обеспечивающая стабильный пользовательский опыт независимо от качества подключения к интернету. Правильное использование Service Workers, стратегий кэширования и обработки состояния подключения позволяет создавать надежные и удобные приложения, которые работают даже в сложных сетевых условиях.