---
aliases: [Очистка данных, Безопасная обработка данных]
tags: [typescript, безопасность, санитизация, безопасность-приложений, XSS, инъекции]
---

# Санитизация данных в TypeScript

## Обзор

Санитизация данных - это процесс очистки и подготовки данных для безопасного использования в приложении. Она помогает предотвратить инъекции, XSS-атаки и другие уязвимости, связанные с неправильной обработкой пользовательского ввода.

## Принципы безопасной санитизации

### 1. Принцип "ничего не доверять"

Все внешние данные должны подвергаться санитизации перед использованием, независимо от их источника.

### 2. Контекстно-зависимая санитизация

Санитизация должна учитывать, где и как будут использоваться данные (HTML, SQL, URL и т.д.).

## Практические реализации

### 1. Санитизация HTML-контента

Для предотвращения XSS-атак используем библиотеку DOMPurify:

```typescript
import DOMPurify from 'isomorphic-dompurify';

// Санитизация HTML-контента
function sanitizeHtml(input: string): string {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li'],
    ALLOWED_ATTR: ['href', 'title', 'class'],
    FORBID_TAGS: ['script', 'object', 'embed', 'iframe']
  });
}

// Пример использования
const userInput = '<p>Привет, <script>alert("XSS")</script>мир!</p>';
const safeOutput = sanitizeHtml(userInput);
console.log(safeOutput); // '<p>Привет, мир!</p>'
```

### 2. Санитизация URL и параметров

```typescript
// Санитизация URL-адресов
function sanitizeUrl(input: string): string | null {
  try {
    const url = new URL(input);
    // Проверяем протокол
    if (!['http:', 'https:'].includes(url.protocol)) {
      return null;
    }
    return url.toString();
  } catch (error) {
    return null;
  }
}

// Санитизация параметров строки запроса
function sanitizeQueryParams(params: Record<string, string>): Record<string, string> {
  const sanitized: Record<string, string> = {};
  
  for (const [key, value] of Object.entries(params)) {
    // Очищаем ключ параметра
    const cleanKey = key.replace(/[^a-zA-Z0-9_]/g, '');
    // Очищаем значение параметра
    const cleanValue = value.replace(/[<>'"&]/g, (match) => {
      const escapeMap: Record<string, string> = {
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '&': '&amp;'
      };
      return escapeMap[match] || match;
    });
    
    sanitized[cleanKey] = cleanValue;
  }
  
  return sanitized;
}
```

### 3. Санитизация файлов

```typescript
// Санитизация загружаемых файлов
interface FileValidationResult {
  isValid: boolean;
  sanitizedFilename: string;
  errorMessage?: string;
}

function sanitizeFileName(filename: string): string {
  // Удаляем потенциально опасные символы
  return filename
    .replace(/[^a-zA-Z0-9._-]/g, '_') // Заменяем недопустимые символы на _
    .replace(/^\.+|\.+$/g, '') // Удаляем точки в начале и конце
    .substring(0, 255); // Ограничиваем длину
}

function validateAndSanitizeFile(file: Express.Multer.File): FileValidationResult {
  // Проверяем расширение файла
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt'];
  const fileExtension = '.' + file.originalname.split('.').pop()!.toLowerCase();
  
  if (!allowedExtensions.includes(fileExtension)) {
    return {
      isValid: false,
      sanitizedFilename: '',
      errorMessage: `Недопустимое расширение файла: ${fileExtension}`
    };
  }
  
  // Проверяем размер файла (например, максимум 5MB)
  if (file.size > 5 * 1024 * 1024) {
    return {
      isValid: false,
      sanitizedFilename: '',
      errorMessage: 'Файл слишком большой (максимум 5MB)'
    };
  }
  
  // Санитизируем имя файла
  const sanitizedFilename = sanitizeFileName(file.originalname);
  
  return {
    isValid: true,
    sanitizedFilename
  };
}
```

### 4. Санитизация JSON-данных

```typescript
// Санитизация JSON-объекта
function sanitizeJson(obj: any, allowedKeys: string[]): any {
  if (Array.isArray(obj)) {
    return obj.map(item => sanitizeJson(item, allowedKeys));
  }
  
  if (obj && typeof obj === 'object') {
    const sanitized: any = {};
    
    for (const [key, value] of Object.entries(obj)) {
      // Проверяем, разрешен ли ключ
      if (allowedKeys.includes(key)) {
        // Рекурсивно санитизируем значение
        sanitized[key] = sanitizeJson(value, allowedKeys);
      }
    }
    
    return sanitized;
  }
  
  // Для примитивных значений возвращаем как есть
  return obj;
}

// Пример использования
const userInput = {
  name: 'John',
  email: 'john@example.com',
  password: 'secret123', // Этот ключ будет удален
  age: 30
};

const sanitizedUser = sanitizeJson(userInput, ['name', 'email', 'age']);
console.log(sanitizedUser); // { name: 'John', email: 'john@example.com', age: 30 }
```

### 5. Санитизация SQL-запросов

```typescript
// Санитизация параметров SQL-запросов
import { Pool } from 'pg'; // Пример с PostgreSQL

class SafeDatabaseQuery {
  private pool: Pool;
  
  constructor(pool: Pool) {
    this.pool = pool;
  }
  
  // Метод для безопасного выполнения запросов с параметрами
  async executeQuery<T>(
    query: string, 
    params: any[]
  ): Promise<T[]> {
    // Проверяем, что параметры не содержат потенциально опасных значений
    const sanitizedParams = params.map(param => {
      if (typeof param === 'string') {
        // Экранируем потенциально опасные символы
        return param.replace(/'/g, "''").replace(/;/g, '');
      }
      return param;
    });
    
    // Используем подготовленные выражения для предотвращения SQL-инъекций
    const result = await this.pool.query(query, sanitizedParams);
    return result.rows as T[];
  }
  
  // Метод для безопасного построения динамических запросов
  buildSafeQuery(
    tableName: string, 
    conditions: Record<string, any>,
    allowedColumns: string[] = []
  ): { query: string; params: any[] } {
    // Санитизируем имя таблицы
    const sanitizedTableName = tableName.replace(/[^a-zA-Z0-9_]/g, '');
    
    // Проверяем, разрешены ли указанные колонки
    const sanitizedConditions: Record<string, any> = {};
    const params: any[] = [];
    
    for (const [key, value] of Object.entries(conditions)) {
      // Санитизируем имя колонки
      const sanitizedKey = key.replace(/[^a-zA-Z0-9_]/g, '');
      
      // Проверяем, разрешена ли колонка
      if (allowedColumns.length === 0 || allowedColumns.includes(sanitizedKey)) {
        sanitizedConditions[sanitizedKey] = value;
        params.push(value);
      }
    }
    
    // Формируем безопасный запрос
    const whereClause = Object.keys(sanitizedConditions)
      .map((key, index) => `"${key}" = $${index + 1}`)
      .join(' AND ');
    
    const query = `SELECT * FROM "${sanitizedTableName}" WHERE ${whereClause}`;
    
    return { query, params };
  }
}
```

### 6. Санитизация пользовательского ввода в формах

```typescript
// Интерфейс для санитизированных данных формы
interface SanitizedFormInput {
  readonly email: string;
  readonly username: string;
  readonly comment: string;
}

// Санитизация данных формы
function sanitizeFormInput(input: any): SanitizedFormInput {
  // Санитизация email
  let email = input.email || '';
  if (typeof email === 'string') {
    email = email.trim().toLowerCase().substring(0, 254); // Ограничение длины
  } else {
    email = '';
  }
  
  // Санитизация username
  let username = input.username || '';
  if (typeof username === 'string') {
    username = username
      .replace(/[^a-zA-Z0-9_]/g, '') // Только буквенно-цифровые символы и подчеркивание
      .substring(0, 30); // Ограничение длины
  } else {
    username = '';
  }
  
  // Санитизация комментария
  let comment = input.comment || '';
  if (typeof comment === 'string') {
    comment = comment
      .substring(0, 1000) // Ограничение длины
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Удаление script-тегов
      .replace(/javascript:/gi, '') // Удаление javascript: ссылок
      .trim();
  } else {
    comment = '';
  }
  
  return {
    email,
    username,
    comment
  };
}
```

## Интеграция с другими аспектами безопасности

Санитизация данных тесно связана с:
- [[Валидация-входных-данных]] - часто санитизация и валидация выполняются совместно
- [[Защита-от-инъекций]] - санитизация является одним из способов предотвращения инъекций
- [[Типизация-данных]] - санитизация помогает обеспечить соответствие данных определенным типам

## Лучшие практики

1. **Санитизация на сервере**: Всегда санитизируйте данные на сервере, даже если они уже санитизированы на клиенте
2. **Контекстно-зависимая обработка**: Используйте разные методы санитизации в зависимости от контекста использования данных
3. **Белый список разрешений**: Предпочитайте белый список разрешенных элементов черному списку запрещенных
4. **Проверка типов**: Используйте типизацию для дополнительной проверки санитизированных данных
5. **Тестирование санитизации**: Покройте тестами различные сценарии санитизации, включая граничные случаи

## Заключение

Санитизация данных в TypeScript - важный элемент безопасности приложений. Она помогает предотвратить множество уязвимостей, включая XSS, SQL-инъекции и другие виды атак. Правильная санитизация требует понимания контекста использования данных и применения соответствующих методов очистки.