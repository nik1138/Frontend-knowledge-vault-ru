---
aliases: [Валидация данных, Проверка входных данных]
tags: [typescript, безопасность, валидация, безопасность-приложений, безопасность-веб-приложений]
---

# Валидация входных данных в TypeScript

## Обзор

Валидация входных данных является критическим элементом безопасности приложений на TypeScript. Она помогает предотвратить множество уязвимостей, включая инъекции, манипуляции с данными и нарушения целостности системы.

## Принципы безопасной валидации

### 1. Принцип "ничего не принимать без проверки"

Все внешние данные, поступающие в приложение, должны быть проверены перед использованием. Это включает:
- Параметры URL
- POST-данные
- Заголовки HTTP
- Файлы, загружаемые пользователем
- Данные из внешних API

### 2. Проверка на границах системы

Валидация должна происходить на границах системы, где внешние данные входят в доверенную область приложения.

## Практические реализации

### 1. Валидация с использованием Zod

Zod - это библиотека для валидации данных, хорошо интегрирующаяся с TypeScript:

```typescript
import { z } from 'zod';

// Определение схемы для данных пользователя
const UserSchema = z.object({
  id: z.number().int().positive(),
  email: z.string().email(),
  name: z.string().min(1).max(100),
  age: z.number().int().min(0).max(120).optional(),
  roles: z.array(z.enum(['admin', 'user', 'moderator'])).default(['user'])
});

type User = z.infer<typeof UserSchema>;

// Функция валидации данных пользователя
function validateUser(data: unknown): User {
  try {
    return UserSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Неверные данные пользователя: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw new Error('Неизвестная ошибка при валидации');
  }
}

// Пример использования
try {
  const userData = validateUser({
    id: 123,
    email: 'user@example.com',
    name: 'John Doe',
    roles: ['user']
  });
  console.log('Валидация успешна:', userData);
} catch (error) {
  console.error('Ошибка валидации:', error.message);
}
```

### 2. Валидация с использованием Yup

Yup - еще одна популярная библиотека для валидации:

```typescript
import * as yup from 'yup';

const userSchema = yup.object({
  email: yup.string().email('Неверный формат email').required('Email обязателен'),
  password: yup
    .string()
    .min(8, 'Пароль должен содержать минимум 8 символов')
    .matches(/[A-Z]/, 'Пароль должен содержать хотя бы одну заглавную букву')
    .matches(/[0-9]/, 'Пароль должен содержать хотя бы одну цифру')
    .required('Пароль обязателен'),
  confirmPassword: yup
    .string()
    .oneOf([yup.ref('password')], 'Пароли должны совпадать')
    .required('Подтверждение пароля обязательно')
});

interface UserRegistration {
  email: string;
  password: string;
  confirmPassword: string;
}

async function validateRegistration(data: UserRegistration): Promise<boolean> {
  try {
    await userSchema.validate(data, { abortEarly: false });
    return true;
  } catch (error) {
    if (error instanceof yup.ValidationError) {
      console.error('Ошибки валидации:', error.inner);
    }
    return false;
  }
}
```

### 3. Валидация в Express-приложениях

```typescript
import express from 'express';
import { body, validationResult } from 'express-validator';

const app = express();
app.use(express.json());

// Валидация данных регистрации
app.post('/register', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
  body('username').isLength({ min: 3, max: 30 }).matches(/^[a-zA-Z0-9_]+$/)
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  // Обработка данных пользователя
  const { email, password, username } = req.body;
  // ... остальная логика
});
```

## Валидация на уровне типов

TypeScript также позволяет создавать типы с дополнительными ограничениями:

```typescript
// Создание типов с ограничениями
type Email = string & { readonly brand: unique symbol };
type Password = string & { readonly brand: unique symbol };
type SafeString = string & { readonly brand: unique symbol };

// Функции для создания безопасных типов
function createEmail(input: string): Email | null {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(input) ? (input as Email) : null;
}

function createPassword(input: string): Password | null {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  return passwordRegex.test(input) ? (input as Password) : null;
}

// Использование типов
interface UserCredentials {
  email: Email;
  password: Password;
}

function processCredentials(credentials: unknown): UserCredentials | null {
  if (typeof credentials !== 'object' || credentials === null) {
    return null;
  }
  
  const { email, password } = credentials as { email?: string; password?: string };
  
  const safeEmail = email && createEmail(email);
  const safePassword = password && createPassword(password);
  
  if (!safeEmail || !safePassword) {
    return null;
  }
  
  return { email: safeEmail, password: safePassword };
}
```

## Валидация конфигурационных данных

```typescript
import { z } from 'zod';

const ConfigSchema = z.object({
  port: z.number().min(1).max(65535),
  databaseUrl: z.string().url(),
  jwtSecret: z.string().min(32, 'JWT secret должен быть не менее 32 символов'),
  rateLimit: z.object({
    windowMs: z.number().positive(),
    max: z.number().int().positive()
  }),
  cors: z.object({
    origin: z.union([z.string(), z.array(z.string())]),
    credentials: z.boolean()
  })
});

type AppConfig = z.infer<typeof ConfigSchema>;

function validateConfig(config: unknown): AppConfig {
  try {
    return ConfigSchema.parse(config);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Ошибка валидации конфигурации: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw error;
  }
}
```

## Интеграция с другими аспектами безопасности

Валидация входных данных тесно связана с:
- [[Типизация-данных]] - валидация подтверждает соответствие данных определенным типам
- [[Санитизация]] - часто валидация и санитизация выполняются вместе
- [[Аутентификация]] - валидация данных аутентификации критически важна

## Лучшие практики

1. **Валидация на клиенте и сервере**: Валидация на клиенте улучшает UX, но серверная валидация обязательна
2. **Ранняя валидация**: Проверяйте данные как можно раньше в цепочке обработки
3. **Использование проверенных библиотек**: Используйте проверенные библиотеки валидации вместо написания своих
4. **Подробные сообщения об ошибках**: Обеспечьте понятные сообщения об ошибках валидации
5. **Тестирование валидации**: Покройте тестами как успешные, так и неуспешные сценарии валидации

## Заключение

Валидация входных данных в TypeScript - это многоуровневый процесс, который включает как проверку типов на этапе компиляции, так и проверку значений на этапе выполнения. Использование специализированных библиотек валидации, таких как Zod или Yup, значительно упрощает этот процесс и делает код более надежным.