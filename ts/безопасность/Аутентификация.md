---
aliases: [Аутентификация пользователей, Идентификация, Логин, Регистрация]
tags: [typescript, безопасность, аутентификация, авторизация, JWT, сессии, безопасность-приложений]
---

# Аутентификация в TypeScript-приложениях

## Обзор

Аутентификация - это процесс проверки идентичности пользователя, системы или сервиса. В TypeScript-приложениях правильная реализация аутентификации критически важна для обеспечения безопасности и защиты пользовательских данных.

## Принципы безопасной аутентификации

### 1. Использование проверенных библиотек

Не реализуйте аутентификацию с нуля. Используйте проверенные библиотеки и фреймворки.

### 2. Защита паролей

Пароли никогда не должны храниться в открытом виде. Всегда используйте хеширование с солью.

### 3. Защита сессий

Сессии должны быть защищены от угона и подделки.

## Реализация аутентификации

### 1. Хеширование паролей

```typescript
import bcrypt from 'bcrypt';

interface User {
  id: number;
  email: string;
  passwordHash: string;
  salt: string;
}

class PasswordService {
  private static readonly SALT_ROUNDS = 12;
  
  // Хеширование пароля
  static async hashPassword(password: string): Promise<{ hash: string; salt: string }> {
    const salt = await bcrypt.genSalt(PasswordService.SALT_ROUNDS);
    const hash = await bcrypt.hash(password, salt);
    
    return { hash, salt };
  }
  
  // Проверка пароля
  static async verifyPassword(password: string, hash: string): Promise<boolean> {
    return await bcrypt.compare(password, hash);
  }
}

// Пример использования при регистрации пользователя
class UserService {
  async registerUser(email: string, plainPassword: string): Promise<User> {
    // Проверяем пароль на сложность
    if (!this.isValidPassword(plainPassword)) {
      throw new Error('Пароль не соответствует требованиям безопасности');
    }
    
    // Хешируем пароль
    const { hash, salt } = await PasswordService.hashPassword(plainPassword);
    
    // Сохраняем пользователя с хешем пароля
    const user: User = {
      id: Date.now(), // В реальном приложении использовать UUID или автоинкремент
      email: email.toLowerCase().trim(),
      passwordHash: hash,
      salt: salt
    };
    
    // Здесь сохранение в базу данных
    return user;
  }
  
  async authenticateUser(email: string, password: string): Promise<User | null> {
    // Получаем пользователя из базы данных
    const user = await this.findUserByEmail(email.toLowerCase().trim());
    
    if (!user) {
      // Важно: не указывать, что пользователь не существует
      // для предотвращения атак по времени
      await PasswordService.verifyPassword('dummy', 'dummy');
      return null;
    }
    
    // Проверяем пароль
    const isValid = await PasswordService.verifyPassword(password, user.passwordHash);
    
    if (!isValid) {
      return null;
    }
    
    return user;
  }
  
  private isValidPassword(password: string): boolean {
    // Проверяем требования к паролю
    return password.length >= 8 &&
           /[A-Z]/.test(password) &&
           /[a-z]/.test(password) &&
           /[0-9]/.test(password) &&
           /[^A-Za-z0-9]/.test(password);
  }
  
  private async findUserByEmail(email: string): Promise<User | null> {
    // Реализация поиска пользователя в базе данных
    // В реальном приложении использовать ORM или SQL-запросы
    return null; // Заглушка
  }
}
```

### 2. JWT-аутентификация

```typescript
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

interface JwtPayload {
  userId: number;
  email: string;
  iat: number;
  exp: number;
}

class JwtAuthService {
  private static readonly JWT_SECRET = process.env.JWT_SECRET || 'default_secret';
  private static readonly JWT_EXPIRES_IN = '24h';
  
  // Создание JWT-токена
  static signToken(user: { id: number; email: string }): string {
    return jwt.sign(
      { userId: user.id, email: user.email },
      JwtAuthService.JWT_SECRET,
      { expiresIn: JwtAuthService.JWT_EXPIRES_IN }
    );
  }
  
  // Проверка JWT-токена
  static verifyToken(token: string): JwtPayload | null {
    try {
      const decoded = jwt.verify(token, JwtAuthService.JWT_SECRET) as JwtPayload;
      return decoded;
    } catch (error) {
      return null;
    }
  }
  
  // Middleware для аутентификации с JWT
  static authenticate(req: Request, res: Response, next: NextFunction): void {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({ error: 'Требуется аутентификация' });
      return;
    }
    
    const token = authHeader.substring(7); // Убираем 'Bearer '
    const payload = JwtAuthService.verifyToken(token);
    
    if (!payload) {
      res.status(401).json({ error: 'Невалидный токен' });
      return;
    }
    
    // Добавляем информацию о пользователе в запрос
    (req as any).user = {
      id: payload.userId,
      email: payload.email
    };
    
    next();
  }
  
  // Обновление токена
  static refreshToken(oldToken: string): string | null {
    const payload = JwtAuthService.verifyToken(oldToken);
    
    if (!payload) {
      return null;
    }
    
    // Создаем новый токен с теми же данными
    return JwtAuthService.signToken({
      id: payload.userId,
      email: payload.email
    });
  }
}

// Пример использования в Express-маршрутах
import express from 'express';
const app = express();

app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  if (!email || !password) {
    return res.status(400).json({ error: 'Email и пароль обязательны' });
  }
  
  const userService = new UserService();
  const user = await userService.authenticateUser(email, password);
  
  if (!user) {
    return res.status(401).json({ error: 'Неверные учетные данные' });
  }
  
  // Создаем JWT-токен
  const token = JwtAuthService.signToken(user);
  
  res.json({
    token,
    user: {
      id: user.id,
      email: user.email
    }
  });
});

// Защищенный маршрут
app.get('/profile', JwtAuthService.authenticate, (req, res) => {
  const user = (req as any).user;
  res.json({ user });
});
```

### 3. Сессионная аутентификация

```typescript
import session from 'express-session';
import connectRedis from 'connect-redis';
import Redis from 'ioredis';

// Настройка Redis для хранения сессий
const RedisStore = connectRedis(session);
const redisClient = new Redis(process.env.REDIS_URL);

const sessionConfig: session.SessionOptions = {
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET || 'default_session_secret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS только в продакшене
    httpOnly: true, // Предотвращение XSS-атак
    maxAge: 24 * 60 * 60 * 1000, // 24 часа
    sameSite: 'strict' // Защита от CSRF
  }
};

// Middleware для сессионной аутентификации
function sessionAuth(req: Request, res: Response, next: NextFunction): void {
  if (req.session && req.session.userId) {
    // Пользователь аутентифицирован
    (req as any).user = { id: req.session.userId };
    next();
  } else {
    res.status(401).json({ error: 'Требуется аутентификация' });
  }
}

// Пример использования
app.use(session(sessionConfig));

app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  const userService = new UserService();
  const user = await userService.authenticateUser(email, password);
  
  if (!user) {
    return res.status(401).json({ error: 'Неверные учетные данные' });
  }
  
  // Устанавливаем сессию
  req.session.userId = user.id;
  req.session.email = user.email;
  
  res.json({
    message: 'Успешный вход',
    user: {
      id: user.id,
      email: user.email
    }
  });
});

app.get('/profile', sessionAuth, (req, res) => {
  const user = (req as any).user;
  res.json({ user });
});
```

### 4. Многофакторная аутентификация (MFA)

```typescript
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';

interface UserWithMFA {
  id: number;
  email: string;
  passwordHash: string;
  mfaSecret?: string;
  mfaEnabled: boolean;
}

class MfaService {
  // Генерация MFA-секрета
  static generateSecret(email: string): { secret: string; otpauthUrl: string; qrCode: string } {
    const secret = speakeasy.generateSecret({
      name: `MyApp (${email})`,
      issuer: 'MyApp'
    });
    
    return {
      secret: secret.base32,
      otpauthUrl: secret.otpauth_url || '',
      qrCode: '' // Будет сгенерирован позже
    };
  }
  
  // Проверка TOTP-кода
  static verifyToken(secret: string, token: string): boolean {
    return speakeasy.totp.verify({
      secret: secret,
      encoding: 'base32',
      token: token,
      window: 2 // Допускаем небольшое отклонение во времени
    });
  }
  
  // Генерация QR-кода для MFA
  static async generateQrCode(otpauthUrl: string): Promise<string> {
    return await QRCode.toDataURL(otpauthUrl);
  }
}

// Расширение UserService для поддержки MFA
class ExtendedUserService extends UserService {
  async enableMfa(userId: number): Promise<{ secret: string; qrCode: string }> {
    const secretInfo = MfaService.generateSecret(`user-${userId}`);
    const qrCode = await MfaService.generateQrCode(secretInfo.otpauthUrl);
    
    // В реальном приложении обновить запись пользователя в базе данных
    // с новым MFA-секретом и флагом mfaEnabled = true
    
    return {
      secret: secretInfo.secret,
      qrCode
    };
  }
  
  async verifyMfa(userId: number, token: string): Promise<boolean> {
    // В реальном приложении получить MFA-секрет из базы данных
    const userMfaSecret = await this.getUserMfaSecret(userId);
    
    if (!userMfaSecret) {
      return false;
    }
    
    return MfaService.verifyToken(userMfaSecret, token);
  }
  
  async authenticateWithMfa(email: string, password: string, mfaToken?: string): Promise<UserWithMFA | null> {
    const user = await this.authenticateUser(email, password);
    
    if (!user) {
      return null;
    }
    
    // В реальном приложении получить полную информацию о пользователе с MFA-данными
    const fullUser: UserWithMFA = {
      ...user,
      mfaSecret: '', // Получить из базы данных
      mfaEnabled: false // Получить из базы данных
    };
    
    if (fullUser.mfaEnabled) {
      if (!mfaToken) {
        throw new Error('Требуется MFA-токен');
      }
      
      const isValid = await this.verifyMfa(fullUser.id, mfaToken);
      
      if (!isValid) {
        return null;
      }
    }
    
    return fullUser;
  }
  
  private async getUserMfaSecret(userId: number): Promise<string | null> {
    // Реализация получения MFA-секрета из базы данных
    return null; // Заглушка
  }
}
```

### 5. Защита от атак на аутентификацию

```typescript
import RateLimit from 'express-rate-limit';
import { Redis } from 'ioredis';

class AuthSecurityService {
  private redis: Redis;
  
  constructor(redisClient: Redis) {
    this.redis = redisClient;
  }
  
  // Отслеживание неудачных попыток входа
  async trackFailedLoginAttempt(identifier: string): Promise<number> {
    const key = `failed_login_attempts:${identifier}`;
    const attempts = await this.redis.incr(key);
    
    // Устанавливаем TTL на 15 минут
    await this.redis.expire(key, 15 * 60);
    
    return attempts;
  }
  
  // Проверка на блокировку
  async isBlocked(identifier: string): Promise<boolean> {
    const key = `failed_login_attempts:${identifier}`;
    const attempts = await this.redis.get(key);
    
    return attempts !== null && parseInt(attempts) >= 5; // 5 неудачных попыток
  }
  
  // Блокировка пользователя
  async blockUser(identifier: string, duration: number = 3600): Promise<void> {
    const key = `blocked_user:${identifier}`;
    await this.redis.setex(key, duration, '1');
  }
  
  // Проверка на окончание блокировки
  async isUserBlocked(identifier: string): Promise<boolean> {
    const key = `blocked_user:${identifier}`;
    const isBlocked = await this.redis.get(key);
    return isBlocked !== null;
  }
  
  // Сброс попыток входа
  async resetFailedLoginAttempts(identifier: string): Promise<void> {
    const key = `failed_login_attempts:${identifier}`;
    await this.redis.del(key);
  }
}

// Rate limiting для аутентификации
const loginLimiter = RateLimit({
  windowMs: 15 * 60 * 1000, // 15 минут
  max: 5, // максимум 5 попыток входа за 15 минут
  message: 'Слишком много попыток входа, попробуйте позже',
  standardHeaders: true,
  legacyHeaders: false,
});

// Защищенный маршрут входа
app.post('/login', loginLimiter, async (req, res) => {
  const { email, password } = req.body;
  const authSecurity = new AuthSecurityService(redisClient);
  
  // Проверяем, заблокирован ли пользователь
  if (await authSecurity.isUserBlocked(email)) {
    return res.status(429).json({ error: 'Слишком много неудачных попыток. Попробуйте позже.' });
  }
  
  const userService = new UserService();
  const user = await userService.authenticateUser(email, password);
  
  if (!user) {
    // Отслеживаем неудачную попытку
    const attempts = await authSecurity.trackFailedLoginAttempt(email);
    
    if (attempts >= 5) {
      await authSecurity.blockUser(email);
    }
    
    return res.status(401).json({ error: 'Неверные учетные данные' });
  }
  
  // Сбрасываем попытки при успешном входе
  await authSecurity.resetFailedLoginAttempts(email);
  
  // Продолжаем с аутентификацией...
});
```

## Интеграция с другими аспектами безопасности

Аутентификация тесно связана с:
- [[Валидация-входных-данных]] - проверка учетных данных пользователя
- [[Санитизация]] - обработка данных аутентификации
- [[Защита-от-инъекций]] - защита от атак на механизмы аутентификации

## Лучшие практики

1. **Использование HTTPS**: Всегда используйте HTTPS для передачи учетных данных
2. **Хранение паролей**: Используйте bcrypt, scrypt или Argon2 для хеширования паролей
3. **Срок действия токенов**: Устанавливайте разумные сроки действия токенов
4. **Многофакторная аутентификация**: Реализуйте MFA для критических систем
5. **Rate limiting**: Защищайтесь от брутфорс-атак
6. **Логирование**: Ведите логи аутентификационных событий
7. **Регулярное обновление**: Регулярно обновляйте библиотеки аутентификации

## Заключение

Аутентификация в TypeScript-приложениях требует комплексного подхода, включающего:
- Надежное хеширование паролей
- Безопасное управление сессиями
- Защиту от атак на аутентификацию
- Использование проверенных библиотек
- Регулярное тестирование безопасности

Правильная реализация аутентификации является фундаментом безопасности любого приложения.