---
aliases: [Предотвращение инъекций, SQL-инъекции, XSS, инъекции в TypeScript]
tags: [typescript, безопасность, инъекции, SQL-инъекции, XSS, безопасность-приложений]
---

# Защита от инъекций в TypeScript

## Обзор

Инъекции - это один из самых распространенных и опасных классов уязвимостей в веб-приложениях. Они происходят, когда приложение неправильно обрабатывает пользовательский ввод, позволяя злоумышленнику внедрять вредоносный код в запросы к системам, таким как базы данных, командные интерпретаторы или движки шаблонов.

## Типы инъекций

### 1. SQL-инъекции

SQL-инъекции происходят, когда пользовательский ввод неправильно экранируется и вставляется в SQL-запросы.

### 2. XSS (Cross-Site Scripting)

XSS-атаки позволяют внедрять вредоносный скрипт в веб-страницу, который затем выполняется в браузере других пользователей.

### 3. Command-инъекции

Command-инъекции происходят, когда пользовательский ввод передается в системные команды без должной проверки.

### 4. Template-инъекции

Template-инъекции происходят, когда пользовательский ввод обрабатывается движком шаблонов без должной санитизации.

## Защита от SQL-инъекций

### 1. Использование подготовленных выражений (Prepared Statements)

```typescript
import { Pool } from 'pg'; // PostgreSQL

class UserService {
  private pool: Pool;
  
  constructor(pool: Pool) {
    this.pool = pool;
  }
  
  // ПЛОХО - уязвимый код
  async getUserVulnerable(username: string) {
    // Никогда не делайте так!
    const query = `SELECT * FROM users WHERE username = '${username}'`;
    const result = await this.pool.query(query);
    return result.rows;
  }
  
  // ХОРОШО - использование подготовленных выражений
  async getUserSafe(username: string) {
    // Использование параметров ($1, $2, ...) предотвращает SQL-инъекции
    const query = 'SELECT * FROM users WHERE username = $1';
    const result = await this.pool.query(query, [username]);
    return result.rows;
  }
  
  // Защита при работе с динамическими полями
  async getUsersByField(field: string, value: any) {
    // Санитизация имени поля (поскольку параметры нельзя использовать для имен полей)
    const allowedFields = ['username', 'email', 'id'];
    if (!allowedFields.includes(field)) {
      throw new Error('Недопустимое имя поля');
    }
    
    // Параметр для значения защищен подготовленным выражением
    const query = `SELECT * FROM users WHERE ${field} = $1`;
    const result = await this.pool.query(query, [value]);
    return result.rows;
  }
}
```

### 2. Использование ORM с защитой от инъекций

```typescript
import { DataSource, Repository } from 'typeorm';
import { User } from './entities/User';

class SafeUserService {
  private userRepository: Repository<User>;
  
  constructor(dataSource: DataSource) {
    this.userRepository = dataSource.getRepository(User);
  }
  
  // TypeORM автоматически экранирует параметры
  async findUserByEmail(email: string): Promise<User | null> {
    return await this.userRepository.findOne({
      where: { email: email } // Параметр автоматически экранируется
    });
  }
  
  // Защита при сложных запросах
  async findUsersWithConditions(searchTerm: string, minAge: number): Promise<User[]> {
    return await this.userRepository
      .createQueryBuilder('user')
      .where('user.email LIKE :searchTerm', { searchTerm: `%${searchTerm}%` })
      .andWhere('user.age >= :minAge', { minAge })
      .getMany();
  }
}
```

## Защита от XSS-атак

### 1. Экранирование вывода

```typescript
// Функция для экранирования HTML
function escapeHtml(text: string): string {
  const escapeMap: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };
  
  return text.replace(/[&<>"'\/]/g, (match) => escapeMap[match] || match);
}

// Пример использования в Express
import express from 'express';
const app = express();

app.get('/profile', (req, res) => {
  const userInput = req.query.name || '';
  
  // ПЛОХО - уязвимый код
  // const html = `<h1>Привет, ${userInput}!</h1>`;
  
  // ХОРОШО - экранирование пользовательского ввода
  const safeHtml = `<h1>Привет, ${escapeHtml(userInput.toString())}!</h1>`;
  
  res.send(safeHtml);
});
```

### 2. Использование шаблонизаторов с автоматическим экранированием

```typescript
// Пример с Handlebars (автоматическое экранирование)
import * as handlebars from 'handlebars';

// Шаблон автоматически экранирует переменные
const template = handlebars.compile(`
  <div class="profile">
    <h1>{{username}}</h1>
    <p>{{bio}}</p>
  </div>
`);

// Для отключения экранирования используем трипл-мсташ ({{{}}})
const unsafeTemplate = handlebars.compile(`
  <div class="content">{{{htmlContent}}}</div>  <!-- Только если htmlContent доверенный -->
`);
```

### 3. Защита в React-компонентах

```tsx
import React from 'react';

// ХОРОШО - React автоматически экранирует переменные
const UserProfile: React.FC<{ username: string; bio: string }> = ({ username, bio }) => {
  return (
    <div className="profile">
      <h1>{username}</h1> {/* Автоматически экранировано */}
      <p>{bio}</p> {/* Автоматически экранировано */}
    </div>
  );
};

// ОПАСНО - использование dangerouslySetInnerHTML
const UnsafeComponent: React.FC<{ htmlContent: string }> = ({ htmlContent }) => {
  return (
    <div 
      // Только если htmlContent был предварительно санитизирован!
      dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(htmlContent) }}
    />
  );
};
```

## Защита от Command-инъекций

### 1. Использование параметров вместо конкатенации строк

```typescript
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execPromise = promisify(exec);

// ПЛОХО - уязвимый код
async function vulnerableCommand(userInput: string) {
  // Никогда не делайте так!
  const { stdout } = await exec(`ls -la ${userInput}`);
  return stdout;
}

// ХОРОШО - использование spawn с отдельными аргументами
async function safeCommand(directory: string) {
  // Санитизация входных данных
  const sanitizedDir = directory.replace(/[^a-zA-Z0-9/_\-\.]/g, '');
  
  // Использование spawn с массивом аргументов (предотвращает инъекции)
  const ls = spawn('ls', ['-la', sanitizedDir]);
  
  return new Promise<string>((resolve, reject) => {
    let output = '';
    ls.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    ls.stderr.on('data', (data) => {
      console.error(data.toString());
    });
    
    ls.on('close', (code) => {
      if (code === 0) {
        resolve(output);
      } else {
        reject(new Error(`Команда завершилась с кодом ${code}`));
      }
    });
  });
}

// Альтернативный подход - белый список разрешенных значений
async function restrictedCommand(action: string) {
  const allowedActions = {
    'list': ['ls', '-la'],
    'disk-usage': ['du', '-sh'],
    'find-large-files': ['find', '.', '-size', '+100M', '-type', 'f']
  };
  
  if (!allowedActions[action as keyof typeof allowedActions]) {
    throw new Error('Недопустимое действие');
  }
  
  const args = allowedActions[action as keyof typeof allowedActions];
  const ls = spawn(args[0], args.slice(1));
  
  // Обработка результата...
}
```

### 2. Санитизация аргументов командной строки

```typescript
// Функция для безопасного формирования аргументов командной строки
function sanitizeCommandLineArgs(args: string[]): string[] {
  return args.map(arg => {
    // Удаляем потенциально опасные символы
    return arg
      .replace(/[;&|`$(){}[\]<>]/g, '') // Удаляем специальные символы командной строки
      .trim();
  });
}

// Использование с валидацией
async function safeFileOperation(filename: string) {
  // Проверяем, что имя файла не содержит относительных путей
  if (filename.includes('..') || filename.startsWith('/')) {
    throw new Error('Недопустимое имя файла');
  }
  
  // Санитизируем имя файла
  const sanitizedFilename = sanitizeCommandLineArgs([filename])[0];
  
  // Используем spawn с безопасными аргументами
  const cat = spawn('cat', [sanitizedFilename]);
  
  // Обработка результата...
}
```

## Защита от Template-инъекций

### 1. Использование безопасных шаблонизаторов

```typescript
// Пример с EJS - используем экранирование по умолчанию
// В шаблоне: <%= variable %> - экранированное значение
// В шаблоне: <%- variable %> - неэкранированное значение (только для доверенных данных)

// Пример с безопасной обработкой пользовательских шаблонов
import vm from 'vm';

// Функция для безопасной оценки выражений в песочнице
function safeTemplateEval(template: string, data: Record<string, any>): string {
  // Белый список разрешенных функций
  const sandbox = {
    data: data,
    // Только безопасные функции
    JSON: JSON,
    Math: Math,
    // Добавляем другие безопасные функции при необходимости
  };
  
  // Компилируем шаблон в безопасной среде
  const script = new vm.Script(`
    (function(data) {
      with(data) {
        return \`${template}\`;
      }
    })(data)
  `);
  
  // Выполняем в изолированной среде
  const context = vm.createContext(sandbox);
  return script.runInContext(context);
}
```

## Общие рекомендации по защите от инъекций

### 1. Принцип наименьших привилегий

```typescript
// Пример настройки соединения с базой данных с ограниченными правами
const dbConfig = {
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  username: 'app_user', // Не root!
  password: process.env.DB_PASSWORD,
  // Пользователь БД должен иметь только необходимые права
  // SELECT, INSERT, UPDATE, DELETE для конкретных таблиц
  // Но НЕ должен иметь права: DROP, CREATE, ALTER, GRANT
};
```

### 2. Централизованная обработка пользовательского ввода

```typescript
// Централизованный класс для обработки пользовательского ввода
class InputProcessor {
  // Метод для безопасной обработки строк
  static sanitizeString(
    input: string, 
    options: {
      maxLength?: number;
      allowedPattern?: RegExp;
      default?: string;
    } = {}
  ): string {
    let result = input || options.default || '';
    
    if (options.maxLength) {
      result = result.substring(0, options.maxLength);
    }
    
    if (options.allowedPattern) {
      result = result.replace(new RegExp(`[^${options.allowedPattern.source}]`, 'g'), '');
    }
    
    return result.trim();
  }
  
  // Метод для безопасной обработки чисел
  static sanitizeNumber(
    input: any, 
    options: {
      min?: number;
      max?: number;
      default?: number;
    } = {}
  ): number {
    const num = Number(input);
    
    if (isNaN(num)) {
      return options.default ?? 0;
    }
    
    if (options.min !== undefined && num < options.min) {
      return options.min;
    }
    
    if (options.max !== undefined && num > options.max) {
      return options.max;
    }
    
    return num;
  }
  
  // Метод для безопасной обработки объектов
  static sanitizeObject<T>(
    input: any, 
    schema: Record<string, (value: any) => any>
  ): Partial<T> {
    const result: Partial<T> = {};
    
    for (const [key, sanitizer] of Object.entries(schema)) {
      if (input && typeof input === 'object' && key in input) {
        result[key as keyof T] = sanitizer(input[key]);
      }
    }
    
    return result;
  }
}

// Использование в контроллере
class UserController {
  async createUser(req: express.Request, res: express.Response) {
    const userData = InputProcessor.sanitizeObject(req.body, {
      email: (val) => InputProcessor.sanitizeString(val, { 
        maxLength: 254, 
        allowedPattern: /^[a-zA-Z0-9@._-]+$/ 
      }),
      age: (val) => InputProcessor.sanitizeNumber(val, { min: 0, max: 120 }),
      username: (val) => InputProcessor.sanitizeString(val, { 
        maxLength: 30, 
        allowedPattern: /^[a-zA-Z0-9_]+$/ 
      })
    });
    
    // Используем санитизированные данные
    // ...
  }
}
```

## Интеграция с другими аспектами безопасности

Защита от инъекций тесно связана с:
- [[Санитизация]] - защита от инъекций часто включает санитизацию данных
- [[Валидация-входных-данных]] - валидация помогает предотвратить инъекции
- [[Типизация-данных]] - правильная типизация может помочь избежать некоторых видов инъекций

## Заключение

Защита от инъекций в TypeScript требует комплексного подхода, включающего:
1. Использование безопасных методов для работы с внешними системами
2. Санитизацию и валидацию всех входных данных
3. Применение принципа наименьших привилегий
4. Регулярное тестирование на уязвимости
5. Использование проверенных библиотек и инструментов

Ключ к эффективной защите - это не доверять никаким внешним данным и всегда обрабатывать их безопасным образом.