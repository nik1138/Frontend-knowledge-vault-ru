---
aliases: [Файловая система TypeScript, Работа с файлами в Node.js]
tags: [typescript, nodejs, fs, файлы]
---

# Работа с файлами в Node.js с TypeScript

## Введение

Работа с файловой системой - важная часть разработки серверных приложений. Node.js предоставляет встроенный модуль `fs` для работы с файлами, а TypeScript добавляет строгую типизацию к этим операциям. В этом руководстве мы рассмотрим различные аспекты работы с файлами в Node.js с использованием TypeScript.

## Импорт модуля fs

Для работы с файлами в TypeScript мы импортируем модуль `fs`:

```typescript
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
```

## Синхронные и асинхронные операции

Все операции с файлами в Node.js доступны в синхронном и асинхронном вариантах. Рекомендуется использовать асинхронные методы, чтобы избежать блокировки потока выполнения.

### Синхронные операции

```typescript
import * as fs from 'fs';
import * as path from 'path';

// Чтение файла синхронно
try {
  const data = fs.readFileSync(path.join(__dirname, 'data.txt'), 'utf8');
  console.log('Содержимое файла:', data);
} catch (err) {
  console.error('Ошибка при чтении файла:', err);
}

// Запись в файл синхронно
try {
  fs.writeFileSync(path.join(__dirname, 'output.txt'), 'Привет, TypeScript!', 'utf8');
  console.log('Файл успешно записан');
} catch (err) {
  console.error('Ошибка при записи файла:', err);
}
```

### Асинхронные операции с коллбэками

```typescript
import * as fs from 'fs';
import * as path from 'path';

// Чтение файла асинхронно
fs.readFile(path.join(__dirname, 'data.txt'), 'utf8', (err, data) => {
  if (err) {
    console.error('Ошибка при чтении файла:', err);
    return;
  }
  console.log('Содержимое файла:', data);
});

// Запись в файл асинхронно
fs.writeFile(path.join(__dirname, 'output.txt'), 'Привет, TypeScript!', 'utf8', (err) => {
  if (err) {
    console.error('Ошибка при записи файла:', err);
    return;
  }
  console.log('Файл успешно записан');
});
```

## Использование промисов

С Node.js 10+ модуль `fs` предоставляет версии методов, возвращающие промисы:

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

async function readFileExample(): Promise<void> {
  try {
    const data = await fs.readFile(path.join(__dirname, 'data.txt'), 'utf8');
    console.log('Содержимое файла:', data);
  } catch (err) {
    console.error('Ошибка при чтении файла:', err);
  }
}

async function writeFileExample(): Promise<void> {
  try {
    await fs.writeFile(path.join(__dirname, 'output.txt'), 'Привет, TypeScript!', 'utf8');
    console.log('Файл успешно записан');
  } catch (err) {
    console.error('Ошибка при записи файла:', err);
  }
}

// Вызов асинхронных функций
readFileExample();
writeFileExample();
```

## Типизация операций с файлами

TypeScript предоставляет строгую типизацию для операций с файлами:

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

interface User {
  id: number;
  name: string;
  email: string;
}

// Функция для чтения и парсинга JSON файла
async function readUsersFromFile(filePath: string): Promise<User[]> {
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const users: User[] = JSON.parse(fileContent);
    return users;
  } catch (err) {
    console.error('Ошибка при чтении пользователей:', err);
    throw err;
  }
}

// Функция для записи пользователей в JSON файл
async function writeUsersToFile(users: User[], filePath: string): Promise<void> {
  try {
    const fileContent = JSON.stringify(users, null, 2);
    await fs.writeFile(filePath, fileContent, 'utf8');
  } catch (err) {
    console.error('Ошибка при записи пользователей:', err);
    throw err;
  }
}

// Пример использования
async function example(): Promise<void> {
  const users: User[] = [
    { id: 1, name: 'Иван', email: 'ivan@example.com' },
    { id: 2, name: 'Мария', email: 'maria@example.com' }
  ];

  await writeUsersToFile(users, path.join(__dirname, 'users.json'));
  const loadedUsers = await readUsersFromFile(path.join(__dirname, 'users.json'));
  console.log('Загруженные пользователи:', loadedUsers);
}
```

## Работа с директориями

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

// Создание директории
async function createDirectory(dirPath: string): Promise<void> {
  try {
    await fs.mkdir(dirPath, { recursive: true });
    console.log(`Директория ${dirPath} создана`);
  } catch (err) {
    console.error('Ошибка при создании директории:', err);
  }
}

// Чтение содержимого директории
async function readDirectory(dirPath: string): Promise<string[]> {
  try {
    const files = await fs.readdir(dirPath);
    return files;
  } catch (err) {
    console.error('Ошибка при чтении директории:', err);
    throw err;
  }
}

// Удаление директории
async function removeDirectory(dirPath: string): Promise<void> {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
    console.log(`Директория ${dirPath} удалена`);
  } catch (err) {
    console.error('Ошибка при удалении директории:', err);
  }
}
```

## Проверка существования файлов

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

// Проверка существования файла
async function checkFileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

// Проверка прав доступа к файлу
async function checkFilePermissions(filePath: string): Promise<{ readable: boolean; writable: boolean }> {
  try {
    await fs.access(filePath, fs.constants.R_OK);
    const readable = true;
    
    try {
      await fs.access(filePath, fs.constants.W_OK);
      return { readable, writable: true };
    } catch {
      return { readable, writable: false };
    }
  } catch {
    return { readable: false, writable: false };
  }
}
```

## Работа с потоками (streams)

Для работы с большими файлами рекомендуется использовать потоки:

```typescript
import * as fs from 'fs';
import * as path from 'path';
import { Transform, pipeline } from 'stream';
import { promisify } from 'util';

const pipelineAsync = promisify(pipeline);

// Трансформационный поток для изменения регистра текста
class UpperCaseTransform extends Transform {
  _transform(chunk: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {
    const upperChunk = chunk.toString().toUpperCase();
    callback(null, upperChunk);
  }
}

// Копирование файла с преобразованием регистра
async function copyFileWithTransform(
  sourcePath: string, 
  destinationPath: string
): Promise<void> {
  try {
    const sourceStream = fs.createReadStream(sourcePath);
    const transformStream = new UpperCaseTransform();
    const destinationStream = fs.createWriteStream(destinationPath);

    await pipelineAsync(
      sourceStream,
      transformStream,
      destinationStream
    );

    console.log('Файл скопирован с преобразованием регистра');
  } catch (err) {
    console.error('Ошибка при копировании файла:', err);
  }
}
```

## Обработка ошибок

Важно правильно обрабатывать ошибки при работе с файлами:

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

enum FileOperationError {
  FILE_NOT_FOUND = 'FILE_NOT_FOUND',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  INVALID_JSON = 'INVALID_JSON',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

interface FileOperationResult<T> {
  success: boolean;
  data?: T;
  error?: FileOperationError;
  message?: string;
}

async function safeReadFile<T>(
  filePath: string,
  parser?: (content: string) => T
): Promise<FileOperationResult<T>> {
  try {
    const content = await fs.readFile(filePath, 'utf8');
    
    if (parser) {
      try {
        const parsedData = parser(content);
        return { success: true, data: parsedData };
      } catch (parseErr) {
        return { 
          success: false, 
          error: FileOperationError.INVALID_JSON,
          message: 'Неверный формат JSON' 
        };
      }
    }
    
    return { success: true, data: content as unknown as T };
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      return { 
        success: false, 
        error: FileOperationError.FILE_NOT_FOUND,
        message: 'Файл не найден' 
      };
    } else if ((err as NodeJS.ErrnoException).code === 'EACCES') {
      return { 
        success: false, 
        error: FileOperationError.PERMISSION_DENIED,
        message: 'Нет доступа к файлу' 
      };
    }
    
    return { 
      success: false, 
      error: FileOperationError.UNKNOWN_ERROR,
      message: (err as Error).message 
    };
  }
}
```

## Примеры использования

```typescript
// Пример: загрузка конфигурации из JSON файла
interface Config {
  port: number;
  host: string;
  database: {
    url: string;
    name: string;
  };
}

async function loadConfig(): Promise<Config | null> {
  const result = await safeReadFile<Config>(
    path.join(__dirname, 'config.json'),
    JSON.parse
  );
  
  if (result.success) {
    return result.data;
  } else {
    console.error('Ошибка при загрузке конфигурации:', result.message);
    return null;
  }
}

// Пример: сохранение логов в файл
async function appendLog(logMessage: string, logFile: string): Promise<void> {
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] ${logMessage}\n`;
  
  try {
    await fs.appendFile(logFile, logEntry, 'utf8');
  } catch (err) {
    console.error('Ошибка при записи лога:', err);
  }
}
```

## Заключение

Работа с файлами в Node.js с TypeScript обеспечивает безопасность типов и лучшую поддержку кода. Использование асинхронных операций, правильная обработка ошибок и типизация делают приложения более надежными и удобными для разработки.

## См. также

- [[Настройка-окружения]]
- [[Express-с-TypeScript]]
- [[Подключение-к-базам-данных]]
- [[Работа с файлами в асинхронном режиме]]
- [[Потоки в Node.js]]