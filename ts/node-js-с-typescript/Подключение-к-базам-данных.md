---
aliases: [Базы данных TypeScript, Подключение к БД в Node.js]
tags: [typescript, nodejs, database, mongodb, postgresql, mysql]
---

# Подключение к базам данных в Node.js с TypeScript

## Введение

Подключение к базам данных - важная часть любого серверного приложения. В этом руководстве мы рассмотрим, как подключаться к различным типам баз данных с использованием TypeScript, включая MongoDB, PostgreSQL, MySQL и SQLite. TypeScript обеспечивает строгую типизацию для запросов к базе данных и результатов.

## Установка зависимостей

Для подключения к различным базам данных установим соответствующие драйверы:

```bash
# Для MongoDB
npm install mongodb @types/mongodb

# Для PostgreSQL
npm install pg @types/pg

# Для MySQL
npm install mysql2 @types/mysql2

# Для SQLite
npm install sqlite3 @types/sqlite3

# Альтернатива для SQLite с лучшей поддержкой TypeScript
npm install better-sqlite3

# Для использования ORM
npm install typeorm reflect-metadata
# или
npm install sequelize @types/sequelize
```

## Подключение к MongoDB

### Установка и настройка

MongoDB - популярная NoSQL база данных. Вот как подключиться к ней с использованием TypeScript:

```typescript
// src/database/mongodb.ts
import { MongoClient, Db, Collection } from 'mongodb';

interface User {
  _id?: string;
  name: string;
  email: string;
  createdAt: Date;
}

class MongoDatabase {
  private client: MongoClient;
  private db: Db;
  private usersCollection: Collection<User>;

  constructor(private uri: string, private dbName: string) {
    this.client = new MongoClient(uri);
    this.usersCollection = this.db.collection<User>('users');
  }

  async connect(): Promise<void> {
    try {
      await this.client.connect();
      this.db = this.client.db(this.dbName);
      this.usersCollection = this.db.collection<User>('users');
      console.log('Подключено к MongoDB');
    } catch (error) {
      console.error('Ошибка подключения к MongoDB:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    await this.client.close();
  }

  async createUser(userData: Omit<User, '_id'>): Promise<User> {
    const user: User = {
      ...userData,
      createdAt: new Date()
    };
    
    const result = await this.usersCollection.insertOne(user);
    user._id = result.insertedId.toString();
    return user;
  }

  async getUserById(id: string): Promise<User | null> {
    const user = await this.usersCollection.findOne({ _id: id });
    return user;
  }

  async getAllUsers(): Promise<User[]> {
    const users = await this.usersCollection.find({}).toArray();
    return users;
  }

  async updateUser(id: string, updateData: Partial<User>): Promise<boolean> {
    const result = await this.usersCollection.updateOne(
      { _id: id },
      { $set: updateData }
    );
    return result.modifiedCount > 0;
  }

  async deleteUser(id: string): Promise<boolean> {
    const result = await this.usersCollection.deleteOne({ _id: id });
    return result.deletedCount > 0;
  }
}

export default MongoDatabase;
```

## Подключение к PostgreSQL

### Настройка подключения

PostgreSQL - мощная реляционная база данных. Вот пример подключения с использованием TypeScript:

```typescript
// src/database/postgresql.ts
import { Pool, PoolClient, QueryResult } from 'pg';

interface User {
  id: number;
  name: string;
  email: string;
  created_at: Date;
}

class PostgreSQLDatabase {
  private pool: Pool;

  constructor(
    private config: {
      host: string;
      port: number;
      database: string;
      user: string;
      password: string;
    }
  ) {
    this.pool = new Pool(config);
  }

  async connect(): Promise<void> {
    try {
      const client = await this.pool.connect();
      console.log('Подключено к PostgreSQL');
      client.release();
    } catch (error) {
      console.error('Ошибка подключения к PostgreSQL:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    await this.pool.end();
  }

  async createUser(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {
    const query = `
      INSERT INTO users (name, email, created_at) 
      VALUES ($1, $2, $3) 
      RETURNING id, name, email, created_at
    `;
    
    const values = [userData.name, userData.email, new Date()];
    
    const result: QueryResult<User> = await this.pool.query(query, values);
    return result.rows[0];
  }

  async getUserById(id: number): Promise<User | null> {
    const query = 'SELECT id, name, email, created_at FROM users WHERE id = $1';
    const result: QueryResult<User> = await this.pool.query(query, [id]);
    
    return result.rows.length > 0 ? result.rows[0] : null;
  }

  async getAllUsers(): Promise<User[]> {
    const query = 'SELECT id, name, email, created_at FROM users ORDER BY id';
    const result: QueryResult<User> = await this.pool.query(query);
    return result.rows;
  }

  async updateUser(id: number, updateData: Partial<User>): Promise<boolean> {
    const fields = Object.keys(updateData);
    if (fields.length === 0) return false;

    const setClause = fields.map((field, index) => `${field} = $${index + 2}`).join(', ');
    const values = [id, ...Object.values(updateData)];
    
    const query = `UPDATE users SET ${setClause} WHERE id = $1 RETURNING id`;
    
    try {
      const result: QueryResult = await this.pool.query(query, values);
      return result.rows.length > 0;
    } catch (error) {
      console.error('Ошибка обновления пользователя:', error);
      return false;
    }
  }

  async deleteUser(id: number): Promise<boolean> {
    const query = 'DELETE FROM users WHERE id = $1 RETURNING id';
    const result: QueryResult = await this.pool.query(query, [id]);
    return result.rows.length > 0;
  }

  async executeTransaction<T>(transaction: (client: PoolClient) => Promise<T>): Promise<T> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      const result = await transaction(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}

export default PostgreSQLDatabase;
```

## Подключение к MySQL

### Настройка подключения

MySQL - еще одна популярная реляционная база данных:

```typescript
// src/database/mysql.ts
import mysql from 'mysql2/promise';

interface User {
  id: number;
  name: string;
  email: string;
  created_at: Date;
}

class MySQLDatabase {
  private connection: mysql.Connection;

  constructor(
    private config: {
      host: string;
      port: number;
      database: string;
      user: string;
      password: string;
    }
  ) {}

  async connect(): Promise<void> {
    try {
      this.connection = await mysql.createConnection(this.config);
      console.log('Подключено к MySQL');
    } catch (error) {
      console.error('Ошибка подключения к MySQL:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    if (this.connection) {
      await this.connection.end();
    }
  }

  async createUser(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {
    const query = 'INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)';
    const values = [userData.name, userData.email, new Date()];
    
    const [result] = await this.connection.execute(query, values);
    
    const insertId = (result as mysql.OkPacket).insertId;
    
    const selectQuery = 'SELECT id, name, email, created_at FROM users WHERE id = ?';
    const [rows] = await this.connection.execute(selectQuery, [insertId]);
    
    if (Array.isArray(rows) && rows.length > 0) {
      return rows[0] as User;
    }
    
    throw new Error('Не удалось получить созданного пользователя');
  }

  async getUserById(id: number): Promise<User | null> {
    const query = 'SELECT id, name, email, created_at FROM users WHERE id = ?';
    const [rows] = await this.connection.execute(query, [id]);
    
    if (Array.isArray(rows) && rows.length > 0) {
      return rows[0] as User;
    }
    
    return null;
  }

  async getAllUsers(): Promise<User[]> {
    const query = 'SELECT id, name, email, created_at FROM users ORDER BY id';
    const [rows] = await this.connection.execute(query);
    
    return Array.isArray(rows) ? rows as User[] : [];
  }

  async updateUser(id: number, updateData: Partial<User>): Promise<boolean> {
    const fields = Object.keys(updateData);
    if (fields.length === 0) return false;

    const setClause = fields.map(field => `${field} = ?`).join(', ');
    const values = [...Object.values(updateData), id];
    
    const query = `UPDATE users SET ${setClause} WHERE id = ?`;
    
    try {
      const [result] = await this.connection.execute(query, values);
      return (result as mysql.OkPacket).affectedRows > 0;
    } catch (error) {
      console.error('Ошибка обновления пользователя:', error);
      return false;
    }
  }

  async deleteUser(id: number): Promise<boolean> {
    const query = 'DELETE FROM users WHERE id = ?';
    const [result] = await this.connection.execute(query, [id]);
    return (result as mysql.OkPacket).affectedRows > 0;
  }
}

export default MySQLDatabase;
```

## Подключение к SQLite

### Использование better-sqlite3

SQLite - легковесная встраиваемая база данных:

```typescript
// src/database/sqlite.ts
import Database from 'better-sqlite3';

interface User {
  id: number;
  name: string;
  email: string;
  created_at: Date;
}

class SQLiteDatabase {
  private db: Database.Database;

  constructor(databasePath: string) {
    this.db = new Database(databasePath);
    this.init();
  }

  private init(): void {
    // Создание таблицы пользователей, если она не существует
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
  }

  async createUser(userData: Omit<User, 'id' | 'created_at'>): Promise<User> {
    const stmt = this.db.prepare(
      'INSERT INTO users (name, email, created_at) VALUES (?, ?, ?)'
    );
    
    const info = stmt.run(userData.name, userData.email, new Date());
    
    const selectStmt = this.db.prepare(
      'SELECT id, name, email, created_at FROM users WHERE id = ?'
    );
    
    const user = selectStmt.get(info.lastInsertRowid) as User;
    return user;
  }

  async getUserById(id: number): Promise<User | null> {
    const stmt = this.db.prepare(
      'SELECT id, name, email, created_at FROM users WHERE id = ?'
    );
    
    const user = stmt.get(id) as User | undefined;
    return user || null;
  }

  async getAllUsers(): Promise<User[]> {
    const stmt = this.db.prepare(
      'SELECT id, name, email, created_at FROM users ORDER BY id'
    );
    
    const users = stmt.all() as User[];
    return users;
  }

  async updateUser(id: number, updateData: Partial<User>): Promise<boolean> {
    const fields = Object.keys(updateData);
    if (fields.length === 0) return false;

    const setClause = fields.map(field => `${field} = ?`).join(', ');
    const values = [...Object.values(updateData), id];
    
    const query = `UPDATE users SET ${setClause} WHERE id = ?`;
    const stmt = this.db.prepare(query);
    
    const result = stmt.run(...values);
    return result.changes > 0;
  }

  async deleteUser(id: number): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM users WHERE id = ?');
    const result = stmt.run(id);
    return result.changes > 0;
  }

  async executeTransaction<T>(transaction: () => T): Promise<T> {
    const transactionFn = this.db.transaction(transaction);
    return transactionFn();
  }

  close(): void {
    this.db.close();
  }
}

export default SQLiteDatabase;
```

## Использование ORM (TypeORM)

### Настройка TypeORM

TypeORM - популярный ORM для TypeScript:

```typescript
// src/database/typeorm.ts
import { 
  Entity, 
  Column, 
  PrimaryGeneratedColumn, 
  CreateDateColumn, 
  UpdateDateColumn,
  DataSource 
} from 'typeorm';

@Entity('users')
export class UserEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 100 })
  name: string;

  @Column({ type: 'varchar', unique: true })
  email: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}

// Конфигурация подключения
const AppDataSource = new DataSource({
  type: 'postgres', // или 'mysql', 'sqlite', 'mongodb' и т.д.
  host: 'localhost',
  port: 5432,
  username: 'your_username',
  password: 'your_password',
  database: 'your_database',
  synchronize: true, // Только для разработки
  logging: false,
  entities: [UserEntity],
  migrations: [],
  subscribers: [],
});

export async function initializeDatabase(): Promise<void> {
  try {
    await AppDataSource.initialize();
    console.log('TypeORM подключен к базе данных');
  } catch (error) {
    console.error('Ошибка подключения к базе данных:', error);
    throw error;
  }
}

export { AppDataSource };
```

## Управление подключениями

### Пул подключений

Для производительных приложений рекомендуется использовать пулы подключений:

```typescript
// src/database/connectionPool.ts
import PostgreSQLDatabase from './postgresql';
import MySQLDatabase from './mysql';
import SQLiteDatabase from './sqlite';
import MongoDatabase from './mongodb';

type DatabaseType = 'postgresql' | 'mysql' | 'sqlite' | 'mongodb';

interface DatabaseConfig {
  type: DatabaseType;
  [key: string]: any;
}

class DatabaseManager {
  private databases: Map<DatabaseType, any> = new Map();

  async connect(config: DatabaseConfig): Promise<void> {
    const { type, ...dbConfig } = config;
    
    switch (type) {
      case 'postgresql':
        const postgresDb = new PostgreSQLDatabase(dbConfig);
        await postgresDb.connect();
        this.databases.set(type, postgresDb);
        break;
        
      case 'mysql':
        const mysqlDb = new MySQLDatabase(dbConfig);
        await mysqlDb.connect();
        this.databases.set(type, mysqlDb);
        break;
        
      case 'sqlite':
        const sqliteDb = new SQLiteDatabase(dbConfig.path);
        this.databases.set(type, sqliteDb);
        break;
        
      case 'mongodb':
        const mongoDb = new MongoDatabase(dbConfig.uri, dbConfig.dbName);
        await mongoDb.connect();
        this.databases.set(type, mongoDb);
        break;
        
      default:
        throw new Error(`Неподдерживаемый тип базы данных: ${type}`);
    }
  }

  getDatabase(type: DatabaseType): any {
    const db = this.databases.get(type);
    if (!db) {
      throw new Error(`База данных ${type} не подключена`);
    }
    return db;
  }

  async disconnectAll(): Promise<void> {
    for (const [type, db] of this.databases) {
      if (typeof db.disconnect === 'function') {
        await db.disconnect();
      } else if (typeof db.close === 'function') {
        db.close();
      }
    }
    this.databases.clear();
  }
}

export default DatabaseManager;
```

## Заключение

Подключение к базам данных в Node.js с TypeScript обеспечивает безопасность типов и улучшает качество кода. Выбор базы данных зависит от конкретных требований проекта - NoSQL для гибкости или SQL для структурированных данных и сложных запросов.

## См. также

- [[Настройка-окружения]]
- [[Express-с-TypeScript]]
- [[Работа-с-файлами]]
- [[Типизация-API]]
- [[ORM в TypeScript]]