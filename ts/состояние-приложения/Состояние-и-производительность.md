---
aliases: [Состояние и производительность, State and Performance]
tags: [typescript, state-management, performance, optimization]
---

# Состояние и производительность

## Введение

Производительность управления состоянием - критический аспект разработки современных приложений. Неправильное управление состоянием может привести к избыточным перерендерингам, утечкам памяти и снижению отзывчивости интерфейса. В этой статье мы рассмотрим, как оптимизировать производительность при работе с состоянием в TypeScript-приложениях.

## Проблемы производительности при управлении состоянием

### 1. Избыточные перерендеринги

Избыточные перерендеринги происходят, когда компоненты обновляются даже при отсутствии изменений в их зависимостях:

```typescript
import React, { useState, useEffect } from 'react';

// ПЛОХО: Компонент будет перерендериваться при каждом изменении состояния приложения
const BadComponent: React.FC = () => {
  const [state, setState] = useState({ count: 0, user: { name: 'John' } });
  
  // Это приведет к перерендерингу при любом изменении состояния
  useEffect(() => {
    console.log('Компонент перерендерился');
  });
  
  return <div>Счетчик: {state.count}</div>;
};

// ХОРОШО: Разделение состояния для минимизации перерендерингов
const GoodComponent: React.FC = () => {
  const [count, setCount] = useState(0);
  const [user] = useState({ name: 'John' }); // Не изменяется, можно вынести
  
  useEffect(() => {
    console.log('Компонент перерендерился только при изменении count');
  }, [count]); // Зависимость только от count
  
  return <div>Счетник: {count}</div>;
};
```

### 2. Глубокие изменения состояния

Изменение вложенных объектов может привести к ненужным перерендерингам:

```typescript
// ПЛОХО: Мутация объекта может привести к непредсказуемому поведению
const badUpdate = (state: any) => {
  state.user.profile.age = 30; // Мутация
  return state;
};

// ХОРОШО: Создание нового объекта с помощью иммутабельных операций
const goodUpdate = (state: any) => {
  return {
    ...state,
    user: {
      ...state.user,
      profile: {
        ...state.user.profile,
        age: 30
      }
    }
  };
};

// Использование библиотеки immer для упрощения иммутабельных операций
import { produce } from 'immer';

const immerUpdate = (state: any) => {
  return produce(state, (draft) => {
    draft.user.profile.age = 30;
  });
};
```

### 3. Неправильное использование глобального состояния

Использование глобального состояния для данных, которые нужны только в одном компоненте:

```typescript
// ПЛОХО: Хранение локальных данных в глобальном состоянии
interface GlobalState {
  modalOpen: boolean; // Локальное состояние модального окна
  theme: string; // Глобальное состояние
  user: User | null;
}

// ХОРОШО: Разделение локального и глобального состояния
interface GlobalState {
  theme: string;
  user: User | null;
}

// Локальное состояние в компоненте
const ModalComponent: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false); // Локальное состояние
  
  return (
    <div style={{ display: isOpen ? 'block' : 'none' }}>
      {/* Содержимое модального окна */}
    </div>
  );
};
```

## Оптимизация производительности

### 1. Использование React.memo

React.memo предотвращает перерендеринг компонента, если его пропсы не изменились:

```typescript
import React, { memo, useState } from 'react';

interface UserCardProps {
  user: {
    id: number;
    name: string;
    email: string;
  };
  onEdit: (id: number) => void;
}

// Компонент, оптимизированный с помощью memo
const UserCard: React.FC<UserCardProps> = memo(({ user, onEdit }) => {
  console.log(`Рендер UserCard для ${user.name}`);
  
  return (
    <div>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Редактировать</button>
    </div>
  );
});

// Использование оптимизированного компонента
const UserList: React.FC = () => {
  const [users, setUsers] = useState([
    { id: 1, name: 'John', email: 'john@example.com' },
    { id: 2, name: 'Jane', email: 'jane@example.com' },
  ]);
  
  const [filter, setFilter] = useState('');
  
  const handleEdit = (id: number) => {
    // Логика редактирования
  };
  
  const filteredUsers = users.filter(user => 
    user.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    <div>
      <input 
        type="text" 
        value={filter} 
        onChange={(e) => setFilter(e.target.value)} 
        placeholder="Фильтр по имени"
      />
      {filteredUsers.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onEdit={handleEdit} 
        />
      ))}
    </div>
  );
};
```

### 2. Использование useMemo и useCallback

useMemo и useCallback помогают избежать ненужных вычислений и создание новых функций:

```typescript
import React, { useState, useMemo, useCallback } from 'react';

interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
}

const ProductList: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([
    { id: 1, name: 'Товар 1', price: 100, category: 'электроника' },
    { id: 2, name: 'Товар 2', price: 200, category: 'одежда' },
    { id: 3, name: 'Товар 3', price: 150, category: 'электроника' },
  ]);
  
  const [categoryFilter, setCategoryFilter] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState<'name' | 'price'>('name');
  
  // Оптимизированная фильтрация и сортировка
  const filteredAndSortedProducts = useMemo(() => {
    console.log('Пересчет filteredAndSortedProducts');
    
    let result = [...products];
    
    if (categoryFilter) {
      result = result.filter(product => product.category === categoryFilter);
    }
    
    result.sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      } else {
        return a.price - b.price;
      }
    });
    
    return result;
  }, [products, categoryFilter, sortBy]);
  
  // Оптимизированная функция добавления продукта
  const handleAddProduct = useCallback((product: Product) => {
    setProducts(prev => [...prev, product]);
  }, []);
  
  // Оптимизированная функция удаления продукта
  const handleDeleteProduct = useCallback((id: number) => {
    setProducts(prev => prev.filter(product => product.id !== id));
  }, []);
  
  return (
    <div>
      <div>
        <button onClick={() => setCategoryFilter('электроника')}>Электроника</button>
        <button onClick={() => setCategoryFilter('одежда')}>Одежда</button>
        <button onClick={() => setCategoryFilter(null)}>Все</button>
      </div>
      <div>
        <button onClick={() => setSortBy('name')}>Сортировать по имени</button>
        <button onClick={() => setSortBy('price')}>Сортировать по цене</button>
      </div>
      <ul>
        {filteredAndSortedProducts.map(product => (
          <li key={product.id}>
            {product.name} - {product.price}р
            <button onClick={() => handleDeleteProduct(product.id)}>
              Удалить
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### 3. Оптимизация Redux-приложений

#### Селекторы и reselect

Использование селекторов для избежания ненужных вычислений:

```typescript
import { createSelector } from 'reselect';

// Основные селекторы
const getUsers = (state: RootState) => state.users;
const getFilter = (state: RootState) => state.filter;

// Мемоизированный селектор
const getFilteredUsers = createSelector(
  [getUsers, getFilter],
  (users, filter) => {
    console.log('Пересчет filtered users');
    return users.filter(user => 
      user.name.toLowerCase().includes(filter.toLowerCase())
    );
  }
);

// Селектор с дополнительными вычислениями
const getUserStats = createSelector(
  [getUsers],
  (users) => {
    return {
      total: users.length,
      active: users.filter(u => u.active).length,
      inactive: users.filter(u => !u.active).length
    };
  }
);

// Использование в компоненте
const UserComponent: React.FC = () => {
  const filteredUsers = useSelector(getFilteredUsers);
  const userStats = useSelector(getUserStats);
  
  return (
    <div>
      <p>Всего пользователей: {userStats.total}</p>
      <p>Активных: {userStats.active}</p>
      <ul>
        {filteredUsers.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
};
```

#### Middleware для оптимизации

```typescript
import { Middleware } from 'redux';

// Middleware для логирования производительности
const performanceMiddleware: Middleware = (store) => (next) => (action) => {
  const startTime = performance.now();
  const result = next(action);
  const endTime = performance.now();
  
  if (endTime - startTime > 16) { // Если действие занимает больше 16мс
    console.warn(`Действие ${action.type} заняло ${endTime - startTime}мс`);
  }
  
  return result;
};

// Middleware для батчинга действий
const batchingMiddleware: Middleware = (store) => (next) => (action) => {
  if (Array.isArray(action)) {
    return action.forEach(a => next(a));
  }
  return next(action);
};
```

### 4. Оптимизация Zustand

```typescript
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface User {
  id: number;
  name: string;
  email: string;
  role: string;
}

interface AppState {
  users: User[];
  currentUser: User | null;
  addUser: (user: User) => void;
  removeUser: (id: number) => void;
  setCurrentUser: (id: number) => void;
  // Селекторы для оптимизации
  getUserById: (id: number) => User | undefined;
  getAdminUsers: () => User[];
}

const useAppStore = create<AppState>()(
  subscribeWithSelector((set, get) => ({
    users: [],
    currentUser: null,
    
    addUser: (user) => set((state) => ({
      users: [...state.users, user]
    })),
    
    removeUser: (id) => set((state) => ({
      users: state.users.filter(u => u.id !== id)
    })),
    
    setCurrentUser: (id) => set((state) => ({
      currentUser: state.users.find(u => u.id === id) || null
    })),
    
    // Селекторы для избежания ненужных вычислений
    getUserById: (id) => get().users.find(u => u.id === id),
    
    getAdminUsers: () => get().users.filter(u => u.role === 'admin'),
  }))
);

// Использование селекторов в компонентах для оптимизации
const UserList: React.FC = () => {
  const users = useAppStore(state => state.users); // Только для чтения списка
  const addUser = useAppStore(state => state.addUser);
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};

const AdminList: React.FC = () => {
  // Используем мемоизированный селектор
  const adminUsers = useAppStore(state => state.getAdminUsers());
  
  return (
    <div>
      <h3>Администраторы:</h3>
      {adminUsers.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};
```

### 5. Оптимизация с помощью виртуального скроллинга

Для списков с большим количеством элементов:

```typescript
import React, { useState, useCallback } from 'react';

interface ListItem {
  id: number;
  content: string;
}

const VirtualList: React.FC = () => {
  const [items] = useState<ListItem[]>(
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      content: `Элемент ${i}`
    }))
  );
  
  const [scrollTop, setScrollTop] = useState(0);
  const itemHeight = 50;
  const visibleCount = 10; // Количество видимых элементов
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  
  const visibleItems = items.slice(startIndex, endIndex);
  
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);
  
  return (
    <div 
      style={{ height: '500px', overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: `${items.length * itemHeight}px`, position: 'relative' }}>
        <div 
          style={{ 
            position: 'absolute', 
            top: `${startIndex * itemHeight}px`,
            height: `${visibleItems.length * itemHeight}px`
          }}
        >
          {visibleItems.map((item, index) => (
            <div 
              key={item.id} 
              style={{ 
                height: `${itemHeight}px`, 
                borderBottom: '1px solid #ccc',
                lineHeight: `${itemHeight}px`
              }}
            >
              {item.content}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

## Практические советы по оптимизации

### 1. Использование инструментов профилирования

```typescript
// Использование React DevTools Profiler
// В production сборке:
if (process.env.NODE_ENV === 'development') {
  import('react-dom/profiling').then(({ unstable_Profiler }) => {
    // Настройка профилирования
  });
}
```

### 2. Lazy loading компонентов

```typescript
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

const App: React.FC = () => {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <LazyComponent />
    </Suspense>
  );
};
```

### 3. Оптимизация запросов данных

```typescript
// Использование React Query для кеширования данных
import { useQuery } from 'react-query';

interface User {
  id: number;
  name: string;
}

const UserComponent: React.FC = () => {
  const { data: users, isLoading, error } = useQuery<User[]>(
    'users', 
    () => fetch('/api/users').then(res => res.json()),
    {
      staleTime: 5 * 60 * 1000, // 5 минут
      cacheTime: 10 * 60 * 1000, // 10 минут
    }
  );
  
  if (isLoading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {(error as Error).message}</div>;
  
  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

## Заключение

Оптимизация производительности при управлении состоянием требует комплексного подхода, включающего правильную архитектуру, использование соответствующих инструментов и паттернов, а также регулярный мониторинг производительности. Ключ к успеху - это понимание того, когда и какие оптимизации применять, чтобы избежать преждевременной оптимизации и при этом обеспечить высокую производительность приложения.

См. также:
- [[Глобальное-состояние]]
- [[Локальное-состояние]]
- [[Управление-состоянием]]
- [[Паттерны-состояния]]