---
aliases: [Глобальное состояние, Global State]
tags: [typescript, state-management, global-state]
---

# Глобальное состояние

## Введение

Глобальное состояние представляет собой данные, которые доступны и могут быть изменены из любой части приложения. Это особенно важно в сложных приложениях, где компоненты на разных уровнях иерархии должны иметь доступ к одним и тем же данным.

## Основные концепции

Глобальное состояние позволяет:

- Обмениваться данными между компонентами без передачи пропсов через промежуточные уровни (prop drilling)
- Централизованно управлять данными приложения
- Сохранять согласованность данных во всем приложении
- Упрощать отладку и тестирование приложения

## Реализации глобального состояния в TypeScript

### Redux

Redux - одна из самых популярных библиотек управления состоянием:

```typescript
import { createStore, combineReducers, applyMiddleware } from 'redux';
import { composeWithDevTools } from 'redux-devtools-extension';

// Определение типов состояния
interface UserState {
  id: number;
  name: string;
  email: string;
}

interface AppState {
  user: UserState;
  theme: string;
}

// Редьюсеры
const userReducer = (state: UserState = { id: 0, name: '', email: '' }, action: any): UserState => {
  switch (action.type) {
    case 'SET_USER':
      return action.payload;
    default:
      return state;
  }
};

const themeReducer = (state: string = 'light', action: any): string => {
  switch (action.type) {
    case 'SET_THEME':
      return action.payload;
    default:
      return state;
  }
};

// Создание хранилища
const rootReducer = combineReducers<AppState>({
  user: userReducer,
  theme: themeReducer,
});

const store = createStore(rootReducer, composeWithDevTools(applyMiddleware()));
```

### Zustand

Zustand предоставляет более простую альтернативу Redux:

```typescript
import { create } from 'zustand';
import { devtools, subscribeWithSelector } from 'zustand/middleware';

interface User {
  id: number;
  name: string;
  email: string;
}

interface AppState {
  user: User | null;
  theme: string;
  setUser: (user: User) => void;
  setTheme: (theme: string) => void;
  logout: () => void;
}

const useAppStore = create<AppState>()(
  devtools(
    subscribeWithSelector((set) => ({
      user: null,
      theme: 'light',
      setUser: (user) => set({ user }),
      setTheme: (theme) => set({ theme }),
      logout: () => set({ user: null }),
    }))
  )
);
```

### Context API

React Context API - встроенное решение для управления глобальным состоянием:

```typescript
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

interface UserState {
  id: number;
  name: string;
  email: string;
}

interface AppState {
  user: UserState | null;
  theme: string;
}

type AppAction = 
  | { type: 'SET_USER'; payload: UserState }
  | { type: 'SET_THEME'; payload: string }
  | { type: 'LOGOUT' };

const initialState: AppState = {
  user: null,
  theme: 'light',
};

const AppReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'LOGOUT':
      return { ...state, user: null };
    default:
      return state;
  }
};

interface AppContextProps {
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
}

const AppContext = createContext<AppContextProps | undefined>(undefined);

interface AppProviderProps {
  children: ReactNode;
}

export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(AppReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};
```

## Преимущества и недостатки глобального состояния

### Преимущества:
- Централизованное управление данными
- Упрощение передачи данных между компонентами
- Возможность сохранения состояния между сессиями
- Улучшенная тестируемость

### Недостатки:
- Увеличение сложности приложения
- Потенциальное снижение производительности
- Сложность отладки
- Возможность избыточного рендеринга

## Лучшие практики

1. **Минимизация глобального состояния**: используйте глобальное состояние только для данных, которые действительно нужны в нескольких компонентах.

2. **Типизация**: всегда используйте строгую типизацию для глобального состояния.

3. **Иммутабельность**: не мутируйте состояние напрямую, создавайте новые объекты при обновлениях.

4. **Разделение состояния**: разделяйте состояние на логические части (user, theme, settings и т.д.).

5. **Санитайзинг данных**: проверяйте и очищайте данные перед сохранением в глобальное состояние.

## Заключение

Глобальное состояние - мощный инструмент управления данными в приложении, но его использование требует осторожности. Правильное применение глобального состояния может значительно улучшить архитектуру приложения и упростить разработку.

См. также:
- [[Локальное-состояние]]
- [[Управление-состоянием]]
- [[Паттерны-состояния]]
- [[Состояние-и-производительность]]