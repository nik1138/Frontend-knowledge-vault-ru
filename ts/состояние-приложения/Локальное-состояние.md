---
aliases: [Локальное состояние, Local State]
tags: [typescript, state-management, local-state, react]
---

# Локальное состояние

## Введение

Локальное состояние (local state) - это данные, которые принадлежат конкретному компоненту и не влияют на остальные части приложения. Это основной способ управления состоянием на уровне отдельных компонентов.

## Основные концепции

Локальное состояние используется для:

- Хранения данных, специфичных для одного компонента
- Управления визуальными изменениями в компоненте
- Отслеживания пользовательского взаимодействия
- Временного хранения данных, не требующих глобального доступа

## Реализации локального состояния в TypeScript

### React useState

Самый распространенный хук для управления локальным состоянием:

```typescript
import React, { useState } from 'react';

interface UserFormState {
  name: string;
  email: string;
  age: number;
}

const UserForm: React.FC = () => {
  const [formData, setFormData] = useState<UserFormState>({
    name: '',
    email: '',
    age: 0
  });
  
  const [errors, setErrors] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: name === 'age' ? parseInt(value) || 0 : value
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Валидация формы
    const newErrors: string[] = [];
    if (!formData.name) newErrors.push('Имя обязательно');
    if (!formData.email) newErrors.push('Email обязателен');
    
    if (newErrors.length > 0) {
      setErrors(newErrors);
      return;
    }

    setIsSubmitting(true);
    // Отправка данных формы
    console.log('Форма отправлена:', formData);
    setIsSubmitting(false);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Имя"
        />
      </div>
      <div>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Email"
        />
      </div>
      <div>
        <input
          type="number"
          name="age"
          value={formData.age}
          onChange={handleChange}
          placeholder="Возраст"
        />
      </div>
      {errors.length > 0 && (
        <ul>
          {errors.map((error, index) => (
            <li key={index} style={{ color: 'red' }}>{error}</li>
          ))}
        </ul>
      )}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Отправка...' : 'Отправить'}
      </button>
    </form>
  );
};
```

### React useReducer

Для более сложного локального состояния можно использовать `useReducer`:

```typescript
import React, { useReducer } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

type TodoAction = 
  | { type: 'ADD_TODO'; payload: string }
  | { type: 'TOGGLE_TODO'; payload: number }
  | { type: 'DELETE_TODO'; payload: number }
  | { type: 'EDIT_TODO'; payload: { id: number; text: string } };

const todoReducer = (state: Todo[], action: TodoAction): Todo[] => {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: Date.now(),
          text: action.payload,
          completed: false
        }
      ];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.payload);
    case 'EDIT_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.text }
          : todo
      );
    default:
      return state;
  }
};

const TodoList: React.FC = () => {
  const [todos, dispatch] = useReducer(todoReducer, []);

  const addTodo = (text: string) => {
    dispatch({ type: 'ADD_TODO', payload: text });
  };

  const toggleTodo = (id: number) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };

  const deleteTodo = (id: number) => {
    dispatch({ type: 'DELETE_TODO', payload: id });
  };

  const editTodo = (id: number, text: string) => {
    dispatch({ type: 'EDIT_TODO', payload: { id, text } });
  };

  return (
    <div>
      <TodoInput onAdd={addTodo} />
      <ul>
        {todos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={() => toggleTodo(todo.id)}
            onDelete={() => deleteTodo(todo.id)}
            onEdit={(text) => editTodo(todo.id, text)}
          />
        ))}
      </ul>
    </div>
  );
};
```

### React useRef

Для хранения изменяемых значений, которые не вызывают перерендеринг:

```typescript
import React, { useRef, useEffect } from 'react';

const Timer: React.FC = () => {
  const [seconds, setSeconds] = React.useState(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  const handleStop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const handleStart = () => {
    if (!intervalRef.current) {
      intervalRef.current = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
  };

  return (
    <div>
      <h2>Таймер: {seconds} секунд</h2>
      <button onClick={handleStart}>Старт</button>
      <button onClick={handleStop}>Стоп</button>
    </div>
  );
};
```

## Преимущества локального состояния

- Простота использования для данных, специфичных для компонента
- Лучшая производительность по сравнению с глобальным состоянием
- Изоляция данных между компонентами
- Простая отладка и тестирование
- Минимизация сложности приложения

## Недостатки локального состояния

- Ограниченная область видимости (только в пределах компонента)
- Сложность при передаче данных между компонентами
- Повторение логики в разных компонентах
- Проблемы с синхронизацией данных между компонентами

## Лучшие практики

1. **Минимизация состояния**: храните только минимально необходимые данные в локальном состоянии.

2. **Иммутабельность**: не мутируйте состояние напрямую, создавайте новые объекты при обновлениях.

3. **Разделение состояния**: разделяйте состояние на логические части для лучшей читаемости.

4. **Типизация**: всегда используйте строгую типизацию для локального состояния.

5. **Очистка ресурсов**: очищайте таймеры, подписки и другие ресурсы при размонтировании компонента.

6. **Использование подходящих хуков**: используйте `useState` для простого состояния, `useReducer` для сложной логики.

## Когда использовать локальное состояние

- Данные используются только в одном компоненте
- Состояние не влияет на другие части приложения
- Нет необходимости в сохранении состояния между сессиями
- Простые изменения UI (открытие/закрытие модальных окон, переключение вкладок и т.д.)

## Заключение

Локальное состояние - фундаментальный концепт управления данными в компонентах. Правильное использование локального состояния делает приложение более предсказуемым, производительным и легко поддерживаемым.

См. также:
- [[Глобальное-состояние]]
- [[Управление-состоянием]]
- [[Паттерны-состояния]]
- [[Состояние-и-производительность]]