---
aliases: [Паттерны состояния, State Patterns]
tags: [typescript, state-management, patterns, architecture]
---

# Паттерны состояния

## Введение

Паттерны управления состоянием - это проверенные подходы к организации, хранению и изменению данных в приложениях. Эти паттерны помогают разработчикам создавать масштабируемые, поддерживаемые и предсказуемые приложения.

## Основные паттерны управления состоянием

### 1. Flux-паттерн

Flux - это архитектурный паттерн, предложенный Facebook, который использует однонаправленный поток данных:

```
Action → Dispatcher → Store → View
```

#### Реализация Flux-паттерна

```typescript
// Определение действия
interface Action<T = any> {
  type: string;
  payload?: T;
}

// Интерфейс хранилища
interface Store<T> {
  getState(): T;
  subscribe(listener: () => void): () => void;
  dispatch(action: Action): void;
}

// Пример реализации Flux-хранилища
class FluxStore<T> implements Store<T> {
  private state: T;
  private listeners: Array<() => void> = [];
  private reducer: (state: T, action: Action) => T;

  constructor(initialState: T, reducer: (state: T, action: Action) => T) {
    this.state = initialState;
    this.reducer = reducer;
  }

  getState(): T {
    return this.state;
  }

  subscribe(listener: () => void): () => void {
    this.listeners.push(listener);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  dispatch(action: Action): void {
    this.state = this.reducer(this.state, action);
    this.listeners.forEach(listener => listener());
  }
}

// Использование
interface CounterState {
  count: number;
}

const counterReducer = (state: CounterState, action: Action): CounterState => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      return state;
  }
};

const counterStore = new FluxStore<CounterState>({ count: 0 }, counterReducer);
```

### 2. Redux-паттерн

Redux расширяет концепции Flux с упором на предсказуемость и функциональность:

```typescript
import { createStore, combineReducers, applyMiddleware, Middleware } from 'redux';
import { composeWithDevTools } from 'redux-devtools-extension';

// Типизированные действия
const INCREMENT = 'INCREMENT' as const;
const DECREMENT = 'DECREMENT' as const;
const SET_USER = 'SET_USER' as const;

interface IncrementAction {
  type: typeof INCREMENT;
}

interface DecrementAction {
  type: typeof DECREMENT;
}

interface SetUserAction {
  type: typeof SET_USER;
  payload: { id: number; name: string };
}

type AppAction = IncrementAction | DecrementAction | SetUserAction;

// Состояния
interface CounterState {
  value: number;
}

interface UserState {
  id: number | null;
  name: string | null;
}

interface RootState {
  counter: CounterState;
  user: UserState;
}

// Редьюсеры
const counterReducer = (
  state: CounterState = { value: 0 },
  action: AppAction
): CounterState => {
  switch (action.type) {
    case INCREMENT:
      return { value: state.value + 1 };
    case DECREMENT:
      return { value: state.value - 1 };
    default:
      return state;
  }
};

const userReducer = (
  state: UserState = { id: null, name: null },
  action: AppAction
): UserState => {
  switch (action.type) {
    case SET_USER:
      return action.payload;
    default:
      return state;
  }
};

// Комбинация редьюсеров
const rootReducer = combineReducers<RootState>({
  counter: counterReducer,
  user: userReducer,
});

// Создание хранилища
const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware())
);

// Типизированные селекторы
const selectCounterValue = (state: RootState): number => state.counter.value;
const selectUserName = (state: RootState): string | null => state.user.name;

// Использование
store.dispatch({ type: INCREMENT });
store.dispatch({ type: SET_USER, payload: { id: 1, name: 'John' } });

console.log(selectCounterValue(store.getState())); // 1
console.log(selectUserName(store.getState())); // 'John'
```

### 3. Context-паттерн

React Context позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на каждом уровне:

```typescript
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

// Определение состояния и действий
interface AppState {
  theme: 'light' | 'dark';
  language: 'ru' | 'en';
  user: { id: number; name: string } | null;
}

type AppAction = 
  | { type: 'SET_THEME'; payload: 'light' | 'dark' }
  | { type: 'SET_LANGUAGE'; payload: 'ru' | 'en' }
  | { type: 'SET_USER'; payload: { id: number; name: string } }
  | { type: 'LOGOUT' };

// Редьюсер
const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'LOGOUT':
      return { ...state, user: null };
    default:
      return state;
  }
};

// Контекст
const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | undefined>(undefined);

// Провайдер
interface AppProviderProps {
  children: ReactNode;
}

const initialState: AppState = {
  theme: 'light',
  language: 'ru',
  user: null,
};

export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};

// Хук для использования контекста
export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};

// Компонент, использующий контекст
const ThemeToggle: React.FC = () => {
  const { state, dispatch } = useAppContext();

  return (
    <button
      onClick={() => 
        dispatch({ 
          type: 'SET_THEME', 
          payload: state.theme === 'light' ? 'dark' : 'light' 
        })
      }
    >
      Переключить тему ({state.theme})
    </button>
  );
};
```

### 4. State Machine-паттерн

State Machine - это паттерн, который моделирует поведение объекта как конечный автомат:

```typescript
// Определение состояний и событий
type AuthState = 
  | { type: 'unauthenticated' }
  | { type: 'authenticating' }
  | { type: 'authenticated'; user: { id: number; name: string } }
  | { type: 'error'; message: string };

type AuthEvent = 
  | { type: 'LOGIN'; credentials: { email: string; password: string } }
  | { type: 'LOGIN_SUCCESS'; user: { id: number; name: string } }
  | { type: 'LOGIN_FAILURE'; error: string }
  | { type: 'LOGOUT' };

// Функция перехода между состояниями
const authReducer = (state: AuthState, event: AuthEvent): AuthState => {
  switch (state.type) {
    case 'unauthenticated':
      if (event.type === 'LOGIN') {
        return { type: 'authenticating' };
      }
      break;
      
    case 'authenticating':
      if (event.type === 'LOGIN_SUCCESS') {
        return { type: 'authenticated', user: event.user };
      }
      if (event.type === 'LOGIN_FAILURE') {
        return { type: 'error', message: event.error };
      }
      break;
      
    case 'authenticated':
      if (event.type === 'LOGOUT') {
        return { type: 'unauthenticated' };
      }
      break;
      
    case 'error':
      if (event.type === 'LOGIN') {
        return { type: 'authenticating' };
      }
      break;
  }
  return state;
};

// Использование
const initialAuthState: AuthState = { type: 'unauthenticated' };
let currentState = initialAuthState;

currentState = authReducer(currentState, { 
  type: 'LOGIN', 
  credentials: { email: 'user@example.com', password: 'password' } 
});

currentState = authReducer(currentState, { 
  type: 'LOGIN_SUCCESS', 
  user: { id: 1, name: 'John Doe' } 
});

console.log(currentState); // { type: 'authenticated', user: { id: 1, name: 'John Doe' } }
```

### 5. Observable-паттерн

Observable-паттерн позволяет объектам наблюдать за изменениями состояния:

```typescript
// Интерфейс наблюдателя
interface Observer<T> {
  next(value: T): void;
  error(error: any): void;
  complete(): void;
}

// Интерфейс observable
interface Observable<T> {
  subscribe(observer: Observer<T>): () => void;
  map<U>(fn: (value: T) => U): Observable<U>;
  filter(fn: (value: T) => boolean): Observable<T>;
}

// Реализация observable
class StateObservable<T> implements Observable<T> {
  private observers: Observer<T>[] = [];
  private currentValue: T;

  constructor(initialValue: T) {
    this.currentValue = initialValue;
  }

  getValue(): T {
    return this.currentValue;
  }

  next(value: T): void {
    this.currentValue = value;
    this.observers.forEach(observer => observer.next(value));
  }

  subscribe(observer: Observer<T>): () => void {
    this.observers.push(observer);
    observer.next(this.currentValue); // Отправляем текущее значение новому наблюдателю
    
    return () => {
      const index = this.observers.indexOf(observer);
      if (index > -1) {
        this.observers.splice(index, 1);
      }
    };
  }

  map<U>(fn: (value: T) => U): Observable<U> {
    const mappedObservable = new StateObservable<U>(fn(this.currentValue));
    
    this.subscribe({
      next: (value) => mappedObservable.next(fn(value)),
      error: (error) => {},
      complete: () => {}
    });
    
    return mappedObservable;
  }

  filter(fn: (value: T) => boolean): Observable<T> {
    const filteredObservable = new StateObservable<T>(this.currentValue);
    
    this.subscribe({
      next: (value) => {
        if (fn(value)) {
          filteredObservable.next(value);
        }
      },
      error: (error) => {},
      complete: () => {}
    });
    
    return filteredObservable;
  }
}

// Использование
const counter$ = new StateObservable<number>(0);

const subscription = counter$.subscribe({
  next: (value) => console.log(`Счетчик: ${value}`),
  error: (error) => console.error('Ошибка:', error),
  complete: () => console.log('Завершено')
});

counter$.next(1); // Счетчик: 1
counter$.next(2); // Счетчик: 2

// Отписка
subscription();
```

### 6. Atomic-паттерн (Jotai)

Atomic-паттерн разбивает состояние на маленькие, независимые атомы:

```typescript
import { atom, useAtom, atomFamily } from 'jotai';

// Простой атом
const countAtom = atom(0);

// Атом с вычисляемым значением
const doubledCountAtom = atom(
  (get) => get(countAtom) * 2, // геттер
  (get, set, newValue: number) => set(countAtom, newValue / 2) // сеттер
);

// Атом с логикой
const canIncrementAtom = atom((get) => get(countAtom) < 10);
const canDecrementAtom = atom((get) => get(countAtom) > 0);

// Атом с асинхронной логикой
const asyncValueAtom = atom(
  async (get) => {
    // Асинхронная операция
    const response = await fetch('/api/data');
    return response.json();
  }
);

// Атом для сложного состояния
interface User {
  id: number;
  name: string;
  email: string;
}

const userAtom = atom<User | null>(null);

// Атом с производными данными
const userNameAtom = atom(
  (get) => {
    const user = get(userAtom);
    return user ? user.name : 'Гость';
  }
);

// Использование в компоненте
const Counter: React.FC = () => {
  const [count, setCount] = useAtom(countAtom);
  const [doubledCount, setDoubledCount] = useAtom(doubledCountAtom);
  const [user, setUser] = useAtom(userAtom);
  const userName = useAtomValue(userNameAtom);
  const [asyncValue, setAsyncValue] = useAtom(asyncValueAtom);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <p>Удвоенное значение: {doubledCount}</p>
      <p>Имя пользователя: {userName}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
      <button onClick={() => setCount(c => c - 1)}>-</button>
      <button onClick={() => setDoubledCount(dc => dc + 4)}>Удвоить +4</button>
    </div>
  );
};
```

## Выбор подходящего паттерна

### Flux/Redux
- Используйте для сложных приложений с множественными источниками данных
- Когда нужна предсказуемость и отладка
- Когда требуется сохранение состояния между сессиями

### Context
- Используйте для средних приложений
- Когда нужно избежать "prop drilling"
- Когда состояние используется несколькими компонентами

### State Machine
- Используйте для сложной логики состояния
- Когда нужно моделировать пользовательские потоки
- Когда важна валидация переходов между состояниями

### Observable
- Используйте для реактивного программирования
- Когда нужно реагировать на изменения в реальном времени
- Когда есть асинхронные данные

### Atomic
- Используйте для гибкого управления состоянием
- Когда нужна высокая производительность
- Когда состояние можно разделить на независимые части

## Заключение

Паттерны управления состоянием предоставляют структурированные подходы к организации данных в приложениях. Выбор правильного паттерна зависит от сложности приложения, требований к производительности и предпочтений команды разработчиков.

См. также:
- [[Глобальное-состояние]]
- [[Локальное-состояние]]
- [[Управление-состоянием]]
- [[Состояние-и-производительность]]