---
aliases: ["Generics Introduction", "TypeScript Generics Basics"]
tags: 
  - typescript
  - дженерики
  - типы
  - программирование
---

# Введение в дженерики в TypeScript

## Обзор

Дженерики (Generics) - это мощная функция TypeScript, которая позволяет создавать переиспользуемые компоненты, которые могут работать с различными типами данных, при этом сохраняя строгую типизацию. Они позволяют разработчикам писать код, который может адаптироваться к различным типам без потери информации о типе.

## Что такое дженерики?

Дженерики позволяют создавать компоненты, которые работают не с одним конкретным типом, а с любым типом. Они обеспечивают способ обобщения, позволяя разработчику определить типы параметров, возвращаемых значений и переменных в функциях, классах и интерфейсах.

## Зачем нужны дженерики?

Без дженериков, разработчики часто используют тип `any`, что приводит к потере информации о типе и снижает безопасность типов. Дженерики решают эту проблему, позволяя сохранить информацию о типе и обеспечить строгую типизацию.

## Примеры использования

### Простой пример дженерик-функции

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

В этом примере `T` - это типовой параметр. Он захватывает тип, переданный пользователем (например, `number`), и обеспечивает его использование в других местах функции, таких как тип возвращаемого значения.

### Использование дженерик-функции

```typescript
let output1 = identity<string>("myString"); // вывод типа: string
let output2 = identity<number>(100);       // вывод типа: number
let output3 = identity("myString");        // вывод типа: string (вывод типа работает автоматически)
```

## Дженерики в интерфейсах

```typescript
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
```

## Ограничения дженериков

Иногда нужно ограничить типы, которые могут быть использованы в дженерик-функциях. Это делается с помощью `extends`:

```typescript
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); // Теперь мы можем безопасно получить доступ к свойству .length
    return arg;
}
```

## Ключевые концепции

- **Типовые параметры**: Переменные, которые хранят информацию о типе
- **Обобщение**: Создание универсального кода, который работает с разными типами
- **Ограничения**: Ограничение возможных типов с помощью ключевого слова `extends`
- **Множественные параметры**: Использование нескольких типовых параметров (например, `T`, `U`, `K`, `V`)

## Практические применения

1. **Коллекции**: Массивы, словари, очереди, стеки
2. **Функции-утилиты**: Функции, работающие с различными типами данных
3. **Компоненты UI**: Компоненты, которые могут работать с различными типами данных
4. **API-клиенты**: Обработка различных типов ответов

## Преимущества дженериков

- **Безопасность типов**: Сохранение информации о типе во время компиляции
- **Переиспользуемость**: Один компонент может работать с множеством типов
- **Читаемость кода**: Ясность намерений разработчика
- **Меньше дублирования кода**: Избегайте написания аналогичных функций для разных типов

## Связанные темы

- [[Ограничения-дженериков]]
- [[Дженерики-в-функциях]]
- [[Дженерики-в-классах]]
- [[Утилиты-дженериков]]

> [!tip] Совет
> Используйте осмысленные имена для типовых параметров. `T` и `U` подходят для простых случаев, но `ValueType`, `KeyType` или `Element` могут быть более понятными в сложных сценариях.

> [!warning] Важно
> Избегайте избыточного использования дженериков там, где конкретный тип был бы более подходящим. Дженерики добавляют сложность, которую нужно оправдывать.

## Заключение

Дженерики являются важной частью TypeScript, позволяющей создавать гибкий и безопасный код. Они обеспечивают способ создавать переиспользуемые компоненты, которые работают с различными типами данных, при этом сохраняя информацию о типе и обеспечивая строгую типизацию.