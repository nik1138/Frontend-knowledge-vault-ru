---
aliases: ["Generics in Classes", "Generic Classes"]
tags: 
  - typescript
  - дженерики
  - классы
  - типы
---

# Дженерики в классах

## Обзор

Дженерики в классах позволяют создавать универсальные классы, которые могут работать с различными типами данных. Это особенно полезно для создания коллекций, контейнеров и других структур данных, которые должны быть типобезопасными при работе с разными типами.

## Базовая реализация дженерик-класса

Создание дженерик-класса начинается с добавления типового параметра после имени класса:

```typescript
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = (x, y) => x + y;
```

## Пример: Обобщенный стек

Реализация стека с использованием дженериков:

```typescript
class Stack<T> {
    private items: T[] = [];

    push(item: T): void {
        this.items.push(item);
    }

    pop(): T | undefined {
        return this.items.pop();
    }

    peek(): T | undefined {
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }
}

// Использование стека с разными типами
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
console.log(numberStack.pop()); // 2

const stringStack = new Stack<string>();
stringStack.push("hello");
stringStack.push("world");
console.log(stringStack.pop()); // "world"
```

## Дженерики с ограничениями

Можно применять ограничения к типовым параметрам в классах:

```typescript
interface WithId {
    id: number;
}

class Repository<T extends WithId> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }

    findById(id: number): T | undefined {
        return this.items.find(item => item.id === id);
    }

    getAll(): T[] {
        return [...this.items];
    }
}

interface User {
    id: number;
    name: string;
}

const userRepository = new Repository<User>();
userRepository.add({ id: 1, name: "Иван" });
userRepository.add({ id: 2, name: "Мария" });

const user = userRepository.findById(1); // тип: User | undefined
```

## Множественные типовые параметры

Классы могут использовать несколько типовых параметров:

```typescript
class KeyValuePair<K, V> {
    constructor(public key: K, public value: V) {}
}

const pair1 = new KeyValuePair<string, number>("age", 25);
const pair2 = new KeyValuePair<number, boolean>(1, true);
```

## Дженерики в методах класса

Класс может иметь как дженерик-параметры уровня класса, так и дженерик-методы:

```typescript
class DataProcessor<T> {
    private data: T[] = [];

    add(item: T): void {
        this.data.push(item);
    }

    // Дженерик-метод с дополнительным параметром
    process<U>(processor: (item: T) => U): U[] {
        return this.data.map(processor);
    }

    // Метод, который может принимать разные типы
    merge<U>(other: U): (T | U)[] {
        return [...this.data, other];
    }
}

const processor = new DataProcessor<string>();
processor.add("hello");
processor.add("world");

const lengths = processor.process(item => item.length); // number[]
const mixed = processor.merge(42); // (string | number)[]
```

## Дженерики с конструкторами

Можно использовать дженерики и в конструкторах классов:

```typescript
class Container<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    getValue(): T {
        return this.value;
    }

    setValue(value: T): void {
        this.value = value;
    }
}

const stringContainer = new Container<string>("hello");
const numberContainer = new Container<number>(42);
```

## Практические примеры

### 1. Обобщенный кэш

```typescript
class Cache<T> {
    private store: Map<string, T> = new Map();

    set(key: string, value: T): void {
        this.store.set(key, value);
    }

    get(key: string): T | undefined {
        return this.store.get(key);
    }

    has(key: string): boolean {
        return this.store.has(key);
    }

    delete(key: string): boolean {
        return this.store.delete(key);
    }

    clear(): void {
        this.store.clear();
    }

    size(): number {
        return this.store.size;
    }
}

const userCache = new Cache<User>();
userCache.set("user1", { id: 1, name: "Иван" });
const user = userCache.get("user1"); // тип: User | undefined
```

### 2. Обобщенный список связей

```typescript
class LinkedList<T> {
    private head: Node<T> | null = null;
    private size: number = 0;

    append(value: T): void {
        const newNode = new Node(value);
        
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }

    prepend(value: T): void {
        const newNode = new Node(value);
        newNode.next = this.head;
        this.head = newNode;
        this.size++;
    }

    toArray(): T[] {
        const result: T[] = [];
        let current = this.head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }

    getSize(): number {
        return this.size;
    }
}

class Node<T> {
    next: Node<T> | null = null;
    
    constructor(public value: T) {}
}

const list = new LinkedList<string>();
list.append("first");
list.append("second");
list.prepend("zero");
console.log(list.toArray()); // ["zero", "first", "second"]
```

### 3. Обобщенный API-клиент

```typescript
class ApiClient {
    private baseUrl: string;

    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }

    async get<T>(endpoint: string): Promise<T> {
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    }

    async post<T, U>(endpoint: string, data: U): Promise<T> {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    }
}

// Использование
interface UserResponse {
    id: number;
    name: string;
    email: string;
}

interface CreateUserRequest {
    name: string;
    email: string;
}

const client = new ApiClient('https://api.example.com');

// Получение пользователя
const user = await client.get<UserResponse>('/users/1');

// Создание пользователя
const newUser = await client.post<UserResponse, CreateUserRequest>('/users', {
    name: 'Иван',
    email: 'ivan@example.com'
});
```

### 4. Обобщенный событийный эмиттер

```typescript
type EventHandler<T = void> = (data: T) => void;

class EventEmitter {
    private events: Map<string, Array<EventHandler<any>>> = new Map();

    on<T>(eventName: string, handler: EventHandler<T>): void {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }
        this.events.get(eventName)!.push(handler);
    }

    emit<T>(eventName: string, data: T): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }

    off<T>(eventName: string, handler: EventHandler<T>): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler as any);
            if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
    }
}

const emitter = new EventEmitter();

// Подписка на событие с данными типа User
emitter.on<User>('userCreated', (user) => {
    console.log(`Пользователь создан: ${user.name}`);
});

// Эмиссия события
emitter.emit('userCreated', { id: 1, name: 'Иван', email: 'ivan@example.com' });
```

## Продвинутые паттерны

### Класс с условными типами

```typescript
class ConditionalProcessor<T> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }

    // Метод, который возвращает разные типы в зависимости от типа T
    getSummary(): T extends string 
        ? { count: number; longest: string } 
        : T extends number 
            ? { count: number; sum: number } 
            : { count: number } {
        
        const count = this.items.length;
        
        if (typeof this.items[0] === 'string') {
            const longest = this.items.reduce((a, b) => a.length > b.length ? a : b, '');
            return { count, longest } as any;
        } else if (typeof this.items[0] === 'number') {
            const sum = this.items.reduce((a, b) => a + b, 0);
            return { count, sum } as any;
        }
        
        return { count } as any;
    }
}
```

## Практические рекомендации

> [!tip] Совет 1
> Используйте дженерики в классах для создания переиспользуемых компонентов, таких как коллекции, контейнеры и утилиты.

> [!tip] Совет 2
> Применяйте ограничения к типовым параметрам, чтобы гарантировать наличие необходимых свойств или методов у типов.

> [!warning] Важно
> Избегайте избыточного использования дженериков. Иногда конкретная реализация делает код более понятным.

> [!warning] Важно 2
> Убедитесь, что дженерики действительно необходимы. Не используйте их только ради использования дженериков.

## Заключение

Дженерики в классах предоставляют мощный способ создания универсальных компонентов, которые могут работать с различными типами данных, при этом сохраняя строгую типизацию. Они особенно полезны для создания коллекций, контейнеров и других структур данных, которые должны быть гибкими и безопасными в использовании.

## Связанные темы

- [[Введение-в-дженерики]]
- [[Ограничения-дженериков]]
- [[Дженерики-в-функциях]]
- [[Утилиты-дженериков]]