---
aliases: ["Generics in Functions", "Generic Functions"]
tags: 
  - typescript
  - дженерики
  - функции
  - типы
---

# Дженерики в функциях

## Обзор

Дженерики в функциях позволяют создавать универсальные функции, которые могут работать с различными типами данных, сохраняя информацию о типе и обеспечивая строгую типизацию. Это позволяет писать более гибкий и переиспользуемый код.

## Базовая реализация дженерик-функции

Самый простой способ использования дженериков в функциях - это добавление типового параметра в объявление функции:

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

В этом примере `T` - это типовой параметр, который захватывает тип, переданный пользователем, и используется как тип параметра и возвращаемого значения.

## Явное и неявное указание типов

При вызове дженерик-функций можно явно указать тип или позволить TypeScript вывести его автоматически:

```typescript
// Явное указание типа
let output1 = identity<string>("hello");

// Неявное указание типа (вывод типа)
let output2 = identity("hello"); // TypeScript выводит, что T - это string
```

## Работа с массивами в дженерик-функциях

Дженерики особенно полезны при работе с массивами:

```typescript
function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);
    return arg;
}

// Или эквивалентная запись
function loggingIdentity2<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);
    return arg;
}
```

## Множественные типовые параметры

Функции могут использовать несколько типовых параметров:

```typescript
function swap<T, U>(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]];
}

const result = swap(["hello", 42]); // тип: [number, string]
console.log(result); // [42, "hello"]
```

## Дженерики с объектами

Дженерики позволяют работать с объектами неизвестной структуры:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3 };
let a = getProperty(x, "a"); // тип: number
let b = getProperty(x, "b"); // тип: number
```

## Ограничения в дженерик-функциях

Можно ограничить типовые параметры с помощью ключевого слова `extends`:

```typescript
interface Lengthwise {
    length: number;
}

function loggingIdentityWithLength<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); // Теперь мы можем безопасно получить доступ к свойству .length
    return arg;
}

loggingIdentityWithLength("hello"); // строка имеет свойство length
loggingIdentityWithLength([1, 2, 3]); // массив имеет свойство length
// loggingIdentityWithLength(123); // ОШИБКА: number не имеет свойства length
```

## Условные дженерик-функции

Создание функций, которые возвращают разные типы в зависимости от входных параметров:

```typescript
function createValue<T extends string | number>(value: T): T extends string ? string : number {
    if (typeof value === 'string') {
        return value.toUpperCase() as T extends string ? string : number;
    }
    return (value * 2) as T extends string ? string : number;
}
```

## Практические примеры

### 1. Функция для создания копии объекта

```typescript
function cloneObject<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
}

const original = { name: "Иван", age: 30, active: true };
const cloned = cloneObject(original); // тип: { name: string; age: number; active: boolean; }
```

### 2. Функция для фильтрации массива по ключу

```typescript
function filterByProperty<T, K extends keyof T>(
    items: T[],
    property: K,
    value: T[K]
): T[] {
    return items.filter(item => item[property] === value);
}

interface User {
    id: number;
    name: string;
    role: string;
}

const users: User[] = [
    { id: 1, name: "Иван", role: "admin" },
    { id: 2, name: "Мария", role: "user" },
    { id: 3, name: "Петр", role: "admin" }
];

const admins = filterByProperty(users, "role", "admin");
```

### 3. Функция для объединения объектов

```typescript
function mergeObjects<T, U>(obj1: T, obj2: U): T & U {
    return { ...obj1, ...obj2 };
}

const person = { name: "Иван", age: 30 };
const job = { position: "инженер", company: "Tech Corp" };

const employee = mergeObjects(person, job);
// Тип: { name: string; age: number; position: string; company: string; }
```

### 4. Функция для получения подмножества свойств объекта

```typescript
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
    const result = {} as Pick<T, K>;
    for (const key of keys) {
        result[key] = obj[key];
    }
    return result;
}

const user = { id: 1, name: "Иван", email: "ivan@example.com", password: "secret" };
const publicUser = pick(user, ["id", "name"]); // Тип: { id: number; name: string; }
```

### 5. Функция для безопасного доступа к вложенным свойствам

```typescript
function getNestedValue<T extends Record<string, any>, K extends keyof T>(
    obj: T,
    key: K
): T[K] | undefined {
    return obj[key];
}

function getDeepValue<T extends Record<string, any>, K1 extends keyof T, K2 extends keyof T[K1]>(
    obj: T,
    key1: K1,
    key2: K2
): T[K1][K2] | undefined {
    return obj[key1]?.[key2];
}
```

## Продвинутые паттерны

### Утилита для создания частичных функций

```typescript
function partial<T extends (...args: any[]) => any>(
    fn: T,
    ...presetArgs: Parameters<T>
): (...args: DropFirst<Parameters<T>, typeof presetArgs>) => ReturnType<T> {
    return (...args: any[]) => fn(...presetArgs, ...args);
}

// Вспомогательный тип для удаления первых элементов из кортежа
type DropFirst<T extends any[], U extends any[]> = T extends [any, ...infer R] 
    ? U['length'] extends 0 
        ? R 
        : DropFirst<R, Shift<U>> 
    : T;

type Shift<T extends any[]> = T extends [any, ...infer R] ? R : [];
```

### Функция с условным возвратом

```typescript
function conditionalReturn<T, U>(
    condition: boolean,
    trueValue: T,
    falseValue: U
): T | U {
    return condition ? trueValue : falseValue;
}

const result = conditionalReturn(true, "строка", 42); // тип: string | number
```

## Практические рекомендации

> [!tip] Совет 1
> Используйте осмысленные имена типовых параметров. Вместо `T` и `U` можно использовать `ValueType`, `KeyType` или `Element`, если это улучшает читаемость.

> [!tip] Совет 2
> Всегда используйте ограничения, когда это необходимо, чтобы избежать ошибок типизации. Ограничения делают код более безопасным и понятным.

> [!warning] Важно
> Избегайте избыточного использования дженериков. Иногда конкретный тип делает код более понятным, чем дженерик.

## Заключение

Дженерики в функциях - мощный инструмент для создания гибких и безопасных компонентов. Они позволяют писать универсальные функции, которые сохраняют информацию о типе и обеспечивают строгую типизацию, что делает код более надежным и поддерживаемым.

## Связанные темы

- [[Введение-в-дженерики]]
- [[Ограничения-дженериков]]
- [[Дженерики-в-классах]]
- [[Утилиты-дженериков]]