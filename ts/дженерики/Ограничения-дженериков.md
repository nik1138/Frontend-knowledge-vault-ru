---
aliases: ["Generic Constraints", "Constraining Generics"]
tags: 
  - typescript
  - дженерики
  - ограничения
  - типы
---

# Ограничения дженериков в TypeScript

## Обзор

Ограничения дженериков позволяют указать, что типовой параметр должен соответствовать определенным требованиям, например, иметь определенные свойства или методы. Это особенно полезно, когда нужно работать с подмножеством типов, обладающих общими характеристиками.

## Базовое ограничение с `extends`

Самый простой способ ограничить типовой параметр - использовать ключевое слово `extends`, чтобы указать, что параметр должен быть подтипом определенного типа:

```typescript
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); // Теперь мы можем безопасно получить доступ к свойству .length
    return arg;
}
```

В этом примере мы ограничили `T` интерфейсом `Lengthwise`, что означает, что любое значение, переданное в качестве `arg`, должно иметь свойство `length` типа `number`.

## Ограничения с ключами объекта

Дженерики особенно полезны при работе с объектами, когда нужно гарантировать, что один параметр является ключом другого:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3 };
getProperty(x, "a"); // OK
getProperty(x, "d"); // Ошибка: "d" не является ключом объекта x
```

Здесь `K extends keyof T` гарантирует, что `key` является допустимым ключом объекта `obj`.

## Ограничения с классами

Также можно ограничить типовой параметр классом, что позволяет использовать свойства и методы этого класса:

```typescript
class BeeKeeper {
    hasMask: boolean = true;
}

class ZooKeeper {
    nametag: string = "Марк";
}

class Animal {
    numLegs: number = 4;
}

class Bee extends Animal {
    keeper: BeeKeeper = new BeeKeeper();
}

class Lion extends Animal {
    keeper: ZooKeeper = new ZooKeeper();
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // OK
createInstance(Bee).keeper.hasMask;   // OK
```

## Условные типы с ограничениями

TypeScript также позволяет создавать условные типы с ограничениями:

```typescript
interface IDInfo {
    id: string;
}

function processEntity<T extends IDInfo>(entity: T): T {
    console.log(`Обработка сущности с ID: ${entity.id}`);
    return entity;
}

// Это будет работать
const user = { id: "123", name: "Иван" };
processEntity(user);

// Это вызовет ошибку, потому что объект не имеет свойства id
// processEntity({ name: "Иван" });
```

## Множественные ограничения

TypeScript не поддерживает множественное наследование, но можно использовать пересечение типов для создания более сложных ограничений:

```typescript
interface HasName {
    name: string;
}

interface HasAge {
    age: number;
}

function greetPerson<T extends HasName & HasAge>(person: T): string {
    return `Привет, меня зовут ${person.name} и мне ${person.age} лет`;
}

// Использование
const person = { name: "Анна", age: 25, occupation: "инженер" };
console.log(greetPerson(person)); // Привет, меня зовут Анна и мне 25 лет
```

## Ограничения с шаблонными литералами

С TypeScript 4.1+ можно использовать ограничения с шаблонными литералами:

```typescript
type EventNames = 'click' | 'scroll' | 'mousemove';

function handleEvent<T extends string>(event: T extends EventNames ? T : never) {
    console.log(`Обработка события: ${event}`);
}

// handleEvent('click');    // OK
// handleEvent('zoom');     // Ошибка: 'zoom' не является допустимым событием
```

## Практические примеры

### Ограничение для объектов с определенными свойствами

```typescript
// Ограничение, чтобы объект обязательно имел id
function findById<T extends { id: string }>(items: T[], id: string): T | undefined {
    return items.find(item => item.id === id);
}

// Использование
interface User {
    id: string;
    name: string;
    email: string;
}

const users: User[] = [
    { id: "1", name: "Иван", email: "ivan@example.com" },
    { id: "2", name: "Мария", email: "maria@example.com" }
];

const user = findById(users, "1"); // Тип возврата: User | undefined
```

### Ограничение для функций с определенными параметрами

```typescript
// Ограничение для функций, которые принимают объект с определенными свойствами
function executeCallback<T extends { id: string }, U>(
    obj: T,
    callback: (arg: T) => U
): U {
    return callback(obj);
}

// Использование
interface DataItem {
    id: string;
    value: number;
}

const item: DataItem = { id: "42", value: 100 };
const result = executeCallback(item, (data) => data.value * 2); // Тип: number
```

## Продвинутые ограничения

### Ограничения с конструкторами

```typescript
function createInstance<T extends new (...args: any[]) => any>(
    constructor: T,
    ...args: ConstructorParameters<T>
): InstanceType<T> {
    return new constructor(...args);
}
```

### Ограничения с частичными типами

```typescript
function updateObject<T extends object>(
    obj: T,
    updates: Partial<T>
): T {
    return { ...obj, ...updates };
}
```

## Заключение

Ограничения дженериков - мощный инструмент, который позволяет создавать гибкие и безопасные типы в TypeScript. Они обеспечивают баланс между универсальностью и строгостью типизации, позволяя разработчикам создавать переиспользуемые компоненты, которые могут работать с широким спектром типов, при этом сохраняя гарантии безопасности типов.

## Связанные темы

- [[Введение-в-дженерики]]
- [[Дженерики-в-функциях]]
- [[Дженерики-в-классах]]
- [[Утилиты-дженериков]]