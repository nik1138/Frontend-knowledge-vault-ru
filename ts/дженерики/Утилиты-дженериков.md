---
aliases: ["Generic Utilities", "Utility Types", "Built-in Generics"]
tags: 
  - typescript
  - дженерики
  - утилиты
  - типы
---

# Утилиты дженериков в TypeScript

## Обзор

TypeScript предоставляет набор встроенных утилит дженериков (Utility Types), которые помогают манипулировать типами и создавать новые типы на основе существующих. Эти утилиты являются мощным инструментом для типобезопасной работы с данными.

## Основные утилиты дженериков

### 1. `Partial<T>`

Делает все свойства типа `T` необязательными:

```typescript
interface User {
    id: number;
    name: string;
    email: string;
}

type PartialUser = Partial<User>;
// Тип: { id?: number; name?: string; email?: string; }

const partialUser: PartialUser = { name: "Иван" }; // OK - остальные свойства необязательны
```

### 2. `Required<T>`

Делает все свойства типа `T` обязательными:

```typescript
interface User {
    id?: number;
    name?: string;
    email?: string;
}

type RequiredUser = Required<User>;
// Тип: { id: number; name: string; email: string; }

const requiredUser: RequiredUser = { 
    id: 1, 
    name: "Иван", 
    email: "ivan@example.com" 
}; // Все свойства обязательны
```

### 3. `Readonly<T>`

Делает все свойства типа `T` только для чтения:

```typescript
interface User {
    id: number;
    name: string;
}

type ReadonlyUser = Readonly<User>;
// Тип: { readonly id: number; readonly name: string; }

const readonlyUser: ReadonlyUser = { id: 1, name: "Иван" };
// readonlyUser.name = "Мария"; // ОШИБКА: нельзя изменить
```

### 4. `Pick<T, K>`

Создает тип с подмножеством свойств `K` из типа `T`:

```typescript
interface User {
    id: number;
    name: string;
    email: string;
    password: string;
}

type PublicUser = Pick<User, 'id' | 'name'>;
// Тип: { id: number; name: string; }

const publicUser: PublicUser = { id: 1, name: "Иван" }; // OK
```

### 5. `Omit<T, K>`

Создает тип, исключая определенные свойства `K` из типа `T`:

```typescript
interface User {
    id: number;
    name: string;
    email: string;
    password: string;
}

type SafeUser = Omit<User, 'password'>;
// Тип: { id: number; name: string; email: string; }

const safeUser: SafeUser = { 
    id: 1, 
    name: "Иван", 
    email: "ivan@example.com" 
}; // password исключен
```

### 6. `Record<K, T>`

Определяет объект, у которого ключи имеют тип `K`, а значения - тип `T`:

```typescript
type Page = 'home' | 'about' | 'contact';
type PageComponent = Record<Page, string>;

const pages: PageComponent = {
    home: "Главная страница",
    about: "О нас",
    contact: "Контакты"
};
```

### 7. `Exclude<T, U>`

Исключает из `T` типы, которые присутствуют в `U`:

```typescript
type AvailableColors = 'red' | 'green' | 'blue' | 'yellow';
type BasicColors = 'red' | 'green';

type AdvancedColors = Exclude<AvailableColors, BasicColors>;
// Тип: 'blue' | 'yellow'

const advanced: AdvancedColors = 'blue'; // OK
// const basic: AdvancedColors = 'red'; // ОШИБКА
```

### 8. `Extract<T, U>`

Извлекает из `T` типы, которые присутствуют в `U`:

```typescript
type AvailableColors = 'red' | 'green' | 'blue' | 'yellow';
type BasicColors = 'red' | 'green';

type BasicAvailable = Extract<AvailableColors, BasicColors>;
// Тип: 'red' | 'green'

const basic: BasicAvailable = 'red'; // OK
// const advanced: BasicAvailable = 'blue'; // ОШИБКА
```

### 9. `NonNullable<T>`

Исключает `null` и `undefined` из типа `T`:

```typescript
type StringOrNull = string | null | undefined;
type NonNullableString = NonNullable<StringOrNull>;
// Тип: string

const value: NonNullableString = "hello"; // OK
// const nullValue: NonNullableString = null; // ОШИБКА
```

### 10. `Parameters<T>`

Получает типы параметров функции `T`:

```typescript
function createUser(name: string, age: number, active: boolean): User {
    return { id: Date.now(), name, email: `${name}@example.com` };
}

type CreateUserParams = Parameters<typeof createUser>;
// Тип: [name: string, age: number, active: boolean]

const params: CreateUserParams = ["Иван", 30, true];
```

### 11. `ConstructorParameters<T>`

Получает типы параметров конструктора класса `T`:

```typescript
class User {
    constructor(
        public id: number,
        public name: string,
        public email: string
    ) {}
}

type UserConstructorParams = ConstructorParameters<typeof User>;
// Тип: [id: number, name: string, email: string]

const params: UserConstructorParams = [1, "Иван", "ivan@example.com"];
const user = new User(...params);
```

### 12. `ReturnType<T>`

Получает тип возвращаемого значения функции `T`:

```typescript
function getUserInfo(): { id: number; name: string; email: string } {
    return { id: 1, name: "Иван", email: "ivan@example.com" };
}

type UserInfo = ReturnType<typeof getUserInfo>;
// Тип: { id: number; name: string; email: string; }

const info: UserInfo = { id: 1, name: "Иван", email: "ivan@example.com" };
```

### 13. `InstanceType<T>`

Получает тип экземпляра класса `T`:

```typescript
class User {
    constructor(
        public id: number,
        public name: string,
        public email: string
    ) {}
}

type UserInstance = InstanceType<typeof User>;
// Тип: User

const user: UserInstance = new User(1, "Иван", "ivan@example.com");
```

## Продвинутые утилиты

### 14. `ThisParameterType<T>`

Получает тип параметра `this` функции `T`:

```typescript
function getUserInfo(this: { id: number; name: string }): string {
    return `${this.id}: ${this.name}`;
}

type ThisType = ThisParameterType<typeof getUserInfo>;
// Тип: { id: number; name: string; }
```

### 15. `OmitThisParameter<T>`

Удаляет параметр `this` из функции `T`:

```typescript
function getUserInfo(this: { id: number; name: string }): string {
    return `${this.id}: ${this.name}`;
}

type FunctionWithoutThis = OmitThisParameter<typeof getUserInfo>;
// Тип: () => string
```

## Практические примеры использования

### Пример 1: Создание DTO (Data Transfer Object)

```typescript
interface User {
    id: number;
    name: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
}

// DTO для создания пользователя
type CreateUserDto = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// DTO для обновления пользователя
type UpdateUserDto = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;

// DTO для публичной информации о пользователе
type PublicUserDto = Pick<User, 'id' | 'name' | 'email'>;

const createUserDto: CreateUserDto = {
    name: "Иван",
    email: "ivan@example.com",
    password: "securePassword"
};

const updateUserDto: UpdateUserDto = {
    name: "Иван Петров" // только имя изменяется
};
```

### Пример 2: Создание асинхронных действий

```typescript
// Утилита для создания типа промиса
type AsyncAction<T> = () => Promise<T>;

// Утилита для создания типа действия с состоянием загрузки
type ActionWithLoading<T> = {
    data: T | null;
    loading: boolean;
    error: string | null;
};

// Пример использования
interface User {
    id: number;
    name: string;
    email: string;
}

type UserAction = ActionWithLoading<User>;
// Тип: { data: User | null; loading: boolean; error: string | null; }
```

### Пример 3: Маппинг типов

```typescript
// Создание маппинга типов
type Stringify<T> = {
    [K in keyof T]: string;
};

interface User {
    id: number;
    name: string;
    active: boolean;
}

type StringifiedUser = Stringify<User>;
// Тип: { id: string; name: string; active: string; }
```

### Пример 4: Условные типы с утилитами

```typescript
// Утилита для создания типа с опциональными полями на основе другого типа
type Optional<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>;

interface User {
    id: number;
    name: string;
    email: string;
    password: string;
}

// Создание типа, где password опционально
type UserWithOptionalPassword = Optional<User, 'password'>;
// Тип: { id: number; name: string; email: string; } & { password?: string; }
```

## Создание собственных утилит

### Кастомная утилита для "deep partial"

```typescript
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

interface User {
    id: number;
    name: string;
    address: {
        street: string;
        city: string;
        country: string;
    };
}

type DeepPartialUser = DeepPartial<User>;
// Позволяет сделать все вложенные свойства опциональными
const partialUser: DeepPartialUser = {
    name: "Иван",
    address: {
        city: "Москва"
        // остальные поля опциональны
    }
};
```

### Кастомная утилита для "readonly deep"

```typescript
type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface User {
    id: number;
    name: string;
    contacts: {
        email: string;
        phone: string;
    };
}

type DeepReadonlyUser = DeepReadonly<User>;
const readonlyUser: DeepReadonlyUser = { 
    id: 1, 
    name: "Иван", 
    contacts: { email: "ivan@example.com", phone: "123-456-7890" } 
};
// readonlyUser.contacts.email = "new@example.com"; // ОШИБКА
```

## Практические рекомендации

> [!tip] Совет 1
> Используйте `Pick` и `Omit` для создания подмножеств типов, особенно при работе с API, где нужно отправлять или получать только часть данных.

> [!tip] Совет 2
> `Partial` и `Required` особенно полезны при создании DTO для обновления и создания сущностей.

> [!tip] Совет 3
> `Record` удобен для создания маппингов и словарей с известными ключами.

> [!warning] Важно
> Избегайте чрезмерного использования вложенных утилит, так как это может усложнить понимание типов.

> [!warning] Важно 2
> Утилиты дженериков - это инструменты для упрощения работы с типами, а не цель сама по себе. Используйте их, когда они действительно улучшают читаемость и безопасность кода.

## Заключение

Утилиты дженериков в TypeScript - мощный инструмент для манипуляции типами. Они позволяют создавать сложные типы на основе существующих, обеспечивая типобезопасность и улучшая читаемость кода. Понимание и правильное использование этих утилит значительно повышает качество TypeScript-кода.

## Связанные темы

- [[Введение-в-дженерики]]
- [[Ограничения-дженериков]]
- [[Дженерики-в-функциях]]
- [[Дженерики-в-классах]]