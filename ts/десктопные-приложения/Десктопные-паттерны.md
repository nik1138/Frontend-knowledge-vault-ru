---
aliases: [Паттерны для десктопных приложений, Desktop Patterns]
tags: [patterns, architecture, desktop-applications, typescript]
---

# Десктопные паттерны

## Обзор

Десктопные паттерны - это проверенные временем решения архитектурных и проектировочных задач, специфичных для разработки десктопных приложений. Эти паттерны помогают структурировать код, улучшить его читаемость, поддерживаемость и тестируемость, а также облегчают командную разработку.

## Архитектурные паттерны

### Model-View-ViewModel (MVVM)

MVVM - это архитектурный паттерн, который особенно популярен в разработке десктопных приложений. Он разделяет разработку графического интерфейса от разработки бизнес-логики.

#### Структура MVVM

- **Model**: Представляет данные и бизнес-логику
- **View**: Отвечает за отображение данных и взаимодействие с пользователем
- **ViewModel**: Связующее звено между Model и View, содержит представление данных и команды

#### Пример реализации

```typescript
// Model
interface User {
  id: number;
  name: string;
  email: string;
}

class UserModel {
  private users: User[] = [];
  
  async loadUsers(): Promise<User[]> {
    // Симуляция загрузки данных
    return [
      { id: 1, name: 'Иван Иванов', email: 'ivan@example.com' },
      { id: 2, name: 'Петр Петров', email: 'petr@example.com' }
    ];
  }
  
  async saveUser(user: User): Promise<void> {
    // Логика сохранения пользователя
    const existingIndex = this.users.findIndex(u => u.id === user.id);
    if (existingIndex !== -1) {
      this.users[existingIndex] = user;
    } else {
      this.users.push(user);
    }
  }
}

// ViewModel
class UserViewModel {
  private model: UserModel;
  public users: User[] = [];
  public currentUser: User | null = null;
  
  constructor(model: UserModel) {
    this.model = model;
  }
  
  async loadUsers(): Promise<void> {
    this.users = await this.model.loadUsers();
  }
  
  selectUser(user: User): void {
    this.currentUser = { ...user };
  }
  
  async saveUser(): Promise<void> {
    if (this.currentUser) {
      await this.model.saveUser(this.currentUser);
      // Обновляем список пользователей
      await this.loadUsers();
    }
  }
  
  updateUserProperty(property: keyof User, value: any): void {
    if (this.currentUser) {
      this.currentUser[property] = value;
    }
  }
}

// Использование
const userModel = new UserModel();
const userViewModel = new UserViewModel(userModel);

// Загрузка пользователей
await userViewModel.loadUsers();
console.log(userViewModel.users);
```

### Model-View-Presenter (MVP)

MVP - это архитектурный паттерн, который также разделяет представление и логику, но с более явным контролем со стороны презентера.

#### Пример реализации

```typescript
// Интерфейс представления
interface IUserView {
  showUsers(users: User[]): void;
  showUserDetails(user: User): void;
  showMessage(message: string): void;
  bindEvents(): void;
}

// Presenter
class UserPresenter {
  private model: UserModel;
  private view: IUserView;
  
  constructor(model: UserModel, view: IUserView) {
    this.model = model;
    this.view = view;
    this.view.bindEvents();
  }
  
  async loadUsers(): Promise<void> {
    try {
      const users = await this.model.loadUsers();
      this.view.showUsers(users);
    } catch (error) {
      this.view.showMessage('Ошибка при загрузке пользователей');
    }
  }
  
  showUserDetails(user: User): void {
    this.view.showUserDetails(user);
  }
}

// Реализация представления (например, для Electron)
class ElectronUserView implements IUserView {
  private mainWindow: BrowserWindow;
  
  constructor(window: BrowserWindow) {
    this.mainWindow = window;
  }
  
  showUsers(users: User[]): void {
    // Отправляем данные в renderer процесс
    this.mainWindow.webContents.send('users-loaded', users);
  }
  
  showUserDetails(user: User): void {
    // Отправляем данные в renderer процесс
    this.mainWindow.webContents.send('user-details', user);
  }
  
  showMessage(message: string): void {
    // Показываем сообщение пользователю
    this.mainWindow.webContents.send('show-message', message);
  }
  
  bindEvents(): void {
    // Привязываем обработчики событий
    ipcMain.on('load-users-request', async () => {
      // Логика загрузки будет вызвана через презентер
    });
  }
}
```

### Model-View-Controller (MVC)

MVC - классический архитектурный паттерн, состоящий из трех компонентов:

- **Model**: Работа с данными
- **View**: Отображение данных
- **Controller**: Обработка пользовательского ввода и координация между Model и View

## Поведенческие паттерны

### Command

Паттерн Command инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь, а также поддерживать отмену операций.

```typescript
// Интерфейс команды
interface ICommand {
  execute(): void;
  undo?(): void;
}

// Конкретные команды
class OpenFileCommand implements ICommand {
  private filePath: string;
  private app: any; // Ссылка на приложение
  
  constructor(app: any, filePath: string) {
    this.app = app;
    this.filePath = filePath;
  }
  
  execute(): void {
    console.log(`Открытие файла: ${this.filePath}`);
    // Логика открытия файла
    this.app.openFile(this.filePath);
  }
  
  undo?(): void {
    console.log(`Закрытие файла: ${this.filePath}`);
    this.app.closeFile(this.filePath);
  }
}

class SaveFileCommand implements ICommand {
  private filePath: string;
  private content: string;
  private app: any;
  
  constructor(app: any, filePath: string, content: string) {
    this.app = app;
    this.filePath = filePath;
    this.content = content;
  }
  
  execute(): void {
    console.log(`Сохранение файла: ${this.filePath}`);
    this.app.saveFile(this.filePath, this.content);
  }
  
  undo?(): void {
    // Для упрощения, предположим, что у нас есть метод для восстановления
    this.app.restorePreviousVersion(this.filePath);
  }
}

// Менеджер команд для поддержки отмены
class CommandManager {
  private history: ICommand[] = [];
  private historyIndex: number = -1;
  
  executeCommand(command: ICommand): void {
    command.execute();
    this.history.push(command);
    this.historyIndex++;
  }
  
  undo(): void {
    if (this.historyIndex >= 0) {
      const command = this.history[this.historyIndex];
      if (command.undo) {
        command.undo();
      }
      this.historyIndex--;
    }
  }
  
  redo(): void {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      const command = this.history[this.historyIndex];
      command.execute();
    }
  }
}
```

### Observer

Паттерн Observer определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются автоматически.

```typescript
// Интерфейс наблюдателя
interface IObserver {
  update(data: any): void;
}

// Интерфейс субъекта
interface ISubject {
  subscribe(observer: IObserver): void;
  unsubscribe(observer: IObserver): void;
  notify(data: any): void;
}

// Реализация субъекта
class DocumentManager implements ISubject {
  private observers: IObserver[] = [];
  private content: string = '';
  
  subscribe(observer: IObserver): void {
    this.observers.push(observer);
  }
  
  unsubscribe(observer: IObserver): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data: any): void {
    this.observers.forEach(observer => observer.update(data));
  }
  
  updateContent(newContent: string): void {
    this.content = newContent;
    this.notify({ type: 'contentChanged', content: this.content });
  }
  
  getContent(): string {
    return this.content;
  }
}

// Реализация наблюдателя
class StatusBarObserver implements IObserver {
  update(data: any): void {
    if (data.type === 'contentChanged') {
      console.log(`Статус: Документ содержит ${data.content.length} символов`);
    }
  }
}

class TitleBarObserver implements IObserver {
  private window: BrowserWindow;
  
  constructor(window: BrowserWindow) {
    this.window = window;
  }
  
  update(data: any): void {
    if (data.type === 'contentChanged') {
      const hasUnsavedChanges = data.content.length > 0;
      const title = hasUnsavedChanges ? '*Новый документ' : 'Новый документ';
      this.window.setTitle(title);
    }
  }
}
```

## Структурные паттерны

### Singleton

Паттерн Singleton гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

```typescript
class SettingsManager {
  private static instance: SettingsManager;
  private settings: Map<string, any> = new Map();
  
  private constructor() {
    // Загружаем настройки из файла
    this.loadSettings();
  }
  
  public static getInstance(): SettingsManager {
    if (!SettingsManager.instance) {
      SettingsManager.instance = new SettingsManager();
    }
    return SettingsManager.instance;
  }
  
  private loadSettings(): void {
    // Симуляция загрузки настроек
    this.settings.set('theme', 'dark');
    this.settings.set('language', 'ru');
    this.settings.set('autoSave', true);
  }
  
  public get<T>(key: string): T | undefined {
    return this.settings.get(key);
  }
  
  public set(key: string, value: any): void {
    this.settings.set(key, value);
    // Автоматически сохраняем настройки
    this.saveSettings();
  }
  
  private saveSettings(): void {
    // Логика сохранения настроек в файл
    console.log('Настройки сохранены');
  }
}

// Использование
const settings = SettingsManager.getInstance();
settings.set('windowWidth', 800);
console.log(settings.get<number>('windowWidth'));
```

### Proxy

Паттерн Proxy предоставляет замену или.placeholder для другого объекта и контролирует доступ к нему.

```typescript
interface IFileSystem {
  readFile(path: string): string;
  writeFile(path: string, content: string): void;
  deleteFile(path: string): void;
}

class RealFileSystem implements IFileSystem {
  readFile(path: string): string {
    // Реальная реализация чтения файла
    return `Содержимое файла ${path}`;
  }
  
  writeFile(path: string, content: string): void {
    // Реальная реализация записи в файл
    console.log(`Запись в файл ${path}: ${content}`);
  }
  
  deleteFile(path: string): void {
    // Реальная реализация удаления файла
    console.log(`Удаление файла ${path}`);
  }
}

class FileSystemProxy implements IFileSystem {
  private realFileSystem: RealFileSystem;
  private accessLog: string[] = [];
  
  constructor() {
    this.realFileSystem = new RealFileSystem();
  }
  
  readFile(path: string): string {
    this.logAccess(`Чтение файла: ${path}`);
    return this.realFileSystem.readFile(path);
  }
  
  writeFile(path: string, content: string): void {
    this.logAccess(`Запись в файл: ${path}`);
    this.realFileSystem.writeFile(path, content);
  }
  
  deleteFile(path: string): void {
    this.logAccess(`Удаление файла: ${path}`);
    this.realFileSystem.deleteFile(path);
  }
  
  private logAccess(operation: string): void {
    const timestamp = new Date().toISOString();
    this.accessLog.push(`${timestamp} - ${operation}`);
    console.log(`Лог: ${operation}`);
  }
  
  getAccessLog(): string[] {
    return [...this.accessLog];
  }
}
```

## Практические рекомендации

### 1. Выбор подходящего паттерна

- Используйте MVVM для приложений с богатым пользовательским интерфейсом
- Применяйте MVP, когда нужно больше контроля над представлением
- Используйте MVC для более простых приложений или при интеграции с существующими системами

### 2. Комбинирование паттернов

Часто в реальных приложениях используются комбинации нескольких паттернов:

```typescript
// Пример комбинации MVVM + Command
class DocumentViewModel {
  private document: DocumentModel;
  private commandManager: CommandManager;
  
  constructor(document: DocumentModel) {
    this.document = document;
    this.commandManager = new CommandManager();
  }
  
  openFile(filePath: string): void {
    const command = new OpenFileCommand(this, filePath);
    this.commandManager.executeCommand(command);
  }
  
  saveFile(): void {
    const command = new SaveFileCommand(this, this.document.path, this.document.content);
    this.commandManager.executeCommand(command);
  }
  
  undo(): void {
    this.commandManager.undo();
  }
  
  redo(): void {
    this.commandManager.redo();
  }
}
```

### 3. Тестирование

Паттерны проектирования упрощают тестирование:

```typescript
// Мок для тестирования
class MockUserModel implements UserModel {
  private mockUsers: User[] = [
    { id: 1, name: 'Тестовый Пользователь', email: 'test@example.com' }
  ];
  
  async loadUsers(): Promise<User[]> {
    return this.mockUsers;
  }
  
  async saveUser(user: User): Promise<void> {
    this.mockUsers.push(user);
  }
}

// Тестирование ViewModel
describe('UserViewModel', () => {
  it('should load users correctly', async () => {
    const mockModel = new MockUserModel();
    const viewModel = new UserViewModel(mockModel);
    
    await viewModel.loadUsers();
    
    expect(viewModel.users.length).toBe(1);
    expect(viewModel.users[0].name).toBe('Тестовый Пользователь');
  });
});
```

## Связанные темы

- [[Electron]] - Фреймворк для создания десктопных приложений
- [[Tauri]] - Современный фреймворк для десктопных приложений
- [[Neutralino]] - Легковесный фреймворк для десктопных приложений
- [[Оптимизация-для-десктопа]] - Рекомендации по оптимизации десктопных приложений
- [[Архитектура приложений]] - Общие принципы архитектуры приложений
- [[Паттерны проектирования]] - Общие паттерны проектирования

## Заключение

Десктопные паттерны проектирования играют важную роль в создании масштабируемых и поддерживаемых приложений. Правильный выбор и применение этих паттернов помогает разработчикам создавать качественные десктопные приложения с чистой архитектурой и легко тестируемым кодом.