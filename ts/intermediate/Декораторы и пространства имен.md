---
tags: [typescript, frontend, decorators, namespaces]
aliases: [Декораторы TypeScript, Пространства имен]
---

# Декораторы и пространства имен

## Введение

Декораторы и пространства имен - это продвинутые возможности TypeScript, которые позволяют изменять поведение классов, методов, свойств и других элементов кода, а также организовывать код в логические группы.

## Декораторы

Декораторы - это специальная разновидность объявления, которая может быть применена к классам, методам, методам доступа, свойствам, параметрам и другим объявлениям. Декораторы - это функции, вызываемые с определенными параметрами в зависимости от декорируемого элемента.

### Включение декораторов

Для использования декораторов необходимо включить соответствующую опцию в `tsconfig.json`:

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

### Типы декораторов

#### Декораторы классов

```ts
// Простой декоратор класса
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

// Декоратор с параметрами
function reportable<T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        reporting = true;
    };
}

@reportable
class Person {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

const person = new Person("Alice");
console.log(person.reporting); // true
```

#### Декораторы методов

```ts
// Декоратор метода для логирования
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with`, args);
        const result = originalMethod.apply(this, args);
        console.log(`${propertyKey} returned`, result);
        return result;
    };

    return descriptor;
}

// Декоратор для проверки аутентификации
function requireAuth(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        if (!this.isAuthenticated) {
            throw new Error("Authentication required");
        }
        return originalMethod.apply(this, args);
    };

    return descriptor;
}

class UserService {
    isAuthenticated = true;

    @log
    @requireAuth
    getUser(id: number) {
        return { id, name: `User ${id}` };
    }
}
```

#### Декораторы свойств

```ts
// Декоратор для отслеживания изменений свойства
function observable(target: any, propertyKey: string) {
    let value: any;

    const getter = function () {
        console.log(`Get: ${propertyKey} => ${value}`);
        return value;
    };

    const setter = function (newVal: any) {
        console.log(`Set: ${propertyKey} => ${newVal}`);
        value = newVal;
    };

    Object.defineProperty(target, propertyKey, {
        get: getter,
        set: setter,
        enumerable: true,
        configurable: true
    });
}

class Task {
    @observable
    name: string;

    constructor(name: string) {
        this.name = name;
    }
}

const task = new Task("Initial task");
task.name = "Updated task"; // Выведет: Set: name => Updated task
console.log(task.name); // Выведет: Get: name => Updated task
```

#### Декораторы параметров

```ts
// Декоратор параметра для валидации
function validate(target: any, propertyName: string, parameterIndex: number) {
    console.log(`Validating parameter at index ${parameterIndex} of ${propertyName}`);
}

class Calculator {
    multiply(@validate x: number, @validate y: number): number {
        return x * y;
    }
}
```

### Практическое применение декораторов в frontend разработке

```ts
// Декоратор для кэширования результатов метода
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map();

    descriptor.value = function (...args: any[]) {
        const key = JSON.stringify(args);
        if (cacheMap.has(key)) {
            return cacheMap.get(key);
        }
        const result = originalMethod.apply(this, args);
        cacheMap.set(key, result);
        return result;
    };

    return descriptor;
}

// Декоратор для ограничения частоты вызовов (debounce)
function debounce(delay: number) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        let timeoutId: any;

        descriptor.value = function (...args: any[]) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                originalMethod.apply(this, args);
            }, delay);
        };

        return descriptor;
    };
}

class SearchService {
    @cache
    async search(query: string) {
        // Симуляция API вызова
        return await new Promise(resolve => 
            setTimeout(() => resolve(`Results for ${query}`), 100)
        );
    }

    @debounce(300)
    handleInput(value: string) {
        console.log(`Searching for: ${value}`);
        // Вызов поиска с задержкой
    }
}
```

## Пространства имен

Пространства имен (namespaces) - это способ организации кода в TypeScript, особенно полезный для избежания конфликта имен.

### Основы пространств имен

```ts
// Пространство имен для валидации
namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    const lettersRegexp = /^[A-Za-z]+$/;
    const numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 && numberRegexp.test(s);
        }
    }
}

// Использование пространства имен
let strings = ["Hello", "98052", "101"];
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();

for (let s of strings) {
    for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${s}' ${isMatch ? "matches" : "does not match"} ${name}`);
    }
}
```

### Вложенные пространства имен

```ts
namespace Geometry {
    export namespace Shapes {
        export interface Shape {
            area(): number;
        }

        export class Circle implements Shape {
            constructor(public radius: number) {}

            area(): number {
                return Math.PI * this.radius * this.radius;
            }
        }

        export class Rectangle implements Shape {
            constructor(public width: number, public height: number) {}

            area(): number {
                return this.width * this.height;
            }
        }
    }

    export namespace Utils {
        export function totalArea(shapes: Shapes.Shape[]): number {
            return shapes.reduce((sum, shape) => sum + shape.area(), 0);
        }
    }
}

// Использование вложенных пространств имен
const circle = new Geometry.Shapes.Circle(5);
const rectangle = new Geometry.Shapes.Rectangle(4, 6);

const total = Geometry.Utils.totalArea([circle, rectangle]);
console.log(`Total area: ${total}`);
```

### Слияние пространств имен

```ts
// Первое определение пространства имен
namespace MyLibrary {
    export function utilityFunction(): string {
        return "Utility function from first definition";
    }
}

// Второе определение того же пространства имен
namespace MyLibrary {
    export function anotherUtility(): number {
        return 42;
    }
    
    export class MyClass {
        method() {
            return utilityFunction(); // Может обращаться к функции из первого определения
        }
    }
}

// Оба определения объединены
const result1 = MyLibrary.utilityFunction(); // "Utility function from first definition"
const result2 = MyLibrary.anotherUtility(); // 42
const instance = new MyLibrary.MyClass();
```

## Современные альтернативы пространствам имен

В современной разработке на TypeScript предпочтительно использовать модули (ES6 modules) вместо пространств имен:

```ts
// utils/validation.ts
export interface StringValidator {
    isAcceptable(s: string): boolean;
}

const lettersRegexp = /^[A-Za-z]+$/;
const numberRegexp = /^[0-9]+$/;

export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}

// main.ts
import { LettersOnlyValidator, ZipCodeValidator } from './utils/validation';

const lettersValidator = new LettersOnlyValidator();
```

## Практическое применение в frontend разработке

### Использование декораторов в Angular (пример)

```ts
// Декораторы в Angular
import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-user-card',
  template: `
    <div class="user-card">
      <h3>{{ user.name }}</h3>
      <button (click)="onSelect.emit(user)">Select</button>
    </div>
  `
})
export class UserCardComponent {
  @Input() user: any;
  @Output() onSelect = new EventEmitter<any>();
}
```

### Пространства имен для организации конфигурации

```ts
// config/app.ts
namespace AppConfiguration {
    export const API_BASE_URL = 'https://api.example.com';
    
    export namespace Endpoints {
        export const USERS = '/users';
        export const POSTS = '/posts';
    }
    
    export namespace Themes {
        export const LIGHT = 'light';
        export const DARK = 'dark';
    }
}

// Использование
const apiUrl = `${AppConfiguration.API_BASE_URL}${AppConfiguration.Endpoints.USERS}`;
```

## Заключение

Декораторы и пространства имен предоставляют мощные возможности для организации и расширения функциональности кода. Декораторы особенно полезны для добавления метаданных и изменения поведения элементов, а пространства имен помогают избежать конфликта имен в больших приложениях.

> [!tip] Совет
> Используйте декораторы для добавления общих функций (логирование, кэширование, валидация) к классам и методам.

> [!warning] Важно
> В современной разработке предпочтительно использовать модули ES6 вместо пространств имен, особенно при работе с bundler'ами.

## Связанные темы

- [[Модули и системы сборки]]
- [[Интерфейсы и классы]]
- [[Утилиты типов TypeScript]]