---
tags: [typescript, frontend, generics, conditional-types]
aliases: [Дженерики в TypeScript, Условные типы]
---

# Дженерики и условные типы

## Введение

Дженерики и условные типы являются продвинутыми возможностями TypeScript, которые позволяют создавать гибкий и переиспользуемый код. Они особенно важны при разработке компонентов и библиотек для frontend разработки.

## Дженерики

Дженерики позволяют создавать компоненты, которые могут работать с различными типами данных, обеспечивая при этом типобезопасность.

### Основы дженериков

```ts
// Обычная функция, работающая только с массивом строк
function identityString(arg: string): string {
    return arg;
}

// Функция с дженериком, работающая с любым типом
function identity<T>(arg: T): T {
    return arg;
}

// Использование дженерика
let output1 = identity<string>("myString"); // Явное указание типа
let output2 = identity("myString");         // Вывод типа (type inference)

// Дженерики в интерфейсах
interface GenericIdentityFn<T> {
    (arg: T): T;
}

function identityFn<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identityFn;
```

### Работа с дженериками в классах

```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };

// Дженерики с ограничениями
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Теперь мы знаем, что у arg есть свойство length
    return arg;
}

// Использование с объектами, имеющими свойство length
loggingIdentity({ length: 10, value: 3 }); // OK
// loggingIdentity(3); // Error: у числа нет свойства length
```

### Использование ключей объекта (keyof)

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // Okay
// getProperty(x, "m"); // Error: "m" is not a key of x
```

## Условные типы

Условные типы позволяют выражать типы, которые зависят от условий.

### Основы условных типов

```ts
// Условный тип: T extends U ? X : Y
type TypeName<T> = T extends string 
    ? "string" 
    : T extends number 
        ? "number" 
        : T extends boolean 
            ? "boolean" 
            : "object";

type T0 = TypeName<string>;  // "string"
type T1 = TypeName<"a">;     // "string"
type T2 = TypeName<true>;    // "boolean"
type T3 = TypeName<() => void>; // "object"
```

### Условные типы с дистрибутивностью

```ts
// Дистрибутивные условные типы применяются к каждому члену объединения
type ToArray<T> = T extends any ? T[] : never;

type T4 = ToArray<string | number>; // string[] | number[]
```

### Встроенные условные типы

TypeScript предоставляет несколько встроенных условных типов:

```ts
// Extract<T, U> - извлекает типы из T, которые могут быть присвоены U
type T5 = Extract<"a" | "b" | "c", "a" | "f">; // "a"

// Exclude<T, U> - исключает типы из T, которые могут быть присвоены U
type T6 = Exclude<"a" | "b" | "c", "a" | "f">; // "b" | "c"

// NonNullable<T> - исключает null и undefined из T
type T7 = NonNullable<string | number | undefined>; // string | number

// ReturnType<T> - возвращает тип возвращаемого значения функции
type T8 = ReturnType<() => string>; // string

// InstanceType<T> - возвращает тип экземпляра класса
class C {
    x = 0;
    y = 0;
}

type T9 = InstanceType<typeof C>; // C
```

## Практическое применение в frontend разработке

### Типизация React компонентов с дженериками

```tsx
import React from 'react';

// Дженерик для компонента списка
interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
}

function List<T>(props: ListProps<T>) {
    return (
        <ul>
            {props.items.map((item, index) => (
                <li key={index}>{props.renderItem(item)}</li>
            ))}
        </ul>
    );
}

// Использование компонента списка
interface User {
    id: number;
    name: string;
}

const users: User[] = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

function UserList() {
    return (
        <List 
            items={users} 
            renderItem={(user) => <span>{user.name}</span>} 
        />
    );
}
```

### Условные типы для типизации API

```ts
// Типизация ответа API с условными типами
type ApiResponse<T> = {
    data: T;
    status: 'success' | 'error';
    message?: string;
};

// Условный тип для обработки успешных ответов
type SuccessResponse<T> = T extends { status: 'success' } ? T : never;

// Утилита для извлечения типа данных из ответа
type ExtractData<T> = T extends ApiResponse<infer U> ? U : never;

// Пример использования
type UserResponse = ApiResponse<User>;
type UserData = ExtractData<UserResponse>; // User
```

### Дженерики для типизации хуков

```ts
import { useState, useEffect } from 'react';

// Кастомный хук с дженериком
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
    const [storedValue, setStoredValue] = useState<T>(() => {
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        } catch (error) {
            return initialValue;
        }
    });

    const setValue = (value: T) => {
        try {
            setStoredValue(value);
            window.localStorage.setItem(key, JSON.stringify(value));
        } catch (error) {
            console.error(error);
        }
    };

    return [storedValue, setValue];
}

// Использование хука
const [userPreferences, setUserPreferences] = useLocalStorage<UserPreferences>(
    'user-preferences',
    { theme: 'light', notifications: true }
);
```

## Продвинутые паттерны

### Ограничения дженериков на основе других параметров

```ts
// Ограничение типа T на основе типа K
function getPropertyFromObject<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getPropertyFromObject(person, "name"); // string
const age = getPropertyFromObject(person, "age");   // number
```

### Условные типы для маппинга свойств

```ts
// Условный тип для создания обязательных свойств
type RequiredBut<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

interface User {
    id: number;
    name?: string;
    email?: string;
    age?: number;
}

// Делаем только name обязательным
type UserWithName = RequiredBut<User, 'name'>;
// Результат: { id: number; name: string; email?: string; age?: number; }
```

## Заключение

Дженерики и условные типы - мощные инструменты, которые позволяют создавать гибкий и типобезопасный код. Они особенно полезны при разработке библиотек, компонентов и API клиентов в frontend разработке.

> [!tip] Совет
> Используйте дженерики для создания переиспользуемых компонентов и функций, которые работают с различными типами данных.

> [!warning] Важно
> Не переусложняйте типы - чрезмерное использование дженериков может сделать код трудночитаемым.

## Связанные темы

- [[Утилиты типов TypeScript]]
- [[Интерфейсы и классы]]
- [[Продвинутые типы и метапрограммирование на типах]]