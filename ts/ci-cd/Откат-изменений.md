---
aliases: [Rollback, Откат изменений]
tags: [typescript, ci-cd, rollback, deployment, recovery]
---

# Откат изменений в CI/CD процессах TypeScript-проектов

## Обзор

Откат изменений (rollback) является критически важной частью CI/CD процесса, обеспечивающей возможность быстрого восстановления работоспособности приложения при возникновении проблем после деплоя. В TypeScript-проектах откат должен учитывать как изменения кода, так и изменения типов и структуры приложения.

## Когда необходим откат

### Автоматический откат

Автоматический откат может быть инициирован при:

- Высоком проценте ошибок после деплоя (>5%)
- Увеличении времени отклика более чем на 50%
- Падении health check endpoint
- Нарушении SLA показателей
- Критических ошибках в логах

### Ручной откат

Ручной откат может быть инициирован:

- При обнаружении критических багов в продакшене
- При сбоях в интеграциях с внешними сервисами
- При проблемах с производительностью
- По решению команды после анализа ситуации

## Стратегии отката

### Blue-Green Deployment

При использовании blue-green стратегии откат реализуется переключением трафика обратно на старую версию:

```yaml
# GitHub Actions для Blue-Green отката
name: Rollback Blue-Green
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to rollback'
        required: true
        default: 'production'
      reason:
        description: 'Reason for rollback'
        required: true

jobs:
  rollback:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
    - name: Switch traffic to previous version
      run: |
        # Переключение трафика на зеленую версию (если сейчас синяя)
        if [ "${{ inputs.environment }}" = "production" ]; then
          kubectl patch service myapp-service -p '{"spec":{"selector":{"version":"green"}}}'
        fi
        
    - name: Notify team about rollback
      run: |
        curl -X POST -H 'Content-Type: application/json' \
        -d '{"text":"Rollback initiated in ${{ inputs.environment }} environment. Reason: ${{ inputs.reason }}"}' \
        ${{ secrets.SLACK_WEBHOOK_URL }}
```

### Canary Release

Для canary релизов откат включает в себя остановку увеличения трафика и возврат к предыдущей версии:

```typescript
// rollback.service.ts
export class RollbackService {
  async rollbackCanary(deploymentId: string): Promise<boolean> {
    try {
      // Получение информации о текущем канареечном релизе
      const canaryInfo = await this.getCanaryInfo(deploymentId);
      
      // Уменьшение трафика до 0%
      await this.updateTrafficWeight(deploymentId, 0);
      
      // Удаление новой версии
      await this.removeCanaryVersion(deploymentId);
      
      // Восстановление предыдущей стабильной версии
      await this.activatePreviousVersion(canaryInfo.previousVersion);
      
      // Логирование отката
      console.log(`Canary rollback completed for deployment ${deploymentId}`);
      
      return true;
    } catch (error) {
      console.error(`Rollback failed: ${error}`);
      return false;
    }
  }

  private async getCanaryInfo(deploymentId: string) {
    // Логика получения информации о канареечном релизе
    return {
      previousVersion: 'v1.2.3',
      currentVersion: 'v1.3.0',
      trafficDistribution: { old: 90, new: 10 }
    };
  }

  private async updateTrafficWeight(deploymentId: string, weight: number) {
    // Логика обновления распределения трафика
    console.log(`Updating traffic weight for ${deploymentId} to ${weight}%`);
  }

  private async removeCanaryVersion(deploymentId: string) {
    // Логика удаления канареечной версии
    console.log(`Removing canary version for ${deploymentId}`);
  }

  private async activatePreviousVersion(version: string) {
    // Логика активации предыдущей версии
    console.log(`Activating previous version ${version}`);
  }
}
```

### Docker-базированный откат

```bash
#!/bin/bash
# rollback.sh

# Параметры
ENVIRONMENT=${1:-production}
IMAGE_TAG=${2:-latest}

echo "Starting rollback for environment: $ENVIRONMENT"

# Получение предыдущего тега образа
PREVIOUS_TAG=$(curl -s https://registry.hub.docker.com/v2/repositories/myorg/myapp/tags/ | \
               jq -r '.results[] | select(.name != "latest") | .name' | \
               sort -V | tail -2 | head -1)

if [ -z "$PREVIOUS_TAG" ]; then
    echo "Error: Could not determine previous image tag"
    exit 1
fi

echo "Rolling back to image tag: $PREVIOUS_TAG"

# Обновление Kubernetes deployment
kubectl set image deployment/myapp-deployment \
    myapp-container=myorg/myapp:$PREVIOUS_TAG \
    -n $ENVIRONMENT

# Ожидание завершения обновления
kubectl rollout status deployment/myapp-deployment -n $ENVIRONMENT

if [ $? -eq 0 ]; then
    echo "Rollback successful to version $PREVIOUS_TAG"
    
    # Отправка уведомления
    curl -X POST -H 'Content-Type: application/json' \
    -d "{\"text\":\"Rollback to version $PREVIOUS_TAG completed successfully\"}" \
    $SLACK_WEBHOOK_URL
else
    echo "Rollback failed"
    exit 1
fi
```

## Автоматизированный откат на основе метрик

### Использование Prometheus для определения необходимости отката

```typescript
// auto-rollback.service.ts
import { MetricsService } from './metrics.service';

export class AutoRollbackService {
  constructor(private metricsService: MetricsService) {}

  async checkForAutoRollback(): Promise<boolean> {
    const errorRate = await this.metricsService.getErrorRate();
    const responseTime = await this.metricsService.getAverageResponseTime();
    
    // Проверка условий для автоматического отката
    if (errorRate > 5) { // Если процент ошибок > 5%
      console.log(`High error rate detected: ${errorRate}%. Initiating rollback.`);
      await this.performRollback('High error rate detected');
      return true;
    }
    
    if (responseTime > 5000) { // Если время ответа > 5 секунд
      console.log(`High response time detected: ${responseTime}ms. Initiating rollback.`);
      await this.performRollback('High response time detected');
      return true;
    }
    
    return false;
  }

  private async performRollback(reason: string) {
    console.log(`Starting automated rollback: ${reason}`);
    
    // Логика отката
    // 1. Остановка новых деплоев
    // 2. Переключение на предыдущую версию
    // 3. Обновление конфигурации
    // 4. Уведомление команды
    
    console.log('Rollback completed');
  }
}
```

### Kubernetes Helm rollback

```yaml
# rollback-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: rollback-job
spec:
  template:
    spec:
      containers:
      - name: rollback
        image: bitnami/helm:latest
        command: 
        - /bin/sh
        - -c
        - |
          # Выполнение отката Helm релиза
          helm rollback myapp-release --namespace production
          
          # Проверка статуса после отката
          sleep 30
          STATUS=$(helm status myapp-release --namespace production | grep Status)
          if echo $STATUS | grep -q "deployed"; then
            echo "Rollback successful"
          else
            echo "Rollback failed"
            exit 1
          fi
      restartPolicy: Never
  backoffLimit: 4
```

## Откат TypeScript-специфичных изменений

### Управление изменениями типов

При откате изменений, затрагивающих типы данных, необходимо учитывать:

```typescript
// Версия 1.2.3
export interface User {
  id: number;
  name: string;
  email: string;
}

// Версия 1.3.0 (новая, которую нужно откатить)
export interface User {
  id: number;
  name: string;
  email: string;
  phone?: string;  // Новое поле
  preferences: UserPreferences; // Новый тип
}

export interface UserPreferences {
  theme: 'light' | 'dark';
  notifications: boolean;
}
```

При откате необходимо:
1. Вернуть предыдущую версию интерфейсов
2. Обновить все места использования новых типов
3. Убедиться в совместимости с API
4. Проверить сборку проекта

### Работа с миграциями базы данных

```typescript
// rollback-migration.service.ts
export class MigrationRollbackService {
  async rollbackMigration(migrationName: string): Promise<boolean> {
    try {
      // Определение зависимостей миграции
      const dependencies = await this.getMigrationDependencies(migrationName);
      
      if (dependencies.length > 0) {
        console.warn(`Migration ${migrationName} has dependencies:`, dependencies);
        // Требуется откат зависимых миграций
      }
      
      // Выполнение отката миграции
      await this.executeRollback(migrationName);
      
      // Обновление статуса миграции в системе
      await this.updateMigrationStatus(migrationName, 'rolled_back');
      
      return true;
    } catch (error) {
      console.error(`Migration rollback failed: ${error}`);
      return false;
    }
  }

  private async getMigrationDependencies(migrationName: string) {
    // Логика определения зависимостей миграции
    return [];
  }

  private async executeRollback(migrationName: string) {
    // Логика выполнения отката миграции
    console.log(`Rolling back migration: ${migrationName}`);
  }

  private async updateMigrationStatus(migrationName: string, status: string) {
    // Логика обновления статуса миграции
    console.log(`Updated migration ${migrationName} status to ${status}`);
  }
}
```

## CI/CD конфигурации для отката

### GitHub Actions

```yaml
name: Automated Rollback
on:
  schedule:
    # Проверка каждые 5 минут
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      deployment_id:
        description: 'Deployment ID to rollback'
        required: true
      reason:
        description: 'Reason for rollback'
        required: true

jobs:
  check-and-rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
    - name: Check application health
      id: health_check
      run: |
        HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.HEALTH_CHECK_URL }})
        if [ $HEALTH_STATUS -ne 200 ]; then
          echo "Health check failed with status: $HEALTH_STATUS"
          echo "needs_rollback=true" >> $GITHUB_OUTPUT
        else
          echo "Application is healthy"
          echo "needs_rollback=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Get current deployment info
      if: steps.health_check.outputs.needs_rollback == 'true'
      run: |
        # Получение информации о текущем деплое
        CURRENT_DEPLOYMENT=$(kubectl get deployment myapp -o jsonpath='{.spec.template.spec.containers[0].image}')
        echo "Current deployment: $CURRENT_DEPLOYMENT"
        
    - name: Rollback to previous version
      if: steps.health_check.outputs.needs_rollback == 'true'
      run: |
        # Откат к предыдущей версии
        kubectl rollout undo deployment/myapp --namespace production
        
        # Проверка статуса отката
        kubectl rollout status deployment/myapp --namespace production
        
    - name: Notify about rollback
      if: steps.health_check.outputs.needs_rollback == 'true'
      run: |
        curl -X POST -H 'Content-Type: application/json' \
        -d '{"text":"Automated rollback executed due to health check failure"}' \
        ${{ secrets.SLACK_WEBHOOK_URL }}

  manual-rollback:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
    - name: Manual rollback
      run: |
        echo "Manual rollback initiated for deployment ${{ github.event.inputs.deployment_id }}"
        echo "Reason: ${{ github.event.inputs.reason }}"
        
        # Логика ручного отката
        kubectl rollout undo deployment/myapp --namespace production
        
    - name: Record rollback
      run: |
        # Запись информации об откате
        echo "$(date): Rollback of ${{ github.event.inputs.deployment_id }} - ${{ github.event.inputs.reason }}" >> rollback-log.txt
```

### GitLab CI

```yaml
stages:
  - monitor
  - rollback

variables:
  DEPLOYMENT_NAMESPACE: production

auto_rollback:
  stage: monitor
  script:
    - |
      # Проверка метрик приложения
      ERROR_RATE=$(curl -s "${PROMETHEUS_URL}/api/v1/query?query=rate(http_requests_total{status_code=~'5..'}[5m])" | jq -r '.data.result[0].value[1]')
      
      if (( $(echo "$ERROR_RATE > 0.05" | bc -l) )); then
        echo "High error rate detected: ${ERROR_RATE}. Initiating rollback..."
        # Выполнение отката
        kubectl rollout undo deployment/myapp --namespace $DEPLOYMENT_NAMESPACE
        exit 0
      else
        echo "Error rate is acceptable: ${ERROR_RATE}"
        exit 0
      fi
  when: on_success
  only:
    - schedules
    - branches

rollback_manual:
  stage: rollback
  script:
    - echo "Manual rollback initiated"
    - kubectl rollout undo deployment/myapp --namespace $DEPLOYMENT_NAMESPACE
    - kubectl rollout status deployment/myapp --namespace $DEPLOYMENT_NAMESPACE
  when: manual
  only:
    - main
```

## Лучшие практики отката

1. **Тестирование процесса отката** в тестовой среде
2. **Сохранение артефактов** предыдущих версий для быстрого отката
3. **Использование семантического версионирования** для четкой идентификации версий
4. **Автоматизация проверок** после отката
5. **Ведение логов** всех операций отката
6. **Уведомление команды** о выполнении отката
7. **Анализ причин** необходимости отката для предотвращения в будущем

## Связанные темы

- [[Сборка-и-деплой]]
- [[Мониторинг-при-развертывании]]
- [[Тестирование-и-линтинг]]
- [[Канареечные-релизы]]
- [[Blue-Green-деплой]]