---
aliases: [Deployment Monitoring, Мониторинг при развертывании]
tags: [typescript, ci-cd, monitoring, deployment, observability]
---

# Мониторинг при развертывании в CI/CD процессах TypeScript-проектов

## Обзор

Мониторинг при развертывании (deployment monitoring) играет ключевую роль в обеспечении стабильности и надежности TypeScript-приложений. Он позволяет отслеживать здоровье приложения после деплоя и быстро реагировать на возникающие проблемы.

## Основные аспекты мониторинга

### Метрики производительности

При развертывании важно отслеживать:

- **Время отклика (Response Time)**: Среднее время обработки запросов
- **Процент ошибок (Error Rate)**: Доля неудачных запросов
- **Пропускная способность (Throughput)**: Количество запросов в единицу времени
- **Использование ресурсов**: CPU, память, дисковое пространство

#### Пример метрик для TypeScript-приложения

```typescript
// metrics.service.ts
import express from 'express';

interface Metrics {
  responseTime: number;
  errorCount: number;
  requestCount: number;
  timestamp: Date;
}

export class MetricsService {
  private metrics: Metrics[] = [];

  recordResponseTime(responseTime: number) {
    this.metrics.push({
      responseTime,
      errorCount: 0,
      requestCount: 1,
      timestamp: new Date()
    });
  }

  getAverageResponseTime(): number {
    const sum = this.metrics.reduce((acc, metric) => acc + metric.responseTime, 0);
    return this.metrics.length > 0 ? sum / this.metrics.length : 0;
  }

  getErrorRate(): number {
    const totalRequests = this.metrics.length;
    const errorRequests = this.metrics.filter(m => m.errorCount > 0).length;
    return totalRequests > 0 ? (errorRequests / totalRequests) * 100 : 0;
  }
}
```

### Логирование

Эффективное логирование помогает отслеживать события приложения:

```typescript
// logger.service.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// Использование в приложении
export class DeploymentLogger {
  logDeployment(deploymentId: string, status: 'success' | 'failed', details?: any) {
    logger.info(`Deployment ${deploymentId} ${status}`, {
      deploymentId,
      status,
      timestamp: new Date(),
      details
    });
  }

  logError(error: Error, context: string) {
    logger.error(`Error in ${context}: ${error.message}`, {
      stack: error.stack,
      timestamp: new Date()
    });
  }
}
```

## Интеграция с системами мониторинга

### Prometheus и Grafana

```typescript
// prometheus.metrics.ts
import client from 'prom-client';

// Создание метрик
export const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
});

export const httpRequestTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code'],
});

// Middleware для измерения времени выполнения
export function metricsMiddleware() {
  return (req: any, res: any, next: any) => {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = (Date.now() - start) / 1000;
      httpRequestDuration
        .labels(req.method, req.route?.path || req.path, res.statusCode.toString())
        .observe(duration);
        
      httpRequestTotal
        .labels(req.method, req.route?.path || req.path, res.statusCode.toString())
        .inc();
    });
    
    next();
  };
}
```

### Application Performance Monitoring (APM)

Использование APM-инструментов:

```typescript
// apm.config.ts
import * as apm from 'elastic-apm-node';

if (process.env.NODE_ENV === 'production') {
  apm.start({
    serviceName: 'my-typescript-app',
    serverUrl: process.env.ELASTIC_APM_SERVER_URL,
    secretToken: process.env.ELASTIC_APM_SECRET_TOKEN,
    environment: process.env.NODE_ENV,
    captureExceptions: true,
    errorOnAbortedRequests: true,
  });
}

// Middleware для отслеживания транзакций
export function apmMiddleware() {
  return (req: any, res: any, next: any) => {
    const transaction = apm.startTransaction(`${req.method} ${req.path}`);
    
    res.on('finish', () => {
      if (transaction) {
        transaction.setResult(res.statusCode);
        transaction.end();
      }
    });
    
    next();
  };
}
```

## Мониторинг в CI/CD пайплайнах

### GitHub Actions

```yaml
name: Deployment Monitoring
on:
  deployment_status:
jobs:
  notify-on-deployment:
    runs-on: ubuntu-latest
    if: github.event.deployment_status.state == 'success'
    steps:
    - name: Send deployment notification
      run: |
        curl -X POST -H 'Content-Type: application/json' \
        -d '{"text":"Deployment to '${{ github.event.deployment_status.environment }}' successful!"}' \
        ${{ secrets.SLACK_WEBHOOK_URL }}
        
  health-check:
    runs-on: ubuntu-latest
    needs: notify-on-deployment
    strategy:
      matrix:
        attempt: [1, 2, 3]
    steps:
    - name: Wait for deployment to be ready
      run: sleep 30
    - name: Health check
      run: |
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.HEALTH_CHECK_URL }})
        if [ $RESPONSE -ne 200 ]; then
          echo "Health check failed with status: $RESPONSE"
          exit 1
        fi
        echo "Health check passed"
```

### GitLab CI

```yaml
stages:
  - deploy
  - monitor

deploy:
  stage: deploy
  script:
    - echo "Deploying application..."
    - # Команды деплоя
  environment:
    name: production
    url: https://myapp.com
  after_script:
    - echo "Deployment completed"

post-deployment-monitoring:
  stage: monitor
  script:
    - |
      # Проверка статуса приложения
      STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://myapp.com/health)
      if [ $STATUS -ne 200 ]; then
        echo "Application health check failed with status: $STATUS"
        exit 1
      fi
      echo "Application is healthy"
    - |
      # Проверка метрик
      # Здесь может быть вызов скрипта для проверки метрик в Prometheus
      ./scripts/check-metrics.sh
  when: on_success
  dependencies:
    - deploy
```

## Health Checks

### Реализация health check endpoint

```typescript
// health.controller.ts
import express from 'express';

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  checks: {
    [key: string]: {
      status: 'up' | 'down';
      responseTime?: number;
      error?: string;
    };
  };
  timestamp: string;
}

export class HealthController {
  async getHealthStatus(): Promise<HealthStatus> {
    const checks: HealthStatus['checks'] = {};
    let overallStatus: HealthStatus['status'] = 'healthy';

    // Проверка базы данных
    try {
      const dbStartTime = Date.now();
      // Здесь будет проверка подключения к базе данных
      const dbResponseTime = Date.now() - dbStartTime;
      
      checks.database = {
        status: 'up',
        responseTime: dbResponseTime
      };
    } catch (error) {
      checks.database = {
        status: 'down',
        error: (error as Error).message
      };
      overallStatus = 'unhealthy';
    }

    // Проверка внешних сервисов
    try {
      const externalStartTime = Date.now();
      // Проверка внешнего API
      const externalResponseTime = Date.now() - externalStartTime;
      
      checks.externalServices = {
        status: 'up',
        responseTime: externalResponseTime
      };
    } catch (error) {
      checks.externalServices = {
        status: 'down',
        error: (error as Error).message
      };
      if (overallStatus === 'healthy') {
        overallStatus = 'degraded';
      }
    }

    return {
      status: overallStatus,
      checks,
      timestamp: new Date().toISOString()
    };
  }

  setupRoutes(app: express.Application) {
    app.get('/health', async (req, res) => {
      try {
        const healthStatus = await this.getHealthStatus();
        const statusCode = healthStatus.status === 'healthy' ? 200 : 503;
        res.status(statusCode).json(healthStatus);
      } catch (error) {
        res.status(503).json({
          status: 'unhealthy',
          checks: {},
          timestamp: new Date().toISOString(),
          error: (error as Error).message
        });
      }
    });

    app.get('/ready', (req, res) => {
      // Проверка готовности приложения к обработке запросов
      res.status(200).send('OK');
    });
  }
}
```

## Алертинг и уведомления

### Настройка алертов

```typescript
// alert.service.ts
interface Alert {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
  resolved: boolean;
}

export class AlertService {
  private alerts: Alert[] = [];

  createAlert(title: string, description: string, severity: Alert['severity']) {
    const alert: Alert = {
      id: Math.random().toString(36).substring(2, 9),
      title,
      description,
      severity,
      timestamp: new Date(),
      resolved: false
    };

    this.alerts.push(alert);
    this.sendNotification(alert);
    return alert;
  }

  resolveAlert(alertId: string) {
    const alert = this.alerts.find(a => a.id === alertId);
    if (alert) {
      alert.resolved = true;
    }
  }

  private sendNotification(alert: Alert) {
    // Отправка уведомлений в Slack, Email, и т.д.
    console.log(`Alert: ${alert.title} - ${alert.description} (Severity: ${alert.severity})`);
    
    // Здесь может быть интеграция с системами уведомлений
    // например, отправка в Slack, Email или PagerDuty
  }

  getActiveAlerts(): Alert[] {
    return this.alerts.filter(alert => !alert.resolved);
  }
}
```

## Анализ и визуализация данных

### Использование Grafana для визуализации

Пример дашборда для мониторинга TypeScript-приложения:

```
{
  "dashboard": {
    "id": null,
    "title": "TypeScript Application Dashboard",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{route}}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total{status_code=~\"5..|4..\"}[5m])",
            "legendFormat": "Errors"
          }
        ]
      }
    ]
  }
}
```

## Лучшие практики

1. **Реализуйте health check endpoints** для проверки состояния приложения
2. **Используйте системы APM** для глубокого мониторинга производительности
3. **Настройте алертинг** для критических метрик
4. **Ведите логирование** всех важных событий
5. **Реализуйте мониторинг зависимостей** (базы данных, внешние API)
6. **Используйте канареечные релизы** с постепенным увеличением трафика
7. **Создавайте дашборды** для визуализации ключевых метрик
8. **Проводите автоматические проверки** после деплоя

## Связанные темы

- [[Сборка-и-деплой]]
- [[Тестирование-и-линтинг]]
- [[Откат-изменений]]
- [[Метрики-производительности]]
- [[Логирование-в-приложениях]]