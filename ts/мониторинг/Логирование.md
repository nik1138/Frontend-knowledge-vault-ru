---
aliases: ["Логирование TypeScript", "Система логирования", "Логи в TypeScript"]
tags: [typescript, monitoring, logging, debugging, best-practices]
---

# Логирование в TypeScript-приложениях

## Обзор

Логирование - это критически важный аспект мониторинга и отладки приложений на TypeScript. Эффективная система логирования позволяет разработчикам отслеживать поведение приложения в реальном времени, диагностировать проблемы и анализировать производительность.

## Основные принципы логирования

### Уровни логирования

В TypeScript-приложениях принято использовать следующие уровни логирования:

- **TRACE** - самая детализированная информация, обычно только при отладке
- **DEBUG** - информация для отладки, полезная при разработке
- **INFO** - общая информация о работе приложения
- **WARN** - предупреждения о потенциальных проблемах
- **ERROR** - ошибки, которые не привели к остановке приложения
- **FATAL** - критические ошибки, приводящие к остановке приложения

### Структурированное логирование

Структурированное логирование с использованием JSON-формата позволяет легче анализировать и парсить логи:

```typescript
interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  context: Record<string, any>;
  stack?: string;
}

class StructuredLogger {
  log(level: string, message: string, context: Record<string, any> = {}) {
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context
    };
    
    console.log(JSON.stringify(logEntry));
  }
  
  info(message: string, context: Record<string, any> = {}) {
    this.log('INFO', message, context);
  }
  
  error(message: string, context: Record<string, any> = {}) {
    this.log('ERROR', message, context);
  }
}
```

## Популярные библиотеки логирования

### Winston

Winston - одна из самых популярных библиотек логирования для Node.js и TypeScript:

```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

export default logger;
```

### Pino

Pino - высокопроизводительная библиотека логирования:

```typescript
import pino from 'pino';

const logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
});

// Использование
logger.info({ user: 'john', action: 'login' }, 'User logged in');
logger.error({ err: new Error('Database connection failed') }, 'Failed to connect to DB');
```

## Лучшие практики логирования

### 1. Используйте контекст в логах

```typescript
// Плохо
logger.info('User created');

// Хорошо
logger.info({
  userId: user.id,
  userName: user.name,
  email: user.email,
  action: 'user_created'
}, 'New user registered');
```

### 2. Избегайте логирования чувствительных данных

```typescript
// Плохо
logger.info({ password: user.password }, 'User login attempt');

// Хорошо
logger.info({
  userId: user.id,
  timestamp: new Date().toISOString()
}, 'User login attempt');
```

### 3. Используйте корреляционные ID для отслеживания запросов

```typescript
import { v4 as uuidv4 } from 'uuid';

function handleRequest(req: Request, res: Response) {
  const correlationId = uuidv4();
  
  const loggerWithContext = logger.child({ correlationId });
  
  loggerWithContext.info('Request started');
  
  // Обработка запроса
  try {
    // ... логика обработки
    loggerWithContext.info('Request completed');
  } catch (error) {
    loggerWithContext.error({ error }, 'Request failed');
  }
}
```

## Логирование в браузере

Для браузерных приложений также важно иметь систему логирования:

```typescript
class BrowserLogger {
  private level: string;
  private remoteLoggingEnabled: boolean;
  
  constructor(level: string = 'info', remoteLoggingEnabled: boolean = false) {
    this.level = level;
    this.remoteLoggingEnabled = remoteLoggingEnabled;
  }
  
  log(level: string, message: string, data?: any) {
    const levels = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR'];
    const currentLevelIndex = levels.indexOf(this.level.toUpperCase());
    const messageLevelIndex = levels.indexOf(level.toUpperCase());
    
    if (messageLevelIndex >= currentLevelIndex) {
      const logEntry = {
        timestamp: new Date().toISOString(),
        level,
        message,
        data,
        userAgent: navigator.userAgent,
        url: window.location.href
      };
      
      console.log(`[${level}] ${message}`, data);
      
      if (this.remoteLoggingEnabled) {
        this.sendToRemoteLog(logEntry);
      }
    }
  }
  
  private async sendToRemoteLog(logEntry: any) {
    try {
      await fetch('/api/logs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(logEntry)
      });
    } catch (error) {
      console.error('Failed to send log to remote server', error);
    }
  }
  
  info(message: string, data?: any) {
    this.log('INFO', message, data);
  }
  
  error(message: string, data?: any) {
    this.log('ERROR', message, data);
  }
}
```

## Интеграция с системами анализа логов

Для эффективного анализа логов часто используются такие системы, как:

- [[ELK Stack]] (Elasticsearch, Logstash, Kibana)
- [[Fluentd]]
- [[Splunk]]

## Заключение

Эффективное логирование - ключ к надежной диагностике и мониторингу приложений. При разработке TypeScript-приложений важно использовать структурированные логи, подходящие библиотеки и следовать лучшим практикам для обеспечения максимальной полезности логов.

См. также:
- [[Метрики]]
- [[Алертинг]]
- [[Трассировка]]
- [[Профилирование]]