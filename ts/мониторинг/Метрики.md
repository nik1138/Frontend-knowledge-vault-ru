---
aliases: ["Метрики TypeScript", "Система метрик", "Мониторинг производительности"]
tags: [typescript, monitoring, metrics, performance, observability]
---

# Метрики в TypeScript-приложениях

## Обзор

Метрики - это числовые значения, которые отслеживают состояние и производительность приложения. Они позволяют разработчикам понимать, как работает приложение в реальном времени, и выявлять потенциальные проблемы производительности.

## Типы метрик

### 1. Счетчики (Counters)

Счетчики представляют собой монотонно возрастающие значения, которые отслеживают количество событий:

```typescript
interface Counter {
  inc(value?: number): void;
  add(value: number): void;
  reset(): void;
}

class SimpleCounter implements Counter {
  private value: number = 0;
  
  inc(value: number = 1) {
    this.value += value;
  }
  
  add(value: number) {
    this.value += value;
  }
  
  reset() {
    this.value = 0;
  }
  
  get(): number {
    return this.value;
  }
}

// Использование
const requestCounter = new SimpleCounter();
requestCounter.inc(); // Увеличиваем при каждом запросе
```

### 2. Гейджи (Gauges)

Гейджи отслеживают текущее значение, которое может как увеличиваться, так и уменьшаться:

```typescript
interface Gauge {
  set(value: number): void;
  inc(value?: number): void;
  dec(value?: number): void;
  get(): number;
}

class MemoryGauge implements Gauge {
  private value: number = 0;
  
  set(value: number) {
    this.value = value;
  }
  
  inc(value: number = 1) {
    this.value += value;
  }
  
  dec(value: number = 1) {
    this.value -= value;
  }
  
  get(): number {
    return this.value;
  }
}

// Использование
const memoryGauge = new MemoryGauge();
setInterval(() => {
  const usedMemory = process.memoryUsage().heapUsed;
  memoryGauge.set(usedMemory);
}, 1000);
```

### 3. Гистограммы (Histograms)

Гистограммы отслеживают распределение значений, таких как время выполнения операций:

```typescript
interface Histogram {
  observe(value: number): void;
  getPercentiles(): { p50: number; p90: number; p95: number; p99: number };
}

class RequestDurationHistogram implements Histogram {
  private values: number[] = [];
  
  observe(value: number) {
    this.values.push(value);
    // Ограничиваем размер для эффективности
    if (this.values.length > 10000) {
      this.values.shift();
    }
  }
  
  getPercentiles(): { p50: number; p90: number; p95: number; p99: number } {
    const sorted = [...this.values].sort((a, b) => a - b);
    const len = sorted.length;
    
    return {
      p50: sorted[Math.floor(len * 0.5)] || 0,
      p90: sorted[Math.floor(len * 0.9)] || 0,
      p95: sorted[Math.floor(len * 0.95)] || 0,
      p99: sorted[Math.floor(len * 0.99)] || 0
    };
  }
}
```

## Библиотеки для работы с метриками

### Prometheus Client

Для Node.js приложений популярна библиотека `prom-client`:

```typescript
import client from 'prom-client';

// Регистрируем метрики
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const httpRequestTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

// Middleware для измерения времени выполнения запросов
const metricsMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000; // в секундах
    const labels = {
      method: req.method,
      route: req.route?.path || req.path,
      status_code: res.statusCode.toString()
    };
    
    httpRequestDuration.labels(labels).observe(duration);
    httpRequestTotal.labels(labels).inc();
  });
  
  next();
};
```

### OpenTelemetry

OpenTelemetry предоставляет стандартный способ сбора метрик:

```typescript
import { MeterProvider, PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { PrometheusExporter } from '@opentelemetry/exporter-prometheus';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

// Настройка экспортера Prometheus
const exporter = new PrometheusExporter({
  port: 9464,
  endpoint: '/metrics'
});

const meterProvider = new MeterProvider({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'my-service'
  })
});

meterProvider.addMetricReader(new PeriodicExportingMetricReader({
  exporter
}));

// Создание измерителя
const meter = meterProvider.getMeter('my-service-meter');

// Создание метрик
const requestCounter = meter.createCounter('requests_total', {
  description: 'Total number of requests'
});

const requestDuration = meter.createHistogram('request_duration_seconds', {
  description: 'Request duration in seconds'
});
```

## Ключевые метрики для отслеживания

### 1. Метрики приложения

- **Время отклика запросов** - время, необходимое для обработки запроса
- **Частота запросов** - количество запросов в секунду
- **Процент ошибок** - соотношение неудачных запросов к общему числу
- **Время выполнения операций** - время выполнения конкретных функций

### 2. Метрики системы

- **Использование CPU** - загрузка процессора
- **Использование памяти** - потребление оперативной памяти
- **Использование диска** - потребление дискового пространства
- **Использование сети** - сетевой трафик

## Пример реализации метрик в Express-приложении

```typescript
import express from 'express';
import client from 'prom-client';

// Регистрация стандартных метрик Node.js
client.collectDefaultMetrics();

const app = express();

// Кастомные метрики
const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const httpRequestTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

// Middleware для метрик
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    const labels = {
      method: req.method,
      route: req.route?.path || req.originalUrl,
      status_code: res.statusCode.toString()
    };
    
    httpRequestDuration.labels(labels).observe(duration);
    httpRequestTotal.labels(labels).inc();
  });
  
  next();
});

// Эндпоинт для получения метрик
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

// Пример эндпоинта
app.get('/api/users', (req, res) => {
  // Симуляция обработки запроса
  setTimeout(() => {
    res.json({ users: [] });
  }, 200);
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

## Визуализация метрик

Для визуализации метрик часто используются:

- [[Grafana]] - для построения дашбордов
- [[Prometheus]] - для сбора и хранения метрик
- [[InfluxDB]] - для хранения временных рядов

## Заключение

Метрики являются важной частью системы мониторинга, позволяя разработчикам понимать производительность и состояние приложения. При разработке TypeScript-приложений важно правильно выбирать и настраивать метрики для эффективного мониторинга.

См. также:
- [[Логирование]]
- [[Алертинг]]
- [[Трассировка]]
- [[Профилирование]]