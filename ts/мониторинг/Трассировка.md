---
aliases: ["Трассировка TypeScript", "Система трассировки", "Distributed Tracing"]
tags: [typescript, monitoring, tracing, distributed-systems, performance]
---

# Трассировка в TypeScript-приложениях

## Обзор

Трассировка (tracing) - это метод мониторинга и диагностики распределенных систем, который позволяет отслеживать путь запроса через различные сервисы и компоненты приложения. Трассировка особенно важна в микросервисной архитектуре, где один запрос может проходить через множество сервисов.

## Основные концепции трассировки

### Спаны (Spans)

Спан - это базовая единица трассировки, представляющая логическую единицу работы в системе:

```typescript
interface Span {
  id: string;
  traceId: string;
  parentId?: string;
  name: string;
  startTime: number; // Unix timestamp в миллисекундах
  endTime?: number;
  attributes: Record<string, string | number | boolean>;
  events: SpanEvent[];
  status?: SpanStatus;
}

interface SpanEvent {
  name: string;
  timestamp: number;
  attributes?: Record<string, string | number | boolean>;
}

interface SpanStatus {
  code: number; // 0 = OK, 1 = CANCELLED, 2 = ERROR
  message?: string;
}
```

### Трассы (Traces)

Трасса - это коллекция спанов, связанных с одним запросом или транзакцией:

```typescript
interface Trace {
  traceId: string;
  spans: Span[];
}

class TraceContext {
  private traceId: string;
  private activeSpan?: Span;
  
  constructor() {
    this.traceId = this.generateId();
  }
  
  private generateId(): string {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }
  
  startSpan(name: string, parentSpan?: Span): Span {
    const span: Span = {
      id: this.generateId(),
      traceId: this.traceId,
      parentId: parentSpan?.id,
      name,
      startTime: Date.now(),
      attributes: {},
      events: []
    };
    
    this.activeSpan = span;
    return span;
  }
  
  endSpan(span: Span, status?: SpanStatus) {
    span.endTime = Date.now();
    span.status = status;
    
    if (this.activeSpan?.id === span.id) {
      this.activeSpan = undefined;
    }
  }
  
  addEventToSpan(span: Span, name: string, attributes?: Record<string, any>) {
    span.events.push({
      name,
      timestamp: Date.now(),
      attributes
    });
  }
  
  getTraceId(): string {
    return this.traceId;
  }
}
```

## OpenTelemetry в TypeScript

OpenTelemetry - это стандарт для трассировки, логирования и метрик:

### Установка зависимостей

```bash
npm install @opentelemetry/api @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node
npm install @opentelemetry/exporter-trace-otlp-http
```

### Настройка трассировки

```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const traceExporter = new OTLPTraceExporter({
  url: process.env.OTLP_ENDPOINT || 'http://localhost:4318/v1/traces'
});

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'my-service'
  }),
  traceExporter,
  instrumentations: [getNodeAutoInstrumentations()]
});

// Регистрация SDK
sdk.start();

// Обработка завершения процесса
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch(error => console.error('Error terminating tracing', error))
    .finally(() => process.exit(0));
});
```

### Использование трассировки в приложении

```typescript
import { trace, context, SpanStatusCode } from '@opentelemetry/api';

const tracer = trace.getTracer('my-service-tracer');

// Пример трассировки HTTP-запроса
async function handleRequest(req: Request, res: Response) {
  const span = tracer.startSpan('handle-request', {
    attributes: {
      'http.method': req.method,
      'http.route': req.route?.path || req.path,
      'http.url': req.url
    }
  });

  try {
    // Добавляем контекст спана к текущему контексту
    await context.with(trace.setSpan(context.active(), span), async () => {
      // Выполняем бизнес-логику
      const result = await processBusinessLogic(req);
      
      // Добавляем атрибуты к спану
      span.setAttributes({
        'result.success': true,
        'business.operation': 'process-request'
      });
      
      res.json(result);
    });
  } catch (error) {
    // Отмечаем спан как ошибочный
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error.message
    });
    
    span.recordException(error);
    res.status(500).json({ error: error.message });
  } finally {
    // Завершаем спан
    span.end();
  }
}

// Пример трассировки внешнего вызова
async function callExternalService(url: string, data: any) {
  const span = tracer.startSpan('external-api-call', {
    attributes: {
      'http.url': url,
      'http.method': 'POST'
    }
  });

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // Передаем traceparent для продолжения трассировки
        'traceparent': span.spanContext().traceFlags === 1 ? 
          `00-${span.spanContext().traceId}-${span.spanContext().spanId}-01` : undefined
      },
      body: JSON.stringify(data)
    });

    span.setAttributes({
      'http.status_code': response.status
    });

    if (!response.ok) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: `HTTP ${response.status}`
      });
    }

    return await response.json();
  } catch (error) {
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error.message
    });
    throw error;
  } finally {
    span.end();
  }
}
```

## Пример трассировки в Express-приложении

```typescript
import express from 'express';
import { trace, context } from '@opentelemetry/api';

const app = express();
const tracer = trace.getTracer('express-tracer');

// Middleware для автоматического создания спанов для запросов
app.use((req, res, next) => {
  const span = tracer.startSpan(`${req.method} ${req.path}`, {
    attributes: {
      'http.method': req.method,
      'http.url': req.url,
      'http.client_ip': req.ip
    }
  });

  // Устанавливаем спан в контекст
  context.with(trace.setSpan(context.active(), span), () => {
    // Завершаем спан при завершении ответа
    res.on('finish', () => {
      span.setAttributes({
        'http.status_code': res.statusCode
      });
      
      if (res.statusCode >= 500) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: `HTTP ${res.statusCode}`
        });
      }
      
      span.end();
    });

    next();
  });
});

// Пример эндпоинта с вложенной трассировкой
app.get('/api/users/:id', async (req, res) => {
  const currentSpan = trace.getActiveSpan();
  
  // Добавляем атрибуты к текущему спану
  currentSpan?.setAttributes({
    'user.id': req.params.id
  });

  try {
    // Подспан для получения пользователя из БД
    const dbSpan = tracer.startSpan('get-user-from-db', {
      attributes: {
        'db.operation': 'SELECT',
        'db.sql.table': 'users',
        'db.statement': 'SELECT * FROM users WHERE id = ?'
      }
    });

    let user;
    try {
      user = await getUserFromDatabase(req.params.id);
      dbSpan.setStatus({ code: SpanStatusCode.OK });
    } catch (error) {
      dbSpan.setStatus({
        code: SpanStatusCode.ERROR,
        message: error.message
      });
      throw error;
    } finally {
      dbSpan.end();
    }

    // Подспан для форматирования ответа
    const formatSpan = tracer.startSpan('format-user-response');
    const response = formatUserResponse(user);
    formatSpan.end();

    res.json(response);
  } catch (error) {
    currentSpan?.recordException(error);
    currentSpan?.setStatus({
      code: SpanStatusCode.ERROR,
      message: error.message
    });
    res.status(500).json({ error: error.message });
  }
});
```

## Трассировка в асинхронных операциях

```typescript
import { trace, context } from '@opentelemetry/api';

class AsyncOperationTracer {
  static async traceOperation<T>(
    operationName: string,
    operation: () => Promise<T>,
    attributes: Record<string, string | number | boolean> = {}
  ): Promise<T> {
    const span = trace.getTracer('async-tracer').startSpan(operationName, { attributes });
    
    const ctx = trace.setSpan(context.active(), span);
    
    try {
      const result = await context.with(ctx, operation);
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error.message
      });
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  }
}

// Использование
async function complexAsyncOperation() {
  return await AsyncOperationTracer.traceOperation(
    'complex-async-operation',
    async () => {
      // Сложная асинхронная операция
      await new Promise(resolve => setTimeout(resolve, 100));
      return 'result';
    },
    { 'operation.type': 'complex' }
  );
}
```

## Трассировка с использованием декораторов

```typescript
import { trace } from '@opentelemetry/api';

function Traced(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const tracer = trace.getTracer('decorator-tracer');
    const span = tracer.startSpan(`${target.constructor.name}.${propertyKey}`, {
      attributes: {
        'method.args.count': args.length
      }
    });

    try {
      const result = originalMethod.apply(this, args);
      
      // Если метод возвращает Promise, обрабатываем асинхронно
      if (result instanceof Promise) {
        return result
          .then(resolvedResult => {
            span.setStatus({ code: SpanStatusCode.OK });
            return resolvedResult;
          })
          .catch(error => {
            span.setStatus({
              code: SpanStatusCode.ERROR,
              message: error.message
            });
            span.recordException(error);
            throw error;
          })
          .finally(() => {
            span.end();
          });
      } else {
        span.setStatus({ code: SpanStatusCode.OK });
        span.end();
        return result;
      }
    } catch (error) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error.message
      });
      span.recordException(error);
      span.end();
      throw error;
    }
  };

  return descriptor;
}

// Использование декоратора
class UserService {
  @Traced
  async getUserById(id: string) {
    // Логика получения пользователя
    return { id, name: 'John Doe' };
  }
}
```

## Популярные системы трассировки

### Jaeger

Jaeger - это распределенная система трассировки, изначально разработанная Uber:

```typescript
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';

const jaegerExporter = new JaegerExporter({
  endpoint: 'http://localhost:14268/api/traces'
});

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'my-service'
  }),
  traceExporter: jaegerExporter,
  instrumentations: [getNodeAutoInstrumentations()]
});
```

### Zipkin

Zipkin - еще одна популярная система трассировки:

```typescript
import { ZipkinExporter } from '@opentelemetry/exporter-zipkin';

const zipkinExporter = new ZipkinExporter({
  url: 'http://localhost:9411/api/v2/spans'
});
```

## Лучшие практики трассировки

### 1. Используйте семантические атрибуты

```typescript
// Плохо
span.setAttributes({
  'method': req.method,
  'path': req.path,
  'status': res.statusCode
});

// Хорошо - используем семантические атрибуты OpenTelemetry
span.setAttributes({
  'http.method': req.method,
  'http.route': req.route?.path,
  'http.status_code': res.statusCode
});
```

### 2. Избегайте чувствительных данных в атрибутах

```typescript
// Плохо
span.setAttributes({
  'user.password': user.password,
  'credit.card': creditCardNumber
});

// Хорошо
span.setAttributes({
  'user.id': user.id,
  'request.has_sensitive_data': true
});
```

### 3. Устанавливайте подходящие имена спанов

```typescript
// Плохо - слишком общие имена
const span = tracer.startSpan('operation');

// Хорошо - описательные имена
const span = tracer.startSpan('get-user-from-database');
const httpSpan = tracer.startSpan(`${req.method} ${req.path}`);
```

## Заключение

Трассировка является важным инструментом для понимания поведения распределенных систем. При разработке TypeScript-приложений важно правильно настраивать трассировку с использованием стандартов, таких как OpenTelemetry, и следовать лучшим практикам для получения максимальной пользы от трассировки.

См. также:
- [[Логирование]]
- [[Метрики]]
- [[Алертинг]]
- [[Профилирование]]