---
aliases: ["Профилирование TypeScript", "Система профилирования", "Анализ производительности"]
tags: [typescript, monitoring, profiling, performance, optimization]
---

# Профилирование TypeScript-приложений

## Обзор

Профилирование - это процесс анализа производительности приложения с целью выявления узких мест, избыточного потребления ресурсов и возможностей для оптимизации. В контексте TypeScript-приложений профилирование помогает разработчикам понимать, где приложение тратит больше всего времени и ресурсов.

## Типы профилирования

### 1. Профилирование CPU

Анализ времени выполнения различных функций и операций:

```typescript
interface CpuProfile {
  functionName: string;
  totalTime: number; // в миллисекундах
  selfTime: number;  // время, проведенное в функции (без вложенных вызовов)
  callCount: number;
  children: CpuProfile[];
}

class CpuProfiler {
  private profiles: Map<string, { totalTime: number; selfTime: number; callCount: number }> = new Map();
  private startTime: Map<string, number> = new Map();
  
  startFunction(fnName: string) {
    this.startTime.set(fnName, process.hrtime.bigint());
  }
  
  endFunction(fnName: string) {
    const start = this.startTime.get(fnName);
    if (start) {
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1000000; // в миллисекундах
      
      const existing = this.profiles.get(fnName) || { totalTime: 0, selfTime: 0, callCount: 0 };
      existing.totalTime += duration;
      existing.callCount++;
      
      this.profiles.set(fnName, existing);
      this.startTime.delete(fnName);
    }
  }
  
  getProfiles(): CpuProfile[] {
    return Array.from(this.profiles.entries()).map(([fnName, data]) => ({
      functionName: fnName,
      totalTime: data.totalTime,
      selfTime: data.selfTime, // В реальном профилировании это вычисляется более точно
      callCount: data.callCount,
      children: []
    }));
  }
  
  printReport() {
    const profiles = this.getProfiles()
      .sort((a, b) => b.totalTime - a.totalTime)
      .slice(0, 10); // Топ-10 функций по времени выполнения
    
    console.log('\n=== CPU Profiling Report ===');
    console.log('Function Name\t\tTotal Time (ms)\tCall Count\tAvg Time (ms)');
    console.log('-----------------------------------------------------------');
    
    profiles.forEach(profile => {
      const avgTime = profile.totalTime / profile.callCount;
      console.log(`${profile.functionName.padEnd(20)}\t${profile.totalTime.toFixed(2)}\t\t${profile.callCount}\t\t${avgTime.toFixed(3)}`);
    });
  }
}
```

### 2. Профилирование памяти

Анализ потребления памяти и утечек:

```typescript
interface MemoryProfile {
  heapUsed: number;      // использованная куча
  heapTotal: number;     // всего выделено под кучу
  external: number;      // внешняя память (например, C++ объекты)
  rss: number;           // Resident Set Size
  timestamp: number;
}

class MemoryProfiler {
  private profiles: MemoryProfile[] = [];
  private intervalId?: NodeJS.Timeout;
  
  startMonitoring(intervalMs: number = 1000) {
    this.intervalId = setInterval(() => {
      const usage = process.memoryUsage();
      this.profiles.push({
        heapUsed: usage.heapUsed,
        heapTotal: usage.heapTotal,
        external: usage.external,
        rss: usage.rss,
        timestamp: Date.now()
      });
    }, intervalMs);
  }
  
  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }
  
  getProfiles(): MemoryProfile[] {
    return [...this.profiles];
  }
  
  getMemoryGrowthRate(): number {
    if (this.profiles.length < 2) return 0;
    
    const first = this.profiles[0].heapUsed;
    const last = this.profiles[this.profiles.length - 1].heapUsed;
    const timeDiff = (this.profiles[this.profiles.length - 1].timestamp - this.profiles[0].timestamp) / 1000; // в секундах
    
    return timeDiff > 0 ? (last - first) / timeDiff : 0; // байт/сек
  }
  
  printReport() {
    if (this.profiles.length === 0) {
      console.log('No memory profiles collected');
      return;
    }
    
    const latest = this.profiles[this.profiles.length - 1];
    const growthRate = this.getMemoryGrowthRate();
    
    console.log('\n=== Memory Profiling Report ===');
    console.log(`Current Heap Used: ${(latest.heapUsed / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Current Heap Total: ${(latest.heapTotal / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Current RSS: ${(latest.rss / 1024 / 1024).toFixed(2)} MB`);
    console.log(`Memory Growth Rate: ${(growthRate / 1024 / 1024).toFixed(2)} MB/s`);
    
    if (growthRate > 1024 * 1024) { // больше 1MB/s
      console.log('⚠️  WARNING: High memory growth detected - possible memory leak!');
    }
  }
}
```

## Встроенные инструменты профилирования

### Использование V8 профилировщика

```typescript
import { Session } from 'inspector';
import fs from 'fs';

class V8Profiler {
  private session: Session;
  
  constructor() {
    this.session = new Session();
    this.session.connect();
  }
  
  async startCpuProfiling(name: string = 'profile') {
    this.session.post('Profiler.enable');
    this.session.post('Profiler.start', {
      params: { 
        includeSamples: true 
      }
    });
  }
  
  async stopCpuProfiling(name: string = 'profile') {
    return new Promise<any>((resolve, reject) => {
      this.session.post('Profiler.stop', (error, params) => {
        if (error) {
          reject(error);
        } else {
          resolve(params.profile);
        }
      });
    });
  }
  
  async saveProfile(profile: any, filename: string) {
    fs.writeFileSync(filename, JSON.stringify(profile));
    console.log(`Profile saved to ${filename}`);
  }
  
  async profileFunction<T>(fn: () => T | Promise<T>, name: string = 'profile'): Promise<T> {
    await this.startCpuProfiling(name);
    
    try {
      const result = await Promise.resolve(fn());
      const profile = await this.stopCpuProfiling(name);
      await this.saveProfile(profile, `${name}.cpuprofile`);
      return result;
    } catch (error) {
      await this.stopCpuProfiling(name);
      throw error;
    }
  }
}
```

## Профилирование с использованием декораторов

```typescript
function Profile(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    const start = process.hrtime.bigint();
    const startMemory = process.memoryUsage().heapUsed;
    
    const result = originalMethod.apply(this, args);
    
    // Если метод возвращает Promise, измеряем асинхронно
    if (result instanceof Promise) {
      return result.then((resolvedResult: any) => {
        const end = process.hrtime.bigint();
        const endMemory = process.memoryUsage().heapUsed;
        const duration = Number(end - start) / 1000000; // в миллисекундах
        
        console.log(`[PROFILING] ${target.constructor.name}.${propertyKey}:`);
        console.log(`  Duration: ${duration.toFixed(2)}ms`);
        console.log(`  Memory delta: ${((endMemory - startMemory) / 1024 / 1024).toFixed(2)}MB`);
        
        return resolvedResult;
      });
    } else {
      const end = process.hrtime.bigint();
      const endMemory = process.memoryUsage().heapUsed;
      const duration = Number(end - start) / 1000000; // в миллисекундах
      
      console.log(`[PROFILING] ${target.constructor.name}.${propertyKey}:`);
      console.log(`  Duration: ${duration.toFixed(2)}ms`);
      console.log(`  Memory delta: ${((endMemory - startMemory) / 1024 / 1024).toFixed(2)}MB`);
      
      return result;
    }
  };
  
  return descriptor;
}

// Использование декоратора
class DataService {
  @Profile
  async fetchData(id: string) {
    // Симуляция длительной операции
    await new Promise(resolve => setTimeout(resolve, 100));
    return { id, data: 'some data' };
  }
}
```

## Профилирование производительности API

```typescript
interface ApiPerformanceMetrics {
  endpoint: string;
  method: string;
  avgResponseTime: number;
  p95ResponseTime: number;
  p99ResponseTime: number;
  requestsPerSecond: number;
  errorRate: number;
  timestamp: number;
}

class ApiProfiler {
  private metrics: Map<string, { 
    responseTimes: number[]; 
    totalRequests: number; 
    errorCount: number; 
    startTime: number 
  }> = new Map();
  
  private samplingWindow: number = 60000; // 1 минута
  
  recordRequest(
    endpoint: string, 
    method: string, 
    responseTime: number, 
    isError: boolean = false
  ) {
    const key = `${method}:${endpoint}`;
    const now = Date.now();
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, {
        responseTimes: [],
        totalRequests: 0,
        errorCount: 0,
        startTime: now
      });
    }
    
    const metric = this.metrics.get(key)!;
    metric.responseTimes.push(responseTime);
    metric.totalRequests++;
    
    if (isError) {
      metric.errorCount++;
    }
    
    // Ограничиваем размер массива для эффективности
    if (metric.responseTimes.length > 10000) {
      metric.responseTimes.shift();
    }
  }
  
  getMetrics(): ApiPerformanceMetrics[] {
    const now = Date.now();
    const results: ApiPerformanceMetrics[] = [];
    
    for (const [key, metric] of this.metrics.entries()) {
      const [method, endpoint] = key.split(':');
      
      // Вычисляем перцентили
      const sortedTimes = [...metric.responseTimes].sort((a, b) => a - b);
      const p95Index = Math.floor(sortedTimes.length * 0.95);
      const p99Index = Math.floor(sortedTimes.length * 0.99);
      
      const avgResponseTime = sortedTimes.length > 0 
        ? sortedTimes.reduce((a, b) => a + b, 0) / sortedTimes.length 
        : 0;
      
      const timeWindow = (now - metric.startTime) / 1000; // в секундах
      const requestsPerSecond = timeWindow > 0 ? metric.totalRequests / timeWindow : 0;
      const errorRate = metric.totalRequests > 0 ? metric.errorCount / metric.totalRequests : 0;
      
      results.push({
        endpoint,
        method,
        avgResponseTime,
        p95ResponseTime: sortedTimes[p95Index] || 0,
        p99ResponseTime: sortedTimes[p99Index] || 0,
        requestsPerSecond,
        errorRate,
        timestamp: now
      });
    }
    
    return results;
  }
  
  printReport() {
    const metrics = this.getMetrics();
    
    console.log('\n=== API Performance Report ===');
    console.log('Endpoint\t\tMethod\tAvg(ms)\tP95(ms)\tP99(ms)\tRPS\tError Rate');
    console.log('--------------------------------------------------------------------');
    
    metrics.forEach(metric => {
      console.log(
        `${metric.endpoint.substring(0, 15).padEnd(15)}\t${metric.method}\t` +
        `${metric.avgResponseTime.toFixed(2)}\t\t${metric.p95ResponseTime.toFixed(2)}\t\t` +
        `${metric.p99ResponseTime.toFixed(2)}\t\t${metric.requestsPerSecond.toFixed(2)}\t` +
        `${(metric.errorRate * 100).toFixed(2)}%`
      );
    });
  }
}
```

## Пример использования профилирования в Express-приложении

```typescript
import express from 'express';

const app = express();
const cpuProfiler = new CpuProfiler();
const memoryProfiler = new MemoryProfiler();
const apiProfiler = new ApiProfiler();

// Middleware для профилирования
app.use((req, res, next) => {
  const start = process.hrtime.bigint();
  const startMemory = process.memoryUsage().heapUsed;
  
  res.on('finish', () => {
    const end = process.hrtime.bigint();
    const endMemory = process.memoryUsage().heapUsed;
    const duration = Number(end - start) / 1000000; // в миллисекундах
    
    // Записываем метрики API
    apiProfiler.recordRequest(
      req.path, 
      req.method, 
      duration, 
      res.statusCode >= 400
    );
    
    console.log(`[API PROFILING] ${req.method} ${req.path}: ${duration.toFixed(2)}ms, ` +
                `Memory: ${((endMemory - startMemory) / 1024 / 1024).toFixed(2)}MB`);
  });
  
  next();
});

// Эндпоинт для получения профилей
app.get('/debug/profile', (req, res) => {
  const report = {
    cpu: cpuProfiler.getProfiles(),
    memory: memoryProfiler.getProfiles(),
    api: apiProfiler.getMetrics()
  };
  
  res.json(report);
});

// Запуск мониторинга памяти
memoryProfiler.startMonitoring(5000); // каждые 5 секунд

// Печать отчетов каждые 30 секунд
setInterval(() => {
  console.log('\n' + '='.repeat(50));
  apiProfiler.printReport();
  memoryProfiler.printReport();
}, 30000);
```

## Профилирование с использованием сторонних библиотек

### clinic.js

Clinic.js - это инструмент для профилирования Node.js приложений:

```bash
npm install -g clinic
clinic doctor -- node your-app.js
clinic bubbleprof -- node your-app.js
clinic flame -- node your-app.js
```

### 0x (zerox)

Инструмент для flamegraph профилирования:

```bash
npm install -g 0x
0x -- node your-app.js
```

## Лучшие практики профилирования

### 1. Профилирование в среде, близкой к продакшену

```typescript
// Плохо - профилирование только в development
if (process.env.NODE_ENV === 'development') {
  // профилирование
}

// Хорошо - возможность включения профилирования в production
const shouldProfile = process.env.PROFILE === 'true' || 
                     process.env.NODE_ENV === 'development';
```

### 2. Ограниченное профилирование в продакшене

```typescript
class SamplingProfiler {
  private sampleRate: number;
  
  constructor(sampleRate: number = 0.1) { // 10% запросов
    this.sampleRate = sampleRate;
  }
  
  shouldProfile(): boolean {
    return Math.random() < this.sampleRate;
  }
  
  async profileIfSampled<T>(fn: () => Promise<T>, name: string): Promise<T> {
    if (this.shouldProfile()) {
      // Выполняем профилирование
      return await this.profileFunction(fn, name);
    } else {
      // Просто выполняем функцию без профилирования
      return await fn();
    }
  }
  
  private async profileFunction<T>(fn: () => Promise<T>, name: string): Promise<T> {
    const start = process.hrtime.bigint();
    try {
      const result = await fn();
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1000000;
      
      console.log(`[PROFILE] ${name}: ${duration.toFixed(2)}ms`);
      return result;
    } catch (error) {
      console.error(`[PROFILE ERROR] ${name}:`, error);
      throw error;
    }
  }
}
```

### 3. Использование специализированных инструментов для разных задач

- Для профилирования CPU: `clinic.js doctor`, `0x`, встроенный V8 профайлер
- Для профилирования памяти: `clinic.js doctor`, `heapdump`
- Для профилирования блокировок: `clinic.js bubbleprof`
- Для анализа производительности: `clinic.js flame`

## Заключение

Профилирование является важным инструментом для оптимизации производительности TypeScript-приложений. При разработке приложений важно использовать комбинацию встроенных инструментов, библиотек и подходов для получения полной картины производительности и выявления узких мест.

См. также:
- [[Логирование]]
- [[Метрики]]
- [[Алертинг]]
- [[Трассировка]]