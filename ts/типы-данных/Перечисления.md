---
aliases: ["Enums", "Перечисления TypeScript", "Enum Types"]
tags: ["#typescript", "#enums", "#constants", "#data-types"]
---

# Перечисления (Enums) в TypeScript

## Введение

Перечисления (enums) в TypeScript - это способ определения набора именованных констант, которые помогают сделать код более понятным и поддерживаемым. Они позволяют создавать набор связанных значений с понятными именами, что особенно полезно для состояний, типов, уровней доступа и других сценариев, где ограниченный набор значений имеет смысл.

## Объявление перечислений

### Числовые перечисления

Самый распространенный тип перечисления - числовое перечисление, где значения автоматически присваиваются начиная с 0:

```typescript
enum Direction {
  Up,
  Down,
  Left,
  Right
}

// Использование перечисления
let moveDirection: Direction = Direction.Up;

// Значения по умолчанию
console.log(Direction.Up);    // 0
console.log(Direction.Down);  // 1
console.log(Direction.Left);  // 2
console.log(Direction.Right); // 3
```

Можно также указать начальное значение или значения для отдельных элементов:

```typescript
enum StatusCode {
  Success = 200,
  NotFound = 404,
  ServerError = 500
}

console.log(StatusCode.Success);    // 200
console.log(StatusCode.NotFound);   // 404
console.log(StatusCode.ServerError); // 500

// Продолжение нумерации после указанного значения
enum Count {
  Zero = 0,
  One,    // 1
  Two,    // 2
  Three   // 3
}
```

### Строковые перечисления

Строковые перечисления позволяют задавать строковые значения для каждого элемента:

```typescript
enum UserRole {
  Admin = "ADMIN",
  Moderator = "MODERATOR",
  User = "USER",
  Guest = "GUEST"
}

let currentUserRole: UserRole = UserRole.Admin;

// Использование в условиях
if (currentUserRole === UserRole.Admin) {
  console.log("Пользователь имеет права администратора");
}
```

### Гетерогенные перечисления

TypeScript позволяет создавать перечисления с разными типами значений (хотя это не рекомендуется):

```typescript
enum MixedEnum {
  No = 0,
  Yes = "YES",
  Maybe = 1
}
```

## Обратное сопоставление

TypeScript автоматически создает обратное сопоставление для числовых перечислений:

```typescript
enum Status {
  Active = 1,
  Inactive = 2
}

// Прямое сопоставление
console.log(Status.Active); // 1

// Обратное сопоставление
console.log(Status[1]); // "Active"
console.log(Status[2]); // "Inactive"

// Это работает только для числовых перечислений
// Для строковых перечислений обратное сопоставление не создается
```

## Константные перечисления

Константные перечисления компилируются в JavaScript как простые значения, а не в объекты, что может улучшить производительность:

```typescript
const enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}

// При компиляции в JavaScript это станет:
// let favoriteColor = "RED";

let favoriteColor: Color = Color.Red;
```

## Вычисляемые и постоянные элементы

Элементы перечисления могут быть постоянными (константами) или вычисляемыми:

```typescript
enum FileAccess {
  // Постоянные элементы
  None = 0,
  Read = 1 << 2,  // 4
  Write = 1 << 3, // 8
  
  // Вычисляемые элементы (после постоянных)
  ReadWrite = Read | Write, // 12
  G = "123".length as any // Вынужденное вычисляемое значение
}
```

## Практические примеры использования

### Состояния приложения

```typescript
enum LoadingState {
  Idle = "idle",
  Loading = "loading",
  Success = "success",
  Error = "error"
}

interface ApiResponse<T> {
  data: T | null;
  state: LoadingState;
  error?: string;
}

function handleResponse<T>(response: ApiResponse<T>) {
  switch (response.state) {
    case LoadingState.Loading:
      console.log("Загрузка данных...");
      break;
    case LoadingState.Success:
      console.log("Данные успешно загружены:", response.data);
      break;
    case LoadingState.Error:
      console.log("Ошибка загрузки:", response.error);
      break;
    default:
      console.log("Состояние:", response.state);
  }
}
```

### Уровни логирования

```typescript
enum LogLevel {
  Debug = 0,
  Info = 1,
  Warning = 2,
  Error = 3
}

function log(message: string, level: LogLevel) {
  const timestamp = new Date().toISOString();
  
  switch (level) {
    case LogLevel.Debug:
      console.debug(`[${timestamp}] DEBUG: ${message}`);
      break;
    case LogLevel.Info:
      console.info(`[${timestamp}] INFO: ${message}`);
      break;
    case LogLevel.Warning:
      console.warn(`[${timestamp}] WARN: ${message}`);
      break;
    case LogLevel.Error:
      console.error(`[${timestamp}] ERROR: ${message}`);
      break;
  }
}

// Использование
log("Приложение запущено", LogLevel.Info);
log("Произошла ошибка", LogLevel.Error);
```

### Типы уведомлений

```typescript
enum NotificationType {
  Email = "EMAIL",
  Sms = "SMS",
  Push = "PUSH",
  InApp = "IN_APP"
}

interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  recipient: string;
  sentAt: Date;
}

function sendNotification(notification: Notification) {
  switch (notification.type) {
    case NotificationType.Email:
      console.log(`Отправка email уведомления на ${notification.recipient}`);
      break;
    case NotificationType.Sms:
      console.log(`Отправка SMS уведомления на ${notification.recipient}`);
      break;
    case NotificationType.Push:
      console.log(`Отправка push уведомления пользователю ${notification.recipient}`);
      break;
    case NotificationType.InApp:
      console.log(`Отправка in-app уведомления`);
      break;
  }
}
```

## Расширение перечислений

В TypeScript можно объявлять перечисления несколько раз, и они будут объединены (declaration merging):

```typescript
enum FileAccess {
  Read = 1,
  Write = 2
}

// Повторное объявление (в другом файле или позже в том же)
enum FileAccess {
  Execute = 4
}

// Результат: { Read: 1, Write: 2, Execute: 4 }
console.log(FileAccess.Execute); // 4
```

## Перечисления vs Объекты

Сравнение перечислений с другими способами определения констант:

```typescript
// Перечисление
enum DirectionEnum {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT"
}

// Объект с readonly
const DirectionObject = {
  Up: "UP",
  Down: "DOWN",
  Left: "LEFT",
  Right: "RIGHT"
} as const;

// Тип для объекта
type DirectionType = typeof DirectionObject[keyof typeof DirectionObject];

// Преимущества перечислений:
// - Лучшая поддержка в IDE
// - Обратное сопоставление (для числовых)
// - Автоматическая типизация
// - Более компактный синтаксис
```

## Лучшие практики

### Использование строковых перечислений

Рекомендуется использовать строковые перечисления вместо числовых, когда значения не имеют числового смысла:

```typescript
// Рекомендуется
enum UserRole {
  Admin = "ADMIN",
  Moderator = "MODERATOR",
  User = "USER"
}

// Не рекомендуется (если числовые значения не важны)
enum UserRoleNumeric {
  Admin = 0,
  Moderator = 1,
  User = 2
}
```

### Определение перечислений в отдельных файлах

Для переиспользования в разных частях приложения:

```typescript
// user-roles.enum.ts
export enum UserRole {
  Admin = "ADMIN",
  Moderator = "MODERATOR",
  User = "USER",
  Guest = "GUEST"
}

// В другом файле
import { UserRole } from './user-roles.enum';

function checkPermissions(role: UserRole) {
  // ...
}
```

### Использование union типов вместо перечислений

В некоторых случаях можно использовать union типы строк:

```typescript
// Альтернатива перечислению
type UserRole = "ADMIN" | "MODERATOR" | "USER" | "GUEST";

// Преимущества union типов:
// - Меньше кода
// - Легче тестировать
// - Лучше работают с типами в функциях
```

## Совместимость с JavaScript

При компиляции в JavaScript перечисления преобразуются в объекты:

```typescript
enum Direction {
  Up,
  Down,
  Left,
  Right
}
```

Компилируется в:

```javascript
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

## Заключение

Перечисления в TypeScript предоставляют мощный способ создания наборов именованных констант, что делает код более понятным и безопасным. Они особенно полезны для представления ограниченных наборов значений, таких как состояния, типы или уровни. Правильное использование перечислений помогает избежать ошибок, связанных с "магическими строками" и числами, и улучшает поддерживаемость кода. В следующих разделах мы рассмотрим другие продвинутые типы данных и концепции TypeScript.

## См. также

- [[Примитивные-типы]]
- [[Объекты]]
- [[Массивы]]
- [[Кортежи]]
- [[Типы-объединения]]
- [[Типы-литералы]]