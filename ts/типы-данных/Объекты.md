---
aliases: ["Объектные типы", "Типы объектов"]
tags: ["#typescript", "#data-types", "#objects", "#interfaces"]
---

# Объекты в TypeScript

## Введение

Объекты являются одним из фундаментальных типов данных в TypeScript, позволяя группировать связанные данные и функции в единую структуру. TypeScript предоставляет мощные возможности для определения структуры объектов, что делает код более надежным и понятным.

## Определение объектных типов

### Интерфейсы

Интерфейс - это способ описания формы объекта. Он определяет, какие свойства должен иметь объект и какого типа они должны быть.

**Пример:**
```typescript
interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

// Использование интерфейса
const user: User = {
  id: 1,
  name: "Александр",
  email: "alex@example.com",
  isActive: true
};
```

**Практические рекомендации:**
- Используйте интерфейсы для определения форм объектов, особенно в API
- Интерфейсы могут быть расширены с помощью ключевого слова `extends`
- Имена интерфейсов обычно начинаются с заглавной буквы

### Типы объектов (Type aliases)

Альтернативой интерфейсам являются псевдонимы типов (type aliases), которые также позволяют создавать именованные типы.

**Пример:**
```typescript
type Product = {
  id: number;
  title: string;
  price: number;
  description?: string; // Необязательное свойство
};

const laptop: Product = {
  id: 1,
  title: "Ноутбук",
  price: 999.99
  // description необязательно
};
```

**Различия между интерфейсами и типами:**
- Интерфейсы могут быть объявлены несколько раз и будут объединены (declaration merging)
- Типы не могут быть повторно объявлены
- Интерфейсы лучше подходят для объектов, типы - для примитивов и union типов

## Необязательные и readonly свойства

### Необязательные свойства

Свойства могут быть помечены как необязательные с помощью символа `?`:

```typescript
interface UserProfile {
  name: string;
  email: string;
  phone?: string; // Необязательное свойство
  address?: {
    street: string;
    city: string;
    zipCode?: string;
  };
}
```

### Readonly свойства

Свойства могут быть помечены как доступные только для чтения с помощью ключевого слова `readonly`:

```typescript
interface Configuration {
  readonly apiKey: string;
  readonly version: string;
  timeout: number; // Может быть изменено
}

const config: Configuration = {
  apiKey: "abc123",
  version: "1.0.0",
  timeout: 5000
};

// config.apiKey = "newKey"; // Ошибка: нельзя изменить readonly свойство
```

## Индексные сигнатуры

Индексные сигнатуры позволяют описывать объекты с динамическими ключами:

```typescript
// Объект с произвольными строковыми ключами
interface StringMap {
  [key: string]: string;
}

const map: StringMap = {
  key1: "value1",
  key2: "value2"
};

// Объект с числовыми ключами
interface NumberMap {
  [key: number]: boolean;
}

const numMap: NumberMap = {
  1: true,
  2: false
};

// Смешанная сигнатура (строки и числа)
interface MixedMap {
  [key: string]: string | number;
  [key: number]: number; // Числовые ключи преобразуются в строки
}
```

## Наследование и расширение интерфейсов

Интерфейсы могут наследовать свойства от других интерфейсов:

```typescript
interface Person {
  name: string;
  age: number;
}

interface Employee extends Person {
  employeeId: number;
  department: string;
}

interface Manager extends Employee {
  teamSize: number;
  responsibilities: string[];
}

const manager: Manager = {
  name: "Иван",
  age: 35,
  employeeId: 101,
  department: "Разработка",
  teamSize: 10,
  responsibilities: ["Управление командой", "Планирование проектов"]
};
```

## Функции в объектах

Объекты могут содержать методы и функции:

```typescript
interface Calculator {
  add(a: number, b: number): number;
  subtract(a: number, b: number): number;
  multiply(a: number, b: number): number;
  divide(a: number, b: number): number | null;
  history: string[];
  addHistory(operation: string): void;
}

const calc: Calculator = {
  add(a, b) {
    const result = a + b;
    this.addHistory(`${a} + ${b} = ${result}`);
    return result;
  },
  subtract(a, b) {
    const result = a - b;
    this.addHistory(`${a} - ${b} = ${result}`);
    return result;
  },
  multiply(a, b) {
    const result = a * b;
    this.addHistory(`${a} * ${b} = ${result}`);
    return result;
  },
  divide(a, b) {
    if (b === 0) {
      this.addHistory(`${a} / ${b} = Error: Division by zero`);
      return null;
    }
    const result = a / b;
    this.addHistory(`${a} / ${b} = ${result}`);
    return result;
  },
  history: [],
  addHistory(operation) {
    this.history.push(operation);
  }
};
```

## Классы и объекты

Классы в TypeScript также создают объекты и могут реализовывать интерфейсы:

```typescript
interface Drawable {
  x: number;
  y: number;
  draw(): void;
}

class Circle implements Drawable {
  constructor(
    public x: number,
    public y: number,
    public radius: number
  ) {}
  
  draw() {
    console.log(`Рисуем круг в точке (${this.x}, ${this.y}) с радиусом ${this.radius}`);
  }
}

const circle = new Circle(10, 20, 5);
circle.draw(); // Рисуем круг в точке (10, 20) с радиусом 5
```

## Практические рекомендации

### Использование интерфейсов для API

```typescript
// Интерфейс для ответа API
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: number;
}

// Использование универсального интерфейса
const response: ApiResponse<User[]> = {
  success: true,
  data: [user],
  timestamp: Date.now()
};
```

### Опциональная цепочка (Optional chaining)

```typescript
interface User {
  name: string;
  address?: {
    street?: string;
    city?: string;
  };
}

const user: User = { name: "Александр" };

// Безопасный доступ к вложенным свойствам
const city = user.address?.city; // undefined, но без ошибки
const street = user.address?.street || "Не указан"; // "Не указан"
```

### Nullish coalescing

```typescript
interface Product {
  title: string;
  price: number;
  discount?: number | null;
}

const product: Product = { title: "Товар", price: 100, discount: null };

// Использование nullish coalescing для обработки null/undefined
const finalPrice = product.price * (1 - (product.discount ?? 0));
```

## Заключение

Объекты в TypeScript предоставляют мощный способ структурирования данных и определения форм. Правильное использование интерфейсов, типов и других возможностей системы типов позволяет создавать более надежный и поддерживаемый код. В следующих разделах мы рассмотрим [[Массивы]] и другие типы данных.

## См. также

- [[Примитивные-типы]]
- [[Массивы]]
- [[Кортежи]]
- [[Перечисления]]
- [[Интерфейсы]]