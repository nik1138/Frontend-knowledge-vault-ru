---
aliases: ["Тип кортеж", "Кортежи TypeScript"]
tags: ["#typescript", "#tuples", "#data-structures"]
---

# Кортежи в TypeScript

## Введение

Кортеж (tuple) - это специальный тип массива в TypeScript, который имеет фиксированную длину и известные типы элементов на каждой позиции. В отличие от обычных массивов, где все элементы имеют одинаковый тип, кортежи позволяют указать разные типы для разных позиций, что делает их идеальными для представления структурированных данных с известной формой.

## Определение кортежей

### Базовый синтаксис

Кортежи определяются с помощью квадратных скобок с перечислением типов элементов в нужном порядке:

```typescript
// Простой кортеж: строка, число, булевое значение
let userTuple: [string, number, boolean] = ["Александр", 30, true];

// Доступ к элементам по индексу
let name: string = userTuple[0]; // "Александр"
let age: number = userTuple[1];   // 30
let isActive: boolean = userTuple[2]; // true

// Длина кортежа строго фиксирована
console.log(userTuple.length); // 3
```

### Именованные кортежи

TypeScript позволяет давать имена элементам кортежа для улучшения читаемости:

```typescript
// Именованный кортеж
let coordinates: [x: number, y: number, z: number] = [10, 20, 30];

// Имена не влияют на типизацию, но улучшают документацию
let x: number = coordinates[0];
let y: number = coordinates[1];
let z: number = coordinates[2];
```

## Использование кортежей

### Возвращаемые значения функций

Кортежи часто используются для возвращаемых значений функций, когда нужно вернуть несколько значений разных типов:

```typescript
// Функция, возвращающая результат и флаг ошибки
function divide(a: number, b: number): [number, boolean] {
  if (b === 0) {
    return [0, true]; // [результат, флаг ошибки]
  }
  return [a / b, false];
}

let [result, hasError] = divide(10, 2);
if (!hasError) {
  console.log(`Результат: ${result}`);
} else {
  console.log("Ошибка деления на ноль");
}
```

### Деструктуризация кортежей

Кортежи поддерживают деструктуризацию, что делает работу с ними удобной:

```typescript
// Кортеж с данными пользователя
let userData: [string, number, boolean, string] = ["Мария", 25, true, "maria@example.com"];

// Деструктуризация с именованием переменных
let [name, age, isActive, email] = userData;

console.log(`Имя: ${name}, Возраст: ${age}, Активен: ${isActive}, Email: ${email}`);

// Частичная деструктуризация
let [firstName, , , userEmail] = userData; // Пропускаем age и isActive
```

### Кортежи с необязательными элементами

Начиная с TypeScript 3.0, можно создавать кортежи с необязательными элементами в конце:

```typescript
// Кортеж с необязательным последним элементом
let optionalTuple: [string, number, boolean?];
optionalTuple = ["test", 42];        // OK
optionalTuple = ["test", 42, true];  // Также OK

// Кортеж с двумя необязательными элементами в конце
let extendedTuple: [string, number, boolean?, string?];
extendedTuple = ["a", 1];                    // OK
extendedTuple = ["a", 1, true];              // OK
extendedTuple = ["a", 1, true, "extra"];     // OK
```

## Ограничения и особенности

### Добавление элементов

Хотя кортежи имеют фиксированную длину, TypeScript позволяет добавлять элементы через метод `push`, но это нарушает типизацию:

```typescript
let tuple: [string, number] = ["hello", 42];
console.log(tuple.length); // 2

tuple.push(true); // OK, но теперь это уже не строго кортеж
console.log(tuple.length); // 3

// Это может привести к проблемам при обращении к элементам
let thirdElement: string | number | boolean = tuple[2]; // Тип union
```

### Операции с кортежами

Кортежи поддерживают все стандартные методы массивов, но возвращаемые типы могут отличаться:

```typescript
let coordinates: [number, number] = [10, 20];

// map возвращает массив того же типа
let doubled: [number, number] = coordinates.map(n => n * 2) as [number, number];

// slice может вернуть массив с неизвестной длиной
let subset = coordinates.slice(0, 1); // number[], не кортеж
```

## Практические применения

### Представление координат

```typescript
// 2D координаты
type Point2D = [number, number];
type Point3D = [number, number, number];

let point2d: Point2D = [10, 20];
let point3d: Point3D = [10, 20, 30];

function calculateDistance(p1: Point2D, p2: Point2D): number {
  return Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
}
```

### Работа с парами значений

```typescript
// Пара ключ-значение
type KeyValuePair<T, U> = [T, U];

let userStatus: KeyValuePair<string, boolean> = ["isAdmin", true];
let configValue: KeyValuePair<string, number> = ["timeout", 5000];

// Функция для обработки пар
function processPairs<T, U>(pairs: [T, U][]): Map<T, U> {
  const result = new Map<T, U>();
  pairs.forEach(([key, value]) => {
    result.set(key, value);
  });
  return result;
}
```

### Возвращаемые значения с ошибками

```typescript
// Тип для результата операции
type Result<T> = [T, null] | [null, Error];

function safeParse(json: string): Result<any> {
  try {
    const parsed = JSON.parse(json);
    return [parsed, null];
  } catch (error) {
    return [null, error as Error];
  }
}

// Использование
const [data, error] = safeParse('{"name": "Александр"}');
if (error) {
  console.error("Ошибка парсинга:", error.message);
} else {
  console.log("Данные:", data);
}
```

### Конфигурационные данные

```typescript
// Кортеж для конфигурации подключения к базе данных
type DatabaseConfig = [host: string, port: number, database: string, options?: Record<string, any>];

let dbConfig: DatabaseConfig = [
  "localhost", 
  5432, 
  "myapp", 
  { ssl: true, poolSize: 10 }
];

function connectToDatabase([host, port, database, options]: DatabaseConfig) {
  console.log(`Подключение к ${database} на ${host}:${port}`);
  if (options) {
    console.log("Дополнительные опции:", options);
  }
}
```

## Сравнение с другими типами

### Кортежи vs Массивы

```typescript
// Массив: неограниченная длина, один тип
let stringArray: string[] = ["a", "b", "c", "d", "e"];

// Кортеж: фиксированная длина, разные типы
let stringTuple: [string, string, string, string, string] = ["a", "b", "c", "d", "e"];

// Массив с union типом
let mixedArray: (string | number)[] = ["a", 1, "b", 2];

// Кортеж с разными типами
let mixedTuple: [string, number, boolean] = ["a", 1, true];
```

### Кортежи vs Объекты

```typescript
// Объект с именованными полями
interface UserObject {
  name: string;
  age: number;
  isActive: boolean;
}

// Кортеж без именованных полей
type UserTuple = [string, number, boolean];

// Объект: более понятные имена, но больше синтаксиса
let userObj: UserObject = { name: "Александр", age: 30, isActive: true };

// Кортеж: компактный, но менее понятный
let userTup: UserTuple = ["Александр", 30, true];

// Выбор зависит от контекста использования
```

## Лучшие практики

### Использование типов для кортежей

```typescript
// Определение типа для переиспользования
type ApiResponse = [data: any, error: Error | null, statusCode: number];

function fetchUser(id: number): ApiResponse {
  try {
    // Симуляция получения данных
    const userData = { id, name: "Александр" };
    return [userData, null, 200];
  } catch (error) {
    return [null, error as Error, 500];
  }
}
```

### Ограничение длины кортежа

```typescript
// Избегайте слишком длинных кортежей - это снижает читаемость
// Плохо: кортеж из 7+ элементов
type BadTuple = [string, number, boolean, string, number, boolean, string];

// Лучше: использовать объект или интерфейс
interface BetterStructure {
  name: string;
  count: number;
  isActive: boolean;
  description: string;
  value: number;
  isValid: boolean;
  category: string;
}
```

## Заключение

Кортежи в TypeScript предоставляют мощный способ представления структурированных данных с фиксированной формой. Они особенно полезны для возвращаемых значений функций, координат, пар значений и других случаев, когда важна как длина, так и типизация каждого элемента. Понимание и правильное использование кортежей позволяет создавать более надежный и понятный код. В следующих разделах мы рассмотрим [[Перечисления]] и другие продвинутые типы данных.

## См. также

- [[Примитивные-типы]]
- [[Объекты]]
- [[Массивы]]
- [[Перечисления]]
- [[Типы-объединения]]