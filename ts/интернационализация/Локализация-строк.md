---
aliases: [Локализация строк, i18n строк, Перевод текста]
tags: [typescript, интернационализация, локализация, строки, i18n]
---

# Локализация строк в TypeScript

## Обзор

Локализация строк - это процесс адаптации текстового контента приложения для различных языков и региональных настроек. В TypeScript, как и в других языках программирования, это ключевой аспект интернационализации (i18n), позволяющий создавать приложения, доступные пользователям по всему миру.

## Основы локализации строк

При разработке приложений с поддержкой нескольких языков, важно отделить текстовый контент от кода. Это позволяет легко переводить интерфейс на разные языки без изменения логики приложения.

### Принципы хорошей локализации

1. **Избегайте жестко закодированных строк** - все текстовые элементы интерфейса должны быть извлечены в файлы локализации
2. **Используйте уникальные ключи** - каждая строка должна иметь уникальный идентификатор
3. **Поддерживайте контекст** - комментарии и метаданные помогают переводчикам понять значение строки
4. **Учитывайте форматирование** - строки могут содержать заполнители для динамических значений

## Практическая реализация

### Базовая структура локализации

```typescript
// types/i18n.ts
export interface Translation {
  [key: string]: string | Translation;
}

export interface LocaleData {
  [locale: string]: Translation;
}

export type SupportedLocale = 'en' | 'ru' | 'es' | 'fr';
```

```typescript
// i18n/locales/en.ts
export const en: Translation = {
  welcome: 'Welcome',
  greeting: 'Hello, {name}!',
  settings: {
    title: 'Settings',
    language: 'Language'
  },
  errors: {
    required: 'This field is required',
    email: 'Please enter a valid email address'
  }
};
```

```typescript
// i18n/locales/ru.ts
export const ru: Translation = {
  welcome: 'Добро пожаловать',
  greeting: 'Привет, {name}!',
  settings: {
    title: 'Настройки',
    language: 'Язык'
  },
  errors: {
    required: 'Это поле обязательно',
    email: 'Пожалуйста, введите действительный адрес электронной почты'
  }
};
```

### Сервис локализации

```typescript
// i18n/i18n-service.ts
import { en } from './locales/en';
import { ru } from './locales/ru';
import { Translation, SupportedLocale } from '../types/i18n';

const locales: Record<SupportedLocale, Translation> = {
  en,
  ru
};

class I18nService {
  private currentLocale: SupportedLocale = 'en';
  private translations: Translation = en;

  setLocale(locale: SupportedLocale) {
    this.currentLocale = locale;
    this.translations = locales[locale];
  }

  getLocale(): SupportedLocale {
    return this.currentLocale;
  }

  t(key: string, params?: Record<string, any>): string {
    let translation = this.getNestedTranslation(key);
    
    if (!translation) {
      console.warn(`Translation key '${key}' not found`);
      return key;
    }

    // Заменяем параметры в строке
    if (params) {
      Object.entries(params).forEach(([paramKey, value]) => {
        translation = translation.replace(`{${paramKey}}`, String(value));
      });
    }

    return translation;
  }

  private getNestedTranslation(key: string): string {
    const keys = key.split('.');
    let current: any = this.translations;

    for (const k of keys) {
      if (current && typeof current === 'object') {
        current = current[k];
      } else {
        return key; // Возвращаем ключ, если путь не найден
      }
    }

    return typeof current === 'string' ? current : key;
  }
}

export const i18n = new I18nService();
```

### Использование в приложении

```typescript
// app.ts
import { i18n } from './i18n/i18n-service';

// Установка языка
i18n.setLocale('ru');

// Использование переводов
console.log(i18n.t('welcome')); // Выведет: "Добро пожаловать"
console.log(i18n.t('greeting', { name: 'Иван' })); // Выведет: "Привет, Иван!"
console.log(i18n.t('settings.title')); // Выведет: "Настройки"
```

## Расширенные возможности

### Интерполяция с форматированием

```typescript
// i18n/interpolation.ts
export class Interpolator {
  static interpolate(template: string, values: Record<string, any>): string {
    return template.replace(/\{([^}]+)\}/g, (match, key) => {
      const [path, format] = key.trim().split(':');
      let value = this.getNestedValue(values, path);
      
      if (format && value !== undefined) {
        value = this.applyFormat(value, format.trim());
      }
      
      return value !== undefined ? String(value) : match;
    });
  }

  private static getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  private static applyFormat(value: any, format: string): string {
    switch (format) {
      case 'uppercase':
        return String(value).toUpperCase();
      case 'lowercase':
        return String(value).toLowerCase();
      case 'capitalize':
        return String(value).charAt(0).toUpperCase() + String(value).slice(1);
      default:
        return String(value);
    }
  }
}
```

### Поддержка множественного числа

```typescript
// i18n/plural.ts
export class Pluralizer {
  static pluralize(count: number, translations: { one: string; few: string; many: string; other: string }): string {
    if (count === 1) return translations.one;
    if (count >= 2 && count <= 4) return translations.few;
    if (count >= 5 || count === 0) return translations.many;
    return translations.other;
  }
}
```

## Лучшие практики

### 1. Организация файлов локализации

Рекомендуется организовывать файлы локализации по модулям или функциональным областям:

```
i18n/
├── locales/
│   ├── en/
│   │   ├── common.json
│   │   ├── auth.json
│   │   └── settings.json
│   └── ru/
│       ├── common.json
│       ├── auth.json
│       └── settings.json
└── index.ts
```

### 2. Использование типов для проверки

```typescript
// types/i18n-keys.ts
export const translationKeys = {
  common: {
    welcome: 'common.welcome',
    greeting: 'common.greeting',
  },
  settings: {
    title: 'settings.title',
    language: 'settings.language',
  },
  errors: {
    required: 'errors.required',
    email: 'errors.email',
  }
} as const;

export type TranslationKey = typeof translationKeys extends Record<infer K, any> 
  ? K extends string ? K : never 
  : never;
```

### 3. Автоматическая генерация ключей

Для обеспечения безопасности типов можно использовать утилиты для автоматической генерации типов из файлов локализации.

## Интеграция с фреймворками

### React с TypeScript

```typescript
// hooks/useTranslation.ts
import { useState, useEffect } from 'react';
import { i18n } from '../i18n/i18n-service';

export function useTranslation() {
  const [_, setUpdate] = useState(0); // Используем для принудительного обновления

  useEffect(() => {
    const updateHandler = () => setUpdate(prev => prev + 1);
    window.addEventListener('localeChange', updateHandler);
    
    return () => window.removeEventListener('localeChange', updateHandler);
  }, []);

  return {
    t: i18n.t.bind(i18n),
    currentLocale: i18n.getLocale(),
    setLocale: (locale: any) => {
      i18n.setLocale(locale);
      window.dispatchEvent(new Event('localeChange'));
    }
  };
}
```

## Заключение

Локализация строк - это важная часть создания доступных приложений. Правильная архитектура локализации с использованием TypeScript позволяет создавать масштабируемые и поддерживаемые решения. Ключевые аспекты:

- Использование уникальных ключей для строк
- Поддержка параметров и форматирования
- Организация файлов локализации
- Интеграция с используемыми фреймворками

Для более сложных сценариев рекомендуется использовать специализированные библиотеки, такие как [[react-i18next]], [[i18next]] или [[linguijs]].

## См. также

- [[Форматирование-дат-и-времени]]
- [[Форматирование-чисел-и-валют]]
- [[Перевод-компонентов]]
- [[Инструменты-локализации]]
- [[react-i18next]]
- [[i18next]]