---
aliases: [Локализация компонентов, i18n компонентов, Перевод React компонентов]
tags: [typescript, интернационализация, компоненты, react, i18n]
---

# Перевод компонентов в TypeScript

## Обзор

Перевод компонентов - это процесс адаптации пользовательского интерфейса приложения для различных языков и региональных настроек на уровне компонентов. В TypeScript, особенно при использовании фреймворков, таких как React, это включает в себя как перевод строк интерфейса, так и адаптацию визуальных элементов под культурные особенности разных регионов.

## Основы перевода компонентов

### Принципы локализации компонентов

1. **Изоляция строк** - все текстовые элементы компонента должны быть извлечены в файлы локализации
2. **Поддержка направления текста** - компоненты должны корректно отображаться в языках с правым направлением текста (RTL)
3. **Адаптация макета** - компоненты должны изменяться в зависимости от длины переведенного текста
4. **Контекстуальные переводы** - переводы должны учитывать контекст использования

### Архитектура системы локализации компонентов

```typescript
// types/i18n-components.ts
export interface TranslationContext {
  locale: string;
  translations: Record<string, string>;
  direction: 'ltr' | 'rtl';
}

export interface ComponentTranslations {
  [componentName: string]: {
    [key: string]: string;
  };
}

export interface TranslatableComponentProps {
  t: (key: string, params?: Record<string, any>) => string;
  direction: 'ltr' | 'rtl';
}
```

## Практическая реализация

### Базовый провайдер локализации

```typescript
// components/I18nProvider.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';
import { i18n } from '../i18n/i18n-service'; // Предполагаем, что у нас есть базовый сервис локализации

interface I18nContextType {
  locale: string;
  direction: 'ltr' | 'rtl';
  t: (key: string, params?: Record<string, any>) => string;
  setLocale: (locale: string) => void;
}

const I18nContext = createContext<I18nContextType | undefined>(undefined);

interface I18nProviderProps {
  children: ReactNode;
  initialLocale?: string;
}

export const I18nProvider: React.FC<I18nProviderProps> = ({ 
  children, 
  initialLocale = 'en-US' 
}) => {
  const [locale, setLocaleState] = useState(initialLocale);
  
  // Определяем направление текста на основе локали
  const direction: 'ltr' | 'rtl' = ['ar', 'he', 'fa', 'ur'].some(
    rtlLocale => locale.startsWith(rtlLocale)
  ) ? 'rtl' : 'ltr';

  const setLocale = (newLocale: string) => {
    setLocaleState(newLocale);
    i18n.setLocale(newLocale as any);
  };

  const value: I18nContextType = {
    locale,
    direction,
    t: i18n.t.bind(i18n),
    setLocale
  };

  return (
    <I18nContext.Provider value={value}>
      <div dir={direction} lang={locale}>
        {children}
      </div>
    </I18nContext.Provider>
  );
};

export const useI18n = () => {
  const context = useContext(I18nContext);
  if (context === undefined) {
    throw new Error('useI18n must be used within an I18nProvider');
  }
  return context;
};
```

### Компонент с переводом

```typescript
// components/WelcomeBanner.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface WelcomeBannerProps {
  userName?: string;
}

export const WelcomeBanner: React.FC<WelcomeBannerProps> = ({ userName }) => {
  const { t, direction } = useI18n();
  
  return (
    <div 
      className={`welcome-banner ${direction === 'rtl' ? 'rtl' : 'ltr'}`}
      style={{ 
        direction,
        textAlign: direction === 'rtl' ? 'right' : 'left'
      }}
    >
      <h1>{t('welcome')}</h1>
      <p>
        {userName 
          ? t('greeting', { name: userName }) 
          : t('greeting_without_name')
        }
      </p>
    </div>
  );
};
```

### Компонент с числовыми форматами

```typescript
// components/PriceDisplay.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface PriceDisplayProps {
  amount: number;
  currency: string;
}

export const PriceDisplay: React.FC<PriceDisplayProps> = ({ amount, currency }) => {
  const { locale } = useI18n();
  
  // Форматирование цены с использованием Intl.NumberFormat
  const formattedPrice = new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
  
  return (
    <div className="price-display">
      <span className="price-amount">{formattedPrice}</span>
    </div>
  );
};
```

### Компонент с датами

```typescript
// components/EventCard.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface EventCardProps {
  title: string;
  date: Date;
  location: string;
}

export const EventCard: React.FC<EventCardProps> = ({ title, date, location }) => {
  const { t, locale } = useI18n();
  
  // Форматирование даты
  const formattedDate = new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    weekday: 'long'
  }).format(date);
  
  return (
    <div className="event-card">
      <h3>{title}</h3>
      <div className="event-date">{formattedDate}</div>
      <div className="event-location">{location}</div>
      <div className="event-time">
        {t('event_time', { 
          time: date.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' }) 
        })}
      </div>
    </div>
  );
};
```

## Продвинутые паттерны локализации

### Компонент с контекстуальными переводами

```typescript
// components/UserStatus.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface UserStatusProps {
  status: 'online' | 'offline' | 'away' | 'busy';
  userName: string;
}

export const UserStatus: React.FC<UserStatusProps> = ({ status, userName }) => {
  const { t } = useI18n();
  
  // Определяем ключ перевода на основе статуса
  const statusKey = `user_status_${status}`;
  const statusText = t(statusKey, { name: userName });
  
  // Определяем CSS класс на основе статуса
  const statusClass = `user-status ${status}`;
  
  return (
    <div className={statusClass}>
      <span className="status-indicator"></span>
      <span className="status-text">{statusText}</span>
    </div>
  );
};
```

### Компонент с множественным числом

```typescript
// components/ItemCount.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface ItemCountProps {
  count: number;
}

export const ItemCount: React.FC<ItemCountProps> = ({ count }) => {
  const { t, locale } = useI18n();
  
  // Использование Intl.PluralRules для определения формы множественного числа
  const pluralRules = new Intl.PluralRules(locale);
  const pluralCategory = pluralRules.select(count);
  
  // Формирование ключа перевода на основе категории множественного числа
  const translationKey = `items_count_${pluralCategory}`;
  
  return (
    <div className="item-count">
      {t(translationKey, { count })}
    </div>
  );
};
```

### Компонент с динамическим переводом

```typescript
// components/DynamicContent.tsx
import React, { useState } from 'react';
import { useI18n } from './I18nProvider';

interface DynamicContentProps {
  contentKey: string;
  params?: Record<string, any>;
}

export const DynamicContent: React.FC<DynamicContentProps> = ({ contentKey, params }) => {
  const { t } = useI18n();
  
  return (
    <div className="dynamic-content">
      {t(contentKey, params)}
    </div>
  );
};

// Компонент с возможностью редактирования переводов (для разработчиков)
interface EditableTranslationProps {
  children: string;
  translationKey: string;
}

export const EditableTranslation: React.FC<EditableTranslationProps> = ({ 
  children, 
  translationKey 
}) => {
  const { t, locale } = useI18n();
  const [isEditing, setIsEditing] = useState(false);
  const [translation, setTranslation] = useState(t(translationKey));
  
  const handleSave = () => {
    // В реальном приложении здесь будет вызов API для сохранения перевода
    console.log(`Saving translation for ${translationKey} in ${locale}: ${translation}`);
    setIsEditing(false);
  };
  
  if (isEditing) {
    return (
      <div className="editable-translation editing">
        <textarea
          value={translation}
          onChange={(e) => setTranslation(e.target.value)}
        />
        <button onClick={handleSave}>Save</button>
        <button onClick={() => setIsEditing(false)}>Cancel</button>
      </div>
    );
  }
  
  return (
    <div className="editable-translation">
      <span>{translation}</span>
      <button onClick={() => setIsEditing(true)} className="edit-btn">Edit</button>
    </div>
  );
};
```

## Локализация с учетом направления текста (RTL)

### Стили для RTL

```css
/* styles/rtl.css */
.rtl .welcome-banner {
  text-align: right;
  direction: rtl;
}

.rtl .button {
  margin-right: 0;
  margin-left: 10px;
}

.rtl .icon-left {
  margin-right: 0;
  margin-left: 8px;
}

.rtl .icon-right {
  margin-left: 0;
  margin-right: 8px;
}
```

### Компонент с поддержкой RTL

```typescript
// components/BidiText.tsx
import React from 'react';
import { useI18n } from './I18nProvider';

interface BidiTextProps {
  children: string;
  className?: string;
}

export const BidiText: React.FC<BidiTextProps> = ({ children, className = '' }) => {
  const { direction } = useI18n();
  
  return (
    <span 
      className={`${className} ${direction === 'rtl' ? 'rtl-text' : 'ltr-text'}`}
      dir={direction}
    >
      {children}
    </span>
  );
};
```

## Асинхронная загрузка переводов

### Динамическая загрузка переводов

```typescript
// hooks/useTranslations.ts
import { useState, useEffect } from 'react';

interface Translations {
  [key: string]: string;
}

export const useTranslations = (locale: string, namespaces: string[] = []) => {
  const [translations, setTranslations] = useState<Translations>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadTranslations = async () => {
      try {
        setLoading(true);
        setError(null);
        
        // Загрузка переводов для указанной локали
        const loadedTranslations: Translations = {};
        
        for (const namespace of namespaces) {
          const module = await import(`../i18n/locales/${locale}/${namespace}.json`);
          Object.assign(loadedTranslations, module.default);
        }
        
        setTranslations(loadedTranslations);
      } catch (err) {
        setError('Failed to load translations');
        console.error('Translation loading error:', err);
      } finally {
        setLoading(false);
      }
    };

    loadTranslations();
  }, [locale, namespaces]);

  return { translations, loading, error };
};
```

### Компонент с асинхронной загрузкой

```typescript
// components/AsyncTranslationComponent.tsx
import React from 'react';
import { useI18n } from './I18nProvider';
import { useTranslations } from '../hooks/useTranslations';

interface AsyncTranslationComponentProps {
  children: (t: (key: string, params?: Record<string, any>) => string) => React.ReactNode;
  namespace: string;
}

export const AsyncTranslationComponent: React.FC<AsyncTranslationComponentProps> = ({ 
  children, 
  namespace 
}) => {
  const { locale } = useI18n();
  const { translations, loading, error } = useTranslations(locale, [namespace]);

  if (loading) {
    return <div>Loading translations...</div>;
  }

  if (error) {
    return <div>Error loading translations: {error}</div>;
  }

  const t = (key: string, params?: Record<string, any>): string => {
    let translation = translations[key] || key;
    
    if (params) {
      Object.entries(params).forEach(([paramKey, value]) => {
        translation = translation.replace(`{${paramKey}}`, String(value));
      });
    }
    
    return translation;
  };

  return <>{children(t)}</>;
};
```

## Тестирование локализованных компонентов

### Моки для тестирования

```typescript
// __mocks__/i18n-mock.ts
export const mockTranslations = {
  'welcome': 'Welcome',
  'greeting': 'Hello, {name}!',
  'greeting_without_name': 'Hello!',
  'user_status_online': '{name} is online',
  'user_status_offline': '{name} is offline',
  'items_count_one': '{count} item',
  'items_count_other': '{count} items'
};

export const mockI18nContext = {
  locale: 'en-US',
  direction: 'ltr',
  t: (key: string, params?: Record<string, any>): string => {
    let translation = mockTranslations[key] || key;
    
    if (params) {
      Object.entries(params).forEach(([paramKey, value]) => {
        translation = translation.replace(`{${paramKey}}`, String(value));
      });
    }
    
    return translation;
  },
  setLocale: jest.fn()
};
```

### Тестирование компонентов

```typescript
// components/WelcomeBanner.test.tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import { I18nProvider } from './I18nProvider';
import { WelcomeBanner } from './WelcomeBanner';
import { mockI18nContext } from '../__mocks__/i18n-mock';

jest.mock('./I18nProvider', () => ({
  ...jest.requireActual('./I18nProvider'),
  useI18n: () => mockI18nContext
}));

describe('WelcomeBanner', () => {
  test('renders translated welcome message', () => {
    render(
      <I18nProvider>
        <WelcomeBanner userName="John" />
      </I18nProvider>
    );
    
    expect(screen.getByText('Welcome')).toBeInTheDocument();
    expect(screen.getByText('Hello, John!')).toBeInTheDocument();
  });
  
  test('renders greeting without name when userName is not provided', () => {
    render(
      <I18nProvider>
        <WelcomeBanner />
      </I18nProvider>
    );
    
    expect(screen.getByText('Hello!')).toBeInTheDocument();
  });
});
```

## Лучшие практики

### 1. Структура файлов локализации

Организуйте файлы локализации по компонентам или функциональным областям:

```
i18n/
├── locales/
│   ├── en/
│   │   ├── common.json
│   │   ├── components/
│   │   │   ├── welcome.json
│   │   │   ├── navigation.json
│   │   │   └── forms.json
│   │   └── pages/
│   │       ├── home.json
│   │       └── profile.json
│   └── ru/
│       ├── common.json
│       ├── components/
│       │   ├── welcome.json
│       │   ├── navigation.json
│       │   └── forms.json
│       └── pages/
│           ├── home.json
│           └── profile.json
└── index.ts
```

### 2. Использование типов для безопасности переводов

```typescript
// types/translation-keys.ts
export const translationKeys = {
  common: {
    welcome: 'common.welcome',
    greeting: 'common.greeting',
  },
  components: {
    welcome: {
      title: 'components.welcome.title',
      message: 'components.welcome.message',
    },
    navigation: {
      home: 'components.navigation.home',
      profile: 'components.navigation.profile',
    }
  }
} as const;

export type TranslationKey = typeof translationKeys extends Record<infer K, any> 
  ? K extends string ? K : never 
  : never;
```

### 3. Обработка отсутствующих переводов

```typescript
// components/FallbackTranslation.tsx
import React from 'react';

interface FallbackTranslationProps {
  children: React.ReactNode;
  fallback: string;
  showWarning?: boolean;
}

export const FallbackTranslation: React.FC<FallbackTranslationProps> = ({ 
  children, 
  fallback, 
  showWarning = true 
}) => {
  const [hasContent, setHasContent] = useState(false);
  
  useEffect(() => {
    // Проверяем, есть ли контент у дочернего элемента
    if (React.isValidElement(children)) {
      const childText = (children as any).props.children;
      setHasContent(!!childText && childText !== '');
    }
  }, [children]);
  
  if (showWarning && !hasContent) {
    console.warn(`Translation missing, using fallback: ${fallback}`);
  }
  
  return <>{hasContent ? children : fallback}</>;
};
```

## Интеграция с популярными библиотеками

### С использованием react-i18next

```typescript
// components/withReactI18Next.tsx
import React from 'react';
import { useTranslation } from 'react-i18next';

interface UserProfileProps {
  name: string;
  email: string;
}

export const UserProfile: React.FC<UserProfileProps> = ({ name, email }) => {
  const { t } = useTranslation('profile');
  
  return (
    <div className="user-profile">
      <h2>{t('title')}</h2>
      <p>{t('name_label')}: {name}</p>
      <p>{t('email_label')}: {email}</p>
    </div>
  );
};
```

### С использованием next-i18next (для Next.js)

```typescript
// pages/profile.tsx
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';
import { useTranslation } from 'next-i18next';

const ProfilePage = () => {
  const { t } = useTranslation('profile');
  
  return (
    <div>
      <h1>{t('page_title')}</h1>
      {/* Содержимое страницы */}
    </div>
  );
};

export const getStaticProps = async ({ locale }: { locale: string }) => ({
  props: {
    ...(await serverSideTranslations(locale, ['profile', 'common'])),
  },
});

export default ProfilePage;
```

## Заключение

Перевод компонентов в TypeScript требует комплексного подхода, включающего:

- Использование провайдеров состояния локализации
- Адаптацию компонентов под различные языки и направления текста
- Правильное форматирование чисел, дат и валют
- Обработку множественного числа
- Тестирование локализованных компонентов
- Эффективную структуру файлов переводов

Для сложных приложений рекомендуется использовать специализированные библиотеки, такие как [[react-i18next]], [[next-i18next]] или [[linguijs]], которые обеспечивают продвинутые возможности локализации компонентов.

## См. также

- [[Локализация-строк]]
- [[Форматирование-дат-и-времени]]
- [[Форматирование-чисел-и-валют]]
- [[Инструменты-локализации]]
- [[react-i18next]]
- [[next-i18next]]
- [[linguijs]]