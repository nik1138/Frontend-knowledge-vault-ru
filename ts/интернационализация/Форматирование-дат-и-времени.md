---
aliases: [Форматирование дат, Локализация дат, Intl.DateTimeFormat, Формат даты]
tags: [typescript, интернационализация, дата, время, форматирование, i18n]
---

# Форматирование дат и времени в TypeScript

## Обзор

Форматирование дат и времени - это важная часть интернационализации веб-приложений, поскольку различные регионы мира используют разные форматы представления даты и времени. В TypeScript, как и в JavaScript, для этой цели используется встроенный объект `Intl.DateTimeFormat`, который позволяет форматировать даты в соответствии с локальными предпочтениями.

## Основы форматирования дат

### Встроенный объект Intl.DateTimeFormat

`Intl.DateTimeFormat` - это конструктор объекта, позволяющий форматировать даты и время в зависимости от языка и региональных настроек. Он предоставляет гибкие возможности для настройки форматирования дат.

```typescript
// Базовое использование
const date = new Date();

// Форматирование для английского языка
const enFormatter = new Intl.DateTimeFormat('en-US');
console.log(enFormatter.format(date)); // Например: "11/23/2025"

// Форматирование для русского языка
const ruFormatter = new Intl.DateTimeFormat('ru-RU');
console.log(ruFormatter.format(date)); // Например: "23.11.2025"
```

### Опции форматирования

`Intl.DateTimeFormat` принимает дополнительный параметр с опциями форматирования, которые позволяют настраивать представление даты и времени:

```typescript
const date = new Date();

// Форматирование с опциями
const options: Intl.DateTimeFormatOptions = {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  weekday: 'long',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit',
  timeZoneName: 'short'
};

const formatter = new Intl.DateTimeFormat('ru-RU', options);
console.log(formatter.format(date)); // Например: "воскресенье, 23 ноября 2025 г., 14:30:00 (MSK)"
```

## Практические примеры форматирования

### Общие форматы даты

```typescript
// Сервис форматирования дат
export class DateFormatter {
  static formatDate(date: Date, locale: string = 'en-US'): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }).format(date);
  }

  static formatDateTime(date: Date, locale: string = 'en-US'): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  }

  static formatTime(date: Date, locale: string = 'en-US'): string {
    return new Intl.DateTimeFormat(locale, {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    }).format(date);
  }

  // Форматирование для отображения в календаре
  static formatCalendarDate(date: Date, locale: string = 'en-US'): string {
    return new Intl.DateTimeFormat(locale, {
      weekday: 'short',
      month: 'short',
      day: 'numeric'
    }).format(date);
  }

  // Форматирование для отчетов
  static formatReportDate(date: Date, locale: string = 'en-US'): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }).format(date);
  }
}

// Использование
const now = new Date();
console.log(DateFormatter.formatDate(now, 'en-US')); // "11/23/2025"
console.log(DateFormatter.formatDate(now, 'ru-RU')); // "23.11.2025"
console.log(DateFormatter.formatTime(now, 'de-DE')); // "14:30:00"
```

### Форматирование относительного времени

```typescript
// Форматирование относительного времени (например, "5 минут назад")
export class RelativeTimeFormatter {
  static format(date: Date, locale: string = 'en-US'): string {
    const formatter = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    const now = new Date();
    const diffInSeconds = Math.floor((date.getTime() - now.getTime()) / 1000);

    // Определяем единицу измерения
    let unit: Intl.RelativeTimeFormatUnit;
    let value: number;

    if (Math.abs(diffInSeconds) < 60) {
      unit = 'second';
      value = diffInSeconds;
    } else if (Math.abs(diffInSeconds) < 3600) {
      unit = 'minute';
      value = Math.floor(diffInSeconds / 60);
    } else if (Math.abs(diffInSeconds) < 86400) {
      unit = 'hour';
      value = Math.floor(diffInSeconds / 3600);
    } else if (Math.abs(diffInSeconds) < 2592000) {
      unit = 'day';
      value = Math.floor(diffInSeconds / 86400);
    } else if (Math.abs(diffInSeconds) < 31536000) {
      unit = 'month';
      value = Math.floor(diffInSeconds / 2592000);
    } else {
      unit = 'year';
      value = Math.floor(diffInSeconds / 31536000);
    }

    return formatter.format(value, unit);
  }
}

// Использование
const pastDate = new Date(Date.now() - 5 * 60 * 1000); // 5 минут назад
console.log(RelativeTimeFormatter.format(pastDate, 'en-US')); // "5 minutes ago"
console.log(RelativeTimeFormatter.format(pastDate, 'ru-RU')); // "5 минут назад"
```

### Форматирование продолжительности

```typescript
// Форматирование продолжительности времени
export class DurationFormatter {
  static format(milliseconds: number, locale: string = 'en-US'): string {
    const formatter = new Intl.NumberFormat(locale, { style: 'unit', unit: 'second', unitDisplay: 'narrow' });
    
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    const remainingMinutes = minutes % 60;
    const remainingSeconds = seconds % 60;
    
    const parts = [];
    
    if (hours > 0) {
      const hourFormatter = new Intl.NumberFormat(locale, { style: 'unit', unit: 'hour', unitDisplay: 'narrow' });
      parts.push(`${hourFormatter.format(hours)}`);
    }
    
    if (remainingMinutes > 0) {
      const minuteFormatter = new Intl.NumberFormat(locale, { style: 'unit', unit: 'minute', unitDisplay: 'narrow' });
      parts.push(`${minuteFormatter.format(remainingMinutes)}`);
    }
    
    if (remainingSeconds > 0 || parts.length === 0) {
      parts.push(`${formatter.format(remainingSeconds)}`);
    }
    
    return parts.join(' ');
  }
  
  // Форматирование продолжительности как интервал
  static formatInterval(start: Date, end: Date, locale: string = 'en-US'): string {
    const duration = end.getTime() - start.getTime();
    return this.format(duration, locale);
  }
}
```

## Расширенные возможности

### Работа с часовыми поясами

```typescript
// Форматирование с учетом часового пояса
export class TimezoneAwareFormatter {
  static formatDate(date: Date, locale: string = 'en-US', timeZone: string = 'UTC'): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      timeZone
    }).format(date);
  }

  static formatDateTimeWithTimezone(date: Date, locale: string = 'en-US', timeZone: string = 'UTC'): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      timeZone,
      timeZoneName: 'short'
    }).format(date);
  }

  // Форматирование для международных пользователей
  static formatForUser(date: Date, userLocale: string, userTimezone: string): string {
    return new Intl.DateTimeFormat(userLocale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      timeZone: userTimezone,
      timeZoneName: 'short'
    }).format(date);
  }
}

// Использование
const utcDate = new Date();
console.log(TimezoneAwareFormatter.formatDateTimeWithTimezone(utcDate, 'en-US', 'America/New_York'));
console.log(TimezoneAwareFormatter.formatDateTimeWithTimezone(utcDate, 'ru-RU', 'Europe/Moscow'));
```

### Кастомные форматы

```typescript
// Класс для создания кастомных форматов
export class CustomDateFormatter {
  private formatters: Map<string, Intl.DateTimeFormat> = new Map();

  constructor(private locale: string = 'en-US') {}

  // Регистрация кастомного формата
  registerFormat(name: string, options: Intl.DateTimeFormatOptions): void {
    this.formatters.set(name, new Intl.DateTimeFormat(this.locale, options));
  }

  // Форматирование по зарегистрированному формату
  format(date: Date, formatName: string): string {
    const formatter = this.formatters.get(formatName);
    if (!formatter) {
      throw new Error(`Format "${formatName}" is not registered`);
    }
    return formatter.format(date);
  }

  // Общие кастомные форматы
  static getCommonFormats(locale: string): Record<string, Intl.DateTimeFormatOptions> {
    return {
      'short': { year: '2-digit', month: '2-digit', day: '2-digit' },
      'medium': { year: 'numeric', month: 'short', day: 'numeric' },
      'long': { year: 'numeric', month: 'long', day: 'numeric' },
      'full': { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' },
      'time': { hour: '2-digit', minute: '2-digit' },
      'datetime': { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' },
      'iso': { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit', 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit', 
        timeZone: 'UTC',
        timeZoneName: 'short'
      }
    };
  }
}

// Использование кастомных форматов
const customFormatter = new CustomDateFormatter('ru-RU');
const commonFormats = CustomDateFormatter.getCommonFormats('ru-RU');

// Регистрация общих форматов
Object.entries(commonFormats).forEach(([name, options]) => {
  customFormatter.registerFormat(name, options);
});

const date = new Date();
console.log(customFormatter.format(date, 'short')); // "23.11.25"
console.log(customFormatter.format(date, 'long'));  // "23 ноября 2025 г."
```

## Лучшие практики

### 1. Хранение дат в UTC

При работе с датами в приложениях, особенно с серверными компонентами, рекомендуется хранить даты в формате UTC и конвертировать их в локальный формат только для отображения пользователю.

```typescript
// Хранение дат в UTC
export class UTCDateManager {
  static toUTC(date: Date): Date {
    return new Date(date.getTime() + date.getTimezoneOffset() * 60000);
  }

  static fromUTC(utcDate: Date): Date {
    return new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
  }

  // Преобразование ISO строки в локальную дату
  static parseISOString(isoString: string): Date {
    // Добавляем 'Z' если отсутствует, чтобы указать UTC
    if (!isoString.endsWith('Z') && !isoString.includes('+') && !isoString.includes('-')) {
      isoString += 'Z';
    }
    return new Date(isoString);
  }
}
```

### 2. Обработка разных календарных систем

```typescript
// Поддержка разных календарных систем
export class CalendarAwareFormatter {
  static formatWithCalendar(date: Date, locale: string, calendar: string): string {
    return new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      calendar
    }).format(date);
  }

  // Примеры календарных систем
  static formatWithCalendars(date: Date, locale: string): Record<string, string> {
    const calendars = ['gregory', 'hebrew', 'islamic', 'japanese', 'chinese'];
    const result: Record<string, string> = {};

    for (const cal of calendars) {
      try {
        result[cal] = this.formatWithCalendar(date, locale, cal);
      } catch (e) {
        // Некоторые календари могут не поддерживаться в определенных локалях
        result[cal] = `Н/Д (${cal})`;
      }
    }

    return result;
  }
}
```

### 3. Кэширование форматтеров

Для повышения производительности при частом форматировании дат рекомендуется кэшировать экземпляры `Intl.DateTimeFormat`:

```typescript
// Кэширование форматтеров
export class CachedDateFormatter {
  private static formatterCache: Map<string, Intl.DateTimeFormat> = new Map();

  static getFormatter(locale: string, options?: Intl.DateTimeFormatOptions): Intl.DateTimeFormat {
    const key = `${locale}-${JSON.stringify(options || {})}`;
    
    if (!this.formatterCache.has(key)) {
      this.formatterCache.set(key, new Intl.DateTimeFormat(locale, options));
    }
    
    return this.formatterCache.get(key)!;
  }

  static format(date: Date, locale: string, options?: Intl.DateTimeFormatOptions): string {
    const formatter = this.getFormatter(locale, options);
    return formatter.format(date);
  }
}
```

## Интеграция с фреймворками

### React с TypeScript

```typescript
// Хук для форматирования дат
import { useMemo } from 'react';

export function useDateFormatter(locale?: string, options?: Intl.DateTimeFormatOptions) {
  const formatter = useMemo(() => {
    return new Intl.DateTimeFormat(locale || 'en-US', options);
  }, [locale, options]);

  return (date: Date) => formatter.format(date);
}

// Использование в компоненте
function DateTimeDisplay({ date }: { date: Date }) {
  const format = useDateFormatter('ru-RU', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });

  return <span>{format(date)}</span>;
}
```

## Заключение

Форматирование дат и времени в TypeScript с использованием `Intl.DateTimeFormat` предоставляет мощные и гибкие возможности для создания интернационализированных приложений. Ключевые аспекты:

- Использование встроенного API `Intl.DateTimeFormat`
- Понимание опций форматирования
- Работа с часовыми поясами
- Кэширование для повышения производительности
- Поддержка различных календарных систем

Для более сложных сценариев форматирования дат рекомендуется использовать специализированные библиотеки, такие как [[date-fns]] или [[moment.js]] с плагинами интернационализации.

## См. также

- [[Локализация-строк]]
- [[Форматирование-чисел-и-валют]]
- [[Перевод-компонентов]]
- [[Инструменты-локализации]]
- [[date-fns]]
- [[moment.js]]