# Функторы и монады

Функторы и монады - это продвинутые концепции функционального программирования, которые позволяют работать с контейнеризированными значениями и управлять эффектами вычислений.

## Содержание

- [Функторы и монады](#функторы-и-монады)
  - [Содержание](#содержание)
  - [Понятие функторов](#понятие-функторов)
  - [Понятие монад](#понятие-монад)
  - [Различие между функторами и монадами](#различие-между-функторами-и-монадами)
  - [Связи с другими концепциями](#связи-с-другими-концепциями)
  - [Следующие шаги](#следующие-шаги)

## Понятие функторов

Функтор - это структура, которая позволяет применять функции к значениям внутри контейнера, не извлекая их. Функтор должен реализовывать метод `map`, который принимает функцию и возвращает новый функтор с преобразованным значением.

```typescript
// Интерфейс функтора
interface Functor<T> {
  map: <U>(fn: (value: T) => U) => Functor<U>;
}

// Пример: Maybe функтор
type Maybe<T> = T | null | undefined;

const mapMaybe = <T, U>(fn: (value: T) => U) => (maybe: Maybe<T>): Maybe<U> => {
  if (maybe === null || maybe === undefined) {
    return maybe as Maybe<U>; // null или undefined
  }
  return fn(maybe);
};

// Использование
const double = (x: number): number => x * 2;
const maybeDouble = mapMaybe(double);

console.log(maybeDouble(5)); // 10
console.log(maybeDouble(null)); // null
console.log(maybeDouble(undefined)); // undefined
```

## Понятие монад

Монада - это функтор с дополнительными возможностями. Монада должна реализовывать метод `flatMap` (или `chain`), который позволяет объединять вычисления, возвращающие монады. Монада также должна иметь метод `of` (или `pure`) для создания монады из обычного значения.

```typescript
// Интерфейс монады
interface Monad<T> extends Functor<T> {
  flatMap: <U>(fn: (value: T) => Monad<U>) => Monad<U>;
  of: (value: T) => Monad<T>;
}

// Пример: Maybe монада
class MaybeMonad<T> {
  private constructor(private value: T | null) {}
  
  static of<T>(value: T | null): MaybeMonad<T> {
    return new MaybeMonad(value);
  }
  
  map<U>(fn: (value: T) => U): MaybeMonad<U> {
    if (this.value === null) {
      return new MaybeMonad<U>(null);
    }
    return new MaybeMonad<U>(fn(this.value));
  }
  
  flatMap<U>(fn: (value: T) => MaybeMonad<U>): MaybeMonad<U> {
    if (this.value === null) {
      return new MaybeMonad<U>(null);
    }
    return fn(this.value);
  }
  
  getValue(): T | null {
    return this.value;
  }
}

// Использование
const divide = (a: number, b: number): MaybeMonad<number> => {
  if (b === 0) {
    return MaybeMonad.of(null);
  }
  return MaybeMonad.of(a / b);
};

const result = MaybeMonad.of(10)
  .flatMap(x => divide(x, 2))
  .flatMap(x => divide(x, 0)) // Это вернет null
  .map(x => x * 2);

console.log(result.getValue()); // null
```

## Различие между функторами и монадами

Основное различие между функторами и монадами заключается в том, что:

1. **Функтор** позволяет применять функции к значениям внутри контейнера с помощью `map`
2. **Монада** позволяет объединять вычисления, возвращающие контейнеры, с помощью `flatMap`

```typescript
// Функтор может применять функции, но не может объединять контексты
const functorExample = () => {
  // Maybe как функтор
  const maybeValue: Maybe<number> = 5;
  const doubled = mapMaybe(x => x * 2)(maybeValue);
  console.log(doubled); // 10
};

// Монада может объединять контексты
const monadExample = () => {
  // Maybe как монада
  const result = MaybeMonad.of(10)
    .flatMap(x => MaybeMonad.of(x * 2)) // 20
    .flatMap(x => MaybeMonad.of(x + 5)); // 25
  
  console.log(result.getValue()); // 25
};

// Пример, где функтор не подходит, а монада решает проблему
const problematicExample = () => {
  // Функция, возвращающая Maybe
  const safeDivide = (a: number, b: number): Maybe<number> => {
    if (b === 0) return null;
    return a / b;
  };
  
  // С функтором мы получим Maybe<Maybe<number>>
  const functorResult = mapMaybe(x => safeDivide(x, 2))(MaybeMonad.of(10).getValue());
  console.log(functorResult); // Maybe<Maybe<number>> - вложенный контейнер
  
  // С монадой мы получаем плоский результат
  const monadResult = MaybeMonad.of(10).flatMap(x => 
    MaybeMonad.of(safeDivide(x, 2) as number)
  );
  console.log(monadResult.getValue()); // number или null
};
```

## Связи с другими концепциями

- [[ts/functional-programming/Функциональное_программирование|Функциональное программирование]] - Основная страница раздела
- [[ts/functional-programming/pure-functions|Чистые функции]] - Работа с чистыми функциями
- [[ts/functional-programming/higher-order-functions|Функции высшего порядка]] - Функции, принимающие или возвращающие другие функции
- [[ts/functional-programming/composition|Композиция функций]] - Объединение функций для создания новых функций
- [[ts/functional-programming/currying|Каррирование]] - Техника создания функций с одним аргументом
- [[ts/error-handling/index|Обработка ошибок]] - Обработка ошибок в функциональном стиле
- [[ts/testing/index|Тестирование]] - Тестирование функторов и монад

## Следующие шаги

- [[ts/functional-programming/functors-monads/functors|Функторы]] - Подробное изучение функторов
- [[ts/functional-programming/functors-monads/monads|Монады]] - Подробное изучение монад
- [[ts/functional-programming/functors-monads/common-monads|Распространенные монады]] - Изучение популярных монад
- [[ts/functional-programming/functors-monads/practical-examples|Практические примеры]] - Реальные примеры использования
- [[ts/error-handling/index|Обработка ошибок]] - Расширенная обработка ошибок в функциональном стиле