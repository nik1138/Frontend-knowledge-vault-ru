# Тестирование функционального кода

Тестирование функционального кода имеет свои особенности и подходы, отличные от традиционного императивного программирования. В функциональном программировании акцент делается на тестировании чистых функций, свойств и поведения системы.

## Содержание

- [Тестирование функционального кода](#тестирование-функционального-кода)
  - [Содержание](#содержание)
  - [Особенности тестирования функционального кода](#особенности-тестирования-функционального-кода)
  - [Тестирование чистых функций](#тестирование-чистых-функций)
  - [Property-based тестирование](#property-based-тестирование)
  - [Тестирование функторов и монад](#тестирование-функторов-и-монад)
  - [Тестирование композиции функций](#тестирование-композиции-функций)
  - [Тестирование с использованием фикстур](#тестирование-с-использованием-фикстур)
  - [Моки и стабы в функциональном стиле](#моки-и-стабы-в-функциональном-стиле)
  - [Интеграционное тестирование](#интеграционное-тестирование)
  - [Лучшие практики](#лучшие-практики)
    - [1. Тестирование чистых функций](#1-тестирование-чистых-функций)
    - [2. Использование property-based тестирования](#2-использование-property-based-тестирования)
    - [3. Тестирование законов функторов и монад](#3-тестирование-законов-функторов-и-монад)
    - [4. Изоляция побочных эффектов](#4-изоляция-побочных-эффектов)
  - [Связи с другими концепциями](#связи-с-другими-концепциями)
  - [Следующие шаги](#следующие-шаги)

## Особенности тестирования функционального кода

Функциональное программирование предоставляет уникальные преимущества для тестирования:

1. **Чистые функции** - легко тестировать, так как результат зависит только от входных параметров
2. **Отсутствие побочных эффектов** - предсказуемое поведение и воспроизводимость
3. **Иммутабельность** - отсутствие изменяемого состояния упрощает тестирование
4. **Композиция** - возможность тестировать компоненты изолированно и в комбинации

```typescript
// Пример чистой функции, которую легко тестировать
const add = (a: number, b: number): number => a + b;

// Пример функции с побочными эффектами (труднее тестировать)
const addWithLogging = (a: number, b: number): number => {
  console.log(`Сложение ${a} и ${b}`);
  return a + b;
};

// Функциональный подход к логированию (тестируемо)
const addWithPureLogging = (a: number, b: number, logger: (msg: string) => void): number => {
  logger(`Сложение ${a} и ${b}`);
  return a + b;
};
```

## Тестирование чистых функций

Чистые функции - основа функционального программирования и самый простой объект для тестирования.

```typescript
// Примеры чистых функций для тестирования
const multiply = (a: number, b: number): number => a * b;

const isEven = (n: number): boolean => n % 2 === 0;

const filterEven = <T extends number>(arr: T[]): T[] => arr.filter(isEven);

const sum = (arr: number[]): number => arr.reduce((acc, curr) => acc + curr, 0);

const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B): ((a: A) => C) => 
  (a: A) => f(g(a));

// Тесты для чистых функций
describe("Чистые функции", () => {
  test("multiply должен корректно умножать числа", () => {
    expect(multiply(2, 3)).toBe(6);
    expect(multiply(-2, 3)).toBe(-6);
    expect(multiply(0, 5)).toBe(0);
  });

  test("isEven должен корректно определять четные числа", () => {
    expect(isEven(2)).toBe(true);
    expect(isEven(3)).toBe(false);
    expect(isEven(0)).toBe(true);
    expect(isEven(-2)).toBe(true);
  });

  test("filterEven должен фильтровать четные числа", () => {
    expect(filterEven([1, 2, 3, 4, 5, 6])).toEqual([2, 4, 6]);
    expect(filterEven([1, 3, 5])).toEqual([]);
    expect(filterEven([2, 4, 6])).toEqual([2, 4, 6]);
  });

  test("sum должен корректно суммировать массив чисел", () => {
    expect(sum([1, 2, 3, 4, 5])).toBe(15);
    expect(sum([])).toBe(0);
    expect(sum([-1, 1])).toBe(0);
  });

  test("compose должен корректно компоновать функции", () => {
    const addOne = (x: number): number => x + 1;
    const multiplyByTwo = (x: number): number => x * 2;
    
    const addOneThenMultiplyByTwo = compose(multiplyByTwo, addOne);
    expect(addOneThenMultiplyByTwo(5)).toBe(12); // (5 + 1) * 2 = 12
  });
});
```

## Property-based тестирование

Property-based тестирование - мощная техника, при которой тестируются свойства функций, а не конкретные значения.

```typescript
// Примеры свойств для тестирования
const reverse = <T>(arr: T[]): T[] => [...arr].reverse();

const sort = <T>(arr: T[]): T[] => [...arr].sort();

// Свойства для тестирования
describe("Property-based тестирование", () => {
  // Property: двойной реверс возвращает исходный массив
  test("reverse(reverse(arr)) === arr", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        expect(reverse(reverse(arr))).toEqual(arr);
      })
    );
  });

  // Property: сортировка возвращает отсортированный массив
  test("sort(arr) возвращает отсортированный массив", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        const sorted = sort(arr);
        for (let i = 0; i < sorted.length - 1; i++) {
          expect(sorted[i] <= sorted[i + 1]).toBe(true);
        }
      })
    );
  });

  // Property: сортировка сохраняет длину массива
  test("sort(arr) сохраняет длину массива", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        expect(sort(arr).length).toBe(arr.length);
      })
    );
  });

  // Property: сортировка содержит те же элементы
  test("sort(arr) содержит те же элементы", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        const sorted = sort(arr);
        const originalElements = [...arr].sort((a, b) => a - b);
        const sortedElements = [...sorted].sort((a, b) => a - b);
        expect(sortedElements).toEqual(originalElements);
      })
    );
  });
});
```

## Тестирование функторов и монад

Функторы и монады должны подчиняться определенным законам, которые также нужно тестировать.

```typescript
// Maybe монада для тестирования
type Maybe<T> = T | null | undefined;

class MaybeMonad<T> {
  private constructor(private value: T | null | undefined) {}
  
  static of<T>(value: T | null | undefined): MaybeMonad<T> {
    return new MaybeMonad(value);
  }
  
  static just<T>(value: T): MaybeMonad<T> {
    return new MaybeMonad(value);
  }
  
  static nothing<T>(): MaybeMonad<T> {
    return new MaybeMonad<T>(null);
  }
  
  map<U>(fn: (value: T) => U): MaybeMonad<U> {
    if (this.value === null || this.value === undefined) {
      return new MaybeMonad<U>(null);
    }
    return new MaybeMonad<U>(fn(this.value));
  }
  
  flatMap<U>(fn: (value: T) => MaybeMonad<U>): MaybeMonad<U> {
    if (this.value === null || this.value === undefined) {
      return new MaybeMonad<U>(null);
    }
    return fn(this.value);
  }
  
  getValue(): T | null | undefined {
    return this.value;
  }
  
  isNothing(): boolean {
    return this.value === null || this.value === undefined;
  }
  
  isJust(): boolean {
    return !this.isNothing();
  }
}

// Тестирование законов функторов
describe("Законы функторов", () => {
  // Закон идентичности: functor.map(x => x) === functor
  test("Закон идентичности для Maybe", () => {
    const identity = <T>(x: T): T => x;
    
    // Тест с Just значением
    const justValue = MaybeMonad.just(5);
    expect(justValue.map(identity).getValue()).toBe(justValue.getValue());
    
    // Тест с Nothing
    const nothingValue = MaybeMonad.nothing<number>();
    expect(nothingValue.map(identity).isNothing()).toBe(true);
  });

  // Закон композиции: functor.map(f).map(g) === functor.map(x => g(f(x)))
  test("Закон композиции для Maybe", () => {
    const f = (x: number): number => x + 1;
    const g = (x: number): number => x * 2;
    
    const justValue = MaybeMonad.just(5);
    
    const leftSide = justValue.map(f).map(g);
    const rightSide = justValue.map(x => g(f(x)));
    
    expect(leftSide.getValue()).toBe(rightSide.getValue());
  });
});

// Тестирование законов монад
describe("Законы монад", () => {
  // Левый закон единицы: Monad.of(a).flatMap(f) === f(a)
  test("Левый закон единицы для Maybe", () => {
    const a = 5;
    const f = (x: number) => MaybeMonad.just(x * 2);
    
    const leftSide = MaybeMonad.of(a).flatMap(f);
    const rightSide = f(a);
    
    expect(leftSide.getValue()).toBe(rightSide.getValue());
  });

  // Правый закон единицы: m.flatMap(Monad.of) === m
  test("Правый закон единицы для Maybe", () => {
    const m = MaybeMonad.just(5);
    
    const leftSide = m.flatMap(x => MaybeMonad.of(x));
    const rightSide = m;
    
    expect(leftSide.getValue()).toBe(rightSide.getValue());
  });

  // Закон ассоциативности: m.flatMap(f).flatMap(g) === m.flatMap(x => f(x).flatMap(g))
  test("Закон ассоциативности для Maybe", () => {
    const m = MaybeMonad.just(5);
    
    const f = (x: number) => MaybeMonad.just(x * 2);
    const g = (x: number) => MaybeMonad.just(x + 1);
    
    const leftSide = m.flatMap(f).flatMap(g);
    const rightSide = m.flatMap(x => f(x).flatMap(g));
    
    expect(leftSide.getValue()).toBe(rightSide.getValue());
  });
});
```

## Тестирование композиции функций

Композиция функций - ключевая концепция функционального программирования, требующая тщательного тестирования.

```typescript
// Утилиты для композиции
const pipe = <A, B, C>(f: (a: A) => B, g: (b: B) => C): ((a: A) => C) => 
  (a: A) => g(f(a));

const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B): ((a: A) => C) => 
  (a: A) => f(g(a));

// Функции для композиции
const add = (x: number): number => x + 1;
const multiply = (x: number): number => x * 2;
const square = (x: number): number => x * x;

// Тестирование композиции
describe("Тестирование композиции", () => {
  test("pipe должен корректно компоновать функции", () => {
    const piped = pipe(add, multiply);
    expect(piped(5)).toBe(12); // (5 + 1) * 2 = 12
  });

  test("compose должен корректно компоновать функции", () => {
    const composed = compose(multiply, add);
    expect(composed(5)).toBe(12); // (5 + 1) * 2 = 12
  });

  test("pipe и compose должны давать одинаковый результат при обратном порядке", () => {
    const piped = pipe(add, multiply);
    const composed = compose(multiply, add);
    
    const input = 5;
    expect(piped(input)).toBe(composed(input));
  });

  test("Сложная композиция функций", () => {
    const complex = pipe(add, multiply, square);
    expect(complex(3)).toBe(64); // ((3 + 1) * 2) ^ 2 = 64
  });
});
```

## Тестирование с использованием фикстур

Фикстуры помогают создавать повторно используемые тестовые данные.

```typescript
// Фикстуры для тестирования
const createUserFixture = (overrides: Partial<User> = {}): User => ({
  id: Math.floor(Math.random() * 1000000),
  name: "Тестовый пользователь",
  email: "test@example.com",
  createdAt: new Date(),
  ...overrides
});

const createProductFixture = (overrides: Partial<Product> = {}): Product => ({
  id: Math.floor(Math.random() * 1000000),
  name: "Тестовый продукт",
  price: 100,
  inStock: true,
  ...overrides
});

interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

interface Product {
  id: number;
  name: string;
  price: number;
  inStock: boolean;
}

// Функции для тестирования
const formatUser = (user: User): string => 
  `${user.name} (${user.email})`;

const calculateTotal = (products: Product[]): number => 
  products.reduce((sum, product) => sum + (product.inStock ? product.price : 0), 0);

const findUserByEmail = (users: User[], email: string): User | undefined => 
  users.find(user => user.email === email);

// Тесты с фикстурами
describe("Тестирование с фикстурами", () => {
  test("formatUser должен корректно форматировать пользователя", () => {
    const user = createUserFixture({ name: "Иван Иванов", email: "ivan@example.com" });
    expect(formatUser(user)).toBe("Иван Иванов (ivan@example.com)");
  });

  test("calculateTotal должен корректно рассчитывать общую сумму", () => {
    const products = [
      createProductFixture({ price: 100, inStock: true }),
      createProductFixture({ price: 200, inStock: true }),
      createProductFixture({ price: 50, inStock: false })
    ];
    
    expect(calculateTotal(products)).toBe(300);
  });

  test("findUserByEmail должен находить пользователя по email", () => {
    const users = [
      createUserFixture({ email: "user1@example.com" }),
      createUserFixture({ email: "user2@example.com" }),
      createUserFixture({ email: "user3@example.com" })
    ];
    
    const foundUser = findUserByEmail(users, "user2@example.com");
    expect(foundUser).toBeDefined();
    expect(foundUser?.email).toBe("user2@example.com");
  });

  test("findUserByEmail должен возвращать undefined для несуществующего email", () => {
    const users = [
      createUserFixture({ email: "user1@example.com" }),
      createUserFixture({ email: "user2@example.com" })
    ];
    
    const foundUser = findUserByEmail(users, "nonexistent@example.com");
    expect(foundUser).toBeUndefined();
  });
});
```

## Моки и стабы в функциональном стиле

В функциональном программировании моки и стабы реализуются через передачу зависимостей в виде функций.

```typescript
// Функциональный подход к мокам
interface Dependencies {
  fetchUser: (id: number) => Promise<User | null>;
  sendEmail: (email: string, message: string) => Promise<boolean>;
  log: (message: string) => void;
}

// Функция с зависимостями
const processUser = async (
  userId: number, 
  deps: Dependencies
): Promise<boolean> => {
  deps.log(`Начало обработки пользователя ${userId}`);
  
  const user = await deps.fetchUser(userId);
  if (!user) {
    deps.log(`Пользователь ${userId} не найден`);
    return false;
  }
  
  const success = await deps.sendEmail(
    user.email, 
    `Привет, ${user.name}!`
  );
  
  deps.log(`Отправка email ${success ? 'успешна' : 'не удалась'}`);
  return success;
};

// Реальные зависимости
const realDependencies: Dependencies = {
  fetchUser: async (id: number) => {
    // Реальная реализация
    return Promise.resolve(null);
  },
  sendEmail: async (email: string, message: string) => {
    // Реальная реализация
    return Promise.resolve(true);
  },
  log: (message: string) => {
    console.log(message);
  }
};

// Моки для тестирования
const createMockDependencies = (overrides: Partial<Dependencies> = {}): Dependencies => ({
  fetchUser: async (id: number) => Promise.resolve(null),
  sendEmail: async (email: string, message: string) => Promise.resolve(true),
  log: (message: string) => {}, // Ничего не делаем в тестах
  ...overrides
});

// Тесты с моками
describe("Тестирование с моками", () => {
  test("processUser должен возвращать false для несуществующего пользователя", async () => {
    const mockDeps = createMockDependencies({
      fetchUser: async (id: number) => Promise.resolve(null)
    });
    
    const result = await processUser(1, mockDeps);
    expect(result).toBe(false);
  });

  test("processUser должен возвращать true для существующего пользователя", async () => {
    const user = createUserFixture({ id: 1, name: "Иван", email: "ivan@example.com" });
    const mockDeps = createMockDependencies({
      fetchUser: async (id: number) => Promise.resolve(user),
      sendEmail: async (email: string, message: string) => Promise.resolve(true)
    });
    
    const result = await processUser(1, mockDeps);
    expect(result).toBe(true);
  });

  test("processUser должен возвращать false при ошибке отправки email", async () => {
    const user = createUserFixture({ id: 1, name: "Иван", email: "ivan@example.com" });
    const mockDeps = createMockDependencies({
      fetchUser: async (id: number) => Promise.resolve(user),
      sendEmail: async (email: string, message: string) => Promise.resolve(false)
    });
    
    const result = await processUser(1, mockDeps);
    expect(result).toBe(false);
  });
});
```

## Интеграционное тестирование

Интеграционное тестирование проверяет взаимодействие между компонентами.

```typescript
// Модели для интеграционного тестирования
interface Order {
  id: number;
  userId: number;
  items: OrderItem[];
  total: number;
  status: "pending" | "confirmed" | "shipped" | "delivered";
}

interface OrderItem {
  productId: number;
  quantity: number;
  price: number;
}

interface Product {
  id: number;
  name: string;
  price: number;
  inStock: boolean;
}

interface User {
  id: number;
  name: string;
  email: string;
  address: string;
}

// Сервисы
class ProductService {
  private products: Product[] = [];
  
  constructor(products: Product[] = []) {
    this.products = products;
  }
  
  findProduct(id: number): Product | undefined {
    return this.products.find(p => p.id === id);
  }
  
  isProductAvailable(id: number, quantity: number): boolean {
    const product = this.findProduct(id);
    return product ? product.inStock && product.price > 0 : false;
  }
}

class UserService {
  private users: User[] = [];
  
  constructor(users: User[] = []) {
    this.users = users;
  }
  
  findUser(id: number): User | undefined {
    return this.users.find(u => u.id === id);
  }
}

class OrderService {
  private orders: Order[] = [];
  private nextOrderId = 1;
  
  constructor(
    private productService: ProductService,
    private userService: UserService
  ) {}
  
  createOrder(userId: number, items: OrderItem[]): Order | null {
    const user = this.userService.findUser(userId);
    if (!user) {
      return null;
    }
    
    // Проверка доступности продуктов
    for (const item of items) {
      if (!this.productService.isProductAvailable(item.productId, item.quantity)) {
        return null;
      }
    }
    
    // Расчет общей суммы
    const total = items.reduce((sum, item) => {
      const product = this.productService.findProduct(item.productId);
      return sum + (product ? product.price * item.quantity : 0);
    }, 0);
    
    const order: Order = {
      id: this.nextOrderId++,
      userId,
      items,
      total,
      status: "pending"
    };
    
    this.orders.push(order);
    return order;
  }
  
  findOrder(id: number): Order | undefined {
    return this.orders.find(o => o.id === id);
  }
  
  confirmOrder(orderId: number): boolean {
    const order = this.findOrder(orderId);
    if (order && order.status === "pending") {
      order.status = "confirmed";
      return true;
    }
    return false;
  }
}

// Интеграционные тесты
describe("Интеграционное тестирование", () => {
  let productService: ProductService;
  let userService: UserService;
  let orderService: OrderService;
  
  beforeEach(() => {
    const products: Product[] = [
      { id: 1, name: "Ноутбук", price: 50000, inStock: true },
      { id: 2, name: "Смартфон", price: 30000, inStock: true },
      { id: 3, name: "Книга", price: 500, inStock: false }
    ];
    
    const users: User[] = [
      { id: 1, name: "Иван", email: "ivan@example.com", address: "Москва" },
      { id: 2, name: "Мария", email: "maria@example.com", address: "Санкт-Петербург" }
    ];
    
    productService = new ProductService(products);
    userService = new UserService(users);
    orderService = new OrderService(productService, userService);
  });
  
  test("Создание заказа с валидными данными", () => {
    const items: OrderItem[] = [
      { productId: 1, quantity: 1, price: 50000 },
      { productId: 2, quantity: 2, price: 30000 }
    ];
    
    const order = orderService.createOrder(1, items);
    
    expect(order).not.toBeNull();
    expect(order?.id).toBe(1);
    expect(order?.userId).toBe(1);
    expect(order?.total).toBe(110000); // 50000 + 2 * 30000
    expect(order?.status).toBe("pending");
  });
  
  test("Создание заказа с несуществующим пользователем", () => {
    const items: OrderItem[] = [
      { productId: 1, quantity: 1, price: 50000 }
    ];
    
    const order = orderService.createOrder(999, items);
    
    expect(order).toBeNull();
  });
  
  test("Создание заказа с недоступным продуктом", () => {
    const items: OrderItem[] = [
      { productId: 3, quantity: 1, price: 500 } // Книга недоступна
    ];
    
    const order = orderService.createOrder(1, items);
    
    expect(order).toBeNull();
  });
  
  test("Подтверждение заказа", () => {
    const items: OrderItem[] = [
      { productId: 1, quantity: 1, price: 50000 }
    ];
    
    const order = orderService.createOrder(1, items);
    expect(order).not.toBeNull();
    
    const confirmed = orderService.confirmOrder(order!.id);
    expect(confirmed).toBe(true);
    
    const updatedOrder = orderService.findOrder(order!.id);
    expect(updatedOrder?.status).toBe("confirmed");
  });
  
  test("Подтверждение несуществующего заказа", () => {
    const confirmed = orderService.confirmOrder(999);
    expect(confirmed).toBe(false);
  });
});
```

## Лучшие практики

### 1. Тестирование чистых функций

```typescript
// Хорошо: тестируем чистые функции
const calculateDiscount = (price: number, discountPercent: number): number => {
  if (discountPercent < 0 || discountPercent > 100) {
    throw new Error("Процент скидки должен быть от 0 до 100");
  }
  return price * (1 - discountPercent / 100);
};

describe("calculateDiscount", () => {
  test("должен корректно рассчитывать скидку", () => {
    expect(calculateDiscount(100, 10)).toBe(90);
    expect(calculateDiscount(200, 25)).toBe(150);
  });
  
  test("должен возвращать исходную цену при 0% скидки", () => {
    expect(calculateDiscount(100, 0)).toBe(100);
  });
  
  test("должен возвращать 0 при 100% скидки", () => {
    expect(calculateDiscount(100, 100)).toBe(0);
  });
  
  test("должен бросать ошибку при невалидном проценте скидки", () => {
    expect(() => calculateDiscount(100, -10)).toThrow();
    expect(() => calculateDiscount(100, 110)).toThrow();
  });
});
```

### 2. Использование property-based тестирования

```typescript
// Хорошо: использование property-based тестирования
const sortArray = <T>(arr: T[]): T[] => [...arr].sort();

describe("sortArray", () => {
  test("результат всегда отсортирован", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        const sorted = sortArray(arr);
        for (let i = 0; i < sorted.length - 1; i++) {
          expect(sorted[i] <= sorted[i + 1]).toBe(true);
        }
      })
    );
  });
  
  test("результат содержит те же элементы", () => {
    fc.assert(
      fc.property(fc.array(fc.integer()), (arr) => {
        const sorted = sortArray(arr);
        const originalElements = [...arr].sort((a, b) => a - b);
        const sortedElements = [...sorted].sort((a, b) => a - b);
        expect(sortedElements).toEqual(originalElements);
      })
    );
  });
});
```

### 3. Тестирование законов функторов и монад

```typescript
// Хорошо: тестирование законов
describe("Законы функторов", () => {
  test("закон идентичности", () => {
    const identity = <T>(x: T): T => x;
    const functor = MaybeMonad.just(5);
    expect(functor.map(identity).getValue()).toBe(functor.getValue());
  });
  
  test("закон композиции", () => {
    const f = (x: number): number => x + 1;
    const g = (x: number): number => x * 2;
    const functor = MaybeMonad.just(5);
    
    const leftSide = functor.map(f).map(g);
    const rightSide = functor.map(x => g(f(x)));
    
    expect(leftSide.getValue()).toBe(rightSide.getValue());
  });
});
```

### 4. Изоляция побочных эффектов

```typescript
// Хорошо: изоляция побочных эффектов
interface Logger {
  log: (message: string) => void;
}

const processDataWithLogging = (
  data: number[], 
  logger: Logger
): number[] => {
  logger.log(`Обработка ${data.length} элементов`);
  const result = data.map(x => x * 2);
  logger.log(`Обработано ${result.length} элементов`);
  return result;
};

// Тестирование с моком логгера
describe("processDataWithLogging", () => {
  test("должен обрабатывать данные и логгировать", () => {
    const mockLogger: Logger = {
      log: jest.fn()
    };
    
    const data = [1, 2, 3];
    const result = processDataWithLogging(data, mockLogger);
    
    expect(result).toEqual([2, 4, 6]);
    expect(mockLogger.log).toHaveBeenCalledTimes(2);
  });
});
```

## Связи с другими концепциями

- [[ts/functional-programming/Функциональное_программирование|Функциональное программирование]] - Основная страница раздела
- [[ts/functional-programming/pure-functions|Чистые функции]] - Основа для тестируемости
- [[ts/functional-programming/functors-monads|Функторы и монады]] - Концепции, требующие тестирования законов
- [[ts/functional-programming/composition|Композиция функций]] - Тестирование композиции
- [[ts/testing/unit-testing|Модульное тестирование]] - Базовые принципы тестирования
- [[ts/testing/integration-testing|Интеграционное тестирование]] - Тестирование взаимодействия компонентов

## Следующие шаги

- [[ts/testing/unit-testing|Модульное тестирование]] - Подробное изучение модульного тестирования
- [[ts/testing/integration-testing|Интеграционное тестирование]] - Тестирование взаимодействия компонентов
- [[ts/testing/e2e-testing|End-to-end тестирование]] - Тестирование полных сценариев
- [[ts/performance/advanced-performance-optimization|Оптимизация производительности]] - Оптимизация функционального кода
- [[Обработка ошибок в TypeScript|Обработка ошибок]] - Обработка ошибок в функциональном стиле