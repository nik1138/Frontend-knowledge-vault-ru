# Оптимизация производительности в функциональном программировании

Оптимизация производительности в функциональном программировании имеет свои особенности по сравнению с императивным подходом. Хотя функциональное программирование делает упор на неизменяемость и чистые функции, это не означает, что производительность должна страдать. Наоборот, правильное применение функциональных паттернов может привести к более эффективному коду.

## Содержание

1. [Основы производительности в FP](#основы-производительности-в-fp)
2. [Ленивые вычисления](#ленивые-вычисления)
3. [Мемоизация](#мемоизация)
4. [Оптимизация структур данных](#оптимизация-структур-данных)
5. [Параллелизм и конкурентность](#параллелизм-и-конкурентность)
6. [Оптимизация рекурсии](#оптимизация-рекурсии)
7. [Профилирование и измерение](#профилирование-и-измерение)
8. [Практические рекомендации](#практические-рекомендации)

## Основы производительности в FP

Функциональное программирование может показаться менее эффективным из-за неизменяемости, но на практике это не всегда так. Современные JavaScript движки хорошо оптимизированы для работы с функциональными паттернами.

### Преимущества функционального подхода к производительности:

1. **Предсказуемость** - Чистые функции проще оптимизировать и кэшировать
2. **Параллелизм** - Отсутствие изменяемого состояния упрощает параллельные вычисления
3. **Композиция** - Функции можно эффективно комбинировать и переиспользовать
4. **Локальные оптимизации** - Легче находить и оптимизировать узкие места

### Потенциальные проблемы производительности:

1. **Создание новых объектов** - При каждом изменении создается новый объект
2. **Рекурсия** - Может привести к переполнению стека
3. **Ленивые вычисления** - Могут накапливать отложенные операции
4. **Функциональные абстракции** - Могут добавлять накладные расходы

## Ленивые вычисления

Ленивые вычисления позволяют откладывать выполнение операций до тех пор, пока результат действительно не понадобится. Это может значительно улучшить производительность при работе с большими наборами данных.

```typescript
// Простая реализация ленивых вычислений
class Lazy<T> {
  private value: T | undefined;
  private computed = false;
  
  constructor(private computation: () => T) {}
  
  get(): T {
    if (!this.computed) {
      this.value = this.computation();
      this.computed = true;
    }
    return this.value!;
  }
}

// Пример использования
const expensiveComputation = new Lazy(() => {
  console.log("Выполняется дорогостоящая операция...");
  // Симуляция сложных вычислений
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += Math.sqrt(i);
  }
  return result;
});

console.log("Ленивый объект создан");
// Вычисления еще не выполнены

const value1 = expensiveComputation.get(); // Вычисления выполняются здесь
console.log("Значение 1:", value1);

const value2 = expensiveComputation.get(); // Значение берется из кэша
console.log("Значение 2:", value2);
```

### Ленивые последовательности

Ленивые последовательности позволяют работать с потенциально бесконечными наборами данных без их полной материализации.

```typescript
// Ленивый итератор
class LazySequence<T> {
  constructor(private generator: () => Iterator<T>) {}
  
  // Преобразование элементов
  map<U>(fn: (item: T) => U): LazySequence<U> {
    const generator = this.generator;
    return new LazySequence(function* () {
      for (const item of generator()) {
        yield fn(item);
      }
    });
  }
  
  // Фильтрация элементов
  filter(predicate: (item: T) => boolean): LazySequence<T> {
    const generator = this.generator;
    return new LazySequence(function* () {
      for (const item of generator()) {
        if (predicate(item)) {
          yield item;
        }
      }
    });
  }
  
  // Ограничение количества элементов
  take(count: number): LazySequence<T> {
    const generator = this.generator;
    return new LazySequence(function* () {
      let taken = 0;
      for (const item of generator()) {
        if (taken >= count) break;
        yield item;
        taken++;
      }
    });
  }
  
  // Преобразование в массив
  toArray(): T[] {
    const result: T[] = [];
    for (const item of this.generator()) {
      result.push(item);
    }
    return result;
  }
  
  // Выполнение операции для каждого элемента
  forEach(fn: (item: T) => void): void {
    for (const item of this.generator()) {
      fn(item);
    }
  }
}

// Создание ленивой последовательности чисел
function* numberGenerator(start = 0, step = 1) {
  let current = start;
  while (true) {
    yield current;
    current += step;
  }
}

const numbers = new LazySequence(() => numberGenerator(1, 1));

// Композиция операций (выполняется лениво)
const result = numbers
  .filter(x => x % 2 === 0)  // Только четные числа
  .map(x => x * x)           // Квадраты
  .take(5)                   // Первые 5 элементов
  .toArray();                // Материализация

console.log(result); // [4, 16, 36, 64, 100]
```

### Оптимизация ленивых вычислений

Ленивые вычисления требуют особого внимания к производительности, чтобы избежать накопления отложенных операций.

```typescript
// Оптимизированная ленивая последовательность с кэшированием
class OptimizedLazySequence<T> {
  private cache: T[] | null = null;
  private cachePosition = 0;
  
  constructor(private generator: () => Iterator<T>) {}
  
  map<U>(fn: (item: T) => U): OptimizedLazySequence<U> {
    const self = this;
    return new OptimizedLazySequence(function* () {
      // Используем кэш, если он есть
      if (self.cache) {
        for (let i = 0; i < self.cachePosition; i++) {
          yield fn(self.cache[i]);
        }
      }
      
      // Генерируем новые элементы
      const iterator = self.generator();
      let index = self.cachePosition;
      
      while (true) {
        const result = iterator.next();
        if (result.done) break;
        
        const mapped = fn(result.value);
        
        // Кэшируем элемент, если нужно
        if (self.cache) {
          self.cache[index] = result.value;
        }
        
        yield mapped;
        index++;
      }
      
      self.cachePosition = index;
    });
  }
  
  filter(predicate: (item: T) => boolean): OptimizedLazySequence<T> {
    const self = this;
    return new OptimizedLazySequence(function* () {
      const iterator = self[Symbol.iterator]();
      
      for (const item of iterator) {
        if (predicate(item)) {
          yield item;
        }
      }
    });
  }
  
  take(count: number): OptimizedLazySequence<T> {
    const self = this;
    return new OptimizedLazySequence(function* () {
      let taken = 0;
      const iterator = self[Symbol.iterator]();
      
      for (const item of iterator) {
        if (taken >= count) break;
        yield item;
        taken++;
      }
    });
  }
  
  *[Symbol.iterator](): Iterator<T> {
    // Используем кэш, если он есть
    if (this.cache) {
      for (let i = 0; i < this.cachePosition; i++) {
        yield this.cache[i];
      }
    }
    
    // Генерируем новые элементы
    const iterator = this.generator();
    this.cache = this.cache || [];
    
    while (true) {
      const result = iterator.next();
      if (result.done) break;
      
      this.cache[this.cachePosition] = result.value;
      yield result.value;
      this.cachePosition++;
    }
  }
  
  toArray(): T[] {
    if (!this.cache) {
      this.cache = [];
      for (const item of this) {
        // Заполняем кэш
      }
    }
    
    return this.cache.slice(0, this.cachePosition);
  }
}
```

## Мемоизация

Мемоизация - это техника кэширования результатов функций для избежания повторных вычислений с теми же аргументами.

```typescript
// Простая мемоизация для функций с одним аргументом
function memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
  const cache = new Map<T, R>();
  
  return function (arg: T): R {
    if (cache.has(arg)) {
      return cache.get(arg)!;
    }
    
    const result = fn(arg);
    cache.set(arg, result);
    return result;
  };
}

// Пример использования
const expensiveFunction = memoize((n: number): number => {
  console.log(`Вычисление для ${n}`);
  // Симуляция сложных вычислений
  let result = 0;
  for (let i = 0; i < n * 1000000; i++) {
    result += Math.sin(i);
  }
  return result;
});

console.log(expensiveFunction(5)); // Вычисление выполняется
console.log(expensiveFunction(5)); // Результат берется из кэша
console.log(expensiveFunction(10)); // Вычисление выполняется
console.log(expensiveFunction(10)); // Результат берется из кэша
```

### Мемоизация для функций с несколькими аргументами

```typescript
// Мемоизация для функций с несколькими аргументами
function memoizeMulti<T extends any[], R>(fn: (...args: T) => R): (...args: T) => R {
  const cache = new Map<string, R>();
  
  return function (...args: T): R {
    // Создаем ключ из аргументов
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key)!;
    }
    
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Пример использования
const fibonacci = memoizeMulti((n: number): number => {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // Быстро вычисляется благодаря мемоизации
console.log(fibonacci(15)); // Использует кэшированные значения для меньших чисел
```

### Продвинутая мемоизация с LRU кэшем

```typescript
// LRU (Least Recently Used) кэш
class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private readonly maxSize: number;
  
  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }
  
  get(key: K): V | undefined {
    const item = this.cache.get(key);
    if (item) {
      // Перемещаем элемент в конец (самый свежий)
      this.cache.delete(key);
      this.cache.set(key, item);
    }
    return item;
  }
  
  set(key: K, value: V): void {
    // Если ключ уже существует, удаляем его
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    // Если кэш переполнен, удаляем самый старый элемент
    else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    
    this.cache.set(key, value);
  }
  
  size(): number {
    return this.cache.size;
  }
  
  clear(): void {
    this.cache.clear();
  }
}

// Мемоизация с LRU кэшем
function memoizeLRU<T extends any[], R>(fn: (...args: T) => R, maxSize: number): (...args: T) => R {
  const cache = new LRUCache<string, R>(maxSize);
  
  return function (...args: T): R {
    const key = JSON.stringify(args);
    const cached = cache.get(key);
    
    if (cached !== undefined) {
      return cached;
    }
    
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Пример использования
const expensiveCalculation = memoizeLRU((a: number, b: number): number => {
  console.log(`Вычисление для ${a}, ${b}`);
  // Симуляция сложных вычислений
  return a * b + Math.sqrt(a + b);
}, 100); // Максимум 100 элементов в кэше

console.log(expensiveCalculation(5, 3));
console.log(expensiveCalculation(5, 3)); // Из кэша
console.log(expensiveCalculation(10, 7));
```

## Оптимизация структур данных

В функциональном программировании структуры данных часто неизменяемы, но существуют специализированные реализации, оптимизированные для производительности.

### Persistent Data Structures

Persistent data structures сохраняют предыдущие версии при изменении, что идеально подходит для функционального программирования.

```typescript
// Persistent массив с оптимизацией для обновлений
class PersistentArray<T> {
  private readonly data: T[];
  
  constructor(data: T[] = []) {
    this.data = [...data]; // Копируем данные для иммутабельности
  }
  
  get(index: number): T | undefined {
    return this.data[index];
  }
  
  set(index: number, value: T): PersistentArray<T> {
    const newData = [...this.data];
    newData[index] = value;
    return new PersistentArray(newData);
  }
  
  push(value: T): PersistentArray<T> {
    return new PersistentArray([...this.data, value]);
  }
  
  pop(): [T | undefined, PersistentArray<T>] {
    if (this.data.length === 0) {
      return [undefined, this];
    }
    
    const newData = this.data.slice(0, -1);
    const lastElement = this.data[this.data.length - 1];
    return [lastElement, new PersistentArray(newData)];
  }
  
  length(): number {
    return this.data.length;
  }
  
  toArray(): T[] {
    return [...this.data];
  }
  
  // Оптимизированная операция map
  map<U>(fn: (item: T, index: number) => U): PersistentArray<U> {
    const result = new Array<U>(this.data.length);
    for (let i = 0; i < this.data.length; i++) {
      result[i] = fn(this.data[i], i);
    }
    return new PersistentArray(result);
  }
  
  // Оптимизированная операция filter
  filter(predicate: (item: T, index: number) => boolean): PersistentArray<T> {
    const result: T[] = [];
    for (let i = 0; i < this.data.length; i++) {
      if (predicate(this.data[i], i)) {
        result.push(this.data[i]);
      }
    }
    return new PersistentArray(result);
  }
}

// Пример использования
const arr1 = new PersistentArray([1, 2, 3, 4, 5]);
const arr2 = arr1.set(2, 10); // Изменяем элемент по индексу 2
const arr3 = arr2.push(6);     // Добавляем элемент

console.log(arr1.toArray()); // [1, 2, 3, 4, 5] - оригинальный массив не изменился
console.log(arr2.toArray()); // [1, 2, 10, 4, 5] - новая версия
console.log(arr3.toArray()); // [1, 2, 10, 4, 5, 6] - еще одна версия
```

### Trie (Prefix Tree) для оптимизации строковых операций

```typescript
// Trie для эффективной работы со строками
class TrieNode {
  children: Map<string, TrieNode> = new Map();
  isEndOfWord = false;
  count = 0; // Количество слов с этим префиксом
}

class Trie {
  private root = new TrieNode();
  
  insert(word: string): void {
    let current = this.root;
    
    for (const char of word) {
      if (!current.children.has(char)) {
        current.children.set(char, new TrieNode());
      }
      current = current.children.get(char)!;
      current.count++;
    }
    
    current.isEndOfWord = true;
  }
  
  search(word: string): boolean {
    let current = this.root;
    
    for (const char of word) {
      if (!current.children.has(char)) {
        return false;
      }
      current = current.children.get(char)!;
    }
    
    return current.isEndOfWord;
  }
  
  startsWith(prefix: string): boolean {
    let current = this.root;
    
    for (const char of prefix) {
      if (!current.children.has(char)) {
        return false;
      }
      current = current.children.get(char)!;
    }
    
    return true;
  }
  
  // Получение всех слов с заданным префиксом
  getWordsWithPrefix(prefix: string): string[] {
    const result: string[] = [];
    let current = this.root;
    
    // Находим узел для префикса
    for (const char of prefix) {
      if (!current.children.has(char)) {
        return result; // Префикс не найден
      }
      current = current.children.get(char)!;
    }
    
    // Рекурсивно собираем все слова
    this.collectWords(current, prefix, result);
    return result;
  }
  
  private collectWords(node: TrieNode, prefix: string, result: string[]): void {
    if (node.isEndOfWord) {
      result.push(prefix);
    }
    
    for (const [char, childNode] of node.children) {
      this.collectWords(childNode, prefix + char, result);
    }
  }
  
  // Получение количества слов с префиксом
  countWordsWithPrefix(prefix: string): number {
    let current = this.root;
    
    for (const char of prefix) {
      if (!current.children.has(char)) {
        return 0;
      }
      current = current.children.get(char)!;
    }
    
    return current.count;
  }
}

// Пример использования
const trie = new Trie();
const words = ["apple", "app", "application", "apply", "banana", "band", "bandana"];

// Вставка слов
for (const word of words) {
  trie.insert(word);
}

console.log(trie.search("app"));        // true
console.log(trie.search("appl"));       // false
console.log(trie.startsWith("app"));    // true
console.log(trie.startsWith("ban"));    // true
console.log(trie.startsWith("cat"));    // false

console.log(trie.getWordsWithPrefix("app")); // ["app", "apple", "application", "apply"]
console.log(trie.countWordsWithPrefix("ban")); // 3
```

## Параллелизм и конкурентность

Функциональное программирование отлично подходит для параллельных и конкурентных вычислений благодаря отсутствию изменяемого состояния.

### Параллельные вычисления

```typescript
// Future для асинхронных вычислений
class Future<T> {
  private promise: Promise<T>;
  
  constructor(executor: (resolve: (value: T) => void, reject: (reason: any) => void) => void) {
    this.promise = new Promise(executor);
  }
  
  static of<T>(value: T): Future<T> {
    return new Future(resolve => resolve(value));
  }
  
  static reject<T>(reason: any): Future<T> {
    return new Future((_, reject) => reject(reason));
  }
  
  map<U>(fn: (value: T) => U): Future<U> {
    return new Future((resolve, reject) => {
      this.promise.then(
        value => {
          try {
            resolve(fn(value));
          } catch (error) {
            reject(error);
          }
        },
        reject
      );
    });
  }
  
  flatMap<U>(fn: (value: T) => Future<U>): Future<U> {
    return new Future((resolve, reject) => {
      this.promise.then(
        value => fn(value).promise.then(resolve, reject),
        reject
      );
    });
  }
  
  // Параллельная комбинация двух Future
  zip<U>(other: Future<U>): Future<[T, U]> {
    return new Future((resolve, reject) => {
      let value1: T | undefined;
      let value2: U | undefined;
      let resolved1 = false;
      let resolved2 = false;
      
      this.promise.then(
        value => {
          value1 = value;
          resolved1 = true;
          if (resolved2) {
            resolve([value1!, value2!]);
          }
        },
        reject
      );
      
      other.promise.then(
        value => {
          value2 = value;
          resolved2 = true;
          if (resolved1) {
            resolve([value1!, value2!]);
          }
        },
        reject
      );
    });
  }
  
  // Параллельная обработка массива
  static parallel<T>(futures: Future<T>[]): Future<T[]> {
    return new Future((resolve, reject) => {
      const results: T[] = new Array(futures.length);
      let completed = 0;
      let hasError = false;
      
      futures.forEach((future, index) => {
        future.promise.then(
          value => {
            if (hasError) return;
            results[index] = value;
            completed++;
            if (completed === futures.length) {
              resolve(results);
            }
          },
          error => {
            if (hasError) return;
            hasError = true;
            reject(error);
          }
        );
      });
    });
  }
  
  then<U>(onFulfilled?: (value: T) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Promise<U> {
    return this.promise.then(onFulfilled, onRejected);
  }
}

// Пример использования Future для параллельных вычислений
async function exampleParallelComputations() {
  // Создаем несколько асинхронных операций
  const future1 = new Future<number>((resolve) => {
    setTimeout(() => resolve(10), 1000);
  });
  
  const future2 = new Future<number>((resolve) => {
    setTimeout(() => resolve(20), 1500);
  });
  
  const future3 = new Future<number>((resolve) => {
    setTimeout(() => resolve(30), 800);
  });
  
  // Параллельная комбинация
  const combined = future1.zip(future2);
  const [result1, result2] = await combined.then();
  console.log(`Результаты: ${result1}, ${result2}`);
  
  // Параллельная обработка массива
  const allResults = await Future.parallel([future1, future2, future3]).then();
  console.log(`Все результаты: ${allResults}`);
}

// Worker pool для CPU-интенсивных задач
class WorkerPool<T, R> {
  private workers: Worker[] = [];
  private taskQueue: { task: T; resolve: (result: R) => void; reject: (error: any) => void }[] = [];
  private idleWorkers: Worker[] = [];
  
  constructor(
    private workerScript: string,
    private maxWorkers: number = navigator.hardwareConcurrency || 4
  ) {
    this.initializeWorkers();
  }
  
  private initializeWorkers(): void {
    for (let i = 0; i < this.maxWorkers; i++) {
      const worker = new Worker(this.workerScript);
      worker.onmessage = (event) => {
        this.handleWorkerMessage(worker, event);
      };
      this.workers.push(worker);
      this.idleWorkers.push(worker);
      this.processNextTask();
    }
  }
  
  private handleWorkerMessage(worker: Worker, event: MessageEvent): void {
    const { taskId, result, error } = event.data;
    
    if (error) {
      this.rejectTask(taskId, error);
    } else {
      this.resolveTask(taskId, result);
    }
    
    // Возвращаем worker в пул
    this.idleWorkers.push(worker);
    this.processNextTask();
  }
  
  private resolveTask(taskId: number, result: R): void {
    const task = this.taskQueue.find(t => (t as any).taskId === taskId);
    if (task) {
      task.resolve(result);
      this.taskQueue = this.taskQueue.filter(t => (t as any).taskId !== taskId);
    }
  }
  
  private rejectTask(taskId: number, error: any): void {
    const task = this.taskQueue.find(t => (t as any).taskId === taskId);
    if (task) {
      task.reject(error);
      this.taskQueue = this.taskQueue.filter(t => (t as any).taskId !== taskId);
    }
  }
  
  execute(task: T): Promise<R> {
    return new Promise((resolve, reject) => {
      const taskWrapper = { task, resolve, reject };
      (taskWrapper as any).taskId = Date.now() + Math.random();
      this.taskQueue.push(taskWrapper);
      this.processNextTask();
    });
  }
  
  private processNextTask(): void {
    if (this.taskQueue.length === 0 || this.idleWorkers.length === 0) {
      return;
    }
    
    const task = this.taskQueue.shift()!;
    const worker = this.idleWorkers.pop()!;
    
    worker.postMessage({ taskId: (task as any).taskId, task: task.task });
  }
  
  terminate(): void {
    this.workers.forEach(worker => worker.terminate());
  }
}
```

## Оптимизация рекурсии

Рекурсия - важная часть функционального программирования, но без оптимизации она может привести к переполнению стека.

### Tail Call Optimization (TCO)

```typescript
// Рекурсивная функция с хвостовой рекурсией
function factorialTCO(n: number, accumulator: number = 1): number {
  if (n <= 1) {
    return accumulator;
  }
  return factorialTCO(n - 1, n * accumulator);
}

// Пример без хвостовой рекурсии (может привести к переполнению стека)
function factorial(n: number): number {
  if (n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

// Trampoline для оптимизации рекурсии
type Trampoline<T> = { value: T } | { continuation: () => Trampoline<T> };

function done<T>(value: T): Trampoline<T> {
  return { value };
}

function next<T>(continuation: () => Trampoline<T>): Trampoline<T> {
  return { continuation };
}

function trampoline<T>(trampoline: Trampoline<T>): T {
  let current = trampoline;
  
  while (!('value' in current)) {
    current = current.continuation();
  }
  
  return current.value;
}

// Рекурсивная функция с использованием trampoline
function sumRecursive(numbers: number[], index: number = 0, accumulator: number = 0): Trampoline<number> {
  if (index >= numbers.length) {
    return done(accumulator);
  }
  
  return next(() => sumRecursive(numbers, index + 1, accumulator + numbers[index]));
}

// Пример использования
const largeArray = Array.from({ length: 100000 }, (_, i) => i + 1);
const sum = trampoline(sumRecursive(largeArray));
console.log(`Сумма: ${sum}`);
```

### Continuation Passing Style (CPS)

```typescript
// Преобразование в Continuation Passing Style
function factorialCPS(n: number, continuation: (result: number) => void): void {
  if (n <= 1) {
    continuation(1);
    return;
  }
  
  factorialCPS(n - 1, (result) => {
    continuation(n * result);
  });
}

// Пример использования
factorialCPS(5, (result) => {
  console.log(`Факториал: ${result}`);
});

// CPS для массивов
function mapCPS<T, U>(
  array: T[],
  transform: (item: T, continuation: (result: U) => void) => void,
  continuation: (result: U[]) => void
): void {
  if (array.length === 0) {
    continuation([]);
    return;
  }
  
  const [head, ...tail] = array;
  
  transform(head, (transformedHead) => {
    mapCPS(tail, transform, (transformedTail) => {
      continuation([transformedHead, ...transformedTail]);
    });
  });
}

// Пример использования mapCPS
const numbers = [1, 2, 3, 4, 5];
mapCPS(
  numbers,
  (item, cont) => cont(item * item), // Возведение в квадрат
  (result) => console.log(`Квадраты: ${result}`)
);
```

## Профилирование и измерение

Для оптимизации производительности необходимо уметь измерять и профилировать код.

### Инструменты профилирования

```typescript
// Простой профайлер
class Profiler {
  private measurements: Map<string, number[]> = new Map();
  
  start(label: string): void {
    if (!performance) return;
    
    const measurements = this.measurements.get(label) || [];
    measurements.push(performance.now());
    this.measurements.set(label, measurements);
  }
  
  end(label: string): number {
    if (!performance) return 0;
    
    const measurements = this.measurements.get(label);
    if (!measurements || measurements.length === 0) {
      throw new Error(`Нет начального измерения для ${label}`);
    }
    
    const startTime = measurements.pop()!;
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    console.log(`${label}: ${duration.toFixed(2)}ms`);
    return duration;
  }
  
  async timeAsync<T>(label: string, fn: () => Promise<T>): Promise<T> {
    this.start(label);
    try {
      const result = await fn();
      this.end(label);
      return result;
    } catch (error) {
      this.end(label);
      throw error;
    }
  }
  
  time<T>(label: string, fn: () => T): T {
    this.start(label);
    try {
      const result = fn();
      this.end(label);
      return result;
    } catch (error) {
      this.end(label);
      throw error;
    }
  }
  
  getStats(label: string): { min: number; max: number; avg: number; count: number } | null {
    const measurements = this.measurements.get(label);
    if (!measurements || measurements.length === 0) {
      return null;
    }
    
    const durations = measurements.filter((_, i) => i % 2 === 1); // Только завершенные измерения
    if (durations.length === 0) return null;
    
    const min = Math.min(...durations);
    const max = Math.max(...durations);
    const avg = durations.reduce((sum, d) => sum + d, 0) / durations.length;
    
    return { min, max, avg, count: durations.length };
  }
}

// Пример использования профайлера
const profiler = new Profiler();

function expensiveOperation(n: number): number {
  let result = 0;
  for (let i = 0; i < n * 1000000; i++) {
    result += Math.sin(i);
  }
  return result;
}

// Измерение синхронной операции
const result = profiler.time("expensiveOperation", () => expensiveOperation(10));
console.log(`Результат: ${result}`);

// Измерение асинхронной операции
async function asyncOperation(): Promise<string> {
  await new Promise(resolve => setTimeout(resolve, 100));
  return "Готово";
}

profiler.timeAsync("asyncOperation", asyncOperation).then(result => {
  console.log(`Асинхронный результат: ${result}`);
});

// Многократные измерения
for (let i = 0; i < 5; i++) {
  profiler.time("repeatedOperation", () => expensiveOperation(5));
}

// Получение статистики
const stats = profiler.getStats("repeatedOperation");
if (stats) {
  console.log(`Статистика: min=${stats.min.toFixed(2)}ms, max=${stats.max.toFixed(2)}ms, avg=${stats.avg.toFixed(2)}ms`);
}
```

### Memory Profiling

```typescript
// Инструмент для измерения использования памяти
class MemoryProfiler {
  static measureMemory(): { used: number; total: number; percentage: number } | null {
    if (typeof performance === 'undefined' || !performance.memory) {
      return null;
    }
    
    const memory = (performance as any).memory;
    const used = memory.usedJSHeapSize;
    const total = memory.totalJSHeapSize;
    const percentage = (used / total) * 100;
    
    return { used, total, percentage };
  }
  
  static logMemory(label: string): void {
    const memory = MemoryProfiler.measureMemory();
    if (memory) {
      console.log(`${label} - Память: ${Math.round(memory.used / 1024 / 1024)}MB / ${Math.round(memory.total / 1024 / 1024)}MB (${memory.percentage.toFixed(1)}%)`);
    }
  }
  
  static async measureMemoryGrowth<T>(fn: () => T): Promise<{ result: T; growth: number | null }> {
    const before = MemoryProfiler.measureMemory();
    const result = fn();
    const after = MemoryProfiler.measureMemory();
    
    const growth = before && after ? after.used - before.used : null;
    
    return { result, growth };
  }
}

// Пример использования memory profiler
MemoryProfiler.logMemory("Начало");

const largeArray = Array.from({ length: 1000000 }, (_, i) => ({ id: i, value: Math.random() }));
MemoryProfiler.logMemory("После создания большого массива");

largeArray.splice(0, 500000); // Удаляем половину элементов
MemoryProfiler.logMemory("После удаления элементов");

// Force garbage collection if available (for testing purposes)
if ((global as any).gc) {
  (global as any).gc();
  MemoryProfiler.logMemory("После сборки мусора");
}
```

## Практические рекомендации

### Оптимизация функционального кода

1. **Используйте мемоизацию** для чистых функций с дорогими вычислениями
2. **Применяйте ленивые вычисления** для работы с большими наборами данных
3. **Оптимизируйте рекурсию** с помощью хвостовых вызовов или trampoline
4. **Используйте специализированные структуры данных** для конкретных задач
5. **Профилируйте код** перед и после оптимизаций
6. **Избегайте ненужных копирований** данных
7. **Используйте параллелизм** для CPU-интенсивных задач

### Антипаттерны производительности

1. **Избыточная иммутабельность** - Создание новых объектов там, где можно обойтись без этого
2. **Накопление отложенных операций** - Ленивые вычисления без контроля памяти
3. **Неоптимизированная рекурсия** - Рекурсия без хвостовых вызовов
4. **Избыточные абстракции** - Слишком много оберток над простыми операциями
5. **Неправильное использование мемоизации** - Кэширование с неподходящими ключами

Оптимизация производительности в функциональном программировании требует баланса между чистотой кода и эффективностью выполнения. Следуя этим принципам и используя подходящие инструменты, можно создавать как чистый, так и производительный код.