---
aliases: ["Behavioral Patterns", "Поведенческие Паттерны"]
tags: ["#typescript", "#design-patterns", "#behavioral-patterns", "#programming"]
---

# Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны связаны с алгоритмами и распределением обязанностей между объектами. Они определяют, как объекты взаимодействуют друг с другом, и как распределяются обязанности между ними. Эти паттерны описывают сложные контрольные структуры, которые реализуют поведение между объектами и обеспечивают гибкость в выполнении этих взаимодействий.

## Содержание
- [[#Chain of Responsibility|Chain of Responsibility]]
- [[#Command|Command]]
- [[#Iterator|Iterator]]
- [[#Mediator|Mediator]]
- [[#Memento|Memento]]
- [[#Observer|Observer]]
- [[#State|State]]
- [[#Strategy|Strategy]]
- [[#Template Method|Template Method]]
- [[#Visitor|Visitor]]

## Chain of Responsibility

Chain of Responsibility позволяет передавать запросы последовательно по цепочке обработчиков. При получении запроса каждый обработчик решает, обработать ли ему запрос или передать его следующему обработчику в цепочке.

```typescript
abstract class Handler {
    protected nextHandler: Handler | null = null;

    public setNext(handler: Handler): Handler {
        this.nextHandler = handler;
        return handler;
    }

    public handle(request: string): string | null {
        if (this.nextHandler) {
            return this.nextHandler.handle(request);
        }
        return null;
    }
}

class ConcreteHandlerA extends Handler {
    public handle(request: string): string | null {
        if (request === "A") {
            return `Обработчик A: Обработка запроса ${request}`;
        }
        return super.handle(request);
    }
}

class ConcreteHandlerB extends Handler {
    public handle(request: string): string | null {
        if (request === "B") {
            return `Обработчик B: Обработка запроса ${request}`;
        }
        return super.handle(request);
    }
}

// Использование
const handlerA = new ConcreteHandlerA();
const handlerB = new ConcreteHandlerB();

handlerA.setNext(handlerB);

console.log(handlerA.handle("A")); // Обработчик A: Обработка запроса A
console.log(handlerA.handle("B")); // Обработчик B: Обработка запроса B
console.log(handlerA.handle("C")); // null
```

## Command

Command превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить в очередь, логировать и поддерживать отмену операций.

```typescript
interface Command {
    execute(): void;
    undo?(): void;
}

class Receiver {
    public doSomething(data: string): void {
        console.log(`Получатель: Выполняю "${data}"`);
    }

    public undoSomething(data: string): void {
        console.log(`Получатель: Отменяю "${data}"`);
    }
}

class SimpleCommand implements Command {
    private payload: string;

    constructor(payload: string) {
        this.payload = payload;
    }

    public execute(): void {
        console.log(`Простая команда: Я могу выполнить "${this.payload}"`);
    }
}

class ComplexCommand implements Command {
    private receiver: Receiver;
    private a: string;
    private b: string;

    constructor(receiver: Receiver, a: string, b: string) {
        this.receiver = receiver;
        this.a = a;
        this.b = b;
    }

    public execute(): void {
        console.log("Сложная команда: Выполняю сложную операцию");
        this.receiver.doSomething(this.a);
        this.receiver.doSomething(this.b);
    }

    public undo?(): void {
        console.log("Сложная команда: Отменяю сложную операцию");
        this.receiver.undoSomething(this.b);
        this.receiver.undoSomething(this.a);
    }
}

class Invoker {
    private onStart: Command | null = null;
    private onFinish: Command | null = null;

    public setOnStart(command: Command): void {
        this.onStart = command;
    }

    public setOnFinish(command: Command): void {
        this.onFinish = command;
    }

    public doSomethingImportant(): void {
        console.log("Инициатор: Выполняю команду в начале...");
        if (this.isCommand(this.onStart)) {
            this.onStart.execute();
        }

        console.log("Инициатор: Выполняю команду в конце...");
        if (this.isCommand(this.onFinish)) {
            this.onFinish.execute();
        }
    }

    private isCommand(object: any): object is Command {
        return object.execute !== undefined;
    }
}

// Использование
const invoker = new Invoker();
invoker.setOnStart(new SimpleCommand("Say Hi!"));
const receiver = new Receiver();
invoker.setOnFinish(new ComplexCommand(receiver, "Send email", "Save report"));

invoker.doSomethingImportant();
```

## Iterator

Iterator предоставляет способ последовательного доступа к элементам коллекции без раскрытия её внутреннего представления. Это позволяет обходить коллекции разными способами без изменения кода коллекции.

```typescript
interface Iterator<T> {
    current(): T;
    next(): T;
    hasNext(): boolean;
    reset(): void;
}

interface Aggregator<T> {
    getIterator(): Iterator<T>;
}

class WordsCollection implements Aggregator<string> {
    private items: string[] = [];

    public getItems(): string[] {
        return this.items;
    }

    public addItem(item: string): void {
        this.items.push(item);
    }

    public getIterator(): AlphabeticalOrderIterator {
        return new AlphabeticalOrderIterator(this);
    }

    public getReverseIterator(): AlphabeticalOrderIterator {
        return new AlphabeticalOrderIterator(this, true);
    }
}

class AlphabeticalOrderIterator implements Iterator<string> {
    private collection: WordsCollection;
    private reverse: boolean = false;
    private position: number = 0;

    constructor(collection: WordsCollection, reverse: boolean = false) {
        this.collection = collection;
        this.reverse = reverse;

        if (reverse) {
            this.position = collection.getItems().length - 1;
        }
    }

    public reset(): void {
        this.position = this.reverse ?
            this.collection.getItems().length - 1 :
            0;
    }

    public hasNext(): boolean {
        return this.reverse ?
            this.position >= 0 :
            this.position < this.collection.getItems().length;
    }

    public next(): string {
        const items = this.collection.getItems();
        const item = items[this.position];
        this.position = this.reverse ? this.position - 1 : this.position + 1;
        return item;
    }

    public current(): string {
        const items = this.collection.getItems();
        return items[this.position];
    }
}

// Использование
const collection = new WordsCollection();
collection.addItem("First");
collection.addItem("Second");
collection.addItem("Third");

const iterator = collection.getIterator();
console.log("По порядку:");
while (iterator.hasNext()) {
    console.log(iterator.next());
}

const reverseIterator = collection.getReverseIterator();
console.log("\nВ обратном порядке:");
while (reverseIterator.hasNext()) {
    console.log(reverseIterator.next());
}
```

## Mediator

Mediator определяет объект, инкапсулирующий способ взаимодействия множества объектов. Он позволяет избежать явных зависимостей между объектами, позволяя изменять взаимодействие между ними независимо.

```typescript
interface Mediator {
    notify(sender: object, event: string): void;
}

class BaseComponent {
    protected mediator: Mediator | null = null;

    constructor(mediator: Mediator | null = null) {
        this.mediator = mediator;
    }

    public setMediator(mediator: Mediator): void {
        this.mediator = mediator;
    }
}

class Component1 extends BaseComponent {
    public doA(): void {
        console.log('Компонент 1: Выполняю A.');
        this.mediator?.notify(this, 'A');
    }

    public doB(): void {
        console.log('Компонент 1: Выполняю B.');
        this.mediator?.notify(this, 'B');
    }
}

class Component2 extends BaseComponent {
    public doC(): void {
        console.log('Компонент 2: Выполняю C.');
        this.mediator?.notify(this, 'C');
    }

    public doD(): void {
        console.log('Компонент 2: Выполняю D.');
        this.mediator?.notify(this, 'D');
    }
}

class ConcreteMediator implements Mediator {
    private component1: Component1;
    private component2: Component2;

    constructor(c1: Component1, c2: Component2) {
        this.component1 = c1;
        this.component1.setMediator(this);
        this.component2 = c2;
        this.component2.setMediator(this);
    }

    public notify(sender: object, event: string): void {
        if (event === 'A') {
            console.log('Посредник: Реагирую на A и запускаю следующие операции:');
            this.component2.doC();
        }

        if (event === 'D') {
            console.log('Посредник: Реагирую на D и запускаю следующие операции:');
            this.component1.doB();
            this.component2.doC();
        }
    }
}

// Использование
const c1 = new Component1();
const c2 = new Component2();
const mediator = new ConcreteMediator(c1, c2);

console.log('Клиент запускает операцию A:');
c1.doA();

console.log('\nКлиент запускает операцию D:');
c2.doD();
```

## Memento

Memento позволяет сохранять и восстанавливать предыдущее состояние объекта без раскрытия его внутреннего представления. Это особенно полезно для реализации функций отмены/повтора.

```typescript
class Memento {
    private state: string;

    constructor(state: string) {
        this.state = state;
    }

    public getState(): string {
        return this.state;
    }

    public getName(): string {
        return `${this.state}_${new Date().getTime()}`;
    }

    public getDate(): string {
        return new Date().toISOString().slice(0, 19).replace('T', ' ');
    }
}

class Originator {
    private state: string;

    constructor(state: string) {
        this.state = state;
        console.log(`Создатель: Изначальное состояние: ${state}`);
    }

    public doSomething(): void {
        console.log('Создатель: Выполняю какую-то важную работу...');
        this.state = this.generateRandomString(30);
        console.log(`Создатель: Состояние изменено на: ${this.state}`);
    }

    private generateRandomString(length: number = 10): string {
        const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    public save(): Memento {
        return new Memento(this.state);
    }

    public restore(memento: Memento): void {
        this.state = memento.getState();
        console.log(`Создатель: Состояние восстановлено до: ${this.state}`);
    }
}

class Caretaker {
    private mementos: Memento[] = [];
    private originator: Originator;

    constructor(originator: Originator) {
        this.originator = originator;
    }

    public backup(): void {
        console.log('\nОпекун: Сохраняю состояние создателя...');
        this.mementos.push(this.originator.save());
    }

    public undo(): void {
        if (!this.mementos.length) {
            return;
        }
        const memento = this.mementos.pop();

        console.log(`Опекун: Восстанавливаю состояние до: ${memento?.getName()}`);
        if (memento) {
            this.originator.restore(memento);
        }
    }

    public showHistory(): void {
        console.log('Опекун: Список сохранений:');
        for (const memento of this.mementos) {
            console.log(memento.getName());
        }
    }
}

// Использование
const originator = new Originator('Супер-песня');
const caretaker = new Caretaker(originator);

caretaker.backup();
originator.doSomething();

caretaker.backup();
originator.doSomething();

caretaker.backup();
originator.doSomething();

console.log('');
caretaker.showHistory();

console.log('\nКлиент: Откатываю операцию!');
caretaker.undo();

console.log('\nКлиент: Еще раз откатываю операцию!');
caretaker.undo();

console.log('\nКлиент: Один раз вперед!');
caretaker.backup();
originator.doSomething();
```

## Observer

Observer определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются автоматически. Это паттерн часто используется в архитектуре Model-View.

```typescript
interface Observer {
    update(subject: Subject): void;
}

interface Subject {
    attach(observer: Observer): void;
    detach(observer: Observer): void;
    notify(): void;
}

class NewsAgency implements Subject {
    private observers: Observer[] = [];
    private news: string = '';

    public getNews(): string {
        return this.news;
    }

    public setNews(news: string): void {
        this.news = news;
        this.notify();
    }

    public attach(observer: Observer): void {
        const isExist = this.observers.includes(observer);
        if (isExist) {
            return console.log('Наблюдатель уже подписан на новости.');
        }

        this.observers.push(observer);
        console.log('Новостное агентство: Подписан новый наблюдатель.');
    }

    public detach(observer: Observer): void {
        const observerIndex = this.observers.indexOf(observer);
        if (observerIndex === -1) {
            return console.log('Наблюдатель не найден.');
        }

        this.observers.splice(observerIndex, 1);
        console.log('Новостное агентство: Отписан наблюдатель.');
    }

    public notify(): void {
        console.log('Новостное агентство: Уведомляю наблюдателей...');
        for (const observer of this.observers) {
            observer.update(this);
        }
    }
}

class NewsChannel implements Observer {
    private news: string = '';

    public update(subject: Subject): void {
        if (subject instanceof NewsAgency) {
            this.news = subject.getNews();
            console.log(`Канал новостей: Получена новая новость - ${this.news}`);
        }
    }
}

// Использование
const agency = new NewsAgency();
const channel1 = new NewsChannel();
const channel2 = new NewsChannel();

agency.attach(channel1);
agency.attach(channel2);

agency.setNews('Новости дня: TypeScript стал еще лучше!');
```

## State

State позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Это паттерн делегирует поведение объекту, представляющему текущее состояние, и позволяет легко переключаться между различными состояниями.

```typescript
interface State {
    doAction(context: Context): void;
}

class StartState implements State {
    public doAction(context: Context): void {
        console.log('Установлено стартовое состояние');
        context.setState(this);
    }

    public toString(): string {
        return 'Стартовое состояние';
    }
}

class StopState implements State {
    public doAction(context: Context): void {
        console.log('Установлено стоп-состояние');
        context.setState(this);
    }

    public toString(): string {
        return 'Стоп-состояние';
    }
}

class Context {
    private state: State | null = null;

    public setState(state: State): void {
        this.state = state;
    }

    public getState(): State | null {
        return this.state;
    }

    public doAction(): void {
        if (this.state) {
            this.state.doAction(this);
        }
    }
}

// Использование
const context = new Context();

const startState = new StartState();
startState.doAction(context);

const stopState = new StopState();
stopState.doAction(context);
```

## Strategy

Strategy определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Это позволяет выбирать алгоритм во время выполнения программы, не изменяя классы, которые его используют.

```typescript
interface Strategy {
    execute(data: string[]): string[];
}

class ConcreteStrategyA implements Strategy {
    public execute(data: string[]): string[] {
        return data.sort();
    }
}

class ConcreteStrategyB implements Strategy {
    public execute(data: string[]): string[] {
        return data.reverse();
    }
}

class Context {
    private strategy: Strategy;

    constructor(strategy: Strategy) {
        this.strategy = strategy;
    }

    public setStrategy(strategy: Strategy): void {
        this.strategy = strategy;
    }

    public executeStrategy(data: string[]): string[] {
        return this.strategy.execute(data);
    }
}

// Использование
const data = ['banana', 'apple', 'orange', 'grape'];

const context = new Context(new ConcreteStrategyA());
console.log('Отсортированные данные:', context.executeStrategy(data));

context.setStrategy(new ConcreteStrategyB());
console.log('Обратный порядок:', context.executeStrategy([...data]));
```

## Template Method

Template Method определяет скелет алгоритма в суперклассе, позволяя подклассам переопределять отдельные шаги алгоритма без изменения его структуры. Это позволяет определять общую структуру алгоритма в одном месте, а специфичные реализации выносить в подклассы.

```typescript
abstract class GameTemplate {
    public play(): void {
        this.initialize();
        this.startPlay();
        this.endPlay();
    }

    protected initialize(): void {
        console.log('Игра инициализируется... Установка доски, фигур и т.д.');
    }

    protected startPlay(): void {
        console.log('Игра начинается... Первый ход.');
    }

    protected endPlay(): void {
        console.log('Игра завершена... Подсчет очков и объявление победителя.');
    }

    // Абстрактные методы, которые должны быть реализованы подклассами
    protected abstract getGameName(): string;
}

class Chess extends GameTemplate {
    protected getGameName(): string {
        return 'Шахматы';
    }

    protected startPlay(): void {
        console.log('Шахматы начинаются... Расстановка фигур на доске.');
    }
}

class Ludo extends GameTemplate {
    protected getGameName(): string {
        return 'Лудо';
    }

    protected startPlay(): void {
        console.log('Лудо начинается... Бросок костей.');
    }
}

// Использование
const chess = new Chess();
chess.play();

console.log('\n');

const ludo = new Ludo();
ludo.play();
```

## Visitor

Visitor позволяет определять новую операцию без изменения классов объектов, над которыми она выполняется. Это особенно полезно, когда нужно выполнить операцию над сложной структурой объектов разных типов.

```typescript
interface Visitor {
    visitElementA(element: ElementA): void;
    visitElementB(element: ElementB): void;
}

interface Element {
    accept(visitor: Visitor): void;
}

class ElementA implements Element {
    public name: string = 'Элемент A';

    public accept(visitor: Visitor): void {
        visitor.visitElementA(this);
    }

    public exclusiveMethodOfA(): string {
        return 'A';
    }
}

class ElementB implements Element {
    public name: string = 'Элемент B';

    public accept(visitor: Visitor): void {
        visitor.visitElementB(this);
    }

    public specialMethodOfB(): string {
        return 'B';
    }
}

class ConcreteVisitor1 implements Visitor {
    public visitElementA(element: ElementA): void {
        console.log(`${element.name} посещен ConcreteVisitor1`);
    }

    public visitElementB(element: ElementB): void {
        console.log(`${element.name} посещен ConcreteVisitor1`);
    }
}

class ConcreteVisitor2 implements Visitor {
    public visitElementA(element: ElementA): void {
        console.log(`${element.name} посещен ConcreteVisitor2`);
        console.log(element.exclusiveMethodOfA());
    }

    public visitElementB(element: ElementB): void {
        console.log(`${element.name} посещен ConcreteVisitor2`);
        console.log(element.specialMethodOfB());
    }
}

function clientCode(elements: Element[], visitor: Visitor): void {
    for (const element of elements) {
        element.accept(visitor);
    }
}

// Использование
const elements = [new ElementA(), new ElementB()];
const visitor1 = new ConcreteVisitor1();
clientCode(elements, visitor1);

console.log('\n');

const visitor2 = new ConcreteVisitor2();
clientCode(elements, visitor2);
```

> [!tip] Совет
> Поведенческие паттерны особенно полезны при проектировании сложных систем, где взаимодействие между объектами играет ключевую роль. Использование этих паттернов позволяет создавать более гибкие и расширяемые архитектуры.

## Заключение

Поведенческие паттерны обеспечивают гибкость в реализации взаимодействий между объектами, позволяя изменять поведение системы без изменения структуры классов. Они помогают создавать системы с понятной архитектурой и легким сопровождением.

Для более глубокого понимания рекомендуется изучить:
- [[Порождающие-паттерны]]
- [[Структурные-паттерны]]
- [[Архитектурные-паттерны]]