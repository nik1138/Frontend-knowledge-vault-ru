---
aliases: ["Functional Patterns", "Функциональные Паттерны"]
tags: ["#typescript", "#functional-programming", "#design-patterns", "#functional-patterns", "#programming"]
---

# Функциональные паттерны (Functional Patterns)

Функциональные паттерны - это подходы к программированию, основанные на использовании функций как основных строительных блоков приложения. В функциональном программировании акцент делается на использование неизменяемых данных, чистых функций и функций высшего порядка. Эти паттерны помогают создавать более предсказуемые, тестируемые и надежные приложения.

## Содержание
- [[#Pure Functions|Pure Functions]]
- [[#Immutability|Immutability]]
- [[#Higher-Order Functions|Higher-Order Functions]]
- [[#Currying|Currying]]
- [[#Composition|Composition]]
- [[#Monads|Monads]]
- [[#Functors|Functors]]
- [[#Memoization|Memoization]]
- [[#Partial Application|Partial Application]]
- [[#Function Pipelines|Function Pipelines]]

## Pure Functions

Чистые функции (Pure Functions) - это функции, которые при одинаковых входных данных всегда возвращают одинаковый результат и не имеют побочных эффектов. Они не изменяют внешнее состояние и не зависят от внешнего состояния.

```typescript
// Чистая функция
function add(a: number, b: number): number {
    return a + b;
}

// Чистая функция
function multiply(x: number, y: number): number {
    return x * y;
}

// Чистая функция для вычисления площади круга
function circleArea(radius: number): number {
    const pi = 3.14159;
    return pi * radius * radius;
}

// Нечистая функция (имеет побочный эффект)
let globalCounter = 0;
function incrementWithSideEffect(): number {
    globalCounter++; // Изменение внешнего состояния
    return globalCounter;
}

// Нечистая функция (зависит от внешнего состояния)
function getCurrentTime(): number {
    return Date.now(); // Возвращает разные значения при каждом вызове
}

// Пример чистой функции для работы с массивами
function doubleArray(numbers: number[]): number[] {
    return numbers.map(n => n * 2);
}

// Использование
console.log(add(2, 3)); // 5
console.log(circleArea(5)); // 78.53975
console.log(doubleArray([1, 2, 3, 4])); // [2, 4, 6, 8]
```

> [!tip] Совет
> Чистые функции легче тестировать, отлаживать и понимать, потому что они не зависят от внешнего состояния и не создают побочных эффектов.

## Immutability

Неизменяемость (Immutability) означает, что данные не могут быть изменены после создания. Вместо изменения существующих данных создаются новые объекты с обновленным состоянием.

```typescript
// Пример неизменяемого объекта
interface User {
    readonly id: number;
    readonly name: string;
    readonly email: string;
}

function createUser(id: number, name: string, email: string): User {
    return Object.freeze({
        id,
        name,
        email
    });
}

// Функция для обновления пользователя (создает новый объект)
function updateUser(user: User, updates: Partial<User>): User {
    return Object.freeze({
        ...user,
        ...updates
    });
}

// Пример неизменяемого массива
function addElement<T>(array: readonly T[], element: T): readonly T[] {
    return [...array, element];
}

function removeElement<T>(array: readonly T[], index: number): readonly T[] {
    return [
        ...array.slice(0, index),
        ...array.slice(index + 1)
    ];
}

// Пример использования
const user = createUser(1, "Мария", "maria@example.com");
const updatedUser = updateUser(user, { name: "Мария Иванова" });

const numbers = [1, 2, 3, 4, 5] as const;
const newNumbers = addElement(numbers, 6);
const removedNumbers = removeElement(newNumbers, 0);

console.log(user); // { id: 1, name: 'Мария', email: 'maria@example.com' }
console.log(updatedUser); // { id: 1, name: 'Мария Иванова', email: 'maria@example.com' }
console.log(numbers); // [1, 2, 3, 4, 5]
console.log(newNumbers); // [1, 2, 3, 4, 5, 6]
console.log(removedNumbers); // [2, 3, 4, 5, 6]
```

## Higher-Order Functions

Функции высшего порядка (Higher-Order Functions) - это функции, которые принимают другие функции в качестве аргументов или возвращают функции. Они позволяют создавать более абстрактный и повторно используемый код.

```typescript
// Функция, принимающая другую функцию
function executeWithLogging<T>(fn: (arg: T) => T, arg: T): T {
    console.log(`Вызов функции с аргументом: ${arg}`);
    const result = fn(arg);
    console.log(`Результат: ${result}`);
    return result;
}

// Функция, возвращающая другую функцию
function createMultiplier(factor: number): (value: number) => number {
    return function(value: number): number {
        return value * factor;
    };
}

// Функция, возвращающая другую функцию (стрелочная функция)
const createAdder = (increment: number) => (value: number) => value + increment;

// Функция, принимающая и возвращающая функцию
function compose<T, U, V>(f: (arg: U) => V, g: (arg: T) => U): (arg: T) => V {
    return (x: T) => f(g(x));
}

// Использование
const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12

const addFive = createAdder(5);
console.log(addFive(10)); // 15

// Использование функции с логированием
const square = (x: number) => x * x;
executeWithLogging(square, 4); // Логирует процесс и возвращает 16

// Композиция функций
const addOne = (x: number) => x + 1;
const multiplyByTwo = (x: number) => x * 2;
const addOneThenDouble = compose(multiplyByTwo, addOne);

console.log(addOneThenDouble(5)); // 12 (5 + 1 = 6, 6 * 2 = 12)
```

## Currying

Каррирование (Currying) - это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.

```typescript
// Функция без каррирования
function multiplyNormal(x: number, y: number, z: number): number {
    return x * y * z;
}

// Каррированная версия той же функции
function multiplyCurried(x: number): (y: number) => (z: number) => number {
    return function(y: number) {
        return function(z: number): number {
            return x * y * z;
        };
    };
}

// Более универсальная реализация каррирования
function curry<T, U, V>(fn: (a: T, b: U) => V): (a: T) => (b: U) => V {
    return (a: T) => (b: U) => fn(a, b);
}

// Каррирование для функции с тремя аргументами
function curry3<A, B, C, R>(fn: (a: A, b: B, c: C) => R): (a: A) => (b: B) => (c: C) => R {
    return (a: A) => (b: B) => (c: C) => fn(a, b, c);
}

// Пример использования
const curriedMultiply = multiplyCurried(2);
const multiplyBy2 = curriedMultiply(3); // Умножение на 2 и 3
const result = multiplyBy2(4); // 2 * 3 * 4 = 24
console.log(result); // 24

// Использование универсального каррирования
const add = (a: number, b: number) => a + b;
const curriedAdd = curry(add);
const addFive = curriedAdd(5);
console.log(addFive(3)); // 8

// Каррирование для функции с тремя аргументами
const formatAddress = (street: string, city: string, country: string) => 
    `${street}, ${city}, ${country}`;
    
const curriedFormatAddress = curry3(formatAddress);
const addressInUSA = curriedFormatAddress("123 Main St")( "New York");
console.log(addressInUSA("USA")); // "123 Main St, New York, USA"

// Практический пример: фильтрация с каррированием
const filterBy = curry3(<T>(predicate: (item: T, condition: any) => boolean, condition: any, items: T[]) => 
    items.filter(item => predicate(item, condition)));

const isGreaterThan = (item: number, threshold: number) => item > threshold;
const filterGreaterThan = filterBy(isGreaterThan);
const numbers = [1, 5, 8, 10, 15];

console.log(filterGreaterThan(7, numbers)); // [8, 10, 15]
```

## Composition

Композиция функций - это техника объединения двух или более функций для создания новой функции. Результат одной функции передается в качестве аргумента следующей функции.

```typescript
// Простая композиция двух функций
function compose2<A, B, C>(f: (b: B) => C, g: (a: A) => B): (a: A) => C {
    return (x: A) => f(g(x));
}

// Композиция нескольких функций
function composeMany<T>(...fns: Array<(arg: any) => any>): (arg: T) => any {
    return (arg: T) => fns.reduceRight((acc, fn) => fn(acc), arg);
}

// Примеры функций для композиции
const toUpperCase = (str: string) => str.toUpperCase();
const addExclamation = (str: string) => `${str}!`;
const emphasize = (str: string) => `***${str}***`;

// Композиция нескольких функций
const transformString = composeMany(emphasize, addExclamation, toUpperCase);

console.log(transformString("hello")); // "***HELLO!***"

// Практический пример: обработка данных пользователя
interface UserData {
    name: string;
    email: string;
    age: number;
}

interface ProcessedUser {
    name: string;
    email: string;
    isAdult: boolean;
    emailDomain: string;
}

const extractDomain = (email: string) => email.split('@')[1];
const isAdult = (age: number) => age >= 18;

// Функции для преобразования
const validateUser = (user: UserData) => {
    if (!user.name || !user.email || user.age < 0) {
        throw new Error("Неверные данные пользователя");
    }
    return user;
};

const processUser = (user: UserData): ProcessedUser => ({
    name: user.name,
    email: user.email,
    isAdult: isAdult(user.age),
    emailDomain: extractDomain(user.email)
});

const formatUserName = (user: ProcessedUser): ProcessedUser => ({
    ...user,
    name: user.name.toUpperCase()
});

// Композиция функций обработки пользователя
const processUserData = composeMany(formatUserName, processUser, validateUser);

try {
    const user: UserData = { name: "иван", email: "ivan@example.com", age: 25 };
    const processed = processUserData(user);
    console.log(processed);
    // { name: 'ИВАН', email: 'ivan@example.com', isAdult: true, emailDomain: 'example.com' }
} catch (error) {
    console.error("Ошибка обработки:", error);
}

// Функция для цепочки вызовов (pipe)
function pipe<A, B, C, D>(f: (a: A) => B, g: (b: B) => C, h: (c: C) => D): (a: A) => D {
    return (x: A) => h(g(f(x)));
}

// Использование pipe (обратный порядок выполнения по сравнению с compose)
const processWithPipe = pipe(
    validateUser,
    processUser,
    formatUserName
);

const processedWithPipe = processWithPipe(user);
console.log(processedWithPipe);
```

## Monads

Монады - это паттерн, который позволяет обрабатывать вычисления с побочными эффектами, такими как обработка ошибок, асинхронные операции или работа с неопределенными значениями, в функциональном стиле.

```typescript
// Простая реализация Maybe монады
interface Maybe<T> {
    isNothing(): boolean;
    isJust(): boolean;
    map<U>(fn: (value: T) => U): Maybe<U>;
    flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U>;
    getOrElse(defaultValue: T): T;
}

class Just<T> implements Maybe<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    isNothing(): boolean {
        return false;
    }

    isJust(): boolean {
        return true;
    }

    map<U>(fn: (value: T) => U): Maybe<U> {
        return new Just(fn(this.value));
    }

    flatMap<U>(fn: (value: T) => Maybe<U>): Maybe<U> {
        return fn(this.value);
    }

    getOrElse(_defaultValue: T): T {
        return this.value;
    }
}

class Nothing<T> implements Maybe<T> {
    isNothing(): boolean {
        return true;
    }

    isJust(): boolean {
        return false;
    }

    map<U>(_fn: (value: T) => U): Maybe<U> {
        return new Nothing<U>();
    }

    flatMap<U>(_fn: (value: T) => Maybe<U>): Maybe<U> {
        return new Nothing<U>();
    }

    getOrElse(defaultValue: T): T {
        return defaultValue;
    }
}

// Функция для создания Maybe
function maybe<T>(value: T | null | undefined): Maybe<T> {
    return value == null ? new Nothing<T>() : new Just(value);
}

// Пример использования Maybe монады
const divide = (a: number, b: number): Maybe<number> => {
    return b === 0 ? new Nothing<number>() : new Just(a / b);
};

const result1 = maybe(10)
    .flatMap(x => divide(x, 2))
    .map(x => x * 3)
    .getOrElse(0);

console.log(result1); // 15 (10 / 2 = 5, 5 * 3 = 15)

const result2 = maybe(10)
    .flatMap(x => divide(x, 0)) // Деление на 0, возвращает Nothing
    .map(x => x * 3)
    .getOrElse(0);

console.log(result2); // 0 (так как деление на 0 невозможно)

// Either монада для обработки ошибок
interface Either<L, R> {
    isLeft(): boolean;
    isRight(): boolean;
    map<U>(fn: (value: R) => U): Either<L, U>;
    flatMap<U>(fn: (value: R) => Either<L, U>): Either<L, U>;
    mapLeft<M>(fn: (value: L) => M): Either<M, R>;
    getOrElse(defaultValue: R): R;
    getLeft(): L | null;
    getRight(): R | null;
}

class Left<L, R> implements Either<L, R> {
    private value: L;

    constructor(value: L) {
        this.value = value;
    }

    isLeft(): boolean {
        return true;
    }

    isRight(): boolean {
        return false;
    }

    map<U>(_fn: (value: R) => U): Either<L, U> {
        return new Left<L, U>(this.value);
    }

    flatMap<U>(_fn: (value: R) => Either<L, U>): Either<L, U> {
        return new Left<L, U>(this.value);
    }

    mapLeft<M>(fn: (value: L) => M): Either<M, R> {
        return new Left<M, R>(fn(this.value));
    }

    getOrElse(_defaultValue: R): R {
        return _defaultValue;
    }

    getLeft(): L {
        return this.value;
    }

    getRight(): R | null {
        return null;
    }
}

class Right<L, R> implements Either<L, R> {
    private value: R;

    constructor(value: R) {
        this.value = value;
    }

    isLeft(): boolean {
        return false;
    }

    isRight(): boolean {
        return true;
    }

    map<U>(fn: (value: R) => U): Either<L, U> {
        return new Right<L, U>(fn(this.value));
    }

    flatMap<U>(fn: (value: R) => Either<L, U>): Either<L, U> {
        return fn(this.value);
    }

    mapLeft<M>(_fn: (value: L) => M): Either<M, R> {
        return new Right<M, R>(this.value);
    }

    getOrElse(_defaultValue: R): R {
        return this.value;
    }

    getLeft(): L | null {
        return null;
    }

    getRight(): R {
        return this.value;
    }
}

// Функция для безопасного деления с возвратом Either
function safeDivide(a: number, b: number): Either<string, number> {
    if (b === 0) {
        return new Left("Деление на ноль невозможно");
    }
    return new Right(a / b);
}

// Использование Either монады
const eitherResult1 = safeDivide(10, 2)
    .map(x => x * 3)
    .getOrElse(0);

console.log(eitherResult1); // 15

const eitherResult2 = safeDivide(10, 0)
    .map(x => x * 3)
    .mapLeft(error => console.log("Ошибка:", error))
    .getOrElse(0);

console.log(eitherResult2); // 0
```

## Functors

Функторы - это структуры данных, которые можно "отобразить" с помощью функции, применяя функцию к каждому элементу внутри структуры, сохраняя при этом структуру.

```typescript
// Интерфейс функтора
interface Functor<T> {
    map<U>(fn: (value: T) => U): Functor<U>;
}

// Класс-функтор для массива
class ArrayFunctor<T> implements Functor<T> {
    private values: T[];

    constructor(values: T[]) {
        this.values = [...values]; // Неизменяемая копия
    }

    map<U>(fn: (value: T) => U): ArrayFunctor<U> {
        return new ArrayFunctor(this.values.map(fn));
    }

    getValues(): T[] {
        return [...this.values];
    }
}

// Класс-функтор для одиночного значения
class IdentityFunctor<T> implements Functor<T> {
    private value: T;

    constructor(value: T) {
        this.value = value;
    }

    map<U>(fn: (value: T) => U): IdentityFunctor<U> {
        return new IdentityFunctor(fn(this.value));
    }

    getValue(): T {
        return this.value;
    }
}

// Класс-функтор для потенциально отсутствующего значения (Maybe)
class MaybeFunctor<T> implements Functor<T> {
    private value: T | null;

    constructor(value: T | null) {
        this.value = value;
    }

    map<U>(fn: (value: T) => U): MaybeFunctor<U> {
        return this.value !== null ? new MaybeFunctor(fn(this.value)) : new MaybeFunctor<U>(null);
    }

    getValue(): T | null {
        return this.value;
    }

    isPresent(): boolean {
        return this.value !== null;
    }
}

// Примеры использования функторов
const numbers = new ArrayFunctor([1, 2, 3, 4, 5]);
const doubled = numbers.map(x => x * 2);
console.log(doubled.getValues()); // [2, 4, 6, 8, 10]

const identity = new IdentityFunctor(42);
const processedIdentity = identity.map(x => x * 2);
console.log(processedIdentity.getValue()); // 84

const maybeValue = new MaybeFunctor("Привет");
const transformedMaybe = maybeValue.map(s => s.toUpperCase());
console.log(transformedMaybe.getValue()); // "ПРИВЕТ"

const emptyMaybe = new MaybeFunctor<string>(null);
const transformedEmpty = emptyMaybe.map(s => s.toUpperCase());
console.log(transformedEmpty.getValue()); // null
console.log(transformedEmpty.isPresent()); // false
```

## Memoization

Мемоизация - это оптимизационная техника, при которой результаты вычислений кэшируются для предотвращения повторных вычислений одинаковых входных данных.

```typescript
// Простая мемоизация для функции
function memoize<T extends (...args: any[]) => any>(fn: T): T {
    const cache = new Map<string, any>();
    
    return function(...args: any[]): any {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log(`Взято из кэша для аргументов: ${key}`);
            return cache.get(key);
        }
        
        console.log(`Вычисление для аргументов: ${key}`);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    } as T;
}

// Пример вычислительно сложной функции
function fibonacci(n: number): number {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Мемоизированная версия
const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // Вычисления для 10, 9, 8, ..., 0
console.log(memoizedFibonacci(8));  // Из кэша

// Мемоизация с пользовательским ключом
function memoizeWithKey<T extends (...args: any[]) => any>(
    fn: T, 
    keyFn: (...args: Parameters<T>) => string = (...args) => JSON.stringify(args)
): T {
    const cache = new Map<string, any>();
    
    return function(...args: any[]): any {
        const key = keyFn(...args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    } as T;
}

// Пример с пользовательским ключом
interface User {
    id: number;
    name: string;
}

function fetchUserDetails(userId: number): Promise<User> {
    // Имитация асинхронного запроса
    return Promise.resolve({
        id: userId,
        name: `Пользователь ${userId}`
    });
}

const memoizedFetchUser = memoizeWithKey(fetchUserDetails, (id: number) => `user-${id}`);

// Пример мемоизации для методов класса
class Calculator {
    @memoizeDecorator
    expensiveCalculation(x: number, y: number): number {
        console.log(`Выполнение сложного вычисления для ${x} и ${y}`);
        // Имитация сложного вычисления
        return x * y + Math.random();
    }
}

// Декоратор для мемоизации методов
function memoizeDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cache = new Map<string, any>();
    
    descriptor.value = function(...args: any[]) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log(`Метод ${propertyKey}: Взято из кэша`);
            return cache.get(key);
        }
        
        console.log(`Метод ${propertyKey}: Вычисление`);
        const result = originalMethod.apply(this, args);
        cache.set(key, result);
        return result;
    };
    
    return descriptor;
}

// Использование
const calc = new Calculator();
console.log(calc.expensiveCalculation(2, 3)); // Вычисление
console.log(calc.expensiveCalculation(2, 3)); // Из кэша
```

## Partial Application

Частичное применение (Partial Application) - это техника создания новой функции путем фиксации некоторых аргументов существующей функции.

```typescript
// Функция для частичного применения
function partial<T extends (...args: any[]) => any>(
    fn: T, 
    ...fixedArgs: any[]
): (...args: any[]) => any {
    return function(...args: any[]) {
        const allArgs = [...fixedArgs, ...args];
        return fn.apply(this, allArgs);
    };
}

// Пример функции для частичного применения
function greet(greeting: string, name: string, punctuation: string = "!"): string {
    return `${greeting}, ${name}${punctuation}`;
}

// Частично примененные функции
const sayHello = partial(greet, "Привет");
const sayHi = partial(greet, "Хай");
const formalGreeting = partial(greet, "Добрый день", "");

console.log(sayHello("Иван")); // "Привет, Иван!"
console.log(sayHi("Мария")); // "Хай, Мария!"
console.log(formalGreeting("Петров")); // "Добрый день, Петров!"

// Более сложный пример с вычислениями
function calculate(operation: string, a: number, b: number): number {
    switch(operation) {
        case 'add': return a + b;
        case 'subtract': return a - b;
        case 'multiply': return a * b;
        case 'divide': return b !== 0 ? a / b : NaN;
        default: throw new Error(`Неизвестная операция: ${operation}`);
    }
}

const add = partial(calculate, 'add');
const multiply = partial(calculate, 'multiply');
const divideByTwo = partial(calculate, 'divide', 2); // a = 2, b будет передан позже

console.log(add(5, 3)); // 8
console.log(multiply(4, 6)); // 24
console.log(divideByTwo(10)); // 5 (2 / 10 -> 0.2, но мы передаем (2, 10), так что 2/10 = 0.2)

// Правильное частичное применение для деления
const divide = partial(calculate, 'divide');
const divideTenBy = partial(divide, 10); // фиксируем 10 как делимое
console.log(divideTenBy(2)); // 5 (10 / 2)

// Универсальная реализация частичного применения с каррированием
function curryPartial<T extends (...args: any[]) => any>(fn: T): any {
    return function curried(...args: any[]) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return (...nextArgs: any[]) => curried(...args, ...nextArgs);
        }
    };
}

// Пример использования каррированной функции
const multiplyThree = (a: number, b: number, c: number) => a * b * c;
const curriedMultiply = curryPartial(multiplyThree);

const multiplyBy2 = curriedMultiply(2);
const multiplyBy2And3 = multiplyBy2(3);
console.log(multiplyBy2And3(4)); // 24

// Или в одну строку
console.log(curriedMultiply(2)(3)(4)); // 24

// Частичное применение с объектами
interface UserFilter {
    name?: string;
    age?: number;
    active?: boolean;
}

function filterUsers(users: any[], filter: UserFilter): any[] {
    return users.filter(user => {
        if (filter.name && user.name !== filter.name) return false;
        if (filter.age !== undefined && user.age !== filter.age) return false;
        if (filter.active !== undefined && user.active !== filter.active) return false;
        return true;
    });
}

const users = [
    { name: "Иван", age: 25, active: true },
    { name: "Мария", age: 30, active: false },
    { name: "Иван", age: 28, active: true }
];

const filterByName = partial(filterUsers, users);
const activeIvan = filterByName({ name: "Иван", active: true });
console.log(activeIvan); // [{ name: "Иван", age: 25, active: true }]
```

## Function Pipelines

Пайплайн функций - это способ последовательного применения нескольких функций к значению, где результат одной функции становится входом для следующей.

```typescript
// Простая реализация пайплайна
function pipe<T, U, V>(fn1: (arg: T) => U, fn2: (arg: U) => V): (arg: T) => V;
function pipe<T, U, V, W>(fn1: (arg: T) => U, fn2: (arg: U) => V, fn3: (arg: V) => W): (arg: T) => W;
function pipe<T>(...fns: Array<(arg: any) => any>): (arg: T) => any {
    return (arg: T) => fns.reduce((acc, fn) => fn(acc), arg);
}

// Примеры функций для пайплайна
const add = (n: number) => (x: number) => x + n;
const multiply = (n: number) => (x: number) => x * n;
const subtract = (n: number) => (x: number) => x - n;
const square = (x: number) => x * x;
const double = (x: number) => x * 2;

// Пайплайн из нескольких функций
const processNumber = pipe(
    add(5),      // x + 5
    square,      // (x + 5)^2
    multiply(2), // (x + 5)^2 * 2
    subtract(10) // ((x + 5)^2 * 2) - 10
);

console.log(processNumber(3)); // ((3 + 5)^2 * 2) - 10 = (64 * 2) - 10 = 118

// Пайплайн для обработки строк
const toUpperCase = (str: string) => str.toUpperCase();
const addPrefix = (prefix: string) => (str: string) => `${prefix}${str}`;
const addSuffix = (suffix: string) => (str: string) => `${str}${suffix}`;
const removeSpaces = (str: string) => str.replace(/\s+/g, '');

const processString = pipe(
    toUpperCase,
    addPrefix(">>> "),
    addSuffix(" <<<"),
    removeSpaces
);

console.log(processString("hello world")); // ">>>HELLOWORLD<<<"

// Пайплайн для обработки данных пользователя
interface UserData {
    name: string;
    email: string;
    age: number;
    active: boolean;
}

interface ProcessedUser {
    id: string;
    name: string;
    email: string;
    category: string;
    isValid: boolean;
}

const validateUser = (user: UserData): UserData => {
    if (!user.name || !user.email) {
        throw new Error("Имя и email обязательны");
    }
    return user;
};

const generateId = (user: UserData): UserData & { id: string } => ({
    ...user,
    id: `user_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`
});

const categorizeUser = (user: UserData & { id: string }): ProcessedUser => ({
    ...user,
    category: user.age < 30 ? "молодой" : user.age < 50 ? "средний" : "старший",
    isValid: user.active
});

const formatUserName = (user: ProcessedUser): ProcessedUser => ({
    ...user,
    name: user.name.split(' ').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ')
});

const processUserPipeline = pipe(
    validateUser,
    generateId,
    categorizeUser,
    formatUserName
);

try {
    const user: UserData = { name: "иван иванов", email: "ivan@example.com", age: 25, active: true };
    const processedUser = processUserPipeline(user);
    console.log(processedUser);
} catch (error) {
    console.error("Ошибка в пайплайне:", error);
}

// Универсальный пайплайн с обработкой ошибок
function safePipe<T>(initialValue: T, ...fns: Array<(arg: any) => any>): { result: any; success: boolean; error?: any } {
    try {
        const result = fns.reduce((acc, fn) => fn(acc), initialValue);
        return { result, success: true };
    } catch (error) {
        return { result: undefined, success: false, error };
    }
}

// Пример использования безопасного пайплайна
const safeResult = safePipe(
    5,
    add(10),  // 15
    square,   // 225
    multiply(2), // 450
    (x: number) => { 
        if (x > 400) throw new Error("Значение слишком большое");
        return x;
    }
);

if (safeResult.success) {
    console.log("Результат:", safeResult.result);
} else {
    console.log("Ошибка в пайплайне:", safeResult.error.message);
}
```

> [!tip] Совет
> Функциональные паттерны особенно полезны при работе с асинхронными операциями, обработкой данных и построении сложных преобразований. Они позволяют создавать чистый, предсказуемый и легко тестируемый код.

## Заключение

Функциональные паттерны предоставляют мощные инструменты для создания надежного и сопровождаемого кода. Они особенно полезны при работе с данными, асинхронными операциями и сложными преобразованиями. Понимание и применение этих паттернов позволяет разработчикам создавать более чистый, предсказуемый и легко тестируемый код.

Для более глубокого понимания рекомендуется изучить:
- [[Порождающие-паттерны]]
- [[Структурные-паттерны]]
- [[Поведенческие-паттерны]]
- [[Архитектурные-паттерны]]