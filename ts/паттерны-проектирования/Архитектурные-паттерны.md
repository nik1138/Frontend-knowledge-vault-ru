---
aliases: ["Architectural Patterns", "Архитектурные Паттерны"]
tags: ["#typescript", "#design-patterns", "#architectural-patterns", "#programming"]
---

# Архитектурные паттерны (Architectural Patterns)

Архитектурные паттерны определяют общую структуру приложения и определяют, как компоненты взаимодействуют друг с другом. Они охватывают более высокий уровень структуры, чем другие паттерны проектирования, и определяют организацию системы в целом. Эти паттерны помогают разработчикам принимать важные решения о структуре приложения и обеспечивают основу для масштабируемости, сопровождаемости и тестируемости.

## Содержание
- [[#Model-View-Controller (MVC)|Model-View-Controller (MVC)]]
- [[#Model-View-Presenter (MVP)|Model-View-Presenter (MVP)]]
- [[#Model-View-ViewModel (MVVM)|Model-View-ViewModel (MVVM)]]
- [[#Layered Architecture|Layered Architecture]]
- [[#Clean Architecture|Clean Architecture]]
- [[#Microkernel Architecture|Microkernel Architecture]]
- [[#Microservices Architecture|Microservices Architecture]]
- [[#Event-Driven Architecture|Event-Driven Architecture]]

## Model-View-Controller (MVC)

MVC (Model-View-Controller) - это классический архитектурный паттерн, который разделяет приложение на три основных компонента: модель, представление и контроллер. Каждый компонент имеет свою ответственность и взаимодействует с другими компонентами по определенным правилам.

```typescript
// Модель - представляет данные и бизнес-логику
class UserModel {
    private name: string;
    private email: string;

    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }

    public getName(): string {
        return this.name;
    }

    public getEmail(): string {
        return this.email;
    }

    public setName(name: string): void {
        this.name = name;
    }

    public setEmail(email: string): void {
        this.email = email;
    }
}

// Представление - отвечает за отображение данных
class UserView {
    public displayUserDetails(name: string, email: string): void {
        console.log(`Имя: ${name}`);
        console.log(`Email: ${email}`);
    }
}

// Контроллер - координирует взаимодействие между моделью и представлением
class UserController {
    private model: UserModel;
    private view: UserView;

    constructor(model: UserModel, view: UserView) {
        this.model = model;
        this.view = view;
    }

    public setUserName(name: string): void {
        this.model.setName(name);
    }

    public setUserEmail(email: string): void {
        this.model.setEmail(email);
    }

    public getUserDetails(): void {
        this.view.displayUserDetails(
            this.model.getName(),
            this.model.getEmail()
        );
    }
}

// Использование
const model = new UserModel("Иван Иванов", "ivan@example.com");
const view = new UserView();
const controller = new UserController(model, view);

controller.getUserDetails(); // Отображает текущие данные
controller.setUserName("Петр Петров");
controller.getUserDetails(); // Отображает обновленные данные
```

> [!warning] Важно
> MVC может привести к тесной связанности между компонентами, особенно в веб-приложениях. Рассмотрите использование более современных архитектурных паттернов для новых проектов.

## Model-View-Presenter (MVP)

MVP (Model-View-Presenter) - это архитектурный паттерн, который улучшает MVC, уменьшая связанность между компонентами. В MVP Presenter напрямую управляет View, а View делегирует пользовательские действия Presenter'у.

```typescript
// Интерфейс для представления
interface UserViewInterface {
    showUserDetails(name: string, email: string): void;
    showError(message: string): void;
    setName(name: string): void;
    setEmail(email: string): void;
    getName(): string;
    getEmail(): string;
}

// Модель
class UserModelMVP {
    private name: string;
    private email: string;

    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }

    public getName(): string {
        return this.name;
    }

    public getEmail(): string {
        return this.email;
    }

    public setName(name: string): void {
        this.name = name;
    }

    public setEmail(email: string): void {
        this.email = email;
    }
}

// Представление
class UserViewMVP implements UserViewInterface {
    private nameElement: string = '';
    private emailElement: string = '';

    public showUserDetails(name: string, email: string): void {
        console.log(`Отображение: Имя: ${name}, Email: ${email}`);
    }

    public showError(message: string): void {
        console.log(`Ошибка: ${message}`);
    }

    public setName(name: string): void {
        this.nameElement = name;
    }

    public setEmail(email: string): void {
        this.emailElement = email;
    }

    public getName(): string {
        return this.nameElement;
    }

    public getEmail(): string {
        return this.emailElement;
    }
}

// Презентер
class UserPresenter {
    private model: UserModelMVP;
    private view: UserViewInterface;

    constructor(model: UserModelMVP, view: UserViewInterface) {
        this.model = model;
        this.view = view;
    }

    public onNameChanged(): void {
        const name = this.view.getName();
        if (name.length < 3) {
            this.view.showError("Имя должно содержать минимум 3 символа");
            return;
        }
        this.model.setName(name);
        this.updateView();
    }

    public onEmailChanged(): void {
        const email = this.view.getEmail();
        if (!email.includes('@')) {
            this.view.showError("Некорректный email");
            return;
        }
        this.model.setEmail(email);
        this.updateView();
    }

    public loadUserDetails(): void {
        this.view.setName(this.model.getName());
        this.view.setEmail(this.model.getEmail());
        this.updateView();
    }

    private updateView(): void {
        this.view.showUserDetails(
            this.model.getName(),
            this.model.getEmail()
        );
    }
}

// Использование
const userMvpModel = new UserModelMVP("Анна Смирнова", "anna@example.com");
const userMvpView = new UserViewMVP();
const userMvpPresenter = new UserPresenter(userMvpModel, userMvpView);

userMvpPresenter.loadUserDetails();
userMvpView.setName("Мария Кузнецова");
userMvpPresenter.onNameChanged();
```

## Model-View-ViewModel (MVVM)

MVVM (Model-View-ViewModel) - это архитектурный паттерн, часто используемый в приложениях с пользовательским интерфейсом. Он обеспечивает полное разделение разработки графического интерфейса (View) от бизнес-логики (Model) через промежуточный слой ViewModel.

```typescript
// Модель
class UserModelMVVM {
    private name: string;
    private email: string;

    constructor(name: string, email: string) {
        this.name = name;
        this.email = email;
    }

    public getName(): string {
        return this.name;
    }

    public getEmail(): string {
        return this.email;
    }

    public setName(name: string): void {
        this.name = name;
    }

    public setEmail(email: string): void {
        this.email = email;
    }
}

// ViewModel
class UserViewModel {
    private model: UserModelMVVM;
    private callbacks: Array<() => void> = [];

    constructor(model: UserModelMVVM) {
        this.model = model;
    }

    public subscribe(callback: () => void): void {
        this.callbacks.push(callback);
    }

    private notify(): void {
        this.callbacks.forEach(callback => callback());
    }

    public getName(): string {
        return this.model.getName();
    }

    public getEmail(): string {
        return this.model.getEmail();
    }

    public setName(name: string): void {
        this.model.setName(name);
        this.notify();
    }

    public setEmail(email: string): void {
        this.model.setEmail(email);
        this.notify();
    }

    public getFormattedName(): string {
        return `Пользователь: ${this.model.getName()}`;
    }

    public getFormattedEmail(): string {
        return `Email: ${this.model.getEmail()}`;
    }
}

// Представление
class UserViewMVVM {
    private viewModel: UserViewModel;

    constructor(viewModel: UserViewModel) {
        this.viewModel = viewModel;
        this.viewModel.subscribe(() => this.render());
    }

    public render(): void {
        console.log(this.viewModel.getFormattedName());
        console.log(this.viewModel.getFormattedEmail());
    }

    public updateName(name: string): void {
        this.viewModel.setName(name);
    }

    public updateEmail(email: string): void {
        this.viewModel.setEmail(email);
    }
}

// Использование
const userMvvmModel = new UserModelMVVM("Ольга Волкова", "olga@example.com");
const userMvvmViewModel = new UserViewModel(userMvvmModel);
const userMvvmView = new UserViewMVVM(userMvvmViewModel);

userMvvmView.render(); // Отображает начальные данные
userMvvmView.updateName("Дмитрий Соколов");
// Автоматически обновит представление благодаря подписке
```

## Layered Architecture

Layered Architecture (архитектура слоев) - это паттерн, в котором компоненты системы организованы в горизонтальные слои. Каждый слой предоставляет определенные услуги слою выше него. Типичные слои: Presentation, Business Logic, Data Access и Database.

```typescript
// Слой данных
interface UserRepository {
    findById(id: number): User | null;
    save(user: User): void;
    findAll(): User[];
}

class DatabaseUserRepository implements UserRepository {
    private users: User[] = [
        new User(1, "Алексей", "alex@example.com"),
        new User(2, "Елена", "elena@example.com")
    ];

    public findById(id: number): User | null {
        return this.users.find(user => user.getId() === id) || null;
    }

    public save(user: User): void {
        const existingIndex = this.users.findIndex(u => u.getId() === user.getId());
        if (existingIndex !== -1) {
            this.users[existingIndex] = user;
        } else {
            this.users.push(user);
        }
    }

    public findAll(): User[] {
        return [...this.users];
    }
}

// Модель
class User {
    private id: number;
    private name: string;
    private email: string;

    constructor(id: number, name: string, email: string) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    public getId(): number {
        return this.id;
    }

    public getName(): string {
        return this.name;
    }

    public getEmail(): string {
        return this.email;
    }

    public setName(name: string): void {
        this.name = name;
    }

    public setEmail(email: string): void {
        this.email = email;
    }
}

// Слой бизнес-логики
class UserService {
    private userRepository: UserRepository;

    constructor(userRepository: UserRepository) {
        this.userRepository = userRepository;
    }

    public getUserById(id: number): User | null {
        if (id <= 0) {
            throw new Error("ID должен быть положительным числом");
        }
        return this.userRepository.findById(id);
    }

    public createUser(name: string, email: string): User {
        if (!name || !email) {
            throw new Error("Имя и email обязательны");
        }
        if (!email.includes('@')) {
            throw new Error("Некорректный email");
        }
        
        const newUser = new User(Date.now(), name, email);
        this.userRepository.save(newUser);
        return newUser;
    }

    public getAllUsers(): User[] {
        return this.userRepository.findAll();
    }
}

// Слой представления
class UserControllerLayered {
    private userService: UserService;

    constructor(userService: UserService) {
        this.userService = userService;
    }

    public handleGetUser(id: number): string {
        try {
            const user = this.userService.getUserById(id);
            if (user) {
                return `Найден пользователь: ${user.getName()} (${user.getEmail()})`;
            } else {
                return "Пользователь не найден";
            }
        } catch (error) {
            return `Ошибка: ${(error as Error).message}`;
        }
    }

    public handleCreateUser(name: string, email: string): string {
        try {
            const user = this.userService.createUser(name, email);
            return `Создан пользователь: ${user.getName()} с ID ${user.getId()}`;
        } catch (error) {
            return `Ошибка создания пользователя: ${(error as Error).message}`;
        }
    }
}

// Использование
const repository = new DatabaseUserRepository();
const userService = new UserService(repository);
const userController = new UserControllerLayered(userService);

console.log(userController.handleGetUser(1));
console.log(userController.handleCreateUser("Михаил", "mikhail@example.com"));
```

## Clean Architecture

Clean Architecture - это архитектурный паттерн, разработанный Робертом Мартином, который ставит бизнес-логику в центр системы. Архитектура состоит из концентрических колец, где внутренние кольца содержат более важную логику, а внешние - менее важную. Ключевое правило: зависимости направлены внутрь.

```typescript
// Внутренние сущности (Entity)
interface UserEntity {
    id: number;
    name: string;
    email: string;
}

// Входные порты (Use Cases)
interface GetUserUseCase {
    execute(userId: number): UserEntity | null;
}

interface CreateUserUseCase {
    execute(userData: { name: string; email: string }): UserEntity;
}

// Выходные порты (Interfaces)
interface UserRepositoryPort {
    findById(id: number): UserEntity | null;
    save(user: UserEntity): void;
}

// Реализация Use Case
class GetUserUseCaseImpl implements GetUserUseCase {
    private userRepository: UserRepositoryPort;

    constructor(userRepository: UserRepositoryPort) {
        this.userRepository = userRepository;
    }

    execute(userId: number): UserEntity | null {
        if (userId <= 0) {
            throw new Error("ID должен быть положительным числом");
        }
        return this.userRepository.findById(userId);
    }
}

class CreateUserUseCaseImpl implements CreateUserUseCase {
    private userRepository: UserRepositoryPort;

    constructor(userRepository: UserRepositoryPort) {
        this.userRepository = userRepository;
    }

    execute(userData: { name: string; email: string }): UserEntity {
        if (!userData.name || !userData.email) {
            throw new Error("Имя и email обязательны");
        }
        if (!userData.email.includes('@')) {
            throw new Error("Некорректный email");
        }
        
        const user: UserEntity = {
            id: Date.now(),
            name: userData.name,
            email: userData.email
        };
        
        this.userRepository.save(user);
        return user;
    }
}

// Адаптеры (внешние слои)
class DatabaseUserRepositoryAdapter implements UserRepositoryPort {
    private users: UserEntity[] = [
        { id: 1, name: "Андрей", email: "andrey@example.com" },
        { id: 2, name: "Татьяна", email: "tanya@example.com" }
    ];

    findById(id: number): UserEntity | null {
        return this.users.find(user => user.id === id) || null;
    }

    save(user: UserEntity): void {
        const existingIndex = this.users.findIndex(u => u.id === user.id);
        if (existingIndex !== -1) {
            this.users[existingIndex] = user;
        } else {
            this.users.push(user);
        }
    }
}

// Внешний контроллер
class UserControllerClean {
    private getUserUseCase: GetUserUseCase;
    private createUserUseCase: CreateUserUseCase;

    constructor(
        getUserUseCase: GetUserUseCase,
        createUserUseCase: CreateUserUseCase
    ) {
        this.getUserUseCase = getUserUseCase;
        this.createUserUseCase = createUserUseCase;
    }

    public handleGetUser(id: number): string {
        try {
            const user = this.getUserUseCase.execute(id);
            if (user) {
                return `Найден пользователь: ${user.name} (${user.email})`;
            } else {
                return "Пользователь не найден";
            }
        } catch (error) {
            return `Ошибка: ${(error as Error).message}`;
        }
    }

    public handleCreateUser(name: string, email: string): string {
        try {
            const user = this.createUserUseCase.execute({ name, email });
            return `Создан пользователь: ${user.name} с ID ${user.id}`;
        } catch (error) {
            return `Ошибка создания пользователя: ${(error as Error).message}`;
        }
    }
}

// Использование
const userRepository = new DatabaseUserRepositoryAdapter();
const getUserUseCase = new GetUserUseCaseImpl(userRepository);
const createUserUseCase = new CreateUserUseCaseImpl(userRepository);
const userController = new UserControllerClean(getUserUseCase, createUserUseCase);

console.log(userController.handleGetUser(1));
console.log(userController.handleCreateUser("Сергей", "sergey@example.com"));
```

## Microkernel Architecture

Microkernel Architecture - это архитектурный паттерн, в котором основная система (ядро) предоставляет минимальный набор функций, а дополнительные возможности добавляются через плагины. Ядро системы содержит только самые необходимые функции, а все расширенные возможности реализуются как отдельные компоненты.

```typescript
// Ядро системы
interface Plugin {
    getName(): string;
    execute(data: any): any;
}

class Microkernel {
    private plugins: Map<string, Plugin> = new Map();

    public registerPlugin(plugin: Plugin): void {
        this.plugins.set(plugin.getName(), plugin);
        console.log(`Плагин ${plugin.getName()} зарегистрирован`);
    }

    public unregisterPlugin(pluginName: string): void {
        this.plugins.delete(pluginName);
        console.log(`Плагин ${pluginName} удален`);
    }

    public executePlugin(pluginName: string, data: any): any {
        const plugin = this.plugins.get(pluginName);
        if (!plugin) {
            throw new Error(`Плагин ${pluginName} не найден`);
        }
        return plugin.execute(data);
    }

    public listPlugins(): string[] {
        return Array.from(this.plugins.keys());
    }
}

// Примеры плагинов
class ValidationPlugin implements Plugin {
    public getName(): string {
        return 'ValidationPlugin';
    }

    public execute(data: any): boolean {
        if (!data.email || !data.email.includes('@')) {
            console.log('Валидация: Некорректный email');
            return false;
        }
        if (!data.name || data.name.length < 3) {
            console.log('Валидация: Некорректное имя');
            return false;
        }
        console.log('Валидация: Данные корректны');
        return true;
    }
}

class LoggingPlugin implements Plugin {
    public getName(): string {
        return 'LoggingPlugin';
    }

    public execute(data: any): void {
        console.log(`Логирование: Обработка данных пользователя - ${JSON.stringify(data)}`);
    }
}

class NotificationPlugin implements Plugin {
    public getName(): string {
        return 'NotificationPlugin';
    }

    public execute(data: any): void {
        console.log(`Уведомление: Пользователь ${data.name} успешно зарегистрирован`);
    }
}

// Использование
const kernel = new Microkernel();

// Регистрация плагинов
kernel.registerPlugin(new ValidationPlugin());
kernel.registerPlugin(new LoggingPlugin());
kernel.registerPlugin(new NotificationPlugin());

// Использование плагинов
const userData = { name: 'Виктория', email: 'vika@example.com' };

// Валидация данных
const isValid = kernel.executePlugin('ValidationPlugin', userData);
if (isValid) {
    // Логирование
    kernel.executePlugin('LoggingPlugin', userData);
    // Уведомление
    kernel.executePlugin('NotificationPlugin', userData);
}

console.log('Зарегистрированные плагины:', kernel.listPlugins());
```

## Microservices Architecture

Microservices Architecture - это архитектурный стиль, при котором приложение строится как набор слабо связанных сервисов. Каждый сервис реализует определенную бизнес-функцию и может разрабатываться, развертываться и масштабироваться независимо от других сервисов.

```typescript
// Интерфейс для сервиса
interface Service {
    getName(): string;
    process(request: any): Promise<any>;
}

// Базовый класс для микросервисов
abstract class Microservice implements Service {
    protected name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    public abstract process(request: any): Promise<any>;
    
    public getName(): string {
        return this.name;
    }
}

// Сервис аутентификации
class AuthService extends Microservice {
    constructor() {
        super('AuthService');
    }
    
    public async process(request: any): Promise<any> {
        if (request.type === 'login') {
            const { username, password } = request.data;
            // Простая проверка (в реальном приложении - проверка в БД)
            if (username === 'admin' && password === 'password') {
                return {
                    success: true,
                    token: `token_${Date.now()}_${Math.random()}`
                };
            }
            return { success: false, error: 'Неверные учетные данные' };
        }
        
        if (request.type === 'validate') {
            const { token } = request.data;
            // Простая проверка токена
            return {
                valid: token.startsWith('token_'),
                userId: token ? 1 : null
            };
        }
        
        return { error: 'Неизвестный тип запроса' };
    }
}

// Сервис пользователей
class UserService extends Microservice {
    private users: Map<number, any> = new Map([
        [1, { id: 1, name: 'Александр', email: 'alex@example.com', role: 'admin' }]
    ]);
    
    constructor() {
        super('UserService');
    }
    
    public async process(request: any): Promise<any> {
        if (request.type === 'getUser') {
            const { userId } = request.data;
            const user = this.users.get(userId);
            return user ? { success: true, user } : { success: false, error: 'Пользователь не найден' };
        }
        
        if (request.type === 'createUser') {
            const { name, email } = request.data;
            const newId = Math.max(...Array.from(this.users.keys()), 0) + 1;
            const newUser = { id: newId, name, email, role: 'user' };
            this.users.set(newId, newUser);
            return { success: true, user: newUser };
        }
        
        return { error: 'Неизвестный тип запроса' };
    }
}

// Сервис уведомлений
class NotificationService extends Microservice {
    constructor() {
        super('NotificationService');
    }
    
    public async process(request: any): Promise<any> {
        if (request.type === 'sendEmail') {
            const { to, subject, body } = request.data;
            // Имитация отправки email
            console.log(`Отправка email: ${to}, Тема: ${subject}, Текст: ${body}`);
            return { success: true, message: 'Email отправлен' };
        }
        
        if (request.type === 'sendSMS') {
            const { phone, message } = request.data;
            // Имитация отправки SMS
            console.log(`Отправка SMS: ${phone}, Сообщение: ${message}`);
            return { success: true, message: 'SMS отправлено' };
        }
        
        return { error: 'Неизвестный тип запроса' };
    }
}

// Оркестратор микросервисов
class ServiceOrchestrator {
    private services: Map<string, Service> = new Map();
    
    public registerService(service: Service): void {
        this.services.set(service.getName(), service);
    }
    
    public async execute(serviceName: string, request: any): Promise<any> {
        const service = this.services.get(serviceName);
        if (!service) {
            throw new Error(`Сервис ${serviceName} не найден`);
        }
        return await service.process(request);
    }
    
    public async authenticateAndProcess(token: string, service: string, request: any): Promise<any> {
        // Сначала проверяем токен
        const authResult = await this.execute('AuthService', {
            type: 'validate',
            data: { token }
        });
        
        if (!authResult.valid) {
            return { error: 'Аутентификация не пройдена' };
        }
        
        // Затем выполняем запрос к нужному сервису
        return await this.execute(service, request);
    }
}

// Использование
async function runMicroservicesExample() {
    const orchestrator = new ServiceOrchestrator();
    
    // Регистрация сервисов
    orchestrator.registerService(new AuthService());
    orchestrator.registerService(new UserService());
    orchestrator.registerService(new NotificationService());
    
    // Аутентификация пользователя
    const loginResult = await orchestrator.execute('AuthService', {
        type: 'login',
        data: { username: 'admin', password: 'password' }
    });
    
    if (loginResult.success) {
        console.log('Аутентификация успешна:', loginResult.token);
        
        // Получение данных пользователя
        const userResult = await orchestrator.authenticateAndProcess(
            loginResult.token,
            'UserService',
            {
                type: 'getUser',
                data: { userId: 1 }
            }
        );
        
        console.log('Данные пользователя:', userResult);
        
        // Отправка уведомления
        const notificationResult = await orchestrator.execute('NotificationService', {
            type: 'sendEmail',
            data: {
                to: 'user@example.com',
                subject: 'Добро пожаловать!',
                body: 'Вы успешно зарегистрировались в системе'
            }
        });
        
        console.log('Результат отправки уведомления:', notificationResult);
    }
}

// Запуск примера
runMicroservicesExample().catch(console.error);
```

## Event-Driven Architecture

Event-Driven Architecture (EDA) - это архитектурный паттерн, в котором компоненты системы взаимодействуют через события. Компоненты могут публиковать события или подписываться на них. Это позволяет создавать слабо связанные системы, которые могут легко масштабироваться и адаптироваться к изменениям.

```typescript
// Интерфейс для события
interface Event {
    type: string;
    data: any;
    timestamp: Date;
}

// Интерфейс для обработчика событий
interface EventHandler {
    handle(event: Event): void;
}

// Центр событий
class EventBus {
    private handlers: Map<string, EventHandler[]> = new Map();

    public subscribe(eventType: string, handler: EventHandler): void {
        if (!this.handlers.has(eventType)) {
            this.handlers.set(eventType, []);
        }
        this.handlers.get(eventType)!.push(handler);
    }

    public publish(event: Event): void {
        const handlers = this.handlers.get(event.type);
        if (handlers) {
            handlers.forEach(handler => {
                try {
                    handler.handle(event);
                } catch (error) {
                    console.error(`Ошибка при обработке события ${event.type}:`, error);
                }
            });
        }
    }
}

// Примеры событий
class UserCreatedEvent implements Event {
    public type: string = 'UserCreated';
    public data: { userId: number; name: string; email: string };
    public timestamp: Date = new Date();

    constructor(userId: number, name: string, email: string) {
        this.data = { userId, name, email };
    }
}

class UserUpdatedEvent implements Event {
    public type: string = 'UserUpdated';
    public data: { userId: number; updates: Partial<{ name: string; email: string }> };
    public timestamp: Date = new Date();

    constructor(userId: number, updates: Partial<{ name: string; email: string }>) {
        this.data = { userId, updates };
    }
}

class UserDeletedEvent implements Event {
    public type: string = 'UserDeleted';
    public data: { userId: number };
    public timestamp: Date = new Date();

    constructor(userId: number) {
        this.data = { userId };
    }
}

// Обработчики событий
class UserNotificationHandler implements EventHandler {
    handle(event: Event): void {
        if (event.type === 'UserCreated') {
            console.log(`Отправка приветственного email для пользователя ${event.data.name}`);
        } else if (event.type === 'UserDeleted') {
            console.log(`Отправка email об удалении аккаунта для пользователя ${event.data.userId}`);
        }
    }
}

class UserLoggingHandler implements EventHandler {
    handle(event: Event): void {
        console.log(`Логирование события: ${event.type}`, event.data, event.timestamp);
    }
}

class UserRoleHandler implements EventHandler {
    handle(event: Event): void {
        if (event.type === 'UserCreated') {
            console.log(`Назначение стандартной роли пользователю ${event.data.name}`);
        } else if (event.type === 'UserUpdated') {
            if (event.data.updates.email) {
                console.log(`Обновление прав доступа для пользователя ${event.data.userId}`);
            }
        }
    }
}

// Сервис пользователей
class UserServiceEDA {
    private eventBus: EventBus;
    private users: Map<number, { id: number; name: string; email: string }> = new Map();

    constructor(eventBus: EventBus) {
        this.eventBus = eventBus;
    }

    public createUser(name: string, email: string): number {
        const userId = Date.now();
        const user = { id: userId, name, email };
        this.users.set(userId, user);
        
        const event = new UserCreatedEvent(userId, name, email);
        this.eventBus.publish(event);
        
        return userId;
    }

    public updateUser(userId: number, updates: Partial<{ name: string; email: string }>): boolean {
        const user = this.users.get(userId);
        if (!user) {
            return false;
        }
        
        // Обновляем пользователя
        if (updates.name) user.name = updates.name;
        if (updates.email) user.email = updates.email;
        
        this.users.set(userId, user);
        
        const event = new UserUpdatedEvent(userId, updates);
        this.eventBus.publish(event);
        
        return true;
    }

    public deleteUser(userId: number): boolean {
        const user = this.users.get(userId);
        if (!user) {
            return false;
        }
        
        this.users.delete(userId);
        
        const event = new UserDeletedEvent(userId);
        this.eventBus.publish(event);
        
        return true;
    }
}

// Использование
const eventBus = new EventBus();

// Регистрация обработчиков
eventBus.subscribe('UserCreated', new UserNotificationHandler());
eventBus.subscribe('UserCreated', new UserLoggingHandler());
eventBus.subscribe('UserCreated', new UserRoleHandler());

eventBus.subscribe('UserUpdated', new UserLoggingHandler());
eventBus.subscribe('UserUpdated', new UserRoleHandler());

eventBus.subscribe('UserDeleted', new UserNotificationHandler());
eventBus.subscribe('UserDeleted', new UserLoggingHandler());

// Создание сервиса пользователей
const userService = new UserServiceEDA(eventBus);

// Создание пользователя
const userId = userService.createUser('Евгений', 'evgeny@example.com');
console.log(`Создан пользователь с ID: ${userId}`);

// Обновление пользователя
userService.updateUser(userId, { email: 'evgeny.new@example.com' });

// Удаление пользователя
userService.deleteUser(userId);
```

> [!tip] Совет
> Архитектурные паттерны должны выбираться в зависимости от требований проекта. Рассмотрите масштабируемость, сложность, команду разработчиков и долгосрочные цели при выборе архитектуры.

## Заключение

Архитектурные паттерны обеспечивают фундамент для построения надежных, масштабируемых и сопровождаемых приложений. Правильный выбор архитектуры влияет на всю жизнедеятельность проекта, поэтому важно тщательно оценивать потребности системы при принятии архитектурных решений.

Для более глубокого понимания рекомендуется изучить:
- [[Порождающие-паттерны]]
- [[Структурные-паттерны]]
- [[Поведенческие-паттерны]]
- [[Функциональные-паттерны]]