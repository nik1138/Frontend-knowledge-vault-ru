---
aliases: ["Structural Patterns", "Структурные Паттерны"]
tags: ["#typescript", "#design-patterns", "#structural-patterns", "#programming"]
---

# Структурные паттерны (Structural Patterns)

Структурные паттерны связаны с композицией классов и объектов. Они помогают ответить на вопрос: "Как реализовать архитектуру классов?" Эти паттерны упрощают проектирование за счет определения способов создания отношений между сущностями.

## Содержание
- [[#Adapter|Adapter]]
- [[#Bridge|Bridge]]
- [[#Composite|Composite]]
- [[#Decorator|Decorator]]
- [[#Facade|Facade]]
- [[#Flyweight|Flyweight]]
- [[#Proxy|Proxy]]

## Adapter

Паттерн Adapter позволяет объектам с несовместимыми интерфейсами работать вместе. Он действует как мост между двумя несовместимыми интерфейсами, конвертируя интерфейс одного класса в интерфейс, который ожидает клиент.

```typescript
interface Target {
    request(): string;
}

class Adaptee {
    public specificRequest(): string {
        return "Специфический запрос";
    }
}

class Adapter implements Target {
    private adaptee: Adaptee;

    constructor(adaptee: Adaptee) {
        this.adaptee = adaptee;
    }

    public request(): string {
        const result = this.adaptee.specificRequest();
        return `Адаптировано: ${result}`;
    }
}

// Использование
const adaptee = new Adaptee();
const adapter = new Adapter(adaptee);
console.log(adapter.request()); // Адаптировано: Специфический запрос
```

## Bridge

Bridge разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо. Это позволяет изменять реализацию без изменения клиентского кода, который зависит от абстракции.

```typescript
interface Implementation {
    operationImplementation(): string;
}

class ConcreteImplementationA implements Implementation {
    public operationImplementation(): string {
        return "Реализация A";
    }
}

class ConcreteImplementationB implements Implementation {
    public operationImplementation(): string {
        return "Реализация B";
    }
}

abstract class Abstraction {
    protected implementation: Implementation;

    constructor(implementation: Implementation) {
        this.implementation = implementation;
    }

    public operation(): string {
        const result = this.implementation.operationImplementation();
        return `Абстракция: Базовая операция с:\n${result}`;
    }
}

class ExtendedAbstraction extends Abstraction {
    public operation(): string {
        const result = this.implementation.operationImplementation();
        return `Расширенная абстракция: Расширенная операция с:\n${result}`;
    }
}

// Использование
const implementationA = new ConcreteImplementationA();
const abstraction = new Abstraction(implementationA);
console.log(abstraction.operation());

const implementationB = new ConcreteImplementationB();
const extendedAbstraction = new ExtendedAbstraction(implementationB);
console.log(extendedAbstraction.operation());
```

## Composite

Composite позволяет клиентам обрабатывать отдельные объекты и составные структуры одинаково. Он создает иерархии объектов, где каждый узел может быть либо листом, либо составным узлом.

```typescript
interface Component {
    operation(): string;
    add(component: Component): void;
    remove(component: Component): void;
    isComposite(): boolean;
}

class Leaf implements Component {
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    public operation(): string {
        return `Лист ${this.name}`;
    }

    public add(component: Component): void {
        // Ничего не делаем - лист не может содержать другие компоненты
    }

    public remove(component: Component): void {
        // Ничего не делаем - лист не может содержать другие компоненты
    }

    public isComposite(): boolean {
        return false;
    }
}

class Composite implements Component {
    protected children: Component[] = [];

    public add(component: Component): void {
        this.children.push(component);
    }

    public remove(component: Component): void {
        const componentIndex = this.children.indexOf(component);
        this.children.splice(componentIndex, 1);
    }

    public isComposite(): boolean {
        return true;
    }

    public operation(): string {
        const results = [];
        for (const child of this.children) {
            results.push(child.operation());
        }
        return `Ветвь с (${results.join('+')})`;
    }
}

// Использование
const simple = new Leaf("Простой");
console.log(simple.operation());

const tree = new Composite();
const branch1 = new Composite();
branch1.add(new Leaf("Лист 1"));
branch1.add(new Leaf("Лист 2"));

const branch2 = new Composite();
branch2.add(new Leaf("Лист 3"));
branch2.add(new Leaf("Лист 4"));

tree.add(branch1);
tree.add(branch2);

console.log(tree.operation());
```

## Decorator

Decorator позволяет динамически добавлять новую функциональность объектам, оборачивая их в полезные "обертки". Это альтернатива созданию подклассов для расширения функциональности.

```typescript
interface Component {
    operation(): string;
}

class ConcreteComponent implements Component {
    public operation(): string {
        return "Конкретный компонент";
    }
}

class Decorator implements Component {
    protected component: Component;

    constructor(component: Component) {
        this.component = component;
    }

    public operation(): string {
        return this.component.operation();
    }
}

class ConcreteDecoratorA extends Decorator {
    public operation(): string {
        return `Декоратор A(${super.operation()})`;
    }
}

class ConcreteDecoratorB extends Decorator {
    public operation(): string {
        return `Декоратор B(${super.operation()})`;
    }
}

// Использование
const simple = new ConcreteComponent();
console.log(simple.operation()); // Конкретный компонент

const decorator1 = new ConcreteDecoratorA(simple);
const decorator2 = new ConcreteDecoratorB(decorator1);
console.log(decorator2.operation()); // Декоратор B(Декоратор A(Конкретный компонент))
```

## Facade

Facade предоставляет унифицированный интерфейс к подсистеме, состоящей из множества интерфейсов. Это упрощает использование сложной системы, предоставляя простой интерфейс.

```typescript
class Subsystem1 {
    public operation1(): string {
        return "Подсистема 1: Готово!\n";
    }

    public operationN(): string {
        return "Подсистема 1: Выполнено!\n";
    }
}

class Subsystem2 {
    public operation1(): string {
        return "Подсистема 2: Подготовка...\n";
    }

    public operationZ(): string {
        return "Подсистема 2: Завершено!\n";
    }
}

class Facade {
    protected subsystem1: Subsystem1;
    protected subsystem2: Subsystem2;

    constructor(subsystem1: Subsystem1 = new Subsystem1(), subsystem2: Subsystem2 = new Subsystem2()) {
        this.subsystem1 = subsystem1;
        this.subsystem2 = subsystem2;
    }

    public operation(): string {
        let result = "Фасад инициализирует подсистемы:\n";
        result += this.subsystem1.operation1();
        result += this.subsystem2.operation1();
        result += "Фасад координирует действия подсистем:\n";
        result += this.subsystem1.operationN();
        result += this.subsystem2.operationZ();
        return result;
    }
}

// Использование
const facade = new Facade();
console.log(facade.operation());
```

## Flyweight

Flyweight позволяет экономить память, разделяя общие данные между объектами, а не храня их в каждом объекте. Это особенно полезно при создании большого количества похожих объектов.

```typescript
interface Flyweight {
    operation(extrinsicState: string): string;
}

class ConcreteFlyweight implements Flyweight {
    private intrinsicState: string;

    constructor(intrinsicState: string) {
        this.intrinsicState = intrinsicState;
    }

    public operation(extrinsicState: string): string {
        return `Конкретный Flyweight: (${this.intrinsicState}) с внешним состоянием (${extrinsicState})\n`;
    }
}

class FlyweightFactory {
    private flyweights: { [key: string]: Flyweight } = {};

    constructor(initialFlyweights: string[][]) {
        for (const state of initialFlyweights) {
            this.flyweights[this.getKey(state)] = new ConcreteFlyweight(state.join('_'));
        }
    }

    private getKey(state: string[]): string {
        return state.join('_');
    }

    public getFlyweight(sharedState: string[]): Flyweight {
        const key = this.getKey(sharedState);

        if (!(key in this.flyweights)) {
            console.log('Фабрика Flyweight: Создание нового Flyweight.');
            this.flyweights[key] = new ConcreteFlyweight(sharedState.join('_'));
        } else {
            console.log('Фабрика Flyweight: Использование существующего Flyweight.');
        }

        return this.flyweights[key];
    }

    public listFlyweights(): void {
        const count = Object.keys(this.flyweights).length;
        console.log(`Фабрика Flyweight: Всего Flyweights: ${count}`);
        for (const key in this.flyweights) {
            console.log(key);
        }
    }
}

// Использование
const factory = new FlyweightFactory([
    ['Apple', 'Red'],
    ['Apple', 'Green'],
    ['Banana', 'Yellow'],
    ['Lemon', 'Yellow'],
]);

factory.listFlyweights();

function addTree(factory: FlyweightFactory, fruit: string, color: string, treeType: string) {
    const flyweight = factory.getFlyweight([fruit, color]);
    console.log(`Добавление дерева: ${flyweight.operation(treeType)}`);
}

addTree(factory, 'Apple', 'Red', 'Семечковый сад');
addTree(factory, 'Banana', 'Yellow', 'Тропический сад');
addTree(factory, 'Apple', 'Green', 'Семечковый сад');
```

## Proxy

Proxy предоставляет замену или заполнитель для другой сущности. Он контролирует доступ к объекту без изменения кода клиента, позволяя выполнить дополнительные действия перед или после вызова основного метода.

```typescript
interface Subject {
    request(): string;
}

class RealSubject implements Subject {
    public request(): string {
        return "Реальный субъект: Обработка запроса.";
    }
}

class Proxy implements Subject {
    private realSubject: RealSubject;

    constructor(realSubject: RealSubject) {
        this.realSubject = realSubject;
    }

    public request(): string {
        if (this.checkAccess()) {
            const result = this.realSubject.request();
            this.logAccess();
            return result;
        }
        return "Прокси: Отказ в доступе.";
    }

    private checkAccess(): boolean {
        console.log("Прокси: Проверка доступа.");
        return true;
    }

    private logAccess(): void {
        console.log("Прокси: Логирование запроса.");
    }
}

// Использование
const realSubject = new RealSubject();
const proxy = new Proxy(realSubject);

console.log("Прямой вызов:");
console.log(realSubject.request());

console.log("\nВызов через прокси:");
console.log(proxy.request());
```

> [!tip] Совет
> Proxy особенно полезен для реализации lazy initialization, logging, access control, caching и других дополнительных действий без изменения основного кода.

## Заключение

Структурные паттерны обеспечивают гибкость в проектировании архитектуры приложения, позволяя создавать связи между сущностями без жесткой зависимости. Эти паттерны помогают строить более устойчивые и масштабируемые системы.

Для более глубокого понимания рекомендуется изучить:
- [[Порождающие-паттерны]]
- [[Поведенческие-паттерны]]
- [[Архитектурные-паттерны]]