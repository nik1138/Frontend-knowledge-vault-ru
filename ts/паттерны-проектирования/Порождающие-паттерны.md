---
aliases: ["Creational Patterns", "Порождающие Паттерны"]
tags: ["#typescript", "#design-patterns", "#creational-patterns", "#programming"]
---

# Порождающие паттерны (Creational Patterns)

Порождающие паттерны в программировании нацелены на обработку механизмов создания объектов, позволяя системе быть независимой от способов создания, композиции и представления объектов. Эти паттерны абстрагируют процесс инстанцирования, что делает систему более гибкой и независимой от изменений в реализации классов.

## Содержание
- [[#Singleton|Singleton]]
- [[#Factory Method|Factory Method]]
- [[#Abstract Factory|Abstract Factory]]
- [[#Builder|Builder]]
- [[#Prototype|Prototype]]

## Singleton

Паттерн Singleton гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему. Это особенно полезно, когда необходимо контролировать доступ к общему ресурсу, например, к базе данных или к настройкам приложения.

```typescript
class Singleton {
    private static instance: Singleton;

    private constructor() {}

    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }

    public someBusinessLogic(): string {
        return "Singleton logic";
    }
}

// Использование
const singleton1 = Singleton.getInstance();
const singleton2 = Singleton.getInstance();

console.log(singleton1 === singleton2); // true
```

> [!warning] Важно
> Использование Singleton может усложнить тестирование и создать скрытые зависимости. Рассмотрите использование DI-контейнера как альтернативу.

## Factory Method

Factory Method определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта. Это позволяет делегировать создание экземпляров подклассам.

```typescript
interface Product {
    operation(): string;
}

class ConcreteProductA implements Product {
    operation(): string {
        return "Результат ConcreteProductA";
    }
}

class ConcreteProductB implements Product {
    operation(): string {
        return "Результат ConcreteProductB";
    }
}

abstract class Creator {
    public abstract factoryMethod(): Product;

    public someOperation(): string {
        const product = this.factoryMethod();
        return `Creator: ${product.operation()}`;
    }
}

class ConcreteCreatorA extends Creator {
    public factoryMethod(): Product {
        return new ConcreteProductA();
    }
}

class ConcreteCreatorB extends Creator {
    public factoryMethod(): Product {
        return new ConcreteProductB();
    }
}

// Использование
const creatorA = new ConcreteCreatorA();
console.log(creatorA.someOperation()); // Creator: Результат ConcreteProductA

const creatorB = new ConcreteCreatorB();
console.log(creatorB.someOperation()); // Creator: Результат ConcreteProductB
```

## Abstract Factory

Abstract Factory предоставляет интерфейс для создания семейств связанных или зависимых объектов без указания их конкретных классов. Это расширение Factory Method, позволяющее создавать группы объектов.

```typescript
interface AbstractProductA {
    usefulFunctionA(): string;
}

interface AbstractProductB {
    usefulFunctionB(): string;
    anotherUsefulFunctionB(collaborator: AbstractProductA): string;
}

class ConcreteProductA1 implements AbstractProductA {
    public usefulFunctionA(): string {
        return "Результат продукта A1.";
    }
}

class ConcreteProductA2 implements AbstractProductA {
    public usefulFunctionA(): string {
        return "Результат продукта A2.";
    }
}

class ConcreteProductB1 implements AbstractProductB {
    public usefulFunctionB(): string {
        return "Результат продукта B1.";
    }

    public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
        const result = collaborator.usefulFunctionA();
        return `Результат B1 collaborating with (${result})`;
    }
}

class ConcreteProductB2 implements AbstractProductB {
    public usefulFunctionB(): string {
        return "Результат продукта B2.";
    }

    public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
        const result = collaborator.usefulFunctionA();
        return `Результат B2 collaborating with (${result})`;
    }
}

interface AbstractFactory {
    createProductA(): AbstractProductA;
    createProductB(): AbstractProductB;
}

class ConcreteFactory1 implements AbstractFactory {
    public createProductA(): AbstractProductA {
        return new ConcreteProductA1();
    }

    public createProductB(): AbstractProductB {
        return new ConcreteProductB1();
    }
}

class ConcreteFactory2 implements AbstractFactory {
    public createProductA(): AbstractProductA {
        return new ConcreteProductA2();
    }

    public createProductB(): AbstractProductB {
        return new ConcreteProductB2();
    }
}

// Использование
function clientCode(factory: AbstractFactory) {
    const productA = factory.createProductA();
    const productB = factory.createProductB();

    console.log(productB.usefulFunctionB());
    console.log(productB.anotherUsefulFunctionB(productA));
}

clientCode(new ConcreteFactory1());
clientCode(new ConcreteFactory2());
```

## Builder

Builder позволяет создавать сложные объекты пошагово. Паттерн позволяет производить разные типы и представления объекта, используя один и тот же процесс построения.

```typescript
class Product {
    public parts: string[] = [];

    public listParts(): string {
        return `Product parts: ${this.parts.join(', ')}\n`;
    }
}

class ConcreteBuilder {
    private product: Product;

    constructor() {
        this.reset();
    }

    public reset(): void {
        this.product = new Product();
    }

    public producePartA(): void {
        this.product.parts.push('PartA1');
    }

    public producePartB(): void {
        this.product.parts.push('PartB1');
    }

    public producePartC(): void {
        this.product.parts.push('PartC1');
    }

    public getProduct(): Product {
        const result = this.product;
        this.reset();
        return result;
    }
}

class Director {
    private builder: ConcreteBuilder;

    public setBuilder(builder: ConcreteBuilder): void {
        this.builder = builder;
    }

    public buildMinimalViableProduct(): void {
        this.builder.producePartA();
    }

    public buildFullFeaturedProduct(): void {
        this.builder.producePartA();
        this.builder.producePartB();
        this.builder.producePartC();
    }
}

// Использование
const director = new Director();
const builder = new ConcreteBuilder();
director.setBuilder(builder);

console.log("Стандартный продукт:");
director.buildMinimalViableProduct();
console.log(builder.getProduct().listParts());

console.log("Полнофункциональный продукт:");
director.buildFullFeaturedProduct();
console.log(builder.getProduct().listParts());

console.log("Пользовательский продукт:");
builder.producePartA();
builder.producePartC();
console.log(builder.getProduct().listParts());
```

## Prototype

Prototype позволяет копировать объекты, не создавая зависимостей от их классов. Это особенно полезно, когда создание объекта является дорогостоящим процессом.

```typescript
interface Prototype {
    clone(): Prototype;
}

class ConcretePrototype implements Prototype {
    public field: string;

    constructor(field: string) {
        this.field = field;
    }

    public clone(): Prototype {
        return new ConcretePrototype(this.field);
    }

    public getField(): string {
        return this.field;
    }
}

// Использование
const prototype1 = new ConcretePrototype("Пример данных");
const prototype2 = prototype1.clone();

console.log(prototype1 === prototype2); // false
console.log(prototype1.getField() === prototype2.getField()); // true
```

> [!tip] Совет
> Паттерн Prototype особенно полезен при работе с объектами, создание которых требует выполнения тяжелых операций, таких как загрузка из базы данных или выполнение сетевых запросов.

## Заключение

Порождающие паттерны играют важную роль в проектировании гибких и масштабируемых приложений. Они позволяют изолировать код создания объектов, делая систему независимой от способов создания, композиции и представления объектов.

Для более глубокого понимания рекомендуется изучить следующие темы:
- [[Структурные-паттерны]]
- [[Поведенческие-паттерны]]
- [[Архитектурные-паттерны]]