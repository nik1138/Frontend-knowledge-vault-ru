---
aliases: [Проверка типов, Типизация, Проверка типов в TypeScript]
tags: [typescript, типизация, проверка-типов, безопасность-типов]
---

# Проверка типов при миграции с JavaScript на TypeScript

Проверка типов - это процесс, при котором TypeScript анализирует код для выявления несоответствий между ожидаемыми и фактическими типами данных. При миграции с JavaScript на TypeScript проверка типов становится важным инструментом для обеспечения корректности кода и выявления потенциальных ошибок на этапе компиляции.

## Введение в проверку типов

Проверка типов в TypeScript может выполняться в двух режимах:
- **Строгий режим** (strict mode) - обеспечивает максимальную безопасность типов
- **Нестрогий режим** - позволяет больше гибкости, но меньше гарантий безопасности

В процессе миграции рекомендуется начинать с нестрогого режима и постепенно переходить к строгому.

## Настройка проверки типов

### Конфигурация tsconfig.json

```json
{
  "compilerOptions": {
    "strict": false,
    "noImplicitAny": false,
    "strictNullChecks": false,
    "strictFunctionTypes": false,
    "strictBindCallApply": false,
    "strictPropertyInitialization": false,
    "noImplicitThis": false,
    "alwaysStrict": false,
    "allowJs": true,
    "checkJs": true
  }
}
```

### Постепенное включение строгих проверок

Рекомендуется включать строгие проверки постепенно:

1. Сначала включите `noImplicitAny` для выявления неявных типов `any`
2. Затем `strictNullChecks` для более точной обработки `null` и `undefined`
3. После этого `strictFunctionTypes` для проверки совместимости функций
4. И так далее, постепенно переходя к полному строгому режиму

## Проверка типов в JavaScript файлах

TypeScript может проверять типы в JavaScript файлах с помощью опции `checkJs: true`. Это позволяет обнаруживать ошибки в существующем JavaScript коде до его преобразования в TypeScript.

```javascript
// Пример кода с ошибкой типа
function calculateTotal(price, quantity) {
  return price * quantity;
}

// Ошибка: передача строки вместо числа
calculateTotal("10", 5);
```

С включенной проверкой типов TypeScript выдаст предупреждение о несоответствии типов.

## Типизация переменных и функций

### Явная типизация

```javascript
/** @type {string} */
let userName;

/** @type {number} */
let userAge;

/** @type {boolean} */
let isActive;

// Функция с явной типизацией параметров и возвращаемого значения
/**
 * @param {string} name
 * @param {number} age
 * @returns {object}
 */
function createUser(name, age) {
  return { name, age, id: Math.random() };
}
```

### Типизация объектов

```javascript
/**
 * @typedef {Object} User
 * @property {string} name
 * @property {number} age
 * @property {string} email
 */

/** @type {User} */
const user = {
  name: "John",
  age: 30,
  email: "john@example.com"
};
```

## Обработка null и undefined

Одной из важных проверок является `strictNullChecks`, которая помогает избежать ошибок, связанных с `null` и `undefined`:

```javascript
// Без strictNullChecks
let userName = undefined;
console.log(userName.length); // Ошибка выполнения: Cannot read property 'length' of undefined

// С включенным strictNullChecks TypeScript предупредит о возможной ошибке
```

Для безопасной работы с потенциально null значениями используйте:

```javascript
/**
 * @param {string | null} name
 * @returns {string}
 */
function formatName(name) {
  if (name) {
    return name.toUpperCase();
  }
  return "Unknown";
}
```

## Проверка типов массивов

```javascript
/** @type {string[]} */
let tags = [];

/** @type {Array.<Object>} */
let items = [];

// Проверка типов при добавлении элементов
tags.push("javascript"); // OK
tags.push(123); // Ошибка: number не может быть присвоен string

/**
 * @param {string[]} tags
 * @returns {string}
 */
function joinTags(tags) {
  return tags.join(", ");
}
```

## Проверка типов функций

TypeScript проверяет совместимость функций по сигнатуре:

```javascript
/**
 * @callback EventHandler
 * @param {Event} event
 * @returns {void}
 */

/**
 * @param {EventHandler} handler
 */
function addListener(handler) {
  // Регистрация обработчика
}

// Корректный обработчик
addListener(function(event) {
  console.log(event.type);
});

// Некорректный обработчик - TypeScript выдаст ошибку
addListener(function() {
  // Ошибка: отсутствует параметр event
});
```

## Работа с внешними библиотеками

При миграции важно учитывать типы внешних библиотек:

```javascript
// Установка типов для внешней библиотеки
// npm install --save-dev @types/lodash

const _ = require('lodash');

/** @type {number[]} */
const numbers = [1, 2, 3, 4, 5];

// TypeScript знает тип возвращаемого значения
const sum = _.sum(numbers); // Тип: number
```

Если типы для библиотеки отсутствуют, можно создать определение типа:

```javascript
/**
 * @typedef {Object} ExternalLibrary
 * @property {function(string): string} format
 * @property {function(number): boolean} validate
 */

/** @type {ExternalLibrary} */
const externalLib = require('some-external-lib');
```

## Обработка ошибок типов

Когда TypeScript обнаруживает ошибки типов, есть несколько подходов к их решению:

### 1. Использование типа any (временное решение)

```javascript
// Временное решение для быстрого устранения ошибки
/** @type {any} */
const unknownData = someComplexOperation();
```

> **Предупреждение**: Избегайте чрезмерного использования `any`, так как это снижает безопасность типов.

### 2. Уточнение типов через проверки

```javascript
/**
 * @param {unknown} value
 * @returns {string}
 */
function processValue(value) {
  if (typeof value === 'string') {
    return value.toUpperCase(); // Тип value теперь string
  }
  return String(value);
}
```

### 3. Использование Type Guards

```javascript
/**
 * @param {unknown} value
 * @returns {value is string}
 */
function isString(value) {
  return typeof value === 'string';
}

function processData(data) {
  if (isString(data)) {
    // Тип data теперь string
    return data.toUpperCase();
  }
  return data;
}
```

## Продвинутые возможности проверки типов

### Union Types

```javascript
/**
 * @param {string | number} value
 * @returns {string}
 */
function formatValue(value) {
  if (typeof value === 'string') {
    return value.trim();
  }
  return value.toString();
}
```

### Literal Types

```javascript
/**
 * @typedef {'pending' | 'active' | 'inactive'} UserStatus
 */

/**
 * @param {UserStatus} status
 */
function updateUserStatus(status) {
  // status может быть только 'pending', 'active' или 'inactive'
}
```

## Практические советы по проверке типов

### 1. Начинайте с критических компонентов

Проверяйте типы вначале в тех частях кода, где ошибки могут привести к серьезным проблемам:

```javascript
/**
 * Обработка платежа - критическая функция
 * @param {number} amount - Сумма платежа
 * @param {string} currency - Валюта (например, 'USD', 'EUR')
 * @param {string} userId - Идентификатор пользователя
 * @returns {Promise<boolean>} Результат обработки
 */
async function processPayment(amount, currency, userId) {
  // Реализация обработки платежа
}
```

### 2. Используйте определения типов

Создавайте переиспользуемые определения типов для сложных структур данных:

```javascript
/**
 * @typedef {Object} PaymentDetails
 * @property {number} amount
 * @property {string} currency
 * @property {string} cardNumber
 * @property {string} cvv
 * @property {string} expiryDate
 */

/**
 * @param {PaymentDetails} details
 * @returns {boolean}
 */
function validatePaymentDetails(details) {
  // Валидация деталей платежа
}
```

### 3. Тестируйте типизированный код

Обязательно запускайте тесты после добавления типизации, чтобы убедиться, что логика работы не изменилась.

## Инструменты для проверки типов

### TypeScript Compiler

Основной инструмент для проверки типов:

```bash
# Проверка типов в проекте
npx tsc --noEmit

# Проверка типов с отображением подробных сообщений
npx tsc --noEmit --verbose
```

### IDE поддержка

Большинство современных редакторов кода (VS Code, WebStorm и др.) предоставляют встроенную поддержку TypeScript и отображают ошибки типов в реальном времени.

## Заключение

Проверка типов - ключевой элемент успешной миграции с JavaScript на TypeScript. Она помогает обнаруживать ошибки на этапе разработки, улучшает читаемость кода и облегчает рефакторинг. Постепенный подход к включению проверок типов позволяет безопасно и эффективно мигрировать даже большие кодовые базы.

Следующий шаг - [[Конвертация-файлов]].