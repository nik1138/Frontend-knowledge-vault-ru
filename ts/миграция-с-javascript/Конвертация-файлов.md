---
aliases: [Конвертация файлов, Переход файлов, Преобразование JS в TS]
tags: [typescript, конвертация, миграция, javascript]
---

# Конвертация файлов при миграции с JavaScript на TypeScript

Конвертация файлов - это ключевой этап миграции с JavaScript на TypeScript, при котором JavaScript файлы преобразуются в TypeScript файлы с расширением `.ts`. Этот процесс требует тщательного подхода, чтобы сохранить функциональность кода и получить преимущества статической типизации.

## Подготовка к конвертации

Прежде чем начинать конвертацию файлов, убедитесь, что:

1. Установлен TypeScript: `npm install --save-dev typescript`
2. Создан файл `tsconfig.json` с настройками проекта
3. В проекте есть покрытие тестами для проверки корректности работы
4. Определена стратегия миграции (по файлам, по модулям, по функциональности)

Пример минимального `tsconfig.json` для начала:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "allowJs": true,
    "checkJs": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
```

## Процесс конвертации

### 1. Выбор файла для конвертации

Выберите файл, который:
- Имеет хорошее тестовое покрытие
- Не имеет сложных зависимостей от других JS файлов
- Относительно изолирован от остальной системы

### 2. Проверка и улучшение JSDoc

Перед конвертацией улучшите JSDoc аннотации в файле, чтобы облегчить процесс типизации:

```javascript
// До
function calculateTotal(price, quantity) {
  return price * quantity;
}

// После
/**
 * Вычисляет общую стоимость
 * @param {number} price - Цена за единицу
 * @param {number} quantity - Количество
 * @returns {number} Общая стоимость
 */
function calculateTotal(price, quantity) {
  return price * quantity;
}
```

Подробнее о [[JSDoc-типизация]].

### 3. Изменение расширения файла

Измените расширение файла с `.js` на `.ts`:

```bash
mv src/utils/calculations.js src/utils/calculations.ts
```

### 4. Исправление ошибок типизации

После изменения расширения запустите TypeScript компилятор, чтобы увидеть ошибки:

```bash
npx tsc --noEmit
```

Исправьте все обнаруженные ошибки типизации. Временно можно использовать `// @ts-ignore` для игнорирования сложных участков, но не злоупотребляйте этим.

## Типичные проблемы при конвертации

### 1. Неявные типы any

TypeScript может автоматически присвоить тип `any` переменным, параметрам функций и возвращаемым значениям, если типы не определены явно:

```typescript
// Проблема: параметр имеет тип any
function processUser(userData) {
  return userData.name.toUpperCase();
}

// Решение: явно определите тип
interface User {
  name: string;
  age: number;
}

function processUser(userData: User): string {
  return userData.name.toUpperCase();
}
```

### 2. Работа с null и undefined

При включенной опции `strictNullChecks` могут возникнуть ошибки, связанные с `null` и `undefined`:

```typescript
// Проблема: возможно undefined
let userName = getUsername();
console.log(userName.length); // Ошибка: Object is possibly 'undefined'

// Решение: проверка на существование
let userName = getUsername();
if (userName) {
  console.log(userName.length);
}

// Или использование оператора опциональной последовательности
console.log(userName?.length);
```

### 3. Проблемы с внешними библиотеками

Если проект использует библиотеки без типов, могут возникнуть ошибки:

```typescript
// Ошибка: Не удается найти объявление для библиотеки
import { someFunction } from 'my-library';

// Решение: установка типов или создание объявления типов
// npm install --save-dev @types/my-library

// Или создание файла declarations.d.ts
declare module 'my-library' {
  export function someFunction(): void;
}
```

## Стратегии конвертации

### 1. Миграция по зависимостям

Начните с файлов, которые не зависят от других JS файлов:

```
utils/
├── constants.ts      # Начните отсюда
├── helpers.ts        # Затем этот
└── validators.ts     # И этот
```

### 2. Миграция по слоям

Следуйте архитектурным слоям вашего приложения:

1. Утилиты и хелперы
2. Модели данных
3. Сервисы
4. Компоненты/контроллеры
5. Точки входа

### 3. Миграция по функциональности

Фокусируйтесь на одном функциональном блоке за раз:

```
authentication/
├── types.ts          # Типы для аутентификации
├── validator.ts      # Валидация данных
├── service.ts        # Сервис аутентификации
└── controller.ts     # Контроллер
```

## Практические примеры конвертации

### Пример 1: Конвертация простого модуля

**Было (math.js):**
```javascript
/**
 * Сложение двух чисел
 * @param {number} a - Первое число
 * @param {number} b - Второе число
 * @returns {number} Результат сложения
 */
function add(a, b) {
  return a + b;
}

/**
 * Умножение двух чисел
 * @param {number} a - Первое число
 * @param {number} b - Второе число
 * @returns {number} Результат умножения
 */
function multiply(a, b) {
  return a * b;
}

module.exports = { add, multiply };
```

**Стало (math.ts):**
```typescript
/**
 * Сложение двух чисел
 */
function add(a: number, b: number): number {
  return a + b;
}

/**
 * Умножение двух чисел
 */
function multiply(a: number, b: number): number {
  return a * b;
}

export { add, multiply };
```

### Пример 2: Конвертация модуля с объектами

**Было (user.js):**
```javascript
/**
 * @typedef {Object} User
 * @property {string} id - Идентификатор пользователя
 * @property {string} name - Имя пользователя
 * @property {number} age - Возраст пользователя
 */

/**
 * Создает нового пользователя
 * @param {string} name - Имя пользователя
 * @param {number} age - Возраст пользователя
 * @returns {User} Объект пользователя
 */
function createUser(name, age) {
  return { id: generateId(), name, age };
}

/**
 * Проверяет, совершеннолетний ли пользователь
 * @param {User} user - Объект пользователя
 * @returns {boolean} Результат проверки
 */
function isAdult(user) {
  return user.age >= 18;
}

function generateId() {
  return Math.random().toString(36).substr(2, 9);
}

module.exports = { createUser, isAdult };
```

**Стало (user.ts):**
```typescript
interface User {
  id: string;
  name: string;
  age: number;
}

/**
 * Создает нового пользователя
 */
function createUser(name: string, age: number): User {
  return { id: generateId(), name, age };
}

/**
 * Проверяет, совершеннолетний ли пользователь
 */
function isAdult(user: User): boolean {
  return user.age >= 18;
}

function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export { createUser, isAdult, User };
```

## Работа с ES6 модулями и CommonJS

При конвертации учитывайте систему модулей, используемую в проекте:

```typescript
// ES6 модули (import/export)
import { someFunction } from './utils';
export { someFunction };

// CommonJS (require/module.exports) - может потребовать настройки
const { someFunction } = require('./utils');
module.exports = { someFunction };
```

Для поддержки обеих систем в `tsconfig.json`:

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
```

## Тестирование конвертированных файлов

После конвертации обязательно:

1. Запустите все тесты, чтобы убедиться, что функциональность не изменилась
2. Проверьте компиляцию TypeScript: `npx tsc --noEmit`
3. Проверьте работоспособность в приложении

## Инструменты для упрощения конвертации

### 1. Автоматическая конвертация JSDoc

Некоторые IDE могут автоматически преобразовывать JSDoc аннотации в TypeScript типы.

### 2. TypeScript Intellisense

VS Code и другие IDE могут предложить автоматическую типизацию на основе JSDoc.

### 3. Скрипты для массовой обработки

Для больших проектов можно создать скрипты для автоматического изменения расширений файлов:

```bash
# Найти все JS файлы и изменить расширение на TS
find src -name "*.js" -exec bash -c 'mv "$1" "${1%.js}.ts"' _ {} \;
```

> **Предупреждение**: Используйте такие скрипты с осторожностью и только после резервного копирования кода.

## Обработка сложных случаев

### 1. Динамические импорты

```typescript
// Работа с динамическими импортами
async function loadModule(moduleName: string) {
  const module = await import(`./modules/${moduleName}`);
  return module;
}
```

### 2. Работа с DOM

```typescript
// Типизация DOM элементов
function getElementById(id: string): HTMLElement | null {
  return document.getElementById(id);
}

function addClickHandler(elementId: string, handler: (event: MouseEvent) => void) {
  const element = document.getElementById(elementId);
  if (element) {
    element.addEventListener('click', handler);
  }
}
```

## Проверка качества после конвертации

После конвертации каждого файла выполните:

1. Проверку типов: `npx tsc --noEmit`
2. Запуск тестов
3. Проверку логики работы
4. Ревью кода другими разработчиками

## Заключение

Конвертация файлов - это важный этап миграции с JavaScript на TypeScript. Подходите к нему постепенно, начиная с простых и изолированных модулей. Используйте JSDoc как промежуточный этап, и не забывайте тестировать код после каждого изменения. Правильная конвертация файлов обеспечивает преимущества статической типизации без потери функциональности.

Следующий шаг - [[Лучшие-практики]].