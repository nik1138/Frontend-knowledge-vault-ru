---
aliases: [Лучшие практики, Рекомендации, Советы по миграции]
tags: [typescript, миграция, javascript, практики, рекомендации]
---

# Лучшие практики миграции с JavaScript на TypeScript

Миграция с JavaScript на TypeScript - это сложный процесс, требующий тщательного планирования и последовательного выполнения. В этой статье собраны лучшие практики, которые помогут сделать миграцию максимально эффективной и безопасной.

## Планирование миграции

### 1. Оценка текущего состояния кодовой базы

Перед началом миграции необходимо:

- Провести аудит существующего JavaScript кода
- Определить объем кода, подлежащего миграции
- Выявить наиболее критичные для бизнеса компоненты
- Оценить качество текущего кода и покрытие тестами

### 2. Определение стратегии миграции

Существует несколько подходов к миграции:

- **Постепенная миграция** - файл за файлом, модуль за модулем
- **Миграция по функциональности** - по отдельным фичам или компонентам
- **Миграция по слоям** - сначала утилиты, затем бизнес-логика, потом UI

Подробнее о стратегиях см. [[Постепенная-миграция]].

### 3. Подготовка команды

- Обучите команду основам TypeScript
- Установите единые стандарты кодирования
- Настройте инструменты (ESLint, Prettier) для TypeScript
- Создайте документацию с рекомендациями по типизации

## Подготовка окружения

### 1. Настройка TypeScript

Создайте `tsconfig.json` с разумными настройками для начала:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "checkJs": false,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
```

### 2. Интеграция с системой сборки

Убедитесь, что ваша система сборки (Webpack, Rollup, Parcel и т.д.) корректно обрабатывает TypeScript файлы:

```javascript
// Пример настройки Webpack для TypeScript
module.exports = {
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
};
```

### 3. Настройка инструментов качества кода

```json
// .eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  plugins: [
    '@typescript-eslint',
  ],
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
  ],
};
```

## Процесс миграции

### 1. Начните с утилит и хелперов

Начинайте миграцию с небольших, изолированных модулей:

- Утилиты для работы с данными
- Хелперы для форматирования
- Константы и конфигурации
- Функции валидации

### 2. Используйте JSDoc как промежуточный этап

Перед конвертацией файла в TypeScript добавьте JSDoc аннотации:

```javascript
/**
 * @typedef {Object} User
 * @property {string} id - Уникальный идентификатор
 * @property {string} name - Имя пользователя
 * @property {number} age - Возраст пользователя
 */

/**
 * Создает нового пользователя
 * @param {string} name - Имя пользователя
 * @param {number} age - Возрат пользователя
 * @returns {User} Объект пользователя
 */
function createUser(name, age) {
  return { id: generateId(), name, age };
}
```

Подробнее о [[JSDoc-типизация]].

### 3. Постепенное включение строгих проверок

Не включайте все строгие проверки сразу. Добавляйте их постепенно:

1. Сначала `noImplicitAny`
2. Затем `strictNullChecks`
3. После этого `strictFunctionTypes`
4. И так далее, пока не достигнете `strict: true`

### 4. Обработка внешних зависимостей

Установите типы для используемых библиотек:

```bash
# Установка типов для популярных библиотек
npm install --save-dev @types/node
npm install --save-dev @types/react
npm install --save-dev @types/lodash
```

Для библиотек без типов создайте файл объявления:

```typescript
// declarations.d.ts
declare module 'some-external-library' {
  export function someFunction(): void;
}
```

## Типизация сложных структур

### 1. Используйте интерфейсы для объектов

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  profile?: UserProfile; // Опциональное свойство
}

interface UserProfile {
  avatar: string;
  bio: string;
}
```

### 2. Типизация функций

```typescript
type EventHandler = (event: Event) => void;

interface ApiService {
  get<T>(url: string): Promise<T>;
  post<T>(url: string, data: unknown): Promise<T>;
}
```

### 3. Работа с Union Types

```typescript
type Status = 'pending' | 'success' | 'error';

interface ApiResponse<T> {
  status: Status;
  data?: T;
  error?: string;
}
```

## Обработка ошибок и отладка

### 1. Использование Type Guards

```typescript
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    // Здесь TypeScript знает, что value - строка
    return value.toUpperCase();
  }
  return String(value);
}
```

### 2. Избегайте чрезмерного использования any

```typescript
// Плохо
function processData(data: any): any {
  return data.items.map((item: any) => item.name);
}

// Лучше
interface DataItem {
  name: string;
}

interface ProcessedData {
  items: DataItem[];
}

function processData(data: ProcessedData): string[] {
  return data.items.map(item => item.name);
}
```

### 3. Использование оператора ! (non-null assertion) с осторожностью

```typescript
// Плохо - может привести к ошибке выполнения
const element = document.getElementById('my-element')!;
element.style.display = 'block';

// Лучше - безопасная проверка
const element = document.getElementById('my-element');
if (element) {
  element.style.display = 'block';
}
```

## Тестирование и качество кода

### 1. Обновление тестов

После миграции обновите тесты, чтобы они учитывали типизацию:

```typescript
// Было
it('should create user with correct name', () => {
  const user = createUser('John', 30);
  expect(user.name).toBe('John');
});

// Стало - с типизацией
interface User {
  name: string;
  age: number;
}

it('should create user with correct name', () => {
  const user: User = createUser('John', 30);
  expect(user.name).toBe('John');
});
```

### 2. Проверка типов в CI/CD

Добавьте проверку типов в процесс сборки:

```yaml
# GitHub Actions
- name: Type Check
  run: npx tsc --noEmit
```

### 3. Использование linting

```bash
# Добавьте в скрипты package.json
"lint": "eslint src --ext .ts,.tsx",
"lint:fix": "eslint src --ext .ts,.tsx --fix"
```

## Практические советы

### 1. Создайте шаблоны типов

Для часто используемых структур данных создайте шаблоны:

```typescript
// Шаблоны для API ответов
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

type ApiResult<T> = Promise<ApiResponse<T>>;
```

### 2. Используйте mapped types для сложных преобразований

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
}

// Создание типа только с публичными полями
type PublicUser = Pick<User, 'id' | 'name' | 'email'>;

// Создание типа с опциональными полями
type PartialUser = Partial<User>;

// Создание типа с обязательными полями
type RequiredUser = Required<Pick<User, 'name' | 'email'>>;
```

### 3. Работа с асинхронным кодом

```typescript
// Типизация async/await
async function fetchUserData(userId: string): Promise<User | null> {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      return null;
    }
    return await response.json();
  } catch (error) {
    console.error('Error fetching user data:', error);
    return null;
  }
}
```

## Обработка сложных случаев

### 1. Работа с классами

```typescript
abstract class BaseService {
  protected baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  abstract get<T>(id: string): Promise<T>;
}

class UserService extends BaseService {
  constructor() {
    super('/api/users');
  }
  
  async get<T>(id: string): Promise<T> {
    // Реализация получения пользователя
  }
}
```

### 2. Использование generics

```typescript
class Repository<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  findById(id: string): T | undefined {
    return this.items.find(item => 
      typeof item === 'object' && 'id' in item && item.id === id
    );
  }
}

// Использование
const userRepository = new Repository<User>();
```

## Мониторинг прогресса

### 1. Отслеживание статуса миграции

Создайте систему отслеживания прогресса миграции:

- Список файлов, подлежащих миграции
- Статус каждого файла (в работе, завершен, отложен)
- Количество типизированных строк кода

### 2. Регулярные ревью

Организуйте регулярные ревью типизации кода:

- Проверка корректности типов
- Обсуждение сложных случаев
- Обновление стандартов и практик

## Заключение

Миграция с JavaScript на TypeScript - это инвестиция в будущее проекта. Следование лучшим практикам позволяет минимизировать риски и получить максимальную пользу от статической типизации. Помните, что процесс миграции требует времени и терпения, но результат стоит усилий: более надежный, читаемый и поддерживаемый код.

Ключевые принципы успешной миграции:
- Планируйте процесс заранее
- Начинайте с простых и изолированных компонентов
- Используйте JSDoc как промежуточный этап
- Тестируйте код после каждого изменения
- Постепенно увеличивайте строгость проверок
- Обучайте команду правильной типизации

Следуя этим рекомендациям, вы сможете успешно мигрировать свой проект с JavaScript на TypeScript без потери функциональности и с улучшением качества кода.