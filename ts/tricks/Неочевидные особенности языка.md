---
tags: [typescript, frontend, advanced, language-features]
aliases: [Неочевидные особенности TypeScript, Скрытые возможности TypeScript]
---

# Неочевидные особенности языка

## Введение

TypeScript содержит множество неочевидных особенностей и скрытых возможностей, которые могут значительно улучшить ваш код. В этом разделе мы рассмотрим редко используемые, но мощные возможности языка, которые могут сделать ваш код более выразительным и типобезопасным.

## Неочевидные особенности системы типов

### Индексные типы и keyof оператор

```ts
// keyof оператор возвращает объединение строковых литералов всех публичных свойств типа
interface Person {
  name: string;
  age: number;
  email: string;
}

type PersonKeys = keyof Person; // "name" | "age" | "email"

// Использование keyof с индексными типами
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person: Person = { name: "John", age: 30, email: "john@example.com" };
const name = getProperty(person, "name"); // Тип: string
const age = getProperty(person, "age");   // Тип: number

// Расширенный пример с ограничением ключей
function getProperties<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map(key => obj[key]);
}

const values = getProperties(person, ["name", "age"]); // (string | number)[]
```

### Условные типы с infer

```ts
// Использование infer для извлечения типов
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function getUser() {
  return { id: 1, name: "John", email: "john@example.com" };
}

type User = GetReturnType<typeof getUser>; // { id: number; name: string; email: string; }

// Извлечение типа параметров функции
type GetParameters<T> = T extends (...args: infer P) => any ? P : never;

function updateUser(id: number, name: string, email: string) {
  return { id, name, email };
}

type UpdateParams = GetParameters<typeof updateUser>; // [number, string, string]

// Извлечение типа элемента массива
type GetArrayType<T> = T extends (infer U)[] ? U : T;

type StringArray = string[];
type ArrayElementType = GetArrayType<StringArray>; // string

// Извлечение типа из Promise
type GetPromiseType<T> = T extends Promise<infer U> ? U : T;

type AsyncUser = Promise<{ id: number; name: string }>;
type UnwrappedUser = GetPromiseType<AsyncUser>; // { id: number; name: string; }

// Продвинутый пример: извлечение типа из сложной структуры
type DeepPromiseValue<T> = T extends Promise<infer U>
  ? DeepPromiseValue<U>
  : T extends (infer U)[]
  ? DeepPromiseValue<U>[]
  : { [K in keyof T]: DeepPromiseValue<T[K]> };

type ComplexType = Promise<{ users: Promise<{ id: number; name: string }[]>[] }>;
type UnwrappedComplex = DeepPromiseValue<ComplexType>; // { users: { id: number; name: string }[][] }
```

### Слияние типов и пространств имен

```ts
// TypeScript позволяет объявлять один и тот же тип/интерфейс несколько раз
// Они будут автоматически объединены

// Объявление интерфейса в одном месте
interface Config {
  apiUrl: string;
}

// Добавление к интерфейсу в другом месте
interface Config {
  timeout: number;
}

// Добавление в третьем месте
interface Config {
  retries: number;
}

// Результат: { apiUrl: string; timeout: number; retries: number; }
const config: Config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3
};

// Слияние пространств имен
namespace Validation {
  export function validateEmail(email: string): boolean {
    return /\S+@\S+\.\S+/.test(email);
  }
}

namespace Validation {
  export function validatePhone(phone: string): boolean {
    return /^\+?[\d\s-()]+$/.test(phone);
  }
}

// Оба метода доступны
const isValidEmail = Validation.validateEmail("test@example.com");
const isValidPhone = Validation.validatePhone("+1234567890");

// Слияние с классами
class Greeter {
  greeting: string;
  
  constructor(message: string) {
    this.greeting = message;
  }
}

namespace Greeter {
  export const standardGreeting = "Hello, World!";
  export function getStandardGreeting() {
    return standardGreeting;
  }
}

// Использование
const greeter = new Greeter("Hi there!");
const standard = Greeter.getStandardGreeting(); // "Hello, World!"
```

## Продвинутые возможности дженериков

### Ограничения дженериков на основе других параметров

```ts
// Ограничение типа T на основе типа K
function getPropertyFromObject<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, active: true };
const name = getPropertyFromObject(person, "name"); // string
const age = getPropertyFromObject(person, "age");   // number
const active = getPropertyFromObject(person, "active"); // boolean

// Продвинутый пример: создание типа с ограниченными полями
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
}

// Создание типа, который позволяет выбирать только определенные поля
type SelectFields<T, K extends keyof T> = {
  [P in K]: T[P]
};

type PublicUser = SelectFields<User, 'id' | 'name' | 'email'>;
// { id: number; name: string; email: string; }

// Ограничение на основе значений
function pickValues<T, K extends keyof T>(
  obj: T,
  keys: K[]
): { [P in K]: T[P] } {
  const result = {} as { [P in K]: T[P] };
  
  for (const key of keys) {
    result[key] = obj[key];
  }
  
  return result;
}

const selected = pickValues(person, ["name", "age"]);
// { name: string; age: number; }
```

### Использование const assertions для уточнения типов

```ts
// const assertions позволяют уточнить типы до конкретных литеральных значений
const status = "active"; // тип: string
const statusConst = "active" as const; // тип: "active"

// Применение к объектам
const user = {
  name: "John",
  role: "admin",
  permissions: ["read", "write"]
}; 
// тип: { name: string; role: string; permissions: string[] }

const userConst = {
  name: "John",
  role: "admin",
  permissions: ["read", "write"]
} as const;
// тип: { readonly name: "John"; readonly role: "admin"; readonly permissions: readonly ["read", "write"] }

// Практический пример: создание безопасных enum-ов
const HttpStatus = {
  OK: 200,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
} as const;

type HttpStatus = typeof HttpStatus[keyof typeof HttpStatus]; // 200 | 404 | 500

// Использование в функциях
function handleStatus(status: HttpStatus) {
  switch (status) {
    case HttpStatus.OK:
      return "Success";
    case HttpStatus.NOT_FOUND:
      return "Not found";
    case HttpStatus.SERVER_ERROR:
      return "Server error";
  }
}

// Создание типобезопасного объекта с возможностью итерации
const RouteNames = {
  HOME: "/",
  USERS: "/users",
  PROFILE: "/profile/:id"
} as const;

type RouteName = keyof typeof RouteNames; // "HOME" | "USERS" | "PROFILE"
type RoutePath = typeof RouteNames[RouteName]; // "/" | "/users" | "/profile/:id"

// Функция для получения пути маршрута
function getRoutePath<T extends RouteName>(name: T): typeof RouteNames[T] {
  return RouteNames[name];
}

const homePath = getRoutePath("HOME"); // тип: "/"
```

## Особенности работы с типами и значениями

### Сопоставленные типы с фильтрацией

```ts
// Создание типа, который делает определенные поля обязательными
type RequiredBut<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

interface User {
  id: number;
  name?: string;
  email?: string;
  phone?: string;
  createdAt: Date;
}

// Делаем только email обязательным
type UserWithEmail = RequiredBut<User, 'email'>;
// { id: number; name?: string; email: string; phone?: string; createdAt: Date; }

// Создание типа, который делает определенные поля опциональными
type PartialBut<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Делаем id и createdAt опциональными
type OptionalIdUser = PartialBut<User, 'id' | 'createdAt'>;
// { id?: number; name?: string; email?: string; phone?: string; createdAt?: Date; }

// Создание типа только с определенными свойствами, но с разными типами
type TransformProperties<T, TransformFn extends (prop: any) => any> = {
  [K in keyof T]: TransformFn extends (prop: T[K]) => infer R ? R : T[K]
};

// Пример: сделать все свойства массивами
type Arrayify<T> = {
  [K in keyof T]: T[K][]
};

type UserArrays = Arrayify<User>;
// { id: number[]; name: (string | undefined)[]; email: (string | undefined)[]; phone: (string | undefined)[]; createdAt: Date[]; }

// Создание типа с измененными названиями свойств
type AddPrefix<T, P extends string> = {
  [K in keyof T as `${P}${Capitalize<string & K>}`]: T[K]
};

type PrefixedUser = AddPrefix<User, 'user'>;
// { userId: number; userName: string | undefined; userEmail: string | undefined; userPhone: string | undefined; userCreatedAt: Date; }
```

### Условные типы с дистрибутивностью

```ts
// Дистрибутивные условные типы применяются к каждому члену объединения
type ToArray<T> = T extends any ? T[] : never;

type StrArr = ToArray<string>;           // string[]
type NumArr = ToArray<number>;           // number[]
type UnionArr = ToArray<string | number>; // string[] | number[]

// Практический пример: извлечение только строковых свойств объекта
type StringValueKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never
}[keyof T];

interface ApiResponse {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
  isActive: boolean;
}

type StringKeys = StringValueKeys<ApiResponse>; // "name" | "email"

// Создание типа только со строковыми свойствами
type StringOnly<T> = {
  [K in StringValueKeys<T>]: T[K]
};

type ResponseStrings = StringOnly<ApiResponse>; // { name: string; email: string; }

// Фильтрация свойств по типу
type FilterByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

type StringProps = FilterByType<ApiResponse, string>; // { name: string; email: string; }
type NumberProps = FilterByType<ApiResponse, number>; // { id: number; }
type BooleanProps = FilterByType<ApiResponse, boolean>; // { isActive: boolean; }
```

## Неочевидные особенности в контексте frontend разработки

### Типизация для мемоизации и производительности

```tsx
import { useMemo, useState, useCallback } from 'react';

// Типизация кастомного мемоизирующего хука
function useMemoCompare<T>(
  next: () => T,
  compare: (prev: T | undefined, next: T) => boolean
): T {
  const previousRef = useRef<{ value: T }>();
  const previous = previousRef.current;

  const isEqual = previous ? compare(previous.value, next()) : false;

  if (!isEqual) {
    previousRef.current = { value: next() };
  }

  return previousRef.current.value;
}

// Пример использования для сложных объектов
interface ComplexObject {
  data: { id: number; name: string }[];
  metadata: { total: number; page: number };
}

const expensiveCalculation = (input: ComplexObject): string => {
  // Сложные вычисления...
  return input.data.map(item => item.name).join(', ');
};

const Component: React.FC<{ data: ComplexObject }> = ({ data }) => {
  const result = useMemoCompare(
    () => expensiveCalculation(data),
    (prev, next) => JSON.stringify(prev) === JSON.stringify(next)
  );

  return <div>{result}</div>;
};

// Типизированный хук для мемоизации функций
function useMemoizedCallback<T extends (...args: any[]) => any>(
  callback: T,
  deps: React.DependencyList
): T {
  return useCallback(callback, deps) as T;
}
```

### Типизация для безопасной работы с DOM

```ts
// Типизация для безопасного получения элементов DOM
function getElementById<T extends HTMLElement>(
  id: string,
  constructor: new() => T
): T | null {
  const element = document.getElementById(id);
  if (element instanceof constructor) {
    return element;
  }
  return null;
}

// Использование
const button = getElementById("myButton", HTMLButtonElement);
if (button) {
  button.disabled = true; // TypeScript знает, что это HTMLButtonElement
}

// Типизация для обработчиков событий с уточнением элемента
function createTypedEventHandler<T extends HTMLElement, E extends Event>(
  element: T,
  eventType: string,
  handler: (element: T, event: E) => void
) {
  const typedHandler = (event: E) => {
    handler(element, event);
  };
  
  element.addEventListener(eventType as any, typedHandler as EventListener);
  
  return () => {
    element.removeEventListener(eventType as any, typedHandler as EventListener);
  };
}

// Пример использования
const input = document.querySelector('input');
if (input) {
  createTypedEventHandler(
    input,
    'input',
    (inputElement: HTMLInputElement, event: InputEvent) => {
      console.log(inputElement.value); // TypeScript знает тип элемента
    }
  );
}
```

### Продвинутая типизация для асинхронных операций

```ts
// Типизация для цепочек промисов
type PromiseChain<T> = T extends Promise<infer U> ? PromiseChain<U> : T;

// Пример: типизация функции, которая может возвращать промис или значение
function resolveValue<T>(value: T | Promise<T>): Promise<PromiseChain<T>> {
  return Promise.resolve(value);
}

// Типизация для параллельного выполнения с сохранением порядка
async function parallelMap<T, U>(
  items: T[],
  mapper: (item: T) => Promise<U>
): Promise<U[]> {
  const promises = items.map(item => mapper(item));
  return Promise.all(promises);
}

// Типизация для выполнения с ограничением по количеству параллельных операций
async function limitedParallelMap<T, U>(
  items: T[],
  mapper: (item: T) => Promise<U>,
  limit: number
): Promise<U[]> {
  const results: U[] = [];
  
  for (let i = 0; i < items.length; i += limit) {
    const batch = items.slice(i, i + limit);
    const batchResults = await Promise.all(batch.map(mapper));
    results.push(...batchResults);
  }
  
  return results;
}

// Использование с типизацией
interface UserData {
  id: number;
  name: string;
}

const userIds = [1, 2, 3, 4, 5];
const users = await limitedParallelMap(
  userIds,
  async (id) => {
    const response = await fetch(`/api/users/${id}`);
    return response.json() as Promise<UserData>;
  },
  2 // не более 2 одновременных запросов
);
// Тип users: UserData[]
```

## Редкие, но полезные возможности

### Использование template literal types для создания типов

```ts
// Создание типа для имен CSS классов
type BEM<B extends string, E extends string[], M extends string[]> = 
  | `${B}--${M[number]}`
  | `${B}__${E[number]}`
  | `${B}__${E[number]}--${M[number]}`;

type ButtonClasses = BEM<'button', ['icon', 'text'], ['primary', 'secondary']>;
// "button--primary" | "button--secondary" | 
// "button__icon" | "button__text" |
// "button__icon--primary" | "button__icon--secondary" | 
// "button__text--primary" | "button__text--secondary"

// Создание типа для имен функций API
type ApiMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiEndpoint = `/api/${string}`;

type ApiCallType<M extends ApiMethod, E extends ApiEndpoint> = 
  `${Lowercase<M>}${Capitalize<E>}`;

type GetUserCall = ApiCallType<'GET', '/api/users/123'>; // "getApiUsers123"

// Создание типа для действий Redux с автодополнением
type ActionCreator<T extends string> = <P = undefined>(payload?: P) => {
  type: T;
  payload?: P;
};

// Создание типобезопасного генератора действий
function createAction<T extends string>(type: T) {
  return Object.assign(
    (payload: any) => ({ type, payload }),
    { type }
  ) as ActionCreator<T>;
}

const setUserAction = createAction('SET_USER');
type SetUserAction = ReturnType<typeof setUserAction>;
// { type: "SET_USER"; payload?: any; }
```

### Особенности работы с перегрузками функций

```ts
// Перегрузки функций с правильной типизацией возврата
function formatValue(value: string): string;
function formatValue(value: number): string;
function formatValue(value: boolean): string;
function formatValue(value: Date): string;
function formatValue(value: string | number | boolean | Date): string {
  if (typeof value === 'string') {
    return value.toUpperCase();
  } else if (typeof value === 'number') {
    return value.toFixed(2);
  } else if (typeof value === 'boolean') {
    return value ? 'TRUE' : 'FALSE';
  } else {
    return value.toISOString();
  }
}

// Использование с правильной типизацией
const str = formatValue("hello");    // string
const num = formatValue(42);         // string
const bool = formatValue(true);      // string
const date = formatValue(new Date()); // string

// Перегрузки с дженериками
function processResult<T>(value: Promise<T>): Promise<T>;
function processResult<T>(value: T): T;
function processResult<T>(value: T | Promise<T>): T | Promise<T> {
  return value;
}

// Использование
const syncResult = processResult(42);        // number
const asyncResult = processResult(Promise.resolve(42)); // Promise<number>
```

## Заключение

Эти неочевидные особенности TypeScript открывают новые возможности для создания более типобезопасного и выразительного кода. Понимание и применение этих возможностей позволяет создавать более надежные и поддерживаемые приложения.

> [!tip] Совет
> Используйте `infer` для извлечения типов из сложных структур данных, особенно при работе с асинхронными операциями.

> [!warning] Важно
> Не переусложняйте типы - чрезмерное использование продвинутых возможностей может затруднить понимание кода.

## Связанные темы

- [[Продвинутые типы и метапрограммирование на типах]]
- [[Дженерики и условные типы]]
- [[Хитрости и лайфхаки TypeScript]]