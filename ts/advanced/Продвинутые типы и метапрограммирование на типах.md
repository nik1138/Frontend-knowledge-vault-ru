---
tags: [typescript, frontend, advanced-types, type-programming]
aliases: [Продвинутые типы TypeScript, Метапрограммирование на типах]
---

# Продвинутые типы и метапрограммирование на типах

## Введение

Продвинутые типы и метапрограммирование на типах позволяют создавать сложную логику на уровне типов, что делает TypeScript мощным инструментом для создания типобезопасных приложений. Эти возможности особенно полезны при разработке библиотек и сложных систем типизации.

## Продвинутые типы

### Mapped Types

Mapped Types позволяют создавать новые типы, трансформируя существующие типы.

```ts
// Простой mapped type
interface Person {
    name: string;
    age: number;
    location: string;
}

// Создание типа с только read-only свойствами
type ReadOnlyPerson = {
    readonly [P in keyof Person]: Person[P]
};

// Создание типа с optional свойствами
type PartialPerson = {
    [P in keyof Person]?: Person[P]
};

// Создание типа с измененными типами значений
type NullablePerson = {
    [P in keyof Person]: Person[P] | null
};

// Пример использования
const readOnlyPerson: ReadOnlyPerson = {
    name: "John",
    age: 30,
    location: "New York"
};
// readOnlyPerson.name = "Jane"; // Error: cannot assign to readonly property
```

### Conditional Types

Conditional Types позволяют создавать типы, которые выбираются на основе условия.

```ts
// Простой conditional type
type TypeName<T> = T extends string 
    ? "string" 
    : T extends number 
        ? "number" 
        : T extends boolean 
            ? "boolean" 
            : "object";

type T0 = TypeName<string>;  // "string"
type T1 = TypeName<"a">;     // "string"
type T2 = TypeName<true>;    // "boolean"
type T3 = TypeName<() => void>; // "object"

// Conditional types с дистрибутивностью
type ToArray<T> = T extends any ? T[] : never;

type T4 = ToArray<string | number>; // string[] | number[]

// Извлечение типов с помощью infer
type ElementType<T> = T extends (infer U)[] ? U : T;

type T5 = ElementType<string[]>; // string
type T6 = ElementType<number>;   // number
```

### Template Literal Types

Template Literal Types позволяют создавать строковые типы с помощью шаблонных литералов.

```ts
// Простые template literal types
type Color = "red" | "blue";
type Animal = "dog" | "cat";

type ColorfulAnimal = `${Color}-${Animal}`;
// "red-dog" | "red-cat" | "blue-dog" | "blue-cat"

// Изменение регистра
type Greeting = "Hello, World";
type ShoutyGreeting = Uppercase<Greeting>;  // "HELLO, WORLD"
type WhisperGreeting = Lowercase<Greeting>; // "hello, world"

// Capitalize и Uncapitalize
type Cap = Capitalize<"hello">;     // "Hello"
type Uncap = Uncapitalize<"Hello">; // "hello"

// Использование в интерфейсах
interface Options {
    width: number;
    height: number;
}

type OptionKeys = keyof Options; // "width" | "height"
type EventOptions = {
    [K in OptionKeys as `${K}Changed`]: Options[K]
};
// { widthChanged: number; heightChanged: number; }
```

## Метапрограммирование на типах

### Создание утилитных типов

```ts
// DeepPartial - делает все свойства опциональными рекурсивно
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object 
        ? DeepPartial<T[P]> 
        : T[P] extends (infer U)[] 
            ? DeepPartial<U>[] 
            : T[P]
};

interface User {
    id: number;
    name: string;
    address: {
        street: string;
        city: string;
        coordinates: {
            lat: number;
            lng: number;
        };
    };
}

type PartialUser = DeepPartial<User>;
// Все свойства, включая вложенные, становятся optional

// DeepReadonly - делает все свойства readonly рекурсивно
type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object 
        ? T[P] extends Function 
            ? T[P] 
            : DeepReadonly<T[P]> 
        : T[P]
};

// PickByType - выбор свойств по типу
type PickByType<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K]
};

interface Example {
    name: string;
    age: number;
    isActive: boolean;
    createdAt: Date;
}

type StringProps = PickByType<Example, string>; // { name: string }
type BooleanProps = PickByType<Example, boolean>; // { isActive: boolean }
```

### Типы для работы с функциями

```ts
// GetReturnType - извлечение типа возврата функции
type GetReturnType<T extends (...args: any[]) => any> = 
    T extends (...args: any[]) => infer R ? R : any;

function getUser() {
    return { id: 1, name: "John" };
}

type User = GetReturnType<typeof getUser>; // { id: number; name: string; }

// GetParameters - извлечение типов параметров функции
type GetParameters<T extends (...args: any[]) => any> = 
    T extends (...args: infer P) => any ? P : never;

function greet(name: string, age: number) {
    return `Hello ${name}, you are ${age} years old`;
}

type GreetParams = GetParameters<typeof greet>; // [string, number]

// CreateFunctionType - создание типа функции с заданными параметрами и возвращаемым типом
type CreateFunctionType<Params extends any[], Return> = (...args: Params) => Return;

type StringFunction = CreateFunctionType<[string], number>; // (arg: string) => number
```

## Практическое применение в frontend разработке

### Типизация компонентов высшего порядка (HOC)

```ts
import React from 'react';

// HOC для добавления пропса loading
function withLoading<P extends object>(Component: React.ComponentType<P>) {
    return function WithLoadingComponent(props: Omit<P, 'loading'> & { loading: boolean }) {
        if (props.loading) {
            return <div>Loading...</div>;
        }
        return <Component {...props as P} />;
    };
}

// Пример компонента
interface UserCardProps {
    user: { name: string; email: string };
    showEmail: boolean;
}

const UserCard: React.FC<UserCardProps> = ({ user, showEmail }) => (
    <div>
        <h3>{user.name}</h3>
        {showEmail && <p>{user.email}</p>}
    </div>
);

// Типизированный HOC
const UserCardWithLoading = withLoading(UserCard);
// Тип props: { user: { name: string; email: string }; showEmail: boolean; loading: boolean }
```

### Типизация для форм

```ts
// Типизация для валидации форм
interface FormField<T> {
    value: T;
    error?: string;
    touched: boolean;
}

interface FormState<T> {
    [K in keyof T]: FormField<T[K]>
}

interface UserFormValues {
    name: string;
    email: string;
    age: number;
    preferences: {
        newsletter: boolean;
        notifications: boolean;
    };
}

type UserFormState = FormState<UserFormValues>;
// {
//   name: FormField<string>;
//   email: FormField<string>;
//   age: FormField<number>;
//   preferences: FormField<{ newsletter: boolean; notifications: boolean; }>;
// }

// Утилита для получения типа значения из FormField
type FieldValue<T> = T extends FormField<infer U> ? U : never;

type NameType = FieldValue<UserFormState['name']>; // string
type PreferencesType = FieldValue<UserFormState['preferences']>; // { newsletter: boolean; notifications: boolean; }
```

### Типизация для API клиентов

```ts
// Типизация для динамического создания API методов
interface ApiEndpoint {
    path: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE';
    requestType?: any;
    responseType: any;
}

// Создание типа для API клиента на основе описания эндпоинтов
type ApiClient<T extends Record<string, ApiEndpoint>> = {
    [K in keyof T]: T[K]['method'] extends 'GET'
        ? () => Promise<T[K]['responseType']>
        : (data: T[K]['requestType']) => Promise<T[K]['responseType']>
};

// Определение эндпоинтов
const endpoints = {
    getUsers: {
        path: '/users',
        method: 'GET',
        responseType: [] as User[]
    },
    createUser: {
        path: '/users',
        method: 'POST',
        requestType: {} as { name: string; email: string },
        responseType: {} as User
    }
} as const;

// Типизированный API клиент
type UserService = ApiClient<typeof endpoints>;

// Пример использования (псевдокод)
// const api: UserService = createApiClient(endpoints);
// const users = await api.getUsers(); // Возвращает Promise<User[]>
// const newUser = await api.createUser({ name: "John", email: "john@example.com" }); // Возвращает Promise<User>
```

## Продвинутые паттерны

### Discriminated Unions

```ts
// Использование discriminanted unions для типизации состояния
interface LoadingState {
    status: 'loading';
}

interface SuccessState<T> {
    status: 'success';
    data: T;
}

interface ErrorState {
    status: 'error';
    error: string;
}

type ApiState<T> = LoadingState | SuccessState<T> | ErrorState;

function handleApiState<T>(state: ApiState<T>) {
    switch (state.status) {
        case 'loading':
            return 'Loading...';
        case 'success':
            return `Data: ${JSON.stringify(state.data)}`;
        case 'error':
            return `Error: ${state.error}`;
    }
}

// Типизация позволяет безопасно обращаться к свойствам
function processData<T>(state: ApiState<T>): T | null {
    if (state.status === 'success') {
        return state.data; // Тип данных известен благодаря discriminant
    }
    return null;
}
```

### Conditional Types для преобразования объектов

```ts
// Преобразование объекта для API запросов
type ToApiFormat<T> = {
    [K in keyof T as `${string & K}Dto`]: T[K]
};

interface User {
    id: number;
    firstName: string;
    lastName: string;
    email: string;
}

type UserApiDto = ToApiFormat<User>;
// {
//   idDto: number;
//   firstNameDto: string;
//   lastNameDto: string;
//   emailDto: string;
// }

// Преобразование обратно из API формата
type FromApiFormat<T> = {
    [K in keyof T as K extends `${infer P}Dto` ? P : K]: T[K]
};

type FromApiUser = FromApiFormat<UserApiDto>;
// {
//   id: number;
//   firstName: string;
//   lastName: string;
//   email: string;
// }
```

## Заключение

Продвинутые типы и метапрограммирование на типах открывают широкие возможности для создания сложных, типобезопасных систем в TypeScript. Эти инструменты особенно полезны при разработке библиотек, фреймворков и сложных приложений, где важна максимальная типобезопасность.

> [!tip] Совет
> Используйте продвинутые типы для создания переиспользуемых утилит, которые обеспечивают типобезопасность в различных частях приложения.

> [!warning] Важно
> Не переусложняйте типы - чрезмерное использование продвинутых типов может затруднить понимание кода.

## Связанные темы

- [[Дженерики и условные типы]]
- [[Утилиты типов TypeScript]]
- [[Интерфейсы и классы]]