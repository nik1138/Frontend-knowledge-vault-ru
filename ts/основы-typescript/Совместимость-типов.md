---
aliases: ["Совместимость типов", "Type Compatibility", "Сравнение типов в TypeScript"]
tags: [typescript, programming, types, compatibility, structural-typing]
---

# Совместимость типов

Совместимость типов в TypeScript определяет, когда значение одного типа может быть использовано в позиции другого типа. TypeScript использует структурную систему типов, что означает, что типы считаются совместимыми на основе их структуры, а не на основе их имен или происхождения.

## Основы структурной типизации

В отличие от языков с номинальной системой типов (где типы совместимы только если явно объявлены как таковые), TypeScript использует структурную типизацию:

```ts
interface Point {
  x: number;
  y: number;
}

class Point2D {
  x: number;
  y: number;
  
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

// Эти типы совместимы, потому что имеют одинаковую структуру
const point: Point = new Point2D(1, 2); // OK
const point2: Point2D = { x: 1, y: 2 } as Point2D; // OK
```

## Совместимость базовых типов

### Совместимость примитивов

```ts
// Числа совместимы с числами
let num: number = 5;
let decimal: number = 3.14;

// Строки совместимы со строками
let str: string = "hello";

// Логические значения совместимы с логическими значениями
let bool: boolean = true;
```

### Совместимость строковых литералов

```ts
type Status = "success" | "error" | "warning";

function handleStatus(status: Status) {
  console.log(status);
}

// Строковые литералы совместимы с объединением этих литералов
handleStatus("success"); // OK
// handleStatus("unknown"); // Ошибка: "unknown" не входит в тип Status
```

## Совместимость объектов

### Простая совместимость объектов

```ts
interface Bird {
  name: string;
  fly(): void;
}

interface Animal {
  name: string;
}

// Animal совместим с Bird, потому что имеет подмножество свойств
let bird: Bird = { name: "твити", fly: () => console.log("летит") };
let animal: Animal = bird; // OK - Bird имеет все свойства Animal

// Обратное не всегда верно
// let bird2: Bird = animal; // Ошибка: у Animal может не быть метода fly
```

### Дополнительные свойства

```ts
interface Square {
  width: number;
}

interface SquareWithColor extends Square {
  color: string;
}

// Объект с дополнительными свойствами может быть присвоен базовому типу
const coloredSquare: SquareWithColor = { width: 10, color: "red" };
const square: Square = coloredSquare; // OK

// Но не наоборот (без утверждения типа)
// const square2: SquareWithColor = square; // Ошибка
const square3: SquareWithColor = { ...square, color: "blue" }; // OK
```

### Совместимость с индексными сигнатурами

```ts
interface Dictionary {
  [index: string]: string;
}

interface NumberDictionary {
  [index: string]: number;
}

// NumberDictionary несовместим с Dictionary, потому что возвращаемые типы разные
// let dict: Dictionary = { key: 1 }; // Ошибка: number несовместим со string

interface ReadOnlyDictionary {
  readonly [index: string]: string;
}

// Объект с readonly индексной сигнатурой может принимать объект с обычной сигнатурой
let readOnly: ReadOnlyDictionary = { a: "test" }; // OK
```

## Совместимость функций

### Совместимость параметров

```ts
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

// y не может быть присвоен x, потому что y ожидает больше параметров
// x = y; // Ошибка

// x может быть присвоен y, потому что y может игнорировать дополнительные параметры
y = x; // OK
```

### Совместимость возвращаемых значений

```ts
let x2 = () => ({ name: "Alice" });
let y2 = () => ({ name: "Alice", location: "Seattle" });

// x2 может быть присвоен y2, потому что возвращаемый тип y2 имеет все свойства x2
x2 = y2; // OK

// y2 не может быть присвоен x2, потому что возвращаемый тип x2 не имеет свойства location
// y2 = x2; // Ошибка
```

### Совместимость функций с различными типами параметров

```ts
interface Input {
  value: string;
}

interface ExtendedInput extends Input {
  placeholder: string;
}

// Функция, принимающая более широкий тип, совместима с функцией, принимающей более узкий тип
let processInput: (input: Input) => void;
let processExtendedInput: (input: ExtendedInput) => void;

// processExtendedInput = processInput; // Ошибка
processInput = processExtendedInput; // OK
```

### Совместимость функций с методами

```ts
class Animal {
  name: string;
  constructor(name: string) { this.name = name; }
}

class Dog extends Animal {
  breed: string;
  constructor(name: string, breed: string) {
    super(name);
    this.breed = breed;
  }
}

// Функция, принимающая Animal, может принимать Dog
let animalFunc: (animal: Animal) => void;
let dogFunc: (dog: Dog) => void;

// dogFunc может быть присвоен animalFunc
animalFunc = dogFunc; // OK
```

## Совместимость массивов и кортежей

### Совместимость массивов

```ts
interface Bird {
  name: string;
  fly(): void;
}

interface Dog {
  name: string;
  bark(): void;
}

// Массивы не ковариантны
let birds: Bird[] = [{ name: "твити", fly: () => {} }];
// let animals: Animal[] = birds; // Ошибка, если Animal не родительский тип

// Но если Bird и Dog не связаны наследованием:
let dogs: Dog[] = [{ name: "рекс", bark: () => {} }];
// birds = dogs; // Ошибка: Dog несовместим с Bird
```

### Совместимость кортежей

```ts
// Кортежи совместимы с массивами их элементов
let tuple: [string, number] = ["hello", 42];
let array: (string | number)[] = tuple; // OK

// Но не наоборот
// let tuple2: [string, number] = array; // Ошибка
```

## Совместимость перечислений

### Совместимость числовых перечислений

```ts
enum Status { Ready, Waiting }
enum Color { Red, Blue, Green }

let status1 = Status.Ready;
let color1 = Color.Red;

// Числовые перечисления несовместимы друг с другом
// status1 = color1; // Ошибка
// color1 = status1; // Ошибка

// Но совместимы с числами
let num1: number = Status.Ready; // OK
status1 = 1; // OK
```

### Совместимость строковых перечислений

```ts
enum StatusStr { Ready = "READY", Waiting = "WAITING" }
enum ColorStr { Red = "RED", Blue = "BLUE" }

let statusStr1 = StatusStr.Ready;
let colorStr1 = ColorStr.Red;

// Строковые перечисления также несовместимы друг с другом
// statusStr1 = colorStr1; // Ошибка
// colorStr1 = statusStr1; // Ошибка

// Но совместимы со своими строковыми значениями
let str1: string = StatusStr.Ready; // OK
```

## Совместимость классов

### Совместимость на основе структуры

```ts
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) { }
}

class Size {
  feet: number;
  constructor(numFeet: number) { }
}

let a: Animal;
let s: Size;

// Эти классы совместимы, потому что имеют одинаковую структуру
a = s;  // OK
s = a;  // OK
```

### Совместимость с приватными и защищенными полями

```ts
class Animal {
  private name: string;
  constructor(name: string) { this.name = name; }
}

class Rhino extends Animal {
  constructor() { super("rhino"); }
}

class Employee {
  private name: string;
  constructor(name: string) { this.name = name; }
}

let animal = new Animal("goat");
let rhino = new Rhino();
let employee = new Employee("bob");

animal = rhino; // OK - Rhino наследует Animal
// animal = employee; // Ошибка: у Employee есть приватное поле name, не связанное с Animal
```

## Совместимость объединений и пересечений

### Совместимость объединений

```ts
interface Bird {
  name: string;
  fly(): void;
}

interface Fish {
  name: string;
  swim(): void;
}

// Совместимость объединений определяется по каждому типу отдельно
function move(pet: Bird | Fish) {
  if ("fly" in pet) {
    pet.fly(); // pet имеет тип Bird
  } else {
    pet.swim(); // pet имеет тип Fish
  }
}

let bird: Bird = { name: "твити", fly: () => {} };
let fish: Fish = { name: "золотая рыбка", swim: () => {} };

// Оба типа могут быть переданы в функцию
move(bird); // OK
move(fish); // OK
```

### Совместимость пересечений

```ts
interface Color {
  color: string;
}

interface Length {
  length: number;
}

type ColorfulLength = Color & Length;

// Объект должен иметь все свойства из обоих типов
let obj: ColorfulLength = {
  color: "blue",
  length: 10
}; // OK

// Совместимость с пересечениями требует всех свойств
// let partial: ColorfulLength = { color: "red" }; // Ошибка: нет свойства length
```

## Совместимость с any, unknown, never

### Совместимость с any

```ts
// any совместим с любым типом
let anyValue: any = 5;
let num: number = anyValue; // OK

// Любой тип совместим с any
num = anyValue; // OK
```

### Совместимость с unknown

```ts
let unknownValue: unknown = 5;

// Нельзя присвоить unknown другим типам без проверки
// let num: number = unknownValue; // Ошибка

// Но можно проверить тип
if (typeof unknownValue === "number") {
  let num: number = unknownValue; // OK
}
```

### never как нижняя граница

```ts
// never совместим с любым типом
let neverValue: never = (function(): never { throw new Error(); })();

let num: number = neverValue; // OK
let str: string = neverValue; // OK
let obj: {} = neverValue; // OK

// Но нет типа, совместимого с never (кроме never)
// let neverValue2: never = 5; // Ошибка
```

## Практические примеры

### Совместимость в интерфейсах API

```ts
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface User {
  id: number;
  name: string;
}

interface DetailedUser extends User {
  email: string;
  createdAt: Date;
}

// Функция может принимать общий тип и работать с более специфичным
function handleResponse(response: ApiResponse<User>) {
  console.log(response.data.name);
}

// Более детальный ответ совместим с общим
const detailedResponse: ApiResponse<DetailedUser> = {
  data: { id: 1, name: "Иван", email: "ivan@example.com", createdAt: new Date() },
  status: 200
};

// Это работает благодаря ковариантности
handleResponse(detailedResponse); // OK
```

### Совместимость в коллбэках

```ts
interface EventHandler<T> {
  (event: T): void;
}

interface BaseEvent {
  timestamp: number;
}

interface ClickEvent extends BaseEvent {
  x: number;
  y: number;
}

// Обработчик базового события может обрабатывать более конкретные события
let baseHandler: EventHandler<BaseEvent> = (event) => {
  console.log(event.timestamp);
};

let clickHandler: EventHandler<ClickEvent> = (event) => {
  console.log(event.x, event.y);
};

// ClickEvent может быть обработан базовым обработчиком
baseHandler = clickHandler; // OK - clickHandler может обработать все, что может baseHandler

// Но не наоборот
// clickHandler = baseHandler; // Ошибка - baseHandler не может обработать x и y
```

## Заключение

Совместимость типов в TypeScript - фундаментальный аспект языка, который определяет, где и как можно использовать различные типы. Понимание структурной типизации и правил совместимости позволяет писать более гибкий и безопасный код. Это особенно важно при работе с интерфейсами, наследованием, функциями и сложными структурами данных.

Для более глубокого понимания рекомендуется ознакомиться с [[Контроль-типов]] и [[Утилиты-типов]].

## Дополнительные ресурсы

- [[Типы-данных]] - основные типы данных в TypeScript
- [[Контроль-типов]] - управление типами в TypeScript
- [[Утилиты-типов]] - встроенные утилиты для работы с типами
- [[any-и-unknown]] - типы any и unknown