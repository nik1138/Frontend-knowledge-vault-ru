---
aliases: ["Утилиты типов", "Type Utilities", "Встроенные утилиты TypeScript"]
tags: [typescript, programming, types, utilities, type-manipulation]
---

# Утилиты типов

TypeScript предоставляет набор встроенных утилит типов, которые позволяют манипулировать типами и создавать более гибкие и переиспользуемые типы. Эти утилиты реализованы как дженерики и могут применяться к любым типам для создания новых типов с определенными характеристиками.

## Основные утилиты типов

### Partial<T>
Преобразует все свойства типа в необязательные:

```ts
interface User {
  name: string;
  email: string;
  age: number;
}

// Создает тип, где все свойства необязательны
type PartialUser = Partial<User>;

// Эквивалентно:
// type PartialUser = {
//   name?: string;
//   email?: string;
//   age?: number;
// };

const partialUser: PartialUser = {
  name: "Иван"
  // email и age не обязательны
};
```

### Required<T>
Преобразует все свойства типа в обязательные:

```ts
interface Props {
  name?: string;
  email?: string;
  age?: number;
}

// Создает тип, где все свойства обязательны
type RequiredProps = Required<Props>;

// Эквивалентно:
// type RequiredProps = {
//   name: string;
//   email: string;
//   age: number;
// };

const requiredProps: RequiredProps = {
  name: "Иван",
  email: "ivan@example.com",
  age: 30
};
```

### Readonly<T>
Делает все свойства типа только для чтения:

```ts
interface Todo {
  title: string;
  completed: boolean;
}

// Создает тип, где все свойства только для чтения
type ReadonlyTodo = Readonly<Todo>;

// Эквивалентно:
// type ReadonlyTodo = {
//   readonly title: string;
//   readonly completed: boolean;
// };

const todo: ReadonlyTodo = {
  title: "Изучить TypeScript",
  completed: false
};

// todo.completed = true; // Ошибка: свойство только для чтения
```

### Pick<T, K>
Создает тип, выбирая только указанные свойства из другого типа:

```ts
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  role: string;
}

// Создает тип только с указанными свойствами
type UserProfile = Pick<User, "name" | "email">;

// Эквивалентно:
// type UserProfile = {
//   name: string;
//   email: string;
// };

const profile: UserProfile = {
  name: "Иван",
  email: "ivan@example.com"
};
```

### Omit<T, K>
Создает тип, исключая указанные свойства из другого типа:

```ts
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  role: string;
}

// Создает тип без указанных свойств
type PublicUser = Omit<User, "password">;

// Эквивалентно:
// type PublicUser = {
//   id: number;
//   name: string;
//   email: string;
//   role: string;
// };

const publicUser: PublicUser = {
  id: 1,
  name: "Иван",
  email: "ivan@example.com",
  role: "user"
};
```

## Утилиты для работы с типами значений

### Exclude<T, U>
Исключает из T типы, которые присутствуют в U:

```ts
type T0 = Exclude<"a" | "b" | "c", "a">;        // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">;  // "c"
type T2 = Exclude<string | number | (() => void), Function>;  // string | number
type T3 = Exclude<unknown, string>;  // unknown (не работает как ожидается)
```

### Extract<T, U>
Извлекает из T типы, которые присутствуют в U:

```ts
type T0 = Extract<"a" | "b" | "c", "a" | "f">;  // "a"
type T1 = Extract<string | number | (() => void), Function>;  // () => void
type T2 = Extract<string | number, number>;  // number
```

### NonNullable<T>
Исключает типы null и undefined из T:

```ts
type T0 = NonNullable<string | number | undefined>;  // string | number
type T1 = NonNullable<string[] | null | undefined>;  // string[]
type T2 = NonNullable<undefined>;  // never
```

## Утилиты для работы с возвращаемыми значениями и параметрами функций

### ReturnType<T>
Получает тип возвращаемого значения функции:

```ts
declare function f1(): { a: number; b: string };

type T0 = ReturnType<() => string>;                    // string
type T1 = ReturnType<(s: string) => void>;            // void
type T2 = ReturnType<<T>() => T>;                     // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>;  // number[]
type T4 = ReturnType<typeof f1>;                      // { a: number, b: string }
type T5 = ReturnType<any>;                            // any
type T6 = ReturnType<never>;                          // any
// type T7 = ReturnType<string>;                         // Ошибка
// type T8 = ReturnType<Function>;                       // Ошибка
```

### Parameters<T>
Получает тип параметров функции в виде кортежа:

```ts
declare function f1(arg: { a: number; b: string }): void;

type T0 = Parameters<() => string>;           // []
type T1 = Parameters<(a: number) => void>;    // [number]
type T2 = Parameters<(a: number, b: string) => void>;  // [number, string]
type T3 = Parameters<typeof f1>;             // [{ a: number, b: string }]
type T4 = Parameters<any>;                   // any[]
type T5 = Parameters<never>;                 // never[]
// type T6 = Parameters<string>;                // Ошибка
// type T7 = Parameters<Function>;              // Ошибка
```

### ConstructorParameters<T>
Получает тип параметров конструктора:

```ts
type T0 = ConstructorParameters<ErrorConstructor>;     // [string?]
type T1 = ConstructorParameters<FunctionConstructor>;  // string[]
type T2 = ConstructorParameters<DateConstructor>;      // [string | number | Date?]
// type T3 = ConstructorParameters<typeof Error>;         // Ошибка
```

### InstanceType<T>
Получает тип экземпляра класса:

```ts
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>;        // C
type T1 = InstanceType<typeof Error>;    // Error
```

## Утилиты для работы с ключами и записями

### Record<K, T>
Создает тип, у которого ключи - из K, а значения - из T:

```ts
// Создает объект с ключами из 'a' | 'b' и значениями типа number
type Page = Record<'a' | 'b', number>;

const page: Page = {
  a: 1,
  b: 2
};

// Использование с динамическими ключами
type StringMap = Record<string, string>;
type BooleanMap = Record<string, boolean>;

// Практический пример: кэширование данных
type Cache<T> = Record<string, T | undefined>;

const userCache: Cache<User> = {};
```

### Keys<T>
Получает тип, состоящий из ключей типа T (реализуется через keyof):

```ts
interface User {
  id: number;
  name: string;
  email: string;
}

type UserKeys = keyof User;  // "id" | "name" | "email"

// Использование с индексными типами
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user: User = { id: 1, name: "Иван", email: "ivan@example.com" };
const userName = getProperty(user, "name");  // тип: string
```

### ThisParameterType<T>
Получает тип параметра this функции:

```ts
function toHex(this: Number) {
  return this.toString(16);
}

type T0 = ThisParameterType<typeof toHex>;  // Number
```

### OmitThisParameter<T>
Удаляет параметр this из типа функции:

```ts
function toHex(this: Number) {
  return this.toString(16);
}

const plainToHex: OmitThisParameter<typeof toHex> = toHex;
// Теперь plainToHex можно вызвать без контекста
```

## Практические примеры использования утилит типов

### Создание обновления сущности

```ts
interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
  updatedAt: Date;
}

// Для обновления пользователя используем только изменяемые поля
type UserUpdate = Omit<Partial<User>, "id" | "createdAt">;

// Эквивалентно:
// type UserUpdate = {
//   name?: string;
//   email?: string;
//   updatedAt?: Date;
// };

function updateUser(id: number, data: UserUpdate): User {
  // Логика обновления
  return { id, ...data } as User;
}
```

### Создание формы редактирования

```ts
interface Product {
  id: string;
  title: string;
  description: string;
  price: number;
  inStock: boolean;
  createdAt: Date;
}

// Форма редактирования не требует ID и дату создания
type ProductForm = Omit<Partial<Product>, "id" | "createdAt">;

// Создание утилиты для формы
type FormType<T> = Omit<Partial<T>, "id" | "createdAt">;

type ProductForm2 = FormType<Product>;
```

### Утилита для выбора полей

```ts
// Утилита для выбора только определенных типов свойств
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

interface Example {
  name: string;
  count: number;
  isActive: boolean;
  createdAt: Date;
  tags: string[];
}

type StringProps = PickByType<Example, string>;  // { name: string }
type ObjectProps = PickByType<Example, {}>;      // { createdAt: Date, tags: string[] }
```

### Утилита для создания опциональных полей по условию

```ts
// Утилита для создания типа с опциональными полями, если они могут быть undefined
type OptionalIfUndefined<T> = {
  [K in keyof T]: undefined extends T[K] ? T[K] : Required<Pick<T, K>>[K]
};

interface ApiResponse {
  name: string;
  email?: string;  // может быть undefined
  age: number | undefined;  // может быть undefined
}

type ProcessedResponse = OptionalIfUndefined<ApiResponse>;
```

## Продвинутые утилиты типов

### DeepPartial<T>
Глубокое преобразование всех свойств в необязательные:

```ts
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

interface Address {
  street: string;
  city: string;
  country: string;
}

interface User {
  name: string;
  age: number;
  address: Address;
}

type DeepPartialUser = DeepPartial<User>;
// Позволяет частично заполнить вложенные объекты
const partialUser: DeepPartialUser = {
  name: "Иван",
  address: {
    city: "Москва"
    // остальные поля опциональны
  }
};
```

### Merge<T, U>
Объединение двух типов:

```ts
type Merge<T, U> = {
  [K in keyof T | keyof U]: K extends keyof U ? U[K] : K extends keyof T ? T[K] : never;
};

type A = { a: string; b: number };
type B = { b: string; c: boolean };

type Merged = Merge<A, B>;  // { a: string; b: string; c: boolean }
```

## Заключение

Утилиты типов в TypeScript предоставляют мощный инструментарий для создания гибких и переиспользуемых типов. Они позволяют манипулировать существующими типами, создавать новые типы на основе старых и обеспечивать большую выразительность в системе типов. Понимание и умелое использование этих утилит позволяет писать более безопасный, чистый и документированный код.

Для продолжения изучения рекомендуется ознакомиться с [[Контроль-типов]] и [[Совместимость-типов]].

## Дополнительные ресурсы

- [[Типы-данных]] - основные типы данных в TypeScript
- [[any-и-unknown]] - типы any и unknown
- [[never-и-void]] - типы never и void
- [[Контроль-типов]] - управление типами в TypeScript
- [[Совместимость-типов]] - как TypeScript обрабатывает совместимость типов