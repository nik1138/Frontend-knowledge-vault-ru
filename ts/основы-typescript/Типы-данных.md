---
aliases: ["Типы данных TypeScript", "Система типов", "Типы в TypeScript"]
tags: [typescript, programming, types, data-types]
---

# Типы данных

TypeScript предоставляет богатую систему типов, которая позволяет разработчикам явно указывать типы данных переменных, параметров функций и возвращаемых значений. Это помогает избежать многих ошибок на этапе компиляции и делает код более понятным и документированным.

## Примитивные типы

### string
Тип `string` представляет строковые значения:

```ts
let firstName: string = "Иван";
let lastName: string = 'Иванов';
let fullName: string = `Полное имя: ${firstName} ${lastName}`;
```

### number
Тип `number` представляет числовые значения (включая целые и дробные числа):

```ts
let age: number = 30;
let pi: number = 3.14159;
let binary: number = 0b1010;  // бинарный литерал
let hex: number = 0xf00d;     // шестнадцатеричный литерал
let octal: number = 0o744;    // восьмеричный литерал
```

### boolean
Тип `boolean` представляет логические значения:

```ts
let isDone: boolean = false;
let isActive: boolean = true;
```

### null и undefined
Типы `null` и `undefined` представляют соответствующие значения:

```ts
let u: undefined = undefined;
let n: null = null;
```

> **Примечание**: При включенной опции `strictNullChecks` в `tsconfig.json`, `null` и `undefined` могут быть присвоены только переменным типа `any` или соответствующих типов.

### symbol
Тип `symbol` представляет уникальные идентификаторы:

```ts
const sym1: symbol = Symbol("key1");
const sym2: symbol = Symbol("key2");

console.log(sym1 === sym2); // false
```

### bigint
Тип `bigint` представляет целые числа произвольной длины:

```ts
const bigNumber: bigint = 123456789012345678901234567890n;
const anotherBig: bigint = BigInt(1000);
```

## Составные типы

### Array
Массивы могут быть определены двумя способами:

```ts
// Способ 1: тип[]
let numbers: number[] = [1, 2, 3, 4, 5];

// Способ 2: Array<тип>
let fruits: Array<string> = ["яблоко", "банан", "апельсин"];

// Многомерные массивы
let matrix: number[][] = [[1, 2], [3, 4]];
```

### Tuple
Кортежи (tuple) позволяют выразить массив с фиксированным количеством элементов, где каждый элемент может иметь разный тип:

```ts
// Кортеж с двумя элементами: строка и число
let person: [string, number] = ["Иван", 30];

// Использование кортежа
let name: string = person[0];
let age: number = person[1];

// Пример более сложного кортежа
let response: [string, number, boolean] = ["успех", 200, true];
```

### Enum
Перечисления (enum) позволяют определить набор именованных констант:

```ts
// Числовое перечисление
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}

let currentDirection: Direction = Direction.Up;
console.log(currentDirection); // 1

// Строковое перечисление
enum HttpStatus {
  OK = "OK",
  NOT_FOUND = "NOT_FOUND",
  SERVER_ERROR = "SERVER_ERROR"
}

let status: HttpStatus = HttpStatus.OK;

// Перечисление с вычисляемыми значениями
enum FileAccess {
  None,
  Read = 1 << 1,
  Write = 1 << 2,
  ReadWrite = Read | Write
}
```

## Объектные типы

### Object
Тип `object` представляет все не примитивные значения:

```ts
let obj: object = { name: "Иван", age: 30 };
let arr: object = [1, 2, 3];
let func: object = function() {};
```

### Интерфейсы
Интерфейсы позволяют определить форму объекта:

```ts
interface User {
  name: string;
  age: number;
  email?: string; // необязательное свойство
  readonly id: number; // только для чтения
}

let user: User = {
  name: "Мария",
  age: 25,
  id: 123
};
```

### Type aliases
Псевдонимы типов позволяют создавать новые имена для типов:

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;

function getName(n: NameOrResolver): Name {
  if (typeof n === "string") {
    return n;
  } else {
    return n();
  }
}
```

## Функциональные типы

### Function
Функции в TypeScript имеют типы, которые описывают их параметры и возвращаемые значения:

```ts
// Объявление типа функции
let myAdd: (x: number, y: number) => number =
  function(x: number, y: number): number { return x + y; };

// Тип функции с именованными параметрами
type MathOperation = (a: number, b: number) => number;

const add: MathOperation = (x, y) => x + y;
const multiply: MathOperation = (x, y) => x * y;
```

## Специальные типы

### any
Тип `any` позволяет переменной принимать значения любого типа:

```ts
let notSure: any = 4;
notSure = "может быть строкой";
notSure = false; // и логическим значением

// any также может использоваться для массивов
let list: any[] = [1, true, "free"];
list[1] = 100;
```

> **Предупреждение**: Использование `any` отключает проверку типов и должно быть ограничено.

### void
Тип `void` представляет отсутствие значения, обычно используется для функций, которые ничего не возвращают:

```ts
function warnUser(): void {
  console.log("Это сообщение с предупреждением");
}

let unusable: void = undefined; // или null при отключенном strictNullChecks
```

### never
Тип `never` представляет значения, которые никогда не происходят:

```ts
// Функция, которая всегда выбрасывает исключение
function error(message: string): never {
  throw new Error(message);
}

// Функция, которая никогда не завершается
function infiniteLoop(): never {
  while (true) {}
}

// never в проверке типов
function checkType(x: string | number): boolean {
  if (typeof x === "string") {
    return true;
  } else if (typeof x === "number") {
    return false;
  }
  // В этой точке TypeScript знает, что x не может быть другим типом
  // поэтому тип x - never
  return x; // Ошибка: несовместимость типов
}
```

## Объединения и пересечения типов

### Union types
Объединения (union) позволяют переменной иметь один из нескольких типов:

```ts
function printId(id: number | string) {
  console.log("ID: " + id);
}

// Работа с объединениями требует проверки типа
function getLength(obj: string | string[]) {
  return obj.length; // Работает для обоих типов
}

// Проверка типа при работе с объединениями
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

### Intersection types
Пересечения (intersection) объединяют два или более типа в один:

```ts
interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}

interface Artwork {
  title: string;
  description: string;
}

interface ArtworkWithHandling extends Artwork, ErrorHandling {}

// Или с использованием пересечения:
type ArtworkWithHandling2 = Artwork & ErrorHandling;

const myArt: ArtworkWithHandling = {
  title: "Солнце в полночь",
  description: "Картина о контрастах",
  success: true
};
```

## Литеральные типы

### String literals
Типы литералов позволяют указать конкретное значение:

```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";

class UIElement {
  animate(dx: number, dy: number, easing: Easing) {
    if (easing === "ease-in") {
      // ...
    } else if (easing === "ease-out") {
      // ...
    } else if (easing === "ease-in-out") {
      // ...
    }
  }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
// button.animate(0, 0, "uneasy"); // Ошибка: неправильное значение
```

### Number literals
```ts
type DiceValue = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceValue {
  return (Math.floor(Math.random() * 6) + 1) as DiceValue;
}
```

### Boolean literals
```ts
type Bool = true | false;

function validateUser(verified: true): string;
function validateUser(verified: false): string;
function validateUser(verified: boolean): string {
  if (verified) {
    return "Пользователь подтвержден";
  } else {
    return "Пользователь не подтвержден";
  }
}
```

## Заключение

Система типов TypeScript - мощный инструмент для создания надежного и поддерживаемого кода. Понимание различных типов данных и способов их использования позволяет писать более чистый, понятный и безопасный код.

Для более глубокого изучения рекомендуется ознакомиться с [[any-и-unknown]], [[never-и-void]] и [[Утилиты-типов]].

## Дополнительные ресурсы

- [[Введение-в-TypeScript]] - общее введение в TypeScript
- [[any-и-unknown]] - особые типы any и unknown
- [[never-и-void]] - типы never и void
- [[Утилиты-типов]] - встроенные утилиты для работы с типами