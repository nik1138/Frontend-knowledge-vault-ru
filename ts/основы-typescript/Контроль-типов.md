---
aliases: ["Контроль типов", "Type Guard", "Проверка типов", "Type Narrowing"]
tags: [typescript, programming, types, type-guard, type-narrowing, control]
---

# Контроль типов

Контроль типов (type narrowing) в TypeScript - это процесс, при котором TypeScript сужает общий тип до более конкретного на основе проверок в коде. Это позволяет использовать возможности конкретных типов в определенных ветвях кода, что делает систему типов более гибкой и безопасной.

## Основы сужения типов

### Простое сужение с typeof

```ts
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    // В этой ветви TypeScript знает, что padding - число
    return " ".repeat(padding) + input;
  }
  // В этой ветви TypeScript знает, что padding - строка
  return padding + input;
}
```

### Сужение с instanceof

```ts
function logValue(x: Date | Error) {
  if (x instanceof Date) {
    // Здесь TypeScript знает, что x - Date
    console.log(x.toISOString());
  } else {
    // Здесь TypeScript знает, что x - Error
    console.log(x.message);
  }
}
```

### Сужение с in operator

```ts
interface Bird {
  name: string;
  fly(): void;
}

interface Dog {
  name: string;
  bark(): void;
}

function handlePet(pet: Bird | Dog) {
  if ("fly" in pet) {
    // TypeScript знает, что pet - Bird
    pet.fly();
  } else {
    // TypeScript знает, что pet - Dog
    pet.bark();
  }
}
```

## Пользовательские проверки типов (Type Guards)

### Проверки типов с предикатами

```ts
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

interface Fish {
  name: string;
  swim(): void;
}

interface Bird {
  name: string;
  fly(): void;
}

function getFood(pet: Fish | Bird) {
  if (isFish(pet)) {
    // pet теперь имеет тип Fish
    return pet.name + " food";
  } else {
    // pet теперь имеет тип Bird
    return pet.name + " seeds";
  }
}
```

### Проверки типов для литеральных значений

```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";

function isEasing(value: string): value is Easing {
  return ["ease-in", "ease-out", "ease-in-out"].includes(value);
}

function applyEasing(easing: Easing) {
  // Логика применения easing
}

// Использование пользовательской проверки
function handleEasing(value: string) {
  if (isEasing(value)) {
    // value теперь имеет тип Easing
    applyEasing(value);
  } else {
    console.log("Неправильное значение easing:", value);
  }
}
```

## Сужение с литералами и объединениями

### Проверка с литералами

```ts
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Circle | Square | Triangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      // TypeScript знает, что shape - Circle
      return Math.PI * shape.radius ** 2;
    case "square":
      // TypeScript знает, что shape - Square
      return shape.sideLength ** 2;
    case "triangle":
      // TypeScript знает, что shape - Triangle
      return 0.5 * shape.base * shape.height;
    default:
      // При правильной реализации shape будет never
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```

### Проверка с числовыми литералами

```ts
type DiceValue = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceValue {
  return Math.floor(Math.random() * 6) + 1 as DiceValue;
}

function handleDice(value: DiceValue | number) {
  if (value === 1) {
    // value теперь имеет тип 1
    console.log("Выпало 1! Это неудача");
  } else if (value === 6) {
    // value теперь имеет тип 6
    console.log("Выпало 6! Это успех!");
  } else if (typeof value === "number" && value >= 2 && value <= 5) {
    // value теперь имеет тип 2 | 3 | 4 | 5
    console.log(`Выпало ${value}`);
  }
}
```

## Сужение с null и undefined

### Проверка на null/undefined

```ts
function liveDangerously(x?: number | null) {
  // Без проверки будет ошибка
  // console.log(x.toFixed()); // Ошибка: x может быть null или undefined

  if (x == null) {
    // x имеет тип null | undefined
    console.log("Значение отсутствует");
    return;
  }

  // Здесь TypeScript знает, что x - number
  console.log(x.toFixed()); // OK
}

// Или с отрицанием
function processValue(x: string | null) {
  if (x) {
    // x имеет тип string
    console.log(x.toUpperCase());
  }
}
```

### Сужение с опциональными свойствами

```ts
interface User {
  id: number;
  name: string;
  email?: string;
  profile?: {
    age: number;
    city: string;
  };
}

function displayUserInfo(user: User) {
  console.log(`ID: ${user.id}, Name: ${user.name}`);

  if (user.email) {
    // TypeScript знает, что email определен
    console.log(`Email: ${user.email}`);
  }

  if (user.profile) {
    // TypeScript знает, что profile определен
    console.log(`Age: ${user.profile.age}, City: ${user.profile.city}`);
  }
}
```

## Сужение с массивами

### Проверка длины массива

```ts
function getFirstElement<T>(arr: T[]): T | undefined {
  if (arr.length > 0) {
    // TypeScript знает, что массив не пустой
    return arr[0]; // Тип T
  }
  return undefined;
}

// Более сложный пример
function processStrings(strings: string[]) {
  if (strings.length === 1) {
    // strings теперь имеет тип [string] (массив с одним элементом)
    console.log(`Один элемент: ${strings[0]}`);
  } else if (strings.length > 1) {
    // strings имеет тип string[] с гарантией более одного элемента
    console.log(`Несколько элементов: ${strings.join(", ")}`);
  }
}
```

### Проверка типа элементов массива

```ts
function filterOutFalsy<T>(arr: T[]): T[] {
  return arr.filter(Boolean); // Убирает falsy значения
}

function processMixedArray(items: (string | number | null)[]) {
  // Сначала фильтруем, чтобы избавиться от null
  const nonNullItems = items.filter((item): item is string | number => item !== null);
  
  // Теперь можем безопасно работать с nonNullItems как с (string | number)[]
  return nonNullItems.map(item => {
    if (typeof item === "string") {
      // item имеет тип string
      return item.toUpperCase();
    } else {
      // item имеет тип number
      return item * 2;
    }
  });
}
```

## Сужение с асинхронными функциями

### Проверка результатов промисов

```ts
interface Success {
  success: true;
  data: string;
}

interface Failure {
  success: false;
  error: string;
}

type Result = Success | Failure;

async function fetchData(): Promise<Result> {
  // Симуляция асинхронного запроса
  return Math.random() > 0.5 
    ? { success: true, data: "данные получены" } 
    : { success: false, error: "ошибка запроса" };
}

async function handleAsyncResult() {
  const result = await fetchData();
  
  if (result.success) {
    // TypeScript знает, что result - Success
    console.log("Успех:", result.data);
  } else {
    // TypeScript знает, что result - Failure
    console.log("Ошибка:", result.error);
  }
}
```

## Сужение с дженериками

### Ограничения в дженериках

```ts
function isDefined<T>(value: T | undefined): value is T {
  return value !== undefined;
}

function firstDefined<T>(...values: (T | undefined)[]): T | undefined {
  for (const value of values) {
    if (isDefined(value)) {
      return value; // TypeScript знает, что это T
    }
  }
  return undefined;
}

// Использование
const result = firstDefined<string>(undefined, undefined, "hello");
// result имеет тип string | undefined
if (result) {
  // result имеет тип string
  console.log(result.toUpperCase());
}
```

### Сужение в функциях с дженериками

```ts
function filterByType<T, U extends T>(
  items: T[],
  predicate: (item: T) => item is U
): U[] {
  return items.filter(predicate);
}

interface Animal { name: string; }
interface Dog extends Animal { breed: string; }

const animals: Animal[] = [
  { name: "Бобик" },
  { name: "Шарик" }
];

// Пример пользовательской проверки типа
function isDog(animal: Animal): animal is Dog {
  return (animal as Dog).breed !== undefined;
}

const dogs = filterByType(animals, isDog);
// dogs имеет тип Dog[]
```

## Продвинутые техники сужения

### Сужение с помощью утверждений типов

```ts
function isInputElement(element: HTMLElement): element is HTMLInputElement {
  return element.tagName === 'INPUT';
}

function handleElement(element: HTMLElement) {
  if (isInputElement(element)) {
    // element теперь имеет тип HTMLInputElement
    console.log(element.value); // Свойство value доступно
  }
}
```

### Сужение с помощью утилит типов

```ts
// Проверка, является ли тип определенным
function isNotNull<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

// Использование
function processValue<T>(value: T | null | undefined): T {
  if (!isNotNull(value)) {
    throw new Error("Значение не определено");
  }
  // Здесь TypeScript знает, что value имеет тип T
  return value;
}
```

## Практические примеры

### Сужение в обработке форм

```ts
interface UserForm {
  name: string;
  email: string;
  age?: number;
  subscribeToNewsletter: boolean;
}

interface AdminForm {
  name: string;
  permissions: string[];
  role: "admin" | "moderator";
}

type Form = UserForm | AdminForm;

function validateForm(form: Form): boolean {
  // Проверяем, является ли это UserForm
  if ('subscribeToNewsletter' in form) {
    // form теперь имеет тип UserForm
    return form.name.length > 0 && form.email.includes('@');
  } else {
    // form теперь имеет тип AdminForm
    return form.name.length > 0 && form.permissions.length > 0;
  }
}
```

### Сужение в обработке ошибок

```ts
class ValidationError extends Error {
  constructor(public field: string, message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class NetworkError extends Error {
  constructor(public url: string, message: string) {
    super(message);
    this.name = 'NetworkError';
  }
}

function handlePotentialError(error: unknown) {
  if (error instanceof ValidationError) {
    // error теперь имеет тип ValidationError
    console.log(`Ошибка валидации поля ${error.field}: ${error.message}`);
  } else if (error instanceof NetworkError) {
    // error теперь имеет тип NetworkError
    console.log(`Ошибка сети при запросе ${error.url}: ${error.message}`);
  } else if (error instanceof Error) {
    // error теперь имеет тип Error
    console.log(`Неизвестная ошибка: ${error.message}`);
  } else {
    // Это может быть любой тип
    console.log('Неизвестная ошибка:', error);
  }
}
```

## Заключение

Контроль типов - мощный механизм TypeScript, который позволяет безопасно работать с объединениями типов, выполняя проверки и сужая типы в различных ветвях кода. Это обеспечивает баланс между гибкостью и безопасностью типов, позволяя разработчикам писать более надежный код с меньшим количеством ошибок. Понимание и умелое использование различных техник сужения типов является ключевым навыком при разработке на TypeScript.

Для более глубокого изучения рекомендуется ознакомиться с [[Совместимость-типов]] и [[Утилиты-типов]].

## Дополнительные ресурсы

- [[Типы-данных]] - основные типы данных в TypeScript
- [[any-и-unknown]] - типы any и unknown
- [[never-и-void]] - типы never и void
- [[Совместимость-типов]] - как TypeScript обрабатывает совместимость типов
- [[Утилиты-типов]] - встроенные утилиты для работы с типами