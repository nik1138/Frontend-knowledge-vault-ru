---
aliases: [Архитектура фреймворков, Архитектура фреймворка]
tags: [typescript, framework, architecture, design-patterns]
---

# Архитектура фреймворков

Архитектура фреймворков определяет структуру, паттерны проектирования и принципы организации кода, которые фреймворки используют для обеспечения структурированной и поддерживаемой разработки приложений. Понимание архитектуры фреймворков позволяет разработчикам эффективно использовать их возможности и создавать масштабируемые приложения.

## Общие архитектурные принципы

### Инверсия управления (IoC)

Инверсия управления - ключевой принцип, лежащий в основе большинства фреймворков. Вместо того чтобы разработчик контролировал поток выполнения, фреймворк управляет этим потоком и вызывает пользовательский код в определенные моменты.

```typescript
// Пример IoC в фреймворке
class Framework {
  private hooks: { [key: string]: Function[] } = {};

  registerHook(name: string, callback: Function) {
    if (!this.hooks[name]) {
      this.hooks[name] = [];
    }
    this.hooks[name].push(callback);
  }

  triggerHook(name: string, ...args: any[]) {
    if (this.hooks[name]) {
      this.hooks[name].forEach(callback => callback(...args));
    }
  }
}

// Пользовательский код регистрирует свои функции
const framework = new Framework();
framework.registerHook('onStart', () => console.log('Приложение запущено'));
framework.registerHook('onEnd', () => console.log('Приложение завершено'));
```

### Внедрение зависимостей (DI)

Многие фреймворки используют внедрение зависимостей для управления зависимостями между компонентами:

```typescript
// Пример DI в NestJS
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
  async findAll(): Promise<User[]> {
    // Логика получения пользователей
    return [];
  }
}

@Injectable()
export class UserController {
  constructor(private userService: UserService) {}
  
  async getUsers() {
    return this.userService.findAll();
  }
}
```

## Архитектура фронтенд-фреймворков

### React - Компонентная архитектура

React использует компонентную архитектуру, где пользовательский интерфейс строится из переиспользуемых компонентов:

```typescript
// Компонент с состоянием
import React, { useState, useEffect } from 'react';

interface UserCardProps {
  userId: number;
}

const UserCard: React.FC<UserCardProps> = ({ userId }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Загрузка данных пользователя
    fetchUser(userId).then(userData => {
      setUser(userData);
      setLoading(false);
    });
  }, [userId]);

  if (loading) return <div>Загрузка...</div>;
  
  return (
    <div className="user-card">
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
};
```

#### Паттерны в React:

- **Контейнеры и презентационные компоненты** - разделение логики и представления
- **Высокоуровневые компоненты (HOC)** - повторное использование логики
- **Хуки** - повторное использование состояния и побочных эффектов

### Angular - Модульная архитектура

Angular использует модульную архитектуру с компонентами, сервисами и директивами:

```typescript
// Angular модуль
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';
import { UserComponent } from './user/user.component';

@NgModule({
  declarations: [
    AppComponent,
    UserComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

#### Архитектурные элементы Angular:

- **Модули (NgModule)** - организуют компоненты, директивы и сервисы
- **Компоненты** - управляют представлениями
- **Сервисы** - содержат бизнес-логику и данные
- **Директивы** - изменяют поведение DOM-элементов

### Vue - Прогрессивная архитектура

Vue предлагает гибкую архитектуру, которую можно использовать постепенно:

```typescript
<template>
  <div class="user-list">
    <UserCard 
      v-for="user in users" 
      :key="user.id" 
      :user="user" 
    />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import UserCard from './UserCard.vue';
import { User } from '@/types/user';

export default defineComponent({
  name: 'UserList',
  components: {
    UserCard
  },
  data() {
    return {
      users: [] as User[],
      loading: true
    };
  },
  async mounted() {
    this.users = await this.fetchUsers();
    this.loading = false;
  },
  methods: {
    async fetchUsers(): Promise<User[]> {
      // Логика загрузки пользователей
      return [];
    }
  }
});
</script>
```

## Архитектура бэкенд-фреймворков

### NestJS - Модульная архитектура

NestJS использует модульную архитектуру, вдохновленную Angular:

```typescript
// Модуль пользователей
import { Module } from '@nestjs/common';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService]
})
export class UserModule {}
```

#### Архитектурные компоненты NestJS:

- **Модули (Modules)** - организуют связанные функции
- **Контроллеры (Controllers)** - обрабатывают HTTP-запросы
- **Сервисы (Providers)** - содержат бизнес-логику
- **Интерцепторы (Interceptors)** - перехватывают запросы/ответы
- **Гварды (Guards)** - обеспечивают авторизацию
- **Пайпы (Pipes)** - валидация и преобразование данных

### Express - Промежуточное ПО (Middleware)

Express использует архитектуру на основе промежуточного программного обеспечения:

```typescript
import express, { Request, Response, NextFunction } from 'express';
import { User } from './models/User';

const app = express();

// Промежуточное ПО для логирования
app.use((req: Request, res: Response, next: NextFunction) => {
  console.log(`${req.method} ${req.path}`);
  next();
});

// Промежуточное ПО для парсинга JSON
app.use(express.json());

// Промежуточное ПО для аутентификации
const authMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // Проверка аутентификации
  if (req.headers.authorization) {
    next();
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
};

// Маршрут с промежуточным ПО
app.get('/users', authMiddleware, (req: Request, res: Response) => {
  const users: User[] = [
    { id: 1, name: 'John', email: 'john@example.com' }
  ];
  res.json(users);
});
```

## Архитектура фуллстек-фреймворков

### Next.js - Архитектура страниц

Next.js использует архитектуру на основе файловой системы:

```
my-app/
├── pages/
│   ├── index.tsx         // Главная страница
│   ├── api/
│   │   └── users.ts      // API маршрут
│   └── users/
│       └── [id].tsx      // Динамическая страница
├── components/
├── styles/
└── types/
```

#### Архитектурные особенности Next.js:

- **Файловая система маршрутов** - автоматическое создание маршрутов
- **API маршруты** - серверные функции в директории api
- **SSR/SSG/ISR** - различные стратегии рендеринга
- **Импорт компонентов** - разделение клиентских и серверных компонентов

## Паттерны проектирования в фреймворках

### MVC (Model-View-Controller)

Многие фреймворки реализуют паттерн MVC или его вариации:

- **Model** - управляет данными и бизнес-логикой
- **View** - отображает данные пользователю
- **Controller** - обрабатывает пользовательский ввод

### MVVM (Model-View-ViewModel)

Используется в Angular и Vue:

- **Model** - источник данных
- **View** - пользовательский интерфейс
- **ViewModel** - связывает View и Model, обеспечивает связывание данных

### Flux/Redux

Используется для управления состоянием в React-приложениях:

```typescript
// Пример Redux с TypeScript
interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
}

const initialState: UserState = {
  users: [],
  loading: false,
  error: null
};

interface FetchUsersAction {
  type: 'FETCH_USERS_REQUEST' | 'FETCH_USERS_SUCCESS' | 'FETCH_USERS_FAILURE';
  payload?: User[];
  error?: string;
}

type UserAction = FetchUsersAction;

const userReducer = (state = initialState, action: UserAction): UserState => {
  switch (action.type) {
    case 'FETCH_USERS_REQUEST':
      return { ...state, loading: true, error: null };
    case 'FETCH_USERS_SUCCESS':
      return { ...state, loading: false, users: action.payload || [] };
    case 'FETCH_USERS_FAILURE':
      return { ...state, loading: false, error: action.error || 'Ошибка' };
    default:
      return state;
  }
};
```

## Архитектурные шаблоны для масштабируемых приложений

### Модульная архитектура

Разделение приложения на независимые модули:

```typescript
// Пример структуры модуля
user/
├── user.module.ts
├── user.controller.ts
├── user.service.ts
├── user.repository.ts
├── entities/
│   └── user.entity.ts
├── dto/
│   ├── create-user.dto.ts
│   └── update-user.dto.ts
└── interfaces/
    └── user.interface.ts
```

### Чистая архитектура (Clean Architecture)

Разделение на слои с четкими границами:

```
┌─────────────────┐
│   Presentation  │
├─────────────────┤
│   Application   │
├─────────────────┤
│   Domain        │
├─────────────────┤
│   Infrastructure│
└─────────────────┘
```

## Лучшие практики архитектуры

1. **Разделение ответственности** - каждый компонент должен иметь одну четко определенную задачу
2. **Инкапсуляция** - скрывайте внутреннюю реализацию и предоставляйте четкий интерфейс
3. **Тестируемость** - проектируйте компоненты так, чтобы их можно было легко тестировать
4. **Масштабируемость** - архитектура должна позволять легко добавлять новые функции
5. **Согласованность** - используйте единые паттерны и подходы по всему приложению

## Заключение

Архитектура фреймворков предоставляет структурированный подход к разработке приложений. Понимание архитектурных принципов конкретного фреймворка позволяет эффективно использовать его возможности и создавать качественные, поддерживаемые приложения.

Для рекомендаций по выбору фреймворка см. [[Выбор-фреймворка]].