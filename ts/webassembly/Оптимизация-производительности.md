---
aliases: [Оптимизация производительности WASM, WASM производительность]
tags: [typescript, webassembly, wasm, производительность, оптимизация]
---

# Оптимизация производительности

Оптимизация производительности WebAssembly (WASM) критически важна для достижения максимальной эффективности вычислений. WASM предлагает близкую к нативной производительность, но требует правильного подхода к разработке и оптимизации кода.

## Основы оптимизации WASM

WebAssembly изначально спроектирован для высокой производительности. Однако, чтобы полностью использовать его возможности, необходимо учитывать особенности его работы и оптимизировать как WASM код, так и взаимодействие с JavaScript/TypeScript.

### Компиляция с оптимизациями

При компиляции WASM кода используйте соответствующие флаги оптимизации:

```bash
# Для Rust
cargo build --release --target wasm32-unknown-unknown

# Для AssemblyScript
asc assembly/index.ts -b build/optimized.wasm -t build/optimized.wat --optimize --optimize-level 3 --shrink-level 2

# Для C/C++ с Emscripten
emcc -O3 -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 input.cpp -o output.js
```

### Настройка Cargo.toml для оптимизации (Rust)

```toml
[profile.release]
lto = true              # Link Time Optimization
opt-level = "s"         # или "z" для минимального размера, "2" или "3" для производительности
codegen-units = 1       # Позволяет лучшие оптимизации, но увеличивает время сборки
panic = "abort"         # Меньший размер бинарного файла
strip = true            # Удаление отладочной информации
```

## Оптимизация алгоритмов

### Выбор эффективных алгоритмов

WASM особенно эффективен для вычислительно сложных задач. Используйте подходящие алгоритмы:

```rust
// Эффективная реализация сортировки
#[no_mangle]
pub extern "C" fn quicksort(arr: *mut i32, low: i32, high: i32) {
    if low < high {
        let pi = partition(arr, low, high);
        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}

fn partition(arr: *mut i32, low: i32, high: i32) -> i32 {
    unsafe {
        let pivot = *arr.offset(high as isize);
        let mut i = low - 1;

        for j in low..high {
            if *arr.offset(j as isize) <= pivot {
                i += 1;
                let temp = *arr.offset(i as isize);
                *arr.offset(i as isize) = *arr.offset(j as isize);
                *arr.offset(j as isize) = temp;
            }
        }

        let temp = *arr.offset((i + 1) as isize);
        *arr.offset((i + 1) as isize) = *arr.offset(high as isize);
        *arr.offset(high as isize) = temp;
        i + 1
    }
}
```

### Избегайте ненужных аллокаций

```rust
// Плохо: создание новых векторов в цикле
#[no_mangle]
pub extern "C" fn bad_example(data: &[f64]) -> Vec<f64> {
    let mut result = Vec::new();
    for value in data {
        let new_value = expensive_computation(*value);
        result.push(new_value);  // Новая аллокация на каждой итерации
    }
    result
}

// Хорошо: предварительное выделение памяти
#[no_mangle]
pub extern "C" fn good_example(data: &[f64]) -> Vec<f64> {
    let mut result = Vec::with_capacity(data.len());  // Предварительное выделение
    for value in data {
        let new_value = expensive_computation(*value);
        result.push(new_value);  // Нет новых аллокаций
    }
    result
}

fn expensive_computation(x: f64) -> f64 {
    x * x + 2.0 * x + 1.0
}
```

## Оптимизация памяти

### Использование стека вместо кучи

```rust
// Используйте стековые массивы для небольших данных
#[no_mangle]
pub extern "C" fn process_small_array(input: [f64; 10]) -> f64 {
    input.iter().sum()
}

// Для больших массивов используйте передачу по ссылке
#[no_mangle]
pub extern "C" fn process_large_array(input: &[f64]) -> f64 {
    input.iter().sum()
}
```

### Эффективная работа с буферами

```typescript
// TypeScript: эффективная передача данных в WASM
class OptimizedWasmProcessor {
  private wasmExports: WebAssembly.Exports;
  private memory: WebAssembly.Memory;
  private reusableBuffer: Float64Array | null = null;

  constructor(wasmInstance: WebAssembly.Instance) {
    this.wasmExports = wasmInstance.exports as any;
    this.memory = this.wasmExports.memory as WebAssembly.Memory;
  }

  // Использование повторно используемых буферов
  processArray(data: number[]): number[] {
    // Проверяем, нужен ли перерасчет размера буфера
    if (!this.reusableBuffer || this.reusableBuffer.length < data.length) {
      // Выделяем новый буфер с запасом
      const newSize = Math.ceil(data.length * 1.2);
      const ptr = (this.wasmExports.allocate_memory as Function)(newSize * 8); // 8 байт на f64
      this.reusableBuffer = new Float64Array(this.memory.buffer, ptr, newSize);
    }

    // Копируем данные в буфер
    this.reusableBuffer.set(data, 0);

    // Вызываем WASM функцию
    const result = (this.wasmExports.process_array as Function)(
      this.reusableBuffer.byteOffset,
      data.length
    );

    // Возвращаем результат
    return Array.from(this.reusableBuffer.slice(0, data.length));
  }
}
```

## Минимизация вызовов между JS и WASM

Каждый вызов между JavaScript и WASM имеет накладные расходы. Минимизируйте количество вызовов:

```typescript
// Плохо: много вызовов для одной операции
async function inefficientApproach(wasmExports: any, data: number[]) {
  const results = [];
  for (const value of data) {
    // Много вызовов WASM функции
    const result = wasmExports.process_single_value(value);
    results.push(result);
  }
  return results;
}

// Хорошо: один вызов для всей операции
async function efficientApproach(wasmExports: any, data: number[]) {
  // Один вызов WASM функции для обработки всех данных
  const inputPtr = allocateWasmMemory(data.length * 8);
  const inputArray = new Float64Array(wasmExports.memory.buffer, inputPtr, data.length);
  inputArray.set(data);
  
  const outputPtr = wasmExports.process_batch(inputPtr, data.length);
  const outputArray = new Float64Array(wasmExports.memory.buffer, outputPtr, data.length);
  
  return Array.from(outputArray);
}
```

## Оптимизация SIMD

WebAssembly поддерживает SIMD (Single Instruction, Multiple Data) для параллельной обработки данных:

```rust
// Использование SIMD для параллельной обработки
#[cfg(target_feature = "simd128")]
use core::arch::wasm32::*;

#[no_mangle]
#[cfg(target_feature = "simd128")]
pub extern "C" fn simd_add_arrays(a: *const f32, b: *const f32, result: *mut f32, len: usize) {
    let mut i = 0;
    while i <= len - 4 {
        unsafe {
            let va = v128_load(a.add(i) as *const v128);
            let vb = v128_load(b.add(i) as *const v128);
            let vr = f32x4_add(va, vb);
            v128_store(result.add(i) as *mut v128, vr);
        }
        i += 4;
    }
    
    // Обработка оставшихся элементов
    for j in i..len {
        unsafe {
            *result.add(j) = *a.add(j) + *b.add(j);
        }
    }
}
```

## Профилирование и измерение производительности

### Использование профилировщиков

```typescript
// Измерение производительности WASM функций
class PerformanceProfiler {
  static measureWasmFunction<T>(
    fn: (...args: any[]) => T,
    ...args: any[]
  ): { result: T; executionTime: number } {
    const start = performance.now();
    const result = fn(...args);
    const end = performance.now();
    return { result, executionTime: end - start };
  }

  static async compareJsVsWasm(
    jsFunction: Function,
    wasmFunction: Function,
    testData: any[]
  ) {
    // Измерение производительности JavaScript функции
    const jsResult = this.measureWasmFunction(jsFunction, testData);
    
    // Измерение производительности WASM функции
    const wasmResult = this.measureWasmFunction(wasmFunction, testData);
    
    console.log(`JS execution time: ${jsResult.executionTime}ms`);
    console.log(`WASM execution time: ${wasmResult.executionTime}ms`);
    console.log(`Speed improvement: ${(jsResult.executionTime / wasmResult.executionTime).toFixed(2)}x`);
    
    return {
      js: jsResult,
      wasm: wasmResult,
      improvement: jsResult.executionTime / wasmResult.executionTime
    };
  }
}

// Пример использования
async function performanceTest() {
  // Подготовка тестовых данных
  const testData = Array.from({ length: 1000000 }, (_, i) => i * 0.1);
  
  // Сравнение производительности
  const results = await PerformanceProfiler.compareJsVsWasm(
    (data) => data.map(x => x * x + 2 * x + 1), // JS функция
    (wasmExports.process_array as Function),     // WASM функция
    testData
  );
  
  console.log('Performance results:', results);
}
```

## Оптимизация загрузки WASM

### Предварительная загрузка

```typescript
// Оптимизация загрузки WASM модуля
class OptimizedWasmLoader {
  private static wasmModule: WebAssembly.Instance | null = null;
  private static loadPromise: Promise<WebAssembly.Instance> | null = null;

  // Предварительная загрузка WASM модуля
  static async preloadWasm(wasmUrl: string): Promise<void> {
    if (this.loadPromise) {
      return this.loadPromise.then(() => {});
    }

    this.loadPromise = fetch(wasmUrl)
      .then(response => response.arrayBuffer())
      .then(bytes => WebAssembly.instantiate(bytes))
      .then(result => {
        this.wasmModule = result.instance;
        return this.wasmModule;
      });

    await this.loadPromise;
  }

  // Получение загруженного модуля
  static async getWasm(): Promise<WebAssembly.Instance> {
    if (this.wasmModule) {
      return this.wasmModule;
    }

    if (this.loadPromise) {
      return this.loadPromise;
    }

    throw new Error('WASM module not preloaded');
  }
}

// Использование
async function initApp() {
  // Предварительно загружаем WASM при старте приложения
  await OptimizedWasmLoader.preloadWasm('/optimized-computations.wasm');
  
  // Теперь WASM модуль доступен без задержки
  const wasm = await OptimizedWasmLoader.getWasm();
  // Продолжаем выполнение приложения
}
```

## Использование Web Workers

Для избежания блокировки основного потока:

```typescript
// WASM в Web Worker
class WasmWorker {
  private worker: Worker;
  private messageId: number = 0;
  private pendingRequests: Map<number, (result: any) => void> = new Map();

  constructor(workerScriptUrl: string) {
    this.worker = new Worker(workerScriptUrl);
    this.worker.onmessage = (event) => {
      const { id, result } = event.data;
      const callback = this.pendingRequests.get(id);
      if (callback) {
        callback(result);
        this.pendingRequests.delete(id);
      }
    };
  }

  async callWasmFunction(fnName: string, ...args: any[]): Promise<any> {
    return new Promise((resolve) => {
      const id = ++this.messageId;
      this.pendingRequests.set(id, resolve);
      this.worker.postMessage({ id, fnName, args });
    });
  }

  terminate() {
    this.worker.terminate();
  }
}

// В Web Worker (wasm-worker.js)
/*
let wasmExports;

async function loadWasm() {
  const wasmModule = await WebAssembly.instantiateStreaming(fetch('/computations.wasm'));
  wasmExports = wasmModule.instance.exports;
}

self.onmessage = async function(event) {
  const { id, fnName, args } = event.data;
  
  if (!wasmExports) {
    await loadWasm();
  }
  
  const result = wasmExports[fnName](...args);
  self.postMessage({ id, result });
};
*/
```

## Best Practices

1. **Используйте оптимизационные флаги при компиляции** - они могут значительно улучшить производительность
2. **Минимизируйте вызовы между JS и WASM** - объединяйте операции в более крупные вызовы
3. **Избегайте ненужных аллокаций в WASM коде** - используйте стек для небольших данных
4. **Используйте SIMD для параллельной обработки** - когда это применимо
5. **Предварительно загружайте WASM модули** - чтобы избежать задержек при первом использовании
6. **Используйте профилирование для оптимизации** - измеряйте реальную производительность
7. **Рассмотрите использование Web Workers** - для избежания блокировки основного потока

## Заключение

Оптимизация производительности WebAssembly требует комплексного подхода, включающего оптимизацию как WASM кода, так и взаимодействия с JavaScript. Правильное использование инструментов и подходов может привести к значительному улучшению производительности веб-приложений.

См. также:
- [[AssemblyScript]]
- [[Rust-и-TypeScript]]
- [[Взаимодействие-с-WASM]]
- [[Отладка-WASM]]