---
aliases: [Коммуникация между сервисами, Взаимодействие сервисов, Сервис-к-сервис]
tags: [microservices, communication, messaging, http, grpc, events]
---

# Взаимодействие между микросервисами

## Обзор

Взаимодействие между микросервисами является ключевым аспектом микросервисной архитектуры. Существует несколько подходов к коммуникации, каждый из которых имеет свои преимущества и недостатки в зависимости от конкретной ситуации.

## Типы взаимодействия

### 1. Синхронное взаимодействие

Синхронное взаимодействие подразумевает прямой вызов одного сервиса другим с ожиданием ответа.

#### REST API

```typescript
// user-service/client.ts
import axios, { AxiosInstance } from 'axios';

export interface OrderServiceClientInterface {
  getUserOrders(userId: string): Promise<Order[]>;
  createOrder(orderData: CreateOrderDto): Promise<Order>;
}

export class OrderServiceClient implements OrderServiceClientInterface {
  private httpClient: AxiosInstance;
  private readonly baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
    this.httpClient = axios.create({
      baseURL: this.baseUrl,
      timeout: 5000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }

  async getUserOrders(userId: string): Promise<Order[]> {
    try {
      const response = await this.httpClient.get(`/api/orders/user/${userId}`);
      return response.data.data;
    } catch (error) {
      throw new Error(`Failed to fetch user orders: ${error.message}`);
    }
  }

  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    try {
      const response = await this.httpClient.post('/api/orders', orderData);
      return response.data.data;
    } catch (error) {
      throw new Error(`Failed to create order: ${error.message}`);
    }
  }
}
```

#### gRPC

```typescript
// order-service/proto/order.proto
syntax = "proto3";

package order;

service OrderService {
  rpc GetUserOrders(GetUserOrdersRequest) returns (GetUserOrdersResponse);
  rpc CreateOrder(CreateOrderRequest) returns (CreateOrderResponse);
}

message GetUserOrdersRequest {
  string user_id = 1;
}

message GetUserOrdersResponse {
  repeated Order orders = 1;
}

message CreateOrderRequest {
  string user_id = 1;
  repeated OrderItem items = 2;
}

message CreateOrderResponse {
  Order order = 1;
}

message Order {
  string id = 1;
  string user_id = 2;
  repeated OrderItem items = 3;
  OrderStatus status = 4;
  double total_amount = 5;
}

message OrderItem {
  string product_id = 1;
  int32 quantity = 2;
  double price = 3;
}

enum OrderStatus {
  PENDING = 0;
  CONFIRMED = 1;
  SHIPPED = 2;
  DELIVERED = 3;
  CANCELLED = 4;
}
```

```typescript
// order-service/client.ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import { promisify } from 'util';

const PROTO_PATH = __dirname + '/order.proto';

const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true,
});

const orderProto = grpc.loadPackageDefinition(packageDefinition).order as any;

export class GrpcOrderServiceClient {
  private client: any;

  constructor(host: string) {
    this.client = new orderProto.OrderService(
      host,
      grpc.credentials.createInsecure()
    );
  }

  async getUserOrders(userId: string): Promise<Order[]> {
    const getUserOrders = promisify(this.client.getUserOrders).bind(this.client);
    const response = await getUserOrders({ user_id: userId });
    return response.orders;
  }

  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    const createOrder = promisify(this.client.createOrder).bind(this.client);
    const response = await createOrder(orderData);
    return response.order;
  }
}
```

### 2. Асинхронное взаимодействие

Асинхронное взаимодействие не требует немедленного ответа и часто используется для обеспечения надежности и масштабируемости.

#### Использование Message Broker (RabbitMQ/Redis)

```typescript
// event-bus/rabbitmq-event-bus.ts
import amqp, { Connection, Channel } from 'amqplib';
import { BaseEvent } from '../types/events.types';

export class RabbitMQEventBus {
  private connection: Connection | null = null;
  private channel: Channel | null = null;
  private eventHandlers: Map<string, ((event: BaseEvent) => Promise<void>)[]> = new Map();

  async connect(): Promise<void> {
    this.connection = await amqp.connect('amqp://localhost');
    this.channel = await this.connection.createChannel();
    
    // Убедимся, что exchange существует
    await this.channel.assertExchange('microservices_events', 'topic', { durable: true });
  }

  async publish<T extends BaseEvent>(event: T): Promise<void> {
    if (!this.channel) {
      throw new Error('Event bus not connected');
    }

    const routingKey = event.type;
    const message = JSON.stringify(event);
    
    this.channel.publish('microservices_events', routingKey, Buffer.from(message));
  }

  async subscribe<T extends BaseEvent>(
    eventType: string,
    handler: (event: T) => Promise<void>
  ): Promise<void> {
    if (!this.channel) {
      throw new Error('Event bus not connected');
    }

    // Создаем очередь для подписчика
    const queue = await this.channel.assertQueue('', { exclusive: true });
    
    // Привязываем очередь к событию
    await this.channel.bindQueue(queue.queue, 'microservices_events', eventType);
    
    // Устанавливаем обработчик сообщений
    this.channel.consume(queue.queue, async (msg) => {
      if (msg) {
        try {
          const event: T = JSON.parse(msg.content.toString());
          await handler(event);
          this.channel.ack(msg);
        } catch (error) {
          console.error(`Error processing event ${eventType}:`, error);
          this.channel.nack(msg, false, true); // Повторная отправка
        }
      }
    });
  }
}
```

#### Использование Kafka

```typescript
// event-bus/kafka-event-bus.ts
import { Kafka, Producer, Consumer, Admin } from 'kafkajs';

export class KafkaEventBus {
  private kafka: Kafka;
  private producer: Producer;
  private consumer: Consumer;
  private admin: Admin;

  constructor(brokers: string[]) {
    this.kafka = new Kafka({
      clientId: 'microservices-event-bus',
      brokers,
    });

    this.producer = this.kafka.producer();
    this.consumer = this.kafka.consumer({ groupId: 'microservices-group' });
    this.admin = this.kafka.admin();
  }

  async connect(): Promise<void> {
    await this.producer.connect();
    await this.consumer.connect();
    await this.admin.connect();
  }

  async publish<T extends BaseEvent>(event: T, topic: string): Promise<void> {
    await this.producer.send({
      topic,
      messages: [
        {
          key: event.id,
          value: JSON.stringify(event),
          timestamp: event.timestamp.getTime().toString(),
        },
      ],
    });
  }

  async subscribe<T extends BaseEvent>(
    eventType: string,
    handler: (event: T) => Promise<void>
  ): Promise<void> {
    await this.consumer.subscribe({ topic: eventType, fromBeginning: true });

    await this.consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        try {
          if (message.value) {
            const event: T = JSON.parse(message.value.toString());
            await handler(event);
          }
        } catch (error) {
          console.error(`Error processing message from topic ${topic}:`, error);
        }
      },
    });
  }
}
```

## Паттерны взаимодействия

### 1. Request/Reply

Самый простой паттерн, когда один сервис отправляет запрос другому и ожидает ответа.

```typescript
// notification-service/client.ts
export class NotificationServiceClient {
  private httpClient: AxiosInstance;

  constructor(private baseUrl: string) {
    this.httpClient = axios.create({
      baseURL: this.baseUrl,
    });
  }

  async sendNotification(userId: string, message: string): Promise<boolean> {
    try {
      const response = await this.httpClient.post('/api/notifications', {
        userId,
        message,
        type: 'info',
      });
      return response.data.success;
    } catch (error) {
      console.error('Failed to send notification:', error);
      return false;
    }
  }
}

// Использование в user-service
export class UserService {
  private notificationClient: NotificationServiceClient;

  constructor() {
    this.notificationClient = new NotificationServiceClient('http://notification-service:3000');
  }

  async createUser(userData: CreateUserDto): Promise<User> {
    const user = await this.userRepository.create(userData);
    
    // Асинхронное уведомление
    this.notificationClient.sendNotification(
      user.id,
      `Добро пожаловать, ${user.firstName}!`
    ).catch(console.error);
    
    return user;
  }
}
```

### 2. Publish/Subscribe

Паттерн, при котором издатель отправляет сообщения в канал, а подписчики получают эти сообщения.

```typescript
// event-handlers/user-created.handler.ts
import { UserCreatedEvent } from '../types/events.types';

export class UserCreatedEventHandler {
  constructor(
    private notificationService: NotificationService,
    private emailService: EmailService,
    private analyticsService: AnalyticsService
  ) {}

  async handle(event: UserCreatedEvent): Promise<void> {
    // Отправка уведомления
    await this.notificationService.sendWelcomeNotification(event.data.email);
    
    // Отправка приветственного письма
    await this.emailService.sendWelcomeEmail(event.data.email, event.data.firstName);
    
    // Логирование в систему аналитики
    await this.analyticsService.logUserRegistration(event.data.email);
  }
}
```

### 3. Saga

Паттерн для управления распределенными транзакциями через последовательность локальных транзакций.

```typescript
// order-saga/order-saga.ts
export interface OrderSagaState {
  orderId: string;
  userId: string;
  paymentId?: string;
  inventoryReserved?: boolean;
  orderConfirmed?: boolean;
}

export class OrderSaga {
  constructor(
    private paymentService: PaymentService,
    private inventoryService: InventoryService,
    private orderService: OrderService
  ) {}

  async execute(orderData: CreateOrderDto): Promise<void> {
    const state: OrderSagaState = {
      orderId: generateId(),
      userId: orderData.userId,
    };

    try {
      // Шаг 1: Резервирование инвентаря
      await this.inventoryService.reserveItems(orderData.items);
      state.inventoryReserved = true;

      // Шаг 2: Обработка платежа
      const paymentResult = await this.paymentService.processPayment(
        orderData.userId,
        orderData.totalAmount
      );
      state.paymentId = paymentResult.id;

      // Шаг 3: Подтверждение заказа
      await this.orderService.confirmOrder(state.orderId);
      state.orderConfirmed = true;

    } catch (error) {
      // Компенсация выполненных шагов
      await this.compensate(state, error);
      throw error;
    }
  }

  private async compensate(state: OrderSagaState, error: Error): Promise<void> {
    // Компенсация в обратном порядке
    if (state.orderConfirmed) {
      await this.orderService.cancelOrder(state.orderId);
    }

    if (state.paymentId) {
      await this.paymentService.refundPayment(state.paymentId);
    }

    if (state.inventoryReserved) {
      await this.inventoryService.releaseItems(state.orderId);
    }
  }
}
```

## Обработка ошибок и отказоустойчивость

### Circuit Breaker

```typescript
// circuit-breaker/circuit-breaker.ts
export enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN',
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount: number = 0;
  private lastFailureTime: Date | null = null;
  private readonly failureThreshold: number = 5;
  private readonly timeout: number = 60000; // 1 minute
  private readonly halfOpenSuccessThreshold: number = 3;

  async call<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (this.isTimeoutExpired()) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    if (this.state === CircuitState.HALF_OPEN) {
      this.failureCount++;
      if (this.failureCount >= this.halfOpenSuccessThreshold) {
        this.reset();
      }
    } else {
      this.reset();
    }
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = new Date();

    if (this.failureCount >= this.failureThreshold) {
      this.state = CircuitState.OPEN;
    }
  }

  private isTimeoutExpired(): boolean {
    if (!this.lastFailureTime) return true;
    return Date.now() - this.lastFailureTime.getTime() > this.timeout;
  }

  private reset(): void {
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = CircuitState.CLOSED;
  }
}
```

### Retry с экспоненциальной задержкой

```typescript
// utils/retry.ts
export async function retry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      if (attempt === maxRetries) {
        break;
      }

      // Экспоненциальная задержка
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError;
}

// Использование в сервисе
export class UserService {
  private orderServiceClient: OrderServiceClient;

  async getUserOrdersWithRetry(userId: string): Promise<Order[]> {
    return retry(() => this.orderServiceClient.getUserOrders(userId), 3, 1000);
  }
}
```

## Лучшие практики

1. **Используйте асинхронное взаимодействие** - для повышения надежности и масштабируемости
2. **Реализуйте Circuit Breaker** - для предотвращения каскадных сбоев
3. **Добавьте таймауты** - для избежания зависания запросов
4. **Используйте корреляционные ID** - для трассировки запросов между сервисами
5. **Реализуйте idempotency** - для безопасного повторного выполнения операций

```typescript
// utils/correlation-id.ts
import { v4 as uuidv4 } from 'uuid';

export class CorrelationIdMiddleware {
  static async addCorrelationId(req: any, res: any, next: any) {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    req.correlationId = correlationId;
    res.setHeader('X-Correlation-ID', correlationId);
    next();
  }
}
```

## Связанные темы

- [[Архитектура-микросервисов]]
- [[Типизация-API]]
- [[Мониторинг-микросервисов]]
- [[Тестирование-микросервисов]]
- [[Событийно-ориентированная-архитектура]]
- [[Распределенные-транзакции]]