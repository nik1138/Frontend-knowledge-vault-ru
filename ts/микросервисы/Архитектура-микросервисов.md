---
aliases: [Микросервисная архитектура, Архитектура сервисов]
tags: [architecture, microservices, typescript, design-patterns]
---

# Архитектура микросервисов в TypeScript

## Обзор

Архитектура микросервисов - это подход к разработке приложений, при котором крупное приложение разбивается на несколько небольших, независимо развертываемых сервисов. Каждый сервис отвечает за определенную функциональность и взаимодействует с другими сервисами через четко определенные интерфейсы.

## Принципы микросервисной архитектуры

### 1. Независимость сервисов

Каждый микросервис должен быть:
- Независимо развертываемым
- Независимо масштабируемым
- Иметь собственную базу данных (принцип "Database per Service")

```typescript
// Пример сервиса пользователей
export class UserService {
  private userRepository: UserRepository;
  
  constructor() {
    this.userRepository = new UserRepository();
  }
  
  async getUserById(id: string): Promise<User> {
    return await this.userRepository.findById(id);
  }
  
  async createUser(userData: CreateUserDto): Promise<User> {
    // Валидация данных
    const validatedData = validateUserData(userData);
    return await this.userRepository.create(validatedData);
  }
}
```

### 2. Четко определенные API

Каждый сервис должен предоставлять четко определенный API для взаимодействия с другими сервисами:

```typescript
// Интерфейс для взаимодействия с сервисом заказов
export interface OrderServiceInterface {
  createOrder(orderData: OrderDto): Promise<Order>;
  getOrderById(orderId: string): Promise<Order | null>;
  updateOrderStatus(orderId: string, status: OrderStatus): Promise<Order>;
  getUserOrders(userId: string): Promise<Order[]>;
}
```

### 3. Распределенное управление данными

Каждый микросервис имеет свою собственную базу данных:

```typescript
// UserRepository для сервиса пользователей
export class UserRepository {
  private db: DatabaseConnection;
  
  constructor() {
    this.db = new DatabaseConnection('users-db');
  }
  
  async findById(id: string): Promise<User> {
    // Запрос к своей базе данных
    return await this.db.query('SELECT * FROM users WHERE id = ?', [id]);
  }
  
  async create(userData: CreateUserDto): Promise<User> {
    return await this.db.query('INSERT INTO users SET ?', [userData]);
  }
}
```

## Структура проекта

```
microservices-project/
├── services/
│   ├── user-service/
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   ├── services/
│   │   │   ├── repositories/
│   │   │   └── main.ts
│   │   ├── Dockerfile
│   │   └── package.json
│   ├── order-service/
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   ├── services/
│   │   │   ├── repositories/
│   │   │   └── main.ts
│   │   ├── Dockerfile
│   │   └── package.json
│   └── notification-service/
│       ├── src/
│       │   ├── controllers/
│       │   ├── services/
│       │   ├── repositories/
│       │   └── main.ts
│       ├── Dockerfile
│       └── package.json
├── shared/
│   ├── dto/
│   ├── types/
│   └── utils/
└── docker-compose.yml
```

## Паттерны проектирования для микросервисов

### 1. API Gateway

Шлюз API обрабатывает все клиентские запросы и направляет их соответствующим микросервисам:

```typescript
import express from 'express';
import { UserService } from './services/user-service';
import { OrderService } from './services/order-service';

const app = express();

// Пример API Gateway
class ApiGateway {
  private userService: UserService;
  private orderService: OrderService;
  
  constructor() {
    this.userService = new UserService();
    this.orderService = new OrderService();
  }
  
  setupRoutes() {
    app.get('/api/users/:id', async (req, res) => {
      try {
        const user = await this.userService.getUserById(req.params.id);
        res.json(user);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    app.get('/api/orders/:id', async (req, res) => {
      try {
        const order = await this.orderService.getOrderById(req.params.id);
        res.json(order);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
  }
}
```

### 2. Circuit Breaker

Паттерн Circuit Breaker предотвращает каскадные сбои в распределенной системе:

```typescript
export class CircuitBreaker {
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  private failureCount: number = 0;
  private lastFailureTime: Date | null = null;
  private readonly failureThreshold: number = 5;
  private readonly timeout: number = 60000; // 1 minute
  
  async call<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (this.isTimeoutExpired()) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = new Date();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
  
  private isTimeoutExpired(): boolean {
    if (!this.lastFailureTime) return true;
    return Date.now() - this.lastFailureTime.getTime() > this.timeout;
  }
}
```

### 3. Service Discovery

Для динамического обнаружения сервисов можно использовать решения вроде Consul или Eureka:

```typescript
export class ServiceDiscovery {
  private services: Map<string, ServiceInstance[]> = new Map();
  
  async registerService(serviceName: string, instance: ServiceInstance): Promise<void> {
    const instances = this.services.get(serviceName) || [];
    instances.push(instance);
    this.services.set(serviceName, instances);
  }
  
  async discoverService(serviceName: string): Promise<ServiceInstance | null> {
    const instances = this.services.get(serviceName);
    if (!instances || instances.length === 0) {
      return null;
    }
    
    // Выбор случайного инстанса (round-robin)
    const randomIndex = Math.floor(Math.random() * instances.length);
    return instances[randomIndex];
  }
}

interface ServiceInstance {
  id: string;
  host: string;
  port: number;
  healthCheckUrl: string;
}
```

## Преимущества и недостатки

### Преимущества
- **Независимая разработка и развертывание** - команды могут работать независимо
- **Технологическая гетерогенность** - возможность использовать разные технологии
- **Масштабируемость** - можно масштабировать только нужные компоненты
- **Отказоустойчивость** - сбой одного сервиса не приводит к сбою всей системы

### Недостатки
- **Сложность управления** - больше сервисов требует больше управления
- **Сетевые задержки** - взаимодействие между сервисами происходит по сети
- **Сложность отладки** - сложнее отслеживать ошибки в распределенной системе
- **Распределенные транзакции** - сложнее обеспечить согласованность данных

## Лучшие практики

1. **Используйте контейнеризацию** - Docker упрощает развертывание и масштабирование
2. **Определите границы сервисов** - используйте принципы Domain-Driven Design
3. **Реализуйте мониторинг и логирование** - централизованные логи помогают в отладке
4. **Используйте асинхронное взаимодействие** - сообщения и события вместо прямых вызовов
5. **Обеспечьте согласованность данных** - используйте Saga паттерн для распределенных транзакций

## Связанные темы

- [[Типизация-API]]
- [[Взаимодействие-между-сервисами]]
- [[Мониторинг-микросервисов]]
- [[Тестирование-микросервисов]]
- [[Архитектурные-шаблоны]]
- [[Domain-Driven-Design]]