---
aliases: [Мониторинг сервисов, Наблюдаемость, Telemetry]
tags: [monitoring, observability, logging, metrics, tracing, prometheus, grafana]
---

# Мониторинг микросервисов

## Обзор

Мониторинг микросервисов - это критически важный аспект управления распределенными системами. Он включает в себя сбор, анализ и визуализацию метрик, логов и трейсов для обеспечения надежности, производительности и безопасности системы.

## Основные компоненты мониторинга

### 1. Логирование

Логирование позволяет отслеживать события и ошибки в системе.

#### Структурированное логирование с Winston

```typescript
// logger/winston-logger.ts
import winston, { Logger } from 'winston';
import { Request, Response, NextFunction } from 'express';

// Формат логов в JSON для лучшей обработки
const jsonFormatter = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

export class LoggerService {
  private logger: Logger;

  constructor(serviceName: string) {
    this.logger = winston.createLogger({
      level: 'info',
      format: jsonFormatter,
      defaultMeta: { service: serviceName },
      transports: [
        // Логирование в файл
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' }),
        // Логирование в консоль
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        })
      ]
    });
  }

  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }

  error(message: string, error?: Error | any): void {
    this.logger.error(message, error);
  }

  warn(message: string, meta?: any): void {
    this.logger.warn(message, meta);
  }

  debug(message: string, meta?: any): void {
    this.logger.debug(message, meta);
  }
}

// Middleware для логирования HTTP запросов
export function httpLogger(logger: LoggerService) {
  return (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    
    res.on('finish', () => {
      const duration = Date.now() - startTime;
      logger.info('HTTP Request', {
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration,
        userAgent: req.get('User-Agent'),
        correlationId: req.headers['x-correlation-id']
      });
    });
    
    next();
  };
}
```

#### Централизованное логирование с ELK Stack

```typescript
// logger/elk-logger.ts
import winston from 'winston';
import { ElasticsearchTransport } from 'winston-elasticsearch';

export class ELKLogger {
  private logger: winston.Logger;

  constructor(serviceName: string, elasticsearchUrl: string) {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new ElasticsearchTransport({
          level: 'info',
          clientOpts: {
            node: elasticsearchUrl,
          },
          index: `${serviceName.toLowerCase()}-${new Date().toISOString().split('T')[0]}`,
        })
      ]
    });
  }

  log(level: string, message: string, meta?: any): void {
    this.logger.log(level, message, meta);
  }

  error(message: string, error?: Error | any): void {
    this.logger.error(message, error);
  }

  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }
}
```

### 2. Метрики

Сбор метрик позволяет отслеживать производительность и здоровье сервисов.

#### Prometheus метрики

```typescript
// metrics/prometheus-metrics.ts
import client, { Histogram, Counter, Gauge } from 'prom-client';
import express from 'express';

export class MetricsService {
  private httpRequestDuration: Histogram<string>;
  private httpRequestTotal: Counter<string>;
  private activeConnections: Gauge<string>;
  private customGauge: Gauge<string>;

  constructor() {
    // Гистограмма для измерения времени выполнения HTTP запросов
    this.httpRequestDuration = new client.Histogram({
      name: 'http_request_duration_seconds',
      help: 'Duration of HTTP requests in seconds',
      labelNames: ['method', 'route', 'status_code'],
      buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
    });

    // Счетчик для подсчета HTTP запросов
    this.httpRequestTotal = new client.Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'route', 'status_code']
    });

    // Гейдж для отслеживания активных соединений
    this.activeConnections = new client.Gauge({
      name: 'active_connections',
      help: 'Number of active connections'
    });

    // Регистрация метрик
    client.register.registerMetric(this.httpRequestDuration);
    client.register.registerMetric(this.httpRequestTotal);
    client.register.registerMetric(this.activeConnections);
  }

  // Регистрация middleware для сбора метрик
  registerMetricsMiddleware(app: express.Application): void {
    app.use((req, res, next) => {
      const start = Date.now();
      
      res.on('finish', () => {
        const duration = (Date.now() - start) / 1000; // в секундах
        
        // Обновление метрик
        this.httpRequestDuration
          .labels(req.method, req.route?.path || req.path, res.statusCode.toString())
          .observe(duration);
          
        this.httpRequestTotal
          .labels(req.method, req.route?.path || req.path, res.statusCode.toString())
          .inc();
      });
      
      next();
    });
  }

  // Методы для обновления кастомных метрик
  incrementActiveConnections(): void {
    this.activeConnections.inc();
  }

  decrementActiveConnections(): void {
    this.activeConnections.dec();
  }

  setCustomGauge(value: number, labels?: Record<string, string>): void {
    if (labels) {
      this.customGauge.labels(labels).set(value);
    } else {
      this.customGauge.set(value);
    }
  }
}

// Экспорт эндпоинта для Prometheus
export function registerMetricsEndpoint(app: express.Application): void {
  app.get('/metrics', async (req, res) => {
    try {
      res.set('Content-Type', client.register.contentType);
      res.end(await client.register.metrics());
    } catch (ex) {
      res.status(500).end(ex);
    }
  });
}
```

#### Метрики бизнес-логики

```typescript
// metrics/business-metrics.ts
import client from 'prom-client';

export class BusinessMetrics {
  private ordersCreated: client.Counter;
  private ordersProcessed: client.Counter;
  private orderProcessingDuration: client.Histogram;
  private activeUsers: client.Gauge;

  constructor() {
    this.ordersCreated = new client.Counter({
      name: 'orders_created_total',
      help: 'Total number of orders created',
      labelNames: ['user_type']
    });

    this.ordersProcessed = new client.Counter({
      name: 'orders_processed_total',
      help: 'Total number of orders processed',
      labelNames: ['status']
    });

    this.orderProcessingDuration = new client.Histogram({
      name: 'order_processing_duration_seconds',
      help: 'Time spent processing orders',
      buckets: [0.1, 0.5, 1, 2, 5, 10]
    });

    this.activeUsers = new client.Gauge({
      name: 'active_users',
      help: 'Number of active users'
    });

    // Регистрация метрик
    client.register.registerMetric(this.ordersCreated);
    client.register.registerMetric(this.ordersProcessed);
    client.register.registerMetric(this.orderProcessingDuration);
    client.register.registerMetric(this.activeUsers);
  }

  recordOrderCreated(userType: string): void {
    this.ordersCreated.labels({ user_type: userType }).inc();
  }

  recordOrderProcessed(status: string): void {
    this.ordersProcessed.labels({ status }).inc();
  }

  observeOrderProcessingDuration(duration: number): void {
    this.orderProcessingDuration.observe(duration);
  }

  setActiveUsers(count: number): void {
    this.activeUsers.set(count);
  }
}
```

### 3. Трассировка (Distributed Tracing)

Трассировка позволяет отслеживать путь запроса через несколько сервисов.

#### OpenTelemetry с Jaeger

```typescript
// tracing/opentelemetry-tracing.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.SERVICE_NAME || 'microservice-app',
  }),
  traceExporter: new JaegerExporter({
    endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',
  }),
  instrumentations: [getNodeAutoInstrumentations()],
});

// Инициализация SDK
sdk.start();

// Использование трассировки в сервисе
import { trace } from '@opentelemetry/api';

export class TracingService {
  static async traceOperation<T>(
    operationName: string,
    operation: () => Promise<T>,
    attributes?: Record<string, string | number>
  ): Promise<T> {
    const tracer = trace.getTracer(process.env.SERVICE_NAME || 'default-service');
    
    return tracer.startActiveSpan(operationName, async (span) => {
      try {
        if (attributes) {
          span.setAttributes(attributes);
        }
        
        const result = await operation();
        span.setStatus({ code: 0 }); // OK
        return result;
      } catch (error) {
        span.setStatus({ code: 2, message: error.message }); // ERROR
        throw error;
      } finally {
        span.end();
      }
    });
  }
}

// Пример использования
export class UserService {
  async getUserWithTracing(userId: string): Promise<User> {
    return TracingService.traceOperation(
      'get-user',
      async () => {
        // Ваши операции получения пользователя
        return await this.userRepository.findById(userId);
      },
      { 'user.id': userId }
    );
  }
}
```

#### Добавление корреляционного ID к трейсам

```typescript
// tracing/correlation-tracing.ts
import { context, setSpan, getSpan } from '@opentelemetry/api';
import { Span } from '@opentelemetry/sdk-trace-base';

export class CorrelationTracing {
  static async withCorrelationId<T>(
    correlationId: string,
    operation: () => Promise<T>
  ): Promise<T> {
    // Создаем span с корреляционным ID
    const tracer = trace.getTracer('correlation-tracer');
    const span = tracer.startSpan('correlation-context', {
      attributes: { 'correlation.id': correlationId }
    });

    // Устанавливаем span в контекст
    const ctx = setSpan(context.active(), span);
    
    return context.with(ctx, async () => {
      try {
        const result = await operation();
        span.setStatus({ code: 0 });
        return result;
      } catch (error) {
        span.setStatus({ code: 2, message: error.message });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  static getCurrentSpan(): Span | undefined {
    return getSpan(context.active());
  }

  static addAttributeToCurrentSpan(key: string, value: string | number): void {
    const span = this.getCurrentSpan();
    if (span) {
      span.setAttribute(key, value);
    }
  }
}
```

## Health Checks

Проверка состояния сервисов критически важна для оркестрации.

```typescript
// health/health-checks.ts
import express from 'express';
import { LoggerService } from '../logger/winston-logger';

export interface HealthIndicator {
  name: string;
  check(): Promise<{ status: 'up' | 'down'; details?: any }>;
}

export class HealthCheckService {
  private indicators: HealthIndicator[] = [];
  private logger: LoggerService;

  constructor(logger: LoggerService) {
    this.logger = logger;
  }

  addIndicator(indicator: HealthIndicator): void {
    this.indicators.push(indicator);
  }

  async checkHealth(): Promise<HealthCheckResponse> {
    const results = await Promise.all(
      this.indicators.map(async indicator => {
        try {
          const result = await indicator.check();
          return { ...indicator, ...result };
        } catch (error) {
          this.logger.error(`Health check failed for ${indicator.name}`, error);
          return { 
            ...indicator, 
            status: 'down', 
            details: { error: error.message } 
          };
        }
      })
    );

    const allUp = results.every(r => r.status === 'up');
    
    return {
      status: allUp ? 'ok' : 'error',
      timestamp: new Date().toISOString(),
      checks: results
    };
  }

  registerHealthEndpoint(app: express.Application): void {
    app.get('/health', async (req, res) => {
      try {
        const health = await this.checkHealth();
        res.status(health.status === 'ok' ? 200 : 503).json(health);
      } catch (error) {
        this.logger.error('Health check error', error);
        res.status(503).json({
          status: 'error',
          timestamp: new Date().toISOString(),
          message: error.message
        });
      }
    });
  }
}

// Пример индикатора для базы данных
export class DatabaseHealthIndicator implements HealthIndicator {
  name = 'database';

  constructor(private connection: any) {}

  async check(): Promise<{ status: 'up' | 'down'; details?: any }> {
    try {
      await this.connection.query('SELECT 1');
      return { status: 'up' };
    } catch (error) {
      return { 
        status: 'down', 
        details: { error: error.message } 
      };
    }
  }
}

interface HealthCheckResponse {
  status: 'ok' | 'error';
  timestamp: string;
  checks: Array<HealthIndicator & { status: 'up' | 'down'; details?: any }>;
}
```

## Alerting и уведомления

```typescript
// alerting/alert-service.ts
import { LoggerService } from '../logger/winston-logger';

export enum AlertSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

export interface Alert {
  id: string;
  title: string;
  description: string;
  severity: AlertSeverity;
  timestamp: Date;
  source: string;
  data?: Record<string, any>;
}

export class AlertService {
  private alerts: Alert[] = [];
  private logger: LoggerService;
  private alertThresholds: Map<string, number> = new Map();

  constructor(logger: LoggerService) {
    this.logger = logger;
    // Установка порогов для различных типов алертов
    this.alertThresholds.set('high_cpu_usage', 90);
    this.alertThresholds.set('low_memory', 10);
    this.alertThresholds.set('error_rate', 5);
  }

  async createAlert(alert: Omit<Alert, 'id' | 'timestamp'>): Promise<void> {
    const newAlert: Alert = {
      ...alert,
      id: Math.random().toString(36).substring(2, 9),
      timestamp: new Date()
    };

    this.alerts.push(newAlert);
    this.logger.warn(`ALERT: ${alert.title}`, {
      severity: alert.severity,
      source: alert.source,
      data: alert.data
    });

    // Отправка уведомления в зависимости от критичности
    await this.sendNotification(newAlert);
  }

  private async sendNotification(alert: Alert): Promise<void> {
    // Здесь может быть интеграция с системами уведомлений
    // например, Slack, PagerDuty, Email и т.д.
    console.log(`Notification sent for alert: ${alert.title} (Severity: ${alert.severity})`);
  }

  async checkAndAlert(metricName: string, currentValue: number): Promise<void> {
    const threshold = this.alertThresholds.get(metricName);
    if (threshold !== undefined && currentValue > threshold) {
      const severity = currentValue > threshold * 1.5 ? AlertSeverity.HIGH : AlertSeverity.MEDIUM;
      
      await this.createAlert({
        title: `High ${metricName} detected`,
        description: `${metricName} is ${currentValue}%, which exceeds the threshold of ${threshold}%`,
        severity,
        source: 'Metrics Monitor',
        data: { metricName, currentValue, threshold }
      });
    }
  }
}
```

## Визуализация и дашборды

### Grafana дашборды

```json
{
  "dashboard": {
    "id": null,
    "title": "Microservices Dashboard",
    "tags": ["microservices", "monitoring"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{route}}"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, http_request_duration_seconds_bucket)",
            "legendFormat": "95th percentile"
          }
        ],
        "yAxes": [
          {
            "label": "Seconds"
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "singlestat",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{status_code=~\"5..|4..\"}[5m])) / sum(rate(http_requests_total[5m])) * 100",
            "refId": "A"
          }
        ],
        "format": "percent",
        "prefix": "",
        "postfix": "%",
        "colorValue": true,
        "colors": ["#299c46", "rgba(237, 129, 40, 0.89)", "#d44a34"]
      }
    ]
  }
}
```

## Лучшие практики мониторинга

1. **Следуйте принципу "Four Golden Signals"**:
   - Latency (задержка)
   - Traffic (трафик)
   - Errors (ошибки)
   - Saturation (насыщение)

2. **Используйте корреляционные ID** - для трассировки запросов между сервисами

3. **Реализуйте Health Checks** - для оркестрации и автоматического восстановления

4. **Централизуйте логи** - для удобства анализа и поиска проблем

5. **Установите пороги оповещений** - для своевременного реагирования на проблемы

```typescript
// best-practices/monitoring-checklist.ts
export class MonitoringBestPractices {
  // Пример реализации "Four Golden Signals"
  static getGoldenSignalsQueries(): Record<string, string> {
    return {
      latency: 'histogram_quantile(0.95, http_request_duration_seconds_bucket)',
      traffic: 'sum(rate(http_requests_total[5m]))',
      errors: 'sum(rate(http_requests_total{status_code=~"5..|4.."}[5m]))',
      saturation: 'process_cpu_usage'
    };
  }

  // Пример проверки настройки мониторинга
  static validateMonitoringSetup(): void {
    console.log('Проверка настройки мониторинга:');
    console.log('- Логирование: настроено');
    console.log('- Метрики: настроены');
    console.log('- Трассировка: настроена');
    console.log('- Health checks: настроены');
    console.log('- Алертинг: настроен');
  }
}
```

## Связанные темы

- [[Архитектура-микросервисов]]
- [[Типизация-API]]
- [[Взаимодействие-между-сервисами]]
- [[Тестирование-микросервисов]]
- [[Логирование-в-микросервисах]]
- [[Распределенные-транзакции]]