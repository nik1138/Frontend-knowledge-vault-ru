---
aliases: [Тестирование микросервисов, Тесты микросервисов, Проверка сервисов]
tags: [testing, microservices, unit-testing, integration-testing, e2e-testing, jest, supertest]
---

# Тестирование микросервисов

## Обзор

Тестирование микросервисов требует особого подхода из-за распределенной природы архитектуры. В отличие от монолитных приложений, микросервисы взаимодействуют друг с другом через сеть, что создает дополнительные сложности при тестировании.

## Типы тестирования микросервисов

### 1. Модульное тестирование (Unit Testing)

Модульное тестирование проверяет отдельные компоненты сервиса изолированно.

```typescript
// user-service/user.service.spec.ts
import { UserService } from './user.service';
import { UserRepository } from './repository/user.repository';
import { CreateUserDto } from '../dto/create-user.dto';
import { User } from '../entities/user.entity';

describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = {
      findById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    } as jest.Mocked<UserRepository>;

    userService = new UserService(mockUserRepository);
  });

  describe('getUserById', () => {
    it('should return user when user exists', async () => {
      // Arrange
      const userId = '123';
      const expectedUser: User = {
        id: userId,
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
      };
      
      mockUserRepository.findById.mockResolvedValue(expectedUser);

      // Act
      const result = await userService.getUserById(userId);

      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
    });

    it('should return null when user does not exist', async () => {
      // Arrange
      const userId = '123';
      mockUserRepository.findById.mockResolvedValue(null);

      // Act
      const result = await userService.getUserById(userId);

      // Assert
      expect(result).toBeNull();
      expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
    });
  });

  describe('createUser', () => {
    it('should create and return user', async () => {
      // Arrange
      const userData: CreateUserDto = {
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
      };
      
      const createdUser: User = {
        id: '456',
        ...userData,
      };
      
      mockUserRepository.create.mockResolvedValue(createdUser);

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result).toEqual(createdUser);
      expect(mockUserRepository.create).toHaveBeenCalledWith(userData);
    });
  });
});
```

### 2. Интеграционное тестирование

Интеграционное тестирование проверяет взаимодействие между компонентами одного сервиса.

```typescript
// user-service/integration/user.service.integration.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from '../../src/services/user.service';
import { UserRepository } from '../../src/repository/user.repository';
import { DatabaseModule } from '../../src/database/database.module';
import { User } from '../../src/entities/user.entity';
import { CreateUserDto } from '../../src/dto/create-user.dto';

describe('UserService Integration', () => {
  let userService: UserService;
  let userRepository: UserRepository;
  let moduleRef: TestingModule;

  beforeAll(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [DatabaseModule],
      providers: [UserService, UserRepository],
    }).compile();

    userService = moduleRef.get<UserService>(UserService);
    userRepository = moduleRef.get<UserRepository>(UserRepository);
  });

  afterAll(async () => {
    await moduleRef.close();
  });

  beforeEach(async () => {
    // Очистка базы данных перед каждым тестом
    await userRepository.deleteAll();
  });

  it('should create and retrieve user from database', async () => {
    // Arrange
    const userData: CreateUserDto = {
      email: 'integration@test.com',
      firstName: 'Integration',
      lastName: 'Test',
    };

    // Act
    const createdUser = await userService.createUser(userData);
    const retrievedUser = await userService.getUserById(createdUser.id);

    // Assert
    expect(retrievedUser).toBeDefined();
    expect(retrievedUser!.email).toBe(userData.email);
    expect(retrievedUser!.firstName).toBe(userData.firstName);
    expect(retrievedUser!.lastName).toBe(userData.lastName);
  });

  it('should update user correctly', async () => {
    // Arrange
    const userData: CreateUserDto = {
      email: 'update@test.com',
      firstName: 'Update',
      lastName: 'Test',
    };
    
    const createdUser = await userService.createUser(userData);
    
    // Act
    const updatedUser = await userService.updateUser(createdUser.id, {
      firstName: 'Updated',
      lastName: 'Name',
    });

    // Assert
    expect(updatedUser.firstName).toBe('Updated');
    expect(updatedUser.lastName).toBe('Name');
  });
});
```

### 3. Тестирование API

Тестирование HTTP-интерфейса сервиса с использованием инструментов вроде Supertest.

```typescript
// user-service/api/user.controller.spec.ts
import request from 'supertest';
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { UserController } from '../../src/controllers/user.controller';
import { UserService } from '../../src/services/user.service';
import { User } from '../../src/entities/user.entity';

describe('UserController', () => {
  let app: INestApplication;
  let userService: UserService;

  beforeAll(async () => {
    const moduleRef: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
      providers: [
        {
          provide: UserService,
          useValue: {
            getUserById: jest.fn(),
            createUser: jest.fn(),
            updateUser: jest.fn(),
            deleteUser: jest.fn(),
          },
        },
      ],
    }).compile();

    app = moduleRef.createNestApplication();
    userService = moduleRef.get<UserService>(UserService);
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('GET /users/:id', () => {
    it('should return user when found', async () => {
      // Arrange
      const userId = '123';
      const mockUser: User = {
        id: userId,
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
      };
      
      jest.spyOn(userService, 'getUserById').mockResolvedValue(mockUser);

      // Act & Assert
      return request(app.getHttpServer())
        .get(`/users/${userId}`)
        .expect(200)
        .then(response => {
          expect(response.body.data).toEqual(mockUser);
        });
    });

    it('should return 404 when user not found', async () => {
      // Arrange
      const userId = 'nonexistent';
      jest.spyOn(userService, 'getUserById').mockResolvedValue(null);

      // Act & Assert
      return request(app.getHttpServer())
        .get(`/users/${userId}`)
        .expect(404);
    });
  });

  describe('POST /users', () => {
    it('should create user successfully', async () => {
      // Arrange
      const userData = {
        email: 'newuser@example.com',
        firstName: 'New',
        lastName: 'User',
      };
      
      const createdUser: User = {
        id: '456',
        ...userData,
      };
      
      jest.spyOn(userService, 'createUser').mockResolvedValue(createdUser);

      // Act & Assert
      return request(app.getHttpServer())
        .post('/users')
        .send(userData)
        .expect(201)
        .then(response => {
          expect(response.body.data).toEqual(createdUser);
        });
    });
  });
});
```

## Тестирование взаимодействия между сервисами

### Использование заглушек (Stubs) и моков (Mocks)

```typescript
// order-service/__mocks__/user-service.client.ts
export const mockUserServiceClient = {
  getUserById: jest.fn(),
};

export class UserServiceClient {
  getUserById = mockUserServiceClient.getUserById;
}

// order-service/order.service.spec.ts
import { OrderService } from './order.service';
import { UserServiceClient } from './clients/user-service.client';
import { OrderRepository } from './repository/order.repository';
import { User } from '../user/entities/user.entity';

describe('OrderService with External Service Mocking', () => {
  let orderService: OrderService;
  let mockUserServiceClient: jest.Mocked<UserServiceClient>;
  let mockOrderRepository: jest.Mocked<OrderRepository>;

  beforeEach(() => {
    mockUserServiceClient = {
      getUserById: jest.fn(),
    } as any;

    mockOrderRepository = {
      findById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    } as any;

    orderService = new OrderService(mockOrderRepository, mockUserServiceClient);
  });

  it('should validate user exists before creating order', async () => {
    // Arrange
    const userId = '123';
    const userData: User = {
      id: userId,
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
    };
    
    const orderData = {
      userId,
      items: [{ productId: 'p1', quantity: 2, price: 100 }],
      totalAmount: 200,
    };
    
    mockUserServiceClient.getUserById.mockResolvedValue(userData);
    mockOrderRepository.create.mockResolvedValue({
      id: 'order123',
      ...orderData,
      status: 'pending',
    });

    // Act
    const result = await orderService.createOrder(orderData);

    // Assert
    expect(mockUserServiceClient.getUserById).toHaveBeenCalledWith(userId);
    expect(result.userId).toBe(userId);
  });

  it('should throw error if user does not exist', async () => {
    // Arrange
    const userId = 'nonexistent';
    mockUserServiceClient.getUserById.mockResolvedValue(null);

    const orderData = {
      userId,
      items: [{ productId: 'p1', quantity: 2, price: 100 }],
      totalAmount: 200,
    };

    // Act & Assert
    await expect(orderService.createOrder(orderData))
      .rejects
      .toThrow('User not found');
  });
});
```

### Использование контрактных тестов (Contract Testing)

```typescript
// contracts/user-service-contract.spec.ts
import { Pact, Matchers } from '@pact-foundation/pact';
import { User } from '../src/entities/user.entity';
import { UserServiceClient } from '../src/clients/user-service.client';

describe('UserService Contract', () => {
  const provider = new Pact({
    consumer: 'OrderService',
    provider: 'UserService',
    port: 1234, // Порт для mock-сервера Pact
  });

  const userId = '123';
  const expectedUser: User = {
    id: userId,
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
  };

  beforeAll(() => provider.setup());
  afterAll(() => provider.finalize());

  describe('get user by ID', () => {
    beforeAll(() => {
      return provider.addInteraction({
        state: 'user exists',
        uponReceiving: 'a request to get a user',
        withRequest: {
          method: 'GET',
          path: `/users/${userId}`,
        },
        willRespondWith: {
          status: 200,
          headers: {
            'Content-Type': 'application/json',
          },
          body: Matchers.like(expectedUser),
        },
      });
    });

    it('should return user when user exists', async () => {
      // Настройка клиента для использования mock-сервера Pact
      const userServiceClient = new UserServiceClient(`http://localhost:${provider.address().port}`);
      
      // Выполнение вызова
      const user = await userServiceClient.getUserById(userId);
      
      // Проверка результата
      expect(user).toEqual(expectedUser);
      
      // Проверка контракта
      return provider.verify();
    });
  });
});
```

## Тестирование с использованием Docker и TestContainers

```typescript
// integration/test-container.setup.ts
import { GenericContainer, StartedTestContainer } from 'testcontainers';
import { PostgreSqlContainer } from 'testcontainers/dist/modules/postgres';

let dbContainer: StartedTestContainer;

beforeAll(async () => {
  // Запуск PostgreSQL контейнера для тестов
  const container = await new PostgreSqlContainer()
    .withDatabase('testdb')
    .withUsername('test')
    .withPassword('test')
    .start();
    
  dbContainer = container;
  
  // Установка переменных окружения для подключения к тестовой БД
  process.env.DATABASE_URL = `postgresql://test:test@localhost:${container.getMappedPort(5432)}/testdb`;
});

afterAll(async () => {
  if (dbContainer) {
    await dbContainer.stop();
  }
});

// user-service/integration/user.database.integration.spec.ts
describe('User Service Database Integration', () => {
  it('should persist user in database', async () => {
    // Использование реальной БД из контейнера
    const userRepository = new UserRepository();
    
    const userData = {
      email: 'integration@test.com',
      firstName: 'Integration',
      lastName: 'Test',
    };
    
    const createdUser = await userRepository.create(userData);
    const retrievedUser = await userRepository.findById(createdUser.id);
    
    expect(retrievedUser).toBeDefined();
    expect(retrievedUser!.email).toBe(userData.email);
  });
});
```

## Тестирование событийной архитектуры

```typescript
// event-bus/event-bus.spec.ts
import { EventBus } from '../src/event-bus/event-bus';
import { UserCreatedEvent } from '../src/events/user-created.event';

describe('EventBus', () => {
  let eventBus: EventBus;
  let eventHandlers: jest.Mock[];

  beforeEach(() => {
    eventBus = new EventBus();
    eventHandlers = [jest.fn(), jest.fn()];
  });

  it('should publish event to all subscribers', async () => {
    // Arrange
    const event: UserCreatedEvent = {
      id: 'event123',
      type: 'USER_CREATED',
      timestamp: new Date(),
      data: {
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
      },
      source: 'UserService',
    };

    // Подписка обработчиков на событие
    eventBus.subscribe('USER_CREATED', eventHandlers[0]);
    eventBus.subscribe('USER_CREATED', eventHandlers[1]);

    // Act
    await eventBus.publish(event);

    // Assert
    expect(eventHandlers[0]).toHaveBeenCalledWith(event);
    expect(eventHandlers[1]).toHaveBeenCalledWith(event);
  });

  it('should handle async event handlers', async () => {
    // Arrange
    const asyncHandler = jest.fn().mockResolvedValue(undefined);
    eventBus.subscribe('USER_CREATED', asyncHandler);

    const event: UserCreatedEvent = {
      id: 'event456',
      type: 'USER_CREATED',
      timestamp: new Date(),
      data: {
        email: 'async@test.com',
        firstName: 'Async',
        lastName: 'Test',
      },
      source: 'UserService',
    };

    // Act
    await eventBus.publish(event);

    // Assert
    expect(asyncHandler).toHaveBeenCalledWith(event);
  });
});
```

## E2E тестирование микросервисов

```typescript
// e2e/order-e2e.spec.ts
import request from 'supertest';
import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { AppModule } from '../src/app.module';
import { UserServiceClient } from '../src/clients/user-service.client';

describe('Order E2E', () => {
  let app: INestApplication;
  let moduleRef: TestingModule;

  // Мок для внешнего сервиса
  const mockUserServiceClient = {
    getUserById: jest.fn(),
  };

  beforeAll(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    })
    .overrideProvider(UserServiceClient)
    .useValue(mockUserServiceClient)
    .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
    await moduleRef.close();
  });

  it('should create order successfully', async () => {
    // Arrange - подготовка моков
    mockUserServiceClient.getUserById.mockResolvedValue({
      id: 'user123',
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
    });

    // Act & Assert
    return request(app.getHttpServer())
      .post('/orders')
      .send({
        userId: 'user123',
        items: [
          { productId: 'product1', quantity: 2, price: 50 },
          { productId: 'product2', quantity: 1, price: 30 },
        ],
      })
      .expect(201)
      .then(response => {
        expect(response.body.data).toBeDefined();
        expect(response.body.data.totalAmount).toBe(130);
        expect(response.body.data.status).toBe('pending');
      });
  });

  it('should return error for invalid user', async () => {
    // Arrange
    mockUserServiceClient.getUserById.mockResolvedValue(null);

    // Act & Assert
    return request(app.getHttpServer())
      .post('/orders')
      .send({
        userId: 'invalidUser',
        items: [{ productId: 'product1', quantity: 1, price: 50 }],
      })
      .expect(400);
  });
});
```

## Тестирование производительности

```typescript
// performance/load-test.spec.ts
import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { performance } from 'perf_hooks';

// Простой пример теста производительности для API
describe('Performance Tests', () => {
  const API_ENDPOINT = 'http://localhost:3000/api/users';

  it('should handle 100 concurrent requests within 2 seconds', async () => {
    const startTime = performance.now();
    const requests = Array.from({ length: 100 }, () => 
      fetch(API_ENDPOINT).then(res => res.json())
    );

    await Promise.all(requests);
    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000; // в секундах

    expect(duration).toBeLessThan(2); // Должно быть выполнено менее чем за 2 секунды
  });

  it('should measure average response time', async () => {
    const responseTimes: number[] = [];
    const iterations = 50;

    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();
      await fetch(`${API_ENDPOINT}/123`).then(res => res.json());
      const endTime = performance.now();
      responseTimes.push(endTime - startTime);
    }

    const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
    console.log(`Average response time: ${avgResponseTime}ms`);
    
    // Установка порога производительности
    expect(avgResponseTime).toBeLessThan(500); // Меньше 500ms в среднем
  });
});
```

## Лучшие практики тестирования

1. **Используйте пирамиду тестирования** - больше модульных тестов, меньше интеграционных и E2E
2. **Изолируйте зависимости** - используйте моки и заглушки для внешних сервисов
3. **Тестируйте граничные условия** - проверяйте как успешные, так и неудачные сценарии
4. **Используйте фикстуры данных** - для воспроизводимости тестов
5. **Автоматизируйте тесты** - интегрируйте в CI/CD pipeline

```typescript
// testing/utils/test-helpers.ts
import { Connection, createConnection } from 'typeorm';
import { User } from '../../src/entities/user.entity';

export class TestHelper {
  static async setupTestDatabase(): Promise<Connection> {
    return createConnection({
      type: 'sqlite',
      database: ':memory:',
      dropSchema: true,
      entities: [User],
      synchronize: true,
      logging: false,
    });
  }

  static async clearTestDatabase(connection: Connection): Promise<void> {
    const entities = connection.entityMetadatas;
    for (const entity of entities) {
      const repository = connection.getRepository(entity.name);
      await repository.query(`DELETE FROM ${entity.tableName}`);
    }
  }

  static async teardownTestDatabase(connection: Connection): Promise<void> {
    if (connection.isConnected) {
      await connection.close();
    }
  }
}

// Фикстуры для тестов
export const createUserFixture = (overrides: Partial<User> = {}): User => ({
  id: 'test-user-id',
  email: 'test@example.com',
  firstName: 'Test',
  lastName: 'User',
  ...overrides,
});
```

## Настройка Jest для микросервисов

```json
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/?(*.)+(spec|test).+(ts|tsx|js)',
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/migrations/**/*',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  testTimeout: 10000,
  // Для тестов с внешними зависимостями
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};
```

## Связанные темы

- [[Архитектура-микросервисов]]
- [[Типизация-API]]
- [[Взаимодействие-между-сервисами]]
- [[Мониторинг-микросервисов]]
- [[Контрактное-тестирование]]
- [[Тестирование-баз-данных]]