---
aliases: ["Structural Patterns", "Структурные шаблоны"]
tags: [programming/design-patterns/typescript, patterns/structural]
---

# Структурные паттерны (Structural Patterns)

Структурные паттерны проектирования в TypeScript фокусируются на составлении классов и объектов в более крупные структуры, сохраняя при этом гибкость и эффективность этих структур. Эти паттерны помогают ответить на вопрос: "Как создать систему из классов и объектов, чтобы система оставалась гибкой и эффективной?"

## Обзор

Структурные паттерны обеспечивают различные способы построения классов и объектов, чтобы формировать более крупные структуры. Они помогают составлять объекты и классы в более крупные структуры, но при этом сохраняется гибкость и эффективность этих структур. Эти паттерны используют наследование для компоновки интерфейсов или реализации классов.

## Паттерны

В этой категории мы рассмотрим следующие паттерны:

- [[Адаптер]]
- [[Мост]]
- [[Компоновщик]]
- [[Декоратор]]
- [[Фасад]]
- [[Легковес]]
- [[Заместитель]]

Каждый из этих паттернов решает задачи структурирования объектов и классов по-своему, предлагая разные подходы к построению систем.

## Примеры использования

Структурные паттерны особенно полезны в следующих случаях:

- Когда нужно расширить функциональность класса без его изменения
- Когда нужно обеспечить совместимость между несовместимыми интерфейсами
- Когда нужно упростить сложную систему, предоставив единый интерфейс
- Когда нужно оптимизировать использование памяти при работе с большим количеством похожих объектов

## Адаптер (Adapter)

**Также известен как:** Обертка (Wrapper)

**Цель:** Преобразует интерфейс одного класса в другой интерфейс, на который рассчитывают клиенты. Адаптер позволяет классам работать вместе, что невозможно было бы без адаптера из-за несовместимости интерфейсов.

### Проблема

Представим, что у нас есть существующий класс, который выполняет нужную функциональность, но его интерфейс несовместим с остальной частью системы. Мы не можем изменить исходный класс, но хотим использовать его функциональность.

### Решение

Адаптер позволяет объектам с несовместимыми интерфейсами работать вместе, преобразуя интерфейс одного класса в интерфейс, который ожидает клиент.

```typescript
interface IMediaPlayer {
  play(audioType: string, fileName: string): void;
}

class AudioPlayer implements IMediaPlayer {
  play(audioType: string, fileName: string): void {
    if (audioType.toLowerCase() === 'mp3') {
      console.log(`Воспроизводим файл: ${fileName} как MP3`);
    } else {
      console.log(`Формат ${audioType} не поддерживается`);
    }
  }
}

// Адаптируемый класс
class AdvancedMediaPlayer {
  playVlc(fileName: string): void {
    console.log(`Воспроизводим файл: ${fileName} как VLC`);
  }

  playMp4(fileName: string): void {
    console.log(`Воспроизводим файл: ${fileName} как MP4`);
  }
}

// Конкретный адаптер
class MediaAdapter implements IMediaPlayer {
  private advancedMusicPlayer: AdvancedMediaPlayer;

  constructor(audioType: string) {
    if (audioType.toLowerCase() === 'vlc') {
      this.advancedMusicPlayer = new AdvancedMediaPlayer();
    } else if (audioType.toLowerCase() === 'mp4') {
      this.advancedMusicPlayer = new AdvancedMediaPlayer();
    }
  }

  play(audioType: string, fileName: string): void {
    if (audioType.toLowerCase() === 'vlc') {
      this.advancedMusicPlayer.playVlc(fileName);
    } else if (audioType.toLowerCase() === 'mp4') {
      this.advancedMusicPlayer.playMp4(fileName);
    }
  }
}

class AudioPlayerAdapter implements IMediaPlayer {
  private audioPlayer: AudioPlayer;
  private mediaAdapter: MediaAdapter | null = null;

  constructor() {
    this.audioPlayer = new AudioPlayer();
  }

  play(audioType: string, fileName: string): void {
    if (audioType.toLowerCase() === 'mp3') {
      this.audioPlayer.play(audioType, fileName);
    } else if (audioType.toLowerCase() === 'vlc' || audioType.toLowerCase() === 'mp4') {
      this.mediaAdapter = new MediaAdapter(audioType);
      this.mediaAdapter.play(audioType, fileName);
    } else {
      console.log(`Формат ${audioType} не поддерживается`);
    }
  }
}
```

### Применение

```typescript
const audioPlayer = new AudioPlayerAdapter();

audioPlayer.play('mp3', 'file1.mp3');  // Воспроизводим файл: file1.mp3 как MP3
audioPlayer.play('vlc', 'file2.vlc');  // Воспроизводим файл: file2.vlc как VLC
audioPlayer.play('mp4', 'file3.mp4');  // Воспроизводим файл: file3.mp4 как MP4
audioPlayer.play('avi', 'file4.avi');  // Формат avi не поддерживается
```

## Мост (Bridge)

**Цель:** Отделяет абстракцию от её реализации так, чтобы то и другое можно было изменять независимо.

### Проблема

Когда нужно избежать постоянной привязки абстракции к конкретной реализации, чтобы и абстракция, и реализация могли изменяться независимо друг от друга.

### Решение

Мост использует композицию вместо наследования, позволяя абстракции и реализации изменяться независимо.

```typescript
interface IDrawingAPI {
  drawCircle(x: number, y: number, radius: number): void;
}

class DrawingAPI1 implements IDrawingAPI {
  drawCircle(x: number, y: number, radius: number): void {
    console.log(`API1: Рисуем круг с центром (${x}, ${y}) и радиусом ${radius}`);
  }
}

class DrawingAPI2 implements IDrawingAPI {
  drawCircle(x: number, y: number, radius: number): void {
    console.log(`API2: Рисуем круг с центром (${x}, ${y}) и радиусом ${radius}`);
  }
}

abstract class Shape {
  protected drawingAPI: IDrawingAPI;

  constructor(drawingAPI: IDrawingAPI) {
    this.drawingAPI = drawingAPI;
  }

  abstract draw(): void;
  abstract resize(percent: number): void;
}

class Circle extends Shape {
  private x: number;
  private y: number;
  private radius: number;

  constructor(x: number, y: number, radius: number, drawingAPI: IDrawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw(): void {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }

  resize(percent: number): void {
    this.radius *= percent;
  }
}
```

### Применение

```typescript
const circle1 = new Circle(1, 2, 3, new DrawingAPI1());
const circle2 = new Circle(5, 7, 11, new DrawingAPI2());

circle1.draw(); // API1: Рисуем круг с центром (1, 2) и радиусом 3
circle2.draw(); // API2: Рисуем круг с центром (5, 7) и радиусом 11

circle1.resize(2);
circle1.draw(); // API1: Рисуем круг с центром (1, 2) и радиусом 6
```

## Компоновщик (Composite)

**Цель:** Компонует объекты в древовидные структуры для представления иерархии "часть-целое". Позволяет клиентам обрабатывать отдельные объекты и композиции одинаково.

### Проблема

Когда нужно работать с древовидной структурой объектов, где отдельные объекты и группы объектов (композиции) должны обрабатываться одинаково.

### Решение

Компоновщик позволяет клиентам обрабатывать отдельные объекты и композиции одинаково, используя один и тот же интерфейс.

```typescript
interface IComponent {
  operation(): string;
  add(component: IComponent): void;
  remove(component: IComponent): void;
  getChild(index: number): IComponent | null;
}

class Leaf implements IComponent {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  operation(): string {
    return `Лист: ${this.name}`;
  }

  add(component: IComponent): void {
    console.log('Лист не поддерживает добавление компонентов');
  }

  remove(component: IComponent): void {
    console.log('Лист не поддерживает удаление компонентов');
  }

  getChild(index: number): IComponent | null {
    console.log('Лист не имеет дочерних элементов');
    return null;
  }
}

class Composite implements IComponent {
  private children: IComponent[] = [];
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  operation(): string {
    let result = `Компоновщик: ${this.name}`;
    for (const child of this.children) {
      result += `\n${child.operation()}`;
    }
    return result;
  }

  add(component: IComponent): void {
    this.children.push(component);
  }

  remove(component: IComponent): void {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  getChild(index: number): IComponent | null {
    if (index >= 0 && index < this.children.length) {
      return this.children[index];
    }
    return null;
  }
}
```

### Применение

```typescript
const tree = new Composite('Дерево');

const branch1 = new Composite('Ветка 1');
const branch2 = new Composite('Ветка 2');

const leaf1 = new Leaf('Лист 1');
const leaf2 = new Leaf('Лист 2');
const leaf3 = new Leaf('Лист 3');

branch1.add(leaf1);
branch1.add(leaf2);
branch2.add(leaf3);

tree.add(branch1);
tree.add(branch2);

console.log(tree.operation());
// Выведет:
// Компоновщик: Дерево
// Компоновщик: Ветка 1
// Лист: Лист 1
// Лист: Лист 2
// Компоновщик: Ветка 2
// Лист: Лист 3
```

## Декоратор (Decorator)

**Также известен как:** Обертка (Wrapper)

**Цель:** Динамически добавляет новую функциональность объектам, оборачивая их в полезные "обертки".

### Проблема

Когда нужно добавить дополнительную функциональность объекту динамически, без изменения его структуры.

### Решение

Декоратор позволяет добавлять новую функциональность к объекту, оборачивая его в специальные "обертки", которые содержат дополнительную логику.

```typescript
interface IComponent {
  operation(): string;
}

class ConcreteComponent implements IComponent {
  operation(): string {
    return 'Конкретный компонент';
  }
}

abstract class Decorator implements IComponent {
  protected component: IComponent;

  constructor(component: IComponent) {
    this.component = component;
  }

  operation(): string {
    return this.component.operation();
  }
}

class ConcreteDecoratorA extends Decorator {
  operation(): string {
    return `Обернутый A(${super.operation()})`;
  }
}

class ConcreteDecoratorB extends Decorator {
  operation(): string {
    return `Обернутый B(${super.operation()})`;
  }
}
```

### Применение

```typescript
const simple = new ConcreteComponent();
console.log('Простой компонент:', simple.operation());

const decorator1 = new ConcreteDecoratorA(simple);
const decorator2 = new ConcreteDecoratorB(decorator1);
console.log('Декорированный:', decorator2.operation());
// Выведет: Обернутый B(Обернутый A(Конкретный компонент))
```

## Фасад (Facade)

**Цель:** Предоставляет унифицированный интерфейс к группе интерфейсов в подсистеме. Фасад определяет более высокий уровень интерфейса, облегчающий использование подсистемы.

### Проблема

Когда сложная система состоит из множества взаимосвязанных классов, и клиентам нужно знать о многих классах, чтобы использовать систему.

### Решение

Фасад предоставляет простой интерфейс к сложной системе, скрывая внутреннюю сложность и зависимости.

```typescript
class CPU {
  freeze(): void {
    console.log('CPU заморожен');
  }

  jump(position: number): void {
    console.log(`CPU перешел к позиции ${position}`);
  }

  execute(): void {
    console.log('CPU выполняет команды');
  }
}

class Memory {
  load(position: number, data: string): void {
    console.log(`Память загрузила ${data} в позицию ${position}`);
  }
}

class HardDrive {
  read(start: number, size: number): string {
    console.log(`Чтение с жесткого диска: начало=${start}, размер=${size}`);
    return 'Данные с диска';
  }
}

class ComputerFacade {
  private cpu: CPU;
  private memory: Memory;
  private hardDrive: HardDrive;

  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }

  startComputer(): void {
    console.log('Запуск компьютера...');
    this.cpu.freeze();
    this.memory.load(0, this.hardDrive.read(0, 1024));
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('Компьютер успешно запущен');
  }
}
```

### Применение

```typescript
const computer = new ComputerFacade();
computer.startComputer();
// Выведет:
// Запуск компьютера...
// CPU заморожен
// Чтение с жесткого диска: начало=0, размер=1024
// Память загрузила Данные с диска в позицию 0
// CPU перешел к позиции 0
// CPU выполняет команды
// Компьютер успешно запущен
```

## Легковес (Flyweight)

**Цель:** Использует разделение для эффективной поддержки большого количества мелких объектов.

### Проблема

Когда приложение использует большое количество объектов, что приводит к высокому потреблению памяти и снижению производительности.

### Решение

Легковес разделяет общее состояние между несколькими объектами, вместо хранения этого состояния в каждом объекте отдельно.

```typescript
interface IFlyweight {
  operation(extrinsicState: number): void;
}

class ConcreteFlyweight implements IFlyweight {
  private intrinsicState: string;

  constructor(intrinsicState: string) {
    this.intrinsicState = intrinsicState;
  }

  operation(extrinsicState: number): void {
    console.log(`Легковес: ${this.intrinsicState} с внешним состоянием: ${extrinsicState}`);
  }
}

class FlyweightFactory {
  private flyweights: Map<string, IFlyweight> = new Map();

  constructor(initialFlyweights: string[]) {
    for (const state of initialFlyweights) {
      this.flyweights.set(state, new ConcreteFlyweight(state));
    }
  }

  public getFlyweight(sharedState: string): IFlyweight {
    if (!this.flyweights.has(sharedState)) {
      console.log('Фабрика легковесов: Создание нового легковеса.');
      this.flyweights.set(sharedState, new ConcreteFlyweight(sharedState));
    } else {
      console.log('Фабрика легковесов: Получение существующего легковеса.');
    }

    return this.flyweights.get(sharedState)!;
  }

  public listFlyweights(): void {
    console.log(`Фабрика легковесов: ${this.flyweights.size} легковесов.`);
  }
}
```

### Применение

```typescript
const factory = new FlyweightFactory(['A', 'B', 'C']);
factory.listFlyweights(); // Фабрика легковесов: 3 легковесов.

const flyweight1 = factory.getFlyweight('A');
const flyweight2 = factory.getFlyweight('B');
const flyweight3 = factory.getFlyweight('A'); // Получение существующего легковеса

flyweight1.operation(1); // Легковес: A с внешним состоянием: 1
flyweight2.operation(2); // Легковес: B с внешним состоянием: 2
flyweight3.operation(3); // Легковес: A с внешним состоянием: 3
```

## Заместитель (Proxy)

**Также известен как:** Суррогат

**Цель:** Предоставляет суррогат или заменитель другого объекта для контроля доступа к нему.

### Проблема

Когда нужно контролировать доступ к объекту, например, для добавления проверки прав доступа, логирования или отложенной инициализации.

### Решение

Заместитель предоставляет тот же интерфейс, что и оригинальный объект, но добавляет дополнительную логику перед или после вызова методов оригинального объекта.

```typescript
interface ISubject {
  request(): void;
}

class RealSubject implements ISubject {
  request(): void {
    console.log('Реальный субъект: Обработка запроса');
  }
}

class Proxy implements ISubject {
  private realSubject: RealSubject;

  constructor(realSubject: RealSubject) {
    this.realSubject = realSubject;
  }

  request(): void {
    if (this.checkAccess()) {
      this.realSubject.request();
      this.logAccess();
    }
  }

  private checkAccess(): boolean {
    console.log('Заместитель: Проверка доступа к запросу');
    return true; // В реальном приложении тут будет проверка прав
  }

  private logAccess(): void {
    console.log('Заместитель: Логирование запроса');
  }
}
```

### Применение

```typescript
const realSubject = new RealSubject();
const proxy = new Proxy(realSubject);

proxy.request();
// Выведет:
// Заместитель: Проверка доступа к запросу
// Реальный субъект: Обработка запроса
// Заместитель: Логирование запроса
```

## Заключение

Структурные паттерны проектирования помогают организовать классы и объекты в более крупные структуры, обеспечивая гибкость и эффективность. Выбор конкретного паттерна зависит от специфики задачи:

- Используйте [[Адаптер]] когда нужно обеспечить совместимость между несовместимыми интерфейсами
- Используйте [[Мост]] когда нужно отделить абстракцию от реализации
- Используйте [[Компоновщик]] когда нужно работать с древовидной структурой объектов
- Используйте [[Декоратор]] когда нужно добавить функциональность объекту динамически
- Используйте [[Фасад]] когда нужно упростить сложную систему
- Используйте [[Легковес]] когда нужно оптимизировать использование памяти
- Используйте [[Заместитель]] когда нужно контролировать доступ к объекту

> [!tip]
> Структурные паттерны особенно полезны при работе с уже существующими системами, где нужно интегрировать новые компоненты или упростить сложные взаимодействия.

## Дополнительные ресурсы

- [[Порождающие-паттерны]]
- [[Поведенческие-паттерны]]
- [[Функциональные-паттерны]]
- [[Антипаттерны]]

#programming #design-patterns #typescript #structural-patterns