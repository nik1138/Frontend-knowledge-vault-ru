---
aliases: ["Functional Patterns", "Функциональные шаблоны"]
tags: [programming/design-patterns/typescript, patterns/functional]
---

# Функциональные паттерны (Functional Patterns)

Функциональные паттерны в TypeScript представляют собой подходы к программированию, основанные на использовании функций как основных строительных блоков. Эти паттерны используют принципы функционального программирования, такие как неизменяемость, чистые функции, композиция функций и обработка ошибок без исключений. Они позволяют создавать более предсказуемые, тестируемые и надежные приложения.

## Обзор

Функциональные паттерны в контексте TypeScript фокусируются на использовании функций как основных единиц логики. В отличие от объектно-ориентированных паттернов, которые акцентируют внимание на классах и объектах, функциональные паттерны акцентируют внимание на функциях и их композиции. Эти паттерны особенно полезны для обработки данных, создания чистого кода и построения надежных систем.

## Основные принципы

- **Неизменяемость**: Данные не изменяются после создания
- **Чистые функции**: Функции, которые не имеют побочных эффектов и возвращают одинаковый результат для одинаковых аргументов
- **Композиция функций**: Создание сложных функций из простых
- **Высокоуровневые функции**: Функции, которые принимают или возвращают другие функции
- **Обработка ошибок без исключений**: Использование специальных типов для представления ошибок

## Паттерны

В этой категории мы рассмотрим следующие паттерны:

- [[Чистые функции]]
- [[Каррирование]]
- [[Композиция функций]]
- [[Монады]]
- [[Функторы]]
- [[Опциональные значения]]
- [[Обработка ошибок с Either]]
- [[Ленивые вычисления]]

Каждый из этих паттернов помогает реализовать функциональный подход в TypeScript.

## Чистые функции (Pure Functions)

**Цель:** Создание функций, которые не имеют побочных эффектов и всегда возвращают одинаковый результат для одинаковых входных данных.

### Проблема

Функции с побочными эффектами и зависимостью от внешнего состояния трудно тестировать, отлаживать и предсказывать их поведение.

### Решение

Чистые функции не зависят от внешнего состояния и не изменяют его, что делает их предсказуемыми и легко тестируемыми.

```typescript
// Нечистая функция - зависит от внешнего состояния
let multiplier = 2;
function impureMultiply(value: number): number {
  return value * multiplier;
}

// Чистая функция - всегда возвращает одинаковый результат для одинаковых аргументов
function pureMultiply(value: number, multiplier: number): number {
  return value * multiplier;
}

// Нечистая функция - изменяет внешнее состояние
const numbers = [1, 2, 3];
function impureAdd(num: number): void {
  numbers.push(num);
}

// Чистая функция - возвращает новый массив, не изменяя исходный
function pureAdd(numbers: number[], num: number): number[] {
  return [...numbers, num];
}
```

### Применение

```typescript
console.log(pureMultiply(5, 3)); // 15
console.log(pureAdd([1, 2, 3], 4)); // [1, 2, 3, 4]
```

## Каррирование (Currying)

**Цель:** Преобразование функции с несколькими аргументами в последовательность функций с одним аргументом.

### Проблема

Иногда нужно частично применить функцию, передав только часть аргументов, и получить новую функцию, которая ожидает оставшиеся аргументы.

### Решение

Каррирование позволяет преобразовать функцию с несколькими аргументами в цепочку функций с одним аргументом, что облегчает частичное применение.

```typescript
// Каррированная функция
function curry<T, U, R>(fn: (a: T, b: U) => R): (a: T) => (b: U) => R {
  return (a: T) => (b: U) => fn(a, b);
}

// Пример использования
function multiply(a: number, b: number): number {
  return a * b;
}

const curriedMultiply = curry(multiply);
const multiplyByTwo = curriedMultiply(2);

console.log(multiplyByTwo(5)); // 10
console.log(curriedMultiply(3)(4)); // 12

// Более сложный пример с тремя аргументами
function add(a: number, b: number, c: number): number {
  return a + b + c;
}

const curriedAdd = (a: number) => (b: number) => (c: number) => add(a, b, c);
const addFiveAndThree = curriedAdd(5)(3);
console.log(addFiveAndThree(2)); // 10
```

## Композиция функций (Function Composition)

**Цель:** Объединение нескольких функций в одну, где результат одной функции становится аргументом следующей.

### Проблема

При необходимости последовательного применения нескольких функций код может стать трудночитаемым и подверженным ошибкам.

### Решение

Композиция функций позволяет объединить несколько функций в одну, улучшая читаемость и переиспользуемость кода.

```typescript
// Композиция справа налево (f(g(x)))
function compose<A, B, C>(f: (b: B) => C, g: (a: A) => B): (a: A) => C {
  return (x: A) => f(g(x));
}

// Композиция слева направо (g(f(x)))
function pipe<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C {
  return (x: A) => g(f(x));
}

// Примеры функций
const toUpperCase = (str: string): string => str.toUpperCase();
const exclaim = (str: string): string => `${str}!`;
const double = (x: number): number => x * 2;
const increment = (x: number): number => x + 1;

// Использование композиции
const angry = compose(exclaim, toUpperCase);
console.log(angry('hello')); // HELLO!

const incrementThenDouble = pipe(increment, double);
console.log(incrementThenDouble(5)); // 12

// Композиция нескольких функций
const composeMultiple = <T>(...fns: Array<(arg: any) => any>) => (value: T): any =>
  fns.reduceRight((acc, fn) => fn(acc), value);

const processString = composeMultiple(
  exclaim,
  toUpperCase,
  (str: string) => str.trim()
);

console.log(processString('  hello world  ')); // HELLO WORLD!
```

## Монады (Monads)

**Цель:** Предоставление структуры для последовательного выполнения вычислений с учетом контекста (например, обработки ошибок, асинхронности и т.д.).

### Проблема

При работе с асинхронными операциями, обработкой ошибок или опциональными значениями код может стать запутанным из-за множества проверок и обработчиков.

### Решение

Монады предоставляют обобщенную структуру для последовательного выполнения вычислений с автоматической обработкой контекста.

```typescript
interface IMonad<T> {
  bind<U>(fn: (value: T) => IMonad<U>): IMonad<U>;
  map<U>(fn: (value: T) => U): IMonad<U>;
  valueOf(): T;
}

// Простая реализация Maybe монады
class Maybe<T> implements IMonad<T> {
  private value: T | null;

  constructor(value?: T | null) {
    this.value = value !== undefined ? value : null;
  }

  static of<T>(value: T | null): Maybe<T> {
    return new Maybe(value);
  }

  static nothing<T>(): Maybe<T> {
    return new Maybe<T>(null);
  }

  static fromNullable<T>(value: T | null | undefined): Maybe<T> {
    return value != null ? Maybe.of(value) : Maybe.nothing<T>();
  }

  bind<U>(fn: (value: T) => Maybe<U>): Maybe<U> {
    if (this.value === null) {
      return Maybe.nothing<U>();
    }
    return fn(this.value);
  }

  map<U>(fn: (value: T) => U): Maybe<U> {
    if (this.value === null) {
      return Maybe.nothing<U>();
    }
    return Maybe.of(fn(this.value));
  }

  valueOf(): T | null {
    return this.value;
  }

  isNothing(): boolean {
    return this.value === null;
  }

  toString(): string {
    return this.isNothing() ? 'Nothing' : `Just(${this.value})`;
  }
}
```

### Применение

```typescript
// Пример использования Maybe монады
const result1 = Maybe.of(5)
  .map(x => x * 2)
  .map(x => x + 1)
  .valueOf(); // 11

console.log(result1); // 11

const result2 = Maybe.of<number>(null)
  .map(x => x * 2)
  .map(x => x + 1)
  .valueOf(); // null

console.log(result2); // null

// Пример с цепочкой операций, где может произойти ошибка
function divide(a: number, b: number): Maybe<number> {
  return b !== 0 ? Maybe.of(a / b) : Maybe.nothing<number>();
}

const calculation = Maybe.of(20)
  .bind(x => divide(x, 2)) // 10
  .bind(x => divide(x, 0)) // Nothing
  .bind(x => divide(x, 5)); // Nothing

console.log(calculation.toString()); // Nothing
```

## Функторы (Functors)

**Цель:** Обеспечение структуры, которая может быть сопоставлена с помощью функции, сохраняя при этом свою структуру.

### Проблема

При работе с контейнерами (например, массивами, опциональными значениями) нужно часто применять функции к содержимому, не разрушая структуру контейнера.

### Решение

Функторы обеспечивают интерфейс для применения функций к содержимому контейнера с сохранением его структуры.

```typescript
interface IFunctor<T> {
  map<U>(fn: (value: T) => U): IFunctor<U>;
}

class Container<T> implements IFunctor<T> {
  private value: T;

  constructor(value: T) {
    this.value = value;
  }

  static of<T>(value: T): Container<T> {
    return new Container(value);
  }

  map<U>(fn: (value: T) => U): Container<U> {
    return new Container(fn(this.value));
  }

  getValue(): T {
    return this.value;
  }
}

// Пример с массивом как функтором
class List<T> implements IFunctor<T> {
  private values: T[];

  constructor(values: T[] = []) {
    this.values = values;
  }

  static of<T>(...values: T[]): List<T> {
    return new List(values);
  }

  map<U>(fn: (value: T) => U): List<U> {
    return new List(this.values.map(fn));
  }

  getValues(): T[] {
    return [...this.values];
  }
}
```

### Применение

```typescript
const container = Container.of(5);
const result = container.map(x => x * 2).map(x => x + 1).getValue();
console.log(result); // 11

const list = List.of(1, 2, 3, 4, 5);
const doubledList = list.map(x => x * 2).getValues();
console.log(doubledList); // [2, 4, 6, 8, 10]
```

## Опциональные значения (Optional Values)

**Цель:** Безопасная работа с потенциально отсутствующими значениями без использования null или undefined.

### Проблема

Работа с null и undefined может привести к ошибкам времени выполнения (ошибки типа "Cannot read property of undefined").

### Решение

Использование специального типа, который явно указывает, что значение может отсутствовать, и предоставляет безопасные методы работы с ним.

```typescript
class Optional<T> {
  private value: T | null;

  constructor(value?: T | null) {
    this.value = value ?? null;
  }

  static of<T>(value: T): Optional<T> {
    if (value === null || value === undefined) {
      throw new Error('Optional.of не принимает null или undefined');
    }
    return new Optional(value);
  }

  static ofNullable<T>(value: T | null | undefined): Optional<T> {
    return new Optional(value);
  }

  static empty<T>(): Optional<T> {
    return new Optional<T>(null);
  }

  isPresent(): boolean {
    return this.value !== null;
  }

  isEmpty(): boolean {
    return this.value === null;
  }

  get(): T {
    if (this.value === null) {
      throw new Error('Значение отсутствует');
    }
    return this.value;
  }

  orElse(other: T): T {
    return this.value !== null ? this.value : other;
  }

  orElseGet(supplier: () => T): T {
    return this.value !== null ? this.value : supplier();
  }

  map<U>(fn: (value: T) => U): Optional<U> {
    if (this.value === null) {
      return Optional.empty<U>();
    }
    return Optional.ofNullable(fn(this.value));
  }

  flatMap<U>(fn: (value: T) => Optional<U>): Optional<U> {
    if (this.value === null) {
      return Optional.empty<U>();
    }
    return fn(this.value);
  }

  filter(predicate: (value: T) => boolean): Optional<T> {
    if (this.value === null || !predicate(this.value)) {
      return Optional.empty<T>();
    }
    return new Optional(this.value);
  }

  toString(): string {
    return this.value !== null ? `Optional(${this.value})` : 'Optional.empty';
  }
}
```

### Применение

```typescript
const optional1 = Optional.ofNullable('Hello');
console.log(optional1.isPresent()); // true
console.log(optional1.map(s => s.toUpperCase()).get()); // HELLO

const optional2 = Optional.ofNullable(null);
console.log(optional2.isEmpty()); // true
console.log(optional2.orElse('Default')); // Default

const optional3 = Optional.ofNullable('World')
  .filter(s => s.length > 5)
  .map(s => `Hello, ${s}!`);

console.log(optional3.toString()); // Optional.empty
```

## Обработка ошибок с Either (Either Pattern)

**Цель:** Представление вычислений, которые могут завершиться успешно (Right) или неудачно (Left) с информацией об ошибке.

### Проблема

Традиционная обработка ошибок с помощью исключений может нарушать поток выполнения и затруднять понимание кода.

### Решение

Either монада предоставляет структуру для представления вычислений, которые могут вернуть либо успешный результат, либо ошибку, без использования исключений.

```typescript
type Either<L, R> = Left<L, R> | Right<L, R>;

class Left<L, R> {
  readonly value: L;

  constructor(value: L) {
    this.value = value;
  }

  isLeft(): this is Left<L, R> {
    return true;
  }

  isRight(): this is Right<L, R> {
    return false;
  }

  map<U>(fn: (right: R) => U): Either<L, U> {
    return new Left<L, U>(this.value);
  }

  flatMap<U>(fn: (right: R) => Either<L, U>): Either<L, U> {
    return new Left<L, U>(this.value);
  }

  mapLeft<M>(fn: (left: L) => M): Either<M, R> {
    return new Left<M, R>(fn(this.value));
  }

  getOrElse(defaultValue: R): R {
    return defaultValue;
  }

  get(): R {
    throw new Error(`Left value: ${this.value}`);
  }
}

class Right<L, R> {
  readonly value: R;

  constructor(value: R) {
    this.value = value;
  }

  isLeft(): this is Left<L, R> {
    return false;
  }

  isRight(): this is Right<L, R> {
    return true;
  }

  map<U>(fn: (right: R) => U): Either<L, U> {
    return new Right<L, U>(fn(this.value));
  }

  flatMap<U>(fn: (right: R) => Either<L, U>): Either<L, U> {
    return fn(this.value);
  }

  mapLeft<M>(fn: (left: L) => M): Either<M, R> {
    return new Right<M, R>(this.value);
  }

  getOrElse(defaultValue: R): R {
    return this.value;
  }

  get(): R {
    return this.value;
  }
}

// Вспомогательные функции
function left<L, R>(value: L): Either<L, R> {
  return new Left(value);
}

function right<L, R>(value: R): Either<L, R> {
  return new Right(value);
}
```

### Применение

```typescript
// Пример валидации
function validateEmail(email: string): Either<string, string> {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email) 
    ? right(email) 
    : left(`Некорректный email: ${email}`);
}

function validateAge(age: number): Either<string, number> {
  return age >= 0 && age <= 120 
    ? right(age) 
    : left(`Некорректный возраст: ${age}`);
}

// Комбинирование валидаций
const emailValidation = validateEmail('user@example.com');
const ageValidation = validateAge(25);

console.log(emailValidation.flatMap(email => 
  ageValidation.map(age => ({ email, age }))
).getOrElse({ email: 'default@example.com', age: 0 }));

// Результат: { email: 'user@example.com', age: 25 }
```

## Ленивые вычисления (Lazy Evaluation)

**Цель:** Отложенное выполнение вычислений до момента, когда результат действительно нужен.

### Проблема

Некоторые вычисления могут быть ресурсоемкими и не всегда необходимыми, что приводит к неэффективному использованию ресурсов.

### Решение

Ленивые вычисления позволяют отложить выполнение вычислений до момента, когда результат действительно требуется, что может улучшить производительность.

```typescript
class Lazy<T> {
  private value: T | null = null;
  private computed: boolean = false;
  private supplier: () => T;

  constructor(supplier: () => T) {
    this.supplier = supplier;
  }

  static of<T>(supplier: () => T): Lazy<T> {
    return new Lazy(supplier);
  }

  get(): T {
    if (!this.computed) {
      this.value = this.supplier();
      this.computed = true;
    }
    return this.value!;
  }

  isComputed(): boolean {
    return this.computed;
  }
}

// Пример с ленивой последовательностью
class LazySequence<T> {
  private generator: (current: T) => T;
  private current: T;
  private step: number;

  constructor(initial: T, generator: (current: T) => T, step: number = 1) {
    this.current = initial;
    this.generator = generator;
    this.step = step;
  }

  static from<T>(initial: T, generator: (current: T) => T): LazySequence<T> {
    return new LazySequence(initial, generator);
  }

  take(n: number): T[] {
    const result: T[] = [];
    let current = this.current;
    let count = 0;

    while (count < n) {
      result.push(current);
      current = this.generator(current);
      count++;
    }

    return result;
  }

  map<U>(fn: (value: T) => U): LazySequence<U> {
    return new LazySequence(
      fn(this.current),
      (current: U) => fn(this.generator(current as any))
    );
  }
}
```

### Применение

```typescript
// Ленивое вычисление дорогостоящей операции
const expensiveOperation = Lazy.of(() => {
  console.log('Выполняется дорогостоящая операция...');
  return 42 * 42;
});

console.log('Значение еще не вычислено');
console.log(expensiveOperation.get()); // Выведет: Выполняется дорогостоящая операция... 1764
console.log(expensiveOperation.get()); // Выведет только: 1764 (операция не выполняется снова)

// Ленивая последовательность
const sequence = LazySequence.from(1, x => x + 1);
console.log(sequence.take(5)); // [1, 2, 3, 4, 5]

const squaredSequence = sequence.map(x => x * x);
console.log(squaredSequence.take(5)); // [1, 4, 9, 16, 25]
```

## Заключение

Функциональные паттерны в TypeScript позволяют создавать более предсказуемый, тестируемый и надежный код. Эти паттерны особенно полезны при работе с обработкой данных, асинхронными операциями и сложной логикой обработки ошибок.

Преимущества функциональных паттернов:
- **Предсказуемость**: Чистые функции всегда возвращают одинаковый результат для одинаковых аргументов
- **Тестируемость**: Легче тестировать изолированные функции без побочных эффектов
- **Композиция**: Возможность комбинировать простые функции для создания сложной логики
- **Безопасность**: Явное представление потенциальных ошибок и отсутствующих значений

> [!tip]
> Функциональные паттерны особенно эффективны при разработке систем обработки данных, API и других приложений, где важна надежность и предсказуемость.

> [!warning]
> Функциональные паттерны могут быть менее интуитивными для разработчиков, привыкших к объектно-ориентированному подходу. Важно использовать их осознанно и обучать команду работе с этими паттернами.

## Дополнительные ресурсы

- [[Порождающие-паттерны]]
- [[Структурные-паттерны]]
- [[Поведенческие-паттерны]]
- [[Антипаттерны]]

#programming #design-patterns #typescript #functional-patterns