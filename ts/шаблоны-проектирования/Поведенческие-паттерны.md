---
aliases: ["Behavioral Patterns", "Поведенческие шаблоны"]
tags: [programming/design-patterns/typescript, patterns/behavioral]
---

# Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны проектирования в TypeScript сосредоточены на эффективном и гибком взаимодействии между объектами. Эти паттерны описывают, как объекты общаются друг с другом, распределяют ответственность и организуют сложные потоки управления. Они помогают определить, как объекты взаимодействуют, и обеспечивают гибкость при изменении этих взаимодействий.

## Обзор

Поведенческие паттерны решают задачи распределения ответственности между объектами, определяя, как они взаимодействуют друг с другом. В отличие от структурных паттернов, которые фокусируются на составлении классов и объектов в более крупные структуры, поведенческие паттерны фокусируются на взаимодействиях и коммуникациях между объектами.

## Паттерны

В этой категории мы рассмотрим следующие паттерны:

- [[Цепочка обязанностей]]
- [[Команда]]
- [[Интерпретатор]]
- [[Итератор]]
- [[Посредник]]
- [[Хранитель]]
- [[Наблюдатель]]
- [[Состояние]]
- [[Стратегия]]
- [[Шаблонный метод]]
- [[Посетитель]]

Каждый из этих паттернов решает задачи взаимодействия между объектами по-своему, предлагая разные подходы к организации коммуникаций.

## Примеры использования

Поведенческие паттерны особенно полезны в следующих случаях:

- Когда нужно уменьшить зависимости между объектами
- Когда нужно изменять поведение объекта в зависимости от его состояния
- Когда нужно управлять сложным потоком выполнения
- Когда нужно обеспечить эффективное взаимодействие между объектами

## Цепочка обязанностей (Chain of Responsibility)

**Цель:** Избегает привязки отправителя запроса к его получателю, позволяя нескольким объектам обработать запрос. Объекты-получатели связываются в цепочку и запрос передается по цепочке до тех пор, пока какой-то объект не обработает его.

### Проблема

Когда есть несколько объектов, которые могут обработать запрос, но конкретный обработчик неизвестен до выполнения, и необходимо передать запрос одному из нескольких объектов без явного указания получателя.

### Решение

Цепочка обязанностей позволяет передавать запрос по цепочке потенциальных обработчиков до тех пор, пока один из них не обработает запрос.

```typescript
abstract class Handler {
  protected nextHandler: Handler | null = null;

  public setNext(handler: Handler): Handler {
    this.nextHandler = handler;
    return handler;
  }

  public handle(request: string): string | null {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

class MonkeyHandler extends Handler {
  public handle(request: string): string | null {
    if (request === 'Banana') {
      return `Monkey: I'll eat the ${request}`;
    }
    return super.handle(request);
  }
}

class DogHandler extends Handler {
  public handle(request: string): string | null {
    if (request === 'MeatBall') {
      return `Dog: I'll eat the ${request}`;
    }
    return super.handle(request);
  }
}

class CatHandler extends Handler {
  public handle(request: string): string | null {
    if (request === 'Milk') {
      return `Cat: I'll drink the ${request}`;
    }
    return super.handle(request);
  }
}
```

### Применение

```typescript
const monkey = new MonkeyHandler();
const dog = new DogHandler();
const cat = new CatHandler();

monkey.setNext(dog).setNext(cat);

console.log(monkey.handle('MeatBall')); // Dog: I'll eat the MeatBall
console.log(monkey.handle('Milk'));     // Cat: I'll drink the Milk
console.log(monkey.handle('Cup of coffee')); // null
```

## Команда (Command)

**Также известен как:** Action, Transaction

**Цель:** Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций.

### Проблема

Когда нужно параметризовать объекты с действиями, ставить действия в очередь, протоколировать или поддерживать отмену операций.

### Решение

Команда инкапсулирует запрос как объект, отделяя объект, который инициирует операцию, от объекта, который знает, как выполнить операцию.

```typescript
interface ICommand {
  execute(): void;
  undo?(): void;
}

class Light {
  private isOn: boolean = false;

  turnOn(): void {
    this.isOn = true;
    console.log('Свет включен');
  }

  turnOff(): void {
    this.isOn = false;
    console.log('Свет выключен');
  }
}

class LightOnCommand implements ICommand {
  private light: Light;

  constructor(light: Light) {
    this.light = light;
  }

  execute(): void {
    this.light.turnOn();
  }

  undo(): void {
    this.light.turnOff();
  }
}

class LightOffCommand implements ICommand {
  private light: Light;

  constructor(light: Light) {
    this.light = light;
  }

  execute(): void {
    this.light.turnOff();
  }

  undo(): void {
    this.light.turnOn();
  }
}

class RemoteControl {
  private command: ICommand | null = null;

  setCommand(command: ICommand): void {
    this.command = command;
  }

  pressButton(): void {
    if (this.command) {
      this.command.execute();
    }
  }

  pressUndo(): void {
    if (this.command && this.command.undo) {
      this.command.undo();
    }
  }
}
```

### Применение

```typescript
const light = new Light();
const lightOn = new LightOnCommand(light);
const lightOff = new LightOffCommand(light);

const remote = new RemoteControl();
remote.setCommand(lightOn);
remote.pressButton(); // Свет включен
remote.setCommand(lightOff);
remote.pressButton(); // Свет выключен
remote.pressUndo();   // Свет включен
```

## Интерпретатор (Interpreter)

**Цель:** Определяет представление грамматики языка, а также интерпретатор для предложений этого языка.

### Проблема

Когда нужно определить грамматику для простого языка и создать интерпретатор, который будет использовать грамматику для интерпретации предложений (выражений) в этом языке.

### Решение

Интерпретатор определяет класс для каждого символа грамматики, и использует эти классы для построения представления предложения языка.

```typescript
interface IExpression {
  interpret(context: string): boolean;
}

class TerminalExpression implements IExpression {
  private data: string;

  constructor(data: string) {
    this.data = data;
  }

  interpret(context: string): boolean {
    return context.includes(this.data);
  }
}

class OrExpression implements IExpression {
  private expr1: IExpression;
  private expr2: IExpression;

  constructor(expr1: IExpression, expr2: IExpression) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  interpret(context: string): boolean {
    return this.expr1.interpret(context) || this.expr2.interpret(context);
  }
}

class AndExpression implements IExpression {
  private expr1: IExpression;
  private expr2: IExpression;

  constructor(expr1: IExpression, expr2: IExpression) {
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  interpret(context: string): boolean {
    return this.expr1.interpret(context) && this.expr2.interpret(context);
  }
}
```

### Применение

```typescript
const person1 = new TerminalExpression('Robert');
const person2 = new TerminalExpression('John');
const isMale = new OrExpression(person1, person2);

const married = new TerminalExpression('Married');
const isMarried = new AndExpression(isMale, married);

console.log(isMale.interpret('Robert Smith')); // true
console.log(isMarried.interpret('Married John')); // true
console.log(isMarried.interpret('Single Robert')); // false
```

## Итератор (Iterator)

**Цель:** Предоставляет способ последовательного доступа к элементам объекта-агрегата, не раскрывая его внутреннего представления.

### Проблема

Когда нужно обеспечить последовательный доступ к элементам объекта-агрегата без раскрытия его внутреннего представления.

### Решение

Итератор предоставляет интерфейс для последовательного доступа к элементам агрегированного объекта без раскрытия его внутренней структуры.

```typescript
interface IIterator<T> {
  hasNext(): boolean;
  next(): T | null;
}

interface IAggregate<T> {
  createIterator(): IIterator<T>;
}

class NameRepository implements IAggregate<string> {
  private names: string[] = ['Robert', 'John', 'Julie', 'Lora'];

  createIterator(): IIterator<string> {
    return new NameIterator(this.names);
  }
}

class NameIterator implements IIterator<string> {
  private names: string[];
  private index: number = 0;

  constructor(names: string[]) {
    this.names = names;
  }

  hasNext(): boolean {
    return this.index < this.names.length;
  }

  next(): string | null {
    if (this.hasNext()) {
      return this.names[this.index++];
    }
    return null;
  }
}
```

### Применение

```typescript
const namesRepo = new NameRepository();
const iter = namesRepo.createIterator();

while (iter.hasNext()) {
  const name = iter.next();
  if (name) {
    console.log(`Имя: ${name}`);
  }
}
// Выведет:
// Имя: Robert
// Имя: John
// Имя: Julie
// Имя: Lora
```

## Посредник (Mediator)

**Цель:** Определяет объект, инкапсулирующий способ взаимодействия множества объектов. Посредник обеспечивает слабую связанность, позволяя избежать явных ссылок объектов друг на друга и позволяя независимо изменять их взаимодействия.

### Проблема

Когда большое количество объектов взаимодействует напрямую, система становится сложно управляемой, так как зависимости между объектами становятся запутанными.

### Решение

Посредник централизует сложное взаимодействие между объектами, позволяя им взаимодействовать через посредника.

```typescript
interface IMediator {
  notify(sender: object, event: string): void;
}

class BaseComponent {
  protected mediator: IMediator | null = null;

  constructor(mediator?: IMediator) {
    if (mediator) {
      this.setMediator(mediator);
    }
  }

  public setMediator(mediator: IMediator): void {
    this.mediator = mediator;
  }
}

class Component1 extends BaseComponent {
  public doA(): void {
    console.log('Компонент 1: Выполняю A.');
    this.mediator?.notify(this, 'A');
  }

  public doB(): void {
    console.log('Компонент 1: Выполняю B.');
    this.mediator?.notify(this, 'B');
  }
}

class Component2 extends BaseComponent {
  public doC(): void {
    console.log('Компонент 2: Выполняю C.');
    this.mediator?.notify(this, 'C');
  }

  public doD(): void {
    console.log('Компонент 2: Выполняю D.');
    this.mediator?.notify(this, 'D');
  }
}

class ConcreteMediator implements IMediator {
  private component1: Component1;
  private component2: Component2;

  constructor(c1: Component1, c2: Component2) {
    this.component1 = c1;
    this.component1.setMediator(this);
    this.component2 = c2;
    this.component2.setMediator(this);
  }

  public notify(sender: object, event: string): void {
    if (event === 'A') {
      console.log('Посредник: Реагирую на A и запускаю операции B и C.');
      this.component2.doC();
    } else if (event === 'D') {
      console.log('Посредник: Реагирую на D и запускаю операции B и C.');
      this.component1.doB();
      this.component2.doC();
    }
  }
}
```

### Применение

```typescript
const c1 = new Component1();
const c2 = new Component2();
const mediator = new ConcreteMediator(c1, c2);

c1.doA();
// Выведет:
// Компонент 1: Выполняю A.
// Посредник: Реагирую на A и запускаю операции B и C.
// Компонент 2: Выполняю C.

c2.doD();
// Выведет:
// Компонент 2: Выполняю D.
// Посредник: Реагирую на D и запускаю операции B и C.
// Компонент 1: Выполняю B.
// Компонент 2: Выполняю C.
```

## Хранитель (Memento)

**Также известен как:** Снимок (Snapshot)

**Цель:** Без нарушения инкапсуляции захватывает и внешним образом сохраняет внутреннее состояние объекта, так чтобы позже можно было восстановить объект в это состояние.

### Прроблема

Когда нужно сохранить и восстановить состояние объекта, возможно, для реализации функции отмены операций.

### Решение

Хранитель позволяет сохранять снимки состояния объекта и восстанавливать его, не нарушая инкапсуляцию.

```typescript
class Memento {
  private state: string;

  constructor(state: string) {
    this.state = state;
  }

  public getState(): string {
    return this.state;
  }
}

class Originator {
  private state: string;

  constructor(state: string) {
    this.state = state;
    console.log(`Создатель: Начальное состояние: ${this.state}`);
  }

  public doSomething(): void {
    console.log('Создатель: Выполняю важную работу...');
    this.state = this.generateRandomString(10);
    console.log(`Создатель: Состояние изменилось на: ${this.state}`);
  }

  private generateRandomString(length: number): string {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  public save(): Memento {
    console.log(`Создатель: Сохраняю состояние в моментальный снимок.`);
    return new Memento(this.state);
  }

  public restore(memento: Memento): void {
    this.state = memento.getState();
    console.log(`Создатель: Состояние восстановлено: ${this.state}`);
  }
}

class Caretaker {
  private mementos: Memento[] = [];
  private originator: Originator;

  constructor(originator: Originator) {
    this.originator = originator;
  }

  public backup(): void {
    console.log('\nОпекун: Сохраняю состояние создателя...');
    this.mementos.push(this.originator.save());
  }

  public undo(): void {
    if (!this.mementos.length) {
      return;
    }
    const memento = this.mementos.pop()!;
    console.log(`Опекун: Восстанавливаю состояние: ${memento.getState()}`);
    try {
      this.originator.restore(memento);
    } catch (e) {
      this.undo();
    }
  }

  public showHistory(): void {
    console.log('Опекун: Список моментальных снимков:');
    for (const memento of this.mementos) {
      console.log(memento.getState());
    }
  }
}
```

### Применение

```typescript
const originator = new Originator('Super-duper-super-puper-sauce');
const caretaker = new Caretaker(originator);

caretaker.backup();
originator.doSomething();

caretaker.backup();
originator.doSomething();

caretaker.backup();
originator.doSomething();

console.log('');
caretaker.showHistory();

console.log('\nОтмена!');
caretaker.undo();

console.log('\nЕще одна отмена!');
caretaker.undo();
```

## Наблюдатель (Observer)

**Также известен как:** Подчинённый (Dependents), Публикатор-Подписчик (Publish-Subscribe)

**Цель:** Определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются автоматически.

### Проблема

Когда нужно, чтобы один объект уведомлял другие объекты об изменениях своего состояния, но при этом не создавал жестких зависимостей между объектами.

### Решение

Наблюдатель определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются автоматически.

```typescript
interface IObserver {
  update(subject: ISubject): void;
}

interface ISubject {
  attach(observer: IObserver): void;
  detach(observer: IObserver): void;
  notify(): void;
}

class NewsAgency implements ISubject {
  private observers: IObserver[] = [];
  private news: string = '';

  getNews(): string {
    return this.news;
  }

  setNews(news: string): void {
    this.news = news;
    this.notify();
  }

  attach(observer: IObserver): void {
    const isExist = this.observers.includes(observer);
    if (isExist) {
      return console.log('Наблюдатель уже подписан');
    }

    console.log('Наблюдатель добавлен');
    this.observers.push(observer);
  }

  detach(observer: IObserver): void {
    const observerIndex = this.observers.indexOf(observer);
    if (observerIndex === -1) {
      return console.log('Наблюдатель не найден');
    }

    this.observers.splice(observerIndex, 1);
    console.log('Наблюдатель удален');
  }

  notify(): void {
    console.log('Новости обновлены. Уведомление наблюдателей...');
    for (const observer of this.observers) {
      observer.update(this);
    }
  }
}

class NewsChannel implements IObserver {
  private latestNews: string = '';

  update(subject: ISubject): void {
    if (subject instanceof NewsAgency) {
      this.latestNews = subject.getNews();
      console.log(`Канал получил новости: ${this.latestNews}`);
    }
  }
}
```

### Применение

```typescript
const agency = new NewsAgency();
const channel1 = new NewsChannel();
const channel2 = new NewsChannel();

agency.attach(channel1);
agency.attach(channel2);

agency.setNews('Новые технологии в TypeScript!');
// Выведет:
// Новости обновлены. Уведомление наблюдателей...
// Канал получил новости: Новые технологии в TypeScript!
// Канал получил новости: Новые технологии в TypeScript!

agency.detach(channel1);
agency.setNews('Паттерны проектирования стали еще интереснее!');
// Выведет:
// Новости обновлены. Уведомление наблюдателей...
// Канал получил новости: Паттерны проектирования стали еще интереснее!
```

## Состояние (State)

**Цель:** Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Кажется, что объект меняет свой класс.

### Проблема

Когда поведение объекта должно изменяться в зависимости от его состояния, и когда состояние кодифицировано в условных операторах, что делает код трудным для понимания и изменения.

### Решение

Состояние позволяет объекту изменять свое поведение в зависимости от внутреннего состояния, делая его поведение похожим на изменение класса.

```typescript
interface State {
  handle(context: Context): void;
}

class Context {
  private state: State;

  constructor(state: State) {
    this.state = state;
  }

  public setState(state: State): void {
    console.log(`Контекст: Переход в состояние ${state.constructor.name}.`);
    this.state = state;
  }

  public request(): void {
    this.state.handle(this);
  }
}

class ConcreteStateA implements State {
  handle(context: Context): void {
    console.log('Конкретное состояние A: Обработка запроса.');
    console.log('Конкретное состояние A: Переход в состояние B.');
    context.setState(new ConcreteStateB());
  }
}

class ConcreteStateB implements State {
  handle(context: Context): void {
    console.log('Конкретное состояние B: Обработка запроса.');
    console.log('Конкретное состояние B: Переход в состояние A.');
    context.setState(new ConcreteStateA());
  }
}
```

### Применение

```typescript
const context = new Context(new ConcreteStateA());
context.request(); // Конкретное состояние A: Обработка запроса. Конкретное состояние A: Переход в состояние B.
context.request(); // Конкретное состояние B: Обработка запроса. Конкретное состояние B: Переход в состояние A.
```

## Стратегия (Strategy)

**Также известен как:** Политика (Policy)

**Цель:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет алгоритму изменяться независимо от клиентов, которые его используют.

### Проблема

Когда нужно использовать разные алгоритмы для выполнения одной и той же задачи, и алгоритм должен выбираться во время выполнения.

### Решение

Стратегия определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

```typescript
interface IStrategy {
  execute(data: string[]): string[];
}

class ConcreteStrategyA implements IStrategy {
  execute(data: string[]): string[] {
    console.log('Сортировка по алфавиту');
    return data.sort();
  }
}

class ConcreteStrategyB implements IStrategy {
  execute(data: string[]): string[] {
    console.log('Обратная сортировка');
    return data.sort().reverse();
  }
}

class Context {
  private strategy: IStrategy;

  constructor(strategy: IStrategy) {
    this.strategy = strategy;
  }

  public setStrategy(strategy: IStrategy): void {
    this.strategy = strategy;
  }

  public executeStrategy(data: string[]): string[] {
    return this.strategy.execute(data);
  }
}
```

### Применение

```typescript
const data = ['banana', 'apple', 'orange', 'grape'];

const context = new Context(new ConcreteStrategyA());
console.log(context.executeStrategy([...data])); // ['apple', 'banana', 'grape', 'orange']

context.setStrategy(new ConcreteStrategyB());
console.log(context.executeStrategy([...data])); // ['orange', 'grape', 'banana', 'apple']
```

## Шаблонный метод (Template Method)

**Цель:** Определяет скелет алгоритма в операции, откладывая некоторые шаги до подклассов. Шаблонный метод позволяет подклассам переопределять шаги алгоритма, не изменяя его структуру.

### Проблема

Когда нужно определить алгоритм в общих чертах, но предоставить подклассам возможность переопределять отдельные шаги без изменения структуры алгоритма.

### Решение

Шаблонный метод определяет скелет алгоритма в суперклассе, позволяя подклассам переопределять отдельные шаги алгоритма.

```typescript
abstract class DataProcessor {
  // Шаблонный метод
  public templateMethod(): void {
    this.openFile();
    this.extractData();
    this.processData();
    this.closeFile();
  }

  protected openFile(): void {
    console.log('Открытие файла');
  }

  protected closeFile(): void {
    console.log('Закрытие файла');
  }

  protected abstract extractData(): void;
  protected abstract processData(): void;
}

class JSONDataProcessor extends DataProcessor {
  protected extractData(): void {
    console.log('Извлечение данных из JSON файла');
  }

  protected processData(): void {
    console.log('Обработка JSON данных');
  }
}

class XMLDataProcessor extends DataProcessor {
  protected extractData(): void {
    console.log('Извлечение данных из XML файла');
  }

  protected processData(): void {
    console.log('Обработка XML данных');
  }
}
```

### Применение

```typescript
console.log('Обработка JSON данных:');
const jsonProcessor = new JSONDataProcessor();
jsonProcessor.templateMethod();

console.log('\nОбработка XML данных:');
const xmlProcessor = new XMLDataProcessor();
xmlProcessor.templateMethod();
```

## Посетитель (Visitor)

**Цель:** Определяет операцию, выполняемую с каждым объектом из некоторой структуры. Посетитель позволяет определить новую операцию, не изменяя классы этих объектов.

### Проблема

Когда нужно выполнить операцию над объектами сложной структуры, и при этом не изменять классы этих объектов.

### Решение

Посетитель позволяет определить новую операцию, не изменяя классы объектов, над которыми выполняется операция.

```typescript
interface IVisitor {
  visitElementA(element: ElementA): void;
  visitElementB(element: ElementB): void;
}

interface IElement {
  accept(visitor: IVisitor): void;
}

class ElementA implements IElement {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  accept(visitor: IVisitor): void {
    visitor.visitElementA(this);
  }

  operationA(): string {
    return `Операция A для ${this.name}`;
  }
}

class ElementB implements IElement {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  accept(visitor: IVisitor): void {
    visitor.visitElementB(this);
  }

  operationB(): string {
    return `Операция B для ${this.name}`;
  }
}

class ConcreteVisitor1 implements IVisitor {
  visitElementA(element: ElementA): void {
    console.log(`Посетитель 1: ${element.operationA()}`);
  }

  visitElementB(element: ElementB): void {
    console.log(`Посетитель 1: ${element.operationB()}`);
  }
}

class ConcreteVisitor2 implements IVisitor {
  visitElementA(element: ElementA): void {
    console.log(`Посетитель 2: ${element.operationA()} с дополнительной логикой`);
  }

  visitElementB(element: ElementB): void {
    console.log(`Посетитель 2: ${element.operationB()} с дополнительной логикой`);
  }
}

class ObjectStructure {
  private elements: IElement[] = [];

  attach(element: IElement): void {
    this.elements.push(element);
  }

  accept(visitor: IVisitor): void {
    for (const element of this.elements) {
      element.accept(visitor);
    }
  }
}
```

### Применение

```typescript
const structure = new ObjectStructure();
structure.attach(new ElementA('Элемент A1'));
structure.attach(new ElementB('Элемент B1'));

console.log('Использование первого посетителя:');
structure.accept(new ConcreteVisitor1());

console.log('\nИспользование второго посетителя:');
structure.accept(new ConcreteVisitor2());
```

## Заключение

Поведенческие паттерны проектирования помогают организовать взаимодействие между объектами, делая систему более гибкой и управляемой. Выбор конкретного паттерна зависит от специфики задачи:

- Используйте [[Цепочка обязанностей]] когда нужно передать запрос нескольким объектам
- Используйте [[Команда]] когда нужно параметризовать объекты с действиями
- Используйте [[Интерпретатор]] когда нужно определить грамматику для простого языка
- Используйте [[Итератор]] когда нужно последовательно обращаться к элементам коллекции
- Используйте [[Посредник]] когда нужно уменьшить зависимости между объектами
- Используйте [[Хранитель]] когда нужно сохранить и восстановить состояние объекта
- Используйте [[Наблюдатель]] когда нужно уведомлять другие объекты об изменениях
- Используйте [[Состояние]] когда поведение объекта зависит от его состояния
- Используйте [[Стратегия]] когда нужно использовать разные алгоритмы
- Используйте [[Шаблонный метод]] когда нужно определить скелет алгоритма
- Используйте [[Посетитель]] когда нужно выполнить операцию над объектами структуры

> [!tip]
> Поведенческие паттерны особенно полезны при разработке сложных систем, где важна гибкость взаимодействий между компонентами.

## Дополнительные ресурсы

- [[Порождающие-паттерны]]
- [[Структурные-паттерны]]
- [[Функциональные-паттерны]]
- [[Антипаттерны]]

#programming #design-patterns #typescript #behavioral-patterns