---
aliases: ["Creational Patterns", "Порождающие шаблоны"]
tags: [programming/design-patterns/typescript, patterns/creational]
---

# Порождающие паттерны (Creational Patterns)

Порождающие паттерны проектирования в TypeScript сосредоточены на механизмах создания объектов, делая систему независимой от того, как создаются, компонуются и представляются конкретные классы. Эти паттерны абстрагируют процесс инстанцирования, что делает систему более гибкой в определении того, какие объекты должны быть созданы, и как они должны быть созданы.

## Обзор

Порождающие паттерны решают проблему создания объектов без указания точного класса объекта, который будет создан. Вместо прямого вызова конструктора с оператором `new`, код получает объекты путем вызова специализированных функций, которые уже знают, какой класс инстанцировать. Это позволяет системе быть более гибкой и расширяемой.

## Паттерны

В этой категории мы рассмотрим следующие паттерны:

- [[Фабричный метод]]
- [[Абстрактная фабрика]]
- [[Синглтон]]
- [[Прототип]]
- [[Строитель]]

Каждый из этих паттернов решает задачу создания объектов по-своему, предлагая разные уровни абстракции и гибкости.

## Примеры использования

Порождающие паттерны особенно полезны в следующих случаях:

- Когда система не должна зависеть от того, как создаются, компонуются и представляются объекты
- Когда классу нужно делегировать обязанность создания экземпляров подклассам
- Когда экземпляр класса может быть только одним из нескольких возможных вариантов

## Фабричный метод (Factory Method)

**Также известен как:** Виртуальный конструктор

**Цель:** Определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать.

### Проблема

Представим, что у нас есть приложение, которое работает с различными типами документов (PDF, Word, Excel). При создании нового документа мы должны решить, какой конкретный тип документа создать.

### Решение

Фабричный метод предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип создаваемых объектов.

```typescript
interface Document {
  open(): void;
  close(): void;
}

class PDFDocument implements Document {
  open(): void {
    console.log('Открытие PDF документа');
  }
  
  close(): void {
    console.log('Закрытие PDF документа');
  }
}

class WordDocument implements Document {
  open(): void {
    console.log('Открытие Word документа');
  }
  
  close(): void {
    console.log('Закрытие Word документа');
  }
}

abstract class DocumentCreator {
  public abstract createDocument(): Document;

  public openDocument(): Document {
    const document = this.createDocument();
    document.open();
    return document;
  }
}

class PDFDocumentCreator extends DocumentCreator {
  public createDocument(): PDFDocument {
    return new PDFDocument();
  }
}

class WordDocumentCreator extends DocumentCreator {
  public createDocument(): WordDocument {
    return new WordDocument();
  }
}
```

### Применение

```typescript
const pdfCreator = new PDFDocumentCreator();
const pdfDoc = pdfCreator.openDocument(); // Выведет: Открытие PDF документа

const wordCreator = new WordDocumentCreator();
const wordDoc = wordCreator.openDocument(); // Выведет: Открытие Word документа
```

## Абстрактная фабрика (Abstract Factory)

**Также известен как:** Китайская фабрика

**Цель:** Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов.

### Проблема

Когда система должна работать с семействами продуктов, и важно, чтобы продукты, используемые вместе, были из одного семейства. Например, GUI приложения может использовать элементы Windows или Mac, но не смешивать их.

### Решение

Абстрактная фабрика определяет интерфейс для создания семейства связанных объектов без указания их конкретных классов.

```typescript
interface Button {
  render(): void;
}

interface Checkbox {
  render(): void;
}

class WindowsButton implements Button {
  render(): void {
    console.log('Рендеринг Windows кнопки');
  }
}

class MacButton implements Button {
  render(): void {
    console.log('Рендеринг Mac кнопки');
  }
}

class WindowsCheckbox implements Checkbox {
  render(): void {
    console.log('Рендеринг Windows чекбокса');
  }
}

class MacCheckbox implements Checkbox {
  render(): void {
    console.log('Рендеринг Mac чекбокса');
  }
}

interface GUIFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

class WindowsFactory implements GUIFactory {
  createButton(): Button {
    return new WindowsButton();
  }
  
  createCheckbox(): Checkbox {
    return new WindowsCheckbox();
  }
}

class MacFactory implements GUIFactory {
  createButton(): Button {
    return new MacButton();
  }
  
  createCheckbox(): Checkbox {
    return new MacCheckbox();
  }
}
```

### Применение

```typescript
function createUI(factory: GUIFactory): void {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  
  button.render();
  checkbox.render();
}

// Для Windows
createUI(new WindowsFactory());
// Выведет:
// Рендеринг Windows кнопки
// Рендеринг Windows чекбокса

// Для Mac
createUI(new MacFactory());
// Выведет:
// Рендеринг Mac кнопки
// Рендеринг Mac чекбокса
```

## Синглтон (Singleton)

**Цель:** Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к нему.

### Проблема

Иногда необходимо контролировать, чтобы был только один экземпляр класса, особенно для ресурсоемких объектов, таких как соединения с базой данных или файловые менеджеры.

### Решение

Синглтон ограничивает создание экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру.

```typescript
class DatabaseConnection {
  private static instance: DatabaseConnection;
  private connectionString: string;

  private constructor(connectionString: string) {
    this.connectionString = connectionString;
  }

  public static getInstance(connectionString: string = 'default'): DatabaseConnection {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection(connectionString);
    }
    return DatabaseConnection.instance;
  }

  public connect(): void {
    console.log(`Подключение к базе данных: ${this.connectionString}`);
  }
}
```

### Применение

```typescript
const db1 = DatabaseConnection.getInstance('mysql://localhost:3306');
const db2 = DatabaseConnection.getInstance('postgresql://localhost:5432');

console.log(db1 === db2); // true - это один и тот же экземпляр
db1.connect(); // Подключение к базе данных: mysql://localhost:3306
```

> [!warning]
> Паттерн Синглтон часто подвергается критике за то, что затрудняет тестирование и может создавать скрытые зависимости в коде. Используйте его с осторожностью.

## Прототип (Prototype)

**Цель:** Указывает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

### Проблема

Когда создание нового объекта является дорогостоящей операцией, и есть уже существующий объект, который можно использовать как прототип для создания новых экземпляров.

### Решение

Прототип позволяет создавать новые объекты путем копирования существующего объекта (прототипа), вместо создания новых экземпляров с нуля.

```typescript
interface Prototype {
  clone(): Prototype;
}

class ConcretePrototype implements Prototype {
  public name: string;
  public data: number[];

  constructor(name: string, data: number[]) {
    this.name = name;
    this.data = [...data]; // Создаем копию массива
  }

  public clone(): ConcretePrototype {
    // Создаем новый объект, но копируем значения из текущего
    return new ConcretePrototype(this.name, [...this.data]);
  }
}
```

### Применение

```typescript
const original = new ConcretePrototype('Прототип', [1, 2, 3]);
const clone = original.clone();

console.log(original === clone); // false - разные объекты
console.log(original.data === clone.data); // false - массивы тоже скопированы
console.log(clone.name); // Прототип
```

## Строитель (Builder)

**Цель:** Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

### Проблема

Когда объект имеет сложную структуру и требует множества параметров для создания, особенно если многие из них необязательны.

### Решение

Строитель предоставляет пошаговый способ создания сложного объекта, позволяя использовать различные шаги для получения разных конфигураций объекта.

```typescript
class User {
  public name: string;
  public email: string;
  public age: number;
  public phone?: string;
  public address?: string;

  constructor(builder: UserBuilder) {
    this.name = builder.name;
    this.email = builder.email;
    this.age = builder.age;
    this.phone = builder.phone;
    this.address = builder.address;
  }
}

class UserBuilder {
  public name: string;
  public email: string;
  public age: number;
  public phone?: string;
  public address?: string;

  constructor(name: string, email: string, age: number) {
    this.name = name;
    this.email = email;
    this.age = age;
  }

  setPhone(phone: string): UserBuilder {
    this.phone = phone;
    return this;
  }

  setAddress(address: string): UserBuilder {
    this.address = address;
    return this;
  }

  build(): User {
    return new User(this);
  }
}
```

### Применение

```typescript
const user = new UserBuilder('Иван', 'ivan@example.com', 30)
  .setPhone('+7-123-456-78-90')
  .setAddress('Москва, ул. Примерная, д. 1')
  .build();

console.log(user);
// Выведет объект User с заполненными полями
```

## Заключение

Порождающие паттерны проектирования помогают решить задачи создания объектов, обеспечивая гибкость и повторное использование кода. Выбор конкретного паттерна зависит от специфики задачи:

- Используйте [[Фабричный метод]] когда класс делегирует создание экземпляров подклассам
- Используйте [[Абстрактная фабрика]] когда нужно создавать семейства взаимосвязанных объектов
- Используйте [[Синглтон]] когда нужен строго один экземпляр класса
- Используйте [[Прототип]] когда создание нового объекта дороже, чем копирование существующего
- Используйте [[Строитель]] когда нужно создавать сложные объекты с множеством параметров

> [!tip]
> Помните, что паттерны проектирования - это решения распространенных проблем, но не универсальный рецепт. Применяйте их осознанно, когда они действительно улучшают архитектуру вашего приложения.

## Дополнительные ресурсы

- [[Структурные-паттерны]]
- [[Поведенческие-паттерны]]
- [[Функциональные-паттерны]]
- [[Антипаттерны]]

#programming #design-patterns #typescript #creational-patterns