---
aliases: [Мобильные паттерны, Mobile Patterns]
tags: [mobile-development, patterns, architecture, typescript]
---

# Мобильные паттерны

Мобильные паттерны - это проверенные временем решения архитектурных и пользовательских задач, которые часто встречаются при разработке мобильных приложений. Эти паттерны помогают создавать приложения, которые легко поддерживать, тестировать и расширять.

## Архитектурные паттерны

### MVVM (Model-View-ViewModel)

MVVM - один из самых популярных паттернов для мобильной разработки, особенно в экосистемах React Native и Xamarin.

```typescript
// model/user-model.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

export class UserModel {
  public id: number;
  public name: string;
  public email: string;

  constructor(data: User) {
    this.id = data.id;
    this.name = data.name;
    this.email = data.email;
  }

  public async updateProfile(updates: Partial<User>): Promise<void> {
    // Логика обновления профиля
    Object.assign(this, updates);
    // Вызов API для сохранения изменений
  }
}
```

```typescript
// viewmodel/user-view-model.ts
import { observable, action, computed } from 'mobx';
import { UserModel } from '../model/user-model';

export class UserViewModel {
  @observable public user: UserModel | null = null;
  @observable public loading: boolean = false;
  @observable public error: string | null = null;

  @computed public get displayName(): string {
    return this.user ? this.user.name : 'Гость';
  }

  @computed public get isLoggedIn(): boolean {
    return !!this.user;
  }

  @action public async loadUser(userId: number): Promise<void> {
    this.loading = true;
    this.error = null;

    try {
      // Имитация API-запроса
      const userData = await fetch(`/api/users/${userId}`).then(res => res.json());
      this.user = new UserModel(userData);
    } catch (err) {
      this.error = 'Ошибка загрузки пользователя';
      console.error(err);
    } finally {
      this.loading = false;
    }
  }

  @action public async updateUser(updates: Partial<User>): Promise<void> {
    if (!this.user) return;

    try {
      await this.user.updateProfile(updates);
    } catch (err) {
      this.error = 'Ошибка обновления профиля';
      console.error(err);
    }
  }
}
```

### MVP (Model-View-Presenter)

MVP часто используется в NativeScript и других фреймворках для лучшего тестирования.

```typescript
// contract/user-contract.ts
export interface UserView {
  showUser(user: any): void;
  showError(message: string): void;
  showLoading(): void;
  hideLoading(): void;
}

export interface UserPresenter {
  loadUser(userId: number): void;
  updateUser(userData: any): void;
}
```

```typescript
// presenter/user-presenter.ts
import { UserView } from '../contract/user-contract';
import { UserModel } from '../model/user-model';

export class UserPresenterImpl implements UserPresenter {
  private view: UserView;
  private userModel: UserModel;

  constructor(view: UserView) {
    this.view = view;
    this.userModel = new UserModel({} as any);
  }

  public async loadUser(userId: number): Promise<void> {
    this.view.showLoading();

    try {
      // Загрузка данных пользователя
      const userData = await fetch(`/api/users/${userId}`).then(res => res.json());
      this.view.showUser(userData);
    } catch (error) {
      this.view.showError('Ошибка загрузки пользователя');
    } finally {
      this.view.hideLoading();
    }
  }

  public async updateUser(userData: any): Promise<void> {
    try {
      await this.userModel.updateProfile(userData);
      this.view.showUser(userData);
    } catch (error) {
      this.view.showError('Ошибка обновления профиля');
    }
  }
}
```

### Clean Architecture

Clean Architecture помогает создавать приложения с четкой структурой и независимостью от внешних факторов.

```typescript
// domain/entities/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

// domain/usecases/get-user-usecase.ts
import { User } from '../entities/user';
import { UserRepository } from '../repositories/user-repository';

export interface GetUserUseCase {
  execute(userId: number): Promise<User>;
}

export class GetUserUseCaseImpl implements GetUserUseCase {
  private repository: UserRepository;

  constructor(repository: UserRepository) {
    this.repository = repository;
  }

  public async execute(userId: number): Promise<User> {
    return await this.repository.getUserById(userId);
  }
}

// domain/repositories/user-repository.ts
import { User } from '../entities/user';

export interface UserRepository {
  getUserById(id: number): Promise<User>;
  updateUser(user: User): Promise<User>;
}
```

```typescript
// data/repositories/user-repository-impl.ts
import { UserRepository } from '../../domain/repositories/user-repository';
import { User } from '../../domain/entities/user';

export class UserRepositoryImpl implements UserRepository {
  public async getUserById(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return await response.json();
  }

  public async updateUser(user: User): Promise<User> {
    const response = await fetch(`/api/users/${user.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(user),
    });
    return await response.json();
  }
}
```

## Паттерны управления состоянием

### Redux для мобильных приложений

```typescript
// store/user/types.ts
export const USER_LOAD_REQUEST = 'USER_LOAD_REQUEST';
export const USER_LOAD_SUCCESS = 'USER_LOAD_SUCCESS';
export const USER_LOAD_FAILURE = 'USER_LOAD_FAILURE';

export interface UserState {
  user: any | null;
  loading: boolean;
  error: string | null;
}

// store/user/actions.ts
import { USER_LOAD_REQUEST, USER_LOAD_SUCCESS, USER_LOAD_FAILURE } from './types';

interface UserLoadRequestAction {
  type: typeof USER_LOAD_REQUEST;
}

interface UserLoadSuccessAction {
  type: typeof USER_LOAD_SUCCESS;
  payload: any;
}

interface UserLoadFailureAction {
  type: typeof USER_LOAD_FAILURE;
  payload: string;
}

export type UserActionTypes = 
  | UserLoadRequestAction 
  | UserLoadSuccessAction 
  | UserLoadFailureAction;

export const loadUser = (userId: number) => {
  return async (dispatch: any) => {
    dispatch({ type: USER_LOAD_REQUEST });
    
    try {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      
      dispatch({ 
        type: USER_LOAD_SUCCESS, 
        payload: userData 
      });
    } catch (error) {
      dispatch({ 
        type: USER_LOAD_FAILURE, 
        payload: error.message 
      });
    }
  };
};
```

```typescript
// store/user/reducer.ts
import { 
  USER_LOAD_REQUEST, 
  USER_LOAD_SUCCESS, 
  USER_LOAD_FAILURE,
  UserState,
  UserActionTypes 
} from './types';

const initialState: UserState = {
  user: null,
  loading: false,
  error: null,
};

export const userReducer = (
  state = initialState,
  action: UserActionTypes
): UserState => {
  switch (action.type) {
    case USER_LOAD_REQUEST:
      return {
        ...state,
        loading: true,
        error: null,
      };
    case USER_LOAD_SUCCESS:
      return {
        ...state,
        loading: false,
        user: action.payload,
      };
    case USER_LOAD_FAILURE:
      return {
        ...state,
        loading: false,
        error: action.payload,
      };
    default:
      return state;
  }
};
```

## Паттерны пользовательского интерфейса

### Паттерн "Pull to Refresh"

```typescript
// components/pull-to-refresh.tsx
import React, { useState } from 'react';
import { View, Text, RefreshControl, ScrollView } from 'react-native';

interface PullToRefreshProps {
  onRefresh: () => Promise<void>;
  children: React.ReactNode;
}

const PullToRefresh: React.FC<PullToRefreshProps> = ({ onRefresh, children }) => {
  const [refreshing, setRefreshing] = useState(false);

  const handleRefresh = async () => {
    setRefreshing(true);
    await onRefresh();
    setRefreshing(false);
  };

  return (
    <ScrollView
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
      }
    >
      {children}
    </ScrollView>
  );
};

export default PullToRefresh;
```

### Паттерн "Infinite Scroll"

```typescript
// components/infinite-list.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { FlatList, View, Text, ActivityIndicator } from 'react-native';

interface Item {
  id: number;
  title: string;
}

interface InfiniteListProps {
  fetchData: (page: number) => Promise<Item[]>;
}

const InfiniteList: React.FC<InfiniteListProps> = ({ fetchData }) => {
  const [items, setItems] = useState<Item[]>([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);
    try {
      const newItems = await fetchData(page);
      setItems(prev => [...prev, ...newItems]);
      setHasMore(newItems.length > 0);
      setPage(prev => prev + 1);
    } catch (error) {
      console.error('Ошибка загрузки данных:', error);
    } finally {
      setLoading(false);
    }
  }, [fetchData, page, loading, hasMore]);

  useEffect(() => {
    loadMore();
  }, []);

  const renderItem = ({ item }: { item: Item }) => (
    <View style={{ padding: 16, borderBottomWidth: 1, borderBottomColor: '#eee' }}>
      <Text>{item.title}</Text>
    </View>
  );

  const renderFooter = () => {
    if (!loading) return null;
    return (
      <View style={{ paddingVertical: 20 }}>
        <ActivityIndicator animating size="large" />
      </View>
    );
  };

  return (
    <FlatList
      data={items}
      renderItem={renderItem}
      onEndReached={loadMore}
      onEndReachedThreshold={0.1}
      ListFooterComponent={renderFooter}
    />
  );
};

export default InfiniteList;
```

## Паттерны навигации

### Стековая навигация

```typescript
// navigation/app-navigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import HomeScreen from '../screens/HomeScreen';
import DetailScreen from '../screens/DetailScreen';
import ProfileScreen from '../screens/ProfileScreen';

export type RootStackParamList = {
  Home: undefined;
  Detail: { id: number; title: string };
  Profile: { userId: number };
};

const Stack = createStackNavigator<RootStackParamList>();

const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen 
          name="Home" 
          component={HomeScreen} 
          options={{ title: 'Главная' }}
        />
        <Stack.Screen 
          name="Detail" 
          component={DetailScreen}
          options={({ route }) => ({ title: route.params.title })}
        />
        <Stack.Screen 
          name="Profile" 
          component={ProfileScreen}
          options={{ title: 'Профиль' }}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default AppNavigator;
```

### Таб навигация

```typescript
// navigation/bottom-tabs.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { MaterialIcons } from '@expo/vector-icons';
import HomeScreen from '../screens/HomeScreen';
import SearchScreen from '../screens/SearchScreen';
import ProfileScreen from '../screens/ProfileScreen';

const Tab = createBottomTabNavigator();

const BottomTabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: any;

          if (route.name === 'Home') {
            iconName = 'home';
          } else if (route.name === 'Search') {
            iconName = 'search';
          } else if (route.name === 'Profile') {
            iconName = 'person';
          }

          return <MaterialIcons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#007AFF',
        tabBarInactiveTintColor: 'gray',
      })}
    >
      <Tab.Screen 
        name="Home" 
        component={HomeScreen} 
        options={{ headerShown: false }}
      />
      <Tab.Screen 
        name="Search" 
        component={SearchScreen} 
        options={{ title: 'Поиск' }}
      />
      <Tab.Screen 
        name="Profile" 
        component={ProfileScreen} 
        options={{ title: 'Профиль' }}
      />
    </Tab.Navigator>
  );
};

export default BottomTabNavigator;
```

## Паттерны обработки данных

### Repository Pattern

```typescript
// repositories/data-repository.ts
import { User } from '../models/user';

export interface DataRepository<T> {
  getAll(): Promise<T[]>;
  getById(id: number): Promise<T>;
  create(item: T): Promise<T>;
  update(id: number, item: T): Promise<T>;
  delete(id: number): Promise<void>;
}

export class UserRepository implements DataRepository<User> {
  private baseUrl = 'https://api.example.com/users';

  public async getAll(): Promise<User[]> {
    const response = await fetch(this.baseUrl);
    return await response.json();
  }

  public async getById(id: number): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`);
    return await response.json();
  }

  public async create(user: User): Promise<User> {
    const response = await fetch(this.baseUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(user),
    });
    return await response.json();
  }

  public async update(id: number, user: User): Promise<User> {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(user),
    });
    return await response.json();
  }

  public async delete(id: number): Promise<void> {
    await fetch(`${this.baseUrl}/${id}`, {
      method: 'DELETE',
    });
  }
}
```

### Singleton Pattern для сервисов

```typescript
// services/api-service.ts
export class ApiService {
  private static instance: ApiService;
  private baseUrl: string;
  private headers: HeadersInit;

  private constructor() {
    this.baseUrl = 'https://api.example.com';
    this.headers = {
      'Content-Type': 'application/json',
    };
  }

  public static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  public async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'GET',
      headers: this.headers,
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  }

  public async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  }
}
```

## Практические советы

- Используйте паттерн Repository для абстрагирования источников данных
- Применяйте принципы SOLID при проектировании архитектуры
- Используйте Dependency Injection для лучшей тестируемости
- Разделяйте бизнес-логику и UI-логику
- Используйте асинхронные паттерны для обработки длительных операций
- Применяйте паттерн State для управления сложным состоянием UI
- Используйте паттерн Observer для обработки событий

## Связанные темы

- [[React-Native]]
- [[Ionic]]
- [[NativeScript]]
- [[TypeScript-в-мобильной-разработке]]
- [[Оптимизация-для-мобильных-устройств]]
- [[Mobile-Architecture-Patterns]]