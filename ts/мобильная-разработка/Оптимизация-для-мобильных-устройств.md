---
aliases: [Оптимизация для мобильных устройств, Mobile Optimization]
tags: [mobile-development, performance, optimization, typescript]
---

# Оптимизация для мобильных устройств

Оптимизация мобильных приложений критически важна для обеспечения плавной работы, экономии заряда батареи и положительного пользовательского опыта. Мобильные устройства имеют ограниченные ресурсы по сравнению с десктопными компьютерами, поэтому оптимизация становится особенно важной.

## Производительность рендеринга

### Оптимизация списков

Одной из самых распространенных задач в мобильных приложениях является отображение списков с большим количеством элементов. Важно использовать виртуальный скроллинг для оптимизации производительности.

#### React Native - FlatList

```typescript
import React, { useState, useMemo } from 'react';
import { FlatList, View, Text, StyleSheet } from 'react-native';

interface ListItem {
  id: number;
  title: string;
  description: string;
}

const OptimizedList: React.FC = () => {
  const [data] = useState<ListItem[]>(
    Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      title: `Элемент ${i}`,
      description: `Описание элемента ${i}`,
    }))
  );

  // Мемоизированный компонент элемента списка
  const ListItemComponent = React.memo(({ item }: { item: ListItem }) => (
    <View style={styles.item}>
      <Text style={styles.title}>{item.title}</Text>
      <Text style={styles.description}>{item.description}</Text>
    </View>
  ));

  // Функция ключа для оптимизации
  const keyExtractor = (item: ListItem) => item.id.toString();

  // Оптимизированная функция отрисовки
  const renderItem = ({ item }: { item: ListItem }) => (
    <ListItemComponent item={item} />
  );

  return (
    <FlatList
      data={data}
      renderItem={renderItem}
      keyExtractor={keyExtractor}
      // Оптимизация - отрисовка только видимых элементов
      initialNumToRender={10}
      maxToRenderPerBatch={5}
      windowSize={5}
      // Оптимизация - уменьшение частоты обновлений
      updateCellsBatchingPeriod={100}
      // Оптимизация - уменьшение задержки между батчами
      removeClippedSubviews={true}
      // Оптимизация - отсоединение невидимых подвидов
      getItemLayout={(data, index) => ({
        length: 80,
        offset: 80 * index,
        index,
      })}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  description: {
    fontSize: 14,
    color: '#666',
  },
});

export default OptimizedList;
```

### Оптимизация компонентов

Использование `React.memo`, `useCallback` и `useMemo` для предотвращения ненужных перерисовок:

```typescript
import React, { useState, useCallback, useMemo, memo } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

interface ExpensiveComponentProps {
  value: number;
  onIncrement: () => void;
  items: string[];
}

// Мемоизированный компонент
const ExpensiveComponent = memo(({ value, onIncrement, items }: ExpensiveComponentProps) => {
  // Вычисляем сложное значение
  const expensiveValue = useMemo(() => {
    // Симуляция дорогостоящего вычисления
    return items.reduce((sum, item) => sum + item.length, 0);
  }, [items]);

  return (
    <View style={styles.expensiveContainer}>
      <Text>Значение: {value}</Text>
      <Text>Сложное значение: {expensiveValue}</Text>
      <TouchableOpacity onPress={onIncrement} style={styles.button}>
        <Text>Увеличить</Text>
      </TouchableOpacity>
    </View>
  );
});

const OptimizationExample: React.FC = () => {
  const [count, setCount] = useState(0);
  const [items] = useState(['один', 'два', 'три', 'четыре', 'пять']);

  // Мемоизированная функция обратного вызова
  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  return (
    <View style={styles.container}>
      <ExpensiveComponent 
        value={count} 
        onIncrement={handleIncrement} 
        items={items} 
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  expensiveContainer: {
    padding: 16,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 12,
    borderRadius: 6,
    alignItems: 'center',
    marginTop: 12,
  },
});

export default OptimizationExample;
```

## Оптимизация памяти

### Управление изображениями

Изображения часто являются основным потребителем памяти в мобильных приложениях:

```typescript
import React from 'react';
import { View, Image, StyleSheet } from 'react-native';

interface ImageComponentProps {
  imageUrl: string;
  width: number;
  height: number;
}

const OptimizedImage: React.FC<ImageComponentProps> = ({ imageUrl, width, height }) => {
  // Оптимизация размера изображения на основе плотности экрана
  const optimizedUrl = `${imageUrl}?w=${Math.round(width * 2)}&h=${Math.round(height * 2)}`;
  
  return (
    <View style={[styles.imageContainer, { width, height }]}>
      <Image
        source={{ uri: optimizedUrl }}
        style={styles.image}
        // Оптимизация кэширования
        resizeMode="cover"
        // Оптимизация - предзагрузка
        onLoad={() => console.log('Изображение загружено')}
        // Оптимизация - обработка ошибок
        onError={(error) => console.error('Ошибка загрузки изображения:', error)}
        // Оптимизация - размытие при загрузке
        blurRadius={0}
      />
    </View>
  );
};

// Использование прогрессивной загрузки изображений
const ProgressiveImage: React.FC<ImageComponentProps> = ({ imageUrl, width, height }) => {
  const [thumbnailLoaded, setThumbnailLoaded] = React.useState(false);
  
  return (
    <View style={[styles.imageContainer, { width, height }]}>
      {!thumbnailLoaded && (
        <Image
          source={{ uri: `${imageUrl}?w=50&h=50` }} // Миниатюра
          style={[styles.image, styles.thumbnail]}
          onLoad={() => setThumbnailLoaded(true)}
        />
      )}
      <Image
        source={{ uri: `${imageUrl}?w=${width * 2}&h=${height * 2}` }}
        style={[styles.image, thumbnailLoaded && styles.loaded]}
        onLoadEnd={() => setThumbnailLoaded(true)}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  imageContainer: {
    overflow: 'hidden',
  },
  image: {
    ...StyleSheet.absoluteFillObject,
  },
  thumbnail: {
    opacity: 0.5,
  },
  loaded: {
    opacity: 1,
  },
});
```

### Управление состоянием

Оптимизация использования состояния для предотвращения утечек памяти:

```typescript
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, Button } from 'react-native';

interface DataItem {
  id: number;
  name: string;
}

const StateOptimization: React.FC = () => {
  const [data, setData] = useState<DataItem[]>([]);
  const [loading, setLoading] = useState(false);
  const mountedRef = useRef(true); // Для предотвращения установки состояния после размонтирования

  useEffect(() => {
    return () => {
      mountedRef.current = false; // Помечаем компонент как размонтированный
    };
  }, []);

  const fetchData = async () => {
    setLoading(true);
    try {
      // Симуляция API-запроса
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const newData: DataItem[] = [
        { id: 1, name: 'Элемент 1' },
        { id: 2, name: 'Элемент 2' },
      ];
      
      // Проверяем, что компонент все еще смонтирован перед установкой состояния
      if (mountedRef.current) {
        setData(newData);
      }
    } catch (error) {
      if (mountedRef.current) {
        console.error('Ошибка загрузки:', error);
      }
    } finally {
      if (mountedRef.current) {
        setLoading(false);
      }
    }
  };

  return (
    <View>
      <Button title="Загрузить данные" onPress={fetchData} />
      {loading && <Text>Загрузка...</Text>}
      {data.map(item => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
};
```

## Оптимизация сети

### Кэширование данных

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';

interface CacheService {
  get: <T>(key: string) => Promise<T | null>;
  set: <T>(key: string, value: T, ttl?: number) => Promise<void>;
  remove: (key: string) => Promise<void>;
  clear: () => Promise<void>;
}

class DataCache implements CacheService {
  private readonly TTL_KEY = 'cache_ttl_';
  
  async get<T>(key: string): Promise<T | null> {
    try {
      // Проверяем TTL
      const ttl = await AsyncStorage.getItem(this.TTL_KEY + key);
      if (ttl && Date.now() > parseInt(ttl, 10)) {
        await this.remove(key);
        return null;
      }
      
      const value = await AsyncStorage.getItem(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error('Ошибка получения из кэша:', error);
      return null;
    }
  }
  
  async set<T>(key: string, value: T, ttl: number = 300000): Promise<void> { // 5 минут по умолчанию
    try {
      await AsyncStorage.setItem(key, JSON.stringify(value));
      await AsyncStorage.setItem(this.TTL_KEY + key, (Date.now() + ttl).toString());
    } catch (error) {
      console.error('Ошибка сохранения в кэш:', error);
    }
  }
  
  async remove(key: string): Promise<void> {
    try {
      await AsyncStorage.removeItem(key);
      await AsyncStorage.removeItem(this.TTL_KEY + key);
    } catch (error) {
      console.error('Ошибка удаления из кэша:', error);
    }
  }
  
  async clear(): Promise<void> {
    try {
      const keys = await AsyncStorage.getAllKeys();
      const cacheKeys = keys.filter(key => !key.startsWith(this.TTL_KEY));
      await AsyncStorage.multiRemove(cacheKeys);
    } catch (error) {
      console.error('Ошибка очистки кэша:', error);
    }
  }
}

// Использование кэша
const apiService = {
  cache: new DataCache(),
  
  async fetchUserData(userId: number) {
    const cacheKey = `user_${userId}`;
    
    // Проверяем кэш
    let user = await this.cache.get<any>(cacheKey);
    if (user) {
      return user;
    }
    
    // Загружаем с сервера
    const response = await fetch(`/api/users/${userId}`);
    user = await response.json();
    
    // Сохраняем в кэш
    await this.cache.set(cacheKey, user);
    
    return user;
  }
};
```

### Оптимизация запросов

```typescript
// Сервис для объединения запросов
class RequestBatcher {
  private queue: Array<{
    key: string;
    resolve: (value: any) => void;
    reject: (reason: any) => void;
  }> = [];
  private processing = false;
  
  async request(key: string, fetcher: () => Promise<any>): Promise<any> {
    return new Promise((resolve, reject) => {
      // Проверяем, есть ли уже ожидающий запрос с таким же ключом
      const existingRequest = this.queue.find(req => req.key === key);
      if (existingRequest) {
        // Если есть, добавляемся к существующему запросу
        this.queue.push({ key, resolve, reject });
        return;
      }
      
      // Иначе создаем новый запрос
      this.queue.push({ key, resolve, reject });
      
      // Запускаем обработку, если она не запущена
      if (!this.processing) {
        this.processRequests();
      }
    });
  }
  
  private async processRequests() {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const batch = [...this.queue];
      this.queue = [];
      
      // Группируем запросы по ключу
      const grouped = batch.reduce((acc, req) => {
        if (!acc[req.key]) {
          acc[req.key] = [];
        }
        acc[req.key].push(req);
        return acc;
      }, {} as Record<string, typeof batch>);
      
      // Выполняем уникальные запросы
      for (const [key, requests] of Object.entries(grouped)) {
        try {
          // Здесь может быть реальный запрос к API
          const result = await this.fetchData(key);
          requests.forEach(req => req.resolve(result));
        } catch (error) {
          requests.forEach(req => req.reject(error));
        }
      }
    }
    
    this.processing = false;
  }
  
  private async fetchData(key: string) {
    // Симуляция API-запроса
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({ data: `Данные для ${key}` });
      }, 100);
    });
  }
}
```

## Оптимизация энергопотребления

### Эффективное использование датчиков

```typescript
import { DeviceEventEmitter } from 'react-native';
import { accelerometer, setUpdateIntervalForType, SensorTypes } from 'react-native-sensors';

// Класс для управления датчиками с оптимизацией
class EfficientSensorManager {
  private subscription: any = null;
  private readonly updateInterval: number; // в миллисекундах
  
  constructor(updateInterval: number = 1000) { // по умолчанию 1 раз в секунду
    this.updateInterval = updateInterval;
    setUpdateIntervalForType(SensorTypes.accelerometer, updateInterval);
  }
  
  startTracking(callback: (data: { x: number; y: number; z: number }) => void) {
    if (this.subscription) {
      this.stopTracking();
    }
    
    this.subscription = accelerometer.subscribe(({ x, y, z }) => {
      callback({ x, y, z });
    });
  }
  
  stopTracking() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }
  }
  
  // Адаптивный интервал обновления в зависимости от активности
  adjustInterval(isActive: boolean) {
    const newInterval = isActive ? 200 : 2000; // 5 раз в секунду или 1 раз в 2 секунды
    setUpdateIntervalForType(SensorTypes.accelerometer, newInterval);
    this.updateInterval = newInterval;
  }
}
```

## Оптимизация архитектуры

### Lazy Loading компонентов

```typescript
import React, { lazy, Suspense } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

// Ленивая загрузка тяжелых компонентов
const HeavyComponent = lazy(() => import('./HeavyComponent'));

const LazyLoadingExample: React.FC = () => {
  return (
    <View>
      <Text>Основной контент</Text>
      <Suspense fallback={<ActivityIndicator size="large" />}>
        <HeavyComponent />
      </Suspense>
    </View>
  );
};

// Условная загрузка компонентов
const ConditionalComponent: React.FC<{ condition: boolean }> = ({ condition }) => {
  if (!condition) {
    return null; // Не рендерим компонент, если условие не выполнено
  }
  
  return <Text>Условный компонент</Text>;
};
```

## Практические советы

- Используйте `React.memo` для компонентов, которые редко обновляются
- Применяйте `useCallback` и `useMemo` для мемоизации функций и значений
- Оптимизируйте списки с помощью `FlatList` и `getItemLayout`
- Используйте кэширование для часто запрашиваемых данных
- Минимизируйте количество HTTP-запросов через батчинг
- Оптимизируйте размеры изображений на стороне сервера
- Используйте векторные изображения вместо растровых, где это возможно
- Оптимизируйте работу с датчиками и геолокацией
- Управляйте жизненным циклом компонентов для предотвращения утечек памяти
- Используйте профилировщики производительности для выявления узких мест

## Инструменты профилирования

- React Native Performance Monitor
- Flipper для отладки
- Chrome DevTools для веб-компонентов
- Xcode Instruments (iOS)
- Android Studio Profiler (Android)

## Связанные темы

- [[React-Native]]
- [[Ionic]]
- [[NativeScript]]
- [[Мобильные-паттерны]]
- [[TypeScript-в-мобильной-разработке]]
- [[Mobile-Performance-Monitoring]]