---
aliases: [angular-service-typing, typescript-services]
tags: [angular, typescript, services, typing, frontend]
---

# Типизация сервисов в Angular

Типизация сервисов в Angular играет важную роль в обеспечении безопасности типов, предотвращении ошибок во время выполнения и улучшении поддерживаемости кода. В этой статье мы рассмотрим, как правильно типизировать сервисы в Angular с использованием TypeScript.

## Основы типизации сервисов

### Базовый сервис с типизацией

```typescript
import { Injectable } from '@angular/core';

export interface User {
  id: number;
  name: string;
  email: string;
}

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
  ];

  getUsers(): User[] {
    return this.users;
  }

  getUserById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }

  addUser(user: Omit<User, 'id'>): User {
    const newUser = { ...user, id: this.generateId() };
    this.users.push(newUser);
    return newUser;
  }

  private generateId(): number {
    return this.users.length > 0 ? Math.max(...this.users.map(u => u.id)) + 1 : 1;
  }
}
```

## Типизация асинхронных операций

### Использование Observable с типизацией

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

export interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private apiUrl = 'https://api.example.com';

  constructor(private http: HttpClient) {}

  getData<T>(endpoint: string): Observable<ApiResponse<T>> {
    return this.http.get<T>(`${this.apiUrl}/${endpoint}`)
      .pipe(
        map(data => ({ success: true, data })),
        catchError(error => {
          console.error('API Error:', error);
          return of({ success: false, data: null as T, message: error.message });
        })
      );
  }
}
```

## Типизация с использованием Generics

### Создание универсального репозитория

```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

export interface Entity {
  id: number;
}

export interface QueryOptions {
  limit?: number;
  offset?: number;
  sort?: string;
  filter?: Record<string, any>;
}

@Injectable()
export abstract class BaseRepository<T extends Entity> {
  protected entitiesSubject = new BehaviorSubject<T[]>([]);
  public entities$ = this.entitiesSubject.asObservable();

  abstract getAll(): Observable<T[]>;
  abstract getById(id: number): Observable<T | null>;
  abstract create(entity: Omit<T, 'id'>): Observable<T>;
  abstract update(id: number, entity: Partial<T>): Observable<T>;
  abstract delete(id: number): Observable<boolean>;

  protected updateEntities(entities: T[]): void {
    this.entitiesSubject.next(entities);
  }
}

@Injectable({
  providedIn: 'root'
})
export class ProductRepository extends BaseRepository<Product> {
  // Реализация методов для работы с продуктами
  getAll(): Observable<Product[]> {
    // Реализация получения всех продуктов
    return this.entities$;
  }

  // Другие методы реализации...
}

export interface Product extends Entity {
  name: string;
  price: number;
  category: string;
}
```

## Типизация HTTP-запросов

### Сервис с типизированными HTTP-методами

```typescript
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface RequestConfig {
  headers?: HttpHeaders;
  params?: HttpParams | { [param: string]: string | string[] };
  responseType?: 'json' | 'text' | 'blob' | 'arraybuffer';
}

@Injectable({
  providedIn: 'root'
})
export class TypedHttpService {
  constructor(private http: HttpClient) {}

  get<T>(url: string, config?: RequestConfig): Observable<T> {
    return this.http.get<T>(url, config);
  }

  post<T>(url: string, body: any, config?: RequestConfig): Observable<T> {
    return this.http.post<T>(url, body, config);
  }

  put<T>(url: string, body: any, config?: RequestConfig): Observable<T> {
    return this.http.put<T>(url, body, config);
  }

  delete<T>(url: string, config?: RequestConfig): Observable<T> {
    return this.http.delete<T>(url, config);
  }
}
```

## Типизация событий и состояний

### Использование enum для состояний

```typescript
export enum LoadingState {
  Idle = 'IDLE',
  Loading = 'LOADING',
  Success = 'SUCCESS',
  Error = 'ERROR'
}

export interface LoadingStateInfo {
  state: LoadingState;
  message?: string;
  error?: any;
}

@Injectable({
  providedIn: 'root'
})
export class StatefulService {
  private stateSubject = new BehaviorSubject<LoadingStateInfo>({
    state: LoadingState.Idle
  });
  
  public state$ = this.stateSubject.asObservable();

  setState(state: LoadingState, message?: string, error?: any): void {
    this.stateSubject.next({ state, message, error });
  }
}
```

## Типизация конфигурации сервиса

### Использование InjectionToken для конфигурации

```typescript
import { InjectionToken, Injectable } from '@angular/core';

export interface ServiceConfig {
  apiUrl: string;
  timeout: number;
  retryAttempts: number;
}

export const SERVICE_CONFIG = new InjectionToken<ServiceConfig>('service.config');

@Injectable({
  providedIn: 'root'
})
export class ConfigurableService {
  constructor(
    @Inject(SERVICE_CONFIG) private config: ServiceConfig
  ) {}

  getData(): Observable<any> {
    // Использование конфигурации в сервисе
    return this.http.get(this.config.apiUrl)
      .pipe(timeout(this.config.timeout));
  }
}
```

## Лучшие практики типизации сервисов

1. **Используйте интерфейсы для определения структур данных**
2. **Типизируйте все параметры методов и возвращаемые значения**
3. **Используйте generics для универсальных сервисов**
4. **Определяйте типы для ошибок и состояний**
5. **Используйте строгую типизацию для Observable и Promise**

## Связанные темы

- [[Декораторы-в-Angular]]
- [[Типизация-компонентов]]
- [[Инъекция-зависимостей]]
- [[Модули-Angular]]

## Ключевые выводы

- Типизация сервисов улучшает надежность и поддерживаемость кода
- Использование интерфейсов и generics позволяет создавать гибкие и переиспользуемые сервисы
- Правильная типизация асинхронных операций помогает избежать ошибок во время выполнения
- Следование лучшим практикам типизации делает код более читаемым и предсказуемым