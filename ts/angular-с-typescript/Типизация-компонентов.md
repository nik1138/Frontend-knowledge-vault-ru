---
aliases: [angular-component-typing, typescript-components]
tags: [angular, typescript, components, typing, frontend]
---

# Типизация компонентов в Angular

Типизация компонентов в Angular является важной частью разработки надежных и поддерживаемых приложений. Правильное использование TypeScript в компонентах помогает избежать ошибок во время выполнения и улучшает опыт разработки за счет автодополнения и проверки типов.

## Основы типизации компонентов

### Базовая типизация свойств компонента

```typescript
import { Component } from '@angular/core';

export interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

@Component({
  selector: 'app-user-profile',
  template: `
    <div *ngIf="user">
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
      <span [class.active]="user.isActive">Status: {{ user.isActive ? 'Active' : 'Inactive' }}</span>
    </div>
  `
})
export class UserProfileComponent {
  user: User | null = null;
  
  // Счетчик с типизацией
  counter: number = 0;
  
  // Массив пользователей
  users: User[] = [];
  
  // Состояние загрузки
  isLoading: boolean = false;
  
  // Возможные статусы
  status: 'idle' | 'loading' | 'success' | 'error' = 'idle';
}
```

## Типизация входных и выходных свойств

### Использование @Input с типизацией

```typescript
import { Component, Input, Output, EventEmitter } from '@angular/core';

export interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
}

@Component({
  selector: 'app-product-card',
  template: `
    <div class="product-card">
      <h3>{{ product.name }}</h3>
      <p>{{ product.description }}</p>
      <span class="price">{{ product.price | currency }}</span>
      <button (click)="onAddToCart()">Add to Cart</button>
    </div>
  `
})
export class ProductCardComponent {
  @Input() product!: Product;
  @Input() showDescription: boolean = true;
  @Input() maxQuantity: number = 10;
  
  @Output() addToCart = new EventEmitter<{ product: Product, quantity: number }>();
  @Output() productViewed = new EventEmitter<Product>();
  
  quantity: number = 1;
  
  onAddToCart(): void {
    if (this.quantity > 0 && this.quantity <= this.maxQuantity) {
      this.addToCart.emit({ product: this.product, quantity: this.quantity });
    }
  }
  
  onViewProduct(): void {
    this.productViewed.emit(this.product);
  }
}
```

## Типизация событий и обработчиков

### Типизация событий DOM с использованием TypeScript

```typescript
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-form-example',
  template: `
    <form (ngSubmit)="onSubmit(form)" #form="ngForm">
      <input 
        type="text" 
        name="username" 
        [(ngModel)]="formData.username"
        (input)="onUsernameInput($event)"
        #usernameInput
        required>
      
      <input 
        type="email" 
        name="email" 
        [(ngModel)]="formData.email"
        (blur)="onEmailBlur($event)"
        required>
      
      <button type="submit" [disabled]="!form.valid">Submit</button>
    </form>
  `
})
export class FormExampleComponent implements OnInit {
  formData = {
    username: '',
    email: ''
  };
  
  ngOnInit(): void {
    // Инициализация компонента
  }
  
  onUsernameInput(event: Event): void {
    const target = event.target as HTMLInputElement;
    console.log('Username input:', target.value);
  }
  
  onEmailBlur(event: FocusEvent): void {
    const target = event.target as HTMLInputElement;
    console.log('Email blurred:', target.value);
  }
  
  onSubmit(form: any): void {
    if (form.valid) {
      console.log('Form submitted:', this.formData);
    }
  }
}
```

## Типизация с использованием Reactive Forms

### Типизация реактивных форм

```typescript
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';

export interface RegistrationFormValue {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  age: number | null;
  newsletter: boolean;
}

@Component({
  selector: 'app-registration-form',
  template: `
    <form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">
      <input type="text" formControlName="firstName" placeholder="First Name">
      <input type="text" formControlName="lastName" placeholder="Last Name">
      <input type="email" formControlName="email" placeholder="Email">
      <input type="password" formControlName="password" placeholder="Password">
      <input type="number" formControlName="age" placeholder="Age">
      <input type="checkbox" formControlName="newsletter"> Subscribe to newsletter
      
      <button type="submit" [disabled]="!registrationForm.valid">Register</button>
    </form>
    
    <div *ngIf="registrationForm.invalid && registrationForm.touched">
      Form has errors
    </div>
  `
})
export class RegistrationFormComponent implements OnInit {
  registrationForm: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.registrationForm = this.fb.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      age: [null, [Validators.min(18), Validators.max(120)]],
      newsletter: [false]
    });
  }
  
  ngOnInit(): void {
    // Подписка на изменения формы
    this.registrationForm.valueChanges.subscribe(
      (value: RegistrationFormValue) => {
        console.log('Form value changed:', value);
      }
    );
  }
  
  get emailControl(): AbstractControl {
    return this.registrationForm.get('email')!;
  }
  
  onSubmit(): void {
    if (this.registrationForm.valid) {
      const formValue: RegistrationFormValue = this.registrationForm.value;
      console.log('Submitting form:', formValue);
      // Отправка данных на сервер
    } else {
      console.log('Form is invalid');
      this.markFormGroupTouched();
    }
  }
  
  private markFormGroupTouched(): void {
    Object.keys(this.registrationForm.controls).forEach(key => {
      const control = this.registrationForm.get(key);
      control?.markAsTouched();
    });
  }
}
```

## Типизация с использованием ViewChild и ContentChild

### Типизация элементов DOM и дочерних компонентов

```typescript
import { 
  Component, 
  ViewChild, 
  ContentChild, 
  ElementRef, 
  AfterViewInit,
  ContentChild
} from '@angular/core';
import { ChildComponent } from './child.component';

@Component({
  selector: 'app-parent',
  template: `
    <div #container>
      <app-child #childComponent [data]="childData"></app-child>
      <ng-content></ng-content>
    </div>
    <button (click)="focusInput()">Focus Input</button>
  `
})
export class ParentComponent implements AfterViewInit {
  @ViewChild('container', { static: true }) container!: ElementRef<HTMLDivElement>;
  @ViewChild('childComponent', { static: true }) childComponent!: ChildComponent;
  @ContentChild('projectedContent', { read: ElementRef }) projectedContent!: ElementRef;
  
  childData: { id: number; name: string } = { id: 1, name: 'Test Child' };
  
  ngAfterViewInit(): void {
    // Теперь можно безопасно обращаться к ViewChild элементам
    console.log('Container element:', this.container.nativeElement);
    console.log('Child component:', this.childComponent);
  }
  
  focusInput(): void {
    // Пример использования ViewChild для взаимодействия с DOM
    const input = this.container.nativeElement.querySelector('input');
    if (input) {
      input.focus();
    }
  }
}
```

## Типизация с использованием Generics

### Универсальные компоненты с типизацией

```typescript
import { Component, Input } from '@angular/core';

export interface ListItem {
  id: number;
}

@Component({
  selector: 'app-generic-list',
  template: `
    <ul>
      <li *ngFor="let item of items; trackBy: trackByFn">
        <ng-container [ngSwitch]="itemType">
          <app-user-item *ngSwitchCase="'user'" [user]="item"></app-user-item>
          <app-product-item *ngSwitchCase="'product'" [product]="item"></app-product-item>
        </ng-container>
      </li>
    </ul>
  `
})
export class GenericListComponent<T extends ListItem> {
  @Input() items: T[] = [];
  @Input() itemType: 'user' | 'product' = 'user';
  
  trackByFn(index: number, item: T): number {
    return item.id;
  }
}
```

## Типизация с использованием темплейтов

### Типизация переменных в шаблонах

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-typed-template',
  template: `
    <!-- Переменная в ngFor с типизацией -->
    <div *ngFor="let user of users; let i = index; trackBy: trackByUserId">
      <h3>{{ user.name }} (ID: {{ user.id }})</h3>
      <p>Email: {{ user.email }}</p>
      <p *ngIf="user.profile">Profile: {{ user.profile.bio }}</p>
    </div>
    
    <!-- Локальная переменная с типизацией -->
    <ng-container *ngIf="user$ | async as user; else noUser">
      <app-user-detail [user]="user"></app-user-detail>
    </ng-container>
    
    <ng-template #noUser>
      <p>User not found</p>
    </ng-template>
  `
})
export class TypedTemplateComponent {
  users: User[] = [
    { id: 1, name: 'John', email: 'john@example.com', profile: { bio: 'Software Developer' } },
    { id: 2, name: 'Jane', email: 'jane@example.com' }
  ];
  
  user$ = of(this.users[0]);
  
  trackByUserId(index: number, user: User): number {
    return user.id;
  }
}

interface User {
  id: number;
  name: string;
  email: string;
  profile?: {
    bio: string;
  };
}
```

## Лучшие практики типизации компонентов

1. **Используйте интерфейсы для определения структур данных**
2. **Типизируйте все @Input и @Output свойства**
3. **Используйте строгую типизацию для событий DOM**
4. **Применяйте типизацию для реактивных форм**
5. **Определяйте типы для ViewChild и ContentChild элементов**
6. **Используйте generics для универсальных компонентов**

## Связанные темы

- [[Декораторы-в-Angular]]
- [[Типизация-сервисов]]
- [[Инъекция-зависимостей]]
- [[Модули-Angular]]

## Ключевые выводы

- Типизация компонентов улучшает надежность и поддерживаемость кода
- Правильная типизация помогает избежать ошибок во время выполнения
- Использование интерфейсов делает код более читаемым и понятным
- Типизация событий и форм улучшает опыт разработки