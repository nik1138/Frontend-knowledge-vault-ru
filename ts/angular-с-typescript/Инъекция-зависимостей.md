---
aliases: [angular-dependency-injection, dependency-injection-guide]
tags: [angular, typescript, di, dependency-injection, frontend]
---

# Инъекция зависимостей в Angular

Инъекция зависимостей (DI) - это паттерн проектирования, который позволяет компонентам и сервисам получать зависимости из внешнего источника, а не создавать их самостоятельно. Angular предоставляет мощную систему внедрения зависимостей, которая упрощает создание тестируемых, масштабируемых и поддерживаемых приложений.

## Основы внедрения зависимостей

### Базовое использование @Injectable

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Сервис предоставляется на уровне корня приложения
})
export class DataService {
  getData(): string {
    return 'Some data';
  }
}

// Компонент, использующий сервис
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  template: `<h1>{{ data }}</h1>`
})
export class ExampleComponent {
  data: string;

  constructor(private dataService: DataService) {
    this.data = this.dataService.getData();
  }
}
```

## Провайдеры зависимостей

### Типы провайдеров

Angular поддерживает несколько способов регистрации провайдеров:

```typescript
import { Injectable, NgModule } from '@angular/core';

// 1. useClass - создает экземпляр класса
@Injectable()
export class RealLoggerService {
  log(message: string): void {
    console.log(message);
  }
}

// 2. useFactory - создает экземпляр с помощью фабричной функции
export function loggerFactory(): LoggerService {
  if (environment.production) {
    return new ProductionLoggerService();
  } else {
    return new DevelopmentLoggerService();
  }
}

// 3. useValue - предоставляет готовое значение
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

@NgModule({
  providers: [
    // useClass
    { provide: LoggerService, useClass: RealLoggerService },
    
    // useFactory
    { provide: LoggerService, useFactory: loggerFactory },
    
    // useValue
    { provide: 'CONFIG', useValue: config },
    
    // useExisting - создает псевдоним
    { provide: 'AliasLogger', useExisting: LoggerService }
  ]
})
export class AppModule {}
```

## Области видимости провайдеров

### providedIn: 'root'

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Одиночный экземпляр для всего приложения
})
export class GlobalService {
  private data: string[] = [];

  addData(item: string): void {
    this.data.push(item);
  }

  getData(): string[] {
    return [...this.data]; // Возвращаем копию для защиты
  }
}
```

### Провайдеры на уровне модуля

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [
    // Сервис будет доступен во всем модуле
    { provide: ApiService, useClass: MockApiService }
  ],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

### Провайдеры на уровне компонента

```typescript
import { Component } from '@angular/core';
import { LocalService } from './local.service';

@Component({
  selector: 'app-local',
  template: `<p>Local component</p>`,
  providers: [
    // Сервис будет создан для каждого экземпляра компонента
    LocalService
  ]
})
export class LocalComponent {
  constructor(private localService: LocalService) {}
}
```

## InjectionToken

### Создание токенов внедрения

```typescript
import { InjectionToken, Inject, Injectable } from '@angular/core';

// Создание токена для простых значений
export const APP_CONFIG = new InjectionToken<AppConfig>('app.config');

export interface AppConfig {
  apiUrl: string;
  version: string;
  debugMode: boolean;
}

// Создание токена для функций
export const LOGGING_FUNCTION = new InjectionToken<Function>('logging.function');

@Injectable()
export class ConfigurableService {
  constructor(
    @Inject(APP_CONFIG) private config: AppConfig,
    @Inject(LOGGING_FUNCTION) private logFn: Function
  ) {}

  performAction(): void {
    if (this.config.debugMode) {
      this.logFn(`Performing action with API: ${this.config.apiUrl}`);
    }
  }
}
```

### Использование InjectionToken в модуле

```typescript
import { NgModule } from '@angular/core';

@NgModule({
  providers: [
    { 
      provide: APP_CONFIG, 
      useValue: {
        apiUrl: 'https://api.example.com',
        version: '1.0.0',
        debugMode: !environment.production
      } as AppConfig
    },
    {
      provide: LOGGING_FUNCTION,
      useValue: (message: string) => console.log(`[LOG] ${message}`)
    }
  ]
})
export class AppModule {}
```

## Асинхронная инъекция зависимостей

### Асинхронные провайдеры с useFactory

```typescript
import { APP_INITIALIZER, NgModule } from '@angular/core';

export function initializeApp(configService: ConfigService): () => Promise<any> {
  return () => configService.loadConfig();
}

@NgModule({
  providers: [
    ConfigService,
    {
      provide: APP_INITIALIZER,
      useFactory: initializeApp,
      deps: [ConfigService],
      multi: true
    }
  ]
})
export class AppModule {}
```

## Нестандартные зависимости

### Внедрение DOM-документа

```typescript
import { Component, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';

@Component({
  selector: 'app-document-example',
  template: `<p>Current title: {{ title }}</p>`
})
export class DocumentExampleComponent {
  title: string;

  constructor(@Inject(DOCUMENT) private document: Document) {
    this.title = this.document.title;
  }

  updateTitle(newTitle: string): void {
    this.document.title = newTitle;
  }
}
```

### Внедрение платформы

```typescript
import { Component, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser, isPlatformServer } from '@angular/common';

@Component({
  selector: 'app-platform-specific',
  template: `<p>Running on: {{ platformType }}</p>`
})
export class PlatformSpecificComponent {
  platformType: string;

  constructor(@Inject(PLATFORM_ID) private platformId: Object) {
    if (isPlatformBrowser(this.platformId)) {
      this.platformType = 'Browser';
    } else if (isPlatformServer(this.platformId)) {
      this.platformType = 'Server';
    } else {
      this.platformType = 'Unknown';
    }
  }
}
```

## Создание кастомных провайдеров

### Интерфейс для провайдера

```typescript
import { Provider } from '@angular/core';

export interface ServiceConfig {
  endpoint: string;
  timeout: number;
}

export function createServiceWithConfig(
  serviceClass: any, 
  config: ServiceConfig
): Provider {
  return {
    provide: serviceClass,
    useFactory: () => new serviceClass(config),
    deps: []
  };
}

// Использование
@NgModule({
  providers: [
    createServiceWithConfig(ApiService, {
      endpoint: 'https://api.example.com',
      timeout: 5000
    })
  ]
})
export class AppModule {}
```

## Лучшие практики

### 1. Используйте providedIn: 'root' для сервисов общего назначения

```typescript
@Injectable({
  providedIn: 'root' // Предпочтительный способ для большинства сервисов
})
export class SharedService {
  // Реализация сервиса
}
```

### 2. Создавайте интерфейсы для зависимостей

```typescript
export abstract class LoggerService {
  abstract log(message: string): void;
  abstract error(message: string): void;
  abstract warn(message: string): void;
}

@Injectable()
export class ConsoleLoggerService extends LoggerService {
  log(message: string): void {
    console.log(message);
  }
  
  error(message: string): void {
    console.error(message);
  }
  
  warn(message: string): void {
    console.warn(message);
  }
}

// В компоненте
constructor(@Inject(LoggerService) private logger: LoggerService) {
  this.logger.log('Component initialized');
}
```

### 3. Используйте токены для конфигурации

```typescript
export const API_CONFIG = new InjectionToken<ApiConfig>('api.config');

export interface ApiConfig {
  baseUrl: string;
  timeout: number;
  retryAttempts: number;
}

@Injectable()
export class ApiService {
  constructor(@Inject(API_CONFIG) private config: ApiConfig) {}
}
```

## Продвинутые сценарии

### Многоуровневая иерархия провайдеров

```typescript
// Сервис на уровне приложения
@Injectable({
  providedIn: 'root'
})
export class AppService {
  getValue(): string {
    return 'App level';
  }
}

// Сервис на уровне модуля
@Injectable()
export class ModuleService {
  getValue(): string {
    return 'Module level';
  }
}

// Сервис на уровне компонента
@Injectable()
export class ComponentService {
  getValue(): string {
    return 'Component level';
  }
}

// Модуль с провайдером
@NgModule({
  providers: [ModuleService]
})
export class FeatureModule {}

// Компонент с провайдером
@Component({
  selector: 'app-child',
  providers: [ComponentService]
})
export class ChildComponent {
  constructor(
    private appService: AppService,      // из корня
    private moduleService: ModuleService, // из модуля
    private compService: ComponentService // из компонента
  ) {}
}
```

## Связанные темы

- [[Декораторы-в-Angular]]
- [[Типизация-сервисов]]
- [[Типизация-компонентов]]
- [[Модули-Angular]]

## Ключевые выводы

- Инъекция зависимостей позволяет создавать слабосвязанные компоненты
- Angular предоставляет гибкую систему провайдеров с разными областями видимости
- Использование InjectionToken позволяет внедрять простые значения и конфигурации
- Правильное использование DI упрощает тестирование и поддержку кода
- Следование лучшим практикам делает приложение более предсказуемым и надежным