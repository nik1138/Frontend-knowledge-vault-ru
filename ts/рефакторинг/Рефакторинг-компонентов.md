---
aliases: [Рефакторинг компонентов, Компонентный рефакторинг]
tags: [refactoring, components, react, typescript, ui]
---

# Рефакторинг компонентов

Рефакторинг компонентов - это процесс улучшения структуры и архитектуры компонентов пользовательского интерфейса без изменения их внешнего поведения. Особенно актуален при работе с фреймворками, такими как [[React-с-TypeScript]], [[Vue-с-TypeScript]] или [[Angular-с-TypeScript]].

## Основные цели рефакторинга компонентов

### Улучшение читаемости и поддержки

Компоненты должны быть легко читаемыми и понятными для других разработчиков. Чистый код компонента облегчает:

- Поддержку существующего функционала
- Добавление новых функций
- Обучение новых членов команды
- Отладку и устранение багов

### Повышение переиспользуемости

Хорошо спроектированные компоненты должны быть переиспользуемыми в разных частях приложения:

- Уменьшение дублирования кода
- Более быстрая разработка новых функций
- Единообразие пользовательского интерфейса

### Оптимизация производительности

Рефакторинг может улучшить производительность компонентов:

- Уменьшение ненужных перерисовок
- Оптимизация обработки состояния
- Эффективное управление памятью

## Обнаружение проблем в компонентах

### Признаки необходимости рефакторинга

#### 1. Большой размер компонента

Компоненты с более чем 200-300 строками кода обычно нуждаются в разделении:

```typescript
// Плохо: огромный компонент
const UserProfile = () => {
  // 500+ строк кода с логикой и JSX
};
```

#### 2. Многоуровневые вложенные условия

Сложные условия делают компонент трудным для понимания:

```typescript
// Плохо: сложная логика отображения
const Dashboard = () => {
  if (user) {
    if (user.role === 'admin') {
      if (user.permissions.includes('read')) {
        // вложенные условия
      }
    }
  }
};
```

#### 3. Смешение логики и представления

Компонент не должен содержать сложной бизнес-логики:

```typescript
// Плохо: бизнес-логика в компоненте
const OrderSummary = () => {
  const calculateTotal = () => {
    // сложные вычисления
  };
  
  const applyDiscount = () => {
    // сложная логика скидок
  };
};
```

## Техники рефакторинга компонентов

### 1. Разделение компонентов

Разбивайте большие компоненты на более мелкие и специфичные:

```typescript
// До рефакторинга
const UserCard = () => {
  return (
    <div className="user-card">
      <div className="user-header">
        <img src={user.avatar} alt={user.name} />
        <h2>{user.name}</h2>
      </div>
      <div className="user-details">
        <p>Email: {user.email}</p>
        <p>Role: {user.role}</p>
      </div>
      <div className="user-actions">
        <button onClick={() => editUser(user.id)}>Edit</button>
        <button onClick={() => deleteUser(user.id)}>Delete</button>
      </div>
    </div>
  );
};

// После рефакторинга
const UserAvatar = ({ user }: { user: User }) => (
  <img src={user.avatar} alt={user.name} className="avatar" />
);

const UserHeader = ({ user }: { user: User }) => (
  <div className="user-header">
    <UserAvatar user={user} />
    <h2>{user.name}</h2>
  </div>
);

const UserDetails = ({ user }: { user: User }) => (
  <div className="user-details">
    <p>Email: {user.email}</p>
    <p>Role: {user.role}</p>
  </div>
);

const UserActions = ({ user, onEdit, onDelete }: { 
  user: User; 
  onEdit: (id: string) => void; 
  onDelete: (id: string) => void; 
}) => (
  <div className="user-actions">
    <button onClick={() => onEdit(user.id)}>Edit</button>
    <button onClick={() => onDelete(user.id)}>Delete</button>
  </div>
);

const UserCard = ({ user }: { user: User }) => {
  const handleEdit = (id: string) => editUser(id);
  const handleDelete = (id: string) => deleteUser(id);
  
  return (
    <div className="user-card">
      <UserHeader user={user} />
      <UserDetails user={user} />
      <UserActions user={user} onEdit={handleEdit} onDelete={handleDelete} />
    </div>
  );
};
```

### 2. Извлечение логики в хуки

Выносите сложную логику в пользовательские хуки:

```typescript
// До рефакторинга
const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await api.getUser(userId);
        setUser(userData);
      } catch (err) {
        setError('Failed to fetch user');
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  const updateUser = async (data: Partial<User>) => {
    try {
      const updatedUser = await api.updateUser(userId, data);
      setUser(updatedUser);
    } catch (err) {
      setError('Failed to update user');
    }
  };

  // JSX компонента
};

// После рефакторинга
const useUser = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await api.getUser(userId);
        setUser(userData);
      } catch (err) {
        setError('Failed to fetch user');
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  const updateUser = async (data: Partial<User>) => {
    try {
      const updatedUser = await api.updateUser(userId, data);
      setUser(updatedUser);
      return updatedUser;
    } catch (err) {
      setError('Failed to update user');
      throw err;
    }
  };

  return { user, loading, error, updateUser };
};

const UserProfile = ({ userId }: { userId: string }) => {
  const { user, loading, error, updateUser } = useUser(userId);

  // JSX компонента
};
```

### 3. Использование утилитарных функций

Выносите сложные вычисления в утилитарные функции:

```typescript
// utils/userUtils.ts
export const formatUserName = (user: User): string => {
  return `${user.firstName} ${user.lastName}`;
};

export const getUserRoleLabel = (role: UserRole): string => {
  const labels = {
    admin: 'Administrator',
    manager: 'Manager',
    employee: 'Employee',
  };
  return labels[role] || 'User';
};

// В компоненте
import { formatUserName, getUserRoleLabel } from '../utils/userUtils';

const UserDisplay = ({ user }: { user: User }) => {
  return (
    <div>
      <h3>{formatUserName(user)}</h3>
      <p>Role: {getUserRoleLabel(user.role)}</p>
    </div>
  );
};
```

### 4. Оптимизация рендеринга

Используйте `React.memo`, `useMemo` и `useCallback` для оптимизации производительности:

```typescript
// Оптимизация компонента
const ExpensiveComponent = React.memo(({ data, onUpdate }: Props) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      calculatedValue: complexCalculation(item)
    }));
  }, [data]);

  const handleUpdate = useCallback((id: string) => {
    onUpdate(id);
  }, [onUpdate]);

  return (
    <div>
      {processedData.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item} 
          onUpdate={handleUpdate} 
        />
      ))}
    </div>
  );
});
```

## Паттерны рефакторинга компонентов

### 1. Паттерн Container/Presenter

Разделяет логику получения данных (Container) и отображения (Presenter):

```typescript
// UserContainer.tsx
const UserContainer = () => {
  const { user, loading, error } = useUser(userId);
  
  return (
    <UserPresenter 
      user={user} 
      loading={loading} 
      error={error} 
      onRefresh={() => refetch()} 
    />
  );
};

// UserPresenter.tsx
interface UserPresenterProps {
  user: User | null;
  loading: boolean;
  error: string | null;
  onRefresh: () => void;
}

const UserPresenter: React.FC<UserPresenterProps> = ({ 
  user, 
  loading, 
  error, 
  onRefresh 
}) => {
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} onRetry={onRefresh} />;
  
  return (
    <div className="user-profile">
      <h1>{user?.name}</h1>
      <p>{user?.email}</p>
    </div>
  );
};
```

### 2. Паттерн Render Props

Позволяет делиться кодом между компонентами с помощью функции в качестве дочернего элемента:

```typescript
interface DataFetcherProps {
  url: string;
  children: (data: any, loading: boolean, error: string | null) => React.ReactNode;
}

const DataFetcher: React.FC<DataFetcherProps> = ({ url, children }) => {
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError('Failed to fetch data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return children(data, loading, error);
};

// Использование
const UserProfile = () => (
  <DataFetcher url="/api/user/123">
    {(user, loading, error) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error}</div>;
      return <div>Hello, {user?.name}!</div>;
    }}
  </DataFetcher>
);
```

### 3. Паттерн Higher-Order Component (HOC)

Функция, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью:

```typescript
const withLoading = <P extends object>(WrappedComponent: React.ComponentType<P>) => {
  return (props: P & { loading: boolean }) => {
    if (props.loading) {
      return <div>Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

const UserProfile = ({ user }: { user: User }) => (
  <div>{user.name}</div>
);

const UserProfileWithLoading = withLoading(UserProfile);
```

## Типизация компонентов

### Строгая типизация пропсов

```typescript
interface UserCardProps {
  user: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'manager' | 'employee';
  };
  onEdit: (userId: string) => void;
  onDelete: (userId: string) => void;
  className?: string;
}

const UserCard: React.FC<UserCardProps> = ({ 
  user, 
  onEdit, 
  onDelete, 
  className = '' 
}) => {
  return (
    <div className={`user-card ${className}`}>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
};
```

### Дженерики в компонентах

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <div>
      {items.map((item, index) => (
        <div key={keyExtractor(item)}>
          {renderItem(item, index)}
        </div>
      ))}
    </div>
  );
}

// Использование
<List<User>
  items={users}
  renderItem={(user) => <UserCard user={user} />}
  keyExtractor={(user) => user.id}
/>
```

## Практические рекомендации

### 1. Используйте композицию вместо наследования

React рекомендует использовать композицию вместо наследования для многократного использования кода:

```typescript
// Вместо наследования
interface ModalProps {
  children: React.ReactNode;
  isOpen: boolean;
  onClose: () => void;
}

const Modal: React.FC<ModalProps> = ({ children, isOpen, onClose }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <button onClick={onClose}>×</button>
        {children}
      </div>
    </div>
  );
};

// Композиция
const UserModal = ({ user, isOpen, onClose }: { 
  user: User; 
  isOpen: boolean; 
  onClose: () => void; 
}) => (
  <Modal isOpen={isOpen} onClose={onClose}>
    <h2>{user.name}</h2>
    <p>{user.email}</p>
  </Modal>
);
```

### 2. Организация файлов

Следуйте согласованной структуре файлов:

```
components/
├── UserCard/
│   ├── UserCard.tsx
│   ├── UserCard.types.ts
│   ├── UserCard.styles.ts
│   └── index.ts
└── UserProfile/
    ├── UserProfile.tsx
    ├── UserProfile.hooks.ts
    └── index.ts
```

### 3. Тестирование компонентов

Пишите тесты для компонентов:

```typescript
// UserCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { UserCard } from './UserCard';

describe('UserCard', () => {
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com'
  };

  const mockOnEdit = jest.fn();
  const mockOnDelete = jest.fn();

  it('renders user information correctly', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={mockOnEdit} 
        onDelete={mockOnDelete} 
      />
    );

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={mockOnEdit} 
        onDelete={mockOnDelete} 
      />
    );

    fireEvent.click(screen.getByText('Edit'));
    expect(mockOnEdit).toHaveBeenCalledWith('1');
  });
});
```

## Заключение

Рефакторинг компонентов - важная часть поддержания качества кода в пользовательском интерфейсе. Следование этим принципам и техникам помогает создавать более читаемые, поддерживаемые и эффективные компоненты.

> [!summary] Ключевые выводы
> - Разделяйте большие компоненты на более мелкие и специфичные
> - Выносите сложную логику в пользовательские хуки
> - Используйте строгую типизацию для пропсов и состояния
> - Оптимизируйте производительность с помощью memo и useCallback
> - Пишите тесты для проверки корректности компонентов
> - Следуйте согласованным паттернам и структуре файлов

> [!tip] Совет
> Регулярно проводите рефакторинг компонентов в рамках спринтов, чтобы предотвратить накопление технического долга.

> [!warning] Важно
> Всегда убедитесь, что у вас есть полный набор тестов перед выполнением рефакторинга компонентов, чтобы избежать регрессий.