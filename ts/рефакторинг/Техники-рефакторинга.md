---
aliases: [Техники рефакторинга, Методы рефакторинга, Паттерны рефакторинга]
tags: [refactoring, techniques, patterns, typescript]
---

# Техники рефакторинга

Техники рефакторинга - это систематизированные методы улучшения структуры кода без изменения его поведения. В этой статье рассмотрим основные техники рефакторинга TypeScript-кода с примерами и объяснениями.

## Базовые техники

### 1. Извлечение переменной (Extract Variable)

Заменяет сложное выражение переменной с понятным именем.

```typescript
// До рефакторинга
if (order.date > Date.now() - 24 * 60 * 60 * 1000 && order.status === 'pending') {
  // обработка свежих заказов
}

// После рефакторинга
const isOrderFresh = order.date > Date.now() - 24 * 60 * 60 * 1000;
const isOrderPending = order.status === 'pending';

if (isOrderFresh && isOrderPending) {
  // обработка свежих заказов
}
```

### 2. Извлечение функции (Extract Function)

Выносит часть кода в отдельную функцию с понятным именем.

```typescript
// До рефакторинга
function calculateTotal(items: Item[], taxRate: number): number {
  let total = 0;
  for (const item of items) {
    total += item.price * item.quantity;
  }
  
  const tax = total * taxRate;
  return total + tax;
}

// После рефакторинга
function calculateSubtotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

function calculateTax(subtotal: number, taxRate: number): number {
  return subtotal * taxRate;
}

function calculateTotal(items: Item[], taxRate: number): number {
  const subtotal = calculateSubtotal(items);
  const tax = calculateTax(subtotal, taxRate);
  return subtotal + tax;
}
```

### 3. Встраивание переменной (Inline Variable)

Обратная операция к извлечению переменной - удаляет переменную и использует выражение напрямую.

```typescript
// До рефакторинга
const temp = this.customer.name;
return `Hello, ${temp}!`;

// После рефакторинга
return `Hello, ${this.customer.name}!`;
```

## Промежуточные техники

### 4. Замена условного оператора полиморфизмом

Заменяет условные операторы на наследование и полиморфизм.

```typescript
// До рефакторинга
class Employee {
  type: 'engineer' | 'manager' | 'salesperson';
  
  calculatePay(): number {
    switch (this.type) {
      case 'engineer':
        return this.baseSalary + this.bonus;
      case 'manager':
        return this.baseSalary + this.stockOptions;
      case 'salesperson':
        return this.baseSalary + this.commission;
      default:
        throw new Error('Unknown employee type');
    }
  }
}

// После рефакторинга
abstract class Employee {
  abstract calculatePay(): number;
}

class Engineer extends Employee {
  calculatePay(): number {
    return this.baseSalary + this.bonus;
  }
}

class Manager extends Employee {
  calculatePay(): number {
    return this.baseSalary + this.stockOptions;
  }
}

class Salesperson extends Employee {
  calculatePay(): number {
    return this.baseSalary + this.commission;
  }
}
```

### 5. Замена параметра вызовом метода

Заменяет передачу параметра вызовом метода объекта.

```typescript
// До рефакторинга
class Order {
  getDiscount(customer: Customer, discountType: 'regular' | 'vip' | 'premium'): number {
    // расчет скидки
  }
}

// После рефакторинга
class Order {
  getDiscount(customer: Customer): number {
    return this.calculateDiscount(customer.getDiscountType());
  }
}

class Customer {
  getDiscountType(): 'regular' | 'vip' | 'premium' {
    // определение типа скидки
  }
}
```

### 6. Замена конструктора фабричным методом

Заменяет конструктор на фабричный метод для более гибкой инициализации.

```typescript
// До рефакторинга
class PaymentProcessor {
  constructor(type: 'credit' | 'debit' | 'paypal') {
    // инициализация в зависимости от типа
  }
}

// После рефакторинга
class PaymentProcessor {
  private constructor() {}
  
  static createCreditProcessor(): PaymentProcessor {
    const processor = new PaymentProcessor();
    // настройка кредитного процессора
    return processor;
  }
  
  static createDebitProcessor(): PaymentProcessor {
    const processor = new PaymentProcessor();
    // настройка дебетового процессора
    return processor;
  }
  
  static createPayPalProcessor(): PaymentProcessor {
    const processor = new PaymentProcessor();
    // настройка PayPal процессора
    return processor;
  }
}
```

## Продвинутые техники

### 7. Введение параметра (Introduce Parameter)

Добавляет параметр к методу для увеличения его гибкости.

```typescript
// До рефакторинга
class ReportGenerator {
  generateReport(): string {
    const data = this.fetchData();
    return this.formatReport(data, 'csv'); // жестко заданный формат
  }
}

// После рефакторинга
class ReportGenerator {
  generateReport(format: 'csv' | 'json' | 'xml' = 'csv'): string {
    const data = this.fetchData();
    return this.formatReport(data, format);
  }
}
```

### 8. Удаление параметра (Remove Parameter)

Убирает неиспользуемый параметр из метода.

```typescript
// До рефакторинга
function calculateArea(width: number, height: number, unusedParam: string): number {
  return width * height;
}

// После рефакторинга
function calculateArea(width: number, height: number): number {
  return width * height;
}
```

### 9. Замена алгоритма

Заменяет реализацию метода другим алгоритмом без изменения интерфейса.

```typescript
// До рефакторинга - медленный алгоритм
function findMaxValue(arr: number[]): number {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      for (let j = 0; j < i; j++) {
        if (arr[j] === max) {
          // дополнительная логика
        }
      }
      max = arr[i];
    }
  }
  return max;
}

// После рефакторинга - эффективный алгоритм
function findMaxValue(arr: number[]): number {
  return Math.max(...arr);
}
```

## Техники работы с классами

### 10. Извлечение класса (Extract Class)

Создает новый класс, чтобы извлечь часть обязанностей из существующего класса.

```typescript
// До рефакторинга
class Person {
  name: string;
  officeAreaCode: string;
  officeNumber: string;
  
  getTelephoneNumber(): string {
    return `(${this.officeAreaCode}) ${this.officeNumber}`;
  }
}

// После рефакторинга
class TelephoneNumber {
  areaCode: string;
  number: string;
  
  getTelephoneNumber(): string {
    return `(${this.areaCode}) ${this.number}`;
  }
}

class Person {
  name: string;
  telephoneNumber: TelephoneNumber;
  
  getTelephoneNumber(): string {
    return this.telephoneNumber.getTelephoneNumber();
  }
}
```

### 11. Встраивание класса (Inline Class)

Обратная операция к извлечению класса - перемещает поведение класса в другой класс.

### 12. Скрытие делегата (Hide Delegate)

Инкапсулирует делегирование, скрывая внутреннюю структуру объекта.

```typescript
// До рефакторинга
customer.billingPlan.name = 'New Plan';

// После рефакторинга
customer.setBillingPlanName('New Plan');
```

### 13. Удаление посредника (Remove Middle Man)

Убирает ненужные делегирующие методы.

```typescript
// До рефакторинга
class Customer {
  private billingPlan: BillingPlan;
  
  getPlan(): BillingPlan {
    return this.billingPlan;
  }
  
  setPlan(plan: BillingPlan): void {
    this.billingPlan = plan;
  }
}

// После рефакторинга
class Customer {
  billingPlan: BillingPlan;
}
```

## Техники работы с условиями

### 14. Разбиение условного оператора (Decompose Conditional)

Разбивает сложное условие на несколько методов.

```typescript
// До рефакторинга
if (date.isBefore(summerStart) || date.isAfter(summerEnd)) {
  charge = quantity * winterRate + winterServiceCharge;
} else {
  charge = quantity * summerRate;
}

// После рефакторинга
if (isSummer(date)) {
  charge = summerCharge(quantity);
} else {
  charge = winterCharge(quantity);
}

function isSummer(date: Date): boolean {
  return date.isAfter(summerStart) && date.isBefore(summerEnd);
}

function summerCharge(quantity: number): number {
  return quantity * summerRate;
}

function winterCharge(quantity: number): number {
  return quantity * winterRate + winterServiceCharge;
}
```

### 15. Консолидация условного оператора

Объединяет проверки условий в одном месте.

## Техники работы с ошибками

### 16. Замена возвращаемого значения ошибкой

Заменяет возвращение специальных значений на выброс исключений.

```typescript
// До рефакторинга
function findUser(id: string): User | null {
  // поиск пользователя
  return user || null;
}

// После рефакторинга
function findUser(id: string): User {
  // поиск пользователя
  if (!user) {
    throw new UserNotFoundError(`User with id ${id} not found`);
  }
  return user;
}
```

### 17. Замена исключения проверкой

Заменяет выброс исключений на возвращение специальных значений.

## Современные TypeScript-техники

### 18. Использование дженериков

```typescript
// До рефакторинга
function identity(arg: any): any {
  return arg;
}

// После рефакторинга
function identity<T>(arg: T): T {
  return arg;
}
```

### 19. Использование типов и интерфейсов

```typescript
// До рефакторинга
function processUser(userData: any): any {
  // обработка
}

// После рефакторинга
interface User {
  id: string;
  name: string;
  email: string;
}

function processUser(userData: User): ProcessedUser {
  // обработка
}
```

### 20. Использование утилитарных типов

```typescript
// Использование утилитарных типов TypeScript
type PartialUser = Partial<User>;
type ReadOnlyUser = Readonly<User>;
type UserKeys = keyof User;
```

## Практические рекомендации

### Планирование рефакторинга

1. [[Принципы-рефакторинга]] - следуйте основным принципам
2. [[Безопасный-рефакторинг]] - используйте безопасные методы
3. [[Инструменты-для-рефакторинга]] - применяйте автоматизированные инструменты

### Проверка качества

- Пишите [[Тесты-для-рефакторинга]] перед началом изменений
- Используйте [[Статический-анализ-кода]] для проверки качества
- Проводите [[Код-ревью]] после завершения рефакторинга

> [!tip] Совет
> Выполняйте рефакторинг маленькими шагами и регулярно тестируйте код, чтобы убедиться, что поведение не изменилось.

> [!warning] Важно
> Перед выполнением рефакторинга обязательно убедитесь, что у вас есть полный набор автоматических тестов, покрывающих изменяемую функциональность.

## Заключение

Техники рефакторинга - это мощный инструмент для улучшения качества кода. Правильное их применение делает код более читаемым, поддерживаемым и расширяемым. Важно понимать, когда и какие техники применять, а также учитывать контекст конкретной задачи.

> [!summary] Ключевые выводы
> - Используйте базовые техники для улучшения читаемости кода
> - Применяйте промежуточные техники для улучшения архитектуры
> - Используйте продвинутые техники для сложных случаев
> - Следуйте принципам [[Принципы-рефакторинга]] при выполнении изменений
> - Проверяйте качество кода с помощью [[Инструменты-для-рефакторинга]]