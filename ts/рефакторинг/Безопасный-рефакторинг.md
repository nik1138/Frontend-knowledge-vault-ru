---
aliases: [Безопасный рефакторинг, Безопасные методы рефакторинга]
tags: [refactoring, safety, testing, typescript, best-practices]
---

# Безопасный рефакторинг

Безопасный рефакторинг - это подход к улучшению кода, при котором минимизируется риск внесения ошибок. Он включает в себя использование автоматизированных тестов, пошаговые изменения и инструменты для проверки корректности кода.

## Основные принципы безопасного рефакторинга

### 1. Наличие автоматических тестов

Перед началом рефакторинга необходимо убедиться в наличии надежного набора тестов:

- [[Модульное-тестирование]] - проверяет отдельные функции и компоненты
- [[Интеграционное-тестирование]] - проверяет взаимодействие между модулями
- [[Приемочные-тесты]] - проверяет бизнес-логику

```typescript
// Пример модульного теста перед рефакторингом
describe('calculateTotal', () => {
  it('should calculate total with tax', () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 15, quantity: 1 }
    ];
    const result = calculateTotal(items, 0.1);
    expect(result).toBe(36.5); // 25 * 1.1 = 27.5, wait... let's fix: (10*2 + 15*1) * 1.1 = 41.25
  });
});
```

### 2. Маленькие шаги

Рефакторинг должен выполняться небольшими, проверяемыми шагами:

1. Вносите минимальное изменение
2. Запускайте тесты
3. Убедитесь, что все работает
4. Фиксируйте изменения
5. Повторите

> [!tip] Совет
> Каждый коммит должен представлять собой рабочее состояние кода. Это позволяет легко откатиться в случае ошибки.

### 3. Использование IDE и инструментов

Современные IDE и инструменты обеспечивают безопасность рефакторинга:

- [[Инструменты-для-рефакторинга]] - автоматизированные инструменты
- [[TypeScript]] - проверка типов
- [[ESLint]] - проверка стиля кода

## Практические техники безопасного рефакторинга

### 1. Техника "Шаг вперед, шаг назад"

Сначала добавьте новую функциональность параллельно старой, затем переключите использование на новую, и только потом удалите старую:

```typescript
// До рефакторинга
function processOrder(order: Order): void {
  // старая сложная логика
}

// Добавляем новую реализацию
function processOrderNew(order: Order): void {
  // улучшенная логика
}

// Переключаем использование
function processOrder(order: Order): void {
  return processOrderNew(order);
}

// Удаляем старую реализацию (после проверки)
```

### 2. Использование Feature Flags

Для безопасного введения изменений в продакшен-код:

```typescript
// Конфигурация фич-флагов
const FEATURE_FLAGS = {
  NEW_ORDER_PROCESSING: process.env.NEW_ORDER_PROCESSING === 'true',
};

// Использование фич-флага
function processOrder(order: Order): void {
  if (FEATURE_FLAGS.NEW_ORDER_PROCESSING) {
    return processOrderNew(order);
  }
  return processOrderOld(order);
}
```

### 3. Параллельное выполнение

Сравнивайте результаты старой и новой реализации:

```typescript
function calculateTotalNew(items: Item[], taxRate: number): number {
  // новая реализация
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0) * (1 + taxRate);
}

function calculateTotal(items: Item[], taxRate: number): number {
  const oldResult = calculateTotalOld(items, taxRate);
  const newResult = calculateTotalNew(items, taxRate);
  
  // В тестовой среде или с логированием
  if (process.env.NODE_ENV === 'development' || Math.abs(oldResult - newResult) > 0.001) {
    console.warn('Results differ:', { old: oldResult, new: newResult });
  }
  
  return newResult; // используем новую реализацию
}
```

## Безопасный рефакторинг функций

### 1. Сохранение сигнатуры функции

При рефакторинге функции сохраняйте её сигнатуру (имя, параметры, возвращаемый тип):

```typescript
// До рефакторинга
function validateUser(user: any): boolean {
  return user && user.name && user.email && user.age > 0;
}

// После рефакторинга - сохраняем сигнатуру
function validateUser(user: User): boolean {
  const requiredFields = ['name', 'email'];
  return requiredFields.every(field => 
    user[field as keyof User] !== undefined && user[field as keyof User] !== ''
  ) && user.age > 0;
}
```

### 2. Пошаговое улучшение логики

```typescript
// До рефакторинга
function processUserData(userData: any): ProcessedUser {
  if (!userData) return null;
  if (!userData.name) return null;
  if (!userData.email) return null;
  
  return {
    id: userData.id || generateId(),
    name: userData.name.trim(),
    email: userData.email.toLowerCase().trim(),
    age: userData.age || 0,
    createdAt: userData.createdAt || new Date()
  };
}

// Этап 1: Выносим проверки в отдельные функции
function isUserDataValid(userData: any): boolean {
  return userData && userData.name && userData.email;
}

function processUserData(userData: any): ProcessedUser {
  if (!isUserDataValid(userData)) return null;
  
  return {
    id: userData.id || generateId(),
    name: userData.name.trim(),
    email: userData.email.toLowerCase().trim(),
    age: userData.age || 0,
    createdAt: userData.createdAt || new Date()
  };
}

// Этап 2: Выносим создание объекта в отдельную функцию
function createProcessedUser(userData: any): ProcessedUser {
  return {
    id: userData.id || generateId(),
    name: userData.name.trim(),
    email: userData.email.toLowerCase().trim(),
    age: userData.age || 0,
    createdAt: userData.createdAt || new Date()
  };
}

function processUserData(userData: any): ProcessedUser {
  if (!isUserDataValid(userData)) return null;
  return createProcessedUser(userData);
}
```

## Безопасный рефакторинг классов

### 1. Сохранение интерфейса класса

При рефакторинге класса сохраняйте его публичный интерфейс:

```typescript
// До рефакторинга
class OrderProcessor {
  processOrder(order: Order): ProcessedOrder {
    // сложная логика
  }
}

// После рефакторинга - сохраняем интерфейс
class OrderProcessor {
  private validator: OrderValidator;
  private calculator: OrderCalculator;
  
  constructor() {
    this.validator = new OrderValidator();
    this.calculator = new OrderCalculator();
  }
  
  processOrder(order: Order): ProcessedOrder {
    this.validator.validate(order);
    const calculatedOrder = this.calculator.calculate(order);
    return this.saveOrder(calculatedOrder);
  }
  
  private saveOrder(order: Order): ProcessedOrder {
    // сохранение заказа
  }
}
```

### 2. Использование абстракций

```typescript
interface PaymentProcessor {
  process(payment: Payment): PaymentResult;
}

class CreditCardProcessor implements PaymentProcessor {
  process(payment: Payment): PaymentResult {
    // обработка кредитной карты
  }
}

class PayPalProcessor implements PaymentProcessor {
  process(payment: Payment): PaymentResult {
    // обработка PayPal
  }
}

// Клиентский код не изменяется при добавлении новых процессоров
class PaymentService {
  constructor(private processor: PaymentProcessor) {}
  
  handlePayment(payment: Payment): PaymentResult {
    return this.processor.process(payment);
  }
}
```

## Безопасный рефакторинг асинхронного кода

### 1. Сохранение асинхронной природы

```typescript
// До рефакторинга
async function fetchUserData(userId: string): Promise<User> {
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  return response.json();
}

// После рефакторинга - сохраняем асинхронность
async function fetchUserData(userId: string): Promise<User> {
  const url = buildUserApiUrl(userId);
  const response = await fetch(url, {
    headers: getAuthHeaders(),
  });
  
  await checkResponse(response);
  return parseUserResponse(response);
}

// Вспомогательные функции
function buildUserApiUrl(userId: string): string {
  return `${API_BASE_URL}/users/${userId}`;
}

async function checkResponse(response: Response): Promise<void> {
  if (!response.ok) {
    const errorData = await response.json();
    throw new ApiError(errorData.message, response.status);
  }
}

async function parseUserResponse(response: Response): Promise<User> {
  const data = await response.json();
  return validateAndTransformUser(data);
}
```

### 2. Обработка ошибок

```typescript
// Безопасная обработка ошибок
async function safeFetchUserData(userId: string): Promise<User | null> {
  try {
    return await fetchUserData(userId);
  } catch (error) {
    console.error(`Failed to fetch user ${userId}:`, error);
    return null; // или выбросить кастомную ошибку
  }
}
```

## Использование TypeScript для безопасности

### 1. Постепенная типизация

```typescript
// Начинаем с any и постепенно уточняем типы
function processUserData(userData: any): any {
  // логика обработки
}

// Затем уточняем типы
interface RawUserData {
  name: string;
  email: string;
  age?: number;
}

interface ProcessedUser {
  id: string;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
}

function processUserData(userData: RawUserData): ProcessedUser {
  // улучшенная логика с типами
}
```

### 2. Использование утилитарных типов

```typescript
// Использование утилитарных типов для безопасного рефакторинга
type PartialUser = Partial<User>;
type ReadOnlyUser = Readonly<User>;
type UserUpdate = Pick<User, 'name' | 'email'>;
type UserCreation = Omit<User, 'id'>;
```

## Практические проверки безопасности

### 1. Проверка перед рефакторингом

```typescript
// Проверьте, что:
// 1. Все тесты проходят
console.log('Running tests before refactoring...');
const testResult = runTests();
if (!testResult.success) {
  throw new Error('Tests failed, cannot proceed with refactoring');
}

// 2. Типы корректны
console.log('Checking types...');
const typeCheckResult = checkTypes();
if (!typeCheckResult.success) {
  throw new Error('Type errors found, fix them before refactoring');
}

// 3. Линтер не ругается
console.log('Linting...');
const lintResult = lint();
if (lintResult.errors.length > 0) {
  throw new Error('Lint errors found, fix them before refactoring');
}
```

### 2. Проверка после рефакторинга

```typescript
// После каждого шага рефакторинга:
// 1. Запускайте тесты
runTests();

// 2. Проверяйте типы
checkTypes();

// 3. Проверяйте логику на простых примерах
const simpleTest = calculateTotal([{ price: 10, quantity: 2 }], 0);
console.assert(simpleTest === 20, 'Simple calculation failed');
```

## Инструменты для безопасного рефакторинга

### 1. Автоматизированные тесты

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "type-check": "tsc --noEmit",
    "lint": "eslint src/ --ext .ts,.tsx"
  }
}
```

### 2. Continuous Integration

Настройте CI/CD для автоматической проверки:

```yaml
# .github/workflows/refactoring-check.yml
name: Refactoring Safety Check
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - run: npm ci
      - run: npm run test
      - run: npm run type-check
      - run: npm run lint
```

## Заключение

Безопасный рефакторинг - это ключ к поддержанию высокого качества кода без риска внесения ошибок. Следование этим принципам и использованию соответствующих инструментов позволяет улучшать код с минимальным риском.

> [!summary] Ключевые выводы
> - Всегда начинайте с полного набора тестов
> - Выполняйте рефакторинг маленькими шагами
> - Используйте автоматизированные инструменты для проверки
> - Сохраняйте интерфейсы при изменении реализации
> - Регулярно проверяйте типы и стили кода

> [!warning] Важно
> Никогда не начинайте рефакторинг без надежного набора тестов. Без них вы не сможете быть уверены, что не сломали существующую функциональность.

> [!tip] Совет
> Используйте Git для фиксации каждого этапа рефакторинга. Это позволяет легко откатиться к предыдущему рабочему состоянию при возникновении проблем.