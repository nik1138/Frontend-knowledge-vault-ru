---
aliases: [Оптимизация рендеринга, Производительность VR, Оптимизация VR-приложений]
tags: [vr, ar, typescript, performance, rendering, optimization, webgl, threejs]
---

# Оптимизация рендеринга VR/AR-приложений

## Введение в оптимизацию VR-рендеринга

Оптимизация рендеринга в VR-приложениях критически важна для обеспечения плавного опыта пользователя. В отличие от традиционных 2D-приложений, VR-приложения должны поддерживать высокую частоту кадров (обычно 90 или 120 FPS) для предотвращения укачивания и обеспечения комфорта пользователя.

## Основные принципы оптимизации

### Частота кадров и задержка

VR-приложения должны поддерживать стабильную частоту кадров:

- **90 FPS** - минимальная частота для комфортного VR-опыта
- **110-120 FPS** - оптимальная частота для премиальных VR-устройств
- **Максимальная задержка** - не более 20 мс от ввода до отображения

```typescript
class FrameRateMonitor {
  private frameCount = 0;
  private lastSecond = performance.now();
  private currentFPS = 0;
  
  public update(): number {
    this.frameCount++;
    const now = performance.now();
    
    if (now >= this.lastSecond + 1000) {
      this.currentFPS = this.frameCount;
      this.frameCount = 0;
      this.lastSecond = now;
      
      console.log(`Текущая частота кадров: ${this.currentFPS} FPS`);
    }
    
    return this.currentFPS;
  }
  
  public isPerformanceCritical(): boolean {
    return this.currentFPS < 70; // Порог для критической производительности
  }
}
```

## Оптимизация геометрии

### Уровни детализации (LOD)

Использование LOD позволяет отображать более простые модели на больших расстояниях:

```typescript
import * as THREE from 'three';

class LODManager {
  private lods: Map<string, THREE.LOD> = new Map();
  
  public createLOD(
    objectId: string,
    highDetail: THREE.Object3D,
    mediumDetail: THREE.Object3D,
    lowDetail: THREE.Object3D
  ): THREE.LOD {
    const lod = new THREE.LOD();
    
    // Добавление уровней детализации
    lod.addLevel(highDetail, 0);      // 0-20 метров
    lod.addLevel(mediumDetail, 20);   // 20-50 метров
    lod.addLevel(lowDetail, 50);      // 50+ метров
    
    this.lods.set(objectId, lod);
    return lod;
  }
  
  public updateLODs(camera: THREE.Camera): void {
    for (const lod of this.lods.values()) {
      lod.update(camera);
    }
  }
}
```

### Instanced Rendering

Для отображения множества одинаковых объектов используйте инстансирование:

```typescript
class InstancedRenderer {
  private instancedMesh: THREE.InstancedMesh;
  private tempMatrix: THREE.Matrix4 = new THREE.Matrix4();
  private positions: THREE.Vector3[] = [];
  
  constructor(
    geometry: THREE.BufferGeometry,
    material: THREE.Material,
    count: number
  ) {
    this.instancedMesh = new THREE.InstancedMesh(geometry, material, count);
  }
  
  public addInstance(position: THREE.Vector3, rotation?: THREE.Euler, scale?: THREE.Vector3): number {
    const index = this.positions.length;
    if (index >= this.instancedMesh.count) {
      throw new Error('Превышено максимальное количество инстансов');
    }
    
    this.tempMatrix.compose(
      position,
      rotation || new THREE.Euler(),
      scale || new THREE.Vector3(1, 1, 1)
    );
    
    this.instancedMesh.setMatrixAt(index, this.tempMatrix);
    this.positions.push(position.clone());
    
    this.instancedMesh.instanceMatrix.needsUpdate = true;
    return index;
  }
  
  public updateInstance(index: number, newPosition: THREE.Vector3): void {
    if (index >= this.positions.length) return;
    
    this.positions[index].copy(newPosition);
    this.tempMatrix.compose(
      newPosition,
      new THREE.Euler(),
      new THREE.Vector3(1, 1, 1)
    );
    
    this.instancedMesh.setMatrixAt(index, this.tempMatrix);
    this.instancedMesh.instanceMatrix.needsUpdate = true;
  }
  
  public getMesh(): THREE.InstancedMesh {
    return this.instancedMesh;
  }
}
```

## Оптимизация текстур и материалов

### Управление текстурами

```typescript
class TextureManager {
  private textureCache: Map<string, THREE.Texture> = new Map();
  private textureLoader: THREE.TextureLoader;
  
  constructor() {
    this.textureLoader = new THREE.TextureLoader();
  }
  
  public async loadTexture(url: string, options?: TextureOptions): Promise<THREE.Texture> {
    // Проверка кэша
    if (this.textureCache.has(url)) {
      return this.textureCache.get(url)!;
    }
    
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          // Оптимизация текстуры
          if (options?.generateMipmaps !== false) {
            texture.generateMipmaps = true;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
          }
          
          if (options?.anisotropy) {
            texture.anisotropy = options.anisotropy;
          }
          
          // Установка формата для экономии памяти
          if (options?.compress) {
            texture.format = THREE.RGBAFormat;
          }
          
          this.textureCache.set(url, texture);
          resolve(texture);
        },
        undefined,
        reject
      );
    });
  }
  
  public disposeTexture(url: string): void {
    const texture = this.textureCache.get(url);
    if (texture) {
      texture.dispose();
      this.textureCache.delete(url);
    }
  }
  
  public clearCache(): void {
    for (const texture of this.textureCache.values()) {
      texture.dispose();
    }
    this.textureCache.clear();
  }
}

interface TextureOptions {
  generateMipmaps?: boolean;
  anisotropy?: number;
  compress?: boolean;
}
```

### Оптимизация материалов

```typescript
class MaterialOptimizer {
  // Создание оптимизированных материалов
  public static createOptimizedStandardMaterial(params: THREE.MeshStandardMaterialParameters = {}): THREE.MeshStandardMaterial {
    return new THREE.MeshStandardMaterial({
      // Упрощение расчетов освещения
      flatShading: false,
      // Отключение ненужных свойств
      wireframe: false,
      // Оптимизация для прозрачности
      transparent: params.transparent || false,
      // Уменьшение количества вычислений
      roughness: params.roughness !== undefined ? params.roughness : 0.5,
      metalness: params.metalness !== undefined ? params.metalness : 0.5,
      // Оптимизация теней
      color: params.color || 0xffffff,
      ...params
    });
  }
  
  // Создание материала для UI в VR
  public static createUIPanelMaterial(): THREE.MeshBasicMaterial {
    return new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide,
      // Отключение освещения для UI
      toneMapped: false
    });
  }
}
```

## Оптимизация освещения

### Упрощенное освещение

```typescript
class LightingOptimizer {
  private lights: THREE.Light[] = [];
  
  // Создание оптимизированного освещения
  public createOptimizedLighting(scene: THREE.Scene): void {
    // Ограничение количества источников света
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    // Один основной направленный свет
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    directionalLight.castShadow = true;
    
    // Оптимизация теней
    directionalLight.shadow.mapSize.width = 1024;  // Уменьшенный размер для производительности
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    
    scene.add(directionalLight);
    
    this.lights.push(ambientLight, directionalLight);
  }
  
  // Динамическое управление освещением
  public updateLightingBasedOnDistance(camera: THREE.Camera, objects: THREE.Object3D[]): void {
    for (const object of objects) {
      const distance = camera.position.distanceTo(object.position);
      
      // Отключение теней для удаленных объектов
      if (distance > 30) {
        (object as THREE.Mesh).castShadow = false;
        (object as THREE.Mesh).receiveShadow = false;
      } else {
        (object as THREE.Mesh).castShadow = true;
        (object as THREE.Mesh).receiveShadow = true;
      }
    }
  }
}
```

## Оптимизация рендеринга

### Frustum culling

```typescript
class FrustumCulling {
  private frustum: THREE.Frustum = new THREE.Frustum();
  private camera: THREE.Camera;
  private visibleObjects: Set<THREE.Object3D> = new Set();
  
  constructor(camera: THREE.Camera) {
    this.camera = camera;
  }
  
  public updateVisibility(objects: THREE.Object3D[]): void {
    // Обновление фрустума камеры
    this.camera.updateMatrixWorld();
    this.frustum.setFromProjectionMatrix(
      new THREE.Matrix4().multiplyMatrices(
        this.camera.projectionMatrix,
        this.camera.matrixWorldInverse
      )
    );
    
    // Очистка предыдущего состояния
    for (const obj of this.visibleObjects) {
      obj.visible = false;
    }
    this.visibleObjects.clear();
    
    // Проверка видимости объектов
    const visible: THREE.Object3D[] = [];
    
    for (const object of objects) {
      // Использование ограничивающей сферы для проверки
      if (!object.geometry) continue;
      
      object.geometry.computeBoundingSphere();
      const boundingSphere = object.geometry.boundingSphere;
      
      if (boundingSphere) {
        boundingSphere.applyMatrix4(object.matrixWorld);
        
        if (this.frustum.intersectsSphere(boundingSphere)) {
          object.visible = true;
          this.visibleObjects.add(object);
          visible.push(object);
        }
      }
    }
    
    console.log(`Отображается ${visible.length} объектов из ${objects.length}`);
  }
}
```

### Occlusion culling

```typescript
class OcclusionCulling {
  private renderer: THREE.WebGLRenderer;
  private objectsToCheck: THREE.Object3D[] = [];
  private visibleObjects: Set<THREE.Object3D> = new Set();
  
  constructor(renderer: THREE.WebGLRenderer) {
    this.renderer = renderer;
  }
  
  public addObjectsToCheck(objects: THREE.Object3D[]): void {
    this.objectsToCheck.push(...objects);
  }
  
  public updateOcclusion(camera: THREE.Camera, scene: THREE.Scene): void {
    // Очистка предыдущего состояния
    for (const obj of this.visibleObjects) {
      obj.visible = false;
    }
    this.visibleObjects.clear();
    
    // Для каждого объекта проверяем, виден ли он
    for (const object of this.objectsToCheck) {
      if (this.isObjectVisible(object, camera, scene)) {
        object.visible = true;
        this.visibleObjects.add(object);
      }
    }
  }
  
  private isObjectVisible(object: THREE.Object3D, camera: THREE.Camera, scene: THREE.Scene): boolean {
    // Упрощенная проверка видимости
    // В реальном приложении можно использовать более сложные методы
    const distance = camera.position.distanceTo(object.position);
    return distance < 50; // Простой порог для демонстрации
  }
}
```

## Оптимизация памяти

### Управление памятью

```typescript
class MemoryOptimizer {
  private geometryCache: Map<string, THREE.BufferGeometry> = new Map();
  private materialCache: Map<string, THREE.Material> = new Map();
  
  // Кэширование геометрии
  public cacheGeometry(id: string, geometry: THREE.BufferGeometry): void {
    // Проверка на дубликаты
    if (this.geometryCache.has(id)) {
      console.warn(`Геометрия с ID ${id} уже закэширована`);
      return;
    }
    
    this.geometryCache.set(id, geometry);
  }
  
  // Получение геометрии из кэша
  public getGeometry(id: string): THREE.BufferGeometry | null {
    return this.geometryCache.get(id) || null;
  }
  
  // Оптимизация геометрии
  public optimizeGeometry(geometry: THREE.BufferGeometry): void {
    // Удаление дубликатов вершин
    geometry.mergeVertices();
    
    // Оптимизация порядка индексов для лучшего использования GPU
    if (geometry.index) {
      (THREE as any).BufferGeometryUtils?.computeTangents?.(geometry);
    }
  }
  
  // Управление материалами
  public reuseMaterial(material: THREE.Material): THREE.Material {
    const materialKey = this.generateMaterialKey(material);
    
    if (this.materialCache.has(materialKey)) {
      // Возвращаем существующий материал
      return this.materialCache.get(materialKey)!;
    }
    
    // Сохраняем новый материал
    this.materialCache.set(materialKey, material);
    return material;
  }
  
  private generateMaterialKey(material: THREE.Material): string {
    // Создание уникального ключа на основе свойств материала
    if (material instanceof THREE.MeshStandardMaterial) {
      return `standard_${material.color.getHex()}_${material.roughness}_${material.metalness}`;
    }
    return material.type;
  }
  
  // Очистка кэша
  public cleanup(): void {
    // Удаление геометрии
    for (const geometry of this.geometryCache.values()) {
      geometry.dispose();
    }
    this.geometryCache.clear();
    
    // Удаление материалов
    for (const material of this.materialCache.values()) {
      if (material instanceof THREE.Material) {
        material.dispose();
      }
    }
    this.materialCache.clear();
  }
}
```

## Оптимизация для разных VR-устройств

### Адаптивная детализация

```typescript
class AdaptiveQualityManager {
  private currentQuality: QualityLevel = 'high';
  private deviceCapabilities: DeviceCapabilities;
  
  constructor() {
    this.deviceCapabilities = this.detectDeviceCapabilities();
  }
  
  private detectDeviceCapabilities(): DeviceCapabilities {
    // Определение возможностей устройства
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
    
    // Оценка производительности
    const performanceScore = this.estimatePerformance();
    
    return {
      isMobile,
      isStandalone,
      performanceScore,
      maxTextureSize: 2048, // Значение по умолчанию
      supportsWebGL2: !!document.createElement('canvas').getContext('webgl2')
    };
  }
  
  private estimatePerformance(): number {
    // Простая эвристика оценки производительности
    const memory = (navigator as any).deviceMemory || 4; // в ГБ
    const hardwareConcurrency = navigator.hardwareConcurrency || 4;
    
    return memory * hardwareConcurrency;
  }
  
  public adjustQuality(renderer: THREE.WebGLRenderer, scene: THREE.Scene): void {
    if (this.deviceCapabilities.performanceScore < 8) {
      // Низкая производительность - уменьшаем качество
      this.currentQuality = 'low';
      this.applyLowQualitySettings(renderer, scene);
    } else if (this.deviceCapabilities.performanceScore < 16) {
      // Средняя производительность
      this.currentQuality = 'medium';
      this.applyMediumQualitySettings(renderer, scene);
    } else {
      // Высокая производительность
      this.currentQuality = 'high';
      this.applyHighQualitySettings(renderer, scene);
    }
  }
  
  private applyLowQualitySettings(renderer: THREE.WebGLRenderer, scene: THREE.Scene): void {
    // Уменьшение разрешения рендеринга
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
    
    // Отключение теней
    scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.castShadow = false;
        object.receiveShadow = false;
      }
    });
    
    // Упрощение освещения
    const lightingOptimizer = new LightingOptimizer();
    lightingOptimizer.createOptimizedLighting(scene);
  }
  
  private applyMediumQualitySettings(renderer: THREE.WebGLRenderer, scene: THREE.Scene): void {
    // Среднее разрешение
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    
    // Ограниченные тени
    scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.castShadow = true;
        object.receiveShadow = (object.position.distanceTo(new THREE.Vector3()) < 20);
      }
    });
  }
  
  private applyHighQualitySettings(renderer: THREE.WebGLRenderer, scene: THREE.Scene): void {
    // Полное разрешение
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Полные тени
    scene.traverse((object) => {
      if (object instanceof THREE.Mesh) {
        object.castShadow = true;
        object.receiveShadow = true;
      }
    });
  }
  
  public getCurrentQuality(): QualityLevel {
    return this.currentQuality;
  }
}

type QualityLevel = 'low' | 'medium' | 'high';

interface DeviceCapabilities {
  isMobile: boolean;
  isStandalone: boolean;
  performanceScore: number;
  maxTextureSize: number;
  supportsWebGL2: boolean;
}
```

## Профилирование производительности

### Система мониторинга

```typescript
class PerformanceMonitor {
  private frameTimes: number[] = [];
  private maxFrameTimes = 60; // Хранить последние 60 значений
  private lastFrameTime = 0;
  private totalFrames = 0;
  private droppedFrames = 0;
  
  public update(): PerformanceStats {
    const currentTime = performance.now();
    const frameTime = currentTime - this.lastFrameTime;
    this.lastFrameTime = currentTime;
    
    // Добавление времени кадра в историю
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxFrameTimes) {
      this.frameTimes.shift();
    }
    
    this.totalFrames++;
    
    // Подсчет пропущенных кадров (время > 11.11 мс для 90 FPS)
    if (frameTime > 11.11) {
      this.droppedFrames++;
    }
    
    // Вычисление статистики
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    const minFrameTime = Math.min(...this.frameTimes);
    const maxFrameTime = Math.max(...this.frameTimes);
    const avgFPS = 1000 / avgFrameTime;
    
    return {
      avgFrameTime,
      minFrameTime,
      maxFrameTime,
      avgFPS,
      droppedFrames: this.droppedFrames,
      totalFrames: this.totalFrames,
      dropRate: (this.droppedFrames / this.totalFrames) * 100
    };
  }
  
  public getStats(): PerformanceStats {
    if (this.frameTimes.length === 0) {
      return {
        avgFrameTime: 0,
        minFrameTime: 0,
        maxFrameTime: 0,
        avgFPS: 0,
        droppedFrames: 0,
        totalFrames: 0,
        dropRate: 0
      };
    }
    
    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
    return {
      avgFrameTime,
      minFrameTime: Math.min(...this.frameTimes),
      maxFrameTime: Math.max(...this.frameTimes),
      avgFPS: 1000 / avgFrameTime,
      droppedFrames: this.droppedFrames,
      totalFrames: this.totalFrames,
      dropRate: (this.droppedFrames / this.totalFrames) * 100
    };
  }
}

interface PerformanceStats {
  avgFrameTime: number;
  minFrameTime: number;
  maxFrameTime: number;
  avgFPS: number;
  droppedFrames: number;
  totalFrames: number;
  dropRate: number;
}
```

## Практические рекомендации

### Оптимизация загрузки ресурсов

```typescript
class ResourcePreloader {
  private loadedResources: Set<string> = new Set();
  private loadingQueue: Array<() => Promise<void>> = [];
  private isPreloading = false;
  
  public async preloadResources(resources: PreloadResource[]): Promise<void> {
    if (this.isPreloading) {
      // Если уже идет предзагрузка, ждем её завершения
      return new Promise(resolve => {
        const checkPreloading = () => {
          if (!this.isPreloading) {
            resolve();
          } else {
            setTimeout(checkPreloading, 100);
          }
        };
        checkPreloading();
      });
    }
    
    this.isPreloading = true;
    
    try {
      for (const resource of resources) {
        if (!this.loadedResources.has(resource.id)) {
          await this.loadResource(resource);
          this.loadedResources.add(resource.id);
        }
      }
    } finally {
      this.isPreloading = false;
    }
  }
  
  private async loadResource(resource: PreloadResource): Promise<void> {
    switch (resource.type) {
      case 'texture':
        return this.loadTexture(resource.url, resource.id);
      case 'model':
        return this.loadModel(resource.url, resource.id);
      case 'audio':
        return this.loadAudio(resource.url, resource.id);
      default:
        throw new Error(`Неизвестный тип ресурса: ${resource.type}`);
    }
  }
  
  private async loadTexture(url: string, id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const loader = new THREE.TextureLoader();
      loader.load(url, () => resolve(), undefined, reject);
    });
  }
  
  private async loadModel(url: string, id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const loader = new THREE.GLTFLoader();
      loader.load(url, () => resolve(), undefined, reject);
    });
  }
  
  private async loadAudio(url: string, id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const audio = new Audio();
      audio.src = url;
      audio.load();
      audio.addEventListener('loadeddata', () => resolve());
      audio.addEventListener('error', () => reject());
    });
  }
}

interface PreloadResource {
  id: string;
  url: string;
  type: 'texture' | 'model' | 'audio';
}
```

## Заключение

Оптимизация рендеринга VR-приложений требует комплексного подхода, включающего:

1. Поддержание стабильной частоты кадров
2. Эффективное управление геометрией и текстурами
3. Оптимизацию освещения и материалов
4. Использование методов отсечения (culling)
5. Адаптацию к возможностям устройства

Для реализации этих оптимизаций рекомендуется использовать [[Three-js]] для 3D-рендеринга и [[WebXR]] для взаимодействия с VR-устройствами. Также важно учитывать [[Взаимодействие-с-пользователем]] при проектировании оптимизаций, чтобы не ухудшить пользовательский опыт.

## Ключевые теги
#vr #ar #typescript #performance #rendering #optimization #webgl #threejs #vr-optimization