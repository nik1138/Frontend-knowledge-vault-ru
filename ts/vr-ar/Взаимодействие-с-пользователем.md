---
aliases: [Взаимодействие с пользователем в VR, UX в VR/AR, Управление в VR]
tags: [vr, ar, typescript, user-interaction, ux, input-handling, webxr, aframe]
---

# Взаимодействие с пользователем в VR/AR-приложениях

## Введение в UX в VR/AR

Взаимодействие с пользователем в VR/AR-приложениях значительно отличается от традиционных 2D-интерфейсов. В трехмерной среде пользователь может перемещаться, смотреть в разные стороны и взаимодействовать с объектами в пространстве, что требует особого подхода к проектированию UX.

## Основные принципы UX в VR

### Комфорт пользователя

Ключевые аспекты комфортного VR-опыта:

- **Минимизация укачивания**: избегать резких движений камеры, использовать плавные переходы
- **Оптимальная частота кадров**: поддерживать не менее 90 FPS
- **Интуитивное управление**: использовать привычные схемы взаимодействия
- **Ясность интерфейса**: элементы управления должны быть легко различимы

```typescript
class VRComfortManager {
  private comfortMetrics = {
    headMovementIntensity: 0,
    cameraVelocity: new THREE.Vector3(),
    lastCameraPosition: new THREE.Vector3()
  };
  
  public updateComfortMetrics(camera: THREE.PerspectiveCamera, deltaTime: number): void {
    // Отслеживание интенсивности движения головы
    const currentPosition = camera.position;
    const velocity = new THREE.Vector3().subVectors(
      currentPosition,
      this.comfortMetrics.lastCameraPosition
    ).multiplyScalar(1 / deltaTime);
    
    this.comfortMetrics.cameraVelocity.copy(velocity);
    this.comfortMetrics.headMovementIntensity = velocity.length();
    this.comfortMetrics.lastCameraPosition.copy(currentPosition);
    
    // Проверка на чрезмерное движение
    if (this.comfortMetrics.headMovementIntensity > 5) { // 5 м/с - пороговое значение
      console.warn('Обнаружено чрезмерное движение камеры, возможен дискомфорт пользователя');
    }
  }
  
  public isComfortable(): boolean {
    return this.comfortMetrics.headMovementIntensity < 3; // Ниже порога дискомфорта
  }
}
```

### Пространственное расположение UI

```typescript
class SpatialUIManager {
  private uiElements: Map<string, THREE.Object3D> = new Map();
  private defaultDistance = 2; // Метры от камеры
  
  public createUIPanel(
    id: string,
    content: string,
    position?: THREE.Vector3,
    options: UIPanelOptions = {}
  ): THREE.Mesh {
    // Создание плоскости для UI
    const geometry = new THREE.PlaneGeometry(
      options.width || 1,
      options.height || 0.5
    );
    
    // Создание материала с текстом
    const canvas = this.createTextCanvas(content, options);
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const panel = new THREE.Mesh(geometry, material);
    
    // Установка позиции
    if (position) {
      panel.position.copy(position);
    } else {
      // По умолчанию впереди от камеры
      panel.position.set(0, 0, -this.defaultDistance);
    }
    
    this.uiElements.set(id, panel);
    return panel;
  }
  
  private createTextCanvas(text: string, options: UIPanelOptions): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d')!;
    
    canvas.width = options.canvasWidth || 512;
    canvas.height = options.canvasHeight || 256;
    
    // Очистка фона
    context.fillStyle = options.backgroundColor || 'rgba(0, 0, 0, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Рисование текста
    context.font = options.fontSize ? `${options.fontSize}px Arial` : '30px Arial';
    context.fillStyle = options.textColor || 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // Перенос текста при необходимости
    const lines = this.wrapText(context, text, canvas.width - 20);
    const lineHeight = options.fontSize ? options.fontSize * 1.2 : 36;
    const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;
    
    lines.forEach((line, index) => {
      context.fillText(line, canvas.width / 2, startY + index * lineHeight);
    });
    
    return canvas;
  }
  
  private wrapText(context: CanvasRenderingContext2D, text: string, maxWidth: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = words[0];
    
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = context.measureText(`${currentLine} ${word}`).width;
      
      if (width < maxWidth) {
        currentLine += ` ${word}`;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    
    lines.push(currentLine);
    return lines;
  }
  
  public positionUIRelativeToCamera(uiId: string, camera: THREE.Camera, offset?: THREE.Vector3): void {
    const uiElement = this.uiElements.get(uiId);
    if (!uiElement) return;
    
    // Позиционирование UI перед пользователем
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(camera.quaternion);
    
    const position = camera.position.clone().add(forward.multiplyScalar(this.defaultDistance));
    
    if (offset) {
      position.add(offset);
    }
    
    uiElement.position.copy(position);
    
    // Поворот UI к пользователю
    uiElement.lookAt(camera.position);
    uiElement.rotateX(Math.PI); // Поворот для правильной ориентации текста
  }
}

interface UIPanelOptions {
  width?: number;
  height?: number;
  fontSize?: number;
  textColor?: string;
  backgroundColor?: string;
  canvasWidth?: number;
  canvasHeight?: number;
}
```

## Управление в VR

### Контроллеры и отслеживание рук

```typescript
class VRInputManager {
  private controllers: Map<string, VRController> = new Map();
  private handTrackers: Map<string, VRHandTracker> = new Map();
  private rayInteractors: Map<string, RayInteractor> = new Map();
  
  constructor(private xrSession: XRSession, private referenceSpace: XRReferenceSpace) {
    this.setupInputHandling();
  }
  
  private setupInputHandling() {
    this.xrSession.addEventListener('inputsourceschange', (event) => {
      // Добавление новых источников ввода
      for (const inputSource of event.added) {
        if (inputSource.hand) {
          // Отслеживание руки
          this.addHandTracker(inputSource);
        } else if (inputSource.targetRayMode === 'tracked-pointer') {
          // Контроллер
          this.addController(inputSource);
        }
      }
      
      // Удаление источников ввода
      for (const inputSource of event.removed) {
        this.removeInputSource(inputSource);
      }
    });
  }
  
  private addController(inputSource: XRInputSource) {
    const controller = new VRController(inputSource);
    this.controllers.set(inputSource.handedness, controller);
    
    // Создание луча для взаимодействия
    const rayInteractor = new RayInteractor(inputSource, this.referenceSpace);
    this.rayInteractors.set(inputSource.handedness, rayInteractor);
  }
  
  private addHandTracker(inputSource: XRInputSource) {
    const handTracker = new VRHandTracker(inputSource);
    this.handTrackers.set(inputSource.handedness, handTracker);
  }
  
  private removeInputSource(inputSource: XRInputSource) {
    if (inputSource.hand) {
      this.handTrackers.delete(inputSource.handedness);
    } else {
      this.controllers.delete(inputSource.handedness);
      this.rayInteractors.delete(inputSource.handedness);
    }
  }
  
  public processInput(frame: XRFrame, scene: THREE.Scene): void {
    // Обработка контроллеров
    for (const [handedness, controller] of this.controllers) {
      const rayInteractor = this.rayInteractors.get(handedness);
      if (rayInteractor) {
        rayInteractor.update(frame);
        
        // Проверка пересечений
        const intersections = rayInteractor.getIntersections(scene);
        controller.setIntersections(intersections);
        
        // Обработка действий
        this.handleControllerActions(controller, intersections);
      }
    }
    
    // Обработка отслеживания рук
    for (const [handedness, handTracker] of this.handTrackers) {
      handTracker.update(frame, this.referenceSpace);
      
      // Обработка жестов
      this.handleHandGestures(handTracker);
    }
  }
  
  private handleControllerActions(controller: VRController, intersections: THREE.Intersection[]) {
    const gamepad = controller.getGamepad();
    if (!gamepad) return;
    
    // Обработка нажатий кнопок
    for (let i = 0; i < gamepad.buttons.length; i++) {
      const button = gamepad.buttons[i];
      
      if (button.pressed && !controller.wasButtonPressed(i)) {
        // Только что нажатая кнопка
        this.onButtonPress(controller, i, intersections);
      } else if (!button.pressed && controller.wasButtonPressed(i)) {
        // Только что отпущенная кнопка
        this.onButtonRelease(controller, i);
      }
      
      controller.updateButtonState(i, button.pressed);
    }
  }
  
  private handleHandGestures(handTracker: VRHandTracker) {
    // Обнаружение жестов (например, сжатие в кулак)
    const gripGesture = handTracker.getGripGesture();
    if (gripGesture.confidence > 0.8) {
      console.log(`${handTracker.getHandedness()} рука сжата в кулак`);
    }
    
    // Обнаружение указывающего жеста
    const pointGesture = handTracker.getPointGesture();
    if (pointGesture.confidence > 0.8) {
      console.log(`${handTracker.getHandedness()} рука указывает`);
    }
  }
  
  private onButtonPress(controller: VRController, buttonIndex: number, intersections: THREE.Intersection[]) {
    switch (buttonIndex) {
      case 0: // Схватывание
        if (intersections.length > 0) {
          const object = intersections[0].object;
          this.grabObject(controller, object);
        }
        break;
      case 1: // Меню
        this.toggleMenu();
        break;
      case 2: // Системная кнопка
        this.handleSystemAction();
        break;
    }
  }
  
  private grabObject(controller: VRController, object: THREE.Object3D) {
    console.log(`Объект захвачен контроллером ${controller.getHandedness()}`);
    // Реализация захвата объекта
  }
  
  private toggleMenu() {
    console.log('Меню переключено');
    // Реализация переключения меню
  }
  
  private handleSystemAction() {
    console.log('Системное действие выполнено');
    // Реализация системного действия
  }
  
  private onButtonRelease(controller: VRController, buttonIndex: number) {
    if (buttonIndex === 0) { // Отпускание захвата
      this.releaseObject(controller);
    }
  }
  
  private releaseObject(controller: VRController) {
    console.log(`Объект освобожден контроллером ${controller.getHandedness()}`);
    // Реализация освобождения объекта
  }
}
```

### Классы для управления вводом

```typescript
class VRController {
  private buttonStates: boolean[] = [];
  private previousButtonStates: boolean[] = [];
  
  constructor(private inputSource: XRInputSource) {
    // Инициализация состояний кнопок
    if (inputSource.gamepad) {
      this.buttonStates = new Array(inputSource.gamepad.buttons.length).fill(false);
      this.previousButtonStates = new Array(inputSource.gamepad.buttons.length).fill(false);
    }
  }
  
  public getGamepad(): Gamepad | null {
    return this.inputSource.gamepad;
  }
  
  public getHandedness(): string {
    return this.inputSource.handedness;
  }
  
  public wasButtonPressed(buttonIndex: number): boolean {
    return this.previousButtonStates[buttonIndex] || false;
  }
  
  public updateButtonState(buttonIndex: number, isPressed: boolean): void {
    this.previousButtonStates[buttonIndex] = this.buttonStates[buttonIndex];
    this.buttonStates[buttonIndex] = isPressed;
  }
  
  public setIntersections(intersections: THREE.Intersection[]): void {
    // Обработка пересечений для этого контроллера
  }
}

class VRHandTracker {
  private joints: Map<XRHandJoint, THREE.Vector3> = new Map();
  private previousJoints: Map<XRHandJoint, THREE.Vector3> = new Map();
  
  constructor(private inputSource: XRInputSource) {}
  
  public update(frame: XRFrame, referenceSpace: XRReferenceSpace): void {
    if (!this.inputSource.hand) return;
    
    // Обновление позиций суставов
    this.previousJoints = new Map(this.joints);
    
    for (const joint of this.inputSource.hand.keys()) {
      const jointPose = frame.getJointPose(this.inputSource.hand.get(joint)!, referenceSpace);
      if (jointPose) {
        const position = new THREE.Vector3().setFromMatrixPosition(
          new THREE.Matrix4().fromArray(jointPose.transform.matrix)
        );
        this.joints.set(joint, position);
      }
    }
  }
  
  public getGripGesture(): GestureResult {
    // Проверка сжатия пальцев в кулак
    const thumbTip = this.joints.get('thumb-tip');
    const indexTip = this.joints.get('index-finger-tip');
    const middleTip = this.joints.get('middle-finger-tip');
    const ringTip = this.joints.get('ring-finger-tip');
    const pinkyTip = this.joints.get('pinky-finger-tip');
    
    if (thumbTip && indexTip && middleTip && ringTip && pinkyTip) {
      // Расчет расстояния между кончиками пальцев и ладонью
      const avgFingerTipPos = new THREE.Vector3()
        .add(thumbTip)
        .add(indexTip)
        .add(middleTip)
        .add(ringTip)
        .add(pinkyTip)
        .multiplyScalar(0.2);
      
      // Примерная позиция ладони (между индексным и средним пальцами)
      const palmPos = new THREE.Vector3()
        .add(this.joints.get('index-finger-metacarpal') || new THREE.Vector3())
        .add(this.joints.get('middle-finger-metacarpal') || new THREE.Vector3())
        .multiplyScalar(0.5);
      
      const distance = avgFingerTipPos.distanceTo(palmPos);
      const confidence = Math.max(0, 1 - distance); // Упрощенный расчет уверенности
      
      return {
        detected: distance < 0.05, // 5 см - порог сжатия
        confidence: Math.min(1, confidence)
      };
    }
    
    return { detected: false, confidence: 0 };
  }
  
  public getPointGesture(): GestureResult {
    // Проверка указывающего жеста
    const indexTip = this.joints.get('index-finger-tip');
    const middleTip = this.joints.get('middle-finger-tip');
    const ringTip = this.joints.get('ring-finger-tip');
    const pinkyTip = this.joints.get('pinky-finger-tip');
    
    if (indexTip && middleTip && ringTip && pinkyTip) {
      // Проверка, что средний, безымянный и мизинец "спрятаны"
      const middleProximal = this.joints.get('middle-finger-phalanx-proximal');
      const ringProximal = this.joints.get('ring-finger-phalanx-proximal');
      const pinkyProximal = this.joints.get('pinky-finger-phalanx-proximal');
      
      if (middleProximal && ringProximal && pinkyProximal) {
        const middleFolded = indexTip.distanceTo(middleProximal) < 0.03;
        const ringFolded = indexTip.distanceTo(ringProximal) < 0.03;
        const pinkyFolded = indexTip.distanceTo(pinkyProximal) < 0.03;
        
        const confidence = (middleFolded ? 1 : 0) * (ringFolded ? 1 : 0) * (pinkyFolded ? 1 : 0);
        
        return {
          detected: middleFolded && ringFolded && pinkyFolded,
          confidence: confidence
        };
      }
    }
    
    return { detected: false, confidence: 0 };
  }
  
  public getHandedness(): string {
    return this.inputSource.handedness;
  }
}

interface GestureResult {
  detected: boolean;
  confidence: number;
}

class RayInteractor {
  private rayOrigin: THREE.Vector3 = new THREE.Vector3();
  private rayDirection: THREE.Vector3 = new THREE.Vector3();
  private raycaster: THREE.Raycaster = new THREE.Raycaster();
  
  constructor(
    private inputSource: XRInputSource,
    private referenceSpace: XRReferenceSpace
  ) {}
  
  public update(frame: XRFrame): void {
    const targetRayPose = frame.getPose(this.inputSource.targetRaySpace, this.referenceSpace);
    
    if (targetRayPose) {
      // Обновление начала и направления луча
      this.rayOrigin.setFromMatrixPosition(
        new THREE.Matrix4().fromArray(targetRayPose.transform.matrix)
      );
      
      // Направление луча (ось Z в системе координат контроллера)
      const targetRayMatrix = new THREE.Matrix4().fromArray(targetRayPose.transform.matrix);
      this.rayDirection.set(0, 0, -1).applyMatrix4(targetRayMatrix).sub(this.rayOrigin);
      this.rayDirection.normalize();
      
      // Обновление рейкастера
      this.raycaster.set(this.rayOrigin, this.rayDirection);
    }
  }
  
  public getIntersections(scene: THREE.Scene, options: RaycastOptions = {}): THREE.Intersection[] {
    // Сбор всех мешей для рейкаста
    const meshes: THREE.Mesh[] = [];
    scene.traverse((object) => {
      if (object instanceof THREE.Mesh && 
          (options.includeInvisible || object.visible) &&
          object.userData?.interactive) {
        meshes.push(object);
      }
    });
    
    return this.raycaster.intersectObjects(meshes, false);
  }
}

interface RaycastOptions {
  includeInvisible?: boolean;
  maxDistance?: number;
}
```

## Визуальная обратная связь

### Подсветка интерактивных элементов

```typescript
class VisualFeedbackManager {
  private highlightedObjects: Set<THREE.Object3D> = new Set();
  private originalMaterials: WeakMap<THREE.Object3D, THREE.Material> = new WeakMap();
  
  public highlightObject(object: THREE.Object3D, highlightColor: number = 0xff0000): void {
    if (this.highlightedObjects.has(object)) return;
    
    if (object instanceof THREE.Mesh) {
      // Сохранение оригинального материала
      if (!this.originalMaterials.has(object)) {
        this.originalMaterials.set(object, object.material);
      }
      
      // Создание подсвеченного материала
      const originalMaterial = object.material as THREE.MeshStandardMaterial;
      const highlightedMaterial = this.createHighlightedMaterial(originalMaterial, highlightColor);
      
      object.material = highlightedMaterial;
      this.highlightedObjects.add(object);
    }
  }
  
  public removeHighlight(object: THREE.Object3D): void {
    if (!this.highlightedObjects.has(object)) return;
    
    if (object instanceof THREE.Mesh) {
      // Восстановление оригинального материала
      const originalMaterial = this.originalMaterials.get(object);
      if (originalMaterial) {
        object.material = originalMaterial;
      }
      
      this.highlightedObjects.delete(object);
    }
  }
  
  public clearAllHighlights(): void {
    for (const object of this.highlightedObjects) {
      this.removeHighlight(object);
    }
  }
  
  private createHighlightedMaterial(
    originalMaterial: THREE.MeshStandardMaterial,
    highlightColor: number
  ): THREE.MeshStandardMaterial {
    const highlightedMaterial = originalMaterial.clone();
    
    // Увеличение эмиссии для подсветки
    highlightedMaterial.emissive = new THREE.Color(highlightColor);
    highlightedMaterial.emissiveIntensity = 0.3;
    
    // Увеличение металличности для более яркого отражения
    highlightedMaterial.metalness = Math.min(1, originalMaterial.metalness + 0.2);
    
    return highlightedMaterial;
  }
  
  // Анимированная подсветка
  public animateHighlight(
    object: THREE.Object3D,
    highlightColor: number = 0xff0000,
    duration: number = 1000
  ): Promise<void> {
    return new Promise((resolve) => {
      const startTime = performance.now();
      
      const animate = (time: number) => {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress < 1) {
          // Пульсация подсветки
          const pulseIntensity = 0.5 + 0.5 * Math.sin(elapsed / 100);
          this.updateHighlightIntensity(object, highlightColor, pulseIntensity);
          
          requestAnimationFrame(animate);
        } else {
          // Завершение анимации
          this.removeHighlight(object);
          resolve();
        }
      };
      
      this.highlightObject(object, highlightColor);
      requestAnimationFrame(animate);
    });
  }
  
  private updateHighlightIntensity(
    object: THREE.Object3D,
    highlightColor: number,
    intensity: number
  ): void {
    if (object instanceof THREE.Mesh && object.material instanceof THREE.MeshStandardMaterial) {
      object.material.emissive = new THREE.Color(highlightColor);
      object.material.emissiveIntensity = intensity * 0.3;
    }
  }
}
```

### Визуализация луча взаимодействия

```typescript
class RayVisualizer {
  private rayMesh: THREE.Line | null = null;
  private rayStart: THREE.Vector3 = new THREE.Vector3();
  private rayEnd: THREE.Vector3 = new THREE.Vector3();
  private maxRayDistance = 10; // Метры
  
  constructor(private scene: THREE.Scene) {}
  
  public updateRay(start: THREE.Vector3, direction: THREE.Vector3, hitPoint?: THREE.Vector3): void {
    this.rayStart.copy(start);
    
    if (hitPoint) {
      this.rayEnd.copy(hitPoint);
    } else {
      // Если нет точки пересечения, рисуем луч до максимального расстояния
      this.rayEnd.copy(start).add(direction.clone().multiplyScalar(this.maxRayDistance));
    }
    
    this.createOrUpdateRayMesh();
  }
  
  private createOrUpdateRayMesh(): void {
    const points = [this.rayStart, this.rayEnd];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    
    // Создание градиентного материала для луча
    const material = new THREE.LineBasicMaterial({
      color: 0x00aaff,
      transparent: true,
      opacity: 0.7,
      linewidth: 2
    });
    
    if (this.rayMesh) {
      // Обновление существующего луча
      this.rayMesh.geometry.dispose();
      this.rayMesh.geometry = geometry;
    } else {
      // Создание нового луча
      this.rayMesh = new THREE.Line(geometry, material);
      this.scene.add(this.rayMesh);
    }
  }
  
  public setVisible(visible: boolean): void {
    if (this.rayMesh) {
      this.rayMesh.visible = visible;
    }
  }
  
  public removeFromScene(): void {
    if (this.rayMesh && this.rayMesh.parent) {
      this.rayMesh.parent.remove(this.rayMesh);
      this.rayMesh.geometry.dispose();
      (this.rayMesh.material as THREE.Material).dispose();
      this.rayMesh = null;
    }
  }
}
```

## Аудиообратная связь

### Пространственное аудио

```typescript
class SpatialAudioManager {
  private audioListener: THREE.AudioListener;
  private positionalAudios: Map<string, THREE.PositionalAudio> = new Map();
  private audioLoader: THREE.AudioLoader;
  
  constructor(camera: THREE.Camera) {
    this.audioListener = new THREE.AudioListener();
    camera.add(this.audioListener);
    
    this.audioLoader = new THREE.AudioLoader();
  }
  
  public createPositionalAudio(
    id: string,
    audioFile: string,
    position: THREE.Vector3,
    options: AudioOptions = {}
  ): Promise<THREE.PositionalAudio> {
    return new Promise((resolve, reject) => {
      const audio = new THREE.PositionalAudio(this.audioListener);
      
      this.audioLoader.load(
        audioFile,
        (buffer) => {
          audio.setBuffer(buffer);
          audio.setRefDistance(options.refDistance || 1);
          audio.setMaxDistance(options.maxDistance || 100);
          audio.setLoop(options.loop || false);
          audio.setVolume(options.volume || 1);
          
          audio.position.copy(position);
          
          this.positionalAudios.set(id, audio);
          resolve(audio);
        },
        undefined,
        reject
      );
    });
  }
  
  public playAudioAtPosition(id: string, position: THREE.Vector3): void {
    const audio = this.positionalAudios.get(id);
    if (audio) {
      audio.position.copy(position);
      audio.play();
    }
  }
  
  public stopAudio(id: string): void {
    const audio = this.positionalAudios.get(id);
    if (audio) {
      audio.stop();
    }
  }
  
  public setAudioVolume(id: string, volume: number): void {
    const audio = this.positionalAudios.get(id);
    if (audio) {
      audio.setVolume(volume);
    }
  }
}

interface AudioOptions {
  refDistance?: number;
  maxDistance?: number;
  loop?: boolean;
  volume?: number;
}
```

## Системы меню и интерфейса

### Пространственное меню

```typescript
class SpatialMenu {
  private menuObject: THREE.Group;
  private items: MenuItem[] = [];
  private selectedItemIndex = -1;
  private onSelectCallback: ((item: MenuItem) => void) | null = null;
  
  constructor(private scene: THREE.Scene) {
    this.menuObject = new THREE.Group();
    this.menuObject.userData.menu = true;
  }
  
  public addItem(label: string, action: () => void): void {
    const item: MenuItem = {
      label,
      action,
      element: this.createMenuItemElement(label, this.items.length)
    };
    
    this.items.push(item);
    this.menuObject.add(item.element);
    
    // Расположение элементов меню
    this.positionMenuItems();
  }
  
  private createMenuItemElement(label: string, index: number): THREE.Object3D {
    // Создание плоскости для элемента меню
    const geometry = new THREE.PlaneGeometry(2, 0.5);
    const canvas = this.createMenuCanvas(label);
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const menuItem = new THREE.Mesh(geometry, material);
    menuItem.userData.interactive = true;
    menuItem.userData.menuIndex = index;
    
    return menuItem;
  }
  
  private createMenuCanvas(label: string): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    
    const context = canvas.getContext('2d')!;
    
    // Фон элемента меню
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Выделение выбранного элемента
    context.fillStyle = 'rgba(100, 100, 255, 0.3)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Текст
    context.font = '40px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, canvas.width / 2, canvas.height / 2);
    
    return canvas;
  }
  
  private positionMenuItems(): void {
    const spacing = 0.6; // Расстояние между элементами
    const startY = (this.items.length - 1) * spacing / 2; // Центрирование
    
    this.items.forEach((item, index) => {
      item.element.position.y = startY - index * spacing;
      item.element.position.x = 0;
      item.element.position.z = -3; // Впереди от центра меню
    });
  }
  
  public showAt(position: THREE.Vector3, rotation?: THREE.Euler): void {
    this.menuObject.position.copy(position);
    
    if (rotation) {
      this.menuObject.rotation.copy(rotation);
    } else {
      // По умолчанию смотрит в сторону сцены
      this.menuObject.lookAt(position.clone().add(new THREE.Vector3(0, 0, 1)));
      this.menuObject.rotateX(Math.PI); // Поворот для правильной ориентации
    }
    
    this.scene.add(this.menuObject);
  }
  
  public hide(): void {
    if (this.menuObject.parent) {
      this.menuObject.parent.remove(this.menuObject);
    }
  }
  
  public setOnSelect(callback: (item: MenuItem) => void): void {
    this.onSelectCallback = callback;
  }
  
  public selectNext(): void {
    if (this.items.length === 0) return;
    
    this.selectedItemIndex = (this.selectedItemIndex + 1) % this.items.length;
    this.updateSelectionVisuals();
  }
  
  public selectPrevious(): void {
    if (this.items.length === 0) return;
    
    this.selectedItemIndex = this.selectedItemIndex <= 0 
      ? this.items.length - 1 
      : this.selectedItemIndex - 1;
    
    this.updateSelectionVisuals();
  }
  
  public selectItem(index: number): void {
    if (index >= 0 && index < this.items.length) {
      this.selectedItemIndex = index;
      this.updateSelectionVisuals();
      
      if (this.onSelectCallback) {
        this.onSelectCallback(this.items[index]);
      }
    }
  }
  
  private updateSelectionVisuals(): void {
    this.items.forEach((item, index) => {
      const canvas = this.createMenuCanvas(item.label);
      if (index === this.selectedItemIndex) {
        // Выделение выбранного элемента
        const highlightedCanvas = this.createHighlightedMenuCanvas(item.label);
        const texture = new THREE.CanvasTexture(highlightedCanvas);
        (item.element as THREE.Mesh).material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        });
      } else {
        // Обычный элемент
        const texture = new THREE.CanvasTexture(canvas);
        (item.element as THREE.Mesh).material = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        });
      }
    });
  }
  
  private createHighlightedMenuCanvas(label: string): HTMLCanvasElement {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 128;
    
    const context = canvas.getContext('2d')!;
    
    // Фон с выделением
    context.fillStyle = 'rgba(100, 100, 255, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Граница
    context.strokeStyle = 'white';
    context.lineWidth = 4;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Текст
    context.font = '40px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, canvas.width / 2, canvas.height / 2);
    
    return canvas;
  }
  
  public isVisible(): boolean {
    return this.menuObject.parent !== null;
  }
}

interface MenuItem {
  label: string;
  action: () => void;
  element: THREE.Object3D;
}
```

## Практические примеры

### Пример интерактивной сцены

```typescript
class InteractiveVRScene {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private inputManager: VRInputManager;
  private visualFeedback: VisualFeedbackManager;
  private spatialMenu: SpatialMenu;
  private comfortManager: VRComfortManager;
  
  constructor() {
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.visualFeedback = new VisualFeedbackManager();
    this.spatialMenu = new SpatialMenu(this.scene);
    this.comfortManager = new VRComfortManager();
    
    this.setupScene();
    this.setupMenu();
  }
  
  private setupScene(): void {
    // Добавление освещения
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    this.scene.add(directionalLight);
    
    // Создание интерактивных объектов
    this.createInteractiveObjects();
  }
  
  private createInteractiveObjects(): void {
    // Создание куба, с которым можно взаимодействовать
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x00ff00,
      roughness: 0.5,
      metalness: 0.5
    });
    
    const interactiveCube = new THREE.Mesh(geometry, material);
    interactiveCube.position.set(0, 1.5, -3);
    interactiveCube.userData.interactive = true; // Пометка как интерактивный
    this.scene.add(interactiveCube);
    
    // Добавление события клика
    interactiveCube.addEventListener('click', () => {
      console.log('Куб кликнут!');
    });
  }
  
  private setupMenu(): void {
    // Добавление элементов меню
    this.spatialMenu.addItem('Начать игру', () => {
      console.log('Игра начата');
    });
    
    this.spatialMenu.addItem('Настройки', () => {
      console.log('Открыты настройки');
    });
    
    this.spatialMenu.addItem('Выход', () => {
      console.log('Выход из приложения');
    });
    
    // Позиционирование меню
    this.spatialMenu.showAt(new THREE.Vector3(0, 1.5, -2));
  }
  
  public setupXR(xrSession: XRSession, referenceSpace: XRReferenceSpace): void {
    this.inputManager = new VRInputManager(xrSession, referenceSpace);
  }
  
  public updateXRFrame(frame: XRFrame): void {
    if (this.inputManager) {
      // Обработка ввода
      this.inputManager.processInput(frame, this.scene);
      
      // Обновление менеджера комфорта
      this.comfortManager.updateComfortMetrics(this.camera, 1/90); // deltaTime для 90 FPS
    }
  }
  
  public render(): void {
    this.renderer.render(this.scene, this.camera);
  }
}
```

## Заключение

Взаимодействие с пользователем в VR/AR-приложениях требует особого внимания к UX-дизайну и интуитивно понятным схемам управления. Ключевые аспекты:

1. Обеспечение комфорта пользователя
2. Интуитивное управление и обратная связь
3. Правильное пространственное расположение UI
4. Эффективная обработка ввода от различных устройств

Для достижения оптимальной производительности рекомендуется использовать оптимизации, описанные в [[Оптимизация-рендеринга]], а также подходящие библиотеки для 3D-рендеринга, такие как [[Three-js]] или [[A-Frame]]. Взаимодействие с WebXR API описано в [[WebXR]].

## Ключевые теги
#vr #ar #typescript #user-interaction #ux #input-handling #webxr #aframe #spatial-ui #vr-ux