---
tags: [typescript, frontend, type-system, primitives]
aliases: [Типы в TypeScript, Система типов TypeScript]
---

# Система типов: примитивные и составные типы

## Введение

TypeScript предоставляет мощную систему типов, которая помогает разработчикам создавать более надежный и читаемый код. В этом материале мы рассмотрим основы системы типов TypeScript, включая примитивные и составные типы.

## Примитивные типы

Примитивные типы — это базовые типы, которые определяют отдельные значения. TypeScript расширяет JavaScript, добавляя статическую типизацию.

### Основные примитивные типы

```ts
// Boolean
let isDone: boolean = false;

// Number
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;

// String
let color: string = "blue";
color = 'red';

// Array
let list: number[] = [1, 2, 3];
let listGeneric: Array<number> = [1, 2, 3];

// Tuple
let x: [string, number];
x = ["hello", 10]; // OK
// x = [10, "hello"]; // Error

// Enum
enum Color {Red, Green, Blue}
let c: Color = Color.Green;

// Any
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean

// Void
function warnUser(): void {
    console.log("This is my warning message");
}
let unusable: void = undefined;

// Null и Undefined
let u: undefined = undefined;
let n: null = null;

// Never
function error(message: string): never {
    throw new Error(message);
}

// Object
declare function create(o: object | null): void;
create({ prop: 0 }); // OK
create(null); // OK
// create(42); // Error
// create("string"); // Error
```

## Составные типы

Составные типы позволяют создавать более сложные структуры данных, комбинируя примитивные типы.

### Объединения (Union Types)

```ts
// Объединение позволяет переменной иметь несколько типов
function formatId(id: number | string): string {
    return `ID: ${id}`;
}

// Пример использования
const userId: number | string = 123;
const adminId: number | string = "admin";
```

### Пересечения (Intersection Types)

```ts
// Пересечение объединяет несколько типов в один
interface ErrorHandling {
    success: boolean;
    error?: { message: string };
}

interface ArtworksData {
    artworks: { title: string }[];
}

interface ArtistsData {
    artists: { name: string }[];
}

type ArtworksResponse = ArtworksData & ErrorHandling;
type ArtistsResponse = ArtistsData & ErrorHandling;

// Пример использования
const response: ArtworksResponse = {
    artworks: [{ title: "Mona Lisa" }],
    success: true
};
```

### Literal Types

```ts
// Литеральные типы ограничивают значение конкретными значениями
type Direction = "up" | "down" | "left" | "right";
type HttpStatus = 200 | 201 | 400 | 404 | 500;

function move(direction: Direction): void {
    console.log(`Moving ${direction}`);
}

// Использование литеральных типов в объединениях
type Status = "loading" | "success" | "error";
type Response<T> = {
    status: Status;
    data?: T;
    error?: string;
};
```

## Типы объектов

### Interface vs Type

```ts
// Interface
interface User {
    name: string;
    age: number;
    email?: string; // Необязательное свойство
}

// Type alias
type Admin = {
    name: string;
    permissions: string[];
    contact: ContactInfo;
};

type ContactInfo = {
    email: string;
    phone: string;
};

// Интерфейсы можно расширять
interface User {
    isActive: boolean; // Расширение существующего интерфейса
}

// Пример использования
const user: User = {
    name: "John",
    age: 30,
    isActive: true
};
```

## Сложные типы для frontend разработки

### Типы для обработки событий

```ts
import { ChangeEvent, MouseEvent } from 'react';

// Типизация обработчиков событий в React
function handleChange(e: ChangeEvent<HTMLInputElement>) {
    const value = e.target.value;
    console.log(value);
}

function handleClick(e: MouseEvent<HTMLButtonElement>) {
    console.log('Button clicked');
    e.preventDefault();
}

// Общий тип для обработчиков событий
type EventHandler<T> = (event: T) => void;
```

### Типы для API запросов

```ts
// Типы для асинхронных операций
interface ApiResponse<T> {
    data: T;
    status: number;
    message?: string;
}

interface User {
    id: number;
    name: string;
    email: string;
}

// Пример асинхронной функции с типизацией
async function fetchUser(id: number): Promise<ApiResponse<User>> {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    return data;
}
```

## Практические советы

1. **Используйте конкретные типы вместо any** - это основная причина использования TypeScript
2. **Используйте readonly для неизменяемых свойств** - помогает избежать непреднамеренных изменений
3. **Используйте необязательные свойства с ?** - когда поле может отсутствовать
4. **Используйте union types для гибкости** - когда значение может быть одного из нескольких типов

## Заключение

Понимание системы типов TypeScript является ключевым для эффективной разработки frontend приложений. Примитивные типы обеспечивают базовую типизацию, а составные типы позволяют создавать сложные структуры данных, соответствующие реальным сценариям использования.

> [!tip] Совет
> Используйте объединения типов для обозначения нескольких возможных значений и пересечения типов для комбинации различных интерфейсов.

> [!warning] Важно
> Избегайте чрезмерного использования `any`, так как это отменяет преимущества статической типизации.

## Связанные темы

- [[Типы в TypeScript]]
- [[Интерфейсы и классы]]
- [[Утилиты типов TypeScript]]