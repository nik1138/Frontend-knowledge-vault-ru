---
aliases: [Оптимизация бандлов, Бандл-оптимизация]
tags: [ts, build, optimization, performance, bundling]
---

# Оптимизация бандлов

Оптимизация бандлов - это критический аспект разработки TypeScript-приложений, направленный на уменьшение размера конечного кода, улучшение времени загрузки и повышение производительности. Эффективная оптимизация позволяет создавать более быстрые и легковесные приложения.

## Основные цели оптимизации

- **Уменьшение размера бандла** - снижение времени загрузки
- **Улучшение времени запуска** - быстрее выполнение кода
- **Оптимизация кеширования** - эффективное использование кеша браузера
- **Улучшение производительности** - быстрее выполнение и отрисовка

## Техники оптимизации

### 1. Code Splitting

Разделение кода на отдельные бандлы позволяет загружать только необходимый код:

```typescript
// Ленивая загрузка компонентов
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// Использование Suspense для обертывания ленивого компонента
function App() {
  return (
    <React.Suspense fallback={<div>Загрузка...</div>}>
      <LazyComponent />
    </React.Suspense>
  );
}
```

### 2. Tree Shaking

Удаление неиспользуемого кода из бандла:

```typescript
// utils.ts
export const heavyFunction = () => {
  // Тяжелая функция
};

export const lightFunction = () => {
  // Легкая функция
};

// main.ts - используем только lightFunction
import { lightFunction } from './utils';

// heavyFunction будет исключена из бандла при tree-shaking
```

### 3. Minification

Минификация кода уменьшает его размер:

```javascript
// rollup.config.js
import terser from '@rollup/plugin-terser';

export default {
  plugins: [
    terser({
      module: true,
      compress: {
        drop_console: true, // удалить console.log
        drop_debugger: true, // удалить debugger
      },
      mangle: true,
      format: {
        comments: false, // удалить комментарии
      },
    }),
  ],
};
```

### 4. Compression

Использование gzip или brotli для сжатия бандлов:

```javascript
// webpack.config.js
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = {
  plugins: [
    new CompressionPlugin({
      algorithm: 'gzip',
      test: /\.(js|css|html|svg)$/,
      threshold: 8192,
      minRatio: 0.8,
    }),
  ],
};
```

## Оптимизация зависимостей

### Использование lighter альтернатив

Замените тяжелые библиотеки на более легкие аналоги:

```typescript
// Вместо lodash
import { debounce } from 'lodash';

// Используйте lighter альтернативу
import debounce from 'lodash-es/debounce';
// или
import debounce from 'just-debounce-it';
```

### Импорт только необходимых частей

```typescript
// Плохо - импорт всей библиотеки
import * as moment from 'moment';

// Хорошо - импорт только необходимой функции
import moment from 'moment/moment';

// Лучше - использование более легкой альтернативы
import dayjs from 'dayjs';
```

## Lazy Loading

Загрузка кода по требованию:

```typescript
// routes.tsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Contact = lazy(() => import('./pages/Contact'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Загрузка...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## Bundle Analysis

Анализ содержимого бандла для оптимизации:

```bash
# Webpack Bundle Analyzer
npm install --save-dev webpack-bundle-analyzer

# Вывод анализа в интерактивный UI
npx webpack-bundle-analyzer dist/static/js/*.js
```

```javascript
// webpack.config.js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: process.env.ANALYZE ? [
    new BundleAnalyzerPlugin()
  ] : [],
};
```

## Chunk Splitting

Создание отдельных чанков для различных частей приложения:

```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        shared: {
          test: /[\\/]src[\\/]shared[\\/]/,
          name: 'shared',
          chunks: 'all',
        },
      },
    },
  },
};
```

## Dynamic Imports

Динамические импорты для разделения кода:

```typescript
// Условная загрузка модуля
async function loadModule(condition: boolean) {
  if (condition) {
    const { heavyModule } = await import('./heavy-module');
    return heavyModule.process();
  } else {
    const { lightModule } = await import('./light-module');
    return lightModule.process();
  }
}

// Загрузка модуля при событии
document.getElementById('button')?.addEventListener('click', async () => {
  const { modal } = await import('./modal');
  modal.show();
});
```

## Asset Optimization

Оптимизация ресурсов (изображений, шрифтов и т.д.):

```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)$/i,
        use: [
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: {
                progressive: true,
                quality: 65,
              },
              optipng: {
                enabled: false,
              },
              pngquant: {
                quality: [0.65, 0.90],
                speed: 4,
              },
              gifsicle: {
                interlaced: false,
              },
            },
          },
        ],
      },
    ],
  },
};
```

## Modern JavaScript Features

Использование современных возможностей JavaScript:

```typescript
// Использование top-level await
const data = await fetch('/api/data').then(r => r.json());

// Использование optional chaining
const userName = user?.profile?.name;

// Использование nullish coalescing
const displayName = user.name ?? 'Аноним';
```

## Service Worker и кеширование

Использование Service Worker для кеширования ресурсов:

```typescript
// sw.ts
const CACHE_NAME = 'app-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

## Практические советы

1. **Используйте lazy loading** для нечасто используемых компонентов
2. **Анализируйте бандл регулярно** с помощью инструментов анализа
3. **Оптимизируйте изображения и медиафайлы** перед включением в проект
4. **Разделяйте код** по функциональным модулям
5. **Используйте асинхронные библиотеки** для тяжелых операций
6. **Минимизируйте количество зависимостей** в проекте

## Метрики производительности

Отслеживайте ключевые метрики:

- **First Contentful Paint (FCP)** - время до первого отображения контента
- **Largest Contentful Paint (LCP)** - время до отображения крупного контента
- **First Input Delay (FID)** - задержка первого взаимодействия
- **Cumulative Layout Shift (CLS)** - смещение макета

## Связанные темы

- [[Webpack]] - сборщик с возможностями оптимизации
- [[Vite]] - современный сборщик с оптимизациями
- [[Rollup]] - сборщик с отличной поддержкой tree-shaking
- [[Tree-shaking]] - техника удаления неиспользуемого кода