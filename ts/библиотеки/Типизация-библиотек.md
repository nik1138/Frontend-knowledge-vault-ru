---
aliases: ["Типизация библиотек", "TypeScript типы", "Типы в библиотеках"]
tags: [typescript, typing, libraries, types]
---

# Типизация-библиотек

## Обзор

Типизация библиотек на TypeScript - это ключевой аспект создания надежных и удобных в использовании библиотек. Правильная типизация позволяет разработчикам получать автодополнение, проверку типов и документацию прямо в редакторе кода.

## Основные принципы типизации

### 1. Явная типизация

Всегда указывайте типы явно для публичного API:

```typescript
// Хорошо: явные типы
export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

export function createUser(userData: Partial<User>): User {
  return {
    id: Date.now(),
    name: '',
    email: '',
    createdAt: new Date(),
    ...userData
  };
}

// Плохо: неявные типы
export function createUser(userData: any) {
  return { id: Date.now(), ...userData };
}
```

### 2. Использование дженериков

Дженерики позволяют создавать гибкие и переиспользуемые компоненты:

```typescript
// Базовый репозиторий с дженериком
export interface Repository<T> {
  findById(id: number): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(item: Omit<T, 'id'>): Promise<T>;
  update(id: number, item: Partial<T>): Promise<T | null>;
  delete(id: number): Promise<boolean>;
}

// Конкретная реализация
export interface Product {
  id: number;
  name: string;
  price: number;
}

export type ProductRepository = Repository<Product>;
```

## Расширенные типы

### Условные типы

```typescript
// Условный тип для определения типа возвращаемого значения
export type ApiResponse<T> = 
  T extends Error 
    ? { success: false; error: T } 
    : { success: true; data: T };

export function handleResponse<T>(result: T): ApiResponse<T> {
  if (result instanceof Error) {
    return { success: false, error: result } as ApiResponse<T>;
  }
  return { success: true, data: result } as ApiResponse<T>;
}
```

### Сопоставляющие типы

```typescript
// Сопоставляющий тип для создания неизменяемой версии
export type Immutable<T> = {
  readonly [K in keyof T]: T[K] extends object 
    ? Immutable<T[K]> 
    : T[K];
};

// Пример использования
export interface MutableUser {
  id: number;
  name: string;
  profile: {
    age: number;
    address: string;
  };
}

export type ImmutableUser = Immutable<MutableUser>;
// Теперь все поля неизменяемы, включая вложенные объекты
```

### Типы утилит

```typescript
// Использование встроенных типов утилит
export interface ApiConfig {
  baseUrl: string;
  timeout: number;
  retries: number;
  headers: Record<string, string>;
}

// Создание типа только с изменяемыми полями
export type MutableConfig = Mutable<ApiConfig>;

// Создание типа с опциональными полями
export type PartialConfig = Partial<ApiConfig>;

// Создание типа с обязательными полями
export type RequiredConfig = Required<ApiConfig>;

// Тип, содержащий только определенные ключи
export type BasicConfig = Pick<ApiConfig, 'baseUrl' | 'timeout'>;

// Тип без определенных ключей
export type AdvancedConfig = Omit<ApiConfig, 'retries'>;
```

## Обработка ошибок с типами

```typescript
// Определение типов ошибок
export enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  AUTH_ERROR = 'AUTH_ERROR'
}

export interface LibraryError {
  code: ErrorCode;
  message: string;
  details?: Record<string, any>;
}

// Тип для результатов операций
export type Result<T, E = LibraryError> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Использование
export function validateUser(user: Partial<User>): Result<User> {
  if (!user.name) {
    return {
      success: false,
      error: {
        code: ErrorCode.VALIDATION_ERROR,
        message: 'Name is required'
      }
    };
  }
  
  return {
    success: true,
    data: {
      id: Date.now(),
      name: user.name,
      email: user.email || ''
    }
  };
}
```

## Типы для асинхронных операций

```typescript
// Типы для промисов
export type AsyncResult<T, E = Error> = Promise<Result<T, E>>;

// Тип для функции, возвращающей промис
export interface AsyncFunction<T, R> {
  (arg: T): Promise<R>;
}

// Тип для асинхронного репозитория
export interface AsyncRepository<T> {
  findById(id: number): AsyncResult<T>;
  findAll(): AsyncResult<T[]>;
  create(item: Omit<T, 'id'>): AsyncResult<T>;
  update(id: number, item: Partial<T>): AsyncResult<T>;
  delete(id: number): AsyncResult<boolean>;
}
```

## Типы для конфигурации

```typescript
// Типы с дефолтными значениями
export interface Config<T = {}> {
  timeout?: number;
  retries?: number;
  baseUrl?: string;
  custom?: T;
}

export const defaultConfig: Required<Config> = {
  timeout: 5000,
  retries: 3,
  baseUrl: 'https://api.example.com',
  custom: {}
};

// Тип для конфигурации с обязательными полями
export interface RequiredConfig<T = {}> extends Required<Config<T>> {}
```

## Типы для коллбэков

```typescript
// Типы для функций обратного вызова
export type EventHandler<T = void> = (data: T) => void;

export interface EventEmitter<T> {
  on(event: string, handler: EventHandler<T>): void;
  off(event: string, handler: EventHandler<T>): void;
  emit(event: string, data: T): void;
}

// Типы для промисов с коллбэками
export interface PromiseWithCallbacks<T> extends Promise<T> {
  onCancel(callback: () => void): PromiseWithCallbacks<T>;
}
```

## Совместимость типов

### Совместимость структурных типов

```typescript
// TypeScript использует структурную типизацию
export interface Point2D {
  x: number;
  y: number;
}

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

// Point3D совместим с Point2D (но не наоборот)
export function drawPoint(point: Point2D): void {
  console.log(`Drawing point at (${point.x}, ${point.y})`);
}

const point3D: Point3D = { x: 1, y: 2, z: 3 };
drawPoint(point3D); // Работает - Point3D совместим с Point2D
```

## Расширение типов

### Интерфейсы против типов

```typescript
// Интерфейсы позволяют расширение
export interface BaseUser {
  id: number;
  name: string;
}

// Этот интерфейс может быть объявлен в другом файле
export interface BaseUser {
  email: string; // Добавление поля к существующему интерфейсу
}

// Типы - нет
export type UserType = {
  id: number;
  name: string;
};

// Нельзя расширить UserType после объявления
```

## Типы для внешних библиотек

```typescript
// Расширение типов для внешних библиотек
declare module 'external-library' {
  export interface ExtendedOptions {
    customOption: boolean;
  }
}

// Создание типов для внешних библиотек
export interface ExternalLibraryWrapper {
  originalLibrary: any; // Тип для оригинальной библиотеки
  enhancedMethod(options: ExtendedOptions): void;
}
```

## Лучшие практики типизации

### 1. Используйте строгую типизацию

```typescript
// Включите строгую типизацию в tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true
  }
}
```

### 2. Документация типов

```typescript
/**
 * Интерфейс пользователя
 * @property id - Уникальный идентификатор пользователя
 * @property name - Имя пользователя
 * @property email - Email пользователя (опционально)
 */
export interface User {
  id: number;
  name: string;
  email?: string;
}
```

### 3. Типы для разных сред

```typescript
// Условные типы для разных сред выполнения
export type PlatformSpecific<T> = {
  node?: T;
  browser?: T;
  reactNative?: T;
};

export function createPlatformSpecific<T>(
  implementations: PlatformSpecific<T>
): T | undefined {
  if (typeof window !== 'undefined' && implementations.browser) {
    return implementations.browser;
  }
  
  if (typeof process !== 'undefined' && implementations.node) {
    return implementations.node;
  }
  
  return implementations.reactNative;
}
```

## Связанные темы

- [[Создание-библиотек]]
- [[Публикация-на-npm]]
- [[Совместимость-библиотек]]
- [[Документация-библиотек]]
- [[TypeScript]]
- [[Типы в TypeScript]]