---
aliases: ["Динамический импорт в TypeScript", "Lazy Loading", "Динамическая загрузка модулей"]
tags: ["typescript", "modules", "dynamic-import", "performance", "optimization"]
---

# Динамический-импорт

## Обзор

Динамический импорт — это механизм в TypeScript (и JavaScript), который позволяет загружать модули по требованию, а не при инициализации приложения. Это особенно полезно для оптимизации производительности, уменьшения начального размера бандла и реализации ленивой загрузки (lazy loading). В отличие от статических импортов, динамические импорты возвращают Promise, что позволяет использовать асинхронные паттерны.

## Синтаксис динамического импорта

Динамический импорт использует функцию `import()`, которая возвращает Promise. Этот синтаксис доступен начиная с ECMAScript 2020.

```typescript
// Синтаксис динамического импорта
const module = await import('./path/to/module');

// Или с использованием .then()
import('./path/to/module').then((module) => {
  // Использование модуля
});
```

## Примеры использования

### Ленивая загрузка компонентов

Одним из распространенных применений динамического импорта является ленивая загрузка компонентов в приложениях с маршрутизацией.

```typescript
// router.ts
interface Route {
  path: string;
  component: () => Promise<any>;
}

const routes: Route[] = [
  {
    path: '/',
    component: () => import('./components/Home'),
  },
  {
    path: '/about',
    component: () => import('./components/About'),
  },
  {
    path: '/contact',
    component: () => import('./components/Contact'),
  },
];

async function loadComponent(path: string) {
  const route = routes.find(r => r.path === path);
  if (route) {
    const module = await route.component();
    return module.default; // Возвращаем компонент по умолчанию
  }
  throw new Error(`Route not found: ${path}`);
}
```

### Условная загрузка модулей

Динамический импорт позволяет загружать модули только при определенных условиях, что экономит ресурсы.

```typescript
// featureLoader.ts
async function loadFeature(featureName: string) {
  switch (featureName) {
    case 'admin':
      const adminModule = await import('./features/admin');
      return adminModule.AdminPanel;
    case 'analytics':
      const analyticsModule = await import('./features/analytics');
      return analyticsModule.AnalyticsDashboard;
    case 'chat':
      const chatModule = await import('./features/chat');
      return chatModule.ChatWidget;
    default:
      throw new Error(`Unknown feature: ${featureName}`);
  }
}

// Использование
async function initializeApp() {
  const userRole = await getCurrentUserRole(); // Предположим, что это асинхронная функция
  if (userRole === 'admin') {
    const AdminPanel = await loadFeature('admin');
    // Инициализация админ-панели
  }
}
```

### Загрузка больших библиотек по требованию

Некоторые библиотеки, такие как графические библиотеки или обработчики документов, могут быть тяжелыми. Их можно загружать только при необходимости.

```typescript
// documentProcessor.ts
async function processDocument(file: File) {
  // Загружаем библиотеку только при необходимости
  const { PDFLib } = await import('pdf-lib');
  const pdfDoc = await PDFLib.PDFDocument.load(await file.arrayBuffer());
  
  // Обработка документа
  const pages = pdfDoc.getPages();
  // ... дополнительная логика
  
  return pdfDoc.save();
}

// Использование
document.getElementById('upload')?.addEventListener('change', async (e) => {
  const file = (e.target as HTMLInputElement).files?.[0];
  if (file && file.type === 'application/pdf') {
    const processedPdf = await processDocument(file);
    // Сохранение или отображение результата
  }
});
```

## Динамический импорт с TypeScript

TypeScript полностью поддерживает динамический импорт. Компилятор может выводить типы из динамически импортируемых модулей.

```typescript
// mathUtils.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

export interface Calculator {
  add: (a: number, b: number) => number;
  multiply: (a: number, b: number) => number;
}
```

```typescript
// main.ts
async function performCalculations() {
  const mathModule = await import('./mathUtils');
  
  // TypeScript знает типы из импортированного модуля
  const sum = mathModule.add(2, 3); // number
  const product = mathModule.multiply(4, 5); // number
  const calc: mathModule.Calculator = {
    add: (a, b) => a + b,
    multiply: (a, b) => a * b
  };
  
  return { sum, product, calc };
}
```

## Ошибки и обработка исключений

При динамическом импорте важно обрабатывать возможные ошибки загрузки модуля.

```typescript
// safeLoader.ts
async function safeImport(modulePath: string) {
  try {
    const module = await import(modulePath);
    return module;
  } catch (error) {
    console.error(`Failed to load module: ${modulePath}`, error);
    throw new Error(`Module ${modulePath} could not be loaded`);
  }
}

// Использование с обработкой ошибок
async function initializeFeature() {
  try {
    const featureModule = await safeImport('./features/advancedFeature');
    // Инициализация функции
  } catch (error) {
    console.warn('Advanced feature not available:', error.message);
    // Резервная реализация
  }
}
```

## Динамический импорт в Node.js

В Node.js динамический импорт также работает, но требует соответствующей настройки компиляции.

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true
  }
}
```

```typescript
// server.ts
async function loadConfig(environment: string) {
  const configModule = await import(`./config/${environment}.ts`);
  return configModule.default;
}

// Использование
async function startServer() {
  const env = process.env.NODE_ENV || 'development';
  const config = await loadConfig(env);
  // Запуск сервера с конфигурацией
}
```

## Производительность и оптимизация

- **Code Splitting**: Динамический импорт позволяет разбивать код на чанки, которые загружаются по требованию.
- **Прогнозирование загрузки**: Современные сборщики (Webpack, Vite) могут автоматически оптимизировать загрузку динамических импортов.
- **Кеширование**: Загруженные модули кешируются, повторные импорты возвращают кешированную версию.

## Лучшие практики

- Используйте динамический импорт для функций, которые не требуются при запуске приложения.
- Организуйте код так, чтобы тяжелые зависимости загружались только при необходимости.
- Обрабатывайте ошибки загрузки модулей.
- Используйте динамический импорт в сочетании с системами маршрутизации для ленивой загрузки страниц.
- Рассмотрите возможность предварительной загрузки (preload) часто используемых модулей.

## Связанные темы

- [[Экспорт-и-импорт]]
- [[Модульность]]
- [[Циклические-зависимости]]