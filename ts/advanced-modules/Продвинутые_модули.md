# Продвинутые модули в TypeScript

Модули в TypeScript предоставляют механизм организации кода в отдельные файлы с четко определенными интерфейсами и зависимостями. Продвинутое использование модулей включает в себя сложные паттерны импорта/экспорта, динамическую загрузку, циклические зависимости и другие аспекты модульной архитектуры.

## Содержание раздела

1. [[ts/advanced-modules/dynamic-imports|Динамические импорты]] - Динамическая загрузка модулей
2. [[ts/advanced-modules/circular-dependencies|Циклические зависимости]] - Решение проблем циклических зависимостей
3. [[ts/advanced-modules/module-augmentation|Расширение модулей]] - Добавление функциональности к существующим модулям
4. [[ts/advanced-modules/namespace-merging|Слияние пространств имен]] - Объединение объявлений
5. [[ts/advanced-modules/ambient-modules|Внешние модули]] - Работа с внешними библиотеками
6. [[ts/advanced-modules/module-resolution|Разрешение модулей]] - Алгоритмы поиска модулей
7. [[ts/advanced-modules/bundling|Бандлинг модулей]] - Оптимизация для сборки
8. [[ts/advanced-modules/code-splitting|Разделение кода]] - Разделение приложения на части

## Введение

Модули - это основной способ организации кода в крупных TypeScript-приложениях. Они позволяют инкапсулировать функциональность, управлять зависимостями и создавать переиспользуемые компоненты.

## Основные концепции

### 1. Модули и файлы

В TypeScript каждый файл является модулем, если он содержит хотя бы один импорт или экспорт:

```typescript
// math.ts - это модуль
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

// types.ts - это тоже модуль
export interface Calculator {
  add(a: number, b: number): number;
  multiply(a: number, b: number): number;
}

// main.ts - это тоже модуль
import { add, multiply } from './math';
import { Calculator } from './types';

const calculator: Calculator = {
  add,
  multiply
};
```

### 2. Экспорт

Существует несколько способов экспорта:

```typescript
// Именованный экспорт
export const PI = 3.14159;
export function calculateArea(radius: number): number {
  return PI * radius * radius;
}

// Экспорт по умолчанию
export default class Circle {
  constructor(private radius: number) {}
  
  get area(): number {
    return calculateArea(this.radius);
  }
}

// Агрегирование
export { PI as PI_CONSTANT } from './math';
export { default as Circle } from './circle';
export * from './utils'; // Экспорт всего из utils
```

### 3. Импорт

Различные способы импорта:

```typescript
// Именованный импорт
import { PI, calculateArea } from './math';

// Импорт по умолчанию
import Circle from './circle';

// Комбинированный импорт
import Circle, { PI, calculateArea } from './circle';

// Импорт с переименованием
import { PI as PI_CONSTANT } from './math';

// Импорт всего как пространство имен
import * as MathUtils from './math';

// Побочный импорт (для сайд-эффектов)
import './polyfills';
```

## Продвинутые паттерны

### 1. Динамический импорт

Динамический импорт позволяет загружать модули по требованию:

```typescript
// Динамический импорт с async/await
async function loadCalculator(): Promise<typeof import('./calculator')> {
  const calculator = await import('./calculator');
  return calculator;
}

// Условная загрузка
async function loadModule(condition: boolean) {
  if (condition) {
    const module = await import('./heavy-module');
    return module.default();
  }
  return null;
}

// Динамический импорт с обработкой ошибок
async function safeImport(modulePath: string) {
  try {
    const module = await import(modulePath);
    return module;
  } catch (error) {
    console.error(`Failed to load module ${modulePath}:`, error);
    return null;
  }
}
```

### 2. Циклические зависимости

Циклические зависимости могут привести к проблемам:

```typescript
// user.ts
import { Post } from './post';

export class User {
  posts: Post[] = [];
  
  addPost(post: Post) {
    this.posts.push(post);
    post.author = this; // Может вызвать проблемы
  }
}

// post.ts
import { User } from './user';

export class Post {
  author: User | null = null;
  
  setAuthor(user: User) {
    this.author = user;
    user.posts.push(this); // Циклическая зависимость
  }
}
```

Решение через интерфейсы:

```typescript
// interfaces.ts
export interface IUser {
  id: string;
  name: string;
  posts: IPost[];
}

export interface IPost {
  id: string;
  title: string;
  author: IUser | null;
}

// user.ts
import { IPost, IUser } from './interfaces';

export class User implements IUser {
  id: string;
  name: string;
  posts: IPost[] = [];
  
  addPost(post: IPost) {
    this.posts.push(post);
    if (post.author === null) {
      post.author = this;
    }
  }
}

// post.ts
import { IUser, IPost } from './interfaces';

export class Post implements IPost {
  id: string;
  title: string;
  author: IUser | null = null;
  
  setAuthor(user: IUser) {
    this.author = user;
    if (!user.posts.includes(this)) {
      user.posts.push(this);
    }
  }
}
```

### 3. Расширение модулей

Модульное расширение позволяет добавлять функциональность к существующим модулям:

```typescript
// original-module.ts
export class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
}

// extension.ts
import { Calculator } from './original-module';

declare module './original-module' {
  interface Calculator {
    multiply(a: number, b: number): number;
  }
}

Calculator.prototype.multiply = function(a: number, b: number): number {
  return a * b;
};

// usage.ts
import { Calculator } from './original-module';
import './extension';

const calc = new Calculator();
console.log(calc.add(2, 3)); // 5
console.log(calc.multiply(2, 3)); // 6
```

### 4. Слияние пространств имен

TypeScript позволяет сливать объявления пространств имен:

```typescript
// math.ts
namespace MathUtils {
  export function add(a: number, b: number): number {
    return a + b;
  }
}

namespace MathUtils {
  export function multiply(a: number, b: number): number {
    return a * b;
  }
}

// Оба объявления сливаются в одно пространство имен
const result1 = MathUtils.add(2, 3);
const result2 = MathUtils.multiply(2, 3);
```

## Практическое применение

### 1. Плагинная архитектура

Модули позволяют создавать гибкие плагинные системы:

```typescript
// plugin-interface.ts
export interface Plugin {
  name: string;
  initialize(): Promise<void>;
  execute(data: any): any;
}

// plugin-manager.ts
export class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  
  async loadPlugin(pluginPath: string): Promise<void> {
    try {
      const pluginModule = await import(pluginPath);
      const plugin: Plugin = new pluginModule.default();
      await plugin.initialize();
      this.plugins.set(plugin.name, plugin);
    } catch (error) {
      console.error(`Failed to load plugin from ${pluginPath}:`, error);
    }
  }
  
  executePlugin(name: string, data: any): any {
    const plugin = this.plugins.get(name);
    if (plugin) {
      return plugin.execute(data);
    }
    throw new Error(`Plugin ${name} not found`);
  }
}

// example-plugin.ts
import { Plugin } from './plugin-interface';

export default class ExamplePlugin implements Plugin {
  name = 'example-plugin';
  
  async initialize(): Promise<void> {
    console.log('Example plugin initialized');
  }
  
  execute(data: any): any {
    return { processed: data, plugin: this.name };
  }
}
```

### 2. Ленивая загрузка

Использование динамических импортов для оптимизации загрузки:

```typescript
// route-loader.ts
interface Route {
  path: string;
  component: () => Promise<any>;
}

const routes: Route[] = [
  {
    path: '/home',
    component: () => import('./pages/home')
  },
  {
    path: '/profile',
    component: () => import('./pages/profile')
  },
  {
    path: '/admin',
    component: () => import('./pages/admin')
  }
];

async function loadRoute(path: string) {
  const route = routes.find(r => r.path === path);
  if (route) {
    const module = await route.component();
    return module.default;
  }
  throw new Error(`Route ${path} not found`);
}
```

### 3. Условная компиляция

Модули позволяют создавать различные сборки приложения:

```typescript
// config.ts
export interface AppConfig {
  apiUrl: string;
  debug: boolean;
}

// config.dev.ts
export const config: AppConfig = {
  apiUrl: 'http://localhost:3000',
  debug: true
};

// config.prod.ts
export const config: AppConfig = {
  apiUrl: 'https://api.example.com',
  debug: false
};

// app.ts
// В зависимости от сборки импортируем нужный конфиг
import { config } from './config.prod'; // или './config.dev'

export class Application {
  constructor() {
    console.log('API URL:', config.apiUrl);
    console.log('Debug mode:', config.debug);
  }
}
```

## Настройка модулей в TypeScript

### 1. moduleResolution

Определяет алгоритм разрешения модулей:

```json
{
  "compilerOptions": {
    "moduleResolution": "node", // или "classic"
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"],
      "@components/*": ["components/*"],
      "@utils/*": ["utils/*"]
    }
  }
}
```

### 2. Псевдонимы путей

Псевдонимы упрощают импорт:

```typescript
// Вместо относительных путей
import { UserService } from '../../../services/user.service';
import { Logger } from '../../../../utils/logger';

// С псевдонимами
import { UserService } from '@services/user.service';
import { Logger } from '@utils/logger';
```

### 3. Внешние модули

Работа с внешними библиотеками:

```typescript
// ambient-module.d.ts
declare module 'my-external-library' {
  export function doSomething(input: string): number;
  export const VERSION: string;
}

// usage.ts
import { doSomething, VERSION } from 'my-external-library';

console.log(VERSION);
const result = doSomething('test');
```

## Оптимизация модулей

### 1. Tree Shaking

Удаление неиспользуемого кода:

```typescript
// utils.ts - Экспортируем только нужные функции
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

// Не экспортируем ненужные функции
function unusedFunction() {
  console.log('This will be removed');
}

// main.ts - Импортируем только нужное
import { add } from './utils'; // multiply не будет включена в сборку
```

### 2. Code Splitting

Разделение кода на части:

```typescript
// lazy-module.ts
export class HeavyComponent {
  processData(data: any[]): any[] {
    // Тяжелая обработка данных
    return data.map(item => ({ ...item, processed: true }));
  }
}

// main.ts
async function loadHeavyComponent() {
  const { HeavyComponent } = await import('./lazy-module');
  const component = new HeavyComponent();
  return component;
}
```

## Лучшие практики

### 1. Явные импорты/экспорты

Избегайте импорта всего пространства имен:

```typescript
// Плохо
import * as fs from 'fs';

// Хорошо
import { readFile, writeFile } from 'fs';
```

### 2. Избегайте циклических зависимостей

Используйте интерфейсы для разрыва циклов:

```typescript
// Плохо - циклическая зависимость
// user.ts -> post.ts -> user.ts

// Хорошо - через интерфейсы
// interfaces.ts -> user.ts, post.ts (оба зависят от interfaces.ts)
```

### 3. Используйте реэкспорт

Организуйте импорты через индексные файлы:

```typescript
// components/index.ts
export { Button } from './button';
export { Input } from './input';
export { Modal } from './modal';

// Вместо множества отдельных импортов
// main.ts
import { Button, Input, Modal } from './components';
```

## Связи с другими концепциями

Модули тесно связаны с другими аспектами TypeScript:

- [[ts/type-system/interfaces|Интерфейсы]] - Для определения контрактов модулей
- [[ts/advanced-types/conditional-types|Условные типы]] - Для создания типобезопасных модулей
- [[ts/utility-types/Утилиты_типов|Утилиты типов]] - Для преобразования типов модулей
- [[ts/decorators/Декораторы|Декораторы]] - Для аннотирования модулей

## Рекомендации по изучению

1. Освойте базовые концепции импорта/экспорта
2. Практикуйтесь в решении циклических зависимостей
3. Изучите динамические импорты и lazy loading
4. Освойте настройку moduleResolution и псевдонимов путей
5. Практикуйтесь в создании плагинных архитектур
6. Изучите оптимизации модулей (tree shaking, code splitting)

## Следующие шаги

- [[ts/configuration/Конфигурация|Конфигурация TypeScript]] - Настройка компилятора
- [[ts/react/React_с_TypeScript|TypeScript с React]] - Типобезопасная разработка React-приложений
- [[ts/functional-programming/Функциональное_программирование|Функциональное программирование]] - Продвинутые функциональные паттерны