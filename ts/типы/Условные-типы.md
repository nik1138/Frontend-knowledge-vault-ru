---
aliases: ["Conditional Types", "Type Conditionals", "Conditional Type Expressions"]
tags: ["#typescript", "#types", "#conditional-types", "#advanced-types"]
---

# Условные типы (Conditional Types)

Условные типы в TypeScript позволяют выражать непростые типы, которые зависят от условий. Они работают по принципу тернарного оператора JavaScript, но на уровне типов, позволяя создавать гибкие и мощные типы, которые могут изменяться в зависимости от входных типов.

## Основы

Условный тип имеет следующий синтаксис:

```ts
T extends U ? X : Y
```

Где:
- `T` - проверяемый тип
- `U` - тип, с которым сравнивается `T`
- `X` - тип, возвращаемый если условие истинно
- `Y` - тип, возвращаемый если условие ложно

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true
type B = IsString<number>; // false
type C = IsString<"hello">; // true (литеральный тип строки)
```

## Примеры использования

### 1. Простые проверки типов

```ts
type TypeName<T> = T extends string
  ? "string"
  : T extends number
  ? "number"
  : T extends boolean
  ? "boolean"
  : "object";

type T0 = TypeName<string>; // "string"
type T1 = TypeName<true>; // "boolean"
type T2 = TypeName<() => void>; // "object"
```

### 2. Извлечение типов из объединений

```ts
type NonNullable<T> = T extends null | undefined ? never : T;

type T0 = NonNullable<string | number | null>; // string | number
type T1 = NonNullable<string | undefined>; // string
type T2 = NonNullable<string | null | undefined>; // string
```

### 3. Преобразование типов на основе условий

```ts
type ElementOf<T> = T extends (infer U)[] ? U : T;

type T0 = ElementOf<string[]>; // string
type T1 = ElementOf<number>; // number
type T2 = ElementOf<(string | number)[]>; // string | number
```

## Распределительные условные типы

Когда условный тип применяется к объединению типов, он становится распределительным, то есть условие применяется к каждому члену объединения отдельно:

```ts
type ToArray<T> = T extends any ? T[] : never;

// Для объединения типов:
type T0 = ToArray<string | number>; // string[] | number[]

// Это эквивалентно:
// (string extends any ? string[] : never) | (number extends any ? number[] : never)
// string[] | number[]
```

## Встроенные условные типы

TypeScript предоставляет несколько встроенных условных типов в виде утилит:

### 1. Exclude<T, U> - исключает типы из T, которые присутствуют в U

```ts
type T0 = Exclude<"a" | "b" | "c", "a" | "c">; // "b"
type T1 = Exclude<string | number | (() => void), Function>; // string | number
```

### 2. Extract<T, U> - извлекает типы из T, которые присутствуют в U

```ts
type T0 = Extract<"a" | "b" | "c", "a" | "c" | "f">; // "a" | "c"
type T1 = Extract<string | number | (() => void), Function>; // () => void
```

### 3. NonNullable<T> - исключает null и undefined

```ts
type T0 = NonNullable<string | number | null | undefined>; // string | number
```

### 4. ReturnType<T> - извлекает тип возвращаемого значения функции

```ts
type T0 = ReturnType<() => string>; // string
type T1 = ReturnType<(x: number) => number>; // number
type T2 = ReturnType<<T>() => T>; // {}
```

### 5. InstanceType<T> - извлекает тип экземпляра класса

```ts
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>; // C
type T1 = InstanceType<typeof Array>; // any[]
```

## Практические применения

### 1. Создание утилит для работы с объектами

```ts
// Извлечение только тех свойств объекта, которые являются функциями
type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;

interface Part {
  id: number;
  name: string;
  updatePart(newName: string): void;
  validate(): boolean;
}

type T0 = FunctionPropertyNames<Part>; // "updatePart" | "validate"
type T1 = FunctionProperties<Part>; // { updatePart(newName: string): void; validate(): boolean; }
```

### 2. Условные типы с дженериками

```ts
// Возвращение типа, но только если он является объектом
type ObjectOnly<T> = T extends object ? T : never;

type T0 = ObjectOnly<string>; // never
type T1 = ObjectOnly<{ a: string }>; // { a: string }
type T2 = ObjectOnly<string | { a: string }>; // { a: string }
```

### 3. Создание маппингов типов

```ts
// Создание типа, который делает определенные свойства обязательными
type RequireExactlyOne<T, Keys extends keyof T = keyof T> = 
  Pick<T, Exclude<keyof T, Keys>> &
  {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>
  }[Keys];

interface Shape {
  circle?: number;
  square?: string;
  triangle?: boolean;
}

// Теперь можно использовать только один из этих параметров
const shape1: RequireExactlyOne<Shape, "circle" | "square" | "triangle"> = {
  circle: 5,
  square: undefined,
  triangle: undefined
};
```

## Особенности и предостережения

### 1. Отложенное вычисление

Условные типы вычисляются только тогда, когда они инстанцируются с конкретным типом:

```ts
type Lazy<T> = T extends string ? string : number; // Не вычисляется до тех пор, пока не будет использован
```

### 2. infer для захвата типов

Ключевое слово `infer` позволяет захватывать типы внутри условных типов:

```ts
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

type T0 = GetReturnType<() => string>; // string
type T1 = GetReturnType<(x: number) => number>; // number
```

### 3. Ограничения на infer

`infer` может использоваться только в правой части условного типа:

```ts
// Правильно
type ParamType<T> = T extends (param: infer P) => any ? P : any;

// Неправильно - ошибка компиляции
// type Wrong<T> = T extends (param: infer P) => infer P ? P : any;
```

## Продвинутые примеры

### 1. Утилита для извлечения типов промисов

```ts
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

type T0 = Awaited<Promise<string>>; // string
type T1 = Awaited<Promise<Promise<number>>>; // number
type T2 = Awaited<boolean>; // boolean
```

### 2. Условный тип для работы с массивами

```ts
type Flatten<T> = T extends Array<infer Item> ? Item : T;

type T0 = Flatten<number[]>; // number
type T1 = Flatten<string[][]>; // string[] (не рекурсивно)
type T2 = Flatten<boolean>; // boolean
```

## Преимущества условных типов

- **Гибкость**: Позволяют создавать типы, которые изменяются в зависимости от входных параметров
- **Мощные утилиты**: Позволяют создавать сложные утилиты для работы с типами
- **Безопасность**: Обеспечивают строгую типизацию даже в сложных сценариях
- **Автоматизация**: Позволяют автоматически выводить типы на основе других типов
- **Метапрограммирование**: Позволяют выполнять операции на уровне типов

## Практические советы

- Начинайте с простых условных типов и постепенно переходите к более сложным
- Используйте `infer` для захвата типов внутри условных выражений
- Помните о распределительных свойствах условных типов при работе с объединениями
- Используйте встроенные условные типы как основу для создания собственных утилит
- Условные типы особенно полезны при создании сложных утилит и библиотек типов
- Тестируйте условные типы с различными входными типами, чтобы убедиться в правильности поведения

## Связанные концепции

- [[Generic Types]]
- [[Utility Types]]
- [[Mapped Types]]
- [[Infer Type]]
- [[Advanced Types]]
