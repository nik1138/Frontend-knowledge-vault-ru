---
aliases: ["Intersection Types", "Type Intersections", "Combined Types"]
tags: ["#typescript", "#types", "#intersection-types", "#combined-types"]
---

# Пересечения типов (Intersection Types)

Пересечения типов в TypeScript позволяют объединить несколько типов в один. Результирующий тип будет иметь все свойства из всех типов, участвующих в пересечении. Это мощный способ создания сложных типов из более простых компонентов.

## Основы

Пересечение типов создается с помощью символа `&` между типами:

```ts
type A = { a: string };
type B = { b: number };
type AB = A & B; // Тип с полями a и b

const value: AB = { a: "hello", b: 42 }; // OK
// const invalid: AB = { a: "hello" }; // Ошибка: отсутствует свойство b
```

## Примеры использования

### 1. Комбинирование интерфейсов

```ts
interface Identifiable {
  id: number;
}

interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

interface Nameable {
  name: string;
}

type Entity = Identifiable & Timestamped & Nameable;

const user: Entity = {
  id: 1,
  createdAt: new Date(),
  updatedAt: new Date(),
  name: "John Doe"
};
```

### 2. Расширение существующих типов

```ts
type BaseUser = {
  id: number;
  email: string;
};

type AdminUser = BaseUser & {
  permissions: string[];
  role: "admin";
};

type GuestUser = BaseUser & {
  lastVisit: Date;
  role: "guest";
};

const admin: AdminUser = {
  id: 1,
  email: "admin@example.com",
  permissions: ["read", "write", "delete"],
  role: "admin"
};
```

### 3. Пересечения с функциями

```ts
type FunctionWithMetadata = ((...args: any[]) => any) & {
  displayName: string;
  version: number;
};

function myFunction() {
  return "Hello";
}

(myFunction as FunctionWithMetadata).displayName = "My Function";
(myFunction as FunctionWithMetadata).version = 1.0;

const enhancedFunction: FunctionWithMetadata = myFunction as FunctionWithMetadata;
```

### 4. Использование с дженериками

```ts
type WithRequired<T, K extends keyof T> = T & Required<Pick<T, K>>;

interface User {
  id?: number;
  name?: string;
  email?: string;
}

type CompleteUser = WithRequired<User, "id" | "name">;

// Теперь CompleteUser требует поля id и name, но email остается опциональным
const user: CompleteUser = {
  id: 1,
  name: "John",
  email: "john@example.com" // опционально
};
```

## Практические применения

### 1. Смешивание поведений

```ts
type Loggable = {
  log: () => void;
};

type Timestamped = {
  timestamp: Date;
};

type Auditable = Loggable & Timestamped;

class AuditEntry implements Auditable {
  timestamp: Date = new Date();
  
  log() {
    console.log(`Audit entry at ${this.timestamp}`);
  }
}
```

### 2. Улучшение существующих библиотечных типов

```ts
import { Component } from "react";

// Предположим, у нас есть тип компонента, который мы хотим расширить
type WithLoading<T> = T & { loading: boolean };

type ComponentWithLoading = WithLoading<Component>;
```

## Особенности и предостережения

### 1. Пересечение объектов

При пересечении объектных типов результатом будет тип, содержащий все поля из всех типов:

```ts
type Left = { a: string };
type Right = { b: number };
type Combined = Left & Right; // { a: string, b: number }
```

### 2. Пересечение примитивов

Пересечение примитивных типов может привести к непредсказуемым результатам:

```ts
type Impossible = string & number; // Тип, который невозможно реализовать
// let value: Impossible; // Невозможно присвоить значение
```

### 3. Пересечение функций

При пересечении функций результатом будет перегрузка функций:

```ts
type FuncA = (x: string) => string;
type FuncB = (x: number) => number;
type CombinedFunc = FuncA & FuncB;

// Это позволяет создать функцию, которая может работать с разными типами
const combined: CombinedFunc = (x: string | number): string | number => {
  if (typeof x === "string") {
    return x;
  }
  return x;
};
```

## Преимущества пересечений типов

- **Композиция**: Позволяет создавать сложные типы из более простых
- **Повторное использование**: Можно комбинировать существующие типы без дублирования кода
- **Гибкость**: Обеспечивает способ расширения типов без наследования
- **Модульность**: Позволяет разделять ответственность за разные аспекты типа

## Практические советы

- Используйте пересечения для комбинирования независимых аспектов данных
- Будьте осторожны при пересечении типов с одинаковыми именами полей - они должны быть совместимы
- Рассмотрите использование пересечений вместо наследования интерфейсов в некоторых случаях
- Пересечения особенно полезны при работе с библиотеками, где нужно расширить существующие типы

## Связанные концепции

- [[Псевдонимы-типов]]
- [[Объединения-типов]]
- [[Интерфейсы]]
- [[Generic Types]]
- [[Utility Types]]
