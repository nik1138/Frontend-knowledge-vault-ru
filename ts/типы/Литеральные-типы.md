---
aliases: ["Literal Types", "Constant Types", "Value Types"]
tags: ["#typescript", "#types", "#literal-types", "#value-types"]
---

# Литеральные типы (Literal Types)

Литеральные типы в TypeScript позволяют указать конкретное значение как тип. Это означает, что переменная может принимать только одно конкретное значение, а не весь тип данных. Литеральные типы могут быть строками, числами, булевыми значениями или символами.

## Основы

Литеральный тип определяется значением, заключенным в кавычки для строк, или просто значением для чисел и булевых типов:

```ts
type World = "world";
type Num = 42;
type Bool = true;

const greeting: `hello ${World}` = "hello world"; // Template literal
const answer: Num = 42; // OK
const isActive: Bool = true; // OK

// const wrongAnswer: Num = 43; // Ошибка: 43 не является частью типа 42
```

## Примеры использования

### 1. Литеральные строки

```ts
type Direction = "up" | "down" | "left" | "right";
type Status = "pending" | "approved" | "rejected";

function move(direction: Direction) {
  console.log(`Moving ${direction}`);
}

move("up"); // OK
// move("forward"); // Ошибка: "forward" не является частью типа Direction
```

### 2. Литеральные числа

```ts
type HTTPStatus = 200 | 201 | 400 | 401 | 404 | 500;
type DiceValue = 1 | 2 | 3 | 4 | 5 | 6;

function handleResponse(status: HTTPStatus) {
  switch(status) {
    case 200:
      console.log("Success");
      break;
    case 404:
      console.log("Not found");
      break;
    default:
      console.log(`Error with status: ${status}`);
  }
}
```

### 3. Литеральные булевы значения

```ts
type Success = true;
type Failure = false;

function apiCall(): Success | Failure {
  // Реализация API вызова
  return Math.random() > 0.5 ? true : false;
}

const result: Success | Failure = apiCall();
```

### 4. Объединения литеральных типов

```ts
type MouseButton = "left" | "middle" | "right";
type Alignment = "left" | "center" | "right";
type Size = "small" | "medium" | "large";

function setButtonProps(
  alignment: Alignment,
  size: Size,
  mouseButton: MouseButton
) {
  // Установка свойств кнопки
}
```

## Практические применения

### 1. Строгая типизация конфигурации

```ts
type Environment = "development" | "staging" | "production";
type LogLevel = "debug" | "info" | "warn" | "error";

interface AppConfig {
  env: Environment;
  logLevel: LogLevel;
  port: number;
}

const config: AppConfig = {
  env: "production", // Только одно из разрешенных значений
  logLevel: "error", // Только одно из разрешенных значений
  port: 8080
};
```

### 2. Типизация параметров API

```ts
type SortOrder = "asc" | "desc";
type FilterType = "equals" | "contains" | "startsWith" | "endsWith";

interface QueryParams {
  sort?: `${keyof any}-${SortOrder}`; // Пример: "name-asc", "date-desc"
  filter?: {
    field: string;
    type: FilterType;
    value: string;
  };
}
```

### 3. Улучшение безопасности типов

```ts
type UserRole = "admin" | "editor" | "viewer";
type Permission = "read" | "write" | "delete";

function hasPermission(userRole: UserRole, permission: Permission): boolean {
  const permissions: Record<UserRole, Permission[]> = {
    admin: ["read", "write", "delete"],
    editor: ["read", "write"],
    viewer: ["read"]
  };
  
  return permissions[userRole].includes(permission);
}
```

## Особенности и предостережения

### 1. Выведение типов

TypeScript может автоматически выводить литеральные типы из значений:

```ts
const status = "pending"; // Тип: "pending", а не string
let status2 = "pending"; // Тип: string (изменяемая переменная)
const status3 = "pending" as const; // Тип: "pending" (const assertion)
```

### 2. Template Literal Types

С версии TypeScript 4.1 можно использовать литеральные типы в шаблонных строках:

```ts
type Color = "red" | "green" | "blue";
type BackgroundColor = `bg-${Color}`;
type TextColor = `text-${Color}`;

const bg: BackgroundColor = "bg-red"; // OK
// const invalid: BackgroundColor = "bg-yellow"; // Ошибка
```

### 3. Совместимость с родительскими типами

Литеральные типы совместимы с родительскими типами:

```ts
type Status = "active" | "inactive";
let status: Status = "active";
let str: string = status; // OK: Status совместим с string
```

## Преимущества литеральных типов

- **Строгая типизация**: Ограничивает значения до конкретных разрешенных вариантов
- **Безопасность**: Предотвращает передачу недопустимых значений
- **Ясность**: Явно указывает, какие значения допустимы в конкретной ситуации
- **Автодополнение**: IDE может предлагать только допустимые значения
- **Документирование**: Служит формой документации для API и интерфейсов

## Практические советы

- Используйте литеральные типы для определения ограниченных наборов значений (например, статусы, типы действий)
- Рассмотрите использование литеральных типов в объединениях для создания дискриминантных типов
- Используйте const assertion (`as const`) для получения литерального типа из выражений
- Литеральные типы особенно полезны при работе с API, где ожидается строго определенный набор значений
- Шаблонные литеральные типы позволяют создавать сложные типы на основе литеральных значений

## Связанные концепции

- [[Объединения-типов]]
- [[Template Literal Types]]
- [[Type Guards]]
- [[Discriminated Unions]]
- [[Const Assertions]]
