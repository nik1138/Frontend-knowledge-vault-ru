---
aliases: ["Union Types", "Type Unions", "Disjoint Types"]
tags: ["#typescript", "#types", "#union-types", "#disjoint-types"]
---

# Объединения типов (Union Types)

Объединения типов в TypeScript позволяют указать, что значение может быть одного из нескольких типов. Это мощный способ описания гибких типов, особенно когда значение может быть разных типов в зависимости от условий.

## Основы

Объединение типов создается с помощью символа `|` между типами:

```ts
type StringOrNumber = string | number;
let value: StringOrNumber = "hello"; // OK
value = 42; // OK
// value = true; // Ошибка: boolean не является частью объединения
```

## Примеры использования

### 1. Простые объединения

```ts
type Status = "success" | "error" | "loading";
type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";

function request(method: HTTPMethod, url: string) {
  // реализация запроса
}

request("GET", "/api/users"); // OK
// request("PATCH", "/api/users"); // Ошибка: "PATCH" не является частью объединения
```

### 2. Объединения с объектами

```ts
type Admin = {
  type: "admin";
  adminId: number;
  permissions: string[];
};

type User = {
  type: "user";
  userId: number;
  email: string;
};

type Person = Admin | User;

function handlePerson(person: Person) {
  if (person.type === "admin") {
    // TypeScript знает, что это Admin
    console.log(person.adminId);
  } else {
    // TypeScript знает, что это User
    console.log(person.email);
  }
}
```

### 3. Объединения с дженериками

```ts
type Result<T> = { success: true; data: T } | { success: false; error: string };

function processData(): Result<User[]> {
  // Возвращает либо успешный результат с данными, либо ошибку
  if (Math.random() > 0.5) {
    return { success: true, data: [{ type: "user", userId: 1, email: "test@example.com" }] };
  } else {
    return { success: false, error: "Failed to process data" };
  }
}
```

## Проверка типов в объединениях

При работе с объединениями типов часто нужно различать, какой конкретно тип используется. TypeScript предоставляет несколько способов для этого:

### Проверка дискриминанта

```ts
// В примере с Person выше, поле type является дискриминантом
// TypeScript автоматически сужает тип внутри условий
```

### Проверка типа с помощью "in" оператора

```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ('swim' in animal) {
    animal.swim(); // animal теперь типа Fish
  } else {
    animal.fly(); // animal теперь типа Bird
  }
}
```

### Проверка типа с помощью пользовательских функций

```ts
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

function getFood(pet: Fish | Bird) {
  if (isFish(pet)) {
    return "fish food";
  } else {
    return "bird food";
  }
}
```

## Преимущества объединений типов

- **Гибкость**: Позволяет описывать значения, которые могут быть разных типов
- **Безопасность типов**: TypeScript проверяет все возможные варианты использования
- **Ясность**: Явно указывает, какие типы допустимы в конкретной ситуации
- **Дискриминантная типизация**: Позволяет эффективно работать с различными вариантами объединения

## Практические советы

- Используйте литеральные типы в объединениях для создания четко определенных значений (например, статусы)
- Рассмотрите использование дискриминантных объединений для сложных структур данных
- Используйте проверки типов (type guards) для безопасной работы с различными вариантами объединения
- Объединения особенно полезны при работе с API-ответами, где структура может варьироваться

## Связанные концепции

- [[Псевдонимы-типов]]
- [[Пересечения-типов]]
- [[Литеральные-типы]]
- [[Type Guards]]
- [[Discriminated Unions]]
