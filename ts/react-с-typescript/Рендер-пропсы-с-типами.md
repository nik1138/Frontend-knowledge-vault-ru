---
aliases: [Typed Render Props, Render Props with Types, Типизированные рендер-пропсы]
tags: [typescript, react, render-props, patterns, typing]
---

# Рендер-пропсы с типами

## Обзор

Рендер-пропсы (Render Props) - это паттерн в React, при котором компонент получает функцию через пропс, которая возвращает React-элемент. Этот паттерн позволяет делиться состоянием и логикой между компонентами. При использовании TypeScript важно правильно типизировать рендер-пропсы, чтобы обеспечить безопасность типов и автодополнение.

## Базовая структура рендер-пропсов

### Простой пример с типами

```typescript
import React, { useState, ReactNode } from 'react';

interface CounterRenderProps {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

interface CounterProps {
  children: (props: CounterRenderProps) => ReactNode;
}

const Counter: React.FC<CounterProps> = ({ children }) => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const reset = () => setCount(0);

  return children({
    count,
    increment,
    decrement,
    reset
  });
};

// Использование
const App: React.FC = () => {
  return (
    <Counter>
      {({ count, increment, decrement, reset }) => (
        <div>
          <p>Счетчик: {count}</p>
          <button onClick={increment}>+</button>
          <button onClick={decrement}>-</button>
          <button onClick={reset}>Сброс</button>
        </div>
      )}
    </Counter>
  );
};
```

### Альтернативный способ: с именованным пропсом

```typescript
import React, { useState, ReactNode } from 'react';

interface MouseRenderProps {
  x: number;
  y: number;
}

interface MouseTrackerProps {
  render: (props: MouseRenderProps) => ReactNode;
}

const MouseTracker: React.FC<MouseTrackerProps> = ({ render }) => {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (e: React.MouseEvent) => {
    setPosition({
      x: e.clientX,
      y: e.clientY
    });
  };

  return (
    <div style={{ height: '100vh' }} onMouseMove={handleMouseMove}>
      {render(position)}
    </div>
  );
};

// Использование
const App: React.FC = () => {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <div>
          <p>X: {x}, Y: {y}</p>
        </div>
      )}
    />
  );
};
```

## Продвинутая типизация рендер-пропсов

### Рендер-пропсы с дженериками

```typescript
import React, { useState, ReactNode } from 'react';

interface DataFetcherRenderProps<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

interface DataFetcherProps<T> {
  url: string;
  children: (props: DataFetcherRenderProps<T>) => ReactNode;
}

function DataFetcher<T>({ url, children }: DataFetcherProps<T>): JSX.Element {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url);
      if (!response.ok) throw new Error('Ошибка запроса');
      const result: T = await response.json();
      setData(result);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setLoading(false);
    }
  };

  React.useEffect(() => {
    fetchData();
  }, [url]);

  return children({
    data,
    loading,
    error,
    refetch: fetchData
  });
}

// Использование с типизацией
interface User {
  id: number;
  name: string;
  email: string;
}

const App: React.FC = () => {
  return (
    <DataFetcher<User[]> url="/api/users">
      {({ data, loading, error, refetch }) => {
        if (loading) return <div>Загрузка...</div>;
        if (error) return <div>Ошибка: {error}</div>;
        
        return (
          <div>
            <button onClick={refetch}>Обновить</button>
            {data?.map(user => (
              <div key={user.id}>
                <h3>{user.name}</h3>
                <p>{user.email}</p>
              </div>
            ))}
          </div>
        );
      }}
    </DataFetcher>
  );
};
```

### Рендер-пропсы с несколькими состояниями

```typescript
import React, { useState, ReactNode } from 'react';

interface FormRenderProps {
  values: Record<string, any>;
  errors: Record<string, string>;
  handleChange: (name: string, value: any) => void;
  handleSubmit: (e: React.FormEvent) => void;
  isSubmitting: boolean;
  isValid: boolean;
}

interface FormProps {
  initialValues: Record<string, any>;
  onSubmit: (values: Record<string, any>) => Promise<void>;
  validate?: (values: Record<string, any>) => Record<string, string>;
  children: (props: FormRenderProps) => ReactNode;
}

const Form: React.FC<FormProps> = ({ 
  initialValues, 
  onSubmit, 
  validate = () => ({}),
  children 
}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (name: string, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Очистка ошибки при изменении поля
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const validationErrors = validate(values);
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length > 0) {
      return;
    }
    
    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  };

  const isValid = Object.keys(errors).length === 0;

  return children({
    values,
    errors,
    handleChange,
    handleSubmit,
    isSubmitting,
    isValid
  });
};

// Использование
const LoginForm: React.FC = () => {
  return (
    <Form
      initialValues={{ email: '', password: '' }}
      onSubmit={async (values) => {
        console.log('Отправка формы:', values);
        // Логика отправки формы
      }}
      validate={(values) => {
        const errors: Record<string, string> = {};
        
        if (!values.email) {
          errors.email = 'Email обязателен';
        } else if (!/\S+@\S+\.\S+/.test(values.email)) {
          errors.email = 'Email некорректен';
        }
        
        if (!values.password) {
          errors.password = 'Пароль обязателен';
        } else if (values.password.length < 6) {
          errors.password = 'Пароль должен быть не менее 6 символов';
        }
        
        return errors;
      }}
    >
      {({ values, errors, handleChange, handleSubmit, isSubmitting, isValid }) => (
        <form onSubmit={handleSubmit}>
          <div>
            <input
              type="email"
              value={values.email}
              onChange={(e) => handleChange('email', e.target.value)}
              placeholder="Email"
            />
            {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
          </div>
          
          <div>
            <input
              type="password"
              value={values.password}
              onChange={(e) => handleChange('password', e.target.value)}
              placeholder="Пароль"
            />
            {errors.password && <span style={{ color: 'red' }}>{errors.password}</span>}
          </div>
          
          <button 
            type="submit" 
            disabled={isSubmitting || !isValid}
          >
            {isSubmitting ? 'Отправка...' : 'Войти'}
          </button>
        </form>
      )}
    </Form>
  );
};
```

## Рендер-пропсы с контекстом

```typescript
import React, { useState, ReactNode, createContext, useContext } from 'react';

interface ThemeRenderProps {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
  fontSize: number;
  setFontSize: (size: number) => void;
}

interface ThemeProviderProps {
  children: ReactNode;
}

const ThemeContext = createContext<ThemeRenderProps | undefined>(undefined);

const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  const [fontSize, setFontSize] = useState(16);

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  const value: ThemeRenderProps = {
    theme,
    toggleTheme,
    fontSize,
    setFontSize
  };

  return (
    <ThemeContext.Provider value={value}>
      <div className={`app ${theme}`} style={{ fontSize }}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

// Компонент, использующий контекст как рендер-проп
const ThemeConsumer: React.FC<{ children: (props: ThemeRenderProps) => ReactNode }> = ({ children }) => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('ThemeConsumer must be used within a ThemeProvider');
  }
  return children(context);
};

// Использование
const App: React.FC = () => {
  return (
    <ThemeProvider>
      <ThemeConsumer>
        {({ theme, toggleTheme, fontSize, setFontSize }) => (
          <div>
            <h1>Текущая тема: {theme}</h1>
            <button onClick={toggleTheme}>Переключить тему</button>
            <div>
              <label>Размер шрифта: {fontSize}px</label>
              <input 
                type="range" 
                min="12" 
                max="24" 
                value={fontSize} 
                onChange={(e) => setFontSize(Number(e.target.value))}
              />
            </div>
          </div>
        )}
      </ThemeConsumer>
    </ThemeProvider>
  );
};
```

## Комбинирование рендер-пропсов

```typescript
import React, { useState, ReactNode } from 'react';

// Рендер-проп для управления видимостью
interface VisibilityRenderProps {
  visible: boolean;
  show: () => void;
  hide: () => void;
  toggle: () => void;
}

interface VisibilityProviderProps {
  children: (props: VisibilityRenderProps) => ReactNode;
}

const VisibilityProvider: React.FC<VisibilityProviderProps> = ({ children }) => {
  const [visible, setVisible] = useState(false);

  const show = () => setVisible(true);
  const hide = () => setVisible(false);
  const toggle = () => setVisible(prev => !prev);

  return children({ visible, show, hide, toggle });
};

// Рендер-проп для управления данными
interface DataRenderProps<T> {
  data: T | null;
  setData: React.Dispatch<React.SetStateAction<T | null>>;
  isLoading: boolean;
  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;
}

interface DataProviderProps<T> {
  initialData: T | null;
  children: (props: DataRenderProps<T>) => ReactNode;
}

function DataProvider<T>({ 
  initialData, 
  children 
}: DataProviderProps<T>): JSX.Element {
  const [data, setData] = useState<T | null>(initialData);
  const [isLoading, setIsLoading] = useState(false);

  return children({ data, setData, isLoading, setIsLoading });
}

// Комбинирование рендер-пропсов
const App: React.FC = () => {
  return (
    <VisibilityProvider>
      {({ visible, toggle }) => (
        <DataProvider<string> initialData="Привет, мир!">
          {({ data, setData, isLoading }) => (
            <div>
              <button onClick={toggle}>
                {visible ? 'Скрыть' : 'Показать'}
              </button>
              
              {visible && (
                <div>
                  <p>{data}</p>
                  <input
                    value={data || ''}
                    onChange={(e) => setData(e.target.value)}
                    disabled={isLoading}
                  />
                  <button 
                    onClick={() => {
                      setIsLoading(true);
                      setTimeout(() => setIsLoading(false), 1000);
                    }}
                    disabled={isLoading}
                  >
                    {isLoading ? 'Загрузка...' : 'Обновить'}
                  </button>
                </div>
              )}
            </div>
          )}
        </DataProvider>
      )}
    </VisibilityProvider>
  );
};
```

## Рендер-пропсы с кастомными хуками

```typescript
import React, { useState, useEffect, ReactNode } from 'react';

// Кастомный хук для работы с localStorage
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value: T) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

interface LocalStorageRenderProps<T> {
  value: T;
  setValue: (value: T) => void;
  reset: () => void;
}

interface LocalStorageProviderProps<T> {
  key: string;
  initialValue: T;
  children: (props: LocalStorageRenderProps<T>) => ReactNode;
}

function LocalStorageProvider<T>({ 
  key, 
  initialValue, 
  children 
}: LocalStorageProviderProps<T>): JSX.Element {
  const [value, setValue] = useLocalStorage<T>(key, initialValue);

  const reset = () => setValue(initialValue);

  return children({ value, setValue, reset });
}

// Использование
const App: React.FC = () => {
  return (
    <LocalStorageProvider<string> key="user-name" initialValue="">
      {({ value, setValue, reset }) => (
        <div>
          <input
            value={value}
            onChange={(e) => setValue(e.target.value)}
            placeholder="Введите ваше имя"
          />
          <p>Сохраненное имя: {value}</p>
          <button onClick={reset}>Сброс</button>
        </div>
      )}
    </LocalStorageProvider>
  );
};
```

## Рендер-пропсы с асинхронными операциями

```typescript
import React, { useState, ReactNode, useCallback } from 'react';

interface AsyncOperationRenderProps<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  execute: (params?: any) => Promise<void>;
  cancel: () => void;
}

interface AsyncOperationProviderProps<T, P = void> {
  operation: (params: P) => Promise<T>;
  children: (props: AsyncOperationRenderProps<T>) => ReactNode;
}

function AsyncOperationProvider<T, P = void>({ 
  operation, 
  children 
}: AsyncOperationProviderProps<T, P>): JSX.Element {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const [abortController, setAbortController] = useState<AbortController | null>(null);

  const execute = useCallback(async (params?: P) => {
    // Отменяем предыдущую операцию, если она есть
    if (abortController) {
      abortController.abort();
    }

    const controller = new AbortController();
    setAbortController(controller);

    try {
      setLoading(true);
      setError(null);
      const result = await operation(params!);
      
      if (!controller.signal.aborted) {
        setData(result);
      }
    } catch (err) {
      if (!controller.signal.aborted) {
        setError(err as Error);
      }
    } finally {
      if (!controller.signal.aborted) {
        setLoading(false);
      }
      if (abortController === controller) {
        setAbortController(null);
      }
    }
  }, [operation, abortController]);

  const cancel = useCallback(() => {
    if (abortController) {
      abortController.abort();
      setAbortController(null);
      setLoading(false);
    }
  }, [abortController]);

  return children({
    data,
    loading,
    error,
    execute,
    cancel
  });
}

// Использование
interface SearchResult {
  id: number;
  title: string;
  description: string;
}

const SearchComponent: React.FC = () => {
  return (
    <AsyncOperationProvider<SearchResult[], string>
      operation={async (query: string) => {
        // Симуляция API-запроса
        await new Promise(resolve => setTimeout(resolve, 1000));
        return [
          { id: 1, title: `Результат для: ${query}`, description: 'Описание результата' }
        ];
      }}
    >
      {({ data, loading, error, execute, cancel }) => (
        <div>
          <input
            type="text"
            placeholder="Поиск..."
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                execute(e.currentTarget.value);
              }
            }}
          />
          <button onClick={() => execute('test')}>Поиск</button>
          <button onClick={cancel} disabled={!loading}>
            Отмена
          </button>
          
          {loading && <p>Поиск...</p>}
          {error && <p>Ошибка: {error.message}</p>}
          {data && (
            <ul>
              {data.map(item => (
                <li key={item.id}>
                  <h4>{item.title}</h4>
                  <p>{item.description}</p>
                </li>
              ))}
            </ul>
          )}
        </div>
      )}
    </AsyncOperationProvider>
  );
};
```

## Лучшие практики

1. **Используйте ReactNode для типизации возвращаемого значения**:
   ```typescript
   children: (props: MyRenderProps) => ReactNode
   ```

2. **Создавайте интерфейсы для пропсов рендер-функции**:
   Это улучшает читаемость и позволяет переиспользовать типы.

3. **Используйте дженерики для универсальных рендер-пропсов**:
   ```typescript
   function MyRenderProp<T>({ data, children }: { data: T; children: (data: T) => ReactNode }) { ... }
   ```

4. **Предоставляйте понятные имена пропсов**:
   Используйте `children` для рендер-пропсов или понятные имена типа `render`.

5. **Избегайте чрезмерного вложения**:
   Слишком глубокое вложение рендер-пропсов может затруднить чтение кода.

## Сравнение с другими паттернами

### Рендер-пропсы vs HOC

Рендер-пропсы часто считаются более гибкой альтернативой HOC:

```typescript
// HOC подход
const EnhancedComponent = withData(withAuth(BaseComponent));

// Рендер-пропсы подход
const App: React.FC = () => (
  <AuthProvider>
    <DataProvider>
      {({ data }) => (
        <AuthConsumer>
          {({ user }) => (
            <BaseComponent data={data} user={user} />
          )}
        </AuthConsumer>
      )}
    </DataProvider>
  </AuthProvider>
);
```

### Рендер-пропсы vs Хуки

Хуки часто являются более предпочтительным подходом в современном React:

```typescript
// Рендер-пропсы
<MouseTracker>
  {({ x, y }) => <div>Позиция: {x}, {y}</div>}
</MouseTracker>

// Хуки (более современный подход)
const App: React.FC = () => {
  const { x, y } = useMousePosition();
  return <div>Позиция: {x}, {y}</div>;
};

function useMousePosition() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return position;
}
```

## Связанные темы

- [[Типизация-React-компонентов]]
- [[Типизация-React-хуков]]
- [[Типизация-React-контекста]]
- [[HOC-с-типами]]
- [[React-паттерны-типов]]

## Заключение

Рендер-пропсы - мощный паттерн для разделения логики и состояния в React-приложениях. При использовании TypeScript важно правильно типизировать рендер-пропсы, чтобы обеспечить безопасность типов и улучшить опыт разработки. Однако в современном React часто предпочтительнее использовать хуки для решения схожих задач, так как они обеспечивают более простую и читаемую структуру кода.