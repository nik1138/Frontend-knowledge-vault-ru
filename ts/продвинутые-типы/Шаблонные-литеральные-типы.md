---
aliases: ["Template Literal Types", "Шаблонные литеральные типы"]
tags: [typescript, advanced-types, template-literal-types, string-types]
---

# Шаблонные литеральные типы (Template Literal Types)

Шаблонные литеральные типы - это мощная функция TypeScript, появившаяся в версии 4.1, которая позволяет создавать строковые типы с использованием шаблонов, аналогично шаблонным строкам в JavaScript. Они позволяют манипулировать строковыми литералами на этапе компиляции, создавая сложные строковые типы на основе существующих.

## Основы шаблонных литеральных типов

Шаблонные литеральные типы создаются с помощью синтаксиса, аналогичного шаблонным строкам в JavaScript, но используются на уровне типов:

```ts
type World = "world";
type Greeting = `hello ${World}`;  // "hello world"
```

### Простые примеры

```ts
type Email = `${string}@${string}.${string}`;  // Шаблонный тип для email

const validEmail: Email = "user@example.com";  // OK
// const invalidEmail: Email = "not-an-email";  // Ошибка компиляции
```

## Комбинирование строковых литералов

Шаблонные литеральные типы особенно полезны при работе с объединениями строковых литералов:

```ts
type EventName = "click" | "scroll" | "mousemove";
type HandlerName = `on${Capitalize<EventName>}`;

// Результат: "onClick" | "onScroll" | "onMousemove"
```

## Встроенные утилиты для работы со строками

TypeScript предоставляет несколько встроенных утилит для работы со строковыми типами:

### Uppercase, Lowercase, Capitalize, Uncapitalize

```ts
type Greeting = "hello, world";
type ShoutyGreeting = Uppercase<Greeting>;     // "HELLO, WORLD"
type QuietGreeting = Lowercase<Greeting>;      // "hello, world"
type TitleCase = Capitalize<"hello world">;    // "Hello world"
type UnTitleCase = Uncapitalize<"Hello World">; // "hello World"
```

## Практические примеры

### 1. Создание типов для событий

```ts
type EventMap = {
  [K in `on${Capitalize<string>}`]: (event: Event) => void;
};

// Использование
const handlers: EventMap = {
  onClick: (e) => console.log("clicked", e),
  onMouseEnter: (e) => console.log("mouse entered", e),
  // onSomeCustomEvent: (e) => console.log("custom", e), // Все валидные
};
```

### 2. Преобразование ключей объекта

```ts
type AddPrefix<T, P extends string> = {
  [K in keyof T as `${P}${Capitalize<string & K>}`]: T[K];
};

interface User {
  name: string;
  email: string;
  age: number;
}

type PrefixedUser = AddPrefix<User, "user">;
// Результат: { userName: string; userEmail: string; userAge: number; }
```

### 3. Создание типов для CSS классов

```ts
type BEM<B extends string, E extends string[], M extends string[]> = 
  | `${B}__${E[number]}`
  | `${B}--${M[number]}`
  | `${B}__${E[number]}--${M[number]}`;

type ButtonClass = BEM<"button", ["icon", "text"], ["primary", "secondary"]>;
// Результат: 
// "button__icon" | "button__text" | 
// "button--primary" | "button--secondary" |
// "button__icon--primary" | "button__icon--secondary" |
// "button__text--primary" | "button__text--secondary"
```

## Рекурсивная обработка строк

Шаблонные литеральные типы могут использоваться в рекурсивных типах для обработки строк:

```ts
// Удаление пробелов из строки
type RemoveSpaces<S extends string> = 
  S extends `${infer T} ${infer U}` 
    ? RemoveSpaces<`${T}${U}`> 
    : S;

type CleanString = RemoveSpaces<"hello world test">;  // "helloworldtest"
```

### Разделение строки

```ts
type Split<S extends string, D extends string> = 
  S extends `${infer T}${D}${infer U}` 
    ? [T, ...Split<U, D>] 
    : [S];

type Parts = Split<"hello.world.foo", ".">;  // ["hello", "world", "foo"]
```

### Преобразование из camelCase в snake_case

```ts
type CamelToSnake<T extends string> = 
  T extends `${infer First}${infer Rest}`
    ? Rest extends Capitalize<Rest>
      ? `${Lowercase<First>}_${CamelToSnake<Rest>}`
      : `${Lowercase<First>}${CamelToSnake<Rest>}`
    : T;

type SnakeCase = CamelToSnake<"firstName">;  // "first_name"
type SnakeCase2 = CamelToSnake<"URLPath">;   // "url_path" (упрощенная версия)
```

## Продвинутые примеры

### 1. Создание типов для API путей

```ts
type RoutePath<T extends string> = 
  T extends `${infer Prefix}/${infer Suffix}`
    ? `${Capitalize<Prefix>}/${RoutePath<Suffix>}`
    : Capitalize<T>;

type CapitalizedPath = RoutePath<"api/users/profile">;  // "Api/Users/Profile"
```

### 2. Построение типов для CSS-in-JS

```ts
type CSSProperties = {
  backgroundColor: string;
  fontSize: number;
  margin: string;
};

type PrefixedCSS<T extends Record<string, any>, Prefix extends string> = {
  [K in keyof T as `${Prefix}${Capitalize<string & K>}`]: T[K];
};

type StyledCSS = PrefixedCSS<CSSProperties, "custom">;
// Результат: { customBackgroundColor: string; customFontSize: number; customMargin: string; }
```

### 3. Создание типов для событий с префиксами

```ts
type CreateEventTypes<Events extends string[], Prefix extends string = ""> = {
  [K in Events[number] as `${Prefix}${K}`]: (data: any) => void;
};

type UserEvents = CreateEventTypes<["login", "logout", "register"], "user/">;
// Результат: { "user/login": (data: any) => void; "user/logout": (data: any) => void; "user/register": (data: any) => void; }
```

## Практические применения

### 1. Создание типов для Redux actions

```ts
type ActionCreator<T extends string, P = void> = P extends void
  ? { type: T }
  : { type: T; payload: P };

type CreateActionType<Domain extends string, Action extends string> = 
  `${Domain}/${Action}`;

type UserLoginAction = CreateActionType<"user", "LOGIN">;  // "user/LOGIN"
type UserLogoutAction = CreateActionType<"user", "LOGOUT">; // "user/LOGOUT"

type ActionMap = {
  [K in UserLoginAction | UserLogoutAction]: ActionCreator<K>;
};
```

### 2. Типы для i18n (интернационализации)

```ts
type I18nKey<T extends string> = 
  T extends `${infer Namespace}:${infer Key}`
    ? { namespace: Namespace; key: Key }
    : { namespace: "common"; key: T };

type Translation = I18nKey<"user:profile.name">;  // { namespace: "user"; key: "profile.name" }
type DefaultTranslation = I18nKey<"welcome">;     // { namespace: "common"; key: "welcome" }
```

### 3. Создание типов для конфигурации

```ts
type ConfigKey<Section extends string, Key extends string> = 
  `${Section}.${Key}`;

type DatabaseConfig = {
  [K in ConfigKey<"database", "host" | "port" | "name">]: string;
};
// Результат: { "database.host": string; "database.port": string; "database.name": string; }
```

## Ограничения и особенности

### 1. Производительность

Сложные шаблонные литеральные типы могут значительно замедлить компиляцию:

```ts
// Это может быть медленным при сложных рекурсивных операциях
type ComplexStringOp<S extends string> = 
  S extends `${infer A}${infer B}${infer C}${infer D}${infer E}`
    ? ComplexStringOp<`${A}${C}${E}`>
    : S;
```

### 2. Ограничения рекурсии

TypeScript имеет ограничения на глубину рекурсии для типов, что может повлиять на сложные операции со строками.

### 3. Совместимость

Шаблонные литеральные типы требуют TypeScript 4.1 или выше.

## Связанные концепции

- [[Сопоставляющие-типы]] - часто используются вместе с шаблонными литералами
- [[Условные-типы]] - основа для условных строковых преобразований
- [[Infer]] - используется для извлечения частей строк
- [[Generic Types]] - необходимы для параметризованных строковых типов
- [[Union Types]] - важны для работы с объединениями строковых литералов

## Заключение

Шаблонные литеральные типы открывают новые возможности для работы со строковыми типами в TypeScript. Они позволяют создавать сложные строковые преобразования на этапе компиляции, что делает код более безопасным и выразительным. Эти типы особенно полезны при создании типобезопасных API, систем стилизации и других сценариев, где важна точная работа со строковыми значениями.