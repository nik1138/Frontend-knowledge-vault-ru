---
aliases: ["Recursive Types", "Рекурсивные типы", "Recursive Data Structures"]
tags: [typescript, advanced-types, recursive-types, data-structures]
---

# Рекурсивные типы (Recursive Types)

Рекурсивные типы - это типы, которые ссылаются на самих себя в своей декларации. Они позволяют создавать сложные структуры данных, такие как деревья, списки и вложенные объекты, с полной типобезопасностью. Рекурсивные типы особенно полезны для представления иерархических данных и структур с неопределенной глубиной вложенности.

## Основы рекурсивных типов

Простейший пример рекурсивного типа - односвязный список:

```ts
type List<T> = 
  | { value: T; next: List<T> }
  | null;

const list: List<number> = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: null
    }
  }
};
```

## Деревья как рекурсивные типы

Деревья - классический пример рекурсивных структур данных:

```ts
type Tree<T> = {
  value: T;
  children: Tree<T>[];
};

const tree: Tree<string> = {
  value: "root",
  children: [
    {
      value: "child1",
      children: [
        { value: "grandchild1", children: [] },
        { value: "grandchild2", children: [] }
      ]
    },
    {
      value: "child2",
      children: []
    }
  ]
};
```

## Вложенные объекты

Рекурсивные типы также полезны для описания вложенных объектов с неограниченной глубиной:

```ts
type NestedObject<T> = {
  [K: string]: T | NestedObject<T>;
};

const nested: NestedObject<string> = {
  level1: {
    level2: {
      level3: "deep value",
      another: "another deep value"
    },
    level2b: "not so deep"
  },
  topLevel: "top value"
};
```

## Рекурсивные типы с условной логикой

Можно создавать рекурсивные типы с условной логикой, например, для ограничения глубины:

```ts
type LimitedDepthTree<T, Depth extends number = 5> = 
  Depth extends 0
    ? T
    : {
        value: T;
        children: LimitedDepthTree<T, Prev<Depth>>[];
      };

// Вспомогательный тип для уменьшения числа
type Prev<T extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10][T];

// Теперь дерево может иметь глубину не более 3 уровней
type ShallowTree<T> = LimitedDepthTree<T, 3>;
```

## Рекурсивные сопоставляющие типы

Рекурсивные типы часто комбинируются с сопоставляющими типами для глубоких преобразований:

### DeepReadonly

```ts
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object 
    ? DeepReadonly<T[K]> 
    : T[K];
};

interface User {
  id: number;
  profile: {
    name: string;
    settings: {
      theme: string;
      notifications: boolean;
    };
  };
}

type ReadonlyUser = DeepReadonly<User>;
// Все вложенные объекты становятся readonly
```

### DeepPartial

```ts
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object 
    ? DeepPartial<T[K]> 
    : T[K];
};

type PartialUser = DeepPartial<User>;
// Все свойства становятся необязательными, включая вложенные
```

### DeepMutable

```ts
type DeepMutable<T> = {
  -readonly [K in keyof T]: T[K] extends (infer U)[] 
    ? U extends object 
      ? DeepMutable<U>[] 
      : U[]
    : T[K] extends object 
      ? DeepMutable<T[K]> 
      : T[K];
};
```

## Рекурсивные условные типы

Рекурсивные условные типы позволяют выполнять сложные преобразования на основе структуры типов:

```ts
type DeepPromisify<T> = T extends Promise<infer U>
  ? U extends object
    ? { [K in keyof U]: DeepPromisify<U[K]> }
    : U
  : T extends object
    ? { [K in keyof T]: DeepPromisify<T[K]> }
    : Promise<T>;

type Result = DeepPromisify<{ 
  user: { name: string; age: number }; 
  posts: string[] 
}>;
// Результат: { user: Promise<{ name: string; age: number }>; posts: Promise<string[]> }
```

## Практические примеры

### 1. JSON-подобные структуры

```ts
type JsonValue = 
  | string 
  | number 
  | boolean 
  | null 
  | JsonObject 
  | JsonArray;

interface JsonObject {
  [key: string]: JsonValue;
}

interface JsonArray extends Array<JsonValue> {}

const data: JsonValue = {
  users: [
    { id: 1, name: "Alice", active: true },
    { id: 2, name: "Bob", active: false }
  ],
  config: {
    theme: "dark",
    language: "en"
  }
};
```

### 2. Типы для конфигурации с валидацией

```ts
type ConfigNode<T> = {
  value: T;
  defaultValue: T;
  description?: string;
  children?: { [K: string]: ConfigNode<any> };
};

const appConfig: ConfigNode<any> = {
  value: "production",
  defaultValue: "development",
  description: "Application environment",
  children: {
    database: {
      value: "postgres://localhost:5432/mydb",
      defaultValue: "sqlite://local.db",
      description: "Database connection string"
    },
    features: {
      value: { analytics: true, notifications: false },
      defaultValue: { analytics: false, notifications: true },
      description: "Feature flags"
    }
  }
};
```

### 3. Рекурсивные типы для DOM-подобных структур

```ts
type ElementNode = {
  type: string;
  props: { [key: string]: any };
  children: Node[];
};

type TextNode = {
  type: '#text';
  content: string;
};

type Node = ElementNode | TextNode;

const element: Node = {
  type: 'div',
  props: { className: 'container' },
  children: [
    {
      type: 'h1',
      props: {},
      children: [{ type: '#text', content: 'Hello World' }]
    },
    {
      type: 'p',
      props: { id: 'description' },
      children: [{ type: '#text', content: 'This is a paragraph' }]
    }
  ]
};
```

## Рекурсивные типы для работы с путями

```ts
type PathImpl<T, Key extends string | number> = 
  Key extends keyof T
    ? `${Key}` | (T[Key] extends object ? `${Key}.${PathImpl<T[Key], keyof T[Key]>}` : never)
    : never;

type Path<T> = PathImpl<T, keyof T>;

interface User {
  id: number;
  profile: {
    name: string;
    contact: {
      email: string;
      phone: string;
    };
  };
}

type UserPaths = Path<User>;
// "id" | "profile" | "profile.name" | "profile.contact" | "profile.contact.email" | "profile.contact.phone"
```

## Оптимизация рекурсивных типов

### Избегание бесконечной рекурсии

```ts
// Опасный тип - может привести к проблемам с компиляцией
type DangerousCircular = {
  parent?: DangerousCircular;
  children: DangerousCircular[];
};

// Более безопасный подход с ограничением
type SafeCircular<T, Depth extends number = 5> = 
  Depth extends 0
    ? T
    : {
        parent?: SafeCircular<T, Prev<Depth>>;
        children: SafeCircular<T, Prev<Depth>>[];
      };
```

### Использование интерфейсов для рекурсивных типов

Иногда интерфейсы работают лучше, чем типы, для рекурсивных структур:

```ts
// С использованием интерфейса
interface Category {
  name: string;
  subcategories: Category[];
  products: Product[];
}

interface Product {
  id: number;
  name: string;
  category: Category;
}
```

## Практические применения

### 1. Типы для GraphQL-подобных запросов

```ts
type QuerySelection<T> = {
  [K in keyof T]?: T[K] extends object 
    ? boolean | QuerySelection<T[K]> 
    : boolean;
};

interface User {
  id: number;
  name: string;
  posts: Post[];
  profile: Profile;
}

interface Post {
  id: number;
  title: string;
  author: User;
}

interface Profile {
  bio: string;
  avatar: string;
}

const userQuery: QuerySelection<User> = {
  id: true,
  name: true,
  posts: {
    id: true,
    title: true,
    author: {
      name: true
    }
  },
  profile: {
    bio: true
  }
};
```

### 2. Типы для валидации форм

```ts
type ValidationRule<T> = {
  required?: boolean;
  validator?: (value: T) => boolean;
  message?: string;
  children?: { [K in keyof T]: ValidationRule<T[K]> };
};

type FormValidation<T> = {
  [K in keyof T]: ValidationRule<T[K]>;
};

interface UserForm {
  email: string;
  password: string;
  profile: {
    firstName: string;
    lastName: string;
  };
}

const userFormValidation: FormValidation<UserForm> = {
  email: {
    required: true,
    validator: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    message: "Invalid email format"
  },
  password: {
    required: true,
    validator: (value) => value.length >= 8,
    message: "Password must be at least 8 characters"
  },
  profile: {
    firstName: { required: true },
    lastName: { required: true }
  }
};
```

## Ограничения и особенности

### 1. Производительность компиляции

Сложные рекурсивные типы могут значительно замедлить компиляцию TypeScript. Всегда стоит оценивать баланс между типобезопасностью и производительностью.

### 2. Ограничения на глубину рекурсии

TypeScript имеет ограничения на глубину рекурсивных типов. Слишком глубокая рекурсия может привести к ошибкам компиляции.

### 3. Сложность отладки

Рекурсивные типы могут быть сложны для понимания и отладки, особенно при ошибках типизации.

## Связанные концепции

- [[Сопоставляющие-типы]] - часто используются вместе с рекурсивными типами
- [[Условные-типы]] - основа для рекурсивных условных преобразований
- [[Infer]] - может использоваться в рекурсивных типах
- [[Template Literal Types]] - могут быть рекурсивными
- [[Generic Types]] - необходимы для параметризованных рекурсивных типов

## Заключение

Рекурсивные типы - мощный инструмент для создания сложных, иерархических структур данных с полной типобезопасностью в TypeScript. Они позволяют точно описывать вложенные структуры, деревья и другие рекурсивные данные, обеспечивая безопасность типов на этапе компиляции. Понимание и умелое использование рекурсивных типов значительно повышает качество и надежность TypeScript-кода.