---
aliases: ["Conditional Types", "Условные типы"]
tags: [typescript, advanced-types, conditional-types]
---

# Условные типы (Conditional Types)

Условные типы - это мощная функция TypeScript, позволяющая создавать типы, которые выбирают один из двух возможных типов в зависимости от условия. Они работают аналогично тернарным операторам JavaScript, но на уровне типов.

## Основы условных типов

Синтаксис условного типа:

```ts
T extends U ? X : Y
```

Это означает: если тип `T` совместим с типом `U`, то результирующий тип будет `X`, иначе - `Y`.

### Простой пример

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<string>;    // true
type B = IsString<number>;    // false
type C = IsString<any>;       // true (any совместим с любым типом)
```

## Распределительные условные типы

Когда условный тип применяется к обобщенному типу, и этот тип является объединением (union), условие применяется к каждому члену объединения отдельно.

```ts
type ToArray<T> = T extends any ? T[] : never;

type A = ToArray<string | number>;  // string[] | number[]
// Это эквивалентно: ToArray<string> | ToArray<number>
```

## Извлечение типов с помощью infer

Условные типы часто используют ключевое слово `infer` для извлечения типов из сложных структур.

```ts
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { name: "Alice", age: 30 };
}

type User = GetReturnType<typeof getUser>;  // { name: string; age: number; }
```

### Извлечение аргументов функции

```ts
type GetFirstArg<T> = T extends (arg: infer U, ...args: any[]) => any ? U : never;

function greet(name: string, age: number) {
  return `Hello, ${name}! You are ${age} years old.`;
}

type FirstName = GetFirstArg<typeof greet>;  // string
```

## Встроенные утилиты на основе условных типов

### Exclude<T, U>

Исключает из типа `T` все типы, которые присутствуют в `U`:

```ts
type T0 = Exclude<"a" | "b" | "c", "a" | "c">;  // "b"
type T1 = Exclude<string | number | (() => void), Function>;  // string | number
```

### Extract<T, U>

Извлекает из типа `T` только те типы, которые присутствуют в `U`:

```ts
type T0 = Extract<"a" | "b" | "c", "a" | "c">;  // "a" | "c"
type T1 = Extract<string | number | (() => void), Function>;  // () => void
```

### NonNullable<T>

Исключает `null` и `undefined` из типа:

```ts
type T0 = NonNullable<string | number | undefined>;  // string | number
type T1 = NonNullable<string[] | null | undefined>;  // string[]
```

### ReturnType<T>

Получает возвращаемый тип функции:

```ts
type T0 = ReturnType<() => string>;  // string
type T1 = ReturnType<(s: string) => void>;  // void
type T2 = ReturnType<<T>() => T>;  // {}
```

### InstanceType<T>

Получает тип экземпляра класса:

```ts
class C {
  x = 0;
  y = 0;
}

type T0 = InstanceType<typeof C>;  // C
type T1 = InstanceType<any>;  // any
```

## Продвинутые примеры

### Фильтрация свойств объекта по типу

```ts
type FilterByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

interface User {
  id: number;
  name: string;
  active: boolean;
  createdAt: Date;
}

type StringProperties = FilterByType<User, string>;  // { name: string }
type PrimitiveProperties = FilterByType<User, string | number | boolean>;  
// { id: number; name: string; active: boolean }
```

### Создание типа для функций с определённым возвращаемым значением

```ts
type FunctionsReturning<T, U> = {
  [K in keyof T]: T[K] extends (...args: any[]) => T ? U : T[K];
};

interface Api {
  getUser: () => { name: string; id: number };
  getPosts: () => Post[];
  updateProfile: (data: any) => boolean;
}

type ApiWithModifiedGetUser = FunctionsReturning<Api, string>;
// getUser будет возвращать string, остальные свойства без изменений
```

### Условное добавление свойств

```ts
type AddTimestamp<T, Add extends boolean> = 
  Add extends true 
    ? T & { createdAt: Date; updatedAt: Date } 
    : T;

interface User {
  name: string;
  email: string;
}

type UserWithTimestamps = AddTimestamp<User, true>;
// { name: string; email: string; createdAt: Date; updatedAt: Date; }

type UserWithoutTimestamps = AddTimestamp<User, false>;
// { name: string; email: string; }
```

## Практические применения

### 1. Асинхронные типы

```ts
type AsyncReturnType<T> = T extends (...args: any[]) => Promise<infer U>
  ? U
  : T extends (...args: any[]) => infer U
    ? U
    : any;

async function fetchUser() {
  return { id: 1, name: "John" };
}

type FetchedUser = AsyncReturnType<typeof fetchUser>;  // { id: number; name: string; }
```

### 2. Обработка коллекций

```ts
type ElementOf<T> = T extends (infer U)[] ? U : never;

type T1 = ElementOf<string[]>;        // string
type T2 = ElementOf<number[][]>;      // number[]
type T3 = ElementOf<[string, number]>; // string | number
```

### 3. Создание типов для валидации

```ts
type ValidateProperty<T, K extends keyof T> = 
  T[K] extends string 
    ? { [P in K]: T[P] } & { [P in K]: string }  // Убедиться, что это строка
    : T[K] extends number 
      ? { [P in K]: T[P] } & { [P in K]: number }  // Убедиться, что это число
      : { [P in K]: T[P] };  // Любой другой тип

interface User {
  name: string;
  age: number;
  active: boolean;
}

type ValidatedName = ValidateProperty<User, 'name'>;  // { name: string }
```

## Ограничения и особенности

1. **Отложенное вычисление** - условные типы вычисляются только при использовании
2. **Распределение** - работает только с обобщенными типами
3. **Ограничения рекурсии** - TypeScript может ограничивать глубину рекурсивных условных типов
4. **Сложность отладки** - сложные условные типы могут быть трудны для понимания

## Связанные концепции

- [[Infer]] - ключевое слово для извлечения типов
- [[Сопоставляющие-типы]] - часто используют условные типы для преобразований
- [[Template Literal Types]] - могут использоваться с условными типами
- [[Generic Types]] - основа для условных типов
- [[Union Types]] - важны для распределительных условных типов

## Заключение

Условные типы - это мощный инструмент для создания гибких и интеллектуальных типов в TypeScript. Они позволяют создавать типы, которые адаптируются к различным условиям, что делает код более безопасным и выразительным. Понимание условных типов открывает путь к созданию сложных типовых систем и утилит.