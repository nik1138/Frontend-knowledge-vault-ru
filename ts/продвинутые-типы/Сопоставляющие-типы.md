---
aliases: ["Mapped Types", "Сопоставляющие типы"]
tags: [typescript, advanced-types, mapped-types]
---

# Сопоставляющие типы (Mapped Types)

Сопоставляющие типы (Mapped Types) - это мощная функция TypeScript, позволяющая создавать новые типы на основе существующих путем сопоставления свойств. Они позволяют изменять типы, добавлять модификаторы доступа, изменять ключи или значения, и создавать производные типы динамически.

## Основы сопоставляющих типов

Сопоставляющий тип создается с помощью синтаксиса, похожего на индексный тип, но с использованием `in` для перебора ключей:

```ts
type MappedType = {
  [Property in keyof ObjectType]: TypeTransform;
}
```

### Примеры базовых сопоставляющих типов

```ts
// Создание типа с теми же свойствами, но с типом string
type Stringify<T> = {
  [P in keyof T]: string;
};

interface Person {
  name: string;
  age: number;
}

type StringPerson = Stringify<Person>;
// Результат: { name: string; age: string; }
```

## Модификаторы доступа

Сопоставляющие типы поддерживают модификаторы `readonly` и `?` для изменения изменяемости и необязательности свойств.

### Добавление readonly

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

### Добавление необязательности

```ts
type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

### Удаление readonly и необязательности

TypeScript предоставляет встроенные утилиты для удаления модификаторов:

```ts
type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};
```

## Встроенные утилиты

TypeScript включает несколько встроенных утилит на основе сопоставляющих типов:

- [[Partial]] - делает все свойства необязательными
- [[Required]] - делает все свойства обязательными
- [[Readonly]] - делает все свойства только для чтения
- [[Pick]] - выбирает подмножество свойств из типа
- [[Omit]] - исключает указанные свойства из типа

### Реализация встроенных утилит

```ts
// Partial<T>
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// Required<T>
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// Readonly<T>
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// Pick<T, K>
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// Omit<T, K>
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

## Продвинутые примеры

### Преобразование ключей

```ts
// Преобразование ключей в camelCase
type Camelize<T> = {
  [K in keyof T as CamelizeKey<K>]: T[K]
};

type CamelizeKey<T extends string> = T extends `${infer First}_${infer Rest}`
  ? `${First}${Capitalize<CamelizeKey<Rest>>}`
  : T;

interface SnakeCaseUser {
  first_name: string;
  last_name: string;
  age_in_years: number;
}

type CamelCaseUser = Camelize<SnakeCaseUser>;
// Результат: { firstName: string; lastName: string; ageInYears: number; }
```

### Условное преобразование значений

```ts
// Преобразование числовых свойств в строковые
type NumericToString<T> = {
  [K in keyof T]: T[K] extends number ? string : T[K];
};

interface Config {
  port: number;
  host: string;
  debug: boolean;
}

type StringifiedConfig = NumericToString<Config>;
// Результат: { port: string; host: string; debug: boolean; }
```

## Практические применения

### 1. API Response Transformation

```ts
interface ApiResponse {
  user_id: number;
  user_name: string;
  created_at: string;
}

// Преобразование в клиентский тип
type ClientUser = {
  [K in keyof ApiResponse as TransformKey<K>]: ApiResponse[K]
};

type TransformKey<T extends string> = 
  T extends `user_${infer Rest}` ? 
    `${Capitalize<Rest>}` : 
    T extends `created_at` ? 
      'createdAt' : 
      T;

// Результат: { Id: number; Name: string; createdAt: string; }
```

### 2. Создание типов для форм

```ts
interface UserForm {
  email: string;
  password: string;
  confirmPassword: string;
}

// Тип для данных формы с сообщениями об ошибках
type FormErrors<T> = {
  [K in keyof T]?: string;
};

type UserFormErrors = FormErrors<UserForm>;
// Результат: { email?: string; password?: string; confirmPassword?: string; }
```

## Ограничения и особенности

1. **Типы не могут быть изменены во время выполнения** - сопоставляющие типы работают только на этапе компиляции
2. **Ограничения на рекурсию** - TypeScript может ограничивать глубину рекурсивных сопоставляющих типов
3. **Производительность** - сложные сопоставляющие типы могут замедлить компиляцию

## Связанные концепции

- [[Условные-типы]] - используются для условных преобразований
- [[Infer]] - позволяет извлекать типы из сложных структур
- [[Template Literal Types]] - позволяют манипулировать строковыми литералами
- [[Keyof]] - оператор для получения ключей типа
- [[Generic Types]] - обобщенные типы, используемые в сопоставляющих типах

## Заключение

Сопоставляющие типы - это мощный инструмент для создания гибких и переиспользуемых типов в TypeScript. Они позволяют создавать сложные преобразования типов, что делает код более безопасным и выразительным. Понимание и умелое использование сопоставляющих типов значительно повышает качество TypeScript-кода.