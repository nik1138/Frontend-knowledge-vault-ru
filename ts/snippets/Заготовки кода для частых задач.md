---
tags: [typescript, frontend, snippets, templates, utilities]
aliases: [Заготовки кода TypeScript, Универсальные типы TypeScript]
---

# Заготовки кода для частых задач

## Введение

В этом разделе собраны полезные заготовки кода для частых задач, с которыми сталкиваются разработчики при работе с TypeScript. Эти шаблоны можно использовать как основу для решения типичных проблем и ускорения разработки.

## Универсальные типы и утилиты

### Основные утилиты типов

```ts
// DeepPartial - делает все свойства опциональными рекурсивно
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepPartial<T[P]> 
    : T[P]
};

// Пример использования
interface User {
  id: number;
  name: string;
  address: {
    street: string;
    city: string;
    coordinates: {
      lat: number;
      lng: number;
    };
  };
}

type PartialUser = DeepPartial<User>;
// { id?: number; name?: string; address?: { street?: string; city?: string; coordinates?: { lat?: number; lng?: number; }; }; }

// DeepReadonly - делает все свойства readonly рекурсивно
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepReadonly<T[P]> 
    : T[P]
};

// RequiredBy - делает определенные поля обязательными
type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

// OptionalBy - делает определенные поля опциональными
type OptionalBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// NonNullableBy - удаляет null и undefined из определенных полей
type NonNullableBy<T, K extends keyof T> = {
  [P in K]: NonNullable<T[P]>
} & Omit<T, K>;

// PickByType - выбирает свойства по типу
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

// Merge - объединяет два типа, приоритет у второго
type Merge<T, U> = Omit<T, keyof U> & U;

// ValueOf - извлекает тип значений объекта
type ValueOf<T> = T[keyof T];

// ArrayElement - извлекает тип элемента массива
type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;

// Awaited - извлекает тип из Promise (встроенный в TypeScript 4.5+)
type Awaited<T> = T extends Promise<infer U> ? U : T;

// Mutable - делает все свойства изменяемыми
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
};

// Concrete - убирает null, undefined и void
type Concrete<T> = {
  [P in keyof T]: NonNullable<T[P]>
};
```

### Утилиты для работы с функциями

```ts
// Типизация для функций с кэшированием
type CacheFunction<T extends (...args: any[]) => any> = T & {
  clearCache: () => void;
};

function createCachedFunction<T extends (...args: any[]) => any>(
  fn: T,
  keyFn: (...args: Parameters<T>) => string = (...args) => JSON.stringify(args)
): CacheFunction<T> {
  const cache = new Map<string, ReturnType<T>>();
  
  const cachedFn = ((...args: Parameters<T>): ReturnType<T> => {
    const key = keyFn(...args);
    if (cache.has(key)) {
      return cache.get(key)!;
    }
    
    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as CacheFunction<T>;
  
  cachedFn.clearCache = () => cache.clear();
  
  return cachedFn;
}

// Пример использования
const expensiveCalculation = (a: number, b: number) => {
  // Сложные вычисления...
  return a * b + Math.random();
};

const cachedCalculation = createCachedFunction(expensiveCalculation);
const result1 = cachedCalculation(2, 3); // Вычисление произойдет
const result2 = cachedCalculation(2, 3); // Результат из кэша

// Типизация для debounce функции
type DebouncedFunction<T extends (...args: any[]) => any> = T & {
  cancel: () => void;
  flush: () => ReturnType<T>;
};

function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): DebouncedFunction<T> {
  let timeout: any;
  
  const debounced = function(this: any, ...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func.apply(this, args);
    };
    
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  } as DebouncedFunction<T>;
  
  debounced.cancel = () => {
    clearTimeout(timeout);
    timeout = null;
  };
  
  debounced.flush = () => {
    if (timeout) {
      clearTimeout(timeout);
      const result = func.apply(this, arguments as any as Parameters<T>);
      timeout = null;
      return result;
    }
  };
  
  return debounced;
}
```

## Шаблоны для React компонентов

### Базовые шаблоны компонентов

```tsx
import React, { useState, useEffect } from 'react';

// Шаблон для компонента с состоянием
interface ExampleComponentProps {
  initialCount?: number;
  label?: string;
}

const ExampleComponent: React.FC<ExampleComponentProps> = ({ 
  initialCount = 0, 
  label = 'Counter' 
}) => {
  const [count, setCount] = useState<number>(initialCount);
  
  return (
    <div>
      <p>{label}: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
};

// Шаблон для компонента с асинхронной загрузкой
interface AsyncComponentProps {
  userId: number;
}

interface UserData {
  id: number;
  name: string;
  email: string;
}

const AsyncComponent: React.FC<AsyncComponentProps> = ({ userId }) => {
  const [data, setData] = useState<UserData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) throw new Error('Failed to fetch');
        const userData: UserData = await response.json();
        setData(userData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No data</div>;
  
  return (
    <div>
      <h3>{data.name}</h3>
      <p>{data.email}</p>
    </div>
  );
};

// Шаблон для компонента с формой
interface FormComponentProps {
  onSubmit: (data: FormData) => void;
}

interface FormData {
  name: string;
  email: string;
  message: string;
}

const FormComponent: React.FC<FormComponentProps> = ({ onSubmit }) => {
  const [formData, setFormData] = useState<FormData>({
    name: '',
    email: '',
    message: ''
  });
  
  const [errors, setErrors] = useState<Partial<FormData>>({});
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Очистка ошибки при изменении поля
    if (errors[name as keyof FormData]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  };
  
  const validate = (): boolean => {
    const newErrors: Partial<FormData> = {};
    
    if (!formData.name.trim()) newErrors.name = 'Name is required';
    if (!formData.email.trim()) newErrors.email = 'Email is required';
    if (!/\S+@\S+\.\S+/.test(formData.email)) newErrors.email = 'Email is invalid';
    if (!formData.message.trim()) newErrors.message = 'Message is required';
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (validate()) {
      onSubmit(formData);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Name"
        />
        {errors.name && <span>{errors.name}</span>}
      </div>
      
      <div>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Email"
        />
        {errors.email && <span>{errors.email}</span>}
      </div>
      
      <div>
        <textarea
          name="message"
          value={formData.message}
          onChange={handleChange}
          placeholder="Message"
        />
        {errors.message && <span>{errors.message}</span>}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
};
```

### Кастомные хуки

```tsx
import { useState, useEffect, useRef, useCallback } from 'react';

// Хук для управления формой
interface UseFormReturn<T> {
  values: T;
  errors: Partial<T>;
  handleChange: (name: keyof T, value: any) => void;
  handleSubmit: (onSubmit: (values: T) => void) => void;
  setFieldValue: (name: keyof T, value: any) => void;
  setFieldError: (name: keyof T, error: string | undefined) => void;
}

function useForm<T>(initialValues: T): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<T>>({});

  const handleChange = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Очистка ошибки при изменении поля
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  }, [errors]);

  const setFieldValue = useCallback((name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);

  const setFieldError = useCallback((name: keyof T, error: string | undefined) => {
    setErrors(prev => ({ ...prev, [name]: error }));
  }, []);

  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {
    onSubmit(values);
  }, [values]);

  return {
    values,
    errors,
    handleChange,
    handleSubmit,
    setFieldValue,
    setFieldError
  };
}

// Хук для работы с localStorage
function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = useCallback((value: T) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  }, [key]);

  return [storedValue, setValue];
}

// Хук для дебаунса
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Хук для асинхронных операций
interface UseAsyncReturn<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  execute: () => Promise<void>;
}

function useAsync<T>(asyncFunction: () => Promise<T>): UseAsyncReturn<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await asyncFunction();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [asyncFunction]);

  return { data, loading, error, execute };
}
```

## Шаблоны для API клиентов

### Базовый API клиент

```ts
// Типы для API
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface ApiError {
  message: string;
  status: number;
  code?: string;
}

// Базовый API клиент
class ApiClient {
  private baseUrl: string;
  private defaultHeaders: HeadersInit;
  private timeout: number;

  constructor(config: {
    baseUrl: string;
    defaultHeaders?: HeadersInit;
    timeout?: number;
  }) {
    this.baseUrl = config.baseUrl;
    this.defaultHeaders = config.defaultHeaders || {};
    this.timeout = config.timeout || 10000;
  }

  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    
    const config: RequestInit = {
      headers: {
        'Content-Type': 'application/json',
        ...this.defaultHeaders,
        ...options.headers,
      },
      ...options,
    };

    // Реализация таймаута
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    
    try {
      const response = await fetch(url, {
        ...config,
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new Error('Network error: Please check your connection');
      }
      
      throw error;
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T, D = any>(endpoint: string, data: D): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put<T, D = any>(endpoint: string, data: D): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}

// Использование
const apiClient = new ApiClient({
  baseUrl: process.env.API_BASE_URL || 'https://api.example.com',
  defaultHeaders: {
    'Authorization': `Bearer ${localStorage.getItem('token')}`,
  },
  timeout: 5000,
});

// Сервисы для конкретных сущностей
interface User {
  id: number;
  name: string;
  email: string;
}

const userService = {
  getAll: () => apiClient.get<User[]>('/users'),
  getById: (id: number) => apiClient.get<User>(`/users/${id}`),
  create: (user: Omit<User, 'id'>) => apiClient.post<User, Omit<User, 'id'>>('/users', user),
  update: (id: number, user: Partial<User>) => apiClient.put<User, Partial<User>>(`/users/${id}`, user),
  delete: (id: number) => apiClient.delete<User>(`/users/${id}`),
};
```

### Типизированный Redux Toolkit шаблон

```ts
// store/userSlice.ts
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { User } from '../types';

// Async thunk для получения пользователей
export const fetchUsers = createAsyncThunk<User[], void, { rejectValue: string }>(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users');
      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(
        error instanceof Error ? error.message : 'Failed to fetch users'
      );
    }
  }
);

// Тип состояния
interface UserState {
  users: User[];
  loading: 'idle' | 'pending' | 'succeeded' | 'failed';
  error: string | null;
  currentUserId: number | null;
}

// Начальное состояние
const initialState: UserState = {
  users: [],
  loading: 'idle',
  error: null,
  currentUserId: null,
};

// Слайс
const userSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    setCurrentUser: (state, action: PayloadAction<number | null>) => {
      state.currentUserId = action.payload;
    },
    addUser: (state, action: PayloadAction<User>) => {
      state.users.push(action.payload);
    },
    updateUser: (state, action: PayloadAction<User>) => {
      const index = state.users.findIndex(user => user.id === action.payload.id);
      if (index !== -1) {
        state.users[index] = action.payload;
      }
    },
    deleteUser: (state, action: PayloadAction<number>) => {
      state.users = state.users.filter(user => user.id !== action.payload);
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = 'pending';
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = 'succeeded';
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = 'failed';
        state.error = action.payload || 'Failed to fetch users';
      });
  },
});

export const { setCurrentUser, addUser, updateUser, deleteUser } = userSlice.actions;
export default userSlice.reducer;
```

## Шаблоны для валидации

### Система валидации форм

```ts
// Типы для валидации
interface ValidationRule<T> {
  condition: (value: T) => boolean;
  message: string;
}

interface ValidationResult<T> {
  value: T;
  isValid: boolean;
  errors: string[];
}

// Базовый валидатор
class Validator<T> {
  private rules: ValidationRule<T>[] = [];

  addRule(condition: (value: T) => boolean, message: string): Validator<T> {
    this.rules.push({ condition, message });
    return this;
  }

  validate(value: T): ValidationResult<T> {
    const errors: string[] = [];

    for (const rule of this.rules) {
      if (!rule.condition(value)) {
        errors.push(rule.message);
      }
    }

    return {
      value,
      isValid: errors.length === 0,
      errors,
    };
  }
}

// Пример использования
const emailValidator = new Validator<string>()
  .addRule(value => value.length > 0, 'Email is required')
  .addRule(value => /\S+@\S+\.\S+/.test(value), 'Email is invalid');

const result = emailValidator.validate('test@example.com');
// { value: 'test@example.com', isValid: true, errors: [] }

// Валидация объекта
interface UserFormData {
  name: string;
  email: string;
  age: number;
}

interface FormErrors {
  name?: string;
  email?: string;
  age?: string;
}

class FormValidator<T> {
  private validators: { [K in keyof T]?: Validator<T[K]> } = {};

  addFieldValidator<K extends keyof T>(field: K, validator: Validator<T[K]>): FormValidator<T> {
    this.validators[field] = validator;
    return this;
  }

  validate(data: T): { values: T; errors: Partial<T> } {
    const errors: Partial<T> = {};

    for (const field in this.validators) {
      if (this.validators[field]) {
        const validator = this.validators[field]!;
        const result = validator.validate(data[field]);
        
        if (!result.isValid) {
          (errors as any)[field] = result.errors[0];
        }
      }
    }

    return {
      values: data,
      errors,
    };
  }
}

// Использование
const userFormValidator = new FormValidator<UserFormData>()
  .addFieldValidator('name', 
    new Validator<string>()
      .addRule(v => v.length >= 2, 'Name must be at least 2 characters')
  )
  .addFieldValidator('email', emailValidator)
  .addFieldValidator('age', 
    new Validator<number>()
      .addRule(v => v >= 18, 'Must be at least 18 years old')
  );

const formResult = userFormValidator.validate({
  name: 'John',
  email: 'john@example.com',
  age: 25
});
```

## Практические шаблоны

### Шаблоны для типизации событий

```ts
// Типизация для обработчиков событий в React
interface EventHandlers {
  // Для форм
  onChange: React.ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>;
  onClick: React.MouseEventHandler<HTMLElement>;
  onSubmit: React.FormEventHandler<HTMLFormElement>;
  onFocus: React.FocusEventHandler<HTMLElement>;
  onBlur: React.FocusEventHandler<HTMLElement>;
  
  // Для мыши
  onMouseEnter: React.MouseEventHandler<HTMLElement>;
  onMouseLeave: React.MouseEventHandler<HTMLElement>;
  
  // Для клавиатуры
  onKeyDown: React.KeyboardEventHandler<HTMLElement>;
  onKeyUp: React.KeyboardEventHandler<HTMLElement>;
}

// Универсальный обработчик изменения инпута
function createInputChangeHandler<T>(
  setter: React.Dispatch<React.SetStateAction<T>>
): React.ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement> {
  return (e) => {
    const { name, value, type, checked } = e.target;
    
    setter(prev => ({
      ...(prev as any),
      [name]: type === 'checkbox' ? checked : value
    }));
  };
}

// Использование
interface FormData {
  name: string;
  email: string;
  subscribe: boolean;
}

const [formData, setFormData] = useState<FormData>({ name: '', email: '', subscribe: false });
const handleInputChange = createInputChangeHandler<FormData>(setFormData);

// В шаблоне:
// <input name="name" value={formData.name} onChange={handleInputChange} />
// <input type="checkbox" name="subscribe" checked={formData.subscribe} onChange={handleInputChange} />
```

### Шаблоны для типизации асинхронных состояний

```ts
// Универсальный тип для асинхронного состояния
interface AsyncState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Хук для управления асинхронным состоянием
function useAsyncState<T>(asyncFn: () => Promise<T>): AsyncState<T> {
  const [state, setState] = useState<Omit<AsyncState<T>, 'refetch'>>({
    data: null,
    loading: true,
    error: null,
  });

  const refetch = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await asyncFn();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({ 
        data: null, 
        loading: false, 
        error: error instanceof Error ? error.message : 'An error occurred' 
      });
    }
  }, [asyncFn]);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return { ...state, refetch };
}

// Использование
const { data: users, loading, error, refetch } = useAsyncState<User[]>(() => 
  fetch('/api/users').then(r => r.json())
);
```

## Заключение

Эти заготовки кода помогут ускорить разработку и избежать типичных ошибок. Их можно адаптировать под конкретные нужды проекта и использовать как основу для создания более сложных решений.

> [!tip] Совет
> Создавайте библиотеку часто используемых шаблонов для вашего проекта - это значительно ускорит разработку.

> [!warning] Важно
> Не забывайте обновлять шаблоны при изменении требований или архитектуры приложения.

## Связанные темы

- [[Решения распространенных задач]]
- [[Утилиты типов TypeScript]]
- [[Практические примеры для frontend разработки]]