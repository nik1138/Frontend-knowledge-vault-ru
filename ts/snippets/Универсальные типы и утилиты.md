---
tags: [typescript, frontend, utilities, types, generics]
aliases: [Универсальные типы TypeScript, Утилиты TypeScript]
---

# Универсальные типы и утилиты

## Введение

Универсальные типы и утилиты являются основой типобезопасного программирования на TypeScript. В этом разделе мы рассмотрим широкий набор готовых решений, которые можно использовать в различных сценариях разработки.

## Основные утилиты типов

### Встроенные утилиты TypeScript

TypeScript предоставляет несколько встроенных утилитных типов:

```ts
// Partial<T> - делает все свойства T опциональными
interface User {
  id: number;
  name: string;
  email: string;
}

type OptionalUser = Partial<User>;
// { id?: number; name?: string; email?: string; }

// Required<T> - делает все свойства T обязательными
type RequiredProfile = Required<{ name?: string; email?: string }>;
// { name: string; email: string; }

// Readonly<T> - делает все свойства T readonly
type ReadonlyUser = Readonly<User>;
// { readonly id: number; readonly name: string; readonly email: string; }

// Pick<T, K> - выбирает свойства K из T
type UserPreview = Pick<User, 'id' | 'name'>;
// { id: number; name: string; }

// Omit<T, K> - исключает свойства K из T
type UserWithoutId = Omit<User, 'id'>;
// { name: string; email: string; }

// Record<K, T> - создает тип с ключами K и значениями T
type UserRoles = Record<User['id'], 'admin' | 'moderator' | 'user'>;

// Exclude<T, U> - исключает типы из T, которые могут быть присвоены U
type AvailableMethods = Exclude<'get' | 'post' | 'put' | 'delete', 'delete'>;
// 'get' | 'post' | 'put'

// Extract<T, U> - извлекает типы из T, которые могут быть присвоены U
type StringNumbers = Extract<'a' | 'b' | '1' | '2', string>;
// 'a' | 'b' | '1' | '2'

// NonNullable<T> - исключает null и undefined из T
type NonNullableString = NonNullable<string | null | undefined>;
// string

// Parameters<T> - получает типы параметров функции T
function updateUser(id: number, name: string, email: string): User {
  return { id, name, email };
}

type UpdateParams = Parameters<typeof updateUser>;
// [number, string, string]

// ConstructorParameters<T> - получает типы параметров конструктора
type DateParams = ConstructorParameters<typeof Date>;
// [] | [string | number | Date]

// ReturnType<T> - получает тип возвращаемого значения функции T
type UpdateReturnType = ReturnType<typeof updateUser>;
// User

// InstanceType<T> - получает тип экземпляра класса
class UserClass {
  constructor(public id: number, public name: string) {}
}

type UserInstance = InstanceType<typeof UserClass>;
// UserClass
```

## Продвинутые утилиты типов

### Глубокие утилиты

```ts
// DeepPartial<T> - рекурсивно делает все свойства опциональными
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepPartial<T[P]> 
    : T[P]
};

interface UserProfile {
  id: number;
  name: string;
  address: {
    street: string;
    city: string;
    coordinates: {
      lat: number;
      lng: number;
    };
  };
}

type PartialProfile = DeepPartial<UserProfile>;
// { id?: number; name?: string; address?: { street?: string; city?: string; coordinates?: { lat?: number; lng?: number; }; }; }

// DeepReadonly<T> - рекурсивно делает все свойства readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepReadonly<T[P]> 
    : T[P]
};

// DeepRequired<T> - рекурсивно делает все свойства обязательными
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepRequired<T[P]> 
    : T[P]
};

// Mutable<T> - убирает readonly из свойств
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
};

// Concrete<T> - убирает null, undefined и void
type Concrete<T> = {
  [P in keyof T]: NonNullable<T[P]>
};
```

### Утилиты для фильтрации и преобразования

```ts
// PickByType<T, U> - выбирает свойства T, которые являются U
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

interface ApiResponse {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
  isActive: boolean;
}

type StringProps = PickByType<ApiResponse, string>;
// { name: string; email: string; }

// OmitByType<T, U> - исключает свойства T, которые являются U
type OmitByType<T, U> = {
  [K in keyof T as T[K] extends U ? never : K]: T[K]
};

type NonStringProps = OmitByType<ApiResponse, string>;
// { id: number; createdAt: Date; isActive: boolean; }

// FilterKeys<T, U> - фильтрует ключи T, где значения являются U
type FilterKeys<T, U> = keyof PickByType<T, U>;

type StringKeys = FilterKeys<ApiResponse, string>;
// "name" | "email"

// UnionToIntersection<U> - преобразует объединение в пересечение
type UnionToIntersection<U> = 
  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;

type Union = { a: string } | { b: number } | { c: boolean };
type Intersection = UnionToIntersection<Union>;
// { a: string; } & { b: number; } & { c: boolean; }

// LastInUnion<U> - извлекает последний тип из объединения
type LastInUnion<U> = 
  UnionToIntersection<U extends any ? (x: U) => void : never> extends (x: infer L) => void ? L : never;

// UnionToTuple<U> - преобразует объединение в кортеж
type UnionToTuple<U, L = LastInUnion<U>> = 
  [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, L>>, L];

type Tuple = UnionToTuple<'a' | 'b' | 'c'>;
// ['a', 'b', 'c']
```

### Утилиты для работы с функциями

```ts
// Overwrite<T, U> - перезаписывает свойства T свойствами из U
type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;

// Diff<T, U> - находит различия между T и U
type Diff<T, U> = Pick<T, Exclude<keyof T, keyof U>>;

// Func<T, U> - тип для функции, принимающей T и возвращающей U
type Func<T, U> = (arg: T) => U;

// AsyncFunc<T, U> - тип для асинхронной функции
type AsyncFunc<T, U> = (arg: T) => Promise<U>;

// ConstructorType<T> - тип конструктора для T
type ConstructorType<T> = new (...args: any[]) => T;

// ParametersOfMethod<T, K> - типы параметров метода K в T
type ParametersOfMethod<T, K extends keyof T> = T[K] extends (...args: infer P) => any ? P : never;

// ReturnTypeOfMethod<T, K> - тип возврата метода K в T
type ReturnTypeOfMethod<T, K extends keyof T> = T[K] extends (...args: any[]) => infer R ? R : never;

// Пример использования
interface UserService {
  getUser(id: number): Promise<User>;
  updateUser(id: number, data: Partial<User>): Promise<User>;
  deleteUser(id: number): Promise<boolean>;
}

type GetUserParams = ParametersOfMethod<UserService, 'getUser'>;
// [number]

type UpdateUserReturn = ReturnTypeOfMethod<UserService, 'updateUser'>;
// Promise<User>
```

## Универсальные типы для конкретных задач

### Типы для работы с API

```ts
// Типы для ответов API
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
}

interface ErrorResponse {
  error: string;
  code: string;
  details?: Record<string, any>;
}

// Типы для запросов
interface ApiRequestConfig {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  headers?: Record<string, string>;
  body?: any;
}

// Тип для асинхронных состояний
interface AsyncState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Тип для состояния формы
interface FormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isSubmitting: boolean;
  isValid: boolean;
}
```

### Типы для работы с событиями

```ts
// Типы для событий в React
type EventHandler<T extends React.SyntheticEvent> = (event: T) => void;

type ClickHandler = EventHandler<React.MouseEvent>;
type ChangeHandler = EventHandler<React.ChangeEvent>;
type SubmitHandler = EventHandler<React.FormEvent>;

// Универсальный тип для обработчиков событий
interface EventHandlers<T> {
  onClick?: (event: React.MouseEvent<T>) => void;
  onChange?: (event: React.ChangeEvent<T>) => void;
  onFocus?: (event: React.FocusEvent<T>) => void;
  onBlur?: (event: React.FocusEvent<T>) => void;
  onKeyDown?: (event: React.KeyboardEvent<T>) => void;
  onKeyUp?: (event: React.KeyboardEvent<T>) => void;
}

// Тип для событий DOM
type DomEventHandlers<T extends HTMLElement> = {
  [K in keyof JSX.IntrinsicElements[T] as K extends `on${string}` ? K : never]?: JSX.IntrinsicElements[T][K];
};
```

### Типы для работы с коллекциями

```ts
// Типы для массивов
type Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never;
type Tail<T extends any[]> = ((...t: T) => void) extends ((h: any, ...rest: infer Rest) => void) ? Rest : never;
type Last<T extends any[]> = T extends [...any[], infer L] ? L : never;
type PreLast<T extends any[]> = T extends [...any[], infer P, any] ? P : never;

// Примеры использования
type H = Head<[string, number, boolean]>; // string
type R = Tail<[string, number, boolean]>; // [number, boolean]
type L = Last<[string, number, boolean]>; // boolean

// Тип для маппинга массива
type MapArray<T extends any[], F extends (item: any) => any> = 
  T extends [infer Head, ...infer Tail] 
    ? [F extends (item: infer I) => infer O ? O : never, ...MapArray<Tail, F>] 
    : [];

// Тип для фильтрации массива
type FilterArray<T extends any[], F extends (item: any) => boolean> = 
  T extends [infer Head, ...infer Tail] 
    ? F extends (item: Head) => infer R 
      ? R extends true 
        ? [Head, ...FilterArray<Tail, F>] 
        : FilterArray<Tail, F> 
      : FilterArray<Tail, F> 
    : [];

// Тип для работы с кортежами
type TupleToObject<T extends [string, any][]> = {
  [K in T[number] as K[0]]: K[1]
};

type ExampleTuple = ['name', string] | ['age', number] | ['active', boolean];
type ExampleObject = TupleToObject<ExampleTuple[]>;
// { name: string; age: number; active: boolean; }
```

## Практические примеры использования

### Создание типобезопасного билдера

```ts
// Типобезопасный билдер для объектов
class TypedBuilder<T> {
  private obj: Partial<T> = {};

  with<K extends keyof T>(key: K, value: T[K]): TypedBuilder<T> {
    this.obj[key] = value;
    return this;
  }

  build(): T {
    return this.obj as T;
  }
}

// Использование
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  active: boolean;
}

const user = new TypedBuilder<User>()
  .with('id', 1)
  .with('name', 'John')
  .with('email', 'john@example.com')
  .with('age', 30)
  .with('active', true)
  .build();
```

### Типобезопасная система плагинов

```ts
// Типобезопасная система плагинов
interface Plugin<T> {
  name: string;
  apply: (api: T) => void;
}

interface Api {
  registerComponent: (name: string, component: any) => void;
  registerRoute: (path: string, handler: any) => void;
  addMiddleware: (middleware: any) => void;
}

class PluginSystem {
  private plugins: Plugin<Api>[] = [];
  private api: Api;

  constructor(api: Api) {
    this.api = api;
  }

  use(plugin: Plugin<Api>): this {
    this.plugins.push(plugin);
    plugin.apply(this.api);
    return this;
  }

  initialize() {
    // Инициализация системы
  }
}

// Пример плагина
const loggingPlugin: Plugin<Api> = {
  name: 'logger',
  apply: (api) => {
    console.log('Logger plugin applied');
    // Расширение API
  }
};
```

### Типобезопасная система событий

```ts
// Типобезопасная система событий
type EventMap = {
  [key: string]: any[];
};

class TypedEventEmitter<T extends EventMap> {
  private events: { [K in keyof T]?: Array<(...args: T[K]) => void> } = {};

  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event]!.push(listener);
  }

  emit<K extends keyof T>(event: K, ...args: T[K]): void {
    const listeners = this.events[event];
    if (listeners) {
      listeners.forEach(listener => listener(...args));
    }
  }

  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    const listeners = this.events[event];
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }
}

// Использование
interface AppEvents {
  userLogin: [User];
  userLogout: [User];
  apiError: [Error, string];
}

const emitter = new TypedEventEmitter<AppEvents>();

emitter.on('userLogin', (user) => {
  console.log(`${user.name} logged in`);
});

emitter.on('apiError', (error, endpoint) => {
  console.error(`API error on ${endpoint}:`, error.message);
});

// emitter.emit('userLogin', { id: 1, name: 'John', email: 'john@example.com' });
// emitter.emit('apiError', new Error('Network error'), '/api/users');
```

### Универсальные хуки для React

```tsx
import { useState, useEffect, useRef, useCallback } from 'react';

// Универсальный хук для управления состоянием с валидацией
function useValidatedState<T>(
  initialValue: T,
  validator: (value: T) => boolean,
  errorMessage: string
) {
  const [value, setValue] = useState<T>(initialValue);
  const [error, setError] = useState<string>('');
  const [touched, setTouched] = useState<boolean>(false);

  const isValid = validator(value);
  
  useEffect(() => {
    if (touched && !isValid) {
      setError(errorMessage);
    } else {
      setError('');
    }
  }, [value, touched, isValid, errorMessage]);

  const handleChange = useCallback((newValue: T) => {
    setValue(newValue);
    if (touched) {
      // Проверяем валидацию при изменении, если поле уже было тронуто
      if (!validator(newValue)) {
        setError(errorMessage);
      } else {
        setError('');
      }
    }
  }, [errorMessage, touched]);

  const handleBlur = useCallback(() => {
    setTouched(true);
  }, []);

  return {
    value,
    error,
    isValid: !error,
    touched,
    handleChange,
    handleBlur,
    reset: () => {
      setValue(initialValue);
      setError('');
      setTouched(false);
    }
  };
}

// Использование
const emailValidator = (email: string) => /\S+@\S+\.\S+/.test(email);
const { value: email, error, handleChange: setEmail, isValid } = useValidatedState(
  '',
  emailValidator,
  'Please enter a valid email'
);
```

## Заключение

Универсальные типы и утилиты являются мощным инструментом для создания типобезопасного и переиспользуемого кода. Понимание и применение этих паттернов позволяет создавать более надежные и поддерживаемые приложения.

> [!tip] Совет
> Создавайте библиотеку часто используемых утилит для вашего проекта - это значительно ускорит разработку.

> [!warning] Важно
> Не переусложняйте типы - чрезмерное использование продвинутых паттернов может затруднить понимание кода.

## Связанные темы

- [[Продвинутые типы и метапрограммирование на типах]]
- [[Дженерики и условные типы]]
- [[Хитрости и лайфхаки TypeScript]]