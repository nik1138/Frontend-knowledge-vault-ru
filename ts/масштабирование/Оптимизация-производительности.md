---
aliases: [Оптимизация производительности, Производительность TypeScript]
tags: [typescript, performance, optimization, scalability, best-practices]
---

# Оптимизация производительности в TypeScript-приложениях

## Введение

Оптимизация производительности - это критический аспект разработки масштабируемых TypeScript-приложений. Эффективная оптимизация позволяет улучшить пользовательский опыт, снизить нагрузку на серверы и обеспечить стабильную работу приложений при увеличении нагрузки. В этой статье рассматриваются ключевые аспекты оптимизации производительности в TypeScript-приложениях.

## Анализ производительности

### 1. Измерение производительности

Перед оптимизацией важно уметь измерять производительность:

```typescript
// Утилита для измерения времени выполнения
class PerformanceTimer {
  private marks: Map<string, number> = new Map();

  start(label: string): void {
    this.marks.set(`${label}_start`, performance.now());
  }

  end(label: string): number {
    const start = this.marks.get(`${label}_start`);
    if (start === undefined) {
      throw new Error(`Timer "${label}" was not started`);
    }

    const duration = performance.now() - start;
    this.marks.set(`${label}_duration`, duration);
    
    // Очистка метки
    this.marks.delete(`${label}_start`);
    
    return duration;
  }

  getDuration(label: string): number | null {
    return this.marks.get(`${label}_duration`) || null;
  }

  static measure<T>(label: string, fn: () => T): T {
    const timer = new PerformanceTimer();
    timer.start(label);
    const result = fn();
    const duration = timer.end(label);
    
    console.log(`${label}: ${duration.toFixed(2)}ms`);
    return result;
  }
}

// Пример использования
const result = PerformanceTimer.measure('complexCalculation', () => {
  // Выполнение сложных вычислений
  return heavyComputation();
});
```

### 2. Профилирование производительности

```typescript
// Интерфейс для результатов профилирования
interface ProfileResult {
  name: string;
  duration: number;
  startTime: number;
  endTime: number;
  memoryBefore?: number;
  memoryAfter?: number;
}

class PerformanceProfiler {
  private results: ProfileResult[] = [];

  async profile<T>(
    name: string,
    fn: () => T | Promise<T>,
    includeMemory: boolean = false
  ): Promise<T> {
    const startTime = performance.now();
    const memoryBefore = includeMemory ? this.getMemoryUsage() : undefined;

    const result = await Promise.resolve(fn());

    const endTime = performance.now();
    const memoryAfter = includeMemory ? this.getMemoryUsage() : undefined;

    const profileResult: ProfileResult = {
      name,
      duration: endTime - startTime,
      startTime,
      endTime,
      memoryBefore,
      memoryAfter
    };

    this.results.push(profileResult);

    console.log(
      `${name}: ${profileResult.duration.toFixed(2)}ms` +
      (memoryBefore && memoryAfter ? `, Memory: ${(memoryAfter - memoryBefore).toFixed(2)}KB` : '')
    );

    return result;
  }

  getResults(): ProfileResult[] {
    return [...this.results];
  }

  getSummary(): { totalDuration: number; averageDuration: number; longestTask: string } {
    if (this.results.length === 0) {
      return { totalDuration: 0, averageDuration: 0, longestTask: '' };
    }

    const totalDuration = this.results.reduce((sum, result) => sum + result.duration, 0);
    const averageDuration = totalDuration / this.results.length;
    const longestTask = this.results.reduce((longest, current) => 
      current.duration > longest.duration ? current : longest
    ).name;

    return { totalDuration, averageDuration, longestTask };
  }

  private getMemoryUsage(): number {
    // В браузере можно использовать performance.memory
    if (typeof performance !== 'undefined' && (performance as any).memory) {
      return (performance as any).memory.usedJSHeapSize / 1024; // в KB
    }
    
    // В Node.js можно использовать process.memoryUsage
    if (typeof process !== 'undefined') {
      return process.memoryUsage().heapUsed / 1024; // в KB
    }

    return 0;
  }
}

// Пример использования
const profiler = new PerformanceProfiler();

await profiler.profile('userCreation', async () => {
  const user = new User({ name: 'John', email: 'john@example.com' });
  await user.save();
});

await profiler.profile('dataProcessing', async () => {
  return processData(largeDataSet);
});

const summary = profiler.getSummary();
console.log(`Total: ${summary.totalDuration.toFixed(2)}ms, Average: ${summary.averageDuration.toFixed(2)}ms`);
```

## Оптимизация алгоритмов и структур данных

### 1. Выбор правильных структур данных

```typescript
// Неправильное использование массива для поиска
class InefficientUserStore {
  private users: User[] = [];

  addUser(user: User): void {
    this.users.push(user);
  }

  // O(n) - неэффективно при большом количестве пользователей
  findUserById(id: string): User | undefined {
    return this.users.find(user => user.id === id);
  }
}

// Эффективное использование Map
class EfficientUserStore {
  private users: Map<string, User> = new Map();

  addUser(user: User): void {
    this.users.set(user.id, user);
  }

  // O(1) - эффективно независимо от количества пользователей
  findUserById(id: string): User | undefined {
    return this.users.get(id);
  }

  // Дополнительные методы для эффективной работы
  updateUser(id: string, updates: Partial<User>): boolean {
    const user = this.users.get(id);
    if (!user) return false;

    Object.assign(user, updates);
    this.users.set(id, user);
    return true;
  }

  removeUser(id: string): boolean {
    return this.users.delete(id);
  }

  getAllUsers(): User[] {
    return Array.from(this.users.values());
  }
}
```

### 2. Оптимизация алгоритмов

```typescript
// Неоптимизированный алгоритм поиска дубликатов - O(n²)
function findDuplicatesSlow<T>(items: T[]): T[] {
  const duplicates: T[] = [];
  
  for (let i = 0; i < items.length; i++) {
    for (let j = i + 1; j < items.length; j++) {
      if (items[i] === items[j] && !duplicates.includes(items[i])) {
        duplicates.push(items[i]);
      }
    }
  }
  
  return duplicates;
}

// Оптимизированный алгоритм поиска дубликатов - O(n)
function findDuplicatesFast<T>(items: T[]): T[] {
  const seen = new Set<T>();
  const duplicates = new Set<T>();
  
  for (const item of items) {
    if (seen.has(item)) {
      duplicates.add(item);
    } else {
      seen.add(item);
    }
  }
  
  return Array.from(duplicates);
}

// Оптимизация сортировки
class SortedCollection<T> {
  private items: T[] = [];
  private compareFn: (a: T, b: T) => number;

  constructor(compareFn: (a: T, b: T) => number) {
    this.compareFn = compareFn;
  }

  insert(item: T): void {
    // Вставка с сохранением сортировки - O(n)
    const index = this.findIndex(item);
    this.items.splice(index, 0, item);
  }

  private findIndex(item: T): number {
    let left = 0;
    let right = this.items.length;

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      const comparison = this.compareFn(this.items[mid], item);

      if (comparison < 0) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    return left;
  }

  search(item: T): T | undefined {
    // Бинарный поиск - O(log n)
    let left = 0;
    let right = this.items.length - 1;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const comparison = this.compareFn(this.items[mid], item);

      if (comparison === 0) {
        return this.items[mid];
      } else if (comparison < 0) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return undefined;
  }
}
```

## Оптимизация памяти

### 1. Управление памятью

```typescript
// Правильное управление ресурсами
class ResourceManager {
  private resources: Map<string, { resource: any; timestamp: number }> = new Map();
  private maxResources: number;
  private cleanupInterval: NodeJS.Timeout;

  constructor(maxResources: number = 1000) {
    this.maxResources = maxResources;
    this.cleanupInterval = setInterval(() => this.cleanup(), 60000); // Очистка каждую минуту
  }

  addResource(id: string, resource: any): void {
    this.resources.set(id, { resource, timestamp: Date.now() });
    
    // Очистка если превышено максимальное количество ресурсов
    if (this.resources.size > this.maxResources) {
      this.cleanup();
    }
  }

  getResource(id: string): any | null {
    const entry = this.resources.get(id);
    if (entry) {
      entry.timestamp = Date.now(); // Обновление времени доступа
      return entry.resource;
    }
    return null;
  }

  removeResource(id: string): boolean {
    return this.resources.delete(id);
  }

  private cleanup(): void {
    const now = Date.now();
    const oldestAllowed = now - 300000; // 5 минут

    for (const [id, entry] of this.resources) {
      if (entry.timestamp < oldestAllowed) {
        // Освобождение ресурсов перед удалением
        if (typeof entry.resource.destroy === 'function') {
          entry.resource.destroy();
        }
        this.resources.delete(id);
      }
    }

    // Если все еще превышено максимальное количество, удаляем старейшие
    if (this.resources.size > this.maxResources) {
      const entries = Array.from(this.resources.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      const toRemove = entries.slice(0, this.resources.size - this.maxResources);
      for (const [id] of toRemove) {
        this.resources.delete(id);
      }
    }
  }

  destroy(): void {
    clearInterval(this.cleanupInterval);
    
    // Освобождение всех ресурсов
    for (const [id, entry] of this.resources) {
      if (typeof entry.resource.destroy === 'function') {
        entry.resource.destroy();
      }
    }
    
    this.resources.clear();
  }
}
```

### 2. Оптимизация объектов

```typescript
// Использование Object Pool для частого создания/удаления объектов
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;
  private resetter: (obj: T) => void;

  constructor(factory: () => T, resetter: (obj: T) => void) {
    this.factory = factory;
    this.resetter = resetter;
  }

  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return this.factory();
  }

  release(obj: T): void {
    this.resetter(obj);
    this.pool.push(obj);
  }

  getPoolSize(): number {
    return this.pool.length;
  }
}

// Пример использования для геометрических точек
interface Point {
  x: number;
  y: number;
  reset(): void;
}

const pointPool = new ObjectPool<Point>(
  () => ({ x: 0, y: 0, reset: function() { this.x = 0; this.y = 0; } }),
  (point) => point.reset()
);

function calculateDistances(points: { x: number; y: number }[]): number[] {
  const distances: number[] = [];
  const tempPoint = pointPool.acquire(); // Взять из пула

  try {
    for (let i = 0; i < points.length - 1; i++) {
      tempPoint.x = points[i + 1].x - points[i].x;
      tempPoint.y = points[i + 1].y - points[i].y;
      
      const distance = Math.sqrt(tempPoint.x ** 2 + tempPoint.y ** 2);
      distances.push(distance);
    }
  } finally {
    pointPool.release(tempPoint); // Вернуть в пул
  }

  return distances;
}
```

## Оптимизация асинхронных операций

### 1. Управление параллельными запросами

```typescript
// Контролируемое выполнение параллельных запросов
class RequestLimiter {
  private activeRequests = 0;
  private maxConcurrent: number;
  private queue: Array<() => Promise<any>> = [];

  constructor(maxConcurrent: number = 5) {
    this.maxConcurrent = maxConcurrent;
  }

  async request<T>(requestFn: () => Promise<T>): Promise<T> {
    return new Promise<T>((resolve, reject) => {
      const execute = async () => {
        try {
          this.activeRequests++;
          const result = await requestFn();
          this.activeRequests--;
          resolve(result);
          this.processQueue();
        } catch (error) {
          this.activeRequests--;
          reject(error);
          this.processQueue();
        }
      };

      if (this.activeRequests < this.maxConcurrent) {
        execute();
      } else {
        this.queue.push(execute);
      }
    });
  }

  private processQueue(): void {
    if (this.queue.length > 0 && this.activeRequests < this.maxConcurrent) {
      const nextRequest = this.queue.shift();
      if (nextRequest) {
        nextRequest();
      }
    }
  }
}

// Пример использования
const limiter = new RequestLimiter(3);

const requests = Array.from({ length: 10 }, (_, i) => 
  () => fetchUserData(i.toString())
);

// Выполнение запросов с ограничением
const results = await Promise.all(
  requests.map(request => limiter.request(request))
);
```

### 2. Кэширование асинхронных результатов

```typescript
// Кэш с TTL для асинхронных операций
class AsyncCache {
  private cache: Map<string, { data: any; timestamp: number; ttl: number; promise?: Promise<any> }> = new Map();

  async get<T>(key: string, fetchFn: () => Promise<T>, ttl: number = 300000): Promise<T> {
    const entry = this.cache.get(key);

    // Проверка на актуальность данных
    if (entry && Date.now() - entry.timestamp < entry.ttl) {
      return entry.data as T;
    }

    // Проверка на активный запрос
    if (entry && entry.promise) {
      return entry.promise as Promise<T>;
    }

    // Выполнение нового запроса
    const promise = fetchFn()
      .then(data => {
        this.cache.set(key, { data, timestamp: Date.now(), ttl });
        return data;
      })
      .finally(() => {
        // Удаление promise из кэша после завершения
        const currentEntry = this.cache.get(key);
        if (currentEntry && currentEntry.promise) {
          const { promise: _, ...newEntry } = currentEntry;
          this.cache.set(key, newEntry as any);
        }
      });

    // Сохранение promise для предотвращения дублирующихся запросов
    if (entry) {
      this.cache.set(key, { ...entry, promise });
    } else {
      this.cache.set(key, { data: null, timestamp: Date.now(), ttl, promise });
    }

    return promise;
  }

  set<T>(key: string, data: T, ttl: number = 300000): void {
    this.cache.set(key, { data, timestamp: Date.now(), ttl });
  }

  invalidate(key: string): void {
    this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }
}

// Пример использования
const cache = new AsyncCache();

async function getCachedUser(id: string): Promise<User> {
  return cache.get(`user:${id}`, () => fetchUserAPI(id), 60000); // 1 минута TTL
}
```

## Оптимизация веб-приложений (React и др.)

### 1. Оптимизация рендеринга

```typescript
// Использование React.memo с правильной логикой сравнения
interface ExpensiveComponentProps {
  data: ComplexDataStructure;
  onAction: (data: ComplexDataStructure) => void;
  userId: string;
}

const ExpensiveComponent: React.FC<ExpensiveComponentProps> = React.memo(
  ({ data, onAction, userId }) => {
    // Использование useMemo для дорогих вычислений
    const processedData = useMemo(() => {
      return complexProcessing(data);
    }, [data]); // Зависимость только от data

    // Использование useCallback для предотвращения создания новых функций
    const handleAction = useCallback(() => {
      onAction(data);
    }, [onAction, data]);

    return (
      <div>
        <h2>User: {userId}</h2>
        {processedData.map(item => (
          <DataItem key={item.id} item={item} onAction={handleAction} />
        ))}
      </div>
    );
  },
  // Пользовательская функция сравнения пропсов
  (prevProps, nextProps) => {
    return (
      prevProps.userId === nextProps.userId &&
      prevProps.data.id === nextProps.data.id && // Сравнение по ID вместо всей структуры
      prevProps.data.version === nextProps.data.version // Сравнение версии данных
    );
  }
);

// Использование virtual scrolling для списков
interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string;
}

const VirtualList = <T extends {}>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  keyExtractor
}: VirtualListProps<T>) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Вычисление видимых элементов
  const visibleStartIndex = Math.floor(scrollTop / itemHeight);
  const visibleEndIndex = Math.min(
    visibleStartIndex + Math.ceil(containerHeight / itemHeight) + 5,
    items.length
  );
  
  const offsetHeight = visibleStartIndex * itemHeight;
  const visibleItems = items.slice(visibleStartIndex, visibleEndIndex);

  return (
    <div
      ref={containerRef}
      className="virtual-list-container"
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetHeight}px)` }}>
          {visibleItems.map((item, index) => (
            <div
              key={keyExtractor(item)}
              style={{ height: itemHeight }}
            >
              {renderItem(item, index + visibleStartIndex)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

### 2. Lazy Loading и Code Splitting

```typescript
// Продвинутая ленивая загрузка с предзагрузкой
interface LazyComponentModule<T> {
  default: React.ComponentType<T>;
  preload?: () => void;
}

class LazyLoader {
  private loadedComponents: Map<string, LazyComponentModule<any>> = new Map();
  private loadingPromises: Map<string, Promise<LazyComponentModule<any>>> = new Map();

  async load<T>(id: string, loader: () => Promise<LazyComponentModule<T>>): Promise<React.ComponentType<T>> {
    // Проверка, загружен ли компонент
    const cached = this.loadedComponents.get(id);
    if (cached) {
      return cached.default;
    }

    // Проверка, идет ли загрузка
    const loadingPromise = this.loadingPromises.get(id);
    if (loadingPromise) {
      const module = await loadingPromise;
      return module.default;
    }

    // Начало загрузки
    const promise = loader().then(module => {
      this.loadedComponents.set(id, module);
      this.loadingPromises.delete(id);
      return module;
    });

    this.loadingPromises.set(id, promise as Promise<LazyComponentModule<any>>);
    
    const module = await promise;
    return module.default;
  }

  preload(id: string, loader: () => Promise<LazyComponentModule<any>>): void {
    if (!this.loadedComponents.has(id) && !this.loadingPromises.has(id)) {
      this.loadingPromises.set(id, loader());
    }
  }

  clear(): void {
    this.loadedComponents.clear();
    // Не очищаем pending promises, чтобы не прерывать активные загрузки
  }
}

const lazyLoader = new LazyLoader();

// Использование в компоненте
const LazyDashboard = lazy(() => lazyLoader.load('dashboard', () => import('./Dashboard')));

// Предзагрузка при наведении на ссылку
const PreloadLink: React.FC<{ to: string; moduleId: string; children: React.ReactNode }> = 
({ to, moduleId, children }) => {
  return (
    <Link 
      to={to}
      onMouseEnter={() => lazyLoader.preload(moduleId, () => import('./Dashboard'))}
    >
      {children}
    </Link>
  );
};
```

## Оптимизация компиляции TypeScript

### 1. Конфигурация компилятора

```json
// tsconfig.json - оптимизированная конфигурация
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "allowJs": false,
    "skipLibCheck": true,          // Ускоряет компиляцию
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,                // Для использования с Babel
    "jsx": "react-jsx",
    "incremental": true,           // Ускоряет последующие сборки
    "composite": true,             // Для работы с проектными ссылками
    "tsBuildInfoFile": ".tsbuildinfo" // Для инкрементной сборки
  },
  "include": [
    "src"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "build"
  ]
}
```

### 2. Использование проектных ссылок

```json
// tsconfig.base.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "moduleResolution": "node",
    "esModuleInterop": true
  }
}
```

```json
// packages/ui/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "../../dist/ui",
    "rootDir": "./src"
  },
  "references": [
    { "path": "../types" }
  ],
  "include": ["src"]
}
```

## Мониторинг и профилирование в продакшене

### 1. Сбор метрик производительности

```typescript
// Служба сбора метрик производительности
interface PerformanceMetrics {
  navigation: PerformanceNavigationTiming;
  paint: PerformancePaintTiming[];
  resource: PerformanceResourceTiming[];
  custom: Map<string, number>;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics;
  private observers: PerformanceObserver[] = [];

  constructor() {
    this.metrics = {
      navigation: null as any,
      paint: [],
      resource: [],
      custom: new Map()
    };

    this.setupObservers();
  }

  private setupObservers(): void {
    // Наблюдение за навигацией
    if ('navigation' in performance) {
      this.metrics.navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    }

    // Наблюдение за рендерингом
    if ('PerformanceObserver' in window) {
      const paintObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'paint') {
            this.metrics.paint.push(entry as PerformancePaintTiming);
          }
        }
      });
      paintObserver.observe({ entryTypes: ['paint'] });
      this.observers.push(paintObserver);

      // Наблюдение за ресурсами
      const resourceObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'resource') {
            this.metrics.resource.push(entry as PerformanceResourceTiming);
          }
        }
      });
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    }
  }

  measureCustom(name: string, fn: () => any): any {
    const startMark = `start-${name}`;
    const endMark = `end-${name}`;
    
    performance.mark(startMark);
    const result = fn();
    performance.mark(endMark);
    performance.measure(name, startMark, endMark);
    
    const measure = performance.getEntriesByName(name)[0];
    if (measure) {
      this.metrics.custom.set(name, measure.duration);
    }
    
    return result;
  }

  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  getCoreWebVitals(): {
    lcp: number | null;
    fcp: number | null;
    cls: number | null;
    fid: number | null;
  } {
    let lcp: number | null = null;
    let fcp: number | null = null;
    let cls: number | null = 0;
    let fid: number | null = null;

    // Largest Contentful Paint
    const lcpEntries = performance.getEntriesByType('largest-contentful-paint');
    if (lcpEntries.length > 0) {
      lcp = (lcpEntries[lcpEntries.length - 1] as any).renderTime || (lcpEntries[lcpEntries.length - 1] as any).loadTime;
    }

    // First Contentful Paint
    const fcpEntry = performance.getEntriesByName('first-contentful-paint')[0];
    if (fcpEntry) {
      fcp = fcpEntry.startTime;
    }

    // Cumulative Layout Shift
    const clsEntries = performance.getEntriesByType('layout-shift');
    for (const entry of clsEntries) {
      if (!entry.hadRecentInput) {
        cls += (entry as any).value;
      }
    }

    // First Input Delay (предполагаем, что отслеживается отдельно)
    // fid будет равно null, если не отслеживается

    return { lcp, fcp, cls, fid };
  }

  destroy(): void {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
  }
}

// Использование в приложении
const monitor = new PerformanceMonitor();

// Мониторинг критических операций
monitor.measureCustom('user-login', () => {
  return performLogin(credentials);
});

// Отправка метрик на сервер
const coreWebVitals = monitor.getCoreWebVitals();
if (coreWebVitals.lcp && coreWebVitals.lcp > 2500) { // LCP > 2.5s
  // Отправить алерт о плохой производительности
  sendPerformanceAlert('LCP too high', coreWebVitals);
}
```

## Заключение

Оптимизация производительности TypeScript-приложений - это комплексный процесс, включающий:

- Измерение и профилирование производительности
- Оптимизацию алгоритмов и структур данных
- Эффективное управление памятью
- Оптимизацию асинхронных операций
- Оптимизацию веб-интерфейсов
- Настройку компиляции TypeScript
- Мониторинг в продакшене

Ключевые принципы оптимизации:
- Измеряй перед оптимизацией
- Фокусируйся на узких местах
- Балансируй между производительностью и читаемостью кода
- Регулярно мониторь производительность в продакшене

Следующие темы: [[Архитектура-для-масштабирования]], [[Горизонтальное-и-вертикальное-масштабирование]], [[Масштабирование-компонентов]], [[Управление-состоянием-при-масштабировании]]