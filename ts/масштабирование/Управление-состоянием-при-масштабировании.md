---
aliases: [Управление состоянием при масштабировании, Состояние при масштабировании]
tags: [typescript, state-management, scalability, architecture, react]
---

# Управление состоянием при масштабировании TypeScript-приложений

## Введение

Управление состоянием - критический аспект разработки масштабируемых приложений. По мере роста сложности приложения и увеличения числа компонентов, взаимодействующих с данными, становится важным эффективное и предсказуемое управление состоянием. Это особенно актуально для TypeScript-приложений, где типизация помогает предотвратить ошибки и улучшить поддерживаемость кода.

## Архитектура управления состоянием

### 1. Локальное состояние

Локальное состояние используется для данных, которые нужны только внутри одного компонента:

```typescript
// Пример локального состояния
interface CounterState {
  count: number;
  step: number;
}

const Counter: React.FC = () => {
  const [state, setState] = useState<CounterState>({ 
    count: 0, 
    step: 1 
  });

  const increment = () => {
    setState(prev => ({ 
      ...prev, 
      count: prev.count + prev.step 
    }));
  };

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={increment}>+</button>
      <input 
        type="number" 
        value={state.step}
        onChange={(e) => setState(prev => ({
          ...prev,
          step: parseInt(e.target.value) || 1
        }))}
      />
    </div>
  );
};
```

### 2. Подъем состояния (Lifting State Up)

Когда несколько компонентов нуждаются в доступе к одному и тому же состоянию, его поднимают до ближайшего общего предка:

```typescript
// Пример подъема состояния
interface AppState {
  temperature: number;
  scale: 'c' | 'f';
}

const TemperatureApp: React.FC = () => {
  const [state, setState] = useState<AppState>({
    temperature: 0,
    scale: 'c'
  });

  const handleCelsiusChange = (temperature: number) => {
    setState({ temperature, scale: 'c' });
  };

  const handleFahrenheitChange = (temperature: number) => {
    setState({ temperature, scale: 'f' });
  };

  const { temperature, scale } = state;
  const celsius = scale === 'f' ? (temperature - 32) * 5 / 9 : temperature;
  const fahrenheit = scale === 'c' ? (temperature * 9 / 5) + 32 : temperature;

  return (
    <div>
      <TemperatureInput
        scale="c"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={celsius} />
    </div>
  );
};

interface TemperatureInputProps {
  scale: 'c' | 'f';
  temperature: number;
  onTemperatureChange: (temperature: number) => void;
}

const TemperatureInput: React.FC<TemperatureInputProps> = ({
  scale,
  temperature,
  onTemperatureChange
}) => {
  const scaleName = scale === 'c' ? 'Celsius' : 'Fahrenheit';

  return (
    <fieldset>
      <legend>Enter temperature in {scaleName}:</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(parseFloat(e.target.value) || 0)}
      />
    </fieldset>
  );
};
```

## Централизованное управление состоянием

### 1. Context API

Context API позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточные уровни:

```typescript
// Определение контекста
interface UserContextType {
  currentUser: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  updateUser: (userData: Partial<User>) => Promise<void>;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

// Провайдер контекста
interface UserProviderProps {
  children: React.ReactNode;
}

const UserProvider: React.FC<UserProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Восстановление сессии при загрузке
    restoreSession()
      .then(user => setCurrentUser(user))
      .finally(() => setLoading(false));
  }, []);

  const login = async (credentials: LoginCredentials) => {
    const user = await authenticate(credentials);
    setCurrentUser(user);
    persistSession(user);
  };

  const logout = () => {
    setCurrentUser(null);
    clearSession();
  };

  const updateUser = async (userData: Partial<User>) => {
    if (!currentUser) throw new Error('User not authenticated');
    
    const updatedUser = await updateUserService(currentUser.id, userData);
    setCurrentUser(updatedUser);
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <UserContext.Provider value={{ 
      currentUser, 
      login, 
      logout, 
      updateUser 
    }}>
      {children}
    </UserContext.Provider>
  );
};

// Хук для использования контекста
const useUser = (): UserContextType => {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
};

// Использование контекста
const UserProfile: React.FC = () => {
  const { currentUser, updateUser } = useUser();
  
  if (!currentUser) {
    return <div>Please log in</div>;
  }

  return (
    <div>
      <h1>{currentUser.name}</h1>
      <p>{currentUser.email}</p>
      <button onClick={() => updateUser({ lastLogin: new Date() })}>
        Update Last Login
      </button>
    </div>
  );
};
```

### 2. useReducer для сложных состояний

Для сложных состояний с логикой переходов между состояниями лучше использовать `useReducer`:

```typescript
// Определение типа состояния и действий
interface TodosState {
  items: Todo[];
  filter: 'all' | 'active' | 'completed';
  loading: boolean;
  error: string | null;
}

type TodosAction =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: Todo[] }
  | { type: 'FETCH_ERROR'; payload: string }
  | { type: 'ADD_TODO'; payload: Todo }
  | { type: 'TOGGLE_TODO'; payload: string }
  | { type: 'DELETE_TODO'; payload: string }
  | { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' };

// Редьюсер для управления состоянием
const todosReducer = (state: TodosState, action: TodosAction): TodosState => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, items: action.payload };
    
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    
    case 'ADD_TODO':
      return { ...state, items: [...state.items, action.payload] };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        items: state.items.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        items: state.items.filter(todo => todo.id !== action.payload)
      };
    
    case 'SET_FILTER':
      return { ...state, filter: action.payload };
    
    default:
      return state;
  }
};

// Провайдер для управления списком задач
const TodosProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(todosReducer, {
    items: [],
    filter: 'all',
    loading: false,
    error: null
  });

  // Асинхронные действия
  const fetchTodos = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const todos = await fetchTodosService();
      dispatch({ type: 'FETCH_SUCCESS', payload: todos });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  const addTodo = async (text: string) => {
    const newTodo: Todo = {
      id: generateId(),
      text,
      completed: false,
      createdAt: new Date()
    };
    dispatch({ type: 'ADD_TODO', payload: newTodo });
  };

  const toggleTodo = (id: string) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };

  const deleteTodo = (id: string) => {
    dispatch({ type: 'DELETE_TODO', payload: id });
  };

  const setFilter = (filter: 'all' | 'active' | 'completed') => {
    dispatch({ type: 'SET_FILTER', payload: filter });
  };

  return (
    <TodosContext.Provider value={{
      ...state,
      fetchTodos,
      addTodo,
      toggleTodo,
      deleteTodo,
      setFilter
    }}>
      {children}
    </TodosContext.Provider>
  );
};
```

## Внешние библиотеки управления состоянием

### 1. Zustand

Zustand - легковесная библиотека для управления состоянием:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UserState {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  fetchUser: (id: string) => Promise<void>;
}

const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      user: null,
      loading: false,
      error: null,
      
      login: async (credentials) => {
        set({ loading: true, error: null });
        try {
          const user = await authenticate(credentials);
          set({ user, loading: false });
        } catch (error) {
          set({ error: error.message, loading: false });
        }
      },
      
      logout: () => {
        set({ user: null });
      },
      
      fetchUser: async (id) => {
        set({ loading: true });
        try {
          const user = await fetchUserService(id);
          set({ user, loading: false });
        } catch (error) {
          set({ error: error.message, loading: false });
        }
      }
    }),
    {
      name: 'user-storage', // имя ключа в localStorage
      partialize: (state) => ({ user: state.user }) // какие данные сохранять
    }
  )
);

// Использование в компоненте
const LoginButton: React.FC = () => {
  const { user, login, logout } = useUserStore();
  const [credentials, setCredentials] = useState({ email: '', password: '' });

  const handleLogin = async () => {
    await login(credentials);
  };

  if (user) {
    return (
      <button onClick={logout}>
        Logout {user.name}
      </button>
    );
  }

  return (
    <div>
      <input
        placeholder="Email"
        value={credentials.email}
        onChange={(e) => setCredentials({...credentials, email: e.target.value})}
      />
      <input
        type="password"
        placeholder="Password"
        value={credentials.password}
        onChange={(e) => setCredentials({...credentials, password: e.target.value})}
      />
      <button onClick={handleLogin}>Login</button>
    </div>
  );
};
```

### 2. Redux Toolkit

Redux Toolkit с улучшенным типизацией для TypeScript:

```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from './store';

// Асинхронное действие для получения пользователей
export const fetchUsers = createAsyncThunk<User[], void, { state: RootState }>(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetchUsersAPI();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Определение состояния
interface UsersState {
  items: User[];
  loading: boolean;
  error: string | null;
  selectedUserId: string | null;
}

const initialState: UsersState = {
  items: [],
  loading: false,
  error: null,
  selectedUserId: null
};

// Слайс для управления состоянием пользователей
const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    selectUser: (state, action: PayloadAction<string>) => {
      state.selectedUserId = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  }
});

export const { selectUser, clearError } = usersSlice.actions;
export default usersSlice.reducer;

// Селекторы для получения данных из состояния
export const selectUsers = (state: RootState) => state.users.items;
export const selectCurrentUser = (state: RootState) => 
  state.users.items.find(user => user.id === state.users.selectedUserId);
export const selectUsersLoading = (state: RootState) => state.users.loading;
```

## Управление асинхронным состоянием

### 1. Паттерн "Loadable Data"

```typescript
// Тип для асинхронных данных
type Loadable<T> =
  | { state: 'loading' }
  | { state: 'error'; error: string }
  | { state: 'success'; data: T };

// Хук для загрузки данных
const useLoadableData = <T>(fetchFn: () => Promise<T>): Loadable<T> => {
  const [loadable, setLoadable] = useState<Loadable<T>>({ state: 'loading' });

  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      try {
        const data = await fetchFn();
        if (!cancelled) {
          setLoadable({ state: 'success', data });
        }
      } catch (error) {
        if (!cancelled) {
          setLoadable({ state: 'error', error: error.message });
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
    };
  }, [fetchFn]);

  return loadable;
};

// Использование хука
const UserList: React.FC = () => {
  const loadableUsers = useLoadableData(fetchUsers);

  switch (loadableUsers.state) {
    case 'loading':
      return <div>Loading users...</div>;
    
    case 'error':
      return <div>Error: {loadableUsers.error}</div>;
    
    case 'success':
      return (
        <ul>
          {loadableUsers.data.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      );
  }
};
```

### 2. Кэширование данных

```typescript
// Простой кэш с TTL
class DataCache {
  private cache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();

  set(key: string, data: any, ttl: number = 300000) { // 5 минут по умолчанию
    this.cache.set(key, { data, timestamp: Date.now(), ttl });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }

  has(key: string): boolean {
    const entry = this.cache.get(key);
    if (!entry) return false;

    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  clear() {
    this.cache.clear();
  }
}

const globalCache = new DataCache();

// Хук с кэшированием
const useCachedData = <T>(key: string, fetchFn: () => Promise<T>, ttl?: number) => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const cached = globalCache.get<T>(key);
    if (cached) {
      setData(cached);
      setLoading(false);
      return;
    }

    let cancelled = false;

    const fetchData = async () => {
      try {
        setLoading(true);
        const result = await fetchFn();
        if (!cancelled) {
          setData(result);
          globalCache.set(key, result, ttl);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
    };
  }, [key, fetchFn, ttl]);

  return { data, loading, error };
};
```

## Паттерны для масштабируемого управления состоянием

### 1. Сегрегация состояния по доменам

```typescript
// Структура для разделения состояния по доменам
interface AppState {
  user: UserState;
  ui: UIState;
  entities: EntitiesState;
  network: NetworkState;
}

interface UserState {
  profile: User | null;
  preferences: UserPreferences;
  auth: AuthState;
}

interface UIState {
  theme: 'light' | 'dark';
  notifications: Notification[];
  modals: ModalState[];
}

interface EntitiesState {
  users: Record<string, User>;
  posts: Record<string, Post>;
  comments: Record<string, Comment>;
}

interface NetworkState {
  requests: Record<string, RequestStatus>;
  cache: Record<string, any>;
}

// Пример разделения редьюсеров
const rootReducer = combineReducers({
  user: userReducer,
  ui: uiReducer,
  entities: entitiesReducer,
  network: networkReducer
});
```

### 2. Нормализация данных

```typescript
// Нормализованная структура данных
interface NormalizedState {
  users: {
    byId: { [id: string]: User };
    allIds: string[];
  };
  posts: {
    byId: { [id: string]: Post };
    allIds: string[];
  };
  userPosts: {
    [userId: string]: string[]; // массив ID постов пользователя
  };
}

// Утилита для нормализации данных
const normalizeData = <T extends { id: string }>(items: T[]): { byId: { [id: string]: T }, allIds: string[] } => {
  const byId: { [id: string]: T } = {};
  const allIds: string[] = [];

  items.forEach(item => {
    byId[item.id] = item;
    allIds.push(item.id);
  });

  return { byId, allIds };
};

// Пример использования в редьюсере
const postsReducer = (state: NormalizedState['posts'] = { byId: {}, allIds: [] }, action: PostsAction) => {
  switch (action.type) {
    case 'FETCH_POSTS_SUCCESS':
      const normalized = normalizeData(action.payload);
      return {
        byId: { ...state.byId, ...normalized.byId },
        allIds: [...state.allIds, ...normalized.allIds]
      };
    
    case 'ADD_POST':
      return {
        byId: { ...state.byId, [action.payload.id]: action.payload },
        allIds: [...state.allIds, action.payload.id]
      };
    
    default:
      return state;
  }
};
```

## Миграция состояния

```typescript
// Пример миграции состояния
interface MigrationState {
  version: number;
  data: any;
}

const migrateState = (state: MigrationState): MigrationState => {
  if (state.version === 1) {
    // Миграция с версии 1 к версии 2
    const migratedData = {
      ...state.data,
      newField: state.data.oldField || []
    };
    
    return {
      version: 2,
      data: migratedData
    };
  }
  
  if (state.version === 2) {
    // Миграция с версии 2 к версии 3
    const migratedData = {
      ...state.data,
      refactoredField: state.data.newField.map(item => ({
        id: item.id,
        name: item.title // переименование поля
      }))
    };
    
    return {
      version: 3,
      data: migratedData
    };
  }
  
  return state;
};

// Использование в провайдере состояния
const StateProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<MigrationState>(() => {
    const savedState = localStorage.getItem('app-state');
    if (savedState) {
      const parsed = JSON.parse(savedState);
      return migrateState(parsed);
    }
    return { version: 3, data: {} };
  });

  useEffect(() => {
    localStorage.setItem('app-state', JSON.stringify(state));
  }, [state]);

  return (
    <StateContext.Provider value={{ state, setState }}>
      {children}
    </StateContext.Provider>
  );
};
```

## Тестирование управления состоянием

```typescript
// Тестирование редьюсера
import { describe, it, expect } from 'vitest';

describe('todosReducer', () => {
  it('should handle initial state', () => {
    expect(todosReducer(undefined, { type: '@@INIT' })).toEqual({
      items: [],
      filter: 'all',
      loading: false,
      error: null
    });
  });

  it('should handle ADD_TODO', () => {
    const todo = { id: '1', text: 'Test', completed: false };
    const action = { type: 'ADD_TODO', payload: todo };
    const state = todosReducer(initialState, action);
    
    expect(state.items).toEqual([todo]);
  });

  it('should handle TOGGLE_TODO', () => {
    const initialStateWithTodos = {
      items: [
        { id: '1', text: 'Test', completed: false },
        { id: '2', text: 'Test 2', completed: true }
      ],
      filter: 'all',
      loading: false,
      error: null
    };
    
    const action = { type: 'TOGGLE_TODO', payload: '1' };
    const state = todosReducer(initialStateWithTodos, action);
    
    expect(state.items[0].completed).toBe(true);
    expect(state.items[1].completed).toBe(true);
  });
});

// Тестирование хука
const renderHookWithState = (hook: () => any) => {
  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <TodosProvider>{children}</TodosProvider>
  );
  
  return renderHook(hook, { wrapper: Wrapper });
};

describe('useTodos', () => {
  it('should add a new todo', async () => {
    const { result } = renderHookWithState(() => useTodos());
    
    act(() => {
      result.current.addTodo('Test todo');
    });
    
    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].text).toBe('Test todo');
  });
});
```

## Заключение

Эффективное управление состоянием в масштабируемых TypeScript-приложениях требует:

- Правильного выбора стратегии (локальное, контекст, внешняя библиотека)
- Четкой архитектуры и разделения ответственности
- Нормализации данных для предотвращения дублирования
- Кэширования для оптимизации производительности
- Адекватного тестирования всех аспектов состояния

Следующие темы: [[Архитектура-для-масштабирования]], [[Горизонтальное-и-вертикальное-масштабирование]], [[Масштабирование-компонентов]], [[Оптимизация-производительности]]