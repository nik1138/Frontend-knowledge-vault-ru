---
aliases: [Горизонтальное и вертикальное масштабирование, Масштабирование по осям]
tags: [typescript, scalability, architecture, performance]
---

# Горизонтальное и вертикальное масштабирование в TypeScript-приложениях

## Введение

Масштабирование приложений - это процесс увеличения их способности обрабатывать нагрузку. Существует два основных подхода: вертикальное и горизонтальное масштабирование. Понимание этих концепций критично для разработки производительных и надежных TypeScript-приложений.

## Вертикальное масштабирование (Scale Up)

### Определение

Вертикальное масштабирование - это увеличение мощности отдельного сервера или узла (CPU, RAM, дисковое пространство). Это более традиционный подход, при котором ресурсы одного узла увеличиваются для обработки большей нагрузки.

### Преимущества

- Простота реализации и управления
- Нет необходимости в сложной логике распределения данных
- Меньше проблем с согласованностью данных
- Простая отладка и мониторинг

### Недостатки

- Ограниченный предел масштабирования
- Высокая стоимость мощных серверов
- Единая точка отказа
- Не всегда эффективное использование ресурсов

### Пример реализации в TypeScript

```typescript
// Пример сервиса, оптимизированного для вертикального масштабирования
class OptimizedUserService {
  private cache: Map<string, User> = new Map();
  private processor: WorkerPool; // Пул потоков для обработки

  constructor() {
    // Использование worker_threads для параллельной обработки
    this.processor = new WorkerPool({
      maxWorkers: require('os').cpus().length,
      taskQueue: new PriorityTaskQueue()
    });
  }

  async processBatchUsers(userDataList: UserData[]): Promise<User[]> {
    // Распределение нагрузки по потокам на одном узле
    const promises = userDataList.map(userData => 
      this.processor.execute<User>(async () => {
        return await this.createUser(userData);
      })
    );

    return await Promise.all(promises);
  }

  private async createUser(userData: UserData): Promise<User> {
    // Интенсивные вычисления в отдельном потоке
    const user = new User(userData);
    
    // Валидация и обработка данных
    await this.validateUser(user);
    await this.saveUser(user);
    
    return user;
  }
}
```

## Горизонтальное масштабирование (Scale Out)

### Определение

Горизонтальное масштабирование - это добавление большего количества серверов или узлов в систему для распределения нагрузки. Это современный подход, позволяющий практически неограниченно увеличивать мощность системы.

### Преимущества

- Практически неограниченный потенциал масштабирования
- Лучшее распределение нагрузки
- Отказоустойчивость (при выходе из строя одного узла другие продолжают работать)
- Более гибкая модель ценообразования

### Недостатки

- Сложность управления распределенной системой
- Проблемы с согласованностью данных
- Необходимость в балансировке нагрузки
- Возможные проблемы с сетевой задержкой

### Пример реализации в TypeScript

```typescript
// Пример сервиса с поддержкой горизонтального масштабирования
import { Cluster } from 'cluster';
import * as os from 'os';

class DistributedUserService {
  private redisClient: RedisClient;
  private messageQueue: MessageQueue;

  constructor() {
    this.redisClient = new RedisClient({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379')
    });

    this.messageQueue = new MessageQueue({
      redis: this.redisClient
    });
  }

  async handleUserCreation(userData: UserData): Promise<User> {
    // Распределение задачи между узлами через очередь сообщений
    const taskId = await this.messageQueue.enqueue({
      type: 'CREATE_USER',
      payload: userData,
      priority: 'high'
    });

    // Ожидание результата из распределенной очереди
    return await this.waitForResult(taskId);
  }

  private async waitForResult(taskId: string): Promise<User> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Timeout waiting for task ${taskId}`));
      }, 30000);

      // Проверка результата в распределенном кеше
      const checkResult = async () => {
        const result = await this.redisClient.get(`result:${taskId}`);
        if (result) {
          clearTimeout(timeout);
          resolve(JSON.parse(result));
        } else {
          setTimeout(checkResult, 100);
        }
      };

      checkResult();
    });
  }
}

// Кластерный подход в Node.js
if (Cluster.isMaster) {
  const numWorkers = os.cpus().length;

  console.log(`Master process ${process.pid} is running`);

  // Создание рабочих процессов
  for (let i = 0; i < numWorkers; i++) {
    Cluster.fork();
  }

  Cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    Cluster.fork(); // Перезапуск упавшего процесса
  });
} else {
  // Рабочий процесс
  const app = new DistributedUserService();
  
  // Обработка запросов в рабочем процессе
  console.log(`Worker ${process.pid} started`);
  
  // Запуск сервера или обработчика задач
  app.start();
}
```

## Стратегии масштабирования в TypeScript-приложениях

### 1. Масштабирование на уровне API

```typescript
// Использование Express с кластеризацией
import express from 'express';
import cluster from 'cluster';
import { cpus } from 'os';

class ScalableApiServer {
  private app: express.Application;

  constructor() {
    this.app = express();
    this.setupRoutes();
  }

  private setupRoutes(): void {
    // Маршруты API
    this.app.get('/api/users/:id', async (req, res) => {
      try {
        const userService = new UserService();
        const user = await userService.getUserById(req.params.id);
        res.json(user);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
  }

  public start(port: number = 3000): void {
    if (cluster.isMaster) {
      const numWorkers = cpus().length;
      
      console.log(`Master process ${process.pid} is running`);
      
      // Создание рабочих процессов
      for (let i = 0; i < numWorkers; i++) {
        cluster.fork();
      }
      
      cluster.on('exit', (worker) => {
        console.log(`Worker ${worker.process.pid} died. Restarting...`);
        cluster.fork();
      });
    } else {
      // Рабочий процесс
      this.app.listen(port, () => {
        console.log(`Worker ${process.pid} listening on port ${port}`);
      });
    }
  }
}
```

### 2. Масштабирование баз данных

```typescript
// Пример шардинга данных
class ShardedUserRepository implements IUserRepository {
  private shards: Map<string, DatabaseConnection>;
  private shardSelector: IShardSelector;

  constructor() {
    this.shards = new Map();
    this.shardSelector = new HashBasedShardSelector();
    
    // Инициализация соединений с разными шардами
    for (let i = 0; i < 4; i++) {
      this.shards.set(
        `shard-${i}`, 
        new DatabaseConnection({
          host: `db-shard-${i}.example.com`,
          port: 5432
        })
      );
    }
  }

  async findById(userId: string): Promise<User | null> {
    const shardKey = this.shardSelector.selectShard(userId);
    const connection = this.shards.get(shardKey);
    
    if (!connection) {
      throw new Error(`No shard found for key: ${shardKey}`);
    }

    return await connection.query<User>(
      'SELECT * FROM users WHERE id = $1', 
      [userId]
    );
  }

  async save(user: User): Promise<User> {
    const shardKey = this.shardSelector.selectShard(user.id);
    const connection = this.shards.get(shardKey);
    
    if (!connection) {
      throw new Error(`No shard found for key: ${shardKey}`);
    }

    const result = await connection.query<User>(
      'INSERT INTO users (id, name, email) VALUES ($1, $2, $3) RETURNING *',
      [user.id, user.name, user.email]
    );

    return result[0];
  }
}
```

### 3. Масштабирование с использованием микросервисов

```typescript
// Пример микросервисной архитектуры
interface IUserServiceClient {
  getUserById(id: string): Promise<User | null>;
  createUser(userData: UserData): Promise<User>;
}

class UserServiceClient implements IUserServiceClient {
  private httpClient: AxiosInstance;

  constructor() {
    this.httpClient = axios.create({
      baseURL: process.env.USER_SERVICE_URL || 'http://user-service:3000',
      timeout: 5000
    });
  }

  async getUserById(id: string): Promise<User | null> {
    try {
      const response = await this.httpClient.get(`/users/${id}`);
      return response.data;
    } catch (error) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  async createUser(userData: UserData): Promise<User> {
    const response = await this.httpClient.post('/users', userData);
    return response.data;
  }
}
```

## Выбор стратегии масштабирования

### Когда использовать вертикальное масштабирование:

- Маленькие и средние приложения
- Ограниченный бюджет на инфраструктуру
- Простые архитектуры
- Приложения с высокими требованиями к вычислительной мощности

### Когда использовать горизонтальное масштабирование:

- Высоконагруженные приложения
- Необходимость высокой доступности
- Переменная нагрузка
- Долгосрочные проекты с планами роста

## Практические рекомендации

### 1. Мониторинг и измерение

```typescript
// Пример метрик для принятия решений о масштабировании
class MetricsCollector {
  private metrics: Map<string, number[]> = new Map();

  recordMetric(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    const values = this.metrics.get(name)!;
    values.push(value);
    
    // Ограничение размера истории метрик
    if (values.length > 1000) {
      values.shift();
    }
  }

  getAverageMetric(name: string): number {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) {
      return 0;
    }
    
    return values.reduce((sum, value) => sum + value, 0) / values.length;
  }

  shouldScaleUp(): boolean {
    const avgCpu = this.getAverageMetric('cpu_usage');
    const avgMemory = this.getAverageMetric('memory_usage');
    
    // Решение о вертикальном масштабировании
    return avgCpu > 80 || avgMemory > 80;
  }

  shouldScaleOut(): boolean {
    const avgResponseTime = this.getAverageMetric('response_time');
    const requestCount = this.getAverageMetric('requests_per_second');
    
    // Решение о горизонтальном масштабировании
    return avgResponseTime > 1000 || requestCount > 1000;
  }
}
```

### 2. Автоматическое масштабирование

```typescript
// Пример автоматического масштабирования
class AutoScaler {
  constructor(
    private metricsCollector: MetricsCollector,
    private clusterManager: ClusterManager
  ) {}

  async checkAndScale(): Promise<void> {
    if (this.metricsCollector.shouldScaleUp()) {
      await this.scaleUp();
    } else if (this.metricsCollector.shouldScaleOut()) {
      await this.scaleOut();
    }
  }

  private async scaleUp(): Promise<void> {
    console.log('Scaling up resources...');
    // Логика увеличения ресурсов текущего узла
  }

  private async scaleOut(): Promise<void> {
    console.log('Scaling out by adding more workers...');
    await this.clusterManager.addWorker();
  }
}
```

## Заключение

Выбор между горизонтальным и вертикальным масштабированием зависит от конкретных требований приложения, бюджета и ожидаемой нагрузки. Часто применяется гибридный подход, когда сначала используется вертикальное масштабирование, а затем добавляется горизонтальное.

Следующие темы: [[Архитектура-для-масштабирования]], [[Масштабирование-компонентов]], [[Управление-состоянием-при-масштабировании]], [[Оптимизация-производительности]]