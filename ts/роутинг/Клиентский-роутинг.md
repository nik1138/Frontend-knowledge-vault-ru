---
aliases: [Клиентский роутинг, SPA роутинг]
tags: [routing, typescript, frontend]
---

# Клиентский роутинг

## Обзор

Клиентский роутинг (Client-side routing) — это механизм маршрутизации, при котором навигация между страницами происходит на стороне клиента (браузера) без перезагрузки страницы. Это основа современных одностраничных приложений (SPA).

## Принцип работы

Клиентский роутинг использует API History браузера для изменения URL без перезапроса сервера. Приложение обрабатывает изменения URL и отображает соответствующий компонент, не перезагружая всю страницу.

### API History

- `history.pushState()` — добавляет новую запись в историю браузера
- `history.replaceState()` — изменяет текущую запись в истории
- `window.onpopstate` — событие при навигации (назад/вперед)

## Преимущества

- **Плавность навигации**: нет перезагрузки страницы
- **Производительность**: загрузка только необходимых данных
- **UX**: более приложение похоже на нативное
- **Кэширование**: возможность кэшировать компоненты и данные

## Недостатки

- **SEO сложности**: требует дополнительной настройки для индексации
- **Инициализация**: первоначальная загрузка может быть медленнее
- **Безопасность**: необходимость валидации на клиенте и сервере

## Основные концепции

### Роуты

```typescript
interface Route {
  path: string;
  component: React.ComponentType | Vue.Component | any;
  exact?: boolean;
  guard?: (to: Route, from: Route) => boolean | Promise<boolean>;
}
```

### Параметры маршрута

- `:id` — обязательный параметр
- `/:id?` — опциональный параметр
- `*` — подстановочный символ

### Навигация

- Программная навигация: `router.push('/path')`
- Декларативная навигация: `<Link to="/path">`

## Практические примеры

### Простая реализация роутера

```typescript
class SimpleRouter {
  private routes: Map<string, () => Promise<void>> = new Map();
  private currentPath: string = window.location.pathname;

  constructor() {
    window.addEventListener('popstate', this.handlePopState.bind(this));
  }

  public addRoute(path: string, handler: () => Promise<void>): void {
    this.routes.set(path, handler);
  }

  public async navigate(path: string): Promise<void> {
    window.history.pushState({}, '', path);
    await this.handleRoute(path);
  }

  private handlePopState(): void {
    const path = window.location.pathname;
    this.handleRoute(path);
  }

  private async handleRoute(path: string): Promise<void> {
    const handler = this.routes.get(path) || this.routes.get('/404');
    if (handler) {
      await handler();
    }
  }
}
```

### Роутинг с параметрами

```typescript
interface RouteMatch {
  path: string;
  params: Record<string, string>;
}

class ParamRouter {
  public matchRoute(path: string, route: string): RouteMatch | null {
    const routeRegex = this.convertToRegex(route);
    const match = path.match(routeRegex);
    
    if (match) {
      const params = this.extractParams(route, path);
      return { path: route, params };
    }
    
    return null;
  }

  private convertToRegex(route: string): RegExp {
    const escapedRoute = route.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const paramRegex = escapedRoute.replace(/:(\w+)/g, '([^/]+)');
    return new RegExp(`^${paramRegex}$`);
  }

  private extractParams(route: string, path: string): Record<string, string> {
    const routeParts = route.split('/');
    const pathParts = path.split('/');
    const params: Record<string, string> = {};

    routeParts.forEach((part, index) => {
      if (part.startsWith(':')) {
        const paramName = part.substring(1);
        params[paramName] = pathParts[index];
      }
    });

    return params;
  }
}
```

## Лучшие практики

### Структура роутов

```typescript
const routes = [
  {
    path: '/',
    component: Home,
    exact: true
  },
  {
    path: '/users',
    component: UsersList,
    children: [
      {
        path: ':id',
        component: UserProfile
      }
    ]
  },
  {
    path: '/admin',
    component: AdminPanel,
    guard: requireAuth
  }
];
```

### Защита маршрутов

```typescript
interface Guard {
  (to: Route, from: Route, next: (allowed: boolean) => void): void;
}

const requireAuth: Guard = (to, from, next) => {
  const isAuthenticated = checkAuth();
  next(isAuthenticated);
};

const roleGuard: (role: string) => Guard = (role) => (to, from, next) => {
  const userRole = getUserRole();
  next(userRole === role);
};
```

###_lazy loading_

```typescript
const routes = [
  {
    path: '/dashboard',
    component: () => import('./Dashboard.tsx')
  },
  {
    path: '/settings',
    component: () => import('./Settings.tsx')
  }
];
```

## Обработка ошибок

```typescript
class ErrorHandler {
  public handle(error: Error, route: string): void {
    console.error(`Routing error on ${route}:`, error);
    // Логирование ошибки
    this.logError(error, route);
    // Перенаправление на страницу ошибки
    router.navigate('/error');
  }

  private logError(error: Error, route: string): void {
    // Отправка ошибки в систему мониторинга
    console.log('Logging error to monitoring service:', { error, route });
  }
}
```

## Типичные проблемы и решения

### SEO проблемы

- Использовать Server-Side Rendering (SSR) или Static Site Generation (SSG)
- Реализовать предварительную загрузку контента
- Настроить meta теги динамически

### Состояние приложения

- Сохранять состояние при переходах между роутами
- Управлять жизненным циклом компонентов
- Очищать подписки и таймеры при размонтировании

### Навигация без перезагрузки

- Обработка навигации по истории браузера
- Обеспечение согласованности состояния
- Управление фокусом и скроллом

## Сравнение с серверным роутингом

| Клиентский роутинг | Серверный роутинг |
|-------------------|------------------|
| Быстрая навигация | Полная перезагрузка |
| Лучший UX | Простая реализация |
| Сложности с SEO | Лучшая индексация |
| Кэширование данных | Без кэширования |

## Заключение

Клиентский роутинг — ключевой элемент современных веб-приложений, обеспечивающий плавную навигацию и улучшенный пользовательский опыт. При правильной реализации он позволяет создавать приложения, похожие на нативные.

См. также: [[Серверный-роутинг]], [[Роутинг-в-React]], [[Роутинг-в-Vue]], [[Роутинг-в-Angular]]