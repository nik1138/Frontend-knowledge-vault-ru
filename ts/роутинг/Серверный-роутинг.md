---
aliases: [Серверный роутинг, Backend routing, API routing]
tags: [routing, typescript, backend, express, nodejs]
---

# Серверный роутинг

## Обзор

Серверный роутинг — это механизм маршрутизации на стороне сервера, который определяет, как приложение отвечает на определенные URL-адреса или запросы клиента. Это основа для обработки HTTP-запросов в веб-приложениях.

## Принцип работы

Серверный роутинг анализирует HTTP-запрос (метод и путь) и направляет его к соответствующему обработчику. Каждый маршрут может иметь несколько middleware функций, которые выполняются последовательно.

## Основные концепции

### Методы HTTP

- `GET` — получение данных
- `POST` — создание данных
- `PUT` — обновление данных
- `DELETE` — удаление данных
- `PATCH` — частичное обновление

### Параметры маршрута

- `req.params` — параметры из URL (`/users/:id`)
- `req.query` — параметры из строки запроса (`?page=1&limit=10`)
- `req.body` — тело запроса (для POST, PUT)

## Популярные фреймворки

### Express.js

```typescript
import express, { Request, Response, NextFunction } from 'express';
import { body, validationResult } from 'express-validator';

const app = express();

// Middleware для парсинга JSON
app.use(express.json());

// Простой маршрут
app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Hello World!' });
});

// Маршрут с параметрами
app.get('/users/:id', (req: Request, res: Response) => {
  const userId = req.params.id;
  res.json({ userId });
});

// Маршрут с валидацией
app.post('/users', [
  body('email').isEmail(),
  body('password').isLength({ min: 6 })
], (req: Request, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  
  // Обработка валидных данных
  res.json({ message: 'User created successfully' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### Koa.js

```typescript
import Koa from 'koa';
import Router from '@koa/router';

const app = new Koa();
const router = new Router();

// Простой маршрут
router.get('/', (ctx) => {
  ctx.body = { message: 'Hello World!' };
});

// Маршрут с параметрами
router.get('/users/:id', (ctx) => {
  const userId = ctx.params.id;
  ctx.body = { userId };
});

// Вложенные маршруты
router.get('/users/:userId/posts/:postId', (ctx) => {
  const { userId, postId } = ctx.params;
  ctx.body = { userId, postId };
});

app.use(router.routes());
app.listen(3000);
```

### Fastify

```typescript
import fastify from 'fastify';
import type { FastifyInstance } from 'fastify';

const server: FastifyInstance = fastify({ logger: true });

// Простой маршрут
server.get('/', async (request, reply) => {
  return { message: 'Hello World!' };
});

// Маршрут с параметрами и схемой
server.get<{
  Params: { id: string };
  Querystring: { includeDetails: boolean };
}>('/users/:id', async (request, reply) => {
  const { id } = request.params;
  const { includeDetails } = request.query;
  
  // Логика обработки
  return { id, includeDetails };
});

// Маршрут с телом запроса
server.post('/users', {
  schema: {
    body: {
      type: 'object',
      required: ['email', 'password'],
      properties: {
        email: { type: 'string', format: 'email' },
        password: { type: 'string', minLength: 6 }
      }
    }
  }
}, async (request, reply) => {
  // Обработка запроса
  return { message: 'User created' };
});

server.listen({ port: 3000 }, (err, address) => {
  if (err) {
    server.log.error(err);
    process.exit(1);
  }
  console.log(`Server listening at ${address}`);
});
```

## Типичные паттерны

### REST API маршруты

```typescript
// GET /api/users - получить список пользователей
// GET /api/users/:id - получить пользователя по ID
// POST /api/users - создать нового пользователя
// PUT /api/users/:id - обновить пользователя
// DELETE /api/users/:id - удалить пользователя

const userRoutes = express.Router();

userRoutes.get('/', getUsers);
userRoutes.get('/:id', getUserById);
userRoutes.post('/', validateUser, createUser);
userRoutes.put('/:id', validateUser, updateUser);
userRoutes.delete('/:id', deleteUser);

app.use('/api/users', userRoutes);
```

### Middleware цепочки

```typescript
// Аутентификация
const authenticate = (req: Request, res: Response, next: NextFunction) => {
  // Проверка токена
  const token = req.headers.authorization?.split(' ')[1];
  if (token) {
    // Проверка токена
    next();
  } else {
    res.status(401).json({ error: 'Unauthorized' });
  }
};

// Авторизация
const authorize = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.role;
    if (userRole && roles.includes(userRole)) {
      next();
    } else {
      res.status(403).json({ error: 'Forbidden' });
    }
  };
};

// Применение middleware
app.get('/admin', authenticate, authorize(['admin']), (req, res) => {
  res.json({ message: 'Admin panel' });
});
```

## Обработка ошибок

```typescript
// Глобальный обработчик ошибок
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// Обработчик 404
app.use((req: Request, res: Response) => {
  res.status(404).json({ error: 'Route not found' });
});
```

### Кастомные ошибки

```typescript
class CustomError extends Error {
  public statusCode: number;
  
  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.name = this.constructor.name;
  }
}

// Использование кастомной ошибки
const validateUser = (req: Request, res: Response, next: NextFunction) => {
  if (!req.body.email) {
    throw new CustomError('Email is required', 400);
  }
  next();
};

// Глобальный обработчик для кастомных ошибок
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof CustomError) {
    return res.status(err.statusCode).json({ error: err.message });
  }
  
  // Обработка других ошибок
  res.status(500).json({ error: 'Internal server error' });
});
```

## Лучшие практики

### Организация маршрутов

```typescript
// routes/index.ts
import { Router } from 'express';
import userRoutes from './users';
import postRoutes from './posts';

const router = Router();

router.use('/users', userRoutes);
router.use('/posts', postRoutes);

export default router;

// app.ts
import routes from './routes';
app.use('/api', routes);
```

### Валидация данных

```typescript
import { body, validationResult, query } from 'express-validator';

const userValidationRules = () => [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }).trim(),
  body('name').notEmpty().trim()
];

const validate = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};

app.post('/users', userValidationRules(), validate, createUserHandler);
```

### Логирование

```typescript
import morgan from 'morgan';

// Логирование всех запросов
app.use(morgan('combined'));

// Кастомное логирование
app.use((req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.path} ${res.statusCode} ${duration}ms`);
  });
  
  next();
});
```

## Безопасность

### Защита от XSS

```typescript
import helmet from 'helmet';

app.use(helmet());

// Экранирование вывода
app.get('/user/:id', (req: Request, res: Response) => {
  const { id } = req.params;
  // Всегда экранируйте пользовательский ввод перед выводом
  res.json({ id: escapeHtml(id) });
});

function escapeHtml(text: string): string {
  const map: { [key: string]: string } = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  
  return text.replace(/[&<>"']/g, (m) => map[m]);
}
```

### Rate limiting

```typescript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // ограничение 100 запросов за windowMs
});

app.use(limiter);
```

## Сравнение с клиентским роутингом

| Серверный роутинг | Клиентский роутинг |
|------------------|-------------------|
| Обработка на сервере | Обработка в браузере |
| Перезагрузка страницы | Без перезагрузки |
| Лучшая SEO поддержка | Требует дополнительных решений |
| Простая реализация | Более сложная реализация |

## Заключение

Серверный роутинг — фундаментальная часть любого веб-приложения, обеспечивающая правильную обработку HTTP-запросов. При правильной реализации он обеспечивает безопасность, производительность и масштабируемость приложения.

См. также: [[Клиентский-роутинг]], [[Роутинг-в-React]], [[Роутинг-в-Vue]], [[Роутинг-в-Angular]]