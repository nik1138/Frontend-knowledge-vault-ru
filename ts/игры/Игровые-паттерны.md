---
aliases: [Игровые паттерны проектирования, Паттерны для игр]
tags: [typescript, game-development, design-patterns, architecture]
---

# Игровые паттерны

Игровые паттерны проектирования — это специфические архитектурные и программные решения, которые помогают создавать масштабируемые, поддерживаемые и эффективные игры. Эти паттерны учитывают специфику игровой разработки, включая циклы обновления, управление состоянием и взаимодействие между игровыми объектами.

## Паттерны архитектуры

### Entity-Component-System (ECS)

ECS — это архитектурный паттерн, который разделяет данные (компоненты) и логику (системы) для гибкого управления игровыми объектами.

```typescript
// Компоненты
interface IComponent {
    id: string;
}

class PositionComponent implements IComponent {
    id = 'position';
    x: number = 0;
    y: number = 0;
    
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

class VelocityComponent implements IComponent {
    id = 'velocity';
    vx: number = 0;
    vy: number = 0;
    
    constructor(vx: number, vy: number) {
        this.vx = vx;
        this.vy = vy;
    }
}

class RenderComponent implements IComponent {
    id = 'render';
    texture: string;
    
    constructor(texture: string) {
        this.texture = texture;
    }
}

// Сущность
class Entity {
    id: string;
    components: Map<string, IComponent> = new Map();
    
    constructor(id: string) {
        this.id = id;
    }
    
    addComponent(component: IComponent): Entity {
        this.components.set(component.id, component);
        return this;
    }
    
    getComponent<T extends IComponent>(id: string): T | undefined {
        return this.components.get(id) as T;
    }
}

// Система
abstract class System {
    abstract update(entities: Entity[], deltaTime: number): void;
}

class MovementSystem extends System {
    update(entities: Entity[], deltaTime: number): void {
        for (const entity of entities) {
            const position = entity.getComponent<PositionComponent>('position');
            const velocity = entity.getComponent<VelocityComponent>('velocity');
            
            if (position && velocity) {
                position.x += velocity.vx * deltaTime;
                position.y += velocity.vy * deltaTime;
            }
        }
    }
}
```

### Game Loop

Классический паттерн цикла обновления игры:

```typescript
class GameLoop {
    private running: boolean = false;
    private lastTime: number = 0;
    
    start() {
        this.running = true;
        this.lastTime = performance.now();
        this.gameLoop(this.lastTime);
    }
    
    private gameLoop(currentTime: number) {
        if (!this.running) return;
        
        const deltaTime = (currentTime - this.lastTime) / 1000; // в секундах
        this.lastTime = currentTime;
        
        this.update(deltaTime);
        this.render();
        
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    private update(deltaTime: number) {
        // Обновление логики игры
        this.movementSystem.update(this.entities, deltaTime);
        this.collisionSystem.update(this.entities, deltaTime);
    }
    
    private render() {
        // Рендеринг
        this.renderer.render(this.entities);
    }
}
```

## Паттерны поведения

### State Pattern (Состояние)

Полезен для управления состояниями игровых объектов:

```typescript
interface IState {
    enter(entity: Entity): void;
    execute(entity: Entity, deltaTime: number): void;
    exit(entity: Entity): void;
}

class IdleState implements IState {
    enter(entity: Entity) {
        console.log('Сущность в состоянии ожидания');
    }
    
    execute(entity: Entity, deltaTime: number) {
        // Логика ожидания
    }
    
    exit(entity: Entity) {
        // Очистка при выходе
    }
}

class WalkingState implements IState {
    enter(entity: Entity) {
        console.log('Сущность идет');
    }
    
    execute(entity: Entity, deltaTime: number) {
        // Логика ходьбы
        const velocity = entity.getComponent<VelocityComponent>('velocity');
        if (velocity) {
            velocity.vx = 100;
        }
    }
    
    exit(entity: Entity) {
        const velocity = entity.getComponent<VelocityComponent>('velocity');
        if (velocity) {
            velocity.vx = 0;
        }
    }
}

class StateMachine {
    private currentState: IState | null = null;
    
    changeState(entity: Entity, newState: IState) {
        if (this.currentState) {
            this.currentState.exit(entity);
        }
        
        this.currentState = newState;
        this.currentState.enter(entity);
    }
    
    update(entity: Entity, deltaTime: number) {
        if (this.currentState) {
            this.currentState.execute(entity, deltaTime);
        }
    }
}
```

### Command Pattern (Команда)

Для обработки пользовательского ввода:

```typescript
interface ICommand {
    execute(): void;
    undo(): void;
}

class MoveCommand implements ICommand {
    private entity: Entity;
    private previousX: number;
    private previousY: number;
    private newX: number;
    private newY: number;
    
    constructor(entity: Entity, deltaX: number, deltaY: number) {
        this.entity = entity;
        const position = entity.getComponent<PositionComponent>('position')!;
        this.previousX = position.x;
        this.previousY = position.y;
        this.newX = position.x + deltaX;
        this.newY = position.y + deltaY;
    }
    
    execute() {
        const position = this.entity.getComponent<PositionComponent>('position')!;
        position.x = this.newX;
        position.y = this.newY;
    }
    
    undo() {
        const position = this.entity.getComponent<PositionComponent>('position')!;
        position.x = this.previousX;
        position.y = this.previousY;
    }
}

class InputHandler {
    private commands: ICommand[] = [];
    
    handleInput(entity: Entity, input: string) {
        let command: ICommand | null = null;
        
        switch(input) {
            case 'move-up':
                command = new MoveCommand(entity, 0, -10);
                break;
            case 'move-down':
                command = new MoveCommand(entity, 0, 10);
                break;
            case 'move-left':
                command = new MoveCommand(entity, -10, 0);
                break;
            case 'move-right':
                command = new MoveCommand(entity, 10, 0);
                break;
        }
        
        if (command) {
            command.execute();
            this.commands.push(command);
        }
    }
}
```

## Паттерны управления объектами

### Object Pool

Для эффективного управления игровыми объектами:

```typescript
class ObjectPool<T> {
    private objects: T[] = [];
    private factory: () => T;
    
    constructor(factory: () => T, initialSize: number = 10) {
        this.factory = factory;
        for (let i = 0; i < initialSize; i++) {
            this.objects.push(this.factory());
        }
    }
    
    acquire(): T {
        if (this.objects.length > 0) {
            return this.objects.pop()!;
        }
        return this.factory();
    }
    
    release(obj: T) {
        // Сбросить состояние объекта перед возвратом в пул
        this.resetObject(obj);
        this.objects.push(obj);
    }
    
    private resetObject(obj: T) {
        // Сбросить состояние объекта (например, позицию, здоровье и т.д.)
        if (obj.hasOwnProperty('active')) {
            (obj as any).active = false;
        }
    }
}

// Использование пула для пуль
class Bullet {
    x: number = 0;
    y: number = 0;
    active: boolean = false;
    
    reset() {
        this.x = 0;
        this.y = 0;
        this.active = false;
    }
}

const bulletPool = new ObjectPool(() => new Bullet(), 20);

function shoot() {
    const bullet = bulletPool.acquire();
    bullet.active = true;
    // Установить начальную позицию пули
}
```

### Observer Pattern (Наблюдатель)

Для уведомления о событиях в игре:

```typescript
interface IObserver {
    notify(event: GameEvent): void;
}

class GameEvent {
    type: string;
    data: any;
    
    constructor(type: string, data: any) {
        this.type = type;
        this.data = data;
    }
}

class EventManager {
    private observers: Map<string, IObserver[]> = new Map();
    
    subscribe(eventType: string, observer: IObserver) {
        if (!this.observers.has(eventType)) {
            this.observers.set(eventType, []);
        }
        this.observers.get(eventType)!.push(observer);
    }
    
    unsubscribe(eventType: string, observer: IObserver) {
        if (this.observers.has(eventType)) {
            const index = this.observers.get(eventType)!.indexOf(observer);
            if (index > -1) {
                this.observers.get(eventType)!.splice(index, 1);
            }
        }
    }
    
    notify(event: GameEvent) {
        if (this.observers.has(event.type)) {
            this.observers.get(event.type)!.forEach(observer => {
                observer.notify(event);
            });
        }
    }
}

// Пример использования
class ScoreDisplay implements IObserver {
    notify(event: GameEvent) {
        if (event.type === 'score-changed') {
            console.log(`Новый счет: ${event.data.score}`);
        }
    }
}

const eventManager = new EventManager();
const scoreDisplay = new ScoreDisplay();
eventManager.subscribe('score-changed', scoreDisplay);

// Уведомление о событии
eventManager.notify(new GameEvent('score-changed', { score: 100 }));
```

## Паттерны управления состоянием игры

### Game State Manager

```typescript
enum GameState {
    MENU,
    PLAYING,
    PAUSED,
    GAME_OVER
}

abstract class BaseGameState {
    abstract enter(): void;
    abstract update(deltaTime: number): void;
    abstract render(): void;
    abstract exit(): void;
}

class MenuState extends BaseGameState {
    enter() {
        console.log('Вход в меню');
    }
    
    update(deltaTime: number) {}
    
    render() {}
    
    exit() {
        console.log('Выход из меню');
    }
}

class PlayingState extends BaseGameState {
    enter() {
        console.log('Начало игры');
    }
    
    update(deltaTime: number) {
        // Обновление игровой логики
    }
    
    render() {
        // Рендеринг игры
    }
    
    exit() {
        console.log('Конец игры');
    }
}

class GameStateManager {
    private currentState: BaseGameState | null = null;
    private states: Map<GameState, BaseGameState> = new Map();
    
    registerState(stateType: GameState, state: BaseGameState) {
        this.states.set(stateType, state);
    }
    
    changeState(newStateType: GameState) {
        if (this.currentState) {
            this.currentState.exit();
        }
        
        this.currentState = this.states.get(newStateType) || null;
        
        if (this.currentState) {
            this.currentState.enter();
        }
    }
    
    update(deltaTime: number) {
        if (this.currentState) {
            this.currentState.update(deltaTime);
        }
    }
    
    render() {
        if (this.currentState) {
            this.currentState.render();
        }
    }
}
```

## Паттерны AI

### Finite State Machine (FSM) для AI

```typescript
class AIEntity {
    stateMachine: StateMachine;
    position: PositionComponent;
    
    constructor() {
        this.stateMachine = new StateMachine();
        this.position = new PositionComponent(0, 0);
    }
    
    update(deltaTime: number) {
        this.stateMachine.update(this, deltaTime);
    }
}

class PatrolState implements IState {
    private waypoints: {x: number, y: number}[] = [];
    private currentWaypointIndex: number = 0;
    
    constructor(waypoints: {x: number, y: number}[]) {
        this.waypoints = waypoints;
    }
    
    enter(entity: AIEntity) {
        console.log('AI начинает патрулирование');
    }
    
    execute(entity: AIEntity, deltaTime: number) {
        if (this.waypoints.length === 0) return;
        
        const target = this.waypoints[this.currentWaypointIndex];
        const pos = entity.position;
        
        // Простое движение к точке
        const dx = target.x - pos.x;
        const dy = target.y - pos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 5) { // Достигли точки
            this.currentWaypointIndex = (this.currentWaypointIndex + 1) % this.waypoints.length;
        } else {
            // Двигаемся к точке
            pos.x += (dx / distance) * 50 * deltaTime;
            pos.y += (dy / distance) * 50 * deltaTime;
        }
    }
    
    exit(entity: AIEntity) {}
}
```

## Ресурсы

- [Game Programming Patterns](https://gameprogrammingpatterns.com/)
- [[Phaser]]
- [[PixiJS]]
- [[Физика-в-играх]]
- [[Анимации-в-играх]]

## См. также

- [[Паттерны проектирования]]
- [[Архитектура TypeScript приложений]]
- [[TypeScript для игр]]