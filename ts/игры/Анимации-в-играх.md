---
aliases: [Анимации в играх, Игровые анимации]
tags: [typescript, game-development, animation, sprites]
---

# Анимации в играх

Анимации в играх — это ключевой элемент, который придает интерактивность, визуальную привлекательность и ощущение жизни игровым объектам. В этой статье рассмотрим различные подходы к созданию анимаций в играх с использованием TypeScript.

## Типы игровых анимаций

### Спрайтовые анимации (Sprite Animation)

Самый распространенный тип анимации, основанный на последовательности изображений:

```typescript
class SpriteAnimation {
    frames: HTMLImageElement[];
    currentFrame: number = 0;
    frameTime: number; // Время на кадр в миллисекундах
    lastFrameTime: number = 0;
    loop: boolean;
    
    constructor(frames: HTMLImageElement[], frameTime: number = 100, loop: boolean = true) {
        this.frames = frames;
        this.frameTime = frameTime;
        this.loop = loop;
    }
    
    update(deltaTime: number, currentTime: number) {
        if (currentTime - this.lastFrameTime >= this.frameTime) {
            this.currentFrame++;
            
            if (this.currentFrame >= this.frames.length) {
                if (this.loop) {
                    this.currentFrame = 0;
                } else {
                    this.currentFrame = this.frames.length - 1;
                }
            }
            
            this.lastFrameTime = currentTime;
        }
    }
    
    getCurrentFrame(): HTMLImageElement {
        return this.frames[this.currentFrame];
    }
    
    reset() {
        this.currentFrame = 0;
        this.lastFrameTime = 0;
    }
}
```

### Анимации с использованием спрайт-атласов

```typescript
class AtlasAnimation {
    atlas: HTMLImageElement;
    frameWidth: number;
    frameHeight: number;
    frameCount: number;
    currentFrame: number = 0;
    frameTime: number;
    lastFrameTime: number = 0;
    framesPerRow: number;
    
    constructor(
        atlas: HTMLImageElement,
        frameWidth: number,
        frameHeight: number,
        frameCount: number,
        frameTime: number = 100,
        framesPerRow: number
    ) {
        this.atlas = atlas;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.frameCount = frameCount;
        this.frameTime = frameTime;
        this.framesPerRow = framesPerRow;
    }
    
    update(deltaTime: number, currentTime: number) {
        if (currentTime - this.lastFrameTime >= this.frameTime) {
            this.currentFrame = (this.currentFrame + 1) % this.frameCount;
            this.lastFrameTime = currentTime;
        }
    }
    
    draw(ctx: CanvasRenderingContext2D, x: number, y: number) {
        const frameX = (this.currentFrame % this.framesPerRow) * this.frameWidth;
        const frameY = Math.floor(this.currentFrame / this.framesPerRow) * this.frameHeight;
        
        ctx.drawImage(
            this.atlas,
            frameX, frameY, this.frameWidth, this.frameHeight,
            x, y, this.frameWidth, this.frameHeight
        );
    }
}
```

## Система анимаций для игровых объектов

```typescript
interface IAnimationState {
    name: string;
    animation: SpriteAnimation | AtlasAnimation;
    isPlaying: boolean;
    loop: boolean;
}

class AnimatedEntity {
    x: number;
    y: number;
    animations: Map<string, IAnimationState> = new Map();
    currentAnimation: string | null = null;
    
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    
    addAnimation(name: string, animation: SpriteAnimation | AtlasAnimation, loop: boolean = true) {
        this.animations.set(name, {
            name,
            animation,
            isPlaying: false,
            loop
        });
    }
    
    playAnimation(name: string) {
        if (this.currentAnimation === name) return;
        
        // Остановить текущую анимацию
        if (this.currentAnimation) {
            const current = this.animations.get(this.currentAnimation);
            if (current) {
                current.isPlaying = false;
            }
        }
        
        // Запустить новую анимацию
        const animation = this.animations.get(name);
        if (animation) {
            animation.isPlaying = true;
            animation.animation.reset();
            this.currentAnimation = name;
        }
    }
    
    update(deltaTime: number, currentTime: number) {
        if (this.currentAnimation) {
            const animation = this.animations.get(this.currentAnimation);
            if (animation && animation.isPlaying) {
                animation.animation.update(deltaTime, currentTime);
            }
        }
    }
    
    draw(ctx: CanvasRenderingContext2D) {
        if (this.currentAnimation) {
            const animation = this.animations.get(this.currentAnimation);
            if (animation && animation.animation instanceof AtlasAnimation) {
                animation.animation.draw(ctx, this.x, this.y);
            }
        }
    }
}
```

## Анимации с использованием интерполяции

### Плавные переходы между состояниями

```typescript
class InterpolatedAnimation {
    startX: number;
    startY: number;
    endX: number;
    endY: number;
    duration: number; // в миллисекундах
    startTime: number;
    currentX: number;
    currentY: number;
    
    constructor(startX: number, startY: number, endX: number, endY: number, duration: number) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.duration = duration;
        this.currentX = startX;
        this.currentY = startY;
    }
    
    start(currentTime: number) {
        this.startTime = currentTime;
    }
    
    update(currentTime: number): boolean { // Возвращает true, если анимация завершена
        const elapsed = currentTime - this.startTime;
        const progress = Math.min(elapsed / this.duration, 1);
        
        // Использование easing функции (линейная интерполяция)
        this.currentX = this.startX + (this.endX - this.startX) * progress;
        this.currentY = this.startY + (this.endY - this.startY) * progress;
        
        return progress >= 1;
    }
    
    getCurrentPosition(): { x: number, y: number } {
        return { x: this.currentX, y: this.currentY };
    }
}

// Пример с easing функцией
class EasingAnimation extends InterpolatedAnimation {
    easingFunction: (t: number) => number;
    
    constructor(
        startX: number, 
        startY: number, 
        endX: number, 
        endY: number, 
        duration: number,
        easingFunction: (t: number) => number = EasingAnimation.easeInOutQuad
    ) {
        super(startX, startY, endX, endY, duration);
        this.easingFunction = easingFunction;
    }
    
    update(currentTime: number): boolean {
        const elapsed = currentTime - this.startTime;
        let progress = Math.min(elapsed / this.duration, 1);
        
        // Применение easing функции
        progress = this.easingFunction(progress);
        
        this.currentX = this.startX + (this.endX - this.startX) * progress;
        this.currentY = this.startY + (this.endY - this.startY) * progress;
        
        return progress >= 1;
    }
    
    // Стандартные easing функции
    static easeInOutQuad(t: number): number {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    
    static easeOutBounce(t: number): number {
        const n1 = 7.5625;
        const d1 = 2.75;
        
        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }
}
```

## Анимации с использованием CSS и Web Animations API

```typescript
class CSSAnimation {
    element: HTMLElement;
    animation: Animation | null = null;
    
    constructor(element: HTMLElement) {
        this.element = element;
    }
    
    animate(animations: KeyframeEffectInit, options: AnimationEffectTiming = {}) {
        // Отменить предыдущую анимацию
        if (this.animation) {
            this.animation.cancel();
        }
        
        // Создать новую анимацию
        const keyframes = new KeyframeEffect(this.element, animations.keyframes, options);
        this.animation = new Animation(keyframes);
        
        // Запустить анимацию
        this.animation.play();
        
        return this.animation;
    }
    
    // Пример анимации появления
    fadeIn(duration: number = 1000) {
        return this.animate({
            keyframes: [
                { opacity: 0 },
                { opacity: 1 }
            ]
        }, {
            duration,
            easing: 'ease-out'
        });
    }
    
    // Пример анимации перемещения
    slideIn(direction: 'left' | 'right' | 'up' | 'down', distance: number = 100, duration: number = 500) {
        let translateX = 0;
        let translateY = 0;
        
        switch(direction) {
            case 'left':
                translateX = -distance;
                break;
            case 'right':
                translateX = distance;
                break;
            case 'up':
                translateY = -distance;
                break;
            case 'down':
                translateY = distance;
                break;
        }
        
        return this.animate({
            keyframes: [
                { transform: `translate(${translateX}px, ${translateY}px)` },
                { transform: 'translate(0, 0)' }
            ]
        }, {
            duration,
            easing: 'ease-out'
        });
    }
}
```

## Анимации с использованием библиотек

### Tween.js

```typescript
// Пример использования Tween.js (необходима установка: npm install @tweenjs/tween.js)
import TWEEN from '@tweenjs/tween.js';

class TweenAnimation {
    object: any;
    tween: TWEEN.Tween<any> | null = null;
    
    constructor(object: any) {
        this.object = object;
    }
    
    animateTo(properties: any, duration: number = 1000, easing: Function = TWEEN.Easing.Linear.None) {
        // Отменить предыдущую анимацию
        if (this.tween) {
            this.tween.stop();
        }
        
        // Создать новую анимацию
        this.tween = new TWEEN.Tween(this.object)
            .to(properties, duration)
            .easing(easing)
            .start();
            
        return this.tween;
    }
    
    // Анимация позиции
    moveTo(x: number, y: number, duration: number = 1000) {
        return this.animateTo({ x, y }, duration, TWEEN.Easing.Quadratic.Out);
    }
    
    // Анимация прозрачности
    fadeTo(opacity: number, duration: number = 1000) {
        return this.animateTo({ opacity }, duration, TWEEN.Easing.Linear.None);
    }
    
    // Анимация масштаба
    scaleTo(scale: number, duration: number = 1000) {
        return this.animateTo({ scale }, duration, TWEEN.Easing.Elastic.Out);
    }
}

// Интеграция с игровым циклом
function animate(time: number) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
}
```

## Анимации в Phaser

```typescript
class PhaserAnimationExample extends Phaser.Scene {
    player: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;
    
    preload() {
        // Загрузка спрайт-атласа
        this.load.atlas('dude', 'assets/dude.png', 'assets/dude_atlas.json');
    }
    
    create() {
        // Создание спрайта
        this.player = this.physics.add.sprite(100, 450, 'dude');
        
        // Создание анимаций
        this.anims.create({
            key: 'left',
            frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
            frameRate: 10,
            repeat: -1
        });
        
        this.anims.create({
            key: 'turn',
            frames: [{ key: 'dude', frame: 4 }],
            frameRate: 20
        });
        
        this.anims.create({
            key: 'right',
            frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
            frameRate: 10,
            repeat: -1
        });
    }
    
    update() {
        const cursors = this.input.keyboard.createCursorKeys();
        
        if (cursors.left.isDown) {
            this.player.setVelocityX(-160);
            this.player.anims.play('left', true);
        } else if (cursors.right.isDown) {
            this.player.setVelocityX(160);
            this.player.anims.play('right', true);
        } else {
            this.player.setVelocityX(0);
            this.player.anims.play('turn');
        }
    }
}
```

## Анимации в PixiJS

```typescript
import * as PIXI from 'pixi.js';

class PixiAnimationExample {
    app: PIXI.Application;
    animatedSprite: PIXI.AnimatedSprite;
    
    constructor() {
        this.app = new PIXI.Application({ width: 800, height: 600 });
        document.body.appendChild(this.app.view);
        
        // Загрузка текстур для анимации
        this.app.loader
            .add('spritesheet', 'assets/spritesheet.json')
            .load(() => {
                this.createAnimatedSprite();
            });
    }
    
    createAnimatedSprite() {
        // Получение текстур из спрайт-атласа
        const textures = [];
        for (let i = 0; i < 4; i++) {
            textures.push(this.app.loader.resources.spritesheet.textures[`sprite${i}.png`]);
        }
        
        // Создание анимированного спрайта
        this.animatedSprite = new PIXI.AnimatedSprite(textures);
        this.animatedSprite.x = 100;
        this.animatedSprite.y = 100;
        this.animatedSprite.animationSpeed = 0.1;
        this.animatedSprite.play();
        
        this.app.stage.addChild(this.animatedSprite);
        
        // Обработка окончания анимации
        this.animatedSprite.onComplete = () => {
            console.log('Анимация завершена');
        };
    }
    
    // Создание сложной анимации с помощью ticker
    createComplexAnimation() {
        this.app.ticker.add(() => {
            // Плавное изменение свойств
            this.animatedSprite.scale.x = 1 + Math.sin(Date.now() * 0.001) * 0.1;
            this.animatedSprite.scale.y = 1 + Math.sin(Date.now() * 0.001) * 0.1;
            this.animatedSprite.rotation += 0.01;
        });
    }
}
```

## Анимации с физикой

### Анимации, взаимодействующие с физикой

```typescript
class PhysicsBasedAnimation {
    position: { x: number, y: number };
    velocity: { x: number, y: number };
    acceleration: { x: number, y: number };
    damping: number;
    
    constructor(x: number, y: number) {
        this.position = { x, y };
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.damping = 0.9;
    }
    
    applyForce(force: { x: number, y: number }) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    update(deltaTime: number) {
        // Применение ускорения к скорости
        this.velocity.x += this.acceleration.x * deltaTime;
        this.velocity.y += this.acceleration.y * deltaTime;
        
        // Применение скорости к позиции
        this.position.x += this.velocity.x * deltaTime;
        this.position.y += this.velocity.y * deltaTime;
        
        // Затухание скорости
        this.velocity.x *= this.damping;
        this.velocity.y *= this.damping;
        
        // Сброс ускорения
        this.acceleration.x = 0;
        this.acceleration.y = 0;
    }
    
    // Анимация с пружинным эффектом
    springTo(targetX: number, targetY: number, stiffness: number = 0.1) {
        const dx = targetX - this.position.x;
        const dy = targetY - this.position.y;
        
        this.applyForce({
            x: dx * stiffness,
            y: dy * stiffness
        });
    }
}
```

## Оптимизация анимаций

### Система пула анимаций

```typescript
class AnimationPool {
    private availableAnimations: SpriteAnimation[] = [];
    private allAnimations: SpriteAnimation[] = [];
    
    constructor(private frameTime: number = 100) {}
    
    getAnimation(frames: HTMLImageElement[], loop: boolean = true): SpriteAnimation {
        let animation: SpriteAnimation;
        
        if (this.availableAnimations.length > 0) {
            animation = this.availableAnimations.pop()!;
            animation.reset();
        } else {
            animation = new SpriteAnimation(frames, this.frameTime, loop);
            this.allAnimations.push(animation);
        }
        
        return animation;
    }
    
    returnAnimation(animation: SpriteAnimation) {
        animation.reset();
        this.availableAnimations.push(animation);
    }
    
    updateAll(deltaTime: number, currentTime: number) {
        for (const animation of this.allAnimations) {
            if (this.availableAnimations.indexOf(animation) === -1) {
                animation.update(deltaTime, currentTime);
            }
        }
    }
}
```

### Батчевая отрисовка анимаций

```typescript
class BatchedAnimationRenderer {
    private animations: { 
        sprite: PIXI.Sprite, 
        animation: PIXI.AnimatedSprite 
    }[] = [];
    
    addAnimation(sprite: PIXI.Sprite, animation: PIXI.AnimatedSprite) {
        this.animations.push({ sprite, animation });
    }
    
    render() {
        // Объединить отрисовку для повышения производительности
        for (const { sprite, animation } of this.animations) {
            // Обновить свойства спрайта на основе анимации
            sprite.texture = animation.texture;
            sprite.tint = animation.tint;
        }
    }
}
```

## Ресурсы

- [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API)
- [Tween.js Documentation](https://github.com/tweenjs/tween.js/)
- [[Phaser]]
- [[PixiJS]]
- [[Игровые-паттерны]]

## См. также

- [[Canvas API]]
- [[WebGL]]
- [[TypeScript для игр]]
- [[Физика-в-играх]]