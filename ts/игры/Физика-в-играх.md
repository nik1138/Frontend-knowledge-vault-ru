---
aliases: [Физика в играх, Игровая физика]
tags: [typescript, game-development, physics, collision-detection]
---

# Физика в играх

Физика в играх — это система, которая имитирует реальные физические законы для создания реалистичного поведения объектов. Включает в себя детекцию столкновений, движение под действием сил, гравитацию и другие физические эффекты.

## Основы игровой физики

### Типы физических движков

- **Box2D** - полноценный 2D физический движок
- **Matter.js** - легковесный 2D физический движок
- **Cannon.js** - 3D физический движок
- **Встроенные физические движки** - как в Phaser

### Основные понятия

- **Тело (Body)** - объект, к которому применяются физические законы
- **Сила (Force)** - вектор, вызывающий ускорение тела
- **Масса (Mass)** - мера инертности тела
- **Скорость (Velocity)** - вектор направления и скорости движения
- **Ускорение (Acceleration)** - изменение скорости во времени
- **Трение (Friction)** - сила, замедляющая движение
- **Отскок (Restitution)** - коэффициент упругости при столкновении

## Простая физическая система

```typescript
class Vector2D {
    x: number;
    y: number;
    
    constructor(x: number = 0, y: number = 0) {
        this.x = x;
        this.y = y;
    }
    
    add(v: Vector2D): Vector2D {
        return new Vector2D(this.x + v.x, this.y + v.y);
    }
    
    multiply(scalar: number): Vector2D {
        return new Vector2D(this.x * scalar, this.y * scalar);
    }
    
    magnitude(): number {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    normalize(): Vector2D {
        const mag = this.magnitude();
        if (mag === 0) return new Vector2D(0, 0);
        return new Vector2D(this.x / mag, this.y / mag);
    }
}

class PhysicsBody {
    position: Vector2D;
    velocity: Vector2D;
    acceleration: Vector2D;
    mass: number;
    force: Vector2D;
    
    constructor(x: number, y: number, mass: number = 1) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.acceleration = new Vector2D(0, 0);
        this.mass = mass;
        this.force = new Vector2D(0, 0);
    }
    
    applyForce(force: Vector2D) {
        // F = ma, следовательно a = F/m
        const f = new Vector2D(force.x / this.mass, force.y / this.mass);
        this.acceleration = this.acceleration.add(f);
    }
    
    update(deltaTime: number) {
        // Обновление скорости
        this.velocity = this.velocity.add(this.acceleration.multiply(deltaTime));
        
        // Обновление позиции
        this.position = this.position.add(this.velocity.multiply(deltaTime));
        
        // Сброс ускорения для следующего кадра
        this.acceleration = new Vector2D(0, 0);
    }
    
    // Применение гравитации
    applyGravity(gravity: Vector2D) {
        const weight = new Vector2D(gravity.x * this.mass, gravity.y * this.mass);
        this.applyForce(weight);
    }
    
    // Применение трения
    applyFriction(coefficient: number) {
        const friction = this.velocity.multiply(-1).normalize().multiply(coefficient);
        this.applyForce(friction);
    }
}
```

## Детекция столкновений

### AABB (Axis-Aligned Bounding Box)

Самый простой метод детекции столкновений для прямоугольников:

```typescript
class Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
    
    constructor(x: number, y: number, width: number, height: number) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    
    // Получить границы
    getBounds(): { left: number, right: number, top: number, bottom: number } {
        return {
            left: this.x,
            right: this.x + this.width,
            top: this.y,
            bottom: this.y + this.height
        };
    }
}

function checkAABBCollision(rect1: Rectangle, rect2: Rectangle): boolean {
    const bounds1 = rect1.getBounds();
    const bounds2 = rect2.getBounds();
    
    return (
        bounds1.left < bounds2.right &&
        bounds1.right > bounds2.left &&
        bounds1.top < bounds2.bottom &&
        bounds1.bottom > bounds2.top
    );
}
```

### Столкновение кругов

```typescript
class Circle {
    x: number;
    y: number;
    radius: number;
    
    constructor(x: number, y: number, radius: number) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
}

function checkCircleCollision(circle1: Circle, circle2: Circle): boolean {
    const dx = circle1.x - circle2.x;
    const dy = circle1.y - circle2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDistance = circle1.radius + circle2.radius;
    
    return distance <= minDistance;
}

// Получить нормаль столкновения и глубину проникновения
function resolveCircleCollision(circle1: Circle, circle2: Circle): { normal: Vector2D, depth: number } | null {
    const dx = circle2.x - circle1.x;
    const dy = circle2.y - circle1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDistance = circle1.radius + circle2.radius;
    
    if (distance < minDistance) {
        const normal = new Vector2D(dx / distance, dy / distance);
        const depth = minDistance - distance;
        return { normal, depth };
    }
    
    return null;
}
```

### Столкновение круга и прямоугольника

```typescript
function checkCircleRectCollision(circle: Circle, rect: Rectangle): boolean {
    // Найти ближайшую точку на прямоугольнике к центру круга
    let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
    
    // Рассчитать расстояние между центром круга и ближайшей точкой
    const distanceX = circle.x - closestX;
    const distanceY = circle.y - closestY;
    const distanceSquared = distanceX * distanceX + distanceY * distanceY;
    
    // Проверить, пересекаются ли они
    return distanceSquared < (circle.radius * circle.radius);
}
```

## Физика с использованием Matter.js

```typescript
import * as Matter from 'matter-js';

// Создание физического мира
const Engine = Matter.Engine;
const Render = Matter.Render;
const Runner = Matter.Runner;
const Bodies = Matter.Bodies;
const Composite = Matter.Composite;

class MatterPhysics {
    engine: Matter.Engine;
    render: Matter.Render;
    
    constructor() {
        // Создание двигателя
        this.engine = Engine.create();
        
        // Создание рендера
        this.render = Render.create({
            element: document.body,
            engine: this.engine,
            options: {
                width: 800,
                height: 600,
                wireframes: false
            }
        });
        
        // Запуск симуляции
        Runner.run(Runner.create(), this.engine);
        Render.run(this.render);
        
        // Создание объектов
        this.createObjects();
    }
    
    createObjects() {
        // Создание земли
        const ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
        
        // Создание шарика
        const ball = Bodies.circle(400, 100, 20, { restitution: 0.8 });
        
        // Создание блока
        const box = Bodies.rectangle(300, 200, 50, 50);
        
        // Добавление объектов в мир
        Composite.add(this.engine.world, [ground, ball, box]);
    }
    
    // Применение силы к телу
    applyForce(body: Matter.Body, force: Matter.Vector) {
        Matter.Body.applyForce(body, body.position, force);
    }
}
```

## Физика в Phaser

```typescript
class PhysicsScene extends Phaser.Scene {
    player: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;
    
    create() {
        // Включение физики
        this.player = this.physics.add.sprite(100, 450, 'player');
        
        // Настройка физических свойств
        this.player.setBounce(0.2);
        this.player.setCollideWorldBounds(true);
        
        // Создание платформ
        const platforms = this.physics.add.staticGroup();
        platforms.create(400, 568, 'ground').setScale(2).refreshBody();
        
        // Установка коллизии
        this.physics.add.collider(this.player, platforms);
    }
    
    update() {
        const cursors = this.input.keyboard.createCursorKeys();
        
        if (cursors.left.isDown) {
            this.player.setVelocityX(-160);
        } else if (cursors.right.isDown) {
            this.player.setVelocityX(160);
        } else {
            this.player.setVelocityX(0);
        }
        
        if (cursors.up.isDown && this.player.body.touching.down) {
            this.player.setVelocityY(-330);
        }
    }
}
```

## Сложные физические взаимодействия

### Ограничения и соединения

```typescript
class Joint {
    bodyA: PhysicsBody;
    bodyB: PhysicsBody;
    length: number;
    stiffness: number;
    
    constructor(bodyA: PhysicsBody, bodyB: PhysicsBody, length: number, stiffness: number = 0.1) {
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.length = length;
        this.stiffness = stiffness;
    }
    
    update() {
        // Рассчитать текущее расстояние между телами
        const dx = this.bodyB.position.x - this.bodyA.position.x;
        const dy = this.bodyB.position.y - this.bodyA.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            // Рассчитать разницу с целевым расстоянием
            const diff = (this.length - distance) / distance;
            
            // Рассчитать корректировки
            const offsetX = dx * diff * this.stiffness;
            const offsetY = dy * diff * this.stiffness;
            
            // Применить корректировки
            this.bodyA.position.x -= offsetX * 0.5;
            this.bodyA.position.y -= offsetY * 0.5;
            this.bodyB.position.x += offsetX * 0.5;
            this.bodyB.position.y += offsetY * 0.5;
        }
    }
}
```

### Система частиц с физикой

```typescript
class Particle {
    position: Vector2D;
    velocity: Vector2D;
    acceleration: Vector2D;
    mass: number;
    radius: number;
    color: string;
    
    constructor(x: number, y: number) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
        );
        this.acceleration = new Vector2D(0, 0);
        this.mass = 1;
        this.radius = 5;
        this.color = `hsl(${Math.random() * 360}, 50%, 50%)`;
    }
    
    applyForce(force: Vector2D) {
        const f = new Vector2D(force.x / this.mass, force.y / this.mass);
        this.acceleration = this.acceleration.add(f);
    }
    
    update(deltaTime: number) {
        this.velocity = this.velocity.add(this.acceleration.multiply(deltaTime));
        this.position = this.position.add(this.velocity.multiply(deltaTime));
        this.acceleration = new Vector2D(0, 0);
    }
    
    checkBoundaryCollision(width: number, height: number) {
        if (this.position.x < this.radius) {
            this.position.x = this.radius;
            this.velocity.x *= -0.8; // Отскок с потерей энергии
        } else if (this.position.x > width - this.radius) {
            this.position.x = width - this.radius;
            this.velocity.x *= -0.8;
        }
        
        if (this.position.y < this.radius) {
            this.position.y = this.radius;
            this.velocity.y *= -0.8;
        } else if (this.position.y > height - this.radius) {
            this.position.y = height - this.radius;
            this.velocity.y *= -0.8;
        }
    }
}

class ParticleSystem {
    particles: Particle[] = [];
    gravity: Vector2D = new Vector2D(0, 500);
    bounds: { width: number, height: number };
    
    constructor(width: number, height: number) {
        this.bounds = { width, height };
    }
    
    addParticle(x: number, y: number) {
        this.particles.push(new Particle(x, y));
    }
    
    update(deltaTime: number) {
        for (const particle of this.particles) {
            particle.applyForce(this.gravity);
            particle.update(deltaTime);
            particle.checkBoundaryCollision(this.bounds.width, this.bounds.height);
        }
    }
    
    render(ctx: CanvasRenderingContext2D) {
        for (const particle of this.particles) {
            ctx.beginPath();
            ctx.arc(particle.position.x, particle.position.y, particle.radius, 0, Math.PI * 2);
            ctx.fillStyle = particle.color;
            ctx.fill();
        }
    }
}
```

## Оптимизация физических расчетов

### Пространственное разбиение (Spatial Partitioning)

```typescript
class SpatialGrid {
    cellSize: number;
    grid: Map<string, PhysicsBody[]>;
    
    constructor(cellSize: number) {
        this.cellSize = cellSize;
        this.grid = new Map();
    }
    
    getCellKey(x: number, y: number): string {
        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);
        return `${cellX},${cellY}`;
    }
    
    insert(body: PhysicsBody) {
        const cellKey = this.getCellKey(body.position.x, body.position.y);
        if (!this.grid.has(cellKey)) {
            this.grid.set(cellKey, []);
        }
        this.grid.get(cellKey)!.push(body);
    }
    
    getNearbyBodies(body: PhysicsBody): PhysicsBody[] {
        const cellKey = this.getCellKey(body.position.x, body.position.y);
        const nearbyBodies: PhysicsBody[] = [];
        
        // Получить тела из текущей ячейки и соседних
        const cellX = Math.floor(body.position.x / this.cellSize);
        const cellY = Math.floor(body.position.y / this.cellSize);
        
        for (let x = cellX - 1; x <= cellX + 1; x++) {
            for (let y = cellY - 1; y <= cellY + 1; y++) {
                const key = `${x},${y}`;
                const bodies = this.grid.get(key);
                if (bodies) {
                    nearbyBodies.push(...bodies);
                }
            }
        }
        
        return nearbyBodies.filter(b => b !== body);
    }
    
    clear() {
        this.grid.clear();
    }
}
```

## Ресурсы

- [Matter.js Documentation](https://brm.io/matter-js/)
- [Box2D Documentation](https://box2d.org/documentation/)
- [[Игровые-паттерны]]
- [[Phaser]]
- [[PixiJS]]

## См. также

- [[Коллизии в играх]]
- [[Архитектура игровых движков]]
- [[TypeScript для игр]]