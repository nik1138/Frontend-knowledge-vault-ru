---
aliases: [Автоматизация процесса деплоя TypeScript, Управление деплоем]
tags: [деплой, автоматизация, typescript, скрипты, инструменты-деплоя, ci-cd]
---

# Автоматизация деплоя TypeScript-приложений

## Обзор

Автоматизация деплоя - это процесс автоматического развертывания приложений без ручного вмешательства. Для TypeScript-приложений автоматизация деплоя особенно важна, так как позволяет обеспечить консистентность, уменьшить человеческие ошибки и ускорить процесс доставки кода в production. В этой статье рассматриваются различные подходы, инструменты и практики для автоматизации деплоя TypeScript-приложений.

## Основы автоматизации деплоя

### Что такое автоматизация деплоя

Автоматизация деплоя - это процесс, при котором изменения кода автоматически проходят через все этапы (тестирование, сборка, развертывание) до попадания в production. Это включает:

- Компиляцию TypeScript в JavaScript
- Запуск тестов
- Проверку качества кода
- Создание артефактов
- Развертывание на целевых серверах

### Преимущества автоматизации деплоя

- **Скорость**: Быстрое развертывание новых функций
- **Консистентность**: Одинаковый процесс для всех окружений
- **Надежность**: Уменьшение человеческих ошибок
- **Воспроизводимость**: Возможность воспроизвести процесс в любой момент
- **Масштабируемость**: Легкое развертывание на нескольких серверах
- **Обратная связь**: Быстрое получение результатов тестирования

## Инструменты автоматизации деплоя

### 1. GitHub Actions

GitHub Actions - это встроенная платформа CI/CD в GitHub, которая позволяет автоматизировать рабочие процессы.

**Пример workflow для деплоя на production:**
```yaml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run type checks
      run: npm run type-check
    
    - name: Run linting
      run: npm run lint
    
    - name: Run tests
      run: npm run test
    
    - name: Build application
      run: npm run build
    
    - name: Deploy to server
      run: |
        # Копируем артефакты на сервер
        scp -r dist user@server:/var/www/myapp/
        
        # Перезапускаем сервис
        ssh user@server 'sudo systemctl restart myapp'
```

### 2. GitLab CI/CD

GitLab CI/CD использует файл `.gitlab-ci.yml` для определения процесса деплоя.

```yaml
stages:
  - build
  - test
  - deploy

variables:
  NODE_VERSION: "18"

before_script:
  - node --version
  - npm --version

build:
  stage: build
  image: node:$NODE_VERSION
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

test:
  stage: test
  image: node:$NODE_VERSION
  script:
    - npm run test
    - npm run type-check
  dependencies:
    - build

deploy:
  stage: deploy
  image: node:$NODE_VERSION
  script:
    - echo "Deploying to production..."
    - npm run deploy:production
  environment:
    name: production
    url: https://myapp.com
  only:
    - main
  when: manual
```

### 3. Jenkins

Jenkins - это сервер автоматизации с открытым исходным кодом, который может быть настроен для деплоя TypeScript-приложений.

```groovy
pipeline {
    agent any

    tools {
        nodejs "NodeJS-18"
    }

    environment {
        NODE_ENV = "production"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }

        stage('Type Check') {
            steps {
                sh 'npm run type-check'
            }
        }

        stage('Lint') {
            steps {
                sh 'npm run lint'
            }
        }

        stage('Test') {
            steps {
                sh 'npm test'
            }
        }

        stage('Build') {
            steps {
                sh 'npm run build'
            }
        }

        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Выполняем деплой на production сервер
                    sh '''
                        # Копируем артефакты на сервер
                        rsync -avz -e ssh dist/ user@production-server:/var/www/myapp/
                        
                        # Перезапускаем приложение
                        ssh user@production-server 'sudo pm2 reload myapp'
                    '''
                }
            }
        }
    }

    post {
        success {
            echo 'Deployment successful!'
            sh 'curl -X POST $SLACK_WEBHOOK_URL -H "Content-Type: application/json" -d \'{"text":"Deployment successful!"}\''
        }
        failure {
            echo 'Deployment failed!'
            sh 'curl -X POST $SLACK_WEBHOOK_URL -H "Content-Type: application/json" -d \'{"text":"Deployment failed!"}\''
        }
    }
}
```

## Автоматизация деплоя на различные окружения

### Разработка (Development)

```yaml
deploy-dev:
  stage: deploy
  script:
    - npm run build
    - rsync -avz dist/ dev-server:/var/www/myapp-dev/
    - ssh dev-server 'sudo systemctl reload myapp-dev'
  environment:
    name: development
    url: https://dev.myapp.com
  only:
    - develop
```

### Тестирование (Staging)

```yaml
deploy-staging:
  stage: deploy
  script:
    - npm run build
    - docker build -t myapp:${CI_COMMIT_SHA} .
    - docker tag myapp:${CI_COMMIT_SHA} registry.example.com/myapp:${CI_COMMIT_SHA}
    - docker push registry.example.com/myapp:${CI_COMMIT_SHA}
    - kubectl set image deployment/myapp myapp=registry.example.com/myapp:${CI_COMMIT_SHA} -n staging
  environment:
    name: staging
    url: https://staging.myapp.com
  only:
    - staging
```

### Production

```yaml
deploy-production:
  stage: deploy
  script:
    - npm run build
    - docker build -t myapp:${CI_COMMIT_SHA} .
    - docker tag myapp:${CI_COMMIT_SHA} registry.example.com/myapp:${CI_COMMIT_SHA}
    - docker push registry.example.com/myapp:${CI_COMMIT_SHA}
    - kubectl set image deployment/myapp myapp=registry.example.com/myapp:${CI_COMMIT_SHA} -n production
  environment:
    name: production
    url: https://myapp.com
  only:
    - main
  when: manual  # Требует ручного подтверждения
```

## Практические примеры автоматизации деплоя

### Пример скрипта деплоя с использованием rsync

**deploy.sh:**
```bash
#!/bin/bash

# Параметры деплоя
ENVIRONMENT=$1
BRANCH=$2
SERVER_USER="deploy"
SERVER_HOST="server.example.com"
APP_PATH="/var/www/myapp"

# Проверяем аргументы
if [ -z "$ENVIRONMENT" ] || [ -z "$BRANCH" ]; then
    echo "Usage: $0 <environment> <branch>"
    echo "Example: $0 production main"
    exit 1
fi

echo "Starting deployment to $ENVIRONMENT from branch $BRANCH..."

# Проверяем, что мы на правильной ветке
if [ "$(git branch --show-current)" != "$BRANCH" ]; then
    echo "Error: Not on branch $BRANCH"
    exit 1
fi

# Сборка приложения
echo "Building application..."
npm run build

if [ $? -ne 0 ]; then
    echo "Build failed, aborting deployment"
    exit 1
fi

echo "Build completed successfully"

# Копируем файлы на сервер
echo "Copying files to server..."
rsync -avz --delete \
    --exclude 'node_modules' \
    --exclude '.git' \
    --exclude 'tests' \
    dist/ ${SERVER_USER}@${SERVER_HOST}:${APP_PATH}/

if [ $? -ne 0 ]; then
    echo "File transfer failed"
    exit 1
fi

echo "Files copied successfully"

# Выполняем команды на сервере
ssh ${SERVER_USER}@${SERVER_HOST} << EOF
    cd ${APP_PATH}
    
    # Устанавливаем зависимости на сервере
    npm ci --production
    
    # Перезапускаем приложение
    pm2 reload myapp || pm2 start ecosystem.config.js
    
    echo "Deployment to $ENVIRONMENT completed successfully"
EOF

if [ $? -eq 0 ]; then
    echo "Deployment completed successfully!"
else
    echo "Deployment failed!"
    exit 1
fi
```

### TypeScript-скрипт для автоматизации деплоя

**scripts/deploy.ts:**
```typescript
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

interface DeployConfig {
  environment: string;
  server: string;
  appPath: string;
  branch: string;
}

class Deployer {
  private config: DeployConfig;

  constructor(config: DeployConfig) {
    this.config = config;
  }

  async deploy(): Promise<void> {
    console.log(`Starting deployment to ${this.config.environment}...`);

    try {
      // Проверяем текущую ветку
      await this.checkBranch();

      // Собираем приложение
      await this.build();

      // Копируем файлы на сервер
      await this.transferFiles();

      // Выполняем команды на сервере
      await this.executeRemoteCommands();

      console.log('Deployment completed successfully!');
    } catch (error) {
      console.error('Deployment failed:', error);
      throw error;
    }
  }

  private async checkBranch(): Promise<void> {
    const { stdout } = await execAsync('git branch --show-current');
    const currentBranch = stdout.trim();

    if (currentBranch !== this.config.branch) {
      throw new Error(`Not on branch ${this.config.branch}, current branch: ${currentBranch}`);
    }

    console.log(`Confirmed on correct branch: ${currentBranch}`);
  }

  private async build(): Promise<void> {
    console.log('Building application...');
    
    const { stdout, stderr } = await execAsync('npm run build');
    
    if (stderr) {
      console.error('Build stderr:', stderr);
    }
    
    console.log('Build output:', stdout);
    console.log('Build completed');
  }

  private async transferFiles(): Promise<void> {
    console.log('Transferring files to server...');
    
    const cmd = `rsync -avz --delete --exclude 'node_modules' --exclude '.git' dist/ ${this.config.server}:${this.config.appPath}/`;
    const { stdout, stderr } = await execAsync(cmd);
    
    if (stderr) {
      console.error('Transfer stderr:', stderr);
    }
    
    console.log('Transfer completed:', stdout);
  }

  private async executeRemoteCommands(): Promise<void> {
    console.log('Executing remote commands...');
    
    const remoteCommands = [
      `cd ${this.config.appPath}`,
      'npm ci --production',
      'pm2 reload myapp || pm2 start ecosystem.config.js'
    ].join(' && ');
    
    const cmd = `ssh ${this.config.server} "${remoteCommands}"`;
    const { stdout, stderr } = await execAsync(cmd);
    
    if (stderr) {
      console.error('Remote execution stderr:', stderr);
    }
    
    console.log('Remote execution completed:', stdout);
  }
}

// Использование
async function main(): Promise<void> {
  const environment = process.argv[2];
  const branch = process.argv[3];

  if (!environment || !branch) {
    console.error('Usage: npm run deploy <environment> <branch>');
    console.error('Example: npm run deploy production main');
    process.exit(1);
  }

  const configs: Record<string, DeployConfig> = {
    development: {
      environment: 'development',
      server: 'dev-server.example.com',
      appPath: '/var/www/myapp-dev',
      branch: 'develop'
    },
    staging: {
      environment: 'staging',
      server: 'staging-server.example.com',
      appPath: '/var/www/myapp-staging',
      branch: 'staging'
    },
    production: {
      environment: 'production',
      server: 'prod-server.example.com',
      appPath: '/var/www/myapp',
      branch: 'main'
    }
  };

  const config = configs[environment];
  if (!config) {
    console.error(`Unknown environment: ${environment}`);
    process.exit(1);
  }

  const deployer = new Deployer(config);
  await deployer.deploy();
}

if (require.main === module) {
  main().catch(error => {
    console.error('Deployment process failed:', error);
    process.exit(1);
  });
}
```

### Docker-based деплой

**docker-compose.prod.yml:**
```yaml
version: '3.8'

services:
  app:
    image: registry.example.com/my-ts-app:${IMAGE_TAG:-latest}
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    depends_on:
      - db
      - redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  db:
    image: postgres:14
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    restart: unless-stopped

volumes:
  postgres_data:
```

**deploy-docker.sh:**
```bash
#!/bin/bash

ENVIRONMENT=$1
IMAGE_TAG=$2

if [ -z "$ENVIRONMENT" ] || [ -z "$IMAGE_TAG" ]; then
    echo "Usage: $0 <environment> <image-tag>"
    echo "Example: $0 production v1.2.3"
    exit 1
fi

echo "Deploying $IMAGE_TAG to $ENVIRONMENT..."

# Устанавливаем переменные окружения для конкретного окружения
case $ENVIRONMENT in
    "production")
        export COMPOSE_FILE=docker-compose.prod.yml
        ;;
    "staging")
        export COMPOSE_FILE=docker-compose.staging.yml
        ;;
    "development")
        export COMPOSE_FILE=docker-compose.dev.yml
        ;;
    *)
        echo "Unknown environment: $ENVIRONMENT"
        exit 1
        ;;
esac

# Обновляем образ
docker pull registry.example.com/my-ts-app:$IMAGE_TAG

# Обновляем переменные для docker-compose
export IMAGE_TAG=$IMAGE_TAG

# Останавливаем старые контейнеры
docker-compose down

# Запускаем новые контейнеры
docker-compose up -d

# Ждем, пока приложение станет доступным
echo "Waiting for application to be ready..."
sleep 30

# Проверяем статус
docker-compose ps

echo "Deployment to $ENVIRONMENT completed!"
```

## Лучшие практики автоматизации деплоя

### 1. Blue-Green деплой

Blue-green деплой позволяет переключаться между двумя идентичными production-окружениями:

```typescript
// Пример функции для blue-green деплоя
async function blueGreenDeploy(newVersion: string): Promise<void> {
  // 1. Развертываем новую версию в "зеленом" окружении
  await deployToEnvironment('green', newVersion);
  
  // 2. Проверяем здоровье нового окружения
  const isHealthy = await checkHealth('green');
  
  if (isHealthy) {
    // 3. Переключаем трафик на новое окружение
    await switchTraffic('green');
    
    // 4. После некоторого времени отключаем старое окружение
    setTimeout(() => {
      undeployEnvironment('blue');
    }, 60000); // 1 минута для мониторинга
  } else {
    // Откатываемся к старой версии
    console.error('New version is not healthy, rolling back');
    await switchTraffic('blue');
    await undeployEnvironment('green');
  }
}
```

### 2. Canary деплой

Canary деплой постепенно перенаправляет трафик на новую версию:

```yaml
# Пример для Kubernetes
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 5
  strategy:
    canary:
      steps:
      - setWeight: 20
      - pause: {duration: 10m}
      - setWeight: 40
      - pause: {duration: 10m}
      - setWeight: 60
      - pause: {duration: 10m}
      - setWeight: 80
      - pause: {duration: 10m}
      - setWeight: 100
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:v2.0
```

### 3. Использование семантического версионирования

Автоматизируйте создание тегов и релизов на основе семантического версионирования:

```bash
#!/bin/bash
# script to auto-increment version and create git tag

VERSION_FILE="package.json"
CURRENT_VERSION=$(node -p "require('./$VERSION_FILE').version")

# Определяем тип изменений
CHANGE_TYPE=${1:-patch}  # patch, minor, major

# Обновляем версию
NEW_VERSION=$(npm version $CHANGE_TYPE --no-git-tag-version)

# Создаем тег
git add $VERSION_FILE
git commit -m "Bump version to $NEW_VERSION"
git tag -a v$NEW_VERSION -m "Release version $NEW_VERSION"

# Push с тегами
git push origin main --tags
```

### 4. Мониторинг и алертинг

Настройте мониторинг после деплоя:

```typescript
// Пример проверки состояния после деплоя
async function postDeployCheck(): Promise<void> {
  const checks = [
    checkHealthEndpoint(),
    checkMetrics(),
    verifyPerformance(),
    runSmokeTests()
  ];

  const results = await Promise.allSettled(checks);

  const failedChecks = results.filter(result => result.status === 'rejected');
  
  if (failedChecks.length > 0) {
    console.error('Post-deploy checks failed:', failedChecks);
    // Отправляем алерт
    await sendAlert('Post-deploy checks failed', failedChecks);
  } else {
    console.log('All post-deploy checks passed');
  }
}
```

## Безопасность в автоматизации деплоя

### Управление секретами

- Используйте инструменты управления секретами (HashiCorp Vault, AWS Secrets Manager)
- Не храните секреты в репозитории
- Используйте environment-переменные для конфиденциальных данных

### Подписывание артефактов

Подписывайте артефакты для проверки целостности:

```bash
# Подписываем артефакт
gpg --detach-sign dist/myapp.tar.gz

# Проверяем подпись
gpg --verify dist/myapp.tar.gz.sig dist/myapp.tar.gz
```

## Мониторинг автоматизации деплоя

### Ключевые метрики

- Время деплоя
- Частота успешных/неудачных деплоев
- Время восстановления после сбоев
- Покрытие тестами перед деплоем

### Уведомления

Настройте уведомления о статусе деплоя в Slack, Discord или другие мессенджеры:

```typescript
async function sendDeployNotification(status: 'success' | 'failure', details: any): Promise<void> {
  const message = status === 'success' 
    ? `✅ Deployment successful to ${details.environment} - ${details.version}`
    : `❌ Deployment failed to ${details.environment} - ${details.error}`;
  
  await fetch(process.env.SLACK_WEBHOOK_URL!, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({text: message})
  });
}
```

## Заключение

Автоматизация деплоя TypeScript-приложений значительно упрощает процесс доставки кода в production, повышает надежность и ускоряет разработку. Правильная настройка автоматизации позволяет сосредоточиться на создании качественного кода, а не на рутинных операциях развертывания.

Следуя лучшим практикам и используя современные инструменты, вы можете создать надежный и эффективный процесс автоматизации деплоя для своих TypeScript-проектов.

## См. также

- [[CI-CD-с-Typescript]]
- [[Docker]]
- [[Kubernetes]]
- [[Облачные-сервисы]]
- [[Мониторинг-и-логирование]]
- [[Безопасность-TypeScript-приложений]]