---
aliases: ["Higher-order functions", "Функции высокого порядка", "HOF"]
tags: [ts/функции, функции-высшего-порядка, programming]
---

# Функции-высшего-порядка

## Обзор

Функции высшего порядка (Higher-Order Functions, HOF) - это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата. Это фундаментальное понятие функционального программирования, которое позволяет создавать более гибкий и переиспользуемый код в TypeScript.

## Определение функций высшего порядка

Функция считается функцией высшего порядка, если она:
1. Принимает одну или несколько функций в качестве аргументов
2. Возвращает функцию в качестве результата
3. Или делает и то, и другое

```ts
// Функция, принимающая другую функцию как аргумент
function executeCallback(callback: () => void): void {
    callback();
}

// Функция, возвращающая другую функцию
function createAdder(x: number): (y: number) => number {
    return function(y: number): number {
        return x + y;
    };
}

// Функция, делающая и то, и другое
function executeWithLogging<T>(fn: (arg: T) => T, arg: T): T {
    console.log('Выполняем функцию с аргументом:', arg);
    const result = fn(arg);
    console.log('Результат:', result);
    return result;
}
```

## Встроенные функции высшего порядка

TypeScript (и JavaScript) предоставляют множество встроенных функций высшего порядка, особенно для работы с массивами:

### map

```ts
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2); // [2, 4, 6, 8, 10]

// С более сложной типизацией
interface User {
    id: number;
    name: string;
    email: string;
}

const users: User[] = [
    { id: 1, name: "Алексей", email: "alex@example.com" },
    { id: 2, name: "Мария", email: "maria@example.com" }
];

const userEmails = users.map(user => user.email); // ["alex@example.com", "maria@example.com"]
```

### filter

```ts
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num % 2 === 0); // [2, 4, 6, 8, 10]

// С более сложным условием
const adults = users.filter(user => user.name.length > 4);
```

### reduce

```ts
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 15

// С аккумуляцией объектов
const products = [
    { name: "Яблоко", category: "Фрукты" },
    { name: "Молоко", category: "Молочные" },
    { name: "Груша", category: "Фрукты" }
];

const categorized = products.reduce((acc, product) => {
    if (!acc[product.category]) {
        acc[product.category] = [];
    }
    acc[product.category].push(product);
    return acc;
}, {} as Record<string, typeof products>);
```

### forEach

```ts
users.forEach(user => {
    console.log(`Пользователь: ${user.name}, Email: ${user.email}`);
});
```

## Создание собственных функций высшего порядка

### Каррирование

```ts
// Функция, возвращающая другую функцию
const multiply = (a: number) => (b: number): number => a * b;

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

### Композиция функций

```ts
// Функция для композиции двух функций
const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A): C => f(g(x));

// Примеры функций
const add10 = (x: number): number => x + 10;
const multiplyBy2 = (x: number): number => x * 2;

// Композиция функций
const add10AndMultiplyBy2 = compose(multiplyBy2, add10);
console.log(add10AndMultiplyBy2(5)); // (5 + 10) * 2 = 30
```

### Утилиты для работы с функциями

```ts
// Функция для создания debounce
const debounce = <T extends (...args: any[]) => any>(fn: T, delay: number): ((...args: Parameters<T>) => void) => {
    let timeoutId: NodeJS.Timeout;
    return (...args: Parameters<T>) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), delay);
    };
};

// Пример использования
const handleSearch = debounce((query: string) => {
    console.log(`Поиск: ${query}`);
}, 300);

// handleSearch("TypeScript"); // Вызовется через 300мс
```

## Типизация функций высшего порядка

### Типизация коллбэков

```ts
// Типизация функции, принимающей коллбэк
function processData<T, R>(
    data: T[], 
    transformer: (item: T, index: number, array: T[]) => R
): R[] {
    return data.map(transformer);
}

// Использование
const numbers = [1, 2, 3, 4];
const squared = processData(numbers, (num) => num * num);
```

### Типизация возвращаемых функций

```ts
// Функция, возвращающая функцию с типизацией
const createValidator = <T>(validator: (value: T) => boolean) => (value: T): { valid: boolean; value: T } => ({
    valid: validator(value),
    value
});

const isPositive = (num: number): boolean => num > 0;
const validatePositive = createValidator(isPositive);

console.log(validatePositive(5));  // { valid: true, value: 5 }
console.log(validatePositive(-3)); // { valid: false, value: -3 }
```

## Практические примеры

### Middleware в веб-приложениях

```ts
interface Request {
    url: string;
    method: string;
    headers: Record<string, string>;
}

interface Response {
    status: number;
    body: string;
}

type Middleware = (req: Request, res: Response, next: () => void) => void;

const loggerMiddleware: Middleware = (req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next();
};

const authMiddleware: Middleware = (req, res, next) => {
    const auth = req.headers['authorization'];
    if (auth) {
        next();
    } else {
        res.status = 401;
        res.body = 'Unauthorized';
    }
};
```

### Обработка событий

```ts
type EventHandler<T = Event> = (event: T) => void;

function addEventHandler<T extends Event>(
    element: HTMLElement,
    eventType: string,
    handler: EventHandler<T>,
    options?: boolean | AddEventListenerOptions
): () => void {
    element.addEventListener(eventType, handler as EventListener, options);
    
    // Возвращаем функцию для удаления обработчика
    return () => element.removeEventListener(eventType, handler as EventListener, options);
}

// Использование
const button = document.getElementById('myButton')!;
const removeHandler = addEventHandler(button, 'click', (e) => {
    console.log('Кнопка нажата');
});

// Позже можно удалить обработчик
// removeHandler();
```

### Универсальные функции преобразования

```ts
// Функция для создания трансформера
const createTransformer = <T, R>(
    transform: (item: T) => R
) => (items: T[]): R[] => items.map(transform);

// Создание конкретных трансформеров
const stringToNumber = createTransformer((str: string) => parseFloat(str));
const stringToUpper = createTransformer((str: string) => str.toUpperCase());

console.log(stringToNumber(["1", "2.5", "3"])); // [1, 2.5, 3]
console.log(stringToUpper(["hello", "world"])); // ["HELLO", "WORLD"]
```

## Применение в асинхронном коде

```ts
// Функция для повторения асинхронной операции
const retryAsync = <T>(
    operation: () => Promise<T>,
    maxRetries: number,
    delay: number = 1000
): Promise<T> => {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        
        const attempt = () => {
            operation()
                .then(resolve)
                .catch((error) => {
                    attempts++;
                    if (attempts >= maxRetries) {
                        reject(error);
                    } else {
                        setTimeout(attempt, delay);
                    }
                });
        };
        
        attempt();
    });
};

// Использование
const fetchUserData = () => fetch('/api/user').then(res => res.json());
retryAsync(fetchUserData, 3)
    .then(data => console.log('Данные пользователя:', data))
    .catch(error => console.error('Не удалось получить данные:', error));
```

## Лучшие практики

- Используйте функции высшего порядка для устранения дублирования кода
- Типизируйте параметры и возвращаемые значения функций для лучшей безопасности типов
- Давайте понятные имена функциям высшего порядка
- Документируйте поведение функций, особенно когда они изменяют переданные аргументы

## Связанные темы

- [[Типизация-функций]]
- [[Стрелочные-функции]]
- [[Перегрузка-функций]]
- [[Рекурсивные-функции]]
- [[Функциональное программирование]]
- [[Каррирование]]

## Заключение

Функции высшего порядка - мощный инструмент в TypeScript, позволяющий создавать гибкий, переиспользуемый и чистый код. Они особенно полезны для обработки коллекций данных, создания утилит и реализации шаблонов проектирования. Понимание и правильное использование HOF делает код более функциональным и выразительным.