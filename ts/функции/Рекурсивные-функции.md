---
aliases: ["Рекурсивные функции", "Рекурсия", "Recursive Functions"]
tags: [ts/функции, рекурсия, programming]
---

# Рекурсивные-функции

## Обзор

Рекурсивные функции - это функции, которые вызывают сами себя для решения задачи. Это важный концепт в программировании, который позволяет решать сложные задачи, разбивая их на более простые подзадачи аналогичной структуры. В TypeScript рекурсивные функции могут быть типизированы и использоваться для обработки структур данных, таких как деревья, списки и графы.

## Основы рекурсии

Любая рекурсивная функция должна содержать:

1. **Базовый случай (base case)** - условие, при котором рекурсия останавливается
2. **Рекурсивный случай (recursive case)** - вызов функции с изменёнными параметрами, приближающими к базовому случаю

```ts
// Простой пример: вычисление факториала
function factorial(n: number): number {
    // Базовый случай
    if (n <= 1) {
        return 1;
    }
    // Рекурсивный случай
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```

## Типизация рекурсивных функций

### Простые рекурсивные функции

```ts
// Вычисление чисел Фибоначчи
function fibonacci(n: number): number {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Проверка палиндрома
function isPalindrome(str: string): boolean {
    if (str.length <= 1) {
        return true;
    }
    if (str[0] !== str[str.length - 1]) {
        return false;
    }
    return isPalindrome(str.slice(1, -1));
}
```

### Рекурсия с массивами

```ts
// Рекурсивный подсчет суммы элементов массива
function sumArray(arr: number[]): number {
    if (arr.length === 0) {
        return 0;
    }
    return arr[0] + sumArray(arr.slice(1));
}

// Рекурсивный поиск элемента
function findElement<T>(arr: T[], predicate: (item: T) => boolean): T | undefined {
    if (arr.length === 0) {
        return undefined;
    }
    if (predicate(arr[0])) {
        return arr[0];
    }
    return findElement(arr.slice(1), predicate);
}
```

## Работа со структурами данных

### Рекурсия с деревьями

```ts
interface TreeNode {
    value: number;
    left?: TreeNode;
    right?: TreeNode;
}

// Рекурсивный обход дерева (in-order)
function inOrderTraversal(node?: TreeNode): number[] {
    if (!node) {
        return [];
    }
    return [
        ...inOrderTraversal(node.left),
        node.value,
        ...inOrderTraversal(node.right)
    ];
}

// Поиск в дереве
function searchInTree(node: TreeNode | undefined, value: number): boolean {
    if (!node) {
        return false;
    }
    if (node.value === value) {
        return true;
    }
    return searchInTree(node.left, value) || searchInTree(node.right, value);
}

// Подсчет узлов в дереве
function countNodes(node?: TreeNode): number {
    if (!node) {
        return 0;
    }
    return 1 + countNodes(node.left) + countNodes(node.right);
}
```

### Рекурсия с вложенными объектами

```ts
interface NestedObject {
    [key: string]: string | number | boolean | NestedObject | NestedObject[];
}

// Рекурсивный поиск значения в глубоко вложенном объекте
function findValue(obj: NestedObject, target: string): any {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (key === target) {
                return obj[key];
            }
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                const result = findValue(obj[key] as NestedObject, target);
                if (result !== undefined) {
                    return result;
                }
            }
        }
    }
    return undefined;
}

// Рекурсивное преобразование всех строк в объекте
function transformStrings(obj: NestedObject, transformer: (str: string) => string): NestedObject {
    const result: NestedObject = {};
    
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (typeof obj[key] === 'string') {
                result[key] = transformer(obj[key] as string);
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                result[key] = Array.isArray(obj[key])
                    ? (obj[key] as NestedObject[]).map(item => transformStrings(item, transformer))
                    : transformStrings(obj[key] as NestedObject, transformer);
            } else {
                result[key] = obj[key];
            }
        }
    }
    
    return result;
}
```

## Продвинутые примеры

### Хвостовая рекурсия

Хвостовая рекурсия - это специальный вид рекурсии, где рекурсивный вызов является последней операцией в функции. Это позволяет оптимизировать рекурсивные вызовы (хотя TypeScript не оптимизирует хвостовую рекурсию автоматически, как некоторые другие языки):

```ts
// Обычная рекурсия для вычисления факториала
function factorialNormal(n: number): number {
    if (n <= 1) {
        return 1;
    }
    return n * factorialNormal(n - 1);
}

// Хвостовая рекурсия для вычисления факториала
function factorialTail(n: number, accumulator: number = 1): number {
    if (n <= 1) {
        return accumulator;
    }
    return factorialTail(n - 1, n * accumulator);
}
```

### Рекурсия с аккумулятором

```ts
// Рекурсивное обращение строки с аккумулятором
function reverseString(str: string, accumulator: string = ""): string {
    if (str.length === 0) {
        return accumulator;
    }
    return reverseString(str.slice(1), str[0] + accumulator);
}

// Рекурсивное объединение массивов с аккумулятором
function flattenArray<T>(arr: (T | T[])[], accumulator: T[] = []): T[] {
    if (arr.length === 0) {
        return accumulator;
    }
    
    const [head, ...tail] = arr;
    if (Array.isArray(head)) {
        return flattenArray(tail, [...accumulator, ...head]);
    } else {
        return flattenArray(tail, [...accumulator, head]);
    }
}
```

## Рекурсия в асинхронных функциях

```ts
// Рекурсивная обработка асинхронных операций
async function processNestedFolders(
    folderPath: string, 
    processor: (path: string) => Promise<void>
): Promise<void> {
    const items = await readDir(folderPath); // Предполагаем, что readDir возвращает список файлов/папок
    
    for (const item of items) {
        if (item.isDirectory) {
            await processNestedFolders(item.path, processor); // Рекурсивный вызов для подпапки
        } else {
            await processor(item.path); // Обработка файла
        }
    }
}
```

## Оптимизация рекурсии

### Мемоизация

```ts
// Мемоизированная версия функции Фибоначчи
function createMemoizedFibonacci() {
    const cache: { [key: number]: number } = {};
    
    function fibonacci(n: number): number {
        if (n in cache) {
            return cache[n];
        }
        
        if (n <= 1) {
            return n;
        }
        
        cache[n] = fibonacci(n - 1) + fibonacci(n - 2);
        return cache[n];
    }
    
    return fibonacci;
}

const memoizedFib = createMemoizedFibonacci();
console.log(memoizedFib(50)); // Вычисляется быстро благодаря кешированию
```

## Практические применения

### Обход файловой системы

```ts
interface FileItem {
    name: string;
    isDirectory: boolean;
    children?: FileItem[];
}

function findFilesByExtension(items: FileItem[], extension: string): string[] {
    let result: string[] = [];
    
    for (const item of items) {
        if (!item.isDirectory) {
            if (item.name.endsWith(extension)) {
                result.push(item.name);
            }
        } else if (item.children) {
            result = result.concat(findFilesByExtension(item.children, extension));
        }
    }
    
    return result;
}
```

### Обработка JSON-данных

```ts
// Рекурсивное обновление значений в JSON-объекте
function updateValues(obj: any, updateFn: (value: any) => any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => updateValues(item, updateFn));
    } else if (obj !== null && typeof obj === 'object') {
        const result: any = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                result[key] = updateValues(obj[key], updateFn);
            }
        }
        return result;
    } else {
        return updateFn(obj);
    }
}
```

## Обработка ошибок и предотвращение бесконечной рекурсии

```ts
// Рекурсивная функция с защитой от бесконечной рекурсии
function safeRecursiveFunction(
    value: number, 
    depth: number = 0, 
    maxDepth: number = 100
): number {
    if (depth > maxDepth) {
        throw new Error("Превышена максимальная глубина рекурсии");
    }
    
    if (value <= 1) {
        return 1;
    }
    
    return value * safeRecursiveFunction(value - 1, depth + 1, maxDepth);
}
```

## Лучшие практики

- Всегда определяйте базовый случай, чтобы избежать бесконечной рекурсии
- Используйте мемоизацию для оптимизации рекурсивных вычислений
- Рассмотрите возможность преобразования рекурсивных функций в итеративные для больших объемов данных
- Тщательно тестируйте рекурсивные функции с различными входными данными
- Используйте типы для документирования структуры данных, с которыми работает рекурсия

## Связанные темы

- [[Функции-высшего-порядка]]
- [[Стрелочные-функции]]
- [[Типизация-функций]]
- [[Перегрузка-функций]]
- [[Структуры данных в TypeScript]]
- [[Функциональное программирование]]

## Заключение

Рекурсивные функции - мощный инструмент в TypeScript, позволяющий элегантно решать задачи, которые можно разбить на подзадачи аналогичной структуры. Правильное использование рекурсии делает код более понятным и выразительным, особенно при работе с древовидными структурами данных. Однако важно помнить о риске переполнения стека вызовов и необходимости определения базового случая для завершения рекурсии.