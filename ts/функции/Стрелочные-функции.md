---
aliases: ["Стрелочные функции", "Lambda функции", "Arrow Functions"]
tags: [ts/функции, стрелочные-функции, programming]
---

# Стрелочные-функции

## Обзор

Стрелочные функции (arrow functions) - это краткий способ объявления функций в TypeScript и JavaScript. Они были введены в ES6 и предоставляют более лаконичный синтаксис по сравнению с традиционными функциональными выражениями. В TypeScript стрелочные функции также поддерживают типизацию параметров и возвращаемого значения.

## Синтаксис стрелочных функций

### Простой синтаксис

```ts
// Стрелочная функция без параметров
const greet = () => "Hello, World!";

// Стрелочная функция с одним параметром (скобки необязательны)
const square = (x: number): number => x * x;
const cube = (x: number): number => x * x * x;

// Стрелочная функция с несколькими параметрами
const add = (a: number, b: number): number => a + b;

// Стрелочная функция с телом в фигурных скобках
const multiply = (a: number, b: number): number => {
    const result = a * b;
    return result;
};
```

## Типизация стрелочных функций

### Явная типизация

```ts
// Типизация параметров и возвращаемого значения
const divide: (a: number, b: number) => number = (x, y) => x / y;

// Использование интерфейса для типизации
interface Calculator {
    (a: number, b: number): number;
}

const subtract: Calculator = (x, y) => x - y;
```

### Типизация с дженериками

```ts
// Универсальная стрелочная функция
const identity = <T>(arg: T): T => arg;

// Использование
const stringResult = identity<string>("hello");
const numberResult = identity(42);
```

## Отличия от обычных функций

### Контекст this

Самое важное отличие стрелочных функций - это привязка контекста `this`:

```ts
class Calculator {
    private factor: number = 2;
    
    // Обычная функция
    multiplyByFactor(numbers: number[]): number[] {
        return numbers.map(function(num) {
            // 'this' не ссылается на экземпляр класса Calculator
            // Это может привести к ошибке
            return num * this.factor; // ОШИБКА!
        });
    }
    
    // Стрелочная функция
    multiplyByFactorCorrect(numbers: number[]): number[] {
        return numbers.map((num) => {
            // 'this' корректно ссылается на экземпляр класса Calculator
            return num * this.factor; // РАБОТАЕТ!
        });
    }
}
```

### Отсутствие arguments

Стрелочные функции не имеют собственного объекта `arguments`:

```ts
// Обычная функция
function regularFunction() {
    console.log(arguments); // Доступен
}

// Стрелочная функция
const arrowFunction = () => {
    // console.log(arguments); // ОШИБКА! arguments не определен
};

// Решение - использовать rest параметры
const arrowFunctionWithRest = (...args: any[]) => {
    console.log(args); // Используем rest параметры вместо arguments
};
```

## Практические примеры использования

### Работа с массивами

```ts
const numbers = [1, 2, 3, 4, 5];

// Фильтрация
const evens = numbers.filter((num) => num % 2 === 0);

// Преобразование
const doubled = numbers.map((num) => num * 2);

// Суммирование
const sum = numbers.reduce((acc, curr) => acc + curr, 0);

// Сортировка
const sorted = numbers.sort((a, b) => a - b);
```

### Коллбэки

```ts
// Асинхронные операции
setTimeout(() => {
    console.log("Прошло 1000 мс");
}, 1000);

// Обработчики событий
document.addEventListener("click", (event) => {
    console.log("Клик по элементу:", event.target);
});
```

### Функции высшего порядка

```ts
// Создание каррированной функции
const multiplyBy = (factor: number) => (value: number): number => value * factor;

const double = multiplyBy(2);
const triple = multiplyBy(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

## Стрелочные функции и Promise

```ts
// Асинхронная стрелочная функция
const fetchData = async (): Promise<string> => {
    const response = await fetch('/api/data');
    return response.text();
};

// Цепочка Promise
fetchData()
    .then((data) => data.toUpperCase())
    .then((processed) => console.log(processed))
    .catch((error) => console.error('Ошибка:', error));
```

## Лучшие практики

### Использование для простых операций

```ts
// Хорошо подходит для простых операций
const isEven = (num: number): boolean => num % 2 === 0;
const formatName = (first: string, last: string): string => `${first} ${last}`;
```

### Избегать для сложных операций

```ts
// Не рекомендуется для сложных функций
const complexOperation = (data: any[]) => {
    // Много строк кода
    let result = [];
    for (let i = 0; i < data.length; i++) {
        // Сложная логика
        if (data[i].value > 10) {
            result.push({
                id: data[i].id,
                processed: true
            });
        }
    }
    return result;
};

// Лучше использовать обычную функцию для сложных операций
function complexOperation(data: any[]) {
    // То же содержимое, но более читаемо
    let result = [];
    for (let i = 0; i < data.length; i++) {
        if (data[i].value > 10) {
            result.push({
                id: data[i].id,
                processed: true
            });
        }
    }
    return result;
}
```

### Сохранение читаемости

```ts
// Для однострочных функций
const add = (a: number, b: number): number => a + b;

// Для многострочных функций - использовать фигурные скобки
const processUser = (user: { name: string; age: number }): string => {
    const { name, age } = user;
    if (age >= 18) {
        return `Взрослый пользователь: ${name}`;
    } else {
        return `Молодой пользователь: ${name}`;
    }
};
```

## Связанные темы

- [[Типизация-функций]]
- [[Перегрузка-функций]]
- [[Функции-высшего-порядка]]
- [[Рекурсивные-функции]]
- [[Контекст this в TypeScript]]

## Заключение

Стрелочные функции предоставляют краткий и выразительный способ объявления функций в TypeScript. Они особенно полезны для простых операций, коллбэков и функций высшего порядка. Понимание их особенностей, таких как привязка контекста `this`, позволяет использовать их эффективно и избегать распространенных ошибок.