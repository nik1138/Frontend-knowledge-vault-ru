---
aliases: [Модульность и масштабируемость, Модульная архитектура]
tags: [typescript, архитектура, модульность, масштабируемость, паттерны-проектирования]
---

# Модульность и масштабируемость

Модульность и масштабируемость являются ключевыми аспектами архитектуры TypeScript-приложений. Они обеспечивают возможность легкого расширения функциональности, упрощают сопровождение кода и позволяют командам разработчиков эффективно работать над различными частями приложения.

## Понятие модульности

Модульность - это принцип проектирования, при котором система разбивается на отдельные компоненты (модули), каждый из которых отвечает за определенную функциональность. Каждый модуль должен быть:
- **Замкнутым** - иметь четко определенные границы и зависимости
- **Самодостаточным** - содержать всю необходимую логику для выполнения своей задачи
- **Независимым** - минимально зависеть от других модулей
- **Повторно используемым** - быть применимым в различных контекстах

### Принципы модульности

1. **Высокая связность (cohesion)** - элементы внутри модуля должны быть тесно связаны по функциональности
2. **Низкая зацепленность (coupling)** - зависимости между модулями должны быть минимальными
3. **Открытость/закрытость (Open/Closed Principle)** - модули должны быть открыты для расширения, но закрыты для модификации
4. **Подстановка Лисков (Liskov Substitution)** - объекты в программе должны быть заменяемыми экземплярами их подтипов

## Организация модулей в TypeScript

### Структура проекта

Правильная структура проекта способствует модульности:

```typescript
// Пример структуры проекта с модульной архитектурой
src/
├── modules/
│   ├── user/
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── value-objects/
│   │   │   ├── repositories/
│   │   │   └── services/
│   │   ├── application/
│   │   │   ├── use-cases/
│   │   │   └── dtos/
│   │   ├── infrastructure/
│   │   │   ├── persistence/
│   │   │   └── api/
│   │   └── presentation/
│   │       ├── controllers/
│   │       └── dtos/
│   ├── product/
│   │   ├── domain/
│   │   ├── application/
│   │   ├── infrastructure/
│   │   └── presentation/
│   └── shared/
│       ├── domain/
│       ├── application/
│       ├── infrastructure/
│       └── presentation/
├── main.ts
└── container.ts
```

### Модульная архитектура на примере домена пользователя

```typescript
// modules/user/domain/entities/User.ts
export interface UserProps {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
}

export class User {
  readonly id: string;
  private email: string;
  private name: string;
  readonly createdAt: Date;

  constructor(props: UserProps) {
    this.id = props.id;
    this.email = props.email;
    this.name = props.name;
    this.createdAt = props.createdAt;
    this.validate();
  }

  private validate(): void {
    if (!this.email || !this.isValidEmail(this.email)) {
      throw new Error('Invalid email');
    }
  }

  private isValidEmail(email: string): boolean {
    // Проверка email
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  // Геттеры и сеттеры
  getEmail(): string {
    return this.email;
  }

  getName(): string {
    return this.name;
  }

  updateEmail(email: string): void {
    if (!this.isValidEmail(email)) {
      throw new Error('Invalid email');
    }
    this.email = email;
  }

  updateName(name: string): void {
    if (!name || name.trim().length === 0) {
      throw new Error('Name cannot be empty');
    }
    this.name = name;
  }
}

// modules/user/domain/repositories/UserRepository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: User): Promise<void>;
  delete(id: string): Promise<void>;
}

// modules/user/application/use-cases/GetUserUseCase.ts
export interface GetUserUseCaseRequest {
  userId: string;
}

export interface GetUserUseCaseResponse {
  user: User | null;
  error?: string;
}

export interface GetUserUseCase {
  execute(request: GetUserUseCaseRequest): Promise<GetUserUseCaseResponse>;
}

export class GetUserUseCaseImpl implements GetUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(request: GetUserUseCaseRequest): Promise<GetUserUseCaseResponse> {
    try {
      const user = await this.userRepository.findById(request.userId);
      return { user };
    } catch (error) {
      return { 
        user: null, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
}
```

## Масштабируемость приложений

Масштабируемость - способность системы эффективно обрабатывать увеличение нагрузки. В контексте архитектуры приложений это означает возможность расширения функциональности без значительных изменений в существующем коде.

### Горизонтальное и вертикальное масштабирование

- **Вертикальное масштабирование** - увеличение мощности отдельных компонентов (CPU, RAM)
- **Горизонтальное масштабирование** - добавление новых экземпляров компонентов

### Паттерны масштабируемости

#### 1. Микросервисная архитектура

Разбиение приложения на независимые сервисы:

```typescript
// Пример микросервиса пользователя
// services/user-service/src/main.ts
import express from 'express';
import { UserController } from './controllers/UserController';
import { UserRepositoryImpl } from './repositories/UserRepositoryImpl';
import { GetUserUseCaseImpl } from './usecases/GetUserUseCaseImpl';

const app = express();
app.use(express.json());

// Инъекция зависимостей
const userRepository = new UserRepositoryImpl();
const getUserUseCase = new GetUserUseCaseImpl(userRepository);
const userController = new UserController(getUserUseCase);

app.get('/users/:id', (req, res) => userController.getUser(req, res));

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`User service running on port ${PORT}`);
});
```

#### 2. Событийно-ориентированная архитектура

Использование событий для связи между модулями:

```typescript
// shared/events/EventBus.ts
export interface Event {
  type: string;
  payload: any;
}

export interface EventHandler<T extends Event = Event> {
  handle(event: T): void;
}

export class EventBus {
  private handlers: Map<string, EventHandler[]> = new Map();

  subscribe<T extends Event>(eventType: string, handler: EventHandler<T>): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }

  publish(event: Event): void {
    const handlers = this.handlers.get(event.type) || [];
    handlers.forEach(handler => handler.handle(event));
  }
}

// modules/user/events/UserCreatedEvent.ts
export interface UserCreatedEvent extends Event {
  type: 'UserCreated';
  payload: {
    userId: string;
    email: string;
    name: string;
  };
}

// modules/notification/services/NotificationService.ts
export class NotificationService implements EventHandler<UserCreatedEvent> {
  async handle(event: UserCreatedEvent): Promise<void> {
    // Отправка приветственного письма
    await this.sendWelcomeEmail(event.payload.email, event.payload.name);
  }

  private async sendWelcomeEmail(email: string, name: string): Promise<void> {
    // Реализация отправки email
    console.log(`Sending welcome email to ${name} at ${email}`);
  }
}

// Регистрация обработчика
const eventBus = new EventBus();
const notificationService = new NotificationService();
eventBus.subscribe('UserCreated', notificationService);
```

## Инверсия зависимостей и DI

Для обеспечения модульности и тестируемости используется инверсия зависимостей:

```typescript
// shared/container/Container.ts
export interface Container {
  resolve<T>(token: string): T;
  register<T>(token: string, resolver: () => T): void;
}

export class DependencyContainer implements Container {
  private registrations: Map<string, () => any> = new Map();

  register<T>(token: string, resolver: () => T): void {
    this.registrations.set(token, resolver);
  }

  resolve<T>(token: string): T {
    const resolver = this.registrations.get(token);
    if (!resolver) {
      throw new Error(`No registration found for token: ${token}`);
    }
    return resolver();
  }
}

// modules/user/container/UserModule.ts
export class UserModule {
  static register(container: DependencyContainer): void {
    // Репозитории
    container.register<UserRepository>(
      'UserRepository',
      () => new UserRepositoryImpl()
    );

    // Юзкейсы
    container.register<GetUserUseCase>(
      'GetUserUseCase',
      () => new GetUserUseCaseImpl(container.resolve('UserRepository'))
    );

    // Контроллеры
    container.register<UserController>(
      'UserController',
      () => new UserController(container.resolve('GetUserUseCase'))
    );
  }
}

// main.ts
const container = new DependencyContainer();
UserModule.register(container);

const userController = container.resolve<UserController>('UserController');
```

## Модульные тесты

Модульность упрощает тестирование за счет изоляции компонентов:

```typescript
// tests/modules/user/GetUserUseCase.test.ts
import { GetUserUseCaseImpl } from '../../../src/modules/user/application/use-cases/GetUserUseCase';
import { UserRepository } from '../../../src/modules/user/domain/repositories/UserRepository';
import { User } from '../../../src/modules/user/domain/entities/User';

describe('GetUserUseCase', () => {
  let getUserUseCase: GetUserUseCaseImpl;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = {
      findById: jest.fn(),
      findByEmail: jest.fn(),
      save: jest.fn(),
      delete: jest.fn(),
    };

    getUserUseCase = new GetUserUseCaseImpl(mockUserRepository);
  });

  it('should return user when found', async () => {
    const mockUser = new User({
      id: '1',
      email: 'test@example.com',
      name: 'Test User',
      createdAt: new Date(),
    });

    mockUserRepository.findById.mockResolvedValue(mockUser);

    const result = await getUserUseCase.execute({ userId: '1' });

    expect(result.user).toBe(mockUser);
    expect(mockUserRepository.findById).toHaveBeenCalledWith('1');
  });

  it('should return null when user not found', async () => {
    mockUserRepository.findById.mockResolvedValue(null);

    const result = await getUserUseCase.execute({ userId: '1' });

    expect(result.user).toBeNull();
  });
});
```

## Повторное использование модулей

Модули могут быть упакованы и использованы в других проектах:

```typescript
// package.json для модуля
{
  "name": "@company/user-module",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "typescript": "^4.9.0"
  }
}

// dist/index.ts
export { User } from './modules/user/domain/entities/User';
export { UserRepository } from './modules/user/domain/repositories/UserRepository';
export { GetUserUseCase } from './modules/user/application/use-cases/GetUserUseCase';
export { UserModule } from './modules/user/container/UserModule';
```

## Масштабирование с помощью архитектурных шаблонов

### Шаблон "Сага" для управления распределенными транзакциями

```typescript
// shared/patterns/Saga.ts
export interface SagaStep<T> {
  execute(data: T): Promise<T>;
  compensate(data: T): Promise<void>;
}

export class Saga<T> {
  private steps: SagaStep<T>[] = [];

  addStep(step: SagaStep<T>): this {
    this.steps.push(step);
    return this;
  }

  async execute(initialData: T): Promise<T> {
    const executedSteps: SagaStep<T>[] = [];
    let data = initialData;

    try {
      for (const step of this.steps) {
        data = await step.execute(data);
        executedSteps.push(step);
      }
    } catch (error) {
      // Компенсация выполненных шагов
      for (const step of executedSteps.reverse()) {
        await step.compensate(data);
      }
      throw error;
    }

    return data;
  }
}

// modules/order/sagas/CreateOrderSaga.ts
export class CreateOrderSaga implements Saga<OrderData> {
  // Реализация создания заказа с компенсацией при ошибках
}
```

## Заключение

Модульность и масштабируемость являются фундаментальными принципами архитектуры TypeScript-приложений. Правильное применение этих принципов позволяет создавать гибкие, поддерживаемые и расширяемые системы. Ключевыми факторами успеха являются:
- Четкое разделение ответственности
- Использование принципов SOLID
- Инверсия зависимостей
- Тестируемость компонентов
- Повторное использование модулей

## Связанные темы

- [[Чистая-архитектура]]
- [[Архитектура-фронтенда]]
- [[Архитектурные-шаблоны]]
- [[Архитектурные-решения]]
- [[Паттерны-проектирования]]