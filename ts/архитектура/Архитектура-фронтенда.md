---
aliases: [Архитектура фронтенда, Фронтенд архитектура]
tags: [typescript, архитектура, фронтенд, react, angular, vue]
---

# Архитектура фронтенда

Архитектура фронтенд-приложений на TypeScript требует особого внимания к структуре, управлению состоянием, взаимодействию компонентов и масштабируемости. В современных веб-приложениях фронтенд стал настолько сложным, что требует тщательного проектирования архитектуры для обеспечения поддерживаемости и производительности.

## Основные компоненты архитектуры фронтенда

### Структура проекта

Хорошая архитектура начинается с правильной структуры проекта. Существует несколько подходов к организации файлов:

1. **По слоям** (layers-based): разделение по типу функциональности (components, services, models, views)
2. **По функциям** (feature-based): группировка файлов по функциональным областям
3. **По доменам** (domain-based): организация по бизнес-доменам

```typescript
// Пример структуры проекта по функциям
src/
├── features/
│   ├── auth/
│   │   ├── components/
│   │   ├── services/
│   │   ├── store/
│   │   └── types/
│   ├── user-profile/
│   │   ├── components/
│   │   ├── services/
│   │   ├── store/
│   │   └── types/
│   └── products/
├── shared/
│   ├── components/
│   ├── hooks/
│   ├── utils/
│   └── types/
├── app/
│   ├── providers/
│   └── routes/
└── main.tsx
```

### Управление состоянием

Управление состоянием - критический аспект фронтенд-архитектуры. В зависимости от сложности приложения можно использовать разные подходы:

- **React Context** для простых случаев
- **Redux Toolkit** для сложных приложений
- **MobX** для реактивного управления состоянием
- **Zustand** для легковесных решений
- **Jotai/Recoil** для атомарного управления состоянием

```typescript
// Пример использования Redux Toolkit
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface UserState {
  currentUser: User | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: UserState = {
  currentUser: null,
  isLoading: false,
  error: null,
};

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    loginStart: (state) => {
      state.isLoading = true;
      state.error = null;
    },
    loginSuccess: (state, action: PayloadAction<User>) => {
      state.isLoading = false;
      state.currentUser = action.payload;
    },
    loginFailure: (state, action: PayloadAction<string>) => {
      state.isLoading = false;
      state.error = action.payload;
    },
    logout: (state) => {
      state.currentUser = null;
    },
  },
});

export const { loginStart, loginSuccess, loginFailure, logout } = userSlice.actions;
```

### Архитектурные шаблоны для компонентов

#### Container/Presentational (умные/глупые компоненты)

Разделение компонентов на контейнеры (управляющие логикой) и презентационные (отвечающие за отображение).

```typescript
// Presentational компонент
interface UserProfileProps {
  user: User;
  onEdit: () => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({ user, onEdit }) => (
  <div className="user-profile">
    <h2>{user.name}</h2>
    <p>{user.email}</p>
    <button onClick={onEdit}>Редактировать</button>
  </div>
);

// Container компонент
import { useSelector, useDispatch } from 'react-redux';
import { selectCurrentUser } from '../store/userSlice';
import { logout } from '../store/userSlice';

export const UserProfileContainer: React.FC = () => {
  const user = useSelector(selectCurrentUser);
  const dispatch = useDispatch();

  const handleEdit = () => {
    // Логика редактирования
  };

  if (!user) {
    return <div>Пользователь не авторизован</div>;
  }

  return <UserProfile user={user} onEdit={handleEdit} />;
};
```

#### Компоненты с хуками

Использование пользовательских хуков для изоляции логики:

```typescript
// Пользовательский хук
export const useUserProfile = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUser = useCallback(async () => {
    try {
      setLoading(true);
      const userData = await api.getUserProfile();
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Ошибка загрузки профиля');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  const updateUser = useCallback(async (updatedData: Partial<User>) => {
    if (!user) return;
    
    try {
      const updatedUser = await api.updateUserProfile(user.id, updatedData);
      setUser(updatedUser);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Ошибка обновления профиля');
    }
  }, [user]);

  return { user, loading, error, updateUser, refetch: fetchUser };
};

// Использование хука в компоненте
export const UserProfile: React.FC = () => {
  const { user, loading, error, updateUser } = useUserProfile();

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;
  if (!user) return <div>Пользователь не найден</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => updateUser({ name: 'Новое имя' })}>
        Обновить имя
      </button>
    </div>
  );
};
```

## Обработка асинхронных операций

### React Query / SWR

Для управления серверным состоянием рекомендуется использовать библиотеки вроде React Query или SWR:

```typescript
import { useQuery, useMutation, useQueryClient } from 'react-query';

// Запрос данных
const useUser = (userId: string) => {
  return useQuery<User, Error>(
    ['user', userId],
    () => api.fetchUser(userId),
    {
      enabled: !!userId,
      staleTime: 5 * 60 * 1000, // 5 минут
    }
  );
};

// Мутация данных
const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation(
    (userData: Partial<User>) => api.updateUser(userData),
    {
      onSuccess: (updatedUser) => {
        // Инвалидация кэша
        queryClient.invalidateQueries(['user', updatedUser.id]);
      },
    }
  );
};
```

## Типизация в фронтенд-архитектуре

TypeScript играет ключевую роль в фронтенд-архитектуре, обеспечивая безопасность типов:

```typescript
// Типы для API
export interface User {
  id: string;
  name: string;
  email: string;
  createdAt: string;
  updatedAt: string;
}

export interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

// Типы для компонентов
export interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
  variant?: 'primary' | 'secondary' | 'danger';
  disabled?: boolean;
}

// Типы для хуков
export interface UseFormReturn<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  handleChange: (field: keyof T, value: any) => void;
  handleSubmit: () => void;
  isValid: boolean;
}
```

## Модульность и повторное использование

### Хуки для бизнес-логики

Создание пользовательских хуков для изоляции бизнес-логики:

```typescript
// Хук для управления формой
export const useForm = <T extends Record<string, any>>(initialValues: T) => {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});

  const handleChange = (field: keyof T, value: any) => {
    setValues(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Очистка ошибки при изменении поля
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  };

  const validate = (): boolean => {
    const newErrors: Partial<Record<keyof T, string>> = {};
    
    // Простая валидация - можно расширить
    Object.entries(values).forEach(([key, value]) => {
      if (!value && typeof value !== 'boolean') {
        newErrors[key as keyof T] = 'Обязательное поле';
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (onSubmit: (data: T) => void) => {
    if (validate()) {
      onSubmit(values);
    }
  };

  return {
    values,
    errors,
    handleChange,
    handleSubmit,
    isValid: Object.keys(errors).length === 0
  };
};
```

### Утилиты и хелперы

Создание переиспользуемых утилит:

```typescript
// Утилита для форматирования даты
export const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString('ru-RU', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

// Утилита для валидации email
export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Утилита для форматирования чисел
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ru-RU').format(num);
};
```

## Безопасность фронтенда

### Защита от XSS

```typescript
// Утилита для очистки HTML
import DOMPurify from 'dompurify';

export const sanitizeHtml = (html: string): string => {
  return DOMPurify.sanitize(html);
};

// Использование в компоненте
const SafeContent: React.FC<{ content: string }> = ({ content }) => {
  const sanitizedContent = useMemo(() => sanitizeHtml(content), [content]);
  
  return (
    <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />
  );
};
```

## Тестирование фронтенд-архитектуры

### Модульное тестирование

```typescript
// Тестирование пользовательского хука
import { renderHook, act } from '@testing-library/react';
import { useForm } from './useForm';

describe('useForm', () => {
  it('should initialize with correct values', () => {
    const { result } = renderHook(() => useForm({ name: '', email: '' }));
    
    expect(result.current.values).toEqual({ name: '', email: '' });
    expect(result.current.errors).toEqual({});
  });

  it('should update values correctly', () => {
    const { result } = renderHook(() => useForm({ name: '', email: '' }));
    
    act(() => {
      result.current.handleChange('name', 'John');
    });
    
    expect(result.current.values.name).toBe('John');
  });
});
```

## Заключение

Архитектура фронтенд-приложений на TypeScript требует комплексного подхода к структуре, типизации, управлению состоянием и тестированию. Правильная архитектура обеспечивает масштабируемость, поддерживаемость и надежность приложения.

## Связанные темы

- [[Чистая-архитектура]]
- [[Модульность-и-масштабируемость]]
- [[Архитектурные-шаблоны]]
- [[Архитектурные-решения]]
- [[Управление-состоянием-в-React]]