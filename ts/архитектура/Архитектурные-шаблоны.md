---
aliases: [Архитектурные шаблоны, Паттерны архитектуры]
tags: [typescript, архитектура, паттерны-проектирования, шаблоны]
---

# Архитектурные шаблоны

Архитектурные шаблоны представляют собой проверенные временем решения для часто встречающихся проблем в проектировании программного обеспечения. В контексте TypeScript-приложений эти шаблоны помогают создавать надежные, масштабируемые и поддерживаемые системы. Понимание и правильное применение архитектурных шаблонов позволяет разработчикам эффективно решать сложные задачи проектирования.

## Классификация архитектурных шаблонов

Архитектурные шаблоны можно разделить на несколько категорий:

1. **Модульные шаблоны** - обеспечивают структурирование кода на модули
2. **Шаблоны интеграции** - определяют способы взаимодействия между компонентами
3. **Шаблоны распределенных систем** - решают задачи масштабирования и распределения
4. **Шаблоны управления состоянием** - обеспечивают согласованность данных

## Модульные шаблоны

### Repository Pattern

Шаблон Repository предоставляет абстракцию для доступа к данным, изолируя логику домена от деталей хранения данных.

```typescript
// domain/entities/User.ts
export interface UserProps {
  id: string;
  email: string;
  name: string;
}

export class User {
  readonly id: string;
  private email: string;
  private name: string;

  constructor(props: UserProps) {
    this.id = props.id;
    this.email = props.email;
    this.name = props.name;
  }

  // Геттеры и методы обновления
  getEmail(): string {
    return this.email;
  }

  updateEmail(email: string): void {
    this.email = email;
  }
}

// domain/repositories/UserRepository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: User): Promise<void>;
  delete(id: string): Promise<void>;
}

// infrastructure/repositories/UserRepositoryImpl.ts
export class UserRepositoryImpl implements UserRepository {
  private users: Map<string, User> = new Map();

  async findById(id: string): Promise<User | null> {
    return this.users.get(id) || null;
  }

  async findByEmail(email: string): Promise<User | null> {
    for (const user of this.users.values()) {
      if (user.getEmail() === email) {
        return user;
      }
    }
    return null;
  }

  async save(user: User): Promise<void> {
    this.users.set(user.id, user);
  }

  async delete(id: string): Promise<void> {
    this.users.delete(id);
  }
}
```

### Service Layer Pattern

Шаблон Service Layer инкапсулирует бизнес-логику приложения в отдельные сервисы.

```typescript
// application/services/UserService.ts
export interface UserService {
  createUser(email: string, name: string): Promise<User>;
  updateUser(id: string, updates: Partial<User>): Promise<User>;
  deleteUser(id: string): Promise<void>;
}

export class UserServiceImpl implements UserService {
  constructor(
    private userRepository: UserRepository,
    private emailValidator: EmailValidator
  ) {}

  async createUser(email: string, name: string): Promise<User> {
    if (!this.emailValidator.isValid(email)) {
      throw new Error('Invalid email');
    }

    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    const user = new User({
      id: this.generateId(),
      email,
      name
    });

    await this.userRepository.save(user);
    return user;
  }

  async updateUser(id: string, updates: Partial<User>): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new Error('User not found');
    }

    if (updates.email) {
      const existingUser = await this.userRepository.findByEmail(updates.email);
      if (existingUser && existingUser.id !== id) {
        throw new Error('Email already in use');
      }
    }

    Object.assign(user, updates);
    await this.userRepository.save(user);
    return user;
  }

  async deleteUser(id: string): Promise<void> {
    await this.userRepository.delete(id);
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

### Specification Pattern

Шаблон Specification позволяет создавать сложные критерии фильтрации с помощью композиции простых спецификаций.

```typescript
// domain/specifications/Specification.ts
export interface Specification<T> {
  isSatisfiedBy(candidate: T): boolean;
  and(other: Specification<T>): Specification<T>;
  or(other: Specification<T>): Specification<T>;
  not(): Specification<T>;
}

export abstract class BaseSpecification<T> implements Specification<T> {
  abstract isSatisfiedBy(candidate: T): boolean;

  and(other: Specification<T>): Specification<T> {
    return new AndSpecification(this, other);
  }

  or(other: Specification<T>): Specification<T> {
    return new OrSpecification(this, other);
  }

  not(): Specification<T> {
    return new NotSpecification(this);
  }
}

class AndSpecification<T> extends BaseSpecification<T> {
  constructor(
    private left: Specification<T>,
    private right: Specification<T>
  ) {
    super();
  }

  isSatisfiedBy(candidate: T): boolean {
    return this.left.isSatisfiedBy(candidate) && 
           this.right.isSatisfiedBy(candidate);
  }
}

class OrSpecification<T> extends BaseSpecification<T> {
  constructor(
    private left: Specification<T>,
    private right: Specification<T>
  ) {
    super();
  }

  isSatisfiedBy(candidate: T): boolean {
    return this.left.isSatisfiedBy(candidate) || 
           this.right.isSatisfiedBy(candidate);
  }
}

class NotSpecification<T> extends BaseSpecification<T> {
  constructor(private specification: Specification<T>) {
    super();
  }

  isSatisfiedBy(candidate: T): boolean {
    return !this.specification.isSatisfiedBy(candidate);
  }
}

// domain/specifications/UserSpecifications.ts
export class UserEmailSpecification extends BaseSpecification<User> {
  constructor(private email: string) {
    super();
  }

  isSatisfiedBy(user: User): boolean {
    return user.getEmail() === this.email;
  }
}

export class UserActiveSpecification extends BaseSpecification<User> {
  isSatisfiedBy(user: User): boolean {
    // Предположим, что у User есть поле isActive
    return (user as any).isActive === true;
  }
}

// Использование спецификаций
const activeUsersWithEmail = users.filter(
  user => new UserActiveSpecification()
    .and(new UserEmailSpecification('test@example.com'))
    .isSatisfiedBy(user)
);
```

## Шаблоны интеграции

### Command Pattern

Шаблон Command инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами.

```typescript
// application/commands/Command.ts
export interface Command {
  execute(): Promise<void>;
}

export interface CommandHandler<T extends Command> {
  handle(command: T): Promise<void>;
}

// application/commands/CreateUserCommand.ts
export interface CreateUserCommandData {
  email: string;
  name: string;
}

export class CreateUserCommand implements Command {
  constructor(public readonly data: CreateUserCommandData) {}
  
  async execute(): Promise<void> {
    // Реализация будет в обработчике
  }
}

// application/handlers/CreateUserCommandHandler.ts
export class CreateUserCommandHandler implements CommandHandler<CreateUserCommand> {
  constructor(private userService: UserService) {}

  async handle(command: CreateUserCommand): Promise<void> {
    await this.userService.createUser(
      command.data.email,
      command.data.name
    );
  }
}

// application/mediator/CommandMediator.ts
export class CommandMediator {
  private handlers: Map<Function, CommandHandler<Command>> = new Map();

  register<T extends Command>(
    commandType: new (...args: any[]) => T,
    handler: CommandHandler<T>
  ): void {
    this.handlers.set(commandType, handler);
  }

  async execute<T extends Command>(command: T): Promise<void> {
    const handler = this.handlers.get(command.constructor as Function);
    if (!handler) {
      throw new Error(`No handler registered for command: ${command.constructor.name}`);
    }
    return handler.handle(command);
  }
}

// Использование
const mediator = new CommandMediator();
mediator.register(CreateUserCommand, new CreateUserCommandHandler(userService));

await mediator.execute(new CreateUserCommand({ 
  email: 'test@example.com', 
  name: 'Test User' 
}));
```

### Observer Pattern

Шаблон Observer определяет зависимость "один ко многим" между объектами, так что при изменении состояния одного объекта все зависящие от него объекты уведомляются автоматически.

```typescript
// shared/observer/Observable.ts
export interface Observer<T> {
  update(data: T): void;
}

export interface Observable<T> {
  subscribe(observer: Observer<T>): void;
  unsubscribe(observer: Observer<T>): void;
  notify(data: T): void;
}

export class EventObservable<T> implements Observable<T> {
  private observers: Observer<T>[] = [];

  subscribe(observer: Observer<T>): void {
    this.observers.push(observer);
  }

  unsubscribe(observer: Observer<T>): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(data: T): void {
    this.observers.forEach(observer => observer.update(data));
  }
}

// application/events/UserEvents.ts
export interface UserCreatedEvent {
  userId: string;
  email: string;
  timestamp: Date;
}

export class UserEventObservable extends EventObservable<UserCreatedEvent> {}

// infrastructure/listeners/UserNotificationListener.ts
export class UserNotificationListener implements Observer<UserCreatedEvent> {
  update(event: UserCreatedEvent): void {
    console.log(`Sending notification for user ${event.userId}`);
    // Отправка уведомления
  }
}

// Использование
const userEventObservable = new UserEventObservable();
const notificationListener = new UserNotificationListener();
userEventObservable.subscribe(notificationListener);

// Когда создается пользователь
userEventObservable.notify({
  userId: '123',
  email: 'test@example.com',
  timestamp: new Date()
});
```

## Шаблоны распределенных систем

### CQRS (Command Query Responsibility Segregation)

Шаблон CQRS разделяет операции чтения и записи, позволяя оптимизировать каждую часть системы отдельно.

```typescript
// application/commands/Command.ts
export interface Command {
  readonly id: string;
}

// application/queries/Query.ts
export interface Query<T> {
  readonly id: string;
}

// application/handlers/CommandHandler.ts
export interface CommandHandler<T extends Command> {
  handle(command: T): Promise<void>;
}

// application/handlers/QueryHandler.ts
export interface QueryHandler<T extends Query<R>, R> {
  handle(query: T): Promise<R>;
}

// application/commands/CreateProductCommand.ts
export interface CreateProductData {
  name: string;
  price: number;
  description: string;
}

export class CreateProductCommand implements Command {
  readonly id: string;
  constructor(
    public readonly data: CreateProductData
  ) {
    this.id = Math.random().toString(36).substr(2, 9);
  }
}

// application/queries/GetProductQuery.ts
export class GetProductQuery implements Query<ProductReadModel> {
  readonly id: string;
  constructor(public readonly productId: string) {
    this.id = Math.random().toString(36).substr(2, 9);
  }
}

// application/read-models/ProductReadModel.ts
export interface ProductReadModel {
  id: string;
  name: string;
  price: number;
  description: string;
  createdAt: Date;
}

// infrastructure/commands/ProductCommandHandler.ts
export class CreateProductCommandHandler implements CommandHandler<CreateProductCommand> {
  constructor(private productRepository: ProductRepository) {}

  async handle(command: CreateProductCommand): Promise<void> {
    const product = new Product({
      id: command.id,
      name: command.data.name,
      price: command.data.price,
      description: command.data.description,
      createdAt: new Date()
    });

    await this.productRepository.save(product);
  }
}

// infrastructure/queries/ProductQueryHandler.ts
export class GetProductQueryHandler implements QueryHandler<GetProductQuery, ProductReadModel> {
  constructor(private productReadRepository: ProductReadRepository) {}

  async handle(query: GetProductQuery): Promise<ProductReadModel> {
    return this.productReadRepository.findById(query.productId);
  }
}

// application/mediator/CQRSMediator.ts
export class CQRSMediator {
  private commandHandlers: Map<Function, CommandHandler<Command>> = new Map();
  private queryHandlers: Map<Function, QueryHandler<Query<any>, any>> = new Map();

  registerCommand<T extends Command>(
    commandType: new (...args: any[]) => T,
    handler: CommandHandler<T>
  ): void {
    this.commandHandlers.set(commandType, handler);
  }

  registerQuery<T extends Query<R>, R>(
    queryType: new (...args: any[]) => T,
    handler: QueryHandler<T, R>
  ): void {
    this.queryHandlers.set(queryType, handler);
  }

  async sendCommand<T extends Command>(command: T): Promise<void> {
    const handler = this.commandHandlers.get(command.constructor as Function);
    if (!handler) {
      throw new Error(`No command handler for: ${command.constructor.name}`);
    }
    return handler.handle(command);
  }

  async query<T extends Query<R>, R>(query: T): Promise<R> {
    const handler = this.queryHandlers.get(query.constructor as Function);
    if (!handler) {
      throw new Error(`No query handler for: ${query.constructor.name}`);
    }
    return handler.handle(query);
  }
}
```

### Event Sourcing

Шаблон Event Sourcing сохраняет изменения состояния системы в виде последовательности событий, а не в виде текущего состояния.

```typescript
// shared/events/Event.ts
export interface Event {
  readonly id: string;
  readonly aggregateId: string;
  readonly type: string;
  readonly data: any;
  readonly timestamp: Date;
}

// domain/aggregates/ProductAggregate.ts
export class ProductAggregate {
  private events: Event[] = [];
  private currentVersion = 0;

  constructor(public readonly id: string, private name: string, private price: number) {}

  static create(id: string, name: string, price: number): ProductAggregate {
    const aggregate = new ProductAggregate(id, name, price);
    aggregate.applyEvent({
      id: Math.random().toString(36).substr(2, 9),
      aggregateId: id,
      type: 'ProductCreated',
      data: { name, price },
      timestamp: new Date()
    });
    return aggregate;
  }

  changePrice(newPrice: number): void {
    if (newPrice <= 0) {
      throw new Error('Price must be positive');
    }
    
    this.applyEvent({
      id: Math.random().toString(36).substr(2, 9),
      aggregateId: this.id,
      type: 'ProductPriceChanged',
      data: { oldPrice: this.price, newPrice },
      timestamp: new Date()
    });
  }

  private applyEvent(event: Event): void {
    this.events.push(event);
    this.apply(event);
    this.currentVersion++;
  }

  private apply(event: Event): void {
    switch (event.type) {
      case 'ProductCreated':
        // Уже установлено в конструкторе
        break;
      case 'ProductPriceChanged':
        this.price = (event.data as any).newPrice;
        break;
    }
  }

  getEvents(): Event[] {
    return [...this.events];
  }

  getVersion(): number {
    return this.currentVersion;
  }
}

// infrastructure/event-store/EventStore.ts
export interface EventStore {
  saveEvents(aggregateId: string, events: Event[], expectedVersion: number): Promise<void>;
  loadEvents(aggregateId: string): Promise<Event[]>;
}

export class InMemoryEventStore implements EventStore {
  private events: Map<string, Event[]> = new Map();
  private versions: Map<string, number> = new Map();

  async saveEvents(aggregateId: string, events: Event[], expectedVersion: number): Promise<void> {
    const currentVersion = this.versions.get(aggregateId) || 0;
    
    if (expectedVersion !== currentVersion) {
      throw new Error(`Optimistic lock failed for aggregate ${aggregateId}`);
    }

    const existingEvents = this.events.get(aggregateId) || [];
    this.events.set(aggregateId, [...existingEvents, ...events]);
    this.versions.set(aggregateId, currentVersion + events.length);
  }

  async loadEvents(aggregateId: string): Promise<Event[]> {
    return this.events.get(aggregateId) || [];
  }
}

// application/services/ProductService.ts
export class ProductService {
  constructor(
    private eventStore: EventStore
  ) {}

  async createProduct(id: string, name: string, price: number): Promise<void> {
    const product = ProductAggregate.create(id, name, price);
    await this.eventStore.saveEvents(
      product.id, 
      product.getEvents(), 
      product.getVersion() - product.getEvents().length
    );
  }

  async changeProductPrice(productId: string, newPrice: number): Promise<void> {
    const events = await this.eventStore.loadEvents(productId);
    const product = new ProductAggregate(productId, '', 0);
    
    // Восстановление состояния из событий
    events.forEach(event => {
      (product as any).apply(event);
    });

    product.changePrice(newPrice);
    
    await this.eventStore.saveEvents(
      product.id,
      product.getEvents().slice(-1), // Только последнее событие
      product.getVersion() - 1
    );
  }
}
```

## Шаблоны управления состоянием

### State Pattern

Шаблон State позволяет объекту изменять свое поведение в зависимости от внутреннего состояния.

```typescript
// domain/entities/Order.ts
export enum OrderStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  SHIPPED = 'shipped',
  DELIVERED = 'delivered',
  CANCELLED = 'cancelled'
}

export interface OrderState {
  getStatus(): OrderStatus;
  confirm(order: Order): void;
  ship(order: Order): void;
  deliver(order: Order): void;
  cancel(order: Order): void;
}

export class Order {
  private state: OrderState;

  constructor(
    public readonly id: string,
    public customerEmail: string,
    public totalAmount: number
  ) {
    this.state = new PendingOrderState();
  }

  getState(): OrderStatus {
    return this.state.getStatus();
  }

  confirm(): void {
    this.state.confirm(this);
  }

  ship(): void {
    this.state.ship(this);
  }

  deliver(): void {
    this.state.deliver(this);
  }

  cancel(): void {
    this.state.cancel(this);
  }

  setState(state: OrderState): void {
    this.state = state;
  }
}

// domain/states/PendingOrderState.ts
export class PendingOrderState implements OrderState {
  getStatus(): OrderStatus {
    return OrderStatus.PENDING;
  }

  confirm(order: Order): void {
    console.log(`Confirming order ${order.id}`);
    order.setState(new ConfirmedOrderState());
  }

  ship(order: Order): void {
    throw new Error('Cannot ship a pending order');
  }

  deliver(order: Order): void {
    throw new Error('Cannot deliver a pending order');
  }

  cancel(order: Order): void {
    console.log(`Cancelling order ${order.id}`);
    order.setState(new CancelledOrderState());
  }
}

// domain/states/ConfirmedOrderState.ts
export class ConfirmedOrderState implements OrderState {
  getStatus(): OrderStatus {
    return OrderStatus.CONFIRMED;
  }

  confirm(order: Order): void {
    throw new Error('Order is already confirmed');
  }

  ship(order: Order): void {
    console.log(`Shipping order ${order.id}`);
    order.setState(new ShippedOrderState());
  }

  deliver(order: Order): void {
    throw new Error('Cannot deliver an order before shipping');
  }

  cancel(order: Order): void {
    console.log(`Cancelling confirmed order ${order.id}`);
    order.setState(new CancelledOrderState());
  }
}

// Другие состояния реализуются аналогично...
export class ShippedOrderState implements OrderState {
  getStatus(): OrderStatus {
    return OrderStatus.SHIPPED;
  }

  confirm(order: Order): void {
    throw new Error('Order is already shipped');
  }

  ship(order: Order): void {
    throw new Error('Order is already shipped');
  }

  deliver(order: Order): void {
    console.log(`Delivering order ${order.id}`);
    order.setState(new DeliveredOrderState());
  }

  cancel(order: Order): void {
    throw new Error('Cannot cancel shipped order');
  }
}

export class DeliveredOrderState implements OrderState {
  getStatus(): OrderStatus {
    return OrderStatus.DELIVERED;
  }

  confirm(order: Order): void {
    throw new Error('Order is already delivered');
  }

  ship(order: Order): void {
    throw new Error('Order is already delivered');
  }

  deliver(order: Order): void {
    throw new Error('Order is already delivered');
  }

  cancel(order: Order): void {
    throw new Error('Cannot cancel delivered order');
  }
}

export class CancelledOrderState implements OrderState {
  getStatus(): OrderStatus {
    return OrderStatus.CANCELLED;
  }

  confirm(order: Order): void {
    throw new Error('Cannot confirm cancelled order');
  }

  ship(order: Order): void {
    throw new Error('Cannot ship cancelled order');
  }

  deliver(order: Order): void {
    throw new Error('Cannot deliver cancelled order');
  }

  cancel(order: Order): void {
    throw new Error('Order is already cancelled');
  }
}
```

## Заключение

Архитектурные шаблоны предоставляют проверенные решения для типичных проблем проектирования. Правильное применение этих шаблонов позволяет создавать гибкие, масштабируемые и поддерживаемые TypeScript-приложения. Ключ к успеху - понимание контекста, в котором каждый шаблон наиболее эффективен, и умение адаптировать их к конкретным требованиям проекта.

## Связанные темы

- [[Чистая-архитектура]]
- [[Архитектура-фронтенда]]
- [[Модульность-и-масштабируемость]]
- [[Архитектурные-решения]]
- [[Паттерны-проектирования]]