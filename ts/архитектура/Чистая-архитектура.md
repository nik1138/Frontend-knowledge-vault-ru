---
aliases: [Чистая архитектура, Чистый архитектурный подход]
tags: [typescript, архитектура, паттерны-проектирования]
---

# Чистая архитектура

Чистая архитектура (Clean Architecture) - это подход к построению программного обеспечения, предложенный Робертом Мартином, который обеспечивает независимость от внешних зависимостей, тестопригодность и масштабируемость приложения. В контексте TypeScript-приложений этот подход особенно важен, поскольку позволяет создавать надежные, легко поддерживаемые и тестируемые системы.

## Основные принципы

### Независимость от внешних факторов

Чистая архитектура позволяет приложению быть независимым от:
- Внешних баз данных
- Веб-фреймворков
- Внешних агентов
- Интерфейсов пользователя

### Структура слоев

Чистая архитектура организована в виде концентрических кругов, где внутренние слои содержат бизнес-логику, а внешние слои отвечают за инфраструктуру и взаимодействие с внешним миром.

```typescript
// Пример структуры слоев в TypeScript-приложении

// Внутренний слой - сущности (Entities)
export interface UserEntity {
  id: string;
  email: string;
  name: string;
}

// Внутренний слой - интерфейсы портов (Ports)
export interface UserRepositoryPort {
  findById(id: string): Promise<UserEntity | null>;
  save(user: UserEntity): Promise<void>;
}

// Внутренний слой - интерфейсы юзкейсов (Use Cases)
export interface GetUserUseCase {
  execute(userId: string): Promise<UserEntity | null>;
}

// Внешний слой - адаптеры (Adapters)
export class HttpUserController {
  constructor(private getUserUseCase: GetUserUseCase) {}

  async handleGetUser(userId: string) {
    const user = await this.getUserUseCase.execute(userId);
    return user ? { status: 200, body: user } : { status: 404 };
  }
}

// Внешний слой - фреймворки и драйверы
export class DatabaseUserRepository implements UserRepositoryPort {
  async findById(id: string): Promise<UserEntity | null> {
    // Реализация получения пользователя из базы данных
    return null; // Заглушка
  }

  async save(user: UserEntity): Promise<void> {
    // Реализация сохранения пользователя в базу данных
  }
}
```

## Правило зависимостей

В чистой архитектуре зависимости всегда направлены внутрь. Внутренние слои не зависят от внешних, а внешние слои зависят от внутренних. Это достигается с помощью инверсии зависимостей.

### Инверсия зависимостей

Внешние слои реализуют интерфейсы, определенные во внутренних слоях.

```typescript
// Внешний слой реализует интерфейс порта
export class DatabaseUserRepository implements UserRepositoryPort {
  // Реализация методов порта
}
```

## Преимущества чистой архитектуры

- **Тестируемость**: Бизнес-логика изолирована от инфраструктуры, что позволяет легко тестировать юзкейсы без мокирования внешних зависимостей.
- **Независимость от фреймворков**: Приложение не зависит от конкретных фреймворков, что позволяет легко их заменять.
- **Независимость от UI**: UI может быть изменен без влияния на бизнес-логику.
- **Независимость от базы данных**: Легко заменить одну СУБД на другую.
- **Независимость от внешних агентов**: Внешние сервисы легко подставляются как моки при тестировании.

## Пример реализации юзкейса

```typescript
// Юзкейс - внутренний слой
export class GetUserUseCaseImpl implements GetUserUseCase {
  constructor(private userRepository: UserRepositoryPort) {}

  async execute(userId: string): Promise<UserEntity | null> {
    if (!userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(userId);
    return user;
  }
}
```

## Интеграция слоев

Для интеграции слоев используется инверсия зависимостей на уровне фреймворка или DI-контейнера.

```typescript
// Файл интеграции (обычно в папке main или infrastructure)
import { GetUserUseCaseImpl } from './usecases/GetUserUseCaseImpl';
import { DatabaseUserRepository } from './adapters/DatabaseUserRepository';
import { HttpUserController } from './adapters/HttpUserController';

// Регистрация зависимостей
const userRepository = new DatabaseUserRepository();
const getUserUseCase = new GetUserUseCaseImpl(userRepository);
const controller = new HttpUserController(getUserUseCase);

// Использование контроллера
const response = await controller.handleGetUser('some-user-id');
```

## Заключение

Чистая архитектура предоставляет мощный подход к построению масштабируемых и поддерживаемых TypeScript-приложений. Следование этим принципам позволяет создавать приложения, которые легко тестировать, изменять и расширять.

## Связанные темы

- [[Архитектура-фронтенда]]
- [[Архитектурные-шаблоны]]
- [[Модульность-и-масштабируемость]]
- [[Архитектурные-решения]]
- [[Паттерны-проектирования]]