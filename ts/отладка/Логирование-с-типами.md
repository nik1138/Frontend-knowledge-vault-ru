---
aliases: ["Логирование с типами", "Typed Logging", "Типизированное логирование"]
tags: [typescript, logging, types, debugging, monitoring]
---

# Логирование с типами в TypeScript

Логирование с типами в TypeScript представляет собой подход, при котором логируемые данные имеют четко определенные типы, что позволяет улучшить надежность, читаемость и отладку приложений. Этот подход позволяет создавать структурированные логи, которые легко анализировать и использовать для мониторинга состояния приложения.

## Основы типизированного логирования

Типизированное логирование включает в себя:
- Определение структуры лог-записей с использованием TypeScript-типов
- Создание унифицированных форматов логов
- Обеспечение безопасности типов при логировании
- Улучшение автодополнения и проверки типов в IDE

## Создание интерфейса лог-записи

### Базовая структура лог-записи

```typescript
interface LogEntry {
  timestamp: Date;
  level: 'error' | 'warn' | 'info' | 'debug';
  message: string;
  context?: string;
  meta?: Record<string, any>;
}

interface ErrorLogEntry extends LogEntry {
  level: 'error';
  error: {
    name: string;
    message: string;
    stack?: string;
    cause?: unknown;
  };
}
```

### Расширенная структура лог-записи

```typescript
interface ExtendedLogEntry extends LogEntry {
  userId?: string;
  sessionId?: string;
  requestId?: string;
  tags?: string[];
  duration?: number; // Время выполнения операции в миллисекундах
}
```

## Создание типизированного логгера

### Базовый типизированный логгер

```typescript
class TypedLogger {
  private static instance: TypedLogger;
  private level: 'error' | 'warn' | 'info' | 'debug' = 'info';

  private constructor() {}

  static getInstance(): TypedLogger {
    if (!TypedLogger.instance) {
      TypedLogger.instance = new TypedLogger();
    }
    return TypedLogger.instance;
  }

  error(message: string, error?: Error, meta?: Record<string, any>): void {
    const logEntry: ErrorLogEntry = {
      timestamp: new Date(),
      level: 'error',
      message,
      error: {
        name: error?.name || 'UnknownError',
        message: error?.message || 'Unknown error occurred',
        stack: error?.stack,
        cause: error?.cause
      },
      meta
    };
    console.error(logEntry);
  }

  warn(message: string, meta?: Record<string, any>): void {
    const logEntry: ExtendedLogEntry = {
      timestamp: new Date(),
      level: 'warn',
      message,
      meta
    };
    console.warn(logEntry);
  }

  info(message: string, meta?: Record<string, any>): void {
    const logEntry: ExtendedLogEntry = {
      timestamp: new Date(),
      level: 'info',
      message,
      meta
    };
    console.info(logEntry);
  }

  debug(message: string, meta?: Record<string, any>): void {
    if (this.level !== 'debug') return;
    
    const logEntry: ExtendedLogEntry = {
      timestamp: new Date(),
      level: 'debug',
      message,
      meta
    };
    console.debug(logEntry);
  }
}
```

## Использование discriminated unions для логов

TypeScript позволяет использовать discriminated unions для различения типов логов:

```typescript
interface RequestLog {
  type: 'request';
  method: string;
  url: string;
  statusCode: number;
  duration: number;
}

interface DatabaseLog {
  type: 'database';
  operation: string;
  collection: string;
  query: Record<string, any>;
  duration: number;
}

interface SecurityLog {
  type: 'security';
  action: string;
  userId: string;
  ip: string;
  success: boolean;
}

type ApplicationLog = RequestLog | DatabaseLog | SecurityLog;

function logApplicationEvent(log: ApplicationLog) {
  const baseLog: ExtendedLogEntry = {
    timestamp: new Date(),
    level: log.type === 'security' && !log.success ? 'error' : 'info',
    message: `${log.type} event occurred`,
    meta: log
  };

  switch (log.type) {
    case 'request':
      console.log(`[REQUEST] ${log.method} ${log.url} - ${log.statusCode} (${log.duration}ms)`);
      break;
    case 'database':
      console.log(`[DB] ${log.operation} on ${log.collection} (${log.duration}ms)`);
      break;
    case 'security':
      console.log(`[SECURITY] ${log.action} by user ${log.userId} from ${log.ip}`);
      break;
  }
}
```

## Логирование с контекстом

### Контекстно-ориентированное логирование

```typescript
interface LoggerContext {
  service: string;
  userId?: string;
  requestId?: string;
}

class ContextualLogger {
  constructor(private context: LoggerContext) {}

  error(message: string, error?: Error): void {
    const logEntry: ExtendedLogEntry = {
      timestamp: new Date(),
      level: 'error',
      message,
      context: this.context.service,
      meta: {
        ...this.context,
        error: error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : undefined
      }
    };
    console.error(logEntry);
  }

  info(message: string): void {
    const logEntry: ExtendedLogEntry = {
      timestamp: new Date(),
      level: 'info',
      message,
      context: this.context.service,
      meta: this.context
    };
    console.info(logEntry);
  }
}

// Использование
const userServiceLogger = new ContextualLogger({ service: 'UserService', userId: '123' });
userServiceLogger.info('User profile updated');
```

## Интеграция с популярными библиотеками логирования

### Winston с типами

```typescript
import winston, { Logger, format } from 'winston';

interface TypedWinstonLogger {
  error(message: string, error: Error): void;
  warn(message: string, meta?: Record<string, any>): void;
  info(message: string, meta?: Record<string, any>): void;
  debug(message: string, meta?: Record<string, any>): void;
}

class WinstonTypedLogger implements TypedWinstonLogger {
  private logger: Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: 'debug',
      format: format.combine(
        format.timestamp(),
        format.errors({ stack: true }),
        format.splat(),
        format.json()
      ),
      defaultMeta: { service: 'ts-app' },
      transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
      ]
    });

    if (process.env.NODE_ENV !== 'production') {
      this.logger.add(new winston.transports.Console({
        format: format.combine(
          format.colorize(),
          format.simple()
        )
      }));
    }
  }

  error(message: string, error: Error): void {
    this.logger.error(message, {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    });
  }

  warn(message: string, meta?: Record<string, any>): void {
    this.logger.warn(message, meta);
  }

  info(message: string, meta?: Record<string, any>): void {
    this.logger.info(message, meta);
  }

  debug(message: string, meta?: Record<string, any>): void {
    this.logger.debug(message, meta);
  }
}
```

### Pino с типами

```typescript
import pino, { Logger } from 'pino';

interface PinoTypedLogger {
  error(message: string, error: Error): void;
  warn(message: string, meta?: Record<string, any>): void;
  info(message: string, meta?: Record<string, any>): void;
  debug(message: string, meta?: Record<string, any>): void;
}

class PinoTypedLogger implements PinoTypedLogger {
  private logger: Logger;

  constructor() {
    this.logger = pino({
      level: 'debug',
      transport: process.env.NODE_ENV !== 'production' 
        ? { target: 'pino-pretty' } 
        : undefined
    });
  }

  error(message: string, error: Error): void {
    this.logger.error({
      message,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    }, message);
  }

  warn(message: string, meta?: Record<string, any>): void {
    this.logger.warn(meta || {}, message);
  }

  info(message: string, meta?: Record<string, any>): void {
    this.logger.info(meta || {}, message);
  }

  debug(message: string, meta?: Record<string, any>): void {
    this.logger.debug(meta || {}, message);
  }
}
```

## Логирование ошибок с типами

### Создание типизированных ошибок для логирования

```typescript
interface ValidationErrorLog {
  type: 'validation';
  field: string;
  value: any;
  message: string;
}

interface NetworkErrorLog {
  type: 'network';
  url: string;
  method: string;
  statusCode?: number;
  message: string;
}

type TypedErrorLog = ValidationErrorLog | NetworkErrorLog;

function logTypedError(error: TypedErrorLog): void {
  const logEntry: ErrorLogEntry = {
    timestamp: new Date(),
    level: 'error',
    message: error.message,
    error: {
      name: error.type,
      message: error.message
    },
    meta: error
  };
  
  console.error(logEntry);
}

// Пример использования
logTypedError({
  type: 'validation',
  field: 'email',
  value: 'invalid-email',
  message: 'Email format is invalid'
});
```

## Логирование в Express.js приложениях

### Мидлвар для логирования запросов

```typescript
import { Request, Response, NextFunction } from 'express';

interface RequestLogEntry {
  type: 'request';
  method: string;
  url: string;
  statusCode: number;
  duration: number;
  userId?: string;
  ip: string;
}

function createRequestLogger() {
  return (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();
    
    res.on('finish', () => {
      const duration = Date.now() - startTime;
      const logEntry: RequestLogEntry = {
        type: 'request',
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration,
        userId: req.user?.id,
        ip: req.ip || req.connection.remoteAddress
      };
      
      console.log(JSON.stringify(logEntry));
    });
    
    next();
  };
}

// Использование
app.use(createRequestLogger());
```

## Логирование асинхронных операций

### Логирование промисов

```typescript
interface AsyncOperationLog {
  type: 'async_operation';
  operation: string;
  status: 'start' | 'success' | 'error';
  duration?: number;
  error?: string;
}

function logAsyncOperation<T>(
  operation: string,
  asyncFn: () => Promise<T>
): Promise<T> {
  const start = Date.now();
  const logStart: AsyncOperationLog = {
    type: 'async_operation',
    operation,
    status: 'start'
  };
  console.log(JSON.stringify(logStart));

  return asyncFn()
    .then(result => {
      const duration = Date.now() - start;
      const logSuccess: AsyncOperationLog = {
        type: 'async_operation',
        operation,
        status: 'success',
        duration
      };
      console.log(JSON.stringify(logSuccess));
      return result;
    })
    .catch(error => {
      const duration = Date.now() - start;
      const logError: AsyncOperationLog = {
        type: 'async_operation',
        operation,
        status: 'error',
        duration,
        error: error.message
      };
      console.error(JSON.stringify(logError));
      throw error;
    });
}

// Использование
logAsyncOperation('fetchUserData', () => fetch('/api/user/123'))
  .then(user => console.log('User:', user));
```

## Логирование с использованием декораторов

### Декоратор для логирования методов

```typescript
function LogMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    const logger = TypedLogger.getInstance();
    logger.debug(`Calling method ${propertyKey} with args:`, args);
    
    const startTime = Date.now();
    const result = originalMethod.apply(this, args);
    
    // Если метод асинхронный
    if (result instanceof Promise) {
      return result.then(res => {
        const duration = Date.now() - startTime;
        logger.debug(`Method ${propertyKey} completed in ${duration}ms`, { result: typeof res });
        return res;
      }).catch(error => {
        const duration = Date.now() - startTime;
        logger.error(`Method ${propertyKey} failed after ${duration}ms`, error);
        throw error;
      });
    }
    
    const duration = Date.now() - startTime;
    logger.debug(`Method ${propertyKey} completed in ${duration}ms`, { result: typeof result });
    return result;
  };
}

// Использование
class UserService {
  @LogMethod
  async getUser(id: string) {
    // Логика получения пользователя
    return { id, name: 'John Doe' };
  }
}
```

## Фильтрация и поиск в логах

### Типизированные фильтры для поиска

```typescript
type LogFilter = (log: ExtendedLogEntry) => boolean;

class LogFilterBuilder {
  static byLevel(level: 'error' | 'warn' | 'info' | 'debug'): LogFilter {
    return (log: ExtendedLogEntry) => log.level === level;
  }

  static byContext(context: string): LogFilter {
    return (log: ExtendedLogEntry) => log.context === context;
  }

  static byDateRange(start: Date, end: Date): LogFilter {
    return (log: ExtendedLogEntry) => 
      log.timestamp >= start && log.timestamp <= end;
  }

  static byMessageContains(search: string): LogFilter {
    return (log: ExtendedLogEntry) => 
      log.message.toLowerCase().includes(search.toLowerCase());
  }

  static combine(...filters: LogFilter[]): LogFilter {
    return (log: ExtendedLogEntry) => 
      filters.every(filter => filter(log));
  }
}

// Пример использования
const logs: ExtendedLogEntry[] = [
  // массив логов
];

const errorLogs = logs.filter(LogFilterBuilder.byLevel('error'));
const userServiceLogs = logs.filter(LogFilterBuilder.byContext('UserService'));
const recentErrorLogs = logs.filter(
  LogFilterBuilder.combine(
    LogFilterBuilder.byLevel('error'),
    LogFilterBuilder.byDateRange(new Date(Date.now() - 86400000), new Date()) // за последние 24 часа
  )
);
```

## Совместимость с системами мониторинга

### Интеграция с ELK Stack

Для интеграции с Elasticsearch, Logstash и Kibana:

```typescript
interface ELKLogEntry {
  '@timestamp': string;
  level: string;
  message: string;
  service: string;
  userId?: string;
  tags?: string[];
  meta?: Record<string, any>;
}

function formatForELK(log: ExtendedLogEntry, serviceName: string): ELKLogEntry {
  return {
    '@timestamp': log.timestamp.toISOString(),
    level: log.level.toUpperCase(),
    message: log.message,
    service: serviceName,
    userId: log.meta?.userId,
    tags: log.meta?.tags,
    meta: log.meta
  };
}
```

## Рекомендации по безопасности

### Фильтрация чувствительных данных

```typescript
function sanitizeLogData(data: Record<string, any>): Record<string, any> {
  const sanitized = { ...data };
  
  // Удаляем чувствительные поля
  const sensitiveFields = ['password', 'token', 'secret', 'key', 'auth'];
  
  for (const field of sensitiveFields) {
    if (sanitized[field]) {
      sanitized[field] = '[REDACTED]';
    }
  }
  
  // Рекурсивно обрабатываем вложенные объекты
  for (const key in sanitized) {
    if (typeof sanitized[key] === 'object' && sanitized[key] !== null) {
      sanitized[key] = sanitizeLogData(sanitized[key]);
    }
  }
  
  return sanitized;
}

// Использование в логгере
class SecureLogger {
  info(message: string, meta?: Record<string, any>): void {
    const sanitizedMeta = meta ? sanitizeLogData(meta) : undefined;
    console.info({ message, meta: sanitizedMeta, timestamp: new Date() });
  }
}
```

> [!warning] Важно
> Всегда фильтруйте чувствительные данные перед логированием, особенно в production-окружении.

## Заключение

Логирование с типами в TypeScript позволяет создавать более надежные и легко отлаживаемые приложения. Использование четко определенных типов для лог-записей обеспечивает:
- Безопасность типов при логировании
- Улучшенное автодополнение в IDE
- Легкость анализа логов
- Совместимость с системами мониторинга
- Структурированный формат логов

См. также:
- [[Инструменты-отладки]]
- [[Отладка-в-IDE]]
- [[Source-map]]
- [[Типизированные-ошибки]]