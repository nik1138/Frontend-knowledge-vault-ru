---
aliases: ["Типизированные ошибки", "Typed Errors", "Ошибки с типами"]
tags: [typescript, error-handling, types, debugging]
---

# Типизированные ошибки в TypeScript

Типизированные ошибки - это подход к обработке ошибок, при котором ошибки имеют конкретные типы, что позволяет эффективно обрабатывать различные виды ошибок с использованием системы типов TypeScript. Это улучшает надежность приложений и облегчает отладку.

## Введение в типизированные ошибки

В традиционном JavaScript ошибки представлены в основном через объекты `Error`, но без четкой типизации. TypeScript позволяет создавать специализированные типы ошибок, что дает возможность:
- Четко определять типы ошибок
- Обрабатывать ошибки по типу
- Улучшать автодополнение и проверку типов
- Упрощать отладку

## Создание пользовательских типов ошибок

### Базовый пользовательский класс ошибки

```typescript
class CustomError extends Error {
  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;
  }
}
```

### Специализированные классы ошибок

```typescript
class ValidationError extends CustomError {
  constructor(message: string, public field?: string) {
    super(message);
    this.field = field;
  }
}

class NetworkError extends CustomError {
  constructor(message: string, public statusCode?: number) {
    super(message);
    this.statusCode = statusCode;
  }
}

class AuthenticationError extends CustomError {
  constructor(message: string = 'Authentication failed') {
    super(message);
  }
}
```

## Использование discriminated unions для ошибок

TypeScript позволяет использовать discriminated unions для различения типов ошибок:

```typescript
interface ValidationError {
  type: 'validation';
  field: string;
  message: string;
}

interface NetworkError {
  type: 'network';
  statusCode: number;
  message: string;
}

interface AuthenticationError {
  type: 'authentication';
  message: string;
}

type AppError = ValidationError | NetworkError | AuthenticationError;

function handleError(error: AppError) {
  switch (error.type) {
    case 'validation':
      console.error(`Validation error in field ${error.field}: ${error.message}`);
      break;
    case 'network':
      console.error(`Network error with status ${error.statusCode}: ${error.message}`);
      break;
    case 'authentication':
      console.error(`Authentication error: ${error.message}`);
      break;
  }
}
```

## Типизированные ошибки в асинхронных операциях

### Использование Result типа

```typescript
type Result<T, E = AppError> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUserData(id: string): Promise<Result<User, NetworkError | ValidationError>> {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      if (response.status === 401) {
        return {
          success: false,
          error: {
            type: 'authentication',
            message: 'Unauthorized access'
          }
        };
      }
      
      return {
        success: false,
        error: {
          type: 'network',
          statusCode: response.status,
          message: `HTTP error: ${response.statusText}`
        }
      };
    }
    
    const user = await response.json();
    return { success: true, data: user };
  } catch (err) {
    return {
      success: false,
      error: {
        type: 'network',
        statusCode: 0,
        message: 'Network request failed'
      }
    };
  }
}

// Использование
const result = await fetchUserData('123');
if (result.success) {
  console.log('User data:', result.data);
} else {
  handleError(result.error);
}
```

## Проверка типа ошибки

TypeScript предоставляет несколько способов проверки типа ошибки:

### Использование instanceof

```typescript
try {
  // какой-то код, который может выбросить ошибку
  validateInput(input);
} catch (error) {
  if (error instanceof ValidationError) {
    // Обработка ошибки валидации
    console.error(`Validation error in field ${error.field}: ${error.message}`);
  } else if (error instanceof NetworkError) {
    // Обработка сетевой ошибки
    console.error(`Network error with status ${error.statusCode}: ${error.message}`);
  } else if (error instanceof Error) {
    // Обработка общей ошибки
    console.error(`General error: ${error.message}`);
  }
}
```

### Создание type guard функций

```typescript
function isErrorWithField(error: unknown): error is ValidationError {
  return error instanceof ValidationError && 'field' in error;
}

function isNetworkError(error: unknown): error is NetworkError {
  return error instanceof NetworkError && 'statusCode' in error;
}

function isAuthenticationError(error: unknown): error is AuthenticationError {
  return error instanceof AuthenticationError;
}
```

## Интеграция с системой логирования

### Логирование с типизацией

```typescript
interface LogEntry {
  timestamp: Date;
  level: 'error' | 'warn' | 'info';
  message: string;
  errorType?: string;
  errorData?: Record<string, any>;
}

class TypedLogger {
  static error(error: AppError, context?: string): void {
    const logEntry: LogEntry = {
      timestamp: new Date(),
      level: 'error',
      message: error.message,
      errorType: error.type,
      errorData: this.extractErrorData(error)
    };
    
    if (context) {
      (logEntry as any).context = context;
    }
    
    console.error(logEntry);
  }
  
  private static extractErrorData(error: AppError): Record<string, any> {
    switch (error.type) {
      case 'validation':
        return { field: error.field };
      case 'network':
        return { statusCode: error.statusCode };
      case 'authentication':
        return {};
      default:
        return {};
    }
  }
}
```

## Использование в Express.js приложениях

```typescript
import express, { Request, Response, NextFunction } from 'express';

// Middleware для обработки ошибок
function errorHandler(err: AppError, req: Request, res: Response, next: NextFunction) {
  let status = 500;
  
  switch (err.type) {
    case 'validation':
      status = 400;
      break;
    case 'authentication':
      status = 401;
      break;
    case 'network':
      status = err.statusCode || 500;
      break;
  }
  
  res.status(status).json({
    error: {
      type: err.type,
      message: err.message,
      ...(err.type === 'validation' && { field: (err as ValidationError).field }),
      ...(err.type === 'network' && { statusCode: (err as NetworkError).statusCode })
    }
  });
}

// Использование middleware
const app = express();
app.use(errorHandler);
```

## Проверка типов во время отладки

### Использование satisfies оператора (TypeScript 4.9+)

```typescript
const errorMap = {
  VALIDATION_ERROR: ValidationError,
  NETWORK_ERROR: NetworkError,
  AUTH_ERROR: AuthenticationError
} satisfies Record<string, new (...args: any[]) => CustomError>;

type ErrorType = keyof typeof errorMap;
```

## Совместимость с библиотеками

### Zod для валидации с типизированными ошибками

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  age: z.number().min(0, 'Age must be positive')
});

type ValidationErrors = z.inferFlattenedErrors<typeof UserSchema>;

function validateUser(data: unknown): Result<User, ValidationError> {
  try {
    const user = UserSchema.parse(data);
    return { success: true, data: user };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const firstError = error.errors[0];
      return {
        success: false,
        error: {
          type: 'validation',
          field: firstError.path.join('.'),
          message: firstError.message
        }
      };
    }
    
    return {
      success: false,
      error: {
        type: 'validation',
        field: 'unknown',
        message: 'Validation failed'
      }
    };
  }
}
```

## Тестирование типизированных ошибок

```typescript
import { expect, describe, it } from 'vitest';

describe('Error handling', () => {
  it('should correctly identify validation errors', async () => {
    const result = await validateUser({ name: '', age: -1 });
    
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.type).toBe('validation');
      expect(result.error.message).toContain('Name is required');
    }
  });
  
  it('should handle network errors properly', async () => {
    // Мокаем сетевой запрос
    const result = await fetchUserData('invalid-id');
    
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.type).toBe('network');
    }
  });
});
```

> [!tip] Совет
> Используйте строгую типизацию для ошибок, чтобы улучшить автодополнение и обнаружение ошибок на этапе компиляции.

## Рекомендации по именованию ошибок

- Используйте суффикс `Error` для классов ошибок
- Добавляйте префикс `App` или название домена для избежания конфликта с встроенными ошибками
- Используйте PascalCase для имен классов ошибок
- Добавляйте полезные свойства в зависимости от типа ошибки

## Заключение

Типизированные ошибки в TypeScript позволяют создавать более надежные и легко отлаживаемые приложения. Они обеспечивают:
- Четкое различение типов ошибок
- Лучшую обработку ошибок
- Улучшенную отладку
- Более надежную систему типов

См. также:
- [[Отладка-в-IDE]]
- [[Инструменты-отладки]]
- [[Source-map]]
- [[Логирование-с-типами]]