---
aliases: ["Практики тестирования", "Testing Practices"]
tags: [typescript, testing, best-practices, tdd]
---

# Практики тестирования в TypeScript

## Обзор

Практики тестирования в TypeScript включают в себя набор принципов, подходов и методологий, направленных на создание эффективных, надежных и поддерживаемых тестов для типизированных приложений. В этой статье рассматриваются лучшие практики, которые помогут улучшить качество вашего тестового кода.

## Основные принципы тестирования

### FIRST принципы

Хорошие тесты должны соответствовать принципам FIRST:

- **Fast** - Тесты должны выполняться быстро
- **Independent** - Тесты не должны зависеть друг от друга
- **Repeatable** - Тесты должны давать одинаковый результат при каждом запуске
- **Self-validating** - Тесты должны иметь четкий результат (прошел/не прошел)
- **Timely** - Тесты должны писаться своевременно (до или во время написания кода)

### Пирамида тестирования

```
          [E2E Tests]
       [Integration Tests]
    [Unit Tests]
```

- **Unit Tests** (70%) - Тестируют отдельные компоненты
- **Integration Tests** (20%) - Тестируют взаимодействие между компонентами
- **E2E Tests** (10%) - Тестируют полный пользовательский сценарий

## Практики написания unit-тестов

### Использование строгой типизации

```typescript
// Плохо: Нет типизации
function testAddition() {
  const result = add(2, 3);
  expect(result).toBe(5);
}

// Хорошо: С явной типизацией
function testAdditionWithTypes() {
  const a: number = 2;
  const b: number = 3;
  const expected: number = 5;
  
  const result: number = add(a, b);
  
  expect(result).toBe(expected);
}
```

### Организация тестов по AAA паттерну

AAA (Arrange, Act, Assert) - структура теста:

```typescript
describe('UserService', () => {
  let userService: UserService;
  let mockDatabase: MockDatabaseService;

  beforeEach(() => {
    mockDatabase = new MockDatabaseService();
    userService = new UserService(mockDatabase);
  });

  it('should create a new user', async () => {
    // Arrange
    const userData: CreateUserRequest = {
      name: 'John Doe',
      email: 'john@example.com'
    };
    const expectedUser: User = {
      id: 1,
      ...userData
    };
    
    mockDatabase.saveUser.mockResolvedValue(expectedUser);

    // Act
    const result: User = await userService.createUser(userData);

    // Assert
    expect(result).toEqual(expectedUser);
    expect(mockDatabase.saveUser).toHaveBeenCalledWith(userData);
  });
});
```

### Использование описательных имен тестов

```typescript
// Плохо: Неинформативное имя
it('works', () => {
  // ...
});

// Хорошо: Информативное имя
it('should return user with correct id when getUser is called with valid id', () => {
  // ...
});

// Еще лучше: Использование BDD стиля
describe('when user exists in database', () => {
  it('returns user object with correct properties', () => {
    // ...
  });
});
```

## Практики тестирования типов

### Использование tsd для тестирования типов

```typescript
// types/utils.ts
export type NonNullableProperties<T> = {
  [P in keyof T]-?: NonNullable<T[P]>;
};

// tests/types/utils.test-d.ts
import { expectType } from 'tsd';
import { NonNullableProperties } from '../../src/types/utils';

interface TestObject {
  a: string | null;
  b: number | undefined;
  c: boolean;
}

type Result = NonNullableProperties<TestObject>;
type Expected = {
  a: string;  // null удален
  b: number;  // undefined удален
  c: boolean; // остался без изменений
};

// Тестирование корректности типа
expectType<Expected>({} as Result);
```

### Тестирование условных типов

```typescript
// types/conditional.ts
export type FilterByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

// tests/types/conditional.test-d.ts
import { expectType } from 'tsd';
import { FilterByType } from '../../src/types/conditional';

interface User {
  id: number;
  name: string;
  isActive: boolean;
  createdAt: Date;
}

type StringProperties = FilterByType<User, string>;
type ExpectedStringProperties = { name: string };

expectType<ExpectedStringProperties>({} as StringProperties);
```

## Практики mock-объектов

### Создание типизированных mock-объектов

```typescript
// services/user-service.ts
export interface UserRepository {
  findById(id: number): Promise<User | null>;
  save(user: User): Promise<User>;
  delete(id: number): Promise<void>;
}

export class UserService {
  constructor(private userRepository: UserRepository) {}

  async getUserProfile(userId: number): Promise<UserProfile | null> {
    const user = await this.userRepository.findById(userId);
    if (!user) return null;
    
    return {
      id: user.id,
      displayName: user.name,
      email: user.email,
      isPremium: user.accountType === 'premium'
    };
  }
}

// tests/unit/user-service.test.ts
import { UserService } from '../../src/services/user-service';

describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    // Создание типизированного mock-объекта
    mockUserRepository = {
      findById: jest.fn(),
      save: jest.fn(),
      delete: jest.fn()
    };

    userService = new UserService(mockUserRepository);
  });

  it('should return user profile when user exists', async () => {
    // Arrange
    const userId: number = 1;
    const mockUser: User = {
      id: userId,
      name: 'John Doe',
      email: 'john@example.com',
      accountType: 'premium'
    };
    const expectedProfile: UserProfile = {
      id: userId,
      displayName: 'John Doe',
      email: 'john@example.com',
      isPremium: true
    };

    mockUserRepository.findById.mockResolvedValue(mockUser);

    // Act
    const result: UserProfile | null = await userService.getUserProfile(userId);

    // Assert
    expect(result).toEqual(expectedProfile);
    expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
  });
});
```

### Использование фабрик для создания mock-объектов

```typescript
// tests/factories/user-factory.ts
export const createUser = (overrides: Partial<User> = {}): User => ({
  id: 1,
  name: 'Test User',
  email: 'test@example.com',
  accountType: 'basic',
  ...overrides
});

export const createMockUserRepository = (): jest.Mocked<UserRepository> => ({
  findById: jest.fn(),
  save: jest.fn(),
  delete: jest.fn()
});

// tests/unit/user-service-with-factory.test.ts
import { 
  createUser, 
  createMockUserRepository 
} from '../factories/user-factory';

describe('UserService with Factory', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = createMockUserRepository();
    userService = new UserService(mockUserRepository);
  });

  it('should handle user with custom properties', async () => {
    // Arrange
    const customUser: User = createUser({
      id: 999,
      name: 'Custom Name',
      accountType: 'premium'
    });
    
    mockUserRepository.findById.mockResolvedValue(customUser);

    // Act
    const result = await userService.getUserProfile(999);

    // Assert
    expect(result?.isPremium).toBe(true);
    expect(result?.displayName).toBe('Custom Name');
  });
});
```

## Практики интеграционного тестирования

### Тестирование взаимодействия между модулями

```typescript
// tests/integration/user-auth-flow.test.ts
import { UserModule } from '../../src/modules/user';
import { AuthModule } from '../../src/modules/auth';
import { DatabaseConnection } from '../../src/database';

describe('User Authentication Flow', () => {
  let userModule: UserModule;
  let authModule: AuthModule;
  let dbConnection: DatabaseConnection;

  beforeAll(async () => {
    dbConnection = new DatabaseConnection();
    await dbConnection.connect();
    
    userModule = new UserModule(dbConnection);
    authModule = new AuthModule(dbConnection);
  });

  afterAll(async () => {
    await dbConnection.disconnect();
  });

  it('should register user and allow authentication', async () => {
    // Arrange
    const registrationData: UserRegistrationData = {
      email: 'test@example.com',
      password: 'securePassword123'
    };

    // Act & Assert
    const newUser: User = await userModule.register(registrationData);
    expect(newUser.email).toBe(registrationData.email);
    
    const token: string = await authModule.authenticate(
      registrationData.email, 
      registrationData.password
    );
    expect(token).toBeDefined();
    
    const authenticatedUser: User | null = await authModule.verifyToken(token);
    expect(authenticatedUser).not.toBeNull();
    expect(authenticatedUser?.email).toBe(registrationData.email);
  });
});
```

## Практики end-to-end тестирования

### Использование Page Object паттерна

```typescript
// tests/e2e/pages/login-page.ts
export class LoginPage {
  private page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  async navigate(): Promise<void> {
    await this.page.goto('/login');
  }

  async login(email: string, password: string): Promise<void> {
    await this.page.fill('input[name="email"]', email);
    await this.page.fill('input[name="password"]', password);
    await this.page.click('button[type="submit"]');
  }

  async isErrorMessageVisible(): Promise<boolean> {
    const errorElement = this.page.locator('.error-message');
    return await errorElement.isVisible();
  }
}

// tests/e2e/login-flow.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage } from './pages/login-page';

test.describe('Login Flow', () => {
  test('should allow user to login with valid credentials', async ({ page }) => {
    const loginPage = new LoginPage(page);
    
    await loginPage.navigate();
    await loginPage.login('user@example.com', 'validPassword');
    
    // Проверка, что пользователь успешно вошел
    await expect(page).toHaveURL('/dashboard');
  });
});
```

## Практики управления тестовыми данными

### Использование фикстур и сидов

```typescript
// tests/fixtures/users.ts
export const TEST_USERS = {
  regular: {
    id: 1,
    name: 'Regular User',
    email: 'regular@example.com',
    role: 'user'
  },
  admin: {
    id: 2,
    name: 'Admin User',
    email: 'admin@example.com',
    role: 'admin'
  },
  premium: {
    id: 3,
    name: 'Premium User',
    email: 'premium@example.com',
    role: 'user',
    isPremium: true
  }
} as const;

// tests/fixtures/database.ts
export class TestDatabaseSeeder {
  static async seedUsers(): Promise<void> {
    for (const userData of Object.values(TEST_USERS)) {
      await database.createUser(userData);
    }
  }

  static async clearUsers(): Promise<void> {
    await database.clearTable('users');
  }
}
```

## Практики CI/CD для тестов

### Конфигурация GitHub Actions

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run type checking
      run: npm run type-check
      
    - name: Run unit tests
      run: npm run test:unit
      
    - name: Run integration tests
      run: npm run test:integration
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
```

## Лучшие практики

1. **Тестируйте поведение, а не реализацию** - Фокусируйтесь на том, что делает код, а не как
2. **Изолируйте тесты** - Каждый тест должен быть независимым
3. **Используйте подходящие mock-объекты** - Избегайте тестирования зависимостей
4. **Покрывайте граничные случаи** - Тестируйте как нормальные, так и крайние случаи
5. **Поддерживайте актуальность тестов** - Обновляйте тесты при изменении кода
6. **Используйте статические проверки** - ESLint, TSLint и другие инструменты
7. **Документируйте тесты** - Комментируйте сложные тестовые сценарии

## Связанные темы

- [[Типизация-тестов]] - Типизация в контексте тестирования
- [[Mock-типы]] - Типы, используемые для создания mock-объектов
- [[Тестирование-типов]] - Проверка корректности определений типов
- [[Инструменты-для-тестирования]] - Инструменты, используемые для тестирования TypeScript кода

## Вывод

Следование лучшим практикам тестирования в TypeScript помогает создавать более надежные, поддерживаемые и понятные тесты. Комбинация правильных инструментов, подходов и принципов позволяет эффективно проверять качество кода и снижать количество ошибок в production.