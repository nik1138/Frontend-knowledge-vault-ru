---
aliases: ["Тестирование типов", "Type Testing"]
tags: [typescript, testing, типизация, type-testing]
---

# Тестирование типов в TypeScript

## Обзор

Тестирование типов в TypeScript - это практика проверки корректности определений типов, интерфейсов и дженериков. В отличие от традиционных тестов, которые проверяют поведение во время выполнения, тестирование типов проверяет корректность типов во время компиляции.

## Зачем нужно тестирование типов?

Тестирование типов важно по следующим причинам:

1. **Проверка корректности определений типов** - Убедиться, что типы работают так, как задумано
2. **Обнаружение ошибок типизации** - Найти несоответствия до запуска приложения
3. **Документирование поведения типов** - Показать, как типы должны использоваться
4. **Поддержка рефакторинга** - При изменении типов тесты помогут найти места, которые нужно обновить

## Основные концепции

### Тестирование поведения типов

В отличие от тестирования во время выполнения, тестирование типов проверяет, как типы взаимодействуют друг с другом:

```typescript
// Определим утилитарный тип
type Merge<T, U> = {
  [K in keyof T | keyof U]: K extends keyof T ? T[K] : K extends keyof U ? U[K] : never;
};

// Тесты для проверки корректности типа
type TestCase1 = Merge<{ a: string }, { b: number }>;
// Ожидаемый результат: { a: string, b: number }

type TestCase2 = Merge<{ a: string, c: boolean }, { b: number, c: string }>;
// Ожидаемый результат: { a: string, b: number, c: string }
```

### Использование вспомогательных типов для тестирования

```typescript
// Вспомогательный тип для проверки равенства типов
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;

// Вспомогательный тип для проверки, что типы не равны
type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true;

// Примеры использования
type Test1 = Equal<TestCase1, { a: string, b: number }>; // Должно быть true
type Test2 = Equal<TestCase2, { a: string, b: number, c: string }>; // Должно быть true
```

## Инструменты для тестирования типов

### tsd - библиотека для тестирования типов

```typescript
// test/type-tests.ts
import { expectType, expectError } from 'tsd';

// Тестируем корректность типов
interface User {
  id: number;
  name: string;
  email: string;
}

const user: User = { id: 1, name: 'John', email: 'john@example.com' };

// Эти тесты проверяются на уровне типов
expectType<User>(user);
expectType<number>(user.id);
expectType<string>(user.name);
expectType<string>(user.email);

// Эти тесты должны вызвать ошибки типизации
expectError<string>(user.id); // Ошибка: number не может быть string
expectError<number>(user.name); // Ошибка: string не может быть number
```

### Использование встроенных возможностей TypeScript

```typescript
// Создаем вспомогательные типы для тестирования
type AssertTrue<T extends true> = T;
type AssertFalse<T extends false> = T;

// Тестируем утилитарный тип
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

// Тесты
type TestObject = {
  id: number;
  name: string;
  isActive: boolean;
  createdAt: Date;
};

type StringProps = PickByType<TestObject, string>;
type ExpectedStringProps = { name: string };

// Проверяем, что типы совпадают
type TestStringProps = AssertTrue<Equal<StringProps, ExpectedStringProps>>;

type NumberProps = PickByType<TestObject, number>;
type ExpectedNumberProps = { id: number };

type TestNumberProps = AssertTrue<Equal<NumberProps, ExpectedNumberProps>>;
```

## Практические примеры

### Тестирование дженериков

```typescript
// Утилитарный тип для извлечения типа возвращаемого значения функции
type GetReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;

// Тестируем
function getUser(id: number): { id: number; name: string } {
  return { id, name: 'User' };
}

function getPosts(userId: number): string[] {
  return ['Post 1', 'Post 2'];
}

// Типы для тестирования
type UserReturnType = GetReturnType<typeof getUser>;
type PostsReturnType = GetReturnType<typeof getPosts>;

// Ожидаемые типы
type ExpectedUserType = { id: number; name: string };
type ExpectedPostsType = string[];

// Проверка соответствия
type TestUserReturn = AssertTrue<Equal<UserReturnType, ExpectedUserType>>;
type TestPostsReturn = AssertTrue<Equal<PostsReturnType, ExpectedPostsType>>;
```

### Тестирование условных типов

```typescript
// Утилитарный тип для извлечения типов из массива
type ArrayElementType<T> = T extends (infer U)[] ? U : T;

// Тесты
type NumberArrayElement = ArrayElementType<number[]>;
type StringArrayElement = ArrayElementType<string[]>;
type NonArrayType = ArrayElementType<string>;

// Проверка
type TestNumberArray = AssertTrue<Equal<NumberArrayElement, number>>;
type TestStringArray = AssertTrue<Equal<StringArrayElement, string>>;
type TestNonArray = AssertTrue<Equal<NonArrayType, string>>;
```

### Тестирование сложных типов

```typescript
// Определяем тип для проверки
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// Тестируем
type ComplexObject = {
  id: number;
  name: string;
  address: {
    street: string;
    city: string;
    country: {
      name: string;
      code: string;
    };
  };
  tags: string[];
};

type ComplexPartial = DeepPartial<ComplexObject>;
type ExpectedPartial = {
  id?: number;
  name?: string;
  address?: {
    street?: string;
    city?: string;
    country?: {
      name?: string;
      code?: string;
    };
  };
  tags?: string[];
};

// Проверка
type TestDeepPartial = AssertTrue<Equal<ComplexPartial, ExpectedPartial>>;
```

## Расширенные техники тестирования типов

### Тестирование типов с помощью перегрузок функций

```typescript
// Определяем функцию с перегрузками
function formatValue(value: string): string;
function formatValue(value: number): string;
function formatValue(value: boolean): string;
function formatValue(value: string | number | boolean): string {
  return String(value);
}

// Тестируем типы возвращаемого значения
type StringFormatReturn = GetReturnType<typeof formatValue>;
// Должно быть string

// Тест с конкретным вызовом
function testStringFormat() {
  const result = formatValue('hello');
  expectType<string>(result);
}
```

### Тестирование типов с помощью дженериков и условий

```typescript
// Определяем тип для проверки
type FilterProperties<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

// Тестируем
type TestFilterObject = {
  id: number;
  name: string;
  count: number;
  isActive: boolean;
};

type NumberProperties = FilterProperties<TestFilterObject, number>;
type ExpectedNumberProps = { id: number; count: number; };

type TestFilter = AssertTrue<Equal<NumberProperties, ExpectedNumberProps>>;
```

## Лучшие практики

1. **Используйте специализированные библиотеки** - tsd и другие инструменты для тестирования типов
2. **Создавайте вспомогательные типы для тестирования** - Это упрощает написание тестов
3. **Тестируйте граничные случаи** - Проверяйте, как типы ведут себя в крайних ситуациях
4. **Документируйте ожидаемое поведение** - Комментарии помогают понять, что проверяется
5. **Регулярно обновляйте тесты типов** - При изменении типов обновляйте соответствующие тесты

## Связанные темы

- [[Типизация-тестов]] - Типизация в контексте тестирования
- [[Mock-типы]] - Типы, используемые для создания mock-объектов
- [[Инструменты-для-тестирования]] - Инструменты, используемые для тестирования TypeScript кода
- [[Практики-тестирования]] - Общие практики тестирования в TypeScript

## Вывод

Тестирование типов в TypeScript - это важная практика, которая помогает обеспечить корректность определений типов и предотвратить ошибки типизации. Использование специализированных инструментов и техник позволяет создавать надежные типизированные приложения.