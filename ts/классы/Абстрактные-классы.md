---
aliases: ["Абстрактные классы в TypeScript", "abstract", "абстракция", "наследование"]
tags: ["#typescript", "#classes", "#abstract", "#oop", "#advanced"]
---

# Абстрактные классы в TypeScript

## Введение

Абстрактные классы в TypeScript представляют собой специальный тип классов, которые не могут быть напрямую инстанцированы (созданы с помощью `new`). Они служат в качестве базовых классов для других классов и могут содержать как реализованные, так и абстрактные члены. Абстрактные члены должны быть реализованы в производных классах, что обеспечивает определенную структуру и контракт для наследников.

## Основы абстрактных классов

Для создания абстрактного класса используется ключевое слово `abstract` перед объявлением класса:

```typescript
abstract class Animal {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  // Обычный метод с реализацией
  move(): void {
    console.log(`${this.name} двигается`);
  }
  
  // Абстрактный метод - должен быть реализован в наследниках
  abstract makeSound(): string;
  
  // Абстрактный метод с параметрами
  abstract communicate(other: Animal): void;
}

// Следующая строка вызовет ошибку компиляции:
// const animal = new Animal("Безымянный"); // ОШИБКА!

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
  
  // Реализация абстрактного метода
  makeSound(): string {
    return "Гав!";
  }
  
  // Реализация другого абстрактного метода
  communicate(other: Animal): void {
    console.log(`${this.name} лает на ${other.name}`);
  }
}

class Cat extends Animal {
  constructor(name: string) {
    super(name);
  }
  
  makeSound(): string {
    return "Мяу!";
  }
  
  communicate(other: Animal): void {
    if (other instanceof Dog) {
      console.log(`${this.name} шипит на ${other.name}`);
    } else {
      console.log(`${this.name} игнорирует ${other.name}`);
    }
  }
}

const dog = new Dog("Рекс");
const cat = new Cat("Мурка");

console.log(dog.makeSound()); // "Гав!"
console.log(cat.makeSound()); // "Мяу!"
dog.communicate(cat); // "Рекс лает на Мурка"
cat.communicate(dog); // "Мурка шипит на Рекс"
```

> [!note] Важно
> Абстрактные классы могут содержать как обычные методы с реализацией, так и абстрактные методы без реализации.

## Абстрактные свойства

Начиная с TypeScript 4.3, можно объявлять абстрактные свойства:

```typescript
abstract class Shape {
  abstract readonly type: string; // Абстрактное свойство
  abstract area(): number;        // Абстрактный метод
  
  // Обычный метод
  getInfo(): string {
    return `Фигура: ${this.type}, Площадь: ${this.area()}`;
  }
}

class Circle extends Shape {
  readonly type = "Круг"; // Реализация абстрактного свойства
  
  constructor(private radius: number) {
    super();
  }
  
  area(): number {
    return Math.PI * this.radius ** 2;
  }
}

class Rectangle extends Shape {
  readonly type = "Прямоугольник"; // Реализация абстрактного свойства
  
  constructor(private width: number, private height: number) {
    super();
  }
  
  area(): number {
    return this.width * this.height;
  }
}

const circle = new Circle(5);
const rectangle = new Rectangle(4, 6);

console.log(circle.getInfo());    // "Фигура: Круг, Площадь: 78.53981633974483"
console.log(rectangle.getInfo()); // "Фигура: Прямоугольник, Площадь: 24"
```

## Абстрактные методы с модификаторами доступа

Абстрактные методы могут иметь модификаторы доступа:

```typescript
abstract class Vehicle {
  protected speed: number = 0;
  
  // Абстрактный публичный метод
  abstract start(): void;
  
  // Абстрактный защищенный метод
  protected abstract calculateMaxSpeed(): number;
  
  // Обычный метод, использующий абстрактный метод
  public getMaxSpeed(): number {
    return this.calculateMaxSpeed();
  }
}

class Car extends Vehicle {
  constructor(private brand: string) {
    super();
  }
  
  start(): void {
    console.log(`${this.brand} заводится`);
    this.speed = 10;
  }
  
  protected calculateMaxSpeed(): number {
    return this.brand === "Ferrari" ? 320 : 180;
  }
}
```

## Применение абстрактных классов

### 1. Определение каркаса приложения

Абстрактные классы полезны для создания каркаса приложения:

```typescript
abstract class Component {
  protected element: HTMLElement;
  
  constructor(protected container: HTMLElement) {
    this.element = this.createElement();
    this.container.appendChild(this.element);
    this.render();
  }
  
  // Абстрактный метод, который должен быть реализован
  abstract render(): void;
  
  // Абстрактный метод для обработки событий
  abstract bindEvents(): void;
  
  // Общий метод для всех компонентов
  protected createElement(): HTMLElement {
    const element = document.createElement('div');
    element.className = this.getClassName();
    return element;
  }
  
  // Абстрактный метод для получения имени класса
  abstract getClassName(): string;
}

class Button extends Component {
  constructor(
    container: HTMLElement,
    private text: string,
    private onClick: () => void
  ) {
    super(container);
  }
  
  render(): void {
    this.element.textContent = this.text;
  }
  
  bindEvents(): void {
    this.element.addEventListener('click', this.onClick);
  }
  
  getClassName(): string {
    return 'button-component';
  }
}
```

### 2. Создание API с обязательными методами

```typescript
abstract class DataProcessor {
  // Абстрактный метод для валидации данных
  abstract validate(data: any): boolean;
  
  // Абстрактный метод для обработки данных
  abstract process(data: any): any;
  
  // Общий метод для выполнения всей операции
  execute(data: any): any {
    if (!this.validate(data)) {
      throw new Error("Данные не прошли валидацию");
    }
    
    return this.process(data);
  }
}

class UserProcessor extends DataProcessor {
  validate(data: any): boolean {
    return typeof data === 'object' && 
           typeof data.name === 'string' && 
           typeof data.age === 'number' && 
           data.age > 0;
  }
  
  process(data: any): any {
    return {
      ...data,
      processedAt: new Date(),
      status: 'processed'
    };
  }
}
```

## Абстрактные классы vs Интерфейсы

| Характеристика | Абстрактные классы | Интерфейсы |
|----------------|-------------------|------------|
| Могут содержать реализацию | ✅ | ❌ |
| Могут содержать конструктор | ✅ | ❌ |
| Поддерживают модификаторы доступа | ✅ | ❌ (все публичные) |
| Можно наследоваться только от одного | ✅ | ✅ (реализовать можно несколько) |
| Могут содержать поля | ✅ | ✅ (только определения) |

```typescript
// Пример сравнения
interface IShape {
  area(): number;
  perimeter(): number;
}

abstract class AbstractShape {
  protected color: string = 'white';
  
  constructor(color: string) {
    this.color = color;
  }
  
  abstract area(): number;
  
  // Общий метод для всех фигур
  getColor(): string {
    return this.color;
  }
}

// Класс может реализовывать интерфейс
class Circle implements IShape {
  constructor(private radius: number) {}
  
  area(): number {
    return Math.PI * this.radius ** 2;
  }
  
  perimeter(): number {
    return 2 * Math.PI * this.radius;
  }
}

// Или наследоваться от абстрактного класса
class Square extends AbstractShape {
  constructor(color: string, private side: number) {
    super(color);
  }
  
  area(): number {
    return this.side ** 2;
  }
}
```

## Связанные темы

- [[Определение-классов]] - Основы создания классов в TypeScript
- [[Наследование-классов]] - Наследование от абстрактных классов
- [[Модификаторы-доступа]] - Использование модификаторов в абстрактных классах
- [[Статические-члены]] - Статические члены в абстрактных классах
- [[Интерфейсы-и-классы]] - Сравнение интерфейсов и абстрактных классов
- [[Полиморфизм]] - Использование полиморфизма с абстрактными классами

## Практические рекомендации

1. **Используйте абстрактные классы для общего функционала** - когда у наследников есть общая реализация
2. **Определяйте контракт через абстрактные методы** - обязательные методы для реализации в наследниках
3. **Не создавайте слишком сложные иерархии** - абстрактные классы должны упрощать, а не усложнять код
4. **Документируйте абстрактные методы** - ясно указывайте, что должен реализовать наследник
5. **Рассмотрите интерфейсы для простых контрактов** - если не нужна общая реализация

## Заключение

Абстрактные классы в TypeScript предоставляют мощный инструмент для создания иерархий классов с обязательными контрактами и общей функциональностью. Они позволяют создавать гибкие и поддерживаемые архитектуры, обеспечивая при этом типовую безопасность и структурированный подход к разработке.

Для более полного понимания темы рекомендуется также изучить [[Интерфейсы-и-классы]] и [[Полиморфизм]].