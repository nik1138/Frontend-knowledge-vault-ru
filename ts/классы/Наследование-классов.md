---
aliases: ["Наследование в TypeScript", "Расширение классов", "extends", "super"]
tags: ["#typescript", "#classes", "#inheritance", "#oop", "#intermediate"]
---

# Наследование классов в TypeScript

## Введение

Наследование - один из ключевых принципов объектно-ориентированного программирования, позволяющий создавать новые классы на основе существующих. В TypeScript наследование реализуется с помощью ключевого слова `extends`. Это позволяет дочерним классам наследовать свойства и методы родительского класса, а также переопределять или расширять их функциональность.

## Базовый синтаксис наследования

```typescript
class Animal {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  move(distance: number = 0): void {
    console.log(`${this.name} перемещается на ${distance} м.`);
  }
}

class Dog extends Animal {
  breed: string;
  
  constructor(name: string, breed: string) {
    super(name); // Вызов конструктора родительского класса
    this.breed = breed;
  }
  
  bark(): void {
    console.log("Гав! Гав!");
  }
  
  // Переопределение метода родителя
  move(distance: number = 5): void {
    console.log("Собака бежит...");
    super.move(distance); // Вызов родительского метода
  }
}

const myDog = new Dog("Рекс", "Лабрадор");
myDog.bark(); // Вывод: "Гав! Гав!"
myDog.move(10); // Вывод: "Собака бежит..." и "Рекс перемещается на 10 м."
```

> [!note] Важно
> При переопределении конструктора в дочернем классе обязательно нужно вызвать `super()` для инициализации родительского класса.

## Метод `super`

Ключевое слово `super` используется для доступа к свойствам и методам родительского класса:

- `super()` - вызывает конструктор родительского класса
- `super.methodName()` - вызывает метод родительского класса
- `super.propertyName` - доступ к свойству родительского класса

```typescript
class Vehicle {
  protected speed: number = 0;
  
  accelerate(increment: number): void {
    this.speed += increment;
    console.log(`Скорость: ${this.speed} км/ч`);
  }
}

class Car extends Vehicle {
  private brand: string;
  
  constructor(brand: string) {
    super();
    this.brand = brand;
  }
  
  accelerate(increment: number): void {
    console.log(`${this.brand} ускоряется...`);
    super.accelerate(increment);
  }
}
```

## Многоуровневое наследование

TypeScript поддерживает многоуровневое наследование, когда класс может наследовать от другого дочернего класса:

```typescript
class LivingBeing {
  alive: boolean = true;
  
  isAlive(): boolean {
    return this.alive;
  }
}

class Animal extends LivingBeing {
  move(): void {
    console.log("Животное двигается");
  }
}

class Mammal extends Animal {
  feedMilk(): void {
    console.log("Млекопитающее кормит детенышей молоком");
  }
}

class Dog extends Mammal {
  bark(): void {
    console.log("Собака лает");
  }
}

const dog = new Dog();
console.log(dog.isAlive()); // true
dog.move(); // "Животное двигается"
dog.feedMilk(); // "Млекопитающее кормит детенышей молоком"
dog.bark(); // "Собака лает"
```

## Наследование с модификаторами доступа

Модификаторы доступа влияют на доступ к членам класса в дочерних классах:

- `public` - доступен везде
- `protected` - доступен в родительском и дочерних классах
- `private` - доступен только в родительском классе

```typescript
class Parent {
  public publicProp: string = "Публичное свойство";
  protected protectedProp: string = "Защищенное свойство";
  private privateProp: string = "Приватное свойство";
  
  public publicMethod(): void {
    console.log("Публичный метод");
  }
  
  protected protectedMethod(): void {
    console.log("Защищенный метод");
  }
  
  private privateMethod(): void {
    console.log("Приватный метод");
  }
}

class Child extends Parent {
  accessParentMembers(): void {
    console.log(this.publicProp); // OK
    console.log(this.protectedProp); // OK
    // console.log(this.privateProp); // ОШИБКА - недоступно
    
    this.publicMethod(); // OK
    this.protectedMethod(); // OK
    // this.privateMethod(); // ОШИБКА - недоступно
  }
}
```

## Переопределение методов

Дочерние классы могут переопределять методы родительского класса с помощью ключевого слова `override` (доступно в TypeScript 4.3+):

```typescript
class Shape {
  area(): number {
    return 0;
  }
  
  perimeter(): number {
    return 0;
  }
}

class Rectangle extends Shape {
  constructor(
    private width: number,
    private height: number
  ) {
    super();
  }
  
  override area(): number {
    return this.width * this.height;
  }
  
  override perimeter(): number {
    return 2 * (this.width + this.height);
  }
}

class Circle extends Shape {
  constructor(private radius: number) {
    super();
  }
  
  override area(): number {
    return Math.PI * this.radius ** 2;
  }
  
  override perimeter(): number {
    return 2 * Math.PI * this.radius;
  }
}
```

## Наследование и интерфейсы

Классы могут реализовывать интерфейсы в дополнение к наследованию от других классов:

```typescript
interface Flyable {
  fly(): void;
}

interface Swimmable {
  swim(): void;
}

class Bird {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  move(): void {
    console.log(`${this.name} движется`);
  }
}

class Duck extends Bird implements Flyable, Swimmable {
  constructor(name: string) {
    super(name);
  }
  
  fly(): void {
    console.log(`${this.name} летит`);
  }
  
  swim(): void {
    console.log(`${this.name} плавает`);
  }
  
  override move(): void {
    this.fly();
    this.swim();
  }
}
```

## Связанные темы

- [[Определение-классов]] - Основы создания классов в TypeScript
- [[Модификаторы-доступа]] - Подробное рассмотрение модификаторов доступа
- [[Абстрактные-классы]] - Создание абстрактных классов и методов
- [[Статические-члены]] - Статические свойства и методы в наследуемых классах
- [[Интерфейсы-и-классы]] - Взаимодействие между интерфейсами и классами
- [[Полиморфизм]] - Использование полиморфизма с наследованием

## Практические рекомендации

1. **Используйте наследование осознанно** - только когда действительно существует отношение "является" между классами
2. **Избегайте глубокой иерархии наследования** - более 3-4 уровней может усложнить код
3. **Предпочитайте композицию наследованию** в сложных сценариях
4. **Используйте `override`** при переопределении методов для явного указания намерений
5. **Документируйте иерархию классов** для лучшего понимания архитектуры

## Заключение

Наследование в TypeScript позволяет эффективно повторно использовать код и создавать иерархии классов. Понимание принципов наследования и правильное его применение - важный навык для разработчиков, использующих объектно-ориентированный подход.

Для более глубокого понимания рекомендуется также изучить [[Абстрактные-классы]] и [[Полиморфизм]].