---
aliases: ["Статические члены в TypeScript", "static", "статические методы", "статические свойства"]
tags: ["#typescript", "#classes", "#static", "#oop", "#intermediate"]
---

# Статические члены в TypeScript

## Введение

Статические члены в TypeScript - это свойства и методы, которые принадлежат самому классу, а не экземплярам этого класса. Они доступны без создания экземпляра класса и используются для определения данных и функций, которые общие для всех экземпляров класса. Статические члены объявляются с использованием ключевого слова `static`.

## Основы статических членов

### Статические свойства

Статические свойства принадлежат классу, а не его экземплярам:

```typescript
class Counter {
  static count: number = 0;
  
  constructor() {
    Counter.count++; // Увеличиваем статическое свойство при создании экземпляра
  }
  
  static getCount(): number {
    return Counter.count;
  }
}

console.log(Counter.count); // 0 - доступ к статическому свойству без экземпляра
const c1 = new Counter();
console.log(Counter.count); // 1
const c2 = new Counter();
const c3 = new Counter();
console.log(Counter.count); // 3
console.log(Counter.getCount()); // 3 - вызов статического метода

// Следующая строка вызовет ошибку:
// console.log(c1.count); // ОШИБКА - нет у экземпляра
```

> [!tip] Совет
> Используйте статические свойства для хранения данных, которые общие для всех экземпляров класса, таких как счетчики, конфигурации или константы.

### Статические методы

Статические методы также принадлежат классу и могут быть вызваны без создания экземпляра:

```typescript
class MathUtils {
  static PI: number = 3.14159;
  
  static add(a: number, b: number): number {
    return a + b;
  }
  
  static multiply(a: number, b: number): number {
    return a * b;
  }
  
  static circleArea(radius: number): number {
    return this.PI * radius * radius; // this ссылается на класс, а не на экземпляр
  }
  
  static isEven(num: number): boolean {
    return num % 2 === 0;
  }
}

console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.multiply(4, 6)); // 24
console.log(MathUtils.circleArea(5)); // 78.53975
console.log(MathUtils.isEven(10)); // true
```

## Практические применения статических членов

### 1. Фабричные методы

Статические методы часто используются как альтернативные конструкторы:

```typescript
class User {
  constructor(
    public name: string,
    public email: string,
    public role: string
  ) {}
  
  // Фабричный метод для создания администратора
  static createAdmin(name: string, email: string): User {
    return new User(name, email, 'admin');
  }
  
  // Фабричный метод для создания гостя
  static createGuest(): User {
    return new User('Guest', 'guest@example.com', 'guest');
  }
  
  // Фабричный метод для создания пользователя из строки
  static fromString(userData: string): User {
    const [name, email, role] = userData.split(',');
    return new User(name.trim(), email.trim(), role.trim());
  }
}

const admin = User.createAdmin('Админ', 'admin@example.com');
const guest = User.createGuest();
const user = User.fromString('Иван,ivan@example.com,user');

console.log(admin.role); // 'admin'
console.log(guest.name); // 'Guest'
console.log(user.email); // 'ivan@example.com'
```

### 2. Синглтон-паттерн

Статические члены позволяют реализовать паттерн синглтон:

```typescript
class DatabaseConnection {
  private static instance: DatabaseConnection;
  private isConnected: boolean = false;
  
  private constructor() {
    // Приватный конструктор предотвращает создание экземпляров напрямую
  }
  
  static getInstance(): DatabaseConnection {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection();
    }
    return DatabaseConnection.instance;
  }
  
  connect(): void {
    if (!this.isConnected) {
      console.log('Подключение к базе данных...');
      this.isConnected = true;
    }
  }
  
  disconnect(): void {
    if (this.isConnected) {
      console.log('Отключение от базы данных...');
      this.isConnected = false;
    }
  }
}

// Использование синглтона
const db1 = DatabaseConnection.getInstance();
const db2 = DatabaseConnection.getInstance();

console.log(db1 === db2); // true - это один и тот же экземпляр
db1.connect(); // "Подключение к базе данных..."
db2.connect(); // Ничего не выводит, так как уже подключено
```

### 3. Утилитарные классы

Статические методы идеально подходят для утилитарных функций:

```typescript
class StringUtils {
  static capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }
  
  static truncate(str: string, maxLength: number): string {
    return str.length > maxLength ? str.substring(0, maxLength) + '...' : str;
  }
  
  static camelCase(str: string): string {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
      return index === 0 ? word.toLowerCase() : word.toUpperCase();
    }).replace(/\s+/g, '');
  }
  
  static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

console.log(StringUtils.capitalize('hello world')); // 'Hello world'
console.log(StringUtils.truncate('Длинная строка', 5)); // 'Длинн...'
console.log(StringUtils.camelCase('hello world test')); // 'helloWorldTest'
console.log(StringUtils.isValidEmail('test@example.com')); // true
```

## Статические члены с модификаторами доступа

Статические члены могут использовать модификаторы доступа:

```typescript
class Configuration {
  private static apiKey: string = '';
  protected static debugMode: boolean = false;
  public static version: string = '1.0.0';
  
  static setApiKey(key: string): void {
    if (this.validateApiKey(key)) {
      this.apiKey = key;
    } else {
      throw new Error('Неверный API ключ');
    }
  }
  
  static getApiKey(): string {
    return this.apiKey;
  }
  
  private static validateApiKey(key: string): boolean {
    return key.length >= 10 && key.startsWith('sk-');
  }
  
  static enableDebug(): void {
    this.debugMode = true;
    console.log('Режим отладки включен');
  }
  
  static isDebugMode(): boolean {
    return this.debugMode;
  }
}

Configuration.setApiKey('sk-1234567890');
console.log(Configuration.getApiKey()); // 'sk-1234567890'
Configuration.enableDebug(); // "Режим отладки включен"
console.log(Configuration.isDebugMode()); // true
```

## Статические поля и инициализация

Статические поля могут быть инициализированы различными способами:

```typescript
class GameConstants {
  // Простая инициализация
  static readonly MAX_PLAYERS: number = 4;
  
  // Инициализация с вычислениями
  static readonly GAME_SPEED: number = Math.random() * 10 + 1;
  
  // Инициализация объекта
  static readonly DEFAULT_SETTINGS = {
    volume: 0.8,
    difficulty: 'medium',
    graphics: 'high'
  };
  
  // Инициализация массива
  static readonly AVAILABLE_LEVELS: string[] = ['easy', 'medium', 'hard', 'expert'];
  
  // Статическое поле с геттером/сеттером
  private static _gameName: string = 'Новая Игра';
  
  static get gameName(): string {
    return this._gameName;
  }
  
  static set gameName(name: string) {
    if (name && name.length > 3) {
      this._gameName = name;
    } else {
      throw new Error('Имя игры должно быть не менее 4 символов');
    }
  }
}

console.log(GameConstants.MAX_PLAYERS); // 4
console.log(GameConstants.DEFAULT_SETTINGS.volume); // 0.8
console.log(GameConstants.AVAILABLE_LEVELS[2]); // 'hard'
GameConstants.gameName = 'Моя Игра';
console.log(GameConstants.gameName); // 'Моя Игра'
```

## Статические методы и наследование

При наследовании статические методы также наследуются, но поведение `this` меняется:

```typescript
class Animal {
  static type: string = 'Животное';
  
  static getInfo(): string {
    return `Тип: ${this.type}`; // this ссылается на вызывающий класс
  }
  
  static makeSound(): string {
    return 'Какой-то звук';
  }
}

class Dog extends Animal {
  static type: string = 'Собака';
  
  static makeSound(): string {
    return 'Гав!';
  }
  
  // Использование super для доступа к родительскому статическому методу
  static getParentInfo(): string {
    return super.getInfo();
  }
}

console.log(Animal.getInfo()); // 'Тип: Животное'
console.log(Dog.getInfo()); // 'Тип: Собака' (полиморфизм статических методов)
console.log(Animal.makeSound()); // 'Какой-то звук'
console.log(Dog.makeSound()); // 'Гав!'
console.log(Dog.getParentInfo()); // 'Тип: Животное'

// Сравнение с обычными методами
class Vehicle {
  static type = 'Транспорт';
  
  getType(): string {
    return `Объект типа: ${(this.constructor as any).type}`;
  }
  
  static getTypeInfo(): string {
    return `Класс типа: ${this.type}`;
  }
}
```

## Связанные темы

- [[Определение-классов]] - Основы создания классов в TypeScript
- [[Наследование-классов]] - Наследование статических членов
- [[Модификаторы-доступа]] - Использование модификаторов с статическими членами
- [[Абстрактные-классы]] - Статические члены в абстрактных классах
- [[Паттерны-проектирования]] - Использование статических членов в паттернах
- [[Функции-высшего-порядка]] - Альтернативы статическим методам

## Практические рекомендации

1. **Используйте статические методы для утилитарных функций** - которые не зависят от состояния экземпляра
2. **Создавайте фабричные методы** - для альтернативных способов создания экземпляров
3. **Используйте статические свойства для конфигурации** - общей для всех экземпляров
4. **Будьте осторожны с состоянием** - статические свойства общие для всех экземпляров
5. **Документируйте статические члены** - особенно фабричные методы и их назначение

## Заключение

Статические члены в TypeScript предоставляют важный механизм для создания методов и свойств, которые принадлежат самому классу, а не его экземплярам. Они особенно полезны для утилитарных функций, фабричных методов, хранения общей конфигурации и реализации паттернов проектирования. Правильное использование статических членов помогает создавать более чистую и структурированную архитектуру приложений.

Для более глубокого понимания рекомендуется также изучить [[Паттерны-проектирования]] и [[Функции-высшего-порядка]].