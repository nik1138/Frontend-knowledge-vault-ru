---
aliases: ["Модификаторы доступа в TypeScript", "public", "private", "protected", "access modifiers"]
tags: ["#typescript", "#classes", "#access-modifiers", "#oop", "#intermediate"]
---

# Модификаторы доступа в TypeScript

## Введение

Модификаторы доступа в TypeScript - это ключевые слова, которые определяют видимость и доступность членов класса (свойств, методов, конструкторов) извне. Они играют важную роль в инкапсуляции - одном из основных принципов объектно-ориентированного программирования. TypeScript поддерживает три основных модификатора доступа: `public`, `private`, и `protected`.

## Основные модификаторы доступа

### Public (публичный)

Модификатор `public` делает член класса доступным из любого места. Это модификатор по умолчанию, поэтому если модификатор не указан, член считается публичным.

```typescript
class PublicExample {
  public name: string; // Явно публичное свойство
  age: number;        // По умолчанию публичное
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  public greet(): string { // Явно публичный метод
    return `Привет, меня зовут ${this.name}`;
  }
  
  introduce(): string { // По умолчанию публичный метод
    return `${this.greet()}, мне ${this.age} лет`;
  }
}

const example = new PublicExample("Алексей", 30);
console.log(example.name);        // OK - доступен извне
console.log(example.age);         // OK - доступен извне
console.log(example.greet());     // OK - вызов метода
console.log(example.introduce()); // OK - вызов метода
```

> [!tip] Совет
> Используйте `public` явно, когда хотите подчеркнуть, что член класса является частью публичного API.

### Private (приватный)

Модификатор `private` делает член класса доступным только внутри этого же класса. Он недоступен в дочерних классах и извне.

```typescript
class BankAccount {
  private balance: number = 0;
  private accountNumber: string;
  
  constructor(initialBalance: number, accountNumber: string) {
    this.balance = initialBalance;
    this.accountNumber = accountNumber;
  }
  
  public deposit(amount: number): void {
    if (amount > 0) {
      this.balance += amount;
      console.log(`Внесено ${amount}. Баланс: ${this.balance}`);
    }
  }
  
  public withdraw(amount: number): boolean {
    if (amount > 0 && amount <= this.balance) {
      this.balance -= amount;
      console.log(`Снято ${amount}. Баланс: ${this.balance}`);
      return true;
    }
    console.log("Недостаточно средств или неверная сумма");
    return false;
  }
  
  public getBalance(): number {
    return this.balance;
  }
  
  private validateAccount(): boolean {
    // Приватный метод для внутренней валидации
    return this.accountNumber.length >= 10;
  }
}

const account = new BankAccount(1000, "ACC123456789");
account.deposit(500);           // OK
account.withdraw(200);          // OK
console.log(account.getBalance()); // OK: 1300

// Следующие строки вызовут ошибки компиляции:
// console.log(account.balance);      // ОШИБКА - приватное свойство
// console.log(account.accountNumber); // ОШИБКА - приватное свойство
// account.validateAccount();         // ОШИБКА - приватный метод
```

> [!warning] Важно
> Приватные члены недоступны даже в дочерних классах. Они видны только внутри класса, где объявлены.

### Protected (защищенный)

Модификатор `protected` делает член класса доступным внутри этого класса и в его дочерних классах, но недоступным извне.

```typescript
class Employee {
  protected name: string;
  protected salary: number;
  
  constructor(name: string, salary: number) {
    this.name = name;
    this.salary = salary;
  }
  
  protected calculateBonus(): number {
    return this.salary * 0.1;
  }
  
  public getDetails(): string {
    return `Сотрудник: ${this.name}, Зарплата: ${this.salary}`;
  }
}

class Manager extends Employee {
  private teamSize: number;
  
  constructor(name: string, salary: number, teamSize: number) {
    super(name, salary);
    this.teamSize = teamSize;
  }
  
  public getDetails(): string {
    // Доступ к protected свойствам родителя
    const baseDetails = super.getDetails();
    return `${baseDetails}, Команда: ${this.teamSize} человек`;
  }
  
  public getBonus(): number {
    // Доступ к protected методу родителя
    return this.calculateBonus();
  }
}

const emp = new Employee("Иван", 50000);
const mgr = new Manager("Мария", 70000, 5);

console.log(mgr.getDetails()); // OK
console.log(`Бонус: ${mgr.getBonus()}`); // OK

// Следующая строка вызовет ошибку:
// console.log(mgr.salary); // ОШИБКА - protected свойство
```

## Сравнение модификаторов доступа

| Модификатор | В классе | В наследнике | Извне |
|-------------|----------|--------------|--------|
| `public`    | ✅       | ✅           | ✅      |
| `protected` | ✅       | ✅           | ❌      |
| `private`   | ✅       | ❌           | ❌      |

## Использование в конструкторах

Модификаторы доступа можно использовать непосредственно в параметрах конструктора, что автоматически создает свойства класса:

```typescript
class Student {
  constructor(
    public name: string,        // Создает public свойство
    private id: number,         // Создает private свойство
    protected course: string    // Создает protected свойство
  ) {}
  
  public getId(): number {
    return this.id; // Доступ к private свойству внутри класса
  }
  
  protected getCourse(): string {
    return this.course; // Доступ к protected свойству внутри класса
  }
}

class GraduateStudent extends Student {
  constructor(
    name: string,
    id: number,
    course: string,
    private thesis: string
  ) {
    super(name, id, course);
  }
  
  public getDetails(): string {
    // Доступ к protected свойству родителя
    return `${this.name} (${this.getCourse()}): ${this.thesis}`;
  }
  
  // Не можем получить доступ к private свойству id напрямую
  public getStudentId(): number {
    return this.getId(); // Используем public метод родителя
  }
}
```

## Применение модификаторов к методам

Модификаторы доступа также применяются к методам класса:

```typescript
class Calculator {
  private lastResult: number = 0;
  
  public add(a: number, b: number): number {
    const result = a + b;
    this.updateLastResult(result);
    return result;
  }
  
  private updateLastResult(result: number): void {
    this.lastResult = result;
  }
  
  protected getLastResult(): number {
    return this.lastResult;
  }
}

class AdvancedCalculator extends Calculator {
  public multiply(a: number, b: number): number {
    const result = a * b;
    // Не можем вызвать updateLastResult напрямую (private)
    // Но можем получить последний результат
    console.log(`Последний результат: ${this.getLastResult()}`);
    return result;
  }
}
```

## Связанные темы

- [[Определение-классов]] - Основы создания классов в TypeScript
- [[Наследование-классов]] - Использование модификаторов доступа при наследовании
- [[Абстрактные-классы]] - Модификаторы доступа в абстрактных классах
- [[Статические-члены]] - Модификаторы доступа для статических членов
- [[Инкапсуляция]] - Принцип инкапсуляции в ООП
- [[Интерфейсы-и-классы]] - Взаимодействие между интерфейсами и классами

## Практические рекомендации

1. **Используйте `private` для внутреннего состояния** - защищайте внутренние данные и методы от внешнего доступа
2. **Предпочтите `protected` для наследования** - когда дочерние классы должны иметь доступ к членам родителя
3. **Минимизируйте `public` API** - публичный интерфейс должен быть минимальным и ясным
4. **Документируйте публичные члены** - используйте JSDoc для описания публичного API
5. **Рассмотрите использование геттеров/сеттеров** для контроля доступа к данным

## Заключение

Модификаторы доступа в TypeScript обеспечивают важный уровень контроля над инкапсуляцией классов. Правильное использование этих модификаторов помогает создавать более безопасные, понятные и поддерживаемые приложения. Понимание различий между `public`, `private` и `protected` позволяет эффективно проектировать архитектуру классов.

Для более глубокого изучения рекомендуется также ознакомиться с [[Абстрактные-классы]] и [[Статические-члены]].