---
aliases: ["Multiple Configurations", "Несколько конфигураций TypeScript", "Многофайловая конфигурация"]
tags: ["#typescript", "#compilation", "#configuration", "#project-structure", "#build-strategy"]
---

# Множественные конфигурации

Множественные конфигурации TypeScript позволяют управлять сложными проектами с различными целями компиляции, окружениями или артефактами. Это особенно полезно для монорепозиториев, библиотек, проектов с разными версиями вывода или различными требованиями к компиляции.

## Основные сценарии использования

### 1. Разделение клиентской и серверной части

Можно создать отдельные конфигурации для фронтенд и бэкенд кода:

- `tsconfig.client.json` - для клиентского кода с настройками для браузеров
- `tsconfig.server.json` - для серверного кода с настройками для Node.js

### 2. Различные цели вывода

Для библиотек может потребоваться несколько версий вывода:

- `tsconfig.esm.json` - для ES модулей
- `tsconfig.cjs.json` - для CommonJS модулей
- `tsconfig.umd.json` - для UMD сборки

### 3. Различные окружения

- `tsconfig.dev.json` - для разработки с отладочной информацией
- `tsconfig.prod.json` - для продакшена с оптимизациями
- `tsconfig.test.json` - для тестирования с дополнительными настройками

## Базовая структура файлов

```
project/
├── tsconfig.json              # Базовая конфигурация
├── tsconfig.client.json       # Конфигурация для клиентского кода
├── tsconfig.server.json       # Конфигурация для серверного кода
├── tsconfig.test.json         # Конфигурация для тестов
├── tsconfig.prod.json         # Продакшен конфигурация
└── tsconfig.dev.json          # Конфигурация для разработки
```

## Наследование конфигураций

Файлы конфигураций могут наследовать настройки от других файлов с помощью свойства `extends`:

```json
// tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

```json
// tsconfig.client.json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "outDir": "./dist/client"
  },
  "include": [
    "src/client/**/*"
  ]
}
```

```json
// tsconfig.server.json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist/server"
  },
  "include": [
    "src/server/**/*"
  ]
}
```

## Composite проекты

Composite проекты позволяют разбить большой проект на более мелкие, управляемые части, каждая из которых может иметь свою конфигурацию.

### Пример структуры composite проекта

```
project/
├── tsconfig.json              # Корневой файл с ссылками на подпроекты
├── packages/
│   ├── core/
│   │   ├── tsconfig.json      # Конфигурация для ядра
│   │   └── src/
│   ├── utils/
│   │   ├── tsconfig.json      # Конфигурация для утилит
│   │   └── src/
│   └── api/
│       ├── tsconfig.json      # Конфигурация для API
│       └── src/
```

### Корневой tsconfig.json для composite проекта

```json
{
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/utils" },
    { "path": "./packages/api" }
  ],
  "files": []
}
```

### Подпроект с composite конфигурацией

```json
// packages/core/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "outDir": "../../dist/core",
    "rootDir": "./src"
  },
  "include": [
    "src/**/*"
  ]
}
```

## Практические примеры конфигураций

### Пример для библиотеки с несколькими целями вывода

```json
// tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2020",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false
  }
}
```

```json
// tsconfig.esm.json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "ESNext",
    "moduleResolution": "node",
    "outDir": "./dist/esm"
  },
  "include": [
    "src/**/*"
  ]
}
```

```json
// tsconfig.cjs.json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "CommonJS",
    "moduleResolution": "node",
    "outDir": "./dist/cjs"
  },
  "include": [
    "src/**/*"
  ]
}
```

### Пример для проекта с разными окружениями

```json
// tsconfig.common.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

```json
// tsconfig.dev.json
{
  "extends": "./tsconfig.common.json",
  "compilerOptions": {
    "sourceMap": true,
    "removeComments": false,
    "incremental": true
  },
  "include": [
    "src/**/*"
  ]
}
```

```json
// tsconfig.prod.json
{
  "extends": "./tsconfig.common.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true,
    "strict": true
  },
  "include": [
    "src/**/*"
  ]
}
```

## Использование в npm scripts

### Сборка с использованием разных конфигураций

```json
{
  "scripts": {
    "build": "npm run build:client && npm run build:server",
    "build:client": "tsc -p tsconfig.client.json",
    "build:server": "tsc -p tsconfig.server.json",
    "build:all": "tsc -b tsconfig.json", // Для composite проектов
    "dev": "tsc -p tsconfig.dev.json --watch",
    "test": "tsc -p tsconfig.test.json"
  }
}
```

### Сборка библиотеки с несколькими целями

```json
{
  "scripts": {
    "build": "npm run build:clean && npm run build:all",
    "build:clean": "rm -rf dist",
    "build:all": "npm run build:esm && npm run build:cjs",
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.cjs.json"
  }
}
```

## Управление зависимостями между конфигурациями

### Использование Project References

Project References позволяют TypeScript понимать зависимости между различными частями проекта и эффективно управлять компиляцией:

```json
// tsconfig.json
{
  "references": [
    { "path": "./client" },
    { "path": "./server" },
    { "path": "./shared" }
  ],
  "files": []
}
```

### Компиляция с учетом зависимостей

```bash
# Компиляция всех проектов с учетом зависимостей
tsc -b

# Компиляция с очисткой
tsc -b --clean

# Вывод информации о проекте
tsc -b --dry
```

## Практические рекомендации

### 1. Иерархия конфигураций

Создайте иерархию конфигураций, где базовая конфигурация содержит общие настройки:

```
tsconfig.base.json    # Общие настройки
├── tsconfig.client.json
├── tsconfig.server.json
├── tsconfig.test.json
└── tsconfig.prod.json
```

### 2. Использование composite проектов для больших приложений

Для больших приложений используйте composite проекты для разделения на логические модули:

- Повышает производительность компиляции
- Улучшает управляемость
- Позволяет использовать инкрементальную компиляцию эффективно

### 3. Оптимизация для разных целей

Разные конфигурации могут быть оптимизированы для:

- Разработки (с source maps, отладочной информацией)
- Продакшена (с оптимизациями, без отладочной информации)
- Тестирования (с дополнительными настройками для тестов)

### 4. Документирование конфигураций

Документируйте назначение каждой конфигурации в README или в комментариях к файлу конфигурации.

## Проблемы и решения

### 1. Конфликты между конфигурациями

Убедитесь, что разные конфигурации не конфликтуют друг с другом по файлам вывода:

```json
{
  "compilerOptions": {
    "outDir": "./dist/client"  // Для клиентской конфигурации
  }
}
```

```json
{
  "compilerOptions": {
    "outDir": "./dist/server"  // Для серверной конфигурации
  }
}
```

### 2. Управление общими файлами

Для общих файлов используйте отдельную конфигурацию или настройки включения:

```json
// tsconfig.shared.json
{
  "compilerOptions": {
    "composite": true,
    "outDir": "../dist/shared",
    "rootDir": "."
  },
  "include": [
    "**/*.ts"
  ]
}
```

## См. также

- [[tsconfig-json]]
- [[Компилятор]]
- [[Флаги-компиляции]]
- [[Инкрементальная-компиляция]]
- [[Сборка и оптимизация]]
- [[Архитектура проекта TypeScript]]