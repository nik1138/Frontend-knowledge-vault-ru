---
aliases: ["Кэширование типов TS", "Type Caching"]
tags: [typescript, performance, types, caching]
---

# Кэширование типов в TypeScript

## Введение

Кэширование типов в TypeScript - это механизм, при котором компилятор сохраняет результаты анализа типов для повторного использования в будущих сессиях компиляции. Это позволяет значительно ускорить процесс проверки типов, особенно в крупных проектах, где одни и те же типы используются в множестве мест.

## Принципы работы кэширования типов

### Базовый механизм

TypeScript кэширует информацию о типах на нескольких уровнях:

1. **Файловый уровень**: кэшируются результаты анализа отдельных файлов
2. **Проектный уровень**: кэшируются зависимости между файлами
3. **Глобальный уровень**: кэшируются библиотечные типы

### Файлы кэша

TypeScript использует следующие файлы для хранения кэшированной информации:

- `.tsbuildinfo` - информация о сборке (при включенной опции `incremental`)
- Кэш в памяти во время сессии компиляции
- Временные файлы кэша (в зависимости от настройки)

## Настройка кэширования

### Включение инкрементальной сборки

Для эффективного кэширования типов необходимо включить инкрементальную сборку:

```json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./build/tsbuildinfo.json",
    "composite": true
  }
}
```

### Оптимизация настроек компиляции

```json
{
  "compilerOptions": {
    "incremental": true,
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

- `skipLibCheck`: пропускает проверку типов в библиотечных файлах, что ускоряет начальную загрузку
- `forceConsistentCasingInFileNames`: помогает избежать проблем с кэшированием на системах с чувствительностью к регистру

## Практические примеры кэширования

### Простое кэширование интерфейсов

```typescript
// common-types.ts
export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

export interface Product {
  id: number;
  title: string;
  price: number;
  category: string;
}

// При первом использовании этих типов TypeScript проанализирует и закэширует их структуру
// При последующем использовании в других файлах будет использован кэш
```

```typescript
// user-service.ts
import { User } from './common-types';

export class UserService {
  // TypeScript использует кэшированную информацию о типе User
  static async getUser(id: number): Promise<User> {
    // реализация
    return { 
      id, 
      name: 'John Doe', 
      email: 'john@example.com', 
      createdAt: new Date() 
    };
  }
  
  static validateUser(user: User): boolean {
    return user.id > 0 && 
           user.name.length > 0 && 
           user.email.includes('@');
  }
}
```

### Кэширование сложных типов

```typescript
// type-utils.ts
export type ApiResponse<T> = {
  data: T;
  status: number;
  message: string;
};

export type AsyncResult<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Эти типы будут кэшироваться и переиспользоваться
```

```typescript
// api-service.ts
import { ApiResponse, AsyncResult } from './type-utils';
import { User } from './common-types';

export class ApiService {
  // Использование кэшированных типов
  async fetchUser(id: number): Promise<AsyncResult<ApiResponse<User>>> {
    try {
      const response = await fetch(`/api/users/${id}`);
      const userData = await response.json();
      
      if (response.ok) {
        return {
          success: true,
          data: {
            data: userData,
            status: response.status,
            message: 'User fetched successfully'
          }
        };
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      return {
        success: false,
        error: error as Error
      };
    }
  }
}
```

## Продвинутые техники кэширования

### Утилиты для работы с типами

```typescript
// type-cache-utils.ts
export namespace TypeCache {
  // Кэширование результата сложных вычислений типов
  export type DeepPartial<T> = T extends object 
    ? { [P in keyof T]?: DeepPartial<T[P]> } 
    : T;
  
  // Кэширование маппинга типов
  export type PickRequired<T, K extends keyof T> = 
    Omit<T, K> & Required<Pick<T, K>>;
  
  // Кэширование условных типов
  export type NonNullableProperties<T> = {
    [P in keyof T]: NonNullable<T[P]>;
  };
}
```

### Кэширование через дженерики

```typescript
// cached-generic.ts
export class TypeCache<T> {
  private cache: Map<string, T> = new Map();
  
  get(key: string): T | undefined {
    return this.cache.get(key);
  }
  
  set(key: string, value: T): void {
    this.cache.set(key, value);
  }
  
  has(key: string): boolean {
    return this.cache.has(key);
  }
}

// Использование кэшированных типов в дженериках
export function createCachedProcessor<T>() {
  const cache = new TypeCache<T>();
  
  return {
    process: (data: T, key: string) => {
      if (!cache.has(key)) {
        cache.set(key, data);
      }
      return cache.get(key)!;
    },
    getCache: () => cache
  };
}
```

## Оптимизация производительности кэширования

### Структурирование типов для лучшего кэширования

```typescript
// Плохо - каждый компонент определяет свои типы
// component-a.ts
interface ComponentAProps {
  user: { id: number; name: string; email: string };
}

// component-b.ts
interface ComponentBProps {
  user: { id: number; name: string; email: string }; // дублирование
}

// Лучше - централизованные типы для кэширования
// shared-types.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

// component-a.ts
import { User } from './shared-types';
interface ComponentAProps {
  user: User;
}

// component-b.ts
import { User } from './shared-types';
interface ComponentBProps {
  user: User; // использует тот же кэшированный тип
}
```

### Избегание сложных вычислений типов

```typescript
// Плохо - сложные вычисления типов при каждом использовании
type ComplexType<T> = T extends Record<string, unknown> 
  ? { [K in keyof T as `processed_${string & K}`]: T[K] extends string ? Uppercase<T[K]> : T[K] } 
  : never;

// Лучше - предварительное вычисление и кэширование
type ProcessedKey<K extends string> = `processed_${K}`;
type ProcessedValue<T> = T extends string ? Uppercase<T> : T;

type OptimizedComplexType<T> = T extends Record<string, unknown> 
  ? { [K in keyof T as ProcessedKey<K & string>]: ProcessedValue<T[K]> } 
  : never;
```

## Инструменты для анализа кэширования

### Встроенные диагностические средства

```json
{
  "compilerOptions": {
    "incremental": true,
    "diagnostics": true,
    "extendedDiagnostics": true,
    "listFiles": true,
    "traceResolution": true
  }
}
```

### Команды для анализа

```bash
# Показать расширенную диагностику
tsc --extendedDiagnostics

# Показать файлы, участвующие в компиляции
tsc --listFiles

# Показать информацию о разрешении модулей
tsc --traceResolution
```

## Практические советы

### 1. Используйте barrel-файлы для кэширования

```typescript
// types/index.ts
export type { User } from './user';
export type { Product } from './product';
export type { Order } from './order';
export * from './api-types';
export * from './validation-types';
```

### 2. Централизуйте общие типы

```typescript
// shared/types/common.ts
export type Id = string | number;
export type Timestamp = number;
export type JsonValue = string | number | boolean | null | JsonObject | JsonValue[];

export interface JsonObject {
  [key: string]: JsonValue;
}
```

### 3. Избегайте реэкспорта типов

```typescript
// Плохо - усложняет кэширование
// types/a.ts
export interface A { /* ... */ }

// types/b.ts
export { A } from './a'; // реэкспорт

// types/c.ts
import { A } from './b'; // дополнительный уровень косвенности

// Лучше - прямой импорт
// types/c.ts
import { A } from './a'; // прямой путь к типу
```

## Заключение

Кэширование типов в TypeScript - мощный инструмент для оптимизации производительности компиляции. Правильное структурирование типов, использование инкрементальной сборки и централизация общих типов позволяют максимально эффективно использовать кэширование и ускорить процесс разработки.

См. также:
- [[Оптимизация-компиляции]]
- [[Инкрементальная-компиляция]]
- [[Профилирование-типов]]
- [[Лучшие-практики-производительности]]