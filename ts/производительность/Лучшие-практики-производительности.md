---
aliases: ["Практики производительности TS", "Best Practices Performance"]
tags: [typescript, performance, best-practices, optimization]
---

# Лучшие практики производительности TypeScript

## Введение

Этот документ охватывает комплексную стратегию оптимизации производительности TypeScript-приложений, включая компиляцию, проверку типов и время выполнения. Правильное применение этих практик позволяет значительно улучшить опыт разработки и производительность конечного приложения.

## Настройка компиляции

### Оптимальная конфигурация tsconfig.json

```json
{
  "compilerOptions": {
    // Основные настройки производительности
    "incremental": true,
    "composite": true,
    "tsBuildInfoFile": "./build/tsbuildinfo.json",
    
    // Настройки вывода
    "target": "ES2020",
    "module": "ESNext",
    "outDir": "./dist",
    "rootDir": "./src",
    
    // Оптимизации типов
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    
    // Настройки типов
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    // Строгие проверки (используйте осознанно)
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "build"
  ]
}
```

### Использование композитных проектов

Для крупных приложений рекомендуется использовать композитные проекты:

```json
// tsconfig.json (корневой)
{
  "files": [],
  "references": [
    { "path": "./packages/shared" },
    { "path": "./packages/client" },
    { "path": "./packages/server" },
    { "path": "./packages/tests" }
  ]
}
```

```json
// packages/shared/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "incremental": true,
    "declaration": true,
    "outDir": "../../dist/shared"
  },
  "include": ["**/*"]
}
```

## Оптимизация структуры кода

### Архитектура модулей

#### Избегайте циклических зависимостей

```typescript
// Плохо - циклическая зависимость
// user.ts
import { Order } from './order';
export class User {
  orders: Order[] = [];
}

// order.ts
import { User } from './user';
export class Order {
  user: User;
}
```

```typescript
// Хорошо - разрешение циклической зависимости через общий интерфейс
// entities.ts
export interface UserEntity {
  id: number;
  name: string;
}

export interface OrderEntity {
  id: number;
  userId: number;
  items: OrderItem[];
}

// user.ts
import { OrderEntity } from './entities';
export class User implements UserEntity {
  id: number;
  name: string;
  orders: OrderEntity[] = [];
}

// order.ts
import { UserEntity } from './entities';
export class Order implements OrderEntity {
  id: number;
  userId: number;
  items: OrderItem[] = [];
}
```

#### Использование barrel-файлов

```typescript
// models/index.ts
export { User } from './user';
export { Product } from './product';
export { Order } from './order';
export { Cart } from './cart';
```

```typescript
// В других файлах
import { User, Product, Order } from '../models'; // Одна строка импорта
```

### Оптимизация типов

#### Избегайте чрезмерно сложных условных типов

```typescript
// Плохо - чрезмерно сложный тип
type OverlyComplexType<T> = T extends Record<string, unknown> 
  ? { 
      [K in keyof T]: T[K] extends infer U 
        ? U extends string 
          ? Uppercase<U> 
          : U extends number 
            ? `${U}` 
            : U extends (infer V)[] 
              ? V extends Record<string, unknown> 
                ? ComplexType<V> 
                : U 
              : ComplexType<U> 
    } 
  : T;

// Лучше - разделение на более простые типы
type StringProcessor<T> = T extends string ? Uppercase<T> : T;
type NumberProcessor<T> = T extends number ? `${T}` : T;
type ArrayProcessor<T> = T extends (infer U)[] ? ProcessType<U>[] : T;
type ObjectProcessor<T> = T extends Record<string, unknown> ? { [K in keyof T]: ProcessType<T[K]> } : T;

type ProcessType<T> = 
  T extends string ? StringProcessor<T> :
  T extends number ? NumberProcessor<T> :
  T extends unknown[] ? ArrayProcessor<T> :
  T extends Record<string, unknown> ? ObjectProcessor<T> :
  T;
```

#### Использование оператора `satisfies`

```typescript
// До TypeScript 4.9
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
} as const;

// config будет иметь тип { readonly [x: string]: string | number }

// С оператором satisfies
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3
} satisfies Record<string, string | number>;

// config сохраняет свои конкретные типы, но проверяется на соответствие структуре
```

## Оптимизация во время выполнения

### Эффективная работа с массивами

```typescript
// Используйте более эффективные методы для больших массивов
const largeArray: number[] = Array.from({ length: 1000000 }, (_, i) => i);

// Плохо - создание промежуточных массивов
const result1 = largeArray
  .filter(x => x % 2 === 0)
  .map(x => x * 2)
  .slice(0, 100);

// Лучше - использование итераторов или оптимизированных методов
function processArray(arr: number[], limit: number): number[] {
  const result: number[] = [];
  let count = 0;
  
  for (const item of arr) {
    if (count >= limit) break;
    if (item % 2 === 0) {
      result.push(item * 2);
      count++;
    }
  }
  
  return result;
}
```

### Оптимизация производительности объектов

```typescript
// Используйте Object.freeze для константных объектов
const CONSTANTS = Object.freeze({
  API_URL: 'https://api.example.com',
  TIMEOUT: 5000,
  MAX_RETRIES: 3
} as const);

// Избегайте создания новых объектов в циклах
interface User {
  id: number;
  name: string;
  email: string;
}

// Плохо
function createUsersBad(count: number): User[] {
  const users: User[] = [];
  for (let i = 0; i < count; i++) {
    users.push({
      id: i,
      name: `User ${i}`,
      email: `user${i}@example.com`
    });
  }
  return users;
}

// Лучше - предварительное создание шаблона
function createUsersGood(count: number): User[] {
  const template: User = {
    id: 0,
    name: '',
    email: ''
  };
  
  const users: User[] = [];
  for (let i = 0; i < count; i++) {
    const user = { ...template }; // или Object.assign
    user.id = i;
    user.name = `User ${i}`;
    user.email = `user${i}@example.com`;
    users.push(user);
  }
  return users;
}
```

## Инструменты и мониторинг

### Использование диагностики TypeScript

```json
{
  "compilerOptions": {
    "incremental": true,
    "diagnostics": true,
    "extendedDiagnostics": true,
    "listFiles": true
  }
}
```

```bash
# Запуск с диагностикой
tsc --diagnostics --extendedDiagnostics
```

### Мониторинг производительности компиляции

Создайте скрипт для регулярного анализа производительности:

```bash
#!/bin/bash
# performance-check.sh
echo "Анализ производительности TypeScript..."

# Время начала
start_time=$(date +%s%N)

# Компиляция
npx tsc --incremental --diagnostics

# Время окончания
end_time=$(date +%s%N)

# Вычисление времени выполнения
execution_time=$(( (end_time - start_time) / 1000000 ))
echo "Время компиляции: ${execution_time}ms"
```

## Практические примеры оптимизации

### Пример 1: Оптимизация API-клиента

```typescript
// Неоптимизированная версия
class NaiveApiClient {
  async fetchUser(id: number) {
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    return userData;
  }
  
  async fetchUsers(ids: number[]) {
    const users = [];
    for (const id of ids) {
      const user = await this.fetchUser(id); // Последовательные запросы!
      users.push(user);
    }
    return users;
  }
}

// Оптимизированная версия
class OptimizedApiClient {
  private cache = new Map<number, any>();
  
  async fetchUser(id: number) {
    if (this.cache.has(id)) {
      return this.cache.get(id);
    }
    
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    this.cache.set(id, userData);
    return userData;
  }
  
  async fetchUsers(ids: number[]) {
    // Параллельные запросы с кэшированием
    const promises = ids.map(id => this.fetchUser(id));
    return Promise.all(promises);
  }
  
  // Пакетный запрос для улучшения производительности
  async fetchUsersBatch(userIds: number[]) {
    const uncachedIds = userIds.filter(id => !this.cache.has(id));
    
    if (uncachedIds.length > 0) {
      const response = await fetch('/api/users/batch', {
        method: 'POST',
        body: JSON.stringify({ ids: uncachedIds })
      });
      const usersData = await response.json();
      
      // Заполнение кэша
      usersData.forEach((user: any) => {
        this.cache.set(user.id, user);
      });
    }
    
    // Возврат в правильном порядке
    return userIds.map(id => this.cache.get(id));
  }
}
```

### Пример 2: Оптимизация сложных вычислений

```typescript
// Кэширование результатов сложных вычислений
class ExpensiveOperationCache {
  private cache = new Map<string, any>();
  
  computeHeavyOperation(input: ComplexInputType): ResultType {
    // Создание уникального ключа для входных данных
    const key = this.generateCacheKey(input);
    
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const result = this.performExpensiveComputation(input);
    this.cache.set(key, result);
    return result;
  }
  
  private generateCacheKey(input: ComplexInputType): string {
    // Реализация генерации ключа на основе входных данных
    return JSON.stringify(input);
  }
  
  private performExpensiveComputation(input: ComplexInputType): ResultType {
    // Реализация сложного вычисления
    return {} as ResultType;
  }
}
```

## Проверка и тестирование производительности

### Создание бенчмарков

```typescript
// performance-benchmark.ts
export class PerformanceBenchmark {
  static measure<T>(fn: () => T, name: string): { result: T; duration: number } {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    console.log(`${name}: ${end - start}ms`);
    return { result, duration: end - start };
  }
  
  static async measureAsync<T>(fn: () => Promise<T>, name: string): Promise<{ result: T; duration: number }> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    console.log(`${name}: ${end - start}ms`);
    return { result, duration: end - start };
  }
}

// Использование
const { result, duration } = PerformanceBenchmark.measure(() => {
  // код для тестирования
  return someExpensiveOperation();
}, 'Expensive Operation');
```

## Заключение

Применение этих практик производительности TypeScript требует баланса между безопасностью типов и производительностью. Важно регулярно анализировать производительность своего кода и вносить оптимизации по мере роста проекта.

Ключевые моменты:
- Используйте инкрементальную компиляцию
- Оптимизируйте структуру типов
- Избегайте циклических зависимостей
- Используйте кэширование для дорогостоящих операций
- Регулярно мониторьте производительность

См. также:
- [[Оптимизация-компиляции]]
- [[Инкрементальная-компиляция]]
- [[Кэширование-типов]]
- [[Профилирование-типов]]