---
aliases: ["Профилирование типов TS", "Type Profiling"]
tags: [typescript, performance, types, profiling, debugging]
---

# Профилирование типов в TypeScript

## Введение

Профилирование типов в TypeScript - это процесс анализа производительности системы типов, который позволяет выявлять узкие места в проверке типов, оптимизировать сложные типы и улучшать общую производительность компиляции. Это особенно важно в крупных проектах, где сложные типы могут значительно замедлить процесс разработки.

## Инструменты профилирования

### Встроенные диагностические средства TypeScript

TypeScript предоставляет несколько встроенных опций для профилирования:

```json
{
  "compilerOptions": {
    "diagnostics": true,
    "extendedDiagnostics": true,
    "listFiles": true,
    "traceResolution": true,
    "explainFiles": true
  }
}
```

- `diagnostics`: Показывает время компиляции для различных этапов
- `extendedDiagnostics`: Показывает более подробную информацию о производительности
- `explainFiles`: Показывает, почему файл был включен в компиляцию

### Команды для профилирования

```bash
# Обычная диагностика
tsc --diagnostics

# Расширенная диагностика
tsc --extendedDiagnostics

# С информацией о файлах
tsc --explainFiles --diagnostics
```

## Идентификация проблем с типами

### Обнаружение сложных типов

Сложные условные типы могут значительно замедлить компиляцию:

```typescript
// Проблемный код - сложный условный тип
type VeryComplexType<T> = T extends Array<infer U>
  ? U extends object
    ? U extends { id: infer ID }
      ? { [K in ID & string]: U }
      : Record<string, U>
    : Record<string, U>
  : T extends Promise<infer V>
    ? V extends { data: infer D }
      ? D
      : V
    : T;
```

### Использование инструментов анализа

Для поиска проблемных типов можно использовать:

1. **ts-unused-exports** - для поиска неиспользуемых типов
2. **typescript-plugin-css-modules** - для оптимизации работы с модулями
3. **Custom linting rules** - для выявления сложных типов

## Практические примеры профилирования

### Пример 1: Анализ производительности условных типов

```typescript
// Файл: performance-test.ts
// Сложный тип для тестирования
type NestedConditional<T> = 
  T extends string 
    ? T extends `a${infer Rest}` 
      ? `processed_a_${Rest}` 
      : T extends `b${infer Rest}` 
        ? `processed_b_${Rest}` 
        : T 
  : T extends number 
    ? T extends 1 | 2 | 3 
      ? `number_${T}` 
      : `${T}` 
  : T;

// Использование типа для профилирования
type TestResult1 = NestedConditional<'abc'>;
type TestResult2 = NestedConditional<'def'>;
type TestResult3 = NestedConditional<1>;
type TestResult4 = NestedConditional<42>;
```

Для анализа производительности этого кода запустите:

```bash
tsc --extendedDiagnostics performance-test.ts
```

### Пример 2: Профилирование больших типов объединения

```typescript
// Проблемный код - большое объединение типов
type LargeUnion = 
  | 'option1' | 'option2' | 'option3' | 'option4' | 'option5'
  | 'option6' | 'option7' | 'option8' | 'option9' | 'option10'
  | 'option11' | 'option12' | 'option13' | 'option14' | 'option15'
  // ... и так далее

function processOptions(option: LargeUnion) {
  // обработка опций
  return option.toUpperCase();
}

// Использование во многих местах
const result1 = processOptions('option1' as LargeUnion);
const result2 = processOptions('option2' as LargeUnion);
// ... много использований
```

### Пример 3: Профилирование рекурсивных типов

```typescript
// Осторожно: потенциально медленные рекурсивные типы
type DeepNested<T, Depth extends number = 5> = 
  Depth extends 0
    ? T
    : T extends object
      ? { [K in keyof T]: DeepNested<T[K], MinusOne<Depth>> }
      : T;

type MinusOne<N extends number> = 
  N extends 0 ? 0 : 
  N extends 1 ? 0 :
  N extends 2 ? 1 :
  N extends 3 ? 2 :
  N extends 4 ? 3 :
  N extends 5 ? 4 :
  N extends 6 ? 5 :
  // ... и так далее
  N;
```

## Инструменты для анализа производительности

### TypeScript Compiler Profiler

Для более глубокого анализа можно использовать сторонние инструменты:

```bash
# Установка tsc-profiler
npm install -g tsc-profiler

# Анализ проекта
tsc-profiler analyze ./tsconfig.json
```

### Использование ts-morph для анализа

```typescript
// analysis.ts
import { Project } from 'ts-morph';

const project = new Project({
  tsConfigFilePath: './tsconfig.json'
});

// Анализ сложности типов
const sourceFiles = project.getSourceFiles();

sourceFiles.forEach(file => {
  const fileName = file.getBaseName();
  console.log(`Анализ файла: ${fileName}`);
  
  // Поиск сложных типов
  const typeAliases = file.getTypeAliases();
  typeAliases.forEach(alias => {
    const name = alias.getName();
    const type = alias.getType();
    console.log(`  Тип: ${name}, Сложность: ${type.getText().length}`);
  });
});
```

## Оптимизация обнаруженных проблем

### Замена сложных условных типов

```typescript
// До: Сложный условный тип
type ComplexConditional<T> = 
  T extends string 
    ? T extends `prefix_${infer Rest}` 
      ? { type: 'prefixed'; value: Rest } 
      : { type: 'normal'; value: T } 
  : T extends number 
    ? { type: 'number'; value: T } 
    : { type: 'other'; value: string };

// После: Упрощенный подход с перегрузками функций
interface ProcessedString {
  type: 'prefixed' | 'normal';
  value: string;
}

interface ProcessedNumber {
  type: 'number';
  value: number;
}

interface ProcessedOther {
  type: 'other';
  value: string;
}

function processValue(value: string): ProcessedString;
function processValue(value: number): ProcessedNumber;
function processValue(value: unknown): ProcessedOther;
function processValue(value: unknown) {
  if (typeof value === 'string') {
    if (value.startsWith('prefix_')) {
      return { type: 'prefixed', value: value.substring(7) };
    }
    return { type: 'normal', value };
  } else if (typeof value === 'number') {
    return { type: 'number', value };
  } else {
    return { type: 'other', value: String(value) };
  }
}
```

### Оптимизация больших объединений

```typescript
// До: Большое объединение
type LargeUnion = 
  | 'option1' | 'option2' | 'option3' | 'option4' | 'option5'
  | 'option6' | 'option7' | 'option8' | 'option9' | 'option10';

// После: Использование литеральных типов с проверкой
const validOptions = [
  'option1', 'option2', 'option3', 'option4', 'option5',
  'option6', 'option7', 'option8', 'option9', 'option10'
] as const;

type ValidOption = typeof validOptions[number];

function isValidOption(value: string): value is ValidOption {
  return (validOptions as readonly string[]).includes(value);
}
```

### Использование мемоизации типов

```typescript
// Создание кэша для сложных вычислений типов
type TypeCache = {
  // Кэш может быть реализован на уровне компилятора
};

// Пример упрощенного кэширования
type CachedComplexType<T> = 
  T extends string 
    ? T extends CachedStringType<T> // Предполагаем, что это кэшированный тип
      ? CachedStringType<T> 
      : ComputeStringType<T>
  : ComputeComplexType<T>;

// Вспомогательные типы для кэширования
type ComputeStringType<T extends string> = 
  T extends `a${infer Rest}` ? `processed_a_${Rest}` : 
  T extends `b${infer Rest}` ? `processed_b_${Rest}` : 
  T;

type CachedStringType<T extends string> = 
  T extends `a${string}` | `b${string}` 
    ? ComputeStringType<T> 
    : T;
```

## Мониторинг производительности в реальном времени

### Настройка watch-режима с профилированием

```json
{
  "compilerOptions": {
    "incremental": true,
    "diagnostics": true
  },
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "fallbackPolling": "dynamicPriority"
  }
}
```

### Использование IDE для профилирования

Большинство современных IDE (VS Code, WebStorm) показывают время проверки типов в реальном времени. Обратите внимание на:

1. Задержки при автодополнении
2. Время обновления информации о типах
3. Сообщения о производительности от TypeScript сервера

## Практические рекомендации

### 1. Регулярный аудит типов

Создайте скрипт для регулярной проверки производительности типов:

```bash
#!/bin/bash
# check-type-performance.sh
echo "Запуск анализа производительности типов..."
tsc --extendedDiagnostics --noEmit
echo "Анализ завершен."
```

### 2. Использование strict-режимов с осторожностью

```json
{
  "compilerOptions": {
    // Используйте строгие режимы осознанно
    "strict": true,
    // Но избегайте избыточной сложности типов
    "noStrictGenericChecks": false
  }
}
```

### 3. Мониторинг сложных паттернов

Следите за следующими паттернами, которые могут вызвать проблемы:

- Глубоко вложенные условные типы
- Рекурсивные типы без надежных базовых случаев
- Типы, зависящие от большого количества параметров
- Сложные маппинг-типы с условиями

## Заключение

Профилирование типов в TypeScript - важный аспект оптимизации производительности проекта. Регулярный анализ, идентификация проблемных типов и их оптимизация позволяют поддерживать высокую производительность компиляции даже в самых сложных проектах.

См. также:
- [[Оптимизация-компиляции]]
- [[Инкрементальная-компиляция]]
- [[Кэширование-типов]]
- [[Лучшие-практики-производительности]]