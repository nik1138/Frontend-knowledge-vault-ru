---
aliases: ["Инкрементальная сборка TS", "Incremental Compilation"]
tags: [typescript, performance, compilation, incremental-build]
---

# Инкрементальная компиляция TypeScript

## Введение

Инкрементальная компиляция - это метод компиляции, при котором компилятор анализирует только измененные файлы и их зависимости, а не перекомпилирует весь проект заново. В TypeScript это реализуется с помощью флага `incremental` и файлов `.tsbuildinfo`, которые хранят информацию о предыдущей сборке.

## Основы инкрементальной компиляции

### Включение инкрементальной компиляции

Для включения инкрементальной компиляции добавьте следующие настройки в ваш `tsconfig.json`:

```json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo"
  }
}
```

Параметр `tsBuildInfoFile` указывает имя файла, в котором TypeScript будет хранить информацию о предыдущей сборке. Этот файл можно безопасно добавить в `.gitignore`, так как он генерируется автоматически.

### Как работает инкрементальная компиляция

При первой компиляции TypeScript анализирует все файлы проекта и сохраняет информацию о типах, структуре файлов и зависимостях в `.tsbuildinfo`. При последующих запусках компилятор:

1. Сравнивает временные метки файлов с предыдущей сборкой
2. Определяет, какие файлы были изменены
3. Перекомпилирует только измененные файлы и те, которые зависят от них
4. Обновляет `.tsbuildinfo` с новой информацией

## Практические примеры

### Простой пример

Рассмотрим простой проект с двумя файлами:

```typescript
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}
```

```typescript
// main.ts
import { add, multiply } from './math';

const result = add(5, 3);
const product = multiply(4, 6);

console.log(`Result: ${result}, Product: ${product}`);
```

После первой компиляции с включенной инкрементальной сборкой, при изменении только `main.ts`, TypeScript перекомпилирует только этот файл, так как `math.ts` не изменился.

### Сложный пример с зависимостями

```typescript
// interfaces/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

export interface UserPreferences {
  theme: 'light' | 'dark';
  notifications: boolean;
}
```

```typescript
// services/user-service.ts
import { User, UserPreferences } from '../interfaces/user';

export class UserService {
  static async getUser(id: number): Promise<User> {
    // реализация
    return { id, name: 'John Doe', email: 'john@example.com' };
  }

  static async getPreferences(userId: number): Promise<UserPreferences> {
    // реализация
    return { theme: 'light', notifications: true };
  }
}
```

```typescript
// controllers/user-controller.ts
import { User, UserPreferences } from '../interfaces/user';
import { UserService } from '../services/user-service';

export class UserController {
  async getUserData(userId: number): Promise<{ user: User; preferences: UserPreferences }> {
    const user = await UserService.getUser(userId);
    const preferences = await UserService.getPreferences(userId);
    
    return { user, preferences };
  }
}
```

При изменении интерфейса `User` в `interfaces/user.ts`, TypeScript перекомпилирует:
- `interfaces/user.ts` (измененный файл)
- `services/user-service.ts` (использует User)
- `controllers/user-controller.ts` (использует User)

## Композитные проекты и инкрементальная компиляция

### Настройка композитных проектов

Для крупных приложений рекомендуется использовать композитные проекты:

```json
// tsconfig.json (корневой)
{
  "files": [],
  "references": [
    { "path": "./shared" },
    { "path": "./client" },
    { "path": "./server" }
  ]
}
```

```json
// shared/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "incremental": true,
    "declaration": true,
    "outDir": "../dist/shared"
  },
  "include": ["**/*"]
}
```

```json
// client/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "incremental": true,
    "outDir": "../dist/client"
  },
  "references": [
    { "path": "../shared" }
  ],
  "include": ["**/*"]
}
```

### Преимущества композитных проектов

1. **Более точный контроль зависимостей**: каждый подпроект может иметь свои зависимости
2. **Лучшая изоляция изменений**: изменения в одном подпроекте не затрагивают другие, если зависимости не изменились
3. **Параллельная компиляция**: можно компилировать подпроекты параллельно

## Практические советы

### Оптимизация структуры файлов

1. **Избегайте циклических зависимостей**:
   ```typescript
   // Плохо - циклическая зависимость
   // a.ts
   import { B } from './b';
   export class A {
     b: B;
   }
   
   // b.ts
   import { A } from './a';
   export class B {
     a: A;
   }
   ```

   ```typescript
   // Хорошо - разрешение циклической зависимости через общий интерфейс
   // common.ts
   export interface IA { }
   export interface IB { }
   
   // a.ts
   import { IB } from './common';
   export class A implements IA {
     b: IB;
   }
   
   // b.ts
   import { IA } from './common';
   export class B implements IB {
     a: IA;
   }
   ```

2. **Используйте barrel-файлы**:
   ```typescript
   // models/index.ts
   export { User } from './user';
   export { Product } from './product';
   export { Order } from './order';
   ```

### Оптимизация типов

1. **Избегайте чрезмерно сложных типов**:
   ```typescript
   // Плохо - сложный тип, замедляющий компиляцию
   type ComplexType<T> = T extends Record<string, unknown> 
     ? { [K in keyof T]: T[K] extends infer U ? U extends string ? U : ComplexType<U> : never } 
     : T;
   
   // Лучше - более простая структура
   type SimpleType<T> = T extends Record<string, unknown> 
     ? { [K in keyof T]: T[K] extends string ? T[K] : SimpleType<T[K]> } 
     : T;
   ```

2. **Используйте типы вместо интерфейсов для простых структур**:
   ```typescript
   // Для простых структур типы могут быть быстрее
   type Point = { x: number; y: number; };
   
   // Для сложных структур с наследованием лучше интерфейсы
   interface Shape {
     area(): number;
   }
   ```

## Команды для работы с инкрементальной компиляцией

### Основные команды

```bash
# Обычная инкрементальная сборка
tsc --incremental

# Сборка с отслеживанием изменений
tsc --incremental --watch

# Очистка кэша инкрементальной сборки
tsc --build --clean

# Полная сборка без использования кэша
tsc --incremental --force
```

### Режим сборки проекта

```bash
# Компиляция всех проектов с учетом зависимостей
tsc --build

# Компиляция с подробной информацией
tsc --build --verbose

# Только проверка необходимости пересборки
tsc --build --dry
```

## Мониторинг производительности

### Использование диагностики

Для анализа производительности инкрементальной компиляции используйте диагностику:

```json
{
  "compilerOptions": {
    "incremental": true,
    "diagnostics": true,
    "extendedDiagnostics": true
  }
}
```

### Инструменты анализа

1. **ts-unused-exports**: находит неиспользуемые экспортные функции
2. **typescript-plugin-css-modules**: улучшает работу с CSS-модулями
3. **ts-loader** с опциями кэширования для Webpack

## Заключение

Инкрементальная компиляция TypeScript - мощный инструмент для ускорения процесса разработки. Правильная настройка и структурирование проекта позволяют значительно сократить время компиляции, особенно в крупных приложениях.

См. также:
- [[Оптимизация-компиляции]]
- [[Кэширование-типов]]
- [[Профилирование-типов]]
- [[Лучшие-практики-производительности]]