---
aliases: ["Decorator Factories", "Фабрики декораторов TS"]
tags: [ts/decorators, typescript, decorator-factories]
---

# Фабрики декораторов

## Обзор

[[Фабрики-декораторов]] - это функции, которые возвращают фактический декоратор. Они позволяют передавать параметры в декораторы, делая их более гибкими и переиспользуемыми. Фабрика декоратора - это функция, которая при вызове возвращает внутреннюю функцию, соответствующую сигнатуре декоратора.

## Структура фабрики декоратора

```typescript
function decoratorFactory(arg: any) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // Логика декоратора
  };
}
```

## Пример фабрики декоратора класса

```typescript
function Component(options: { selector: string; template: string }) {
  return function (constructor: Function) {
    // Добавляем метаданные к классу
    constructor.prototype.selector = options.selector;
    constructor.prototype.template = options.template;
    
    console.log(`Компонент зарегистрирован: ${options.selector}`);
  };
}

@Component({
  selector: 'app-header',
  template: '<h1>Заголовок приложения</h1>'
})
class HeaderComponent {
  title = 'Мое приложение';
}
```

## Пример фабрики декоратора метода

```typescript
function Retry(maxAttempts: number, delay: number = 1000) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          attempts++;
          console.log(`Попытка ${attempts} не удалась:`, error.message);
          
          if (attempts >= maxAttempts) {
            throw error;
          }
          
          // Задержка перед следующей попыткой
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    };

    return descriptor;
  };
}

class ApiService {
  @Retry(3, 500)
  async fetchData(url: string) {
    // Имитация асинхронного запроса
    if (Math.random() > 0.5) {
      throw new Error('Сетевая ошибка');
    }
    return `Данные с ${url}`;
  }
}
```

## Фабрика декоратора свойства с параметрами

```typescript
function Min(minValue: number) {
  return function (target: any, propertyKey: string) {
    // Сохраняем ограничение в метаданных
    Reflect.defineMetadata(`validation:min:${propertyKey}`, minValue, target, propertyKey);
  };
}

function Max(maxValue: number) {
  return function (target: any, propertyKey: string) {
    Reflect.defineMetadata(`validation:max:${propertyKey}`, maxValue, target, propertyKey);
  };
}

function validate(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const keys = Object.keys(this);
    
    for (const key of keys) {
      const minVal = Reflect.getMetadata(`validation:min:${key}`, target, key);
      const maxVal = Reflect.getMetadata(`validation:max:${key}`, target, key);
      
      if (minVal !== undefined && this[key] < minVal) {
        throw new Error(`${key} не может быть меньше ${minVal}`);
      }
      
      if (maxVal !== undefined && this[key] > maxVal) {
        throw new Error(`${key} не может быть больше ${maxVal}`);
      }
    }
    
    return originalMethod.apply(this, args);
  };

  return descriptor;
}

class Rectangle {
  @Min(1)
  @Max(100)
  width: number;
  
  @Min(1)
  @Max(100)
  height: number;
  
  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }
  
  @validate
  calculateArea() {
    return this.width * this.height;
  }
}

const rect = new Rectangle(5, 10);
console.log(rect.calculateArea()); // 50
```

## Универсальная фабрика логирования

```typescript
function Log(level: 'info' | 'warn' | 'error' = 'info', prefix: string = '') {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      const logPrefix = prefix ? `[${prefix}] ` : '';
      const logLevel = level.toUpperCase();
      
      console[level](`${logLevel}: ${logPrefix}Вызов метода ${propertyKey}`, ...args);
      
      const result = originalMethod.apply(this, args);
      
      console[level](`${logLevel}: ${logPrefix}Метод ${propertyKey} вернул`, result);
      
      return result;
    };

    return descriptor;
  };
}

class Calculator {
  @Log('info', 'CALC')
  add(a: number, b: number): number {
    return a + b;
  }
  
  @Log('warn', 'CALC')
  divide(a: number, b: number): number {
    if (b === 0) {
      throw new Error('Деление на ноль');
    }
    return a / b;
  }
}
```

## Фабрика декоратора для кеширования с TTL

```typescript
function CacheWithTTL(ttl: number) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cache = new Map();
    
    descriptor.value = function (...args: any[]) {
      const key = JSON.stringify(args);
      const now = Date.now();
      
      if (cache.has(key)) {
        const { value, timestamp } = cache.get(key);
        
        if (now - timestamp < ttl) {
          console.log(`Возвращаем результат из кеша для ${propertyKey}`);
          return value;
        } else {
          // Удаляем устаревший кеш
          cache.delete(key);
        }
      }
      
      const result = originalMethod.apply(this, args);
      
      // Сохраняем результат с меткой времени
      cache.set(key, { value: result, timestamp: now });
      
      return result;
    };

    return descriptor;
  };
}

class WeatherService {
  @CacheWithTTL(5000) // 5 секунд
  async getWeather(city: string) {
    // Имитация асинхронного запроса
    return new Promise(resolve => 
      setTimeout(() => resolve(`Погода в ${city}: солнечно`), 100)
    );
  }
}
```

## Фабрика декоратора для проверки ролей

```typescript
function RequireRoles(roles: string[]) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      if (!this.user) {
        throw new Error('Пользователь не аутентифицирован');
      }
      
      const hasRole = roles.some(role => this.user.roles.includes(role));
      
      if (!hasRole) {
        throw new Error(`Требуется одна из ролей: ${roles.join(', ')}`);
      }
      
      return originalMethod.apply(this, args);
    };

    return descriptor;
  };
}

class AdminService {
  user = { roles: ['user', 'editor'] };

  @RequireRoles(['admin'])
  deleteUser(userId: number) {
    console.log(`Пользователь ${userId} удален`);
  }
  
  @RequireRoles(['admin', 'moderator'])
  banUser(userId: number) {
    console.log(`Пользователь ${userId} заблокирован`);
  }
}
```

## Фабрика декоратора для таймаута

```typescript
function Timeout(ms: number) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`Таймаут выполнения метода ${propertyKey}`)), ms);
      });
      
      const resultPromise = originalMethod.apply(this, args);
      
      // Race между результатом и таймаутом
      return Promise.race([resultPromise, timeoutPromise]);
    };

    return descriptor;
  };
}

class ExternalApiService {
  @Timeout(2000) // 2 секунды
  async getData() {
    // Имитация длительного запроса
    return new Promise(resolve => 
      setTimeout(() => resolve('Данные получены'), 3000)
    );
  }
}
```

## Комбинирование фабрик декораторов

```typescript
function combineDecorators<T extends PropertyDecorator | MethodDecorator>(
  ...decorators: T[]
): T {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    for (const decorator of decorators) {
      const result = decorator(target, propertyKey, descriptor);
      if (result) {
        return result;
      }
    }
  } as T;
}

// Пример использования
const loggedAndTimed = combineDecorators(
  Log('info', 'TIMED'),
  Timeout(5000)
);

class DataProcessor {
  @loggedAndTimed
  async processLargeDataset() {
    // Обработка данных
    return new Promise(resolve => 
      setTimeout(() => resolve('Обработка завершена'), 1000)
    );
  }
}
```

## Важные замечания

> [!note] Примечание
> Фабрики декораторов позволяют создавать параметризованные декораторы, что делает их гораздо более гибкими и переиспользуемыми.

> [!warning] Важно
> При создании фабрик декораторов необходимо учитывать, что параметры передаются при объявлении декоратора, а не при выполнении метода.

## Заключение

[[Фабрики-декораторов]] являются мощным инструментом для создания гибких и переиспользуемых декораторов с параметрами. Они позволяют создавать более сложные и настраиваемые декораторы, которые могут адаптироваться к различным сценариям использования.

Для изучения других аспектов декораторов см.:
- [[Введение-в-декораторы]]
- [[Декораторы-классов]]
- [[Декораторы-методов]]
- [[Декораторы-свойств]]