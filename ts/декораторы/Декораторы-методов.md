---
aliases: ["Method Decorators", "Декораторы методов TS"]
tags: [ts/decorators, typescript, method-decorators]
---

# Декораторы методов

## Обзор

[[Декораторы-методов]] применяются к объявлению метода класса и могут использоваться для наблюдения, изменения или замены определения метода. Они получают информацию о методе и могут изменить его дескриптор, тем самым изменяя поведение метода.

## Сигнатура декоратора метода

```typescript
declare type MethodDecorator = <T>(
  target: Object,
  propertyKey: string | symbol,
  descriptor: TypedPropertyDescriptor<T>
) => TypedPropertyDescriptor<T> | void;
```

Декоратор метода принимает три параметра:
- `target` - прототип класса для статических методов, экземпляр класса для методов экземпляра
- `propertyKey` - имя метода
- `descriptor` - дескриптор свойства, содержащий `value`, `writable`, `enumerable` и `configurable`

## Простой пример логирования

```typescript
function logMethod(
  target: Object,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Вызов метода: ${propertyKey}`, args);
    const result = originalMethod.apply(this, args);
    console.log(`Результат метода: ${propertyKey} =`, result);
    return result;
  };

  return descriptor;
}

class Calculator {
  @logMethod
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(5, 3); // Логирует вызов и результат
```

## Декоратор для измерения производительности

```typescript
function performance(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const start = performance.now();
    const result = originalMethod.apply(this, args);
    const end = performance.now();
    console.log(`${propertyKey} выполнено за ${end - start} миллисекунд`);
    return result;
  };

  return descriptor;
}

class DataProcessor {
  @performance
  processLargeArray() {
    // Представим, что здесь обработка большого массива
    return new Array(1000000).fill(0).map((_, i) => i * 2);
  }
}
```

## Декоратор для кеширования результатов

```typescript
function cache(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  const cacheMap = new Map();

  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    
    if (cacheMap.has(key)) {
      console.log(`Возвращаем результат из кеша для ${propertyKey}`);
      return cacheMap.get(key);
    }

    const result = originalMethod.apply(this, args);
    cacheMap.set(key, result);
    return result;
  };

  return descriptor;
}

class ExpensiveOperation {
  @cache
  fibonacci(n: number): number {
    if (n <= 1) return n;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
}
```

## Декоратор для валидации аргументов

```typescript
function validateString(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === 'string' && args[i].length === 0) {
        throw new Error(`Аргумент ${i} не может быть пустой строкой`);
      }
    }
    return originalMethod.apply(this, args);
  };

  return descriptor;
}

class UserService {
  @validateString
  createUser(name: string, email: string) {
    return { name, email };
  }
}
```

## Декоратор для ограничения частоты вызовов (throttle)

```typescript
function throttle(delay: number) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    let timeoutId: NodeJS.Timeout;

    descriptor.value = function (...args: any[]) {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      timeoutId = setTimeout(() => {
        originalMethod.apply(this, args);
      }, delay);
    };

    return descriptor;
  };
}

class Button {
  @throttle(1000)
  onClick() {
    console.log('Кнопка нажата');
  }
}
```

## Декоратор для авторизации

```typescript
function requireRole(role: string) {
  return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      if (!this.user || !this.user.roles.includes(role)) {
        throw new Error(`Требуется роль: ${role}`);
      }
      return originalMethod.apply(this, args);
    };

    return descriptor;
  };
}

class AdminService {
  user = { roles: ['user'] };

  @requireRole('admin')
  deleteAllUsers() {
    console.log('Все пользователи удалены');
  }
}
```

## Комбинирование декораторов

Можно использовать несколько декораторов на одном методе:

```typescript
class DataService {
  @logMethod
  @performance
  @cache
  getExpensiveData(id: number) {
    // Выполнение дорогостоящей операции
    return { id, data: `Данные для ${id}` };
  }
}
```

## Совместимость с асинхронными методами

Декораторы также работают с асинхронными методами:

```typescript
function asyncLog(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = async function (...args: any[]) {
    console.log(`Асинхронный вызов: ${propertyKey}`, args);
    const result = await originalMethod.apply(this, args);
    console.log(`Асинхронный результат: ${propertyKey} =`, result);
    return result;
  };

  return descriptor;
}

class ApiService {
  @asyncLog
  async fetchUser(id: number) {
    // Имитация асинхронного запроса
    return new Promise(resolve => 
      setTimeout(() => resolve({ id, name: `User${id}` }), 1000)
    );
  }
}
```

## Важные замечания

> [!warning] Важно
> Декораторы методов не могут быть использованы в объявлениях интерфейсов или в параметрах шаблона.

> [!note] Примечание
> Декораторы методов могут изменять дескриптор метода, но должны возвращать либо измененный дескриптор, либо undefined.

## Заключение

[[Декораторы-методов]] предоставляют мощный способ модификации поведения методов без изменения их основного кода. Они особенно полезны для внедрения общих функций, таких как логирование, кеширование, валидация и контроль доступа.

Для изучения других типов декораторов см.:
- [[Введение-в-декораторы]]
- [[Декораторы-классов]]
- [[Декораторы-свойств]]
- [[Фабрики-декораторов]]