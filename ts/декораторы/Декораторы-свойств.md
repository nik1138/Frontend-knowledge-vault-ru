---
aliases: ["Property Decorators", "Декораторы свойств TS"]
tags: [ts/decorators, typescript, property-decorators]
---

# Декораторы свойств

## Обзор

[[Декораторы-свойств]] применяются к объявлению свойства класса. Они могут использоваться для наблюдения за свойством или добавления метаданных, но не могут изменить дескриптор свойства, так как он не передается декоратору свойства во время объявления класса.

## Сигнатура декоратора свойства

```typescript
declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
```

Декоратор свойства принимает два параметра:
- `target` - прототип класса для статических свойств, экземпляр класса для свойств экземпляра
- `propertyKey` - имя свойства

## Ограничения декораторов свойств

> [!warning] Ограничение
> Декораторы свойств не получают дескриптор свойства, поэтому они не могут напрямую изменить определение свойства, как это делают декораторы методов.

## Простой пример с метаданными

```typescript
function format(formatString: string) {
  return function (target: any, propertyKey: string) {
    // Сохраняем формат в метаданных свойства
    Reflect.defineMetadata(`format:${propertyKey}`, formatString, target, propertyKey);
  };
}

class User {
  @format('email')
  email: string;

  @format('phone')
  phone: string;

  constructor(email: string, phone: string) {
    this.email = email;
    this.phone = phone;
  }
}

const user = new User('john@example.com', '+1234567890');
console.log(Reflect.getMetadata('format:email', User.prototype, 'email')); // 'email'
```

## Использование декоратора свойства для валидации

```typescript
// Массив для хранения правил валидации
const validationRules: { [key: string]: any[] } = {};

function required(target: Object, propertyKey: string) {
  if (!validationRules[target.constructor.name]) {
    validationRules[target.constructor.name] = [];
  }
  validationRules[target.constructor.name].push({
    property: propertyKey,
    rule: 'required'
  });
}

function minLength(length: number) {
  return function (target: Object, propertyKey: string) {
    if (!validationRules[target.constructor.name]) {
      validationRules[target.constructor.name] = [];
    }
    validationRules[target.constructor.name].push({
      property: propertyKey,
      rule: 'minLength',
      value: length
    });
  };
}

class RegistrationForm {
  @required
  username: string;

  @required
  @minLength(6)
  password: string;

  email: string;

  constructor(username: string, password: string, email: string) {
    this.username = username;
    this.password = password;
    this.email = email;
  }
}

// Функция для проверки валидации
function validate(instance: any): boolean {
  const className = instance.constructor.name;
  const rules = validationRules[className] || [];

  for (const rule of rules) {
    const value = instance[rule.property];
    
    switch (rule.rule) {
      case 'required':
        if (!value) {
          console.log(`${rule.property} является обязательным`);
          return false;
        }
        break;
      case 'minLength':
        if (typeof value === 'string' && value.length < rule.value) {
          console.log(`${rule.property} должен быть не менее ${rule.value} символов`);
          return false;
        }
        break;
    }
  }
  return true;
}

const form = new RegistrationForm('john', '123', 'john@example.com');
console.log(validate(form)); // false - пароль слишком короткий
```

## Декоратор для создания геттеров и сеттеров

Поскольку декоратор свойства не может изменить дескриптор напрямую, часто используются в сочетании с определением геттеров/сеттеров:

```typescript
// Хранилище значений свойств
const propertyValues = new WeakMap();

function observable(target: any, propertyKey: string) {
  const privatePropertyKey = `_${propertyKey}`;
  
  // Создаем геттер и сеттер
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[privatePropertyKey];
    },
    set(value: any) {
      console.log(`Свойство ${propertyKey} изменилось с ${this[privatePropertyKey]} на ${value}`);
      this[privatePropertyKey] = value;
      // Здесь можно вызвать уведомления об изменении
    },
    enumerable: true,
    configurable: true
  });
}

class Person {
  _name: string;
  
  @observable
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
}

const person = new Person('John');
person.name = 'Jane'; // Выведет: Свойство name изменилось с John на Jane
```

## Декоратор для сериализации

```typescript
const serializableProperties: string[] = [];

function serialize(target: any, propertyKey: string) {
  if (!serializableProperties.includes(propertyKey)) {
    serializableProperties.push(propertyKey);
  }
}

function serializeObject(obj: any): any {
  const result: any = {};
  
  for (const prop of serializableProperties) {
    if (obj.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  
  return result;
}

class Product {
  @serialize
  id: number;
  
  @serialize
  name: string;
  
  price: number; // Это свойство не будет сериализовано
  
  constructor(id: number, name: string, price: number) {
    this.id = id;
    this.name = name;
    this.price = price;
  }
}

const product = new Product(1, 'Laptop', 999);
console.log(serializeObject(product)); // { id: 1, name: 'Laptop' }
```

## Декоратор для приватных свойств

```typescript
const privateProperties = new WeakMap();

function private(target: any, propertyKey: string) {
  const privatePropertyKey = `_${propertyKey}`;
  
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[privatePropertyKey];
    },
    set(value: any) {
      this[privatePropertyKey] = value;
    },
    enumerable: false,
    configurable: true
  });
}

class BankAccount {
  _balance: number;
  
  @private
  balance: number;
  
  constructor(initialBalance: number) {
    this.balance = initialBalance;
  }
  
  getBalance(): number {
    return this.balance;
  }
}
```

## Декоратор для вычисляемых свойств

```typescript
const computedProperties = new Map();

function computed(target: any, propertyKey: string) {
  const originalDescriptor = Object.getOwnPropertyDescriptor(target, propertyKey);
  const getter = originalDescriptor?.get;
  
  if (getter) {
    const cacheKey = `_${propertyKey}Cache`;
    
    // Заменяем геттер с кешированием
    Object.defineProperty(target, propertyKey, {
      get() {
        if (this[cacheKey] === undefined) {
          this[cacheKey] = getter.call(this);
        }
        return this[cacheKey];
      },
      enumerable: true,
      configurable: true
    });
  }
}

class Circle {
  radius: number;
  
  constructor(radius: number) {
    this.radius = radius;
  }
  
  @computed
  get area() {
    console.log('Вычисляем площадь...');
    return Math.PI * this.radius * this.radius;
  }
}

const circle = new Circle(5);
console.log(circle.area); // Выведет "Вычисляем площадь..." и результат
console.log(circle.area); // Выведет только результат (кешированный)
```

## Важные замечания

> [!note] Примечание
> Декораторы свойств не могут изменить дескриптор свойства напрямую, как это делают декораторы методов. Вместо этого они часто используются для хранения метаданных или для изменения поведения через геттеры/сеттеры.

> [!warning] Важно
> Декораторы свойств не могут быть использованы в объявлениях интерфейсов или в параметрах шаблона.

## Заключение

[[Декораторы-свойств]] предоставляют способ добавления метаданных к свойствам класса и могут использоваться для реализации различных паттернов, таких как валидация, сериализация и наблюдение за изменениями. Несмотря на свои ограничения, они остаются мощным инструментом для метапрограммирования в TypeScript.

Для изучения других типов декораторов см.:
- [[Введение-в-декораторы]]
- [[Декораторы-классов]]
- [[Декораторы-методов]]
- [[Фабрики-декораторов]]