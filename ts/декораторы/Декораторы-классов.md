---
aliases: ["Class Decorators", "Декораторы классов TS"]
tags: [ts/decorators, typescript, class-decorators]
---

# Декораторы классов

## Обзор

[[Декораторы-классов]] применяются к объявлению класса и могут использоваться для изменения или замены определения класса. Они получают конструктор класса в качестве аргумента и могут возвращать новый конструктор, модифицируя поведение класса.

## Сигнатура декоратора класса

```typescript
declare type ClassDecorator = <TFunction extends Function>(
  target: TFunction
) => TFunction | void;
```

Декоратор класса принимает один параметр:
- `target` - конструктор декорируемого класса

## Простой пример

```typescript
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Person {
  name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  greet() {
    return `Hello, I'm ${this.name}`;
  }
}
```

В этом примере декоратор `@sealed` предотвращает расширение класса и добавление новых свойств к прототипу.

## Расширенный пример с изменением конструктора

```typescript
function loggedClass<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    constructor(...args: any[]) {
      super(...args);
      console.log(`Новый экземпляр класса ${constructor.name} создан`);
    }
  };
}

@loggedClass
class UserService {
  constructor(private apiUrl: string) {
    console.log('UserService инициализирован');
  }
}

const service = new UserService('https://api.example.com');
// Выведет: UserService инициализирован
// Выведет: Новый экземпляр класса UserService создан
```

## Пример с добавлением статических свойств

```typescript
function addMetadata<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    static metadata = {
      createdAt: new Date(),
      version: '1.0.0'
    };
  };
}

@addMetadata
class Product {
  constructor(public name: string, public price: number) {}
}

const product = new Product('Laptop', 999);
console.log(Product.metadata); // { createdAt: ..., version: '1.0.0' }
```

## Практические применения

### 1. Регистрация классов в контейнере внедрения зависимостей

```typescript
const registry = new Map<string, any>();

function Injectable(name: string) {
  return function (constructor: Function) {
    registry.set(name, constructor);
  };
}

@Injectable('httpService')
class HttpService {
  get(url: string) {
    return `GET ${url}`;
  }
}

// HttpService теперь зарегистрирован в registry
```

### 2. Валидация конфигурации

```typescript
function Configurable(options: { enabled: boolean }) {
  return function (constructor: Function) {
    constructor.prototype.config = options;
  };
}

@Configurable({ enabled: true })
class DatabaseConnection {
  connect() {
    if (this.config.enabled) {
      console.log('Соединение установлено');
    } else {
      console.log('Соединение отключено');
    }
  }
}
```

### 3. Аутентификация и авторизация

```typescript
function Authorized(roles: string[]) {
  return function (constructor: Function) {
    constructor.prototype.requiredRoles = roles;
  };
}

@Authorized(['admin', 'moderator'])
class AdminPanel {
  showUsers() {
    console.log('Показ пользователей');
  }
}
```

## Совместимость с другими декораторами

Декораторы классов можно комбинировать с другими типами декораторов:

```typescript
function Singleton<T extends { new (...args: any[]): {} }>(constructor: T) {
  let instance: T;
  return class extends constructor {
    constructor(...args: any[]) {
      if (!instance) {
        super(...args);
        instance = this as any;
      }
      return instance;
    }
  };
}

@Singleton
class Logger {
  log(message: string) {
    console.log(`[LOG] ${message}`);
  }
}

const logger1 = new Logger();
const logger2 = new Logger();
console.log(logger1 === logger2); // true
```

## Важные замечания

> [!warning] Важно
> Декораторы классов не могут быть использованы в объявлении интерфейса, объявления типа, или в параметрах шаблона.

> [!note] Примечание
> При использовании декораторов классов, которые возвращают новый класс, могут возникнуть проблемы с инструментальной разработкой (IntelliSense) и отладкой.

## Заключение

[[Декораторы-классов]] предоставляют мощный способ модификации поведения классов во время их объявления. Они особенно полезны для реализации шаблонов проектирования, таких как Singleton, а также для внедрения зависимостей и регистрации компонентов.

Для изучения других типов декораторов см.:
- [[Введение-в-декораторы]]
- [[Декораторы-методов]]
- [[Декораторы-свойств]]
- [[Фабрики-декораторов]]