---
aliases: [Типизация моделей, Модели с типами, Типизированные модели]
tags: [typescript, database, models, typing]
---

# Типизация моделей в TypeScript для баз данных

## Введение

Типизация моделей данных является ключевым аспектом разработки надежных приложений с использованием TypeScript. Правильная типизация позволяет избежать ошибок на этапе компиляции, улучшает автодополнение в IDE и делает код более понятным для команды разработчиков.

## Основы типизации моделей

При работе с базами данных в TypeScript мы должны определить типы для:

- Сущностей базы данных (таблиц/коллекций)
- Входных данных (DTO - Data Transfer Objects)
- Возвращаемых данных
- Опциональных и обязательных полей

### Простая модель пользователя

```typescript
interface User {
  id: number;
  email: string;
  name: string;
  age?: number; // Необязательное поле
  createdAt: Date;
  updatedAt: Date;
}
```

### Модель с отношениями

```typescript
interface User {
  id: number;
  email: string;
  name: string;
  posts: Post[]; // Отношение один-ко-многим
}

interface Post {
  id: number;
  title: string;
  content: string;
  userId: number; // Внешний ключ
  user: User; // Отношение многие-к-одному
  tags: Tag[];
}
```

## Использование Omit и Pick для разных сценариев

### Создание сущности (без ID)

```typescript
type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Использование
const newUser: CreateUserInput = {
  email: 'john@example.com',
  name: 'John Doe',
  age: 30
};
```

### Обновление сущности (все поля опциональны)

```typescript
type UpdateUserInput = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;

// Использование
const updateData: UpdateUserInput = {
  name: 'John Smith',
  age: 31
  // email остается неизменным
};
```

### Ответ API (без чувствительных данных)

```typescript
type UserResponse = Omit<User, 'password'>;

// Использование
const userResponse: UserResponse = {
  id: 1,
  email: 'john@example.com',
  name: 'John Doe',
  createdAt: new Date(),
  updatedAt: new Date()
};
```

## Типизация для различных ORM

### Sequelize

```typescript
import { Model, DataTypes } from 'sequelize';

interface UserAttributes {
  id: number;
  email: string;
  name: string;
  age?: number;
  createdAt?: Date;
  updatedAt?: Date;
}

interface UserCreationAttributes extends Optional<UserAttributes, 'id' | 'createdAt' | 'updatedAt'> {}

class User extends Model<UserAttributes, UserCreationAttributes> implements UserAttributes {
  public id!: number;
  public email!: string;
  public name!: string;
  public age?: number;
  public createdAt!: Date;
  public updatedAt!: Date;

  // Методы ассоциаций будут определены здесь
}
```

### TypeORM

```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column()
  name: string;

  @Column({ nullable: true })
  age?: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

### Mongoose (MongoDB)

```typescript
import { Document, Schema, model } from 'mongoose';

interface IUser extends Document {
  email: string;
  name: string;
  age?: number;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema({
  email: { type: String, required: true, unique: true },
  name: { type: String, required: true },
  age: { type: Number, required: false },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export const User = model<IUser>('User', userSchema);
```

## Адаптация типов для различных операций

### Типы для валидации

```typescript
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100),
  age: z.number().min(0).max(150).optional()
});

type ValidatedUser = z.infer<typeof userSchema>;
```

### Типы для запросов с фильтрацией

```typescript
interface UserFilter {
  email?: string;
  age?: { $gte?: number; $lte?: number };
  name?: { $regex?: string; $options?: string };
}

interface UserQueryOptions {
  limit?: number;
  offset?: number;
  orderBy?: { field: keyof User; direction: 'ASC' | 'DESC' };
}
```

## Практические рекомендации

### 1. Используйте строгую типизацию для внешних ключей

```typescript
interface Post {
  id: number;
  title: string;
  userId: number; // Явно указываем тип внешнего ключа
  user: User;
}
```

### 2. Определяйте типы для различных слоев приложения

```typescript
// Типы для базы данных
interface UserDb {
  id: number;
  email: string;
  password_hash: string;
  created_at: Date;
  updated_at: Date;
}

// Типы для бизнес-логики
interface UserBusiness {
  id: number;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

// Типы для API
interface UserApi {
  id: number;
  email: string;
  name: string;
  createdAt: string; // Дата в формате ISO строка
}
```

### 3. Используйте branded types для дополнительной безопасности

```typescript
type Brand<T, B> = T & { __brand: B };

type Email = Brand<string, 'Email'>;
type UserId = Brand<number, 'UserId'>;

// Теперь нельзя случайно передать строку вместо email
const email: Email = 'user@example.com' as Email; // OK
const notEmail: Email = 123 as Email; // Ошибка компиляции
```

## Заключение

Правильная типизация моделей данных в TypeScript помогает создавать более надежные и поддерживаемые приложения. Она позволяет выявлять ошибки на этапе компиляции, улучшает автодополнение в IDE и делает код более понятным для других разработчиков.

Следующие темы, связанные с типизацией баз данных:
- [[ORM-с-TypeScript]]
- [[Запросы]]
- [[Транзакции]]
- [[Миграции]]

#typescript #database #models #typing #backend #development