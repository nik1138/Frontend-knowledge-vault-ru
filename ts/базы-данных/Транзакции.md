---
aliases: [Транзакции в базах данных, Database Transactions, Транзакции в TypeScript]
tags: [typescript, database, transactions, typeorm, sequelize, prisma, atomicity]
---

# Транзакции в TypeScript

## Введение

Транзакции - это фундаментальный концепт в работе с базами данных, обеспечивающий атомарность, согласованность, изолированность и устойчивость (ACID) операций. В TypeScript транзакции позволяют группировать несколько операций с базой данных в одну логическую единицу, которая либо выполняется полностью, либо откатывается целиком при возникновении ошибки.

## Принципы транзакций (ACID)

### 1. Атомарность (Atomicity)
Все операции внутри транзакции рассматриваются как одна неделимая операция. Либо все операции выполняются, либо ни одна не выполняется.

### 2. Согласованность (Consistency)
Транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние.

### 3. Изолированность (Isolation)
Выполнение транзакции изолировано от других транзакций. Результаты промежуточных операций внутри транзакции не видны другим транзакциям до завершения.

### 4. Устойчивость (Durability)
После завершения транзакции изменения сохраняются в базе данных навсегда, даже в случае сбоя системы.

## Транзакции в TypeORM

### Базовое использование транзакции

```typescript
import { getRepository, getConnection, QueryRunner } from 'typeorm';
import { User } from '../entity/User';
import { Profile } from '../entity/Profile';

// Метод 1: Использование transaction()
async function createUserWithProfile(userData: UserInput, profileData: ProfileInput) {
  const userRepo = getRepository(User);
  const profileRepo = getRepository(Profile);
  
  return await getConnection().transaction(async transactionalEntityManager => {
    // Создание пользователя
    const user = new User();
    user.email = userData.email;
    user.name = userData.name;
    
    const savedUser = await transactionalEntityManager.save(user);
    
    // Создание профиля пользователя
    const profile = new Profile();
    profile.userId = savedUser.id;
    profile.bio = profileData.bio;
    profile.location = profileData.location;
    
    const savedProfile = await transactionalEntityManager.save(profile);
    
    return { user: savedUser, profile: savedProfile };
  });
}
```

### Использование QueryRunner для более сложных сценариев

```typescript
async function complexUserOperation(userId: number, newEmail: string, newBio: string) {
  const connection = getConnection();
  const queryRunner = connection.createQueryRunner();
  
  await queryRunner.connect();
  await queryRunner.startTransaction();
  
  try {
    // Обновление пользователя
    await queryRunner.manager.update(User, userId, { email: newEmail });
    
    // Обновление профиля
    await queryRunner.manager.update(Profile, { userId }, { bio: newBio });
    
    // Логирование операции
    const log = new OperationLog();
    log.userId = userId;
    log.operation = 'USER_PROFILE_UPDATE';
    log.timestamp = new Date();
    
    await queryRunner.manager.save(log);
    
    await queryRunner.commitTransaction();
    console.log('Transaction committed successfully');
  } catch (error) {
    await queryRunner.rollbackTransaction();
    console.error('Transaction rolled back due to error:', error);
    throw error;
  } finally {
    await queryRunner.release();
  }
}
```

### Транзакции с различными уровнями изоляции

```typescript
import { IsolationLevel } from 'typeorm';

async function transferMoney(fromUserId: number, toUserId: number, amount: number) {
  return await getConnection().transaction(IsolationLevel.SERIALIZABLE, async manager => {
    // Получение счетов пользователей
    const fromAccount = await manager.findOne(Account, { userId: fromUserId });
    const toAccount = await manager.findOne(Account, { userId: toUserId });
    
    if (!fromAccount || !toAccount) {
      throw new Error('Accounts not found');
    }
    
    if (fromAccount.balance < amount) {
      throw new Error('Insufficient funds');
    }
    
    // Выполнение перевода
    fromAccount.balance -= amount;
    toAccount.balance += amount;
    
    await manager.save([fromAccount, toAccount]);
  });
}
```

## Транзакции в Sequelize

### Базовое использование транзакции

```typescript
import { Sequelize, Transaction } from 'sequelize';
import { User } from '../models/User';
import { Profile } from '../models/Profile';

// Простая транзакция
async function createUserWithProfile(userData: UserInput, profileData: ProfileInput) {
  const transaction = await sequelize.transaction();
  
  try {
    // Создание пользователя
    const user = await User.create({
      email: userData.email,
      name: userData.name
    }, { transaction });
    
    // Создание профиля
    const profile = await Profile.create({
      userId: user.id,
      bio: profileData.bio,
      location: profileData.location
    }, { transaction });
    
    await transaction.commit();
    return { user, profile };
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
```

### Использование async/await с транзакциями

```typescript
async function transferMoney(fromUserId: number, toUserId: number, amount: number) {
  return await sequelize.transaction(async (t: Transaction) => {
    // Получение счетов пользователей
    const fromAccount = await Account.findOne({
      where: { userId: fromUserId }
    }, { transaction: t });
    
    const toAccount = await Account.findOne({
      where: { userId: toUserId }
    }, { transaction: t });
    
    if (!fromAccount || !toAccount) {
      throw new Error('Accounts not found');
    }
    
    if (fromAccount.balance < amount) {
      throw new Error('Insufficient funds');
    }
    
    // Выполнение перевода
    await fromAccount.update({ balance: fromAccount.balance - amount }, { transaction: t });
    await toAccount.update({ balance: toAccount.balance + amount }, { transaction: t });
    
    // Логирование операции
    await OperationLog.create({
      userId: fromUserId,
      operation: 'MONEY_TRANSFER',
      amount: amount
    }, { transaction: t });
    
    return { fromAccount, toAccount };
  });
}
```

### Вложенные транзакции (Savepoints)

```typescript
async function complexOperation(userId: number) {
  return await sequelize.transaction(async (t: Transaction) => {
    // Основная операция
    const user = await User.findByPk(userId, { transaction: t });
    
    // Создание savepoint
    const savepoint = await t.savepoint();
    
    try {
      // Выполнение операции, которая может не удастся
      await SomeModel.create({ userId, data: 'critical' }, { transaction: t });
      
      // Если все хорошо, продолжаем
      await AnotherModel.create({ userId, data: 'additional' }, { transaction: t });
    } catch (error) {
      // Откат к savepoint, если критическая операция не удалась
      await savepoint.rollback();
      // Выполнение альтернативной операции
      await AlternativeModel.create({ userId, data: 'fallback' }, { transaction: t });
    }
    
    // Остальные операции
    await User.update({ lastOperation: new Date() }, { 
      where: { id: userId }, 
      transaction: t 
    });
  });
}
```

## Транзакции в Prisma

### Базовое использование транзакции

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function createUserWithProfile(userData: UserInput, profileData: ProfileInput) {
  return await prisma.$transaction(async (tx) => {
    // Создание пользователя
    const user = await tx.user.create({
      data: {
        email: userData.email,
        name: userData.name
      }
    });
    
    // Создание профиля
    const profile = await tx.profile.create({
      data: {
        userId: user.id,
        bio: profileData.bio,
        location: profileData.location
      }
    });
    
    return { user, profile };
  });
}
```

### Транзакции с несколькими операциями

```typescript
async function transferMoney(fromUserId: number, toUserId: number, amount: number) {
  return await prisma.$transaction(async (tx) => {
    // Получение счетов пользователей
    const fromAccount = await tx.account.findUnique({
      where: { userId: fromUserId }
    });
    
    const toAccount = await tx.account.findUnique({
      where: { userId: toUserId }
    });
    
    if (!fromAccount || !toAccount) {
      throw new Error('Accounts not found');
    }
    
    if (fromAccount.balance < amount) {
      throw new Error('Insufficient funds');
    }
    
    // Выполнение перевода
    await tx.account.update({
      where: { userId: fromUserId },
      data: { balance: { decrement: amount } }
    });
    
    await tx.account.update({
      where: { userId: toUserId },
      data: { balance: { increment: amount } }
    });
    
    // Логирование операции
    await tx.operationLog.create({
      data: {
        userId: fromUserId,
        operation: 'MONEY_TRANSFER',
        amount: amount
      }
    });
    
    return { fromAccount, toAccount };
  });
}
```

### Управление изоляцией транзакций в Prisma

```typescript
// Prisma использует уровень изоляции по умолчанию, определяемый базой данных
// Но можно управлять транзакциями с дополнительными опциями
async function complexTransaction() {
  return await prisma.$transaction(
    async (tx) => {
      // Операции внутри транзакции
      const user = await tx.user.findFirst({
        where: { email: 'user@example.com' },
        // Для предотвращения гонок, можно использовать уникальные блокировки
        // (зависит от базы данных)
      });
      
      if (!user) {
        throw new Error('User not found');
      }
      
      // Дополнительные операции
      return await tx.user.update({
        where: { id: user.id },
        data: { lastLogin: new Date() }
      });
    },
    {
      // Опции транзакции
      maxWait: 5000, // Максимальное время ожидания блокировки (в мс)
      timeout: 10000, // Таймаут всей транзакции (в мс)
    }
  );
}
```

## Практические примеры использования транзакций

### 1. Финансовые операции

```typescript
interface TransferInput {
  fromAccountId: number;
  toAccountId: number;
  amount: number;
  description: string;
}

async function performTransfer(input: TransferInput) {
  return await getConnection().transaction(async manager => {
    // Блокировка счетов для предотвращения конкурентных операций
    const fromAccount = await manager.findOne(Account, {
      where: { id: input.fromAccountId },
      lock: { mode: 'pessimistic_write' } // Пессимистическая блокировка
    });
    
    if (!fromAccount || fromAccount.balance < input.amount) {
      throw new Error('Insufficient funds or account not found');
    }
    
    const toAccount = await manager.findOne(Account, {
      where: { id: input.toAccountId },
      lock: { mode: 'pessimistic_write' }
    });
    
    if (!toAccount) {
      throw new Error('Destination account not found');
    }
    
    // Выполнение перевода
    fromAccount.balance -= input.amount;
    toAccount.balance += input.amount;
    
    await manager.save([fromAccount, toAccount]);
    
    // Создание записи о переводе
    const transfer = new Transfer();
    transfer.fromAccountId = input.fromAccountId;
    transfer.toAccountId = input.toAccountId;
    transfer.amount = input.amount;
    transfer.description = input.description;
    transfer.timestamp = new Date();
    
    await manager.save(transfer);
    
    return { fromAccount, toAccount, transfer };
  });
}
```

### 2. Создание заказа с позициями

```typescript
interface CreateOrderInput {
  userId: number;
  items: { productId: number; quantity: number }[];
}

async function createOrder(input: CreateOrderInput) {
  return await getConnection().transaction(async manager => {
    // Создание заказа
    const order = new Order();
    order.userId = input.userId;
    order.status = 'PENDING';
    order.createdAt = new Date();
    
    const savedOrder = await manager.save(order);
    
    let totalAmount = 0;
    
    // Обработка позиций заказа
    const orderItems = [];
    
    for (const item of input.items) {
      // Получение информации о продукте
      const product = await manager.findOne(Product, {
        where: { id: item.productId },
        lock: { mode: 'pessimistic_write' }
      });
      
      if (!product) {
        throw new Error(`Product with ID ${item.productId} not found`);
      }
      
      if (product.stock < item.quantity) {
        throw new Error(`Insufficient stock for product ${item.productId}`);
      }
      
      // Обновление остатка
      product.stock -= item.quantity;
      await manager.save(product);
      
      // Создание позиции заказа
      const orderItem = new OrderItem();
      orderItem.orderId = savedOrder.id;
      orderItem.productId = item.productId;
      orderItem.quantity = item.quantity;
      orderItem.price = product.price;
      
      orderItems.push(orderItem);
      totalAmount += product.price * item.quantity;
    }
    
    // Сохранение позиций заказа
    await manager.save(orderItems);
    
    // Обновление общей суммы заказа
    savedOrder.totalAmount = totalAmount;
    savedOrder.status = 'CONFIRMED';
    
    await manager.save(savedOrder);
    
    return savedOrder;
  });
}
```

## Лучшие практики работы с транзакциями

### 1. Минимизация продолжительности транзакций

```typescript
// Плохо - долгая транзакция
async function badExample() {
  return await getConnection().transaction(async manager => {
    const users = await manager.find(User); // Загрузка большого количества данных
    
    // Долгие вычисления вне базы данных
    const processedData = heavyComputation(users);
    
    // Только потом операции с базой данных
    await manager.save(processedData);
  });
}

// Хорошо - короткая транзакция
async function goodExample() {
  const users = await getRepository(User).find(); // Вне транзакции
  
  // Вычисления вне транзакции
  const processedData = heavyComputation(users);
  
  // Короткая транзакция только для сохранения
  return await getConnection().transaction(async manager => {
    return await manager.save(processedData);
  });
}
```

### 2. Обработка ошибок

```typescript
async function safeTransaction() {
  try {
    return await getConnection().transaction(async manager => {
      // Операции в транзакции
      const result = await performDatabaseOperations(manager);
      return result;
    });
  } catch (error) {
    // Логирование ошибки
    console.error('Transaction failed:', error);
    
    // Проверка типа ошибки и выполнение соответствующих действий
    if (error.code === '23505') { // Ошибка уникального ограничения
      throw new Error('Duplicate entry detected');
    }
    
    throw error; // Перебрасываем ошибку дальше
  }
}
```

### 3. Использование подходящих уровней изоляции

```typescript
// Для финансовых операций - SERIALIZABLE
async function financialOperation() {
  return await getConnection().transaction(IsolationLevel.SERIALIZABLE, async manager => {
    // Финансовые операции требуют высокого уровня изоляции
  });
}

// Для операций чтения - READ_COMMITTED (по умолчанию)
async function readOperation() {
  return await getConnection().transaction(IsolationLevel.READ_COMMITTED, async manager => {
    // Операции чтения
  });
}
```

## Заключение

Транзакции являются важным инструментом для обеспечения целостности данных в приложениях TypeScript. Правильное использование транзакций позволяет избежать проблем с согласованностью данных и обеспечивает надежность приложений.

Следующие темы, связанные с транзакциями:
- [[ORM-с-TypeScript]]
- [[Запросы]]
- [[Миграции]]
- [[Типизация-моделей]]

#typescript #database #transactions #acid #typeorm #sequelize #prisma #backend #development