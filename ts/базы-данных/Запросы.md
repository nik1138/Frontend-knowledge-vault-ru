---
aliases: [Запросы к базе данных, SQL запросы в TypeScript, Database Queries]
tags: [typescript, database, queries, sql, typeorm, sequelize, prisma]
---

# Запросы к базе данных в TypeScript

## Введение

Запросы к базе данных являются основным способом взаимодействия приложения с данными. В TypeScript запросы могут быть типизированы, что обеспечивает безопасность типов и улучшает автодополнение в IDE. В этой статье мы рассмотрим различные подходы к выполнению запросов в TypeScript с использованием популярных ORM и библиотек.

## Типы запросов

### 1. CRUD операции

- **Create** - создание новых записей
- **Read** - чтение данных
- **Update** - обновление существующих записей
- **Delete** - удаление записей

### 2. Сложные запросы

- **JOIN** - объединение таблиц
- **Агрегации** - GROUP BY, COUNT, SUM и т.д.
- **Подзапросы** - вложенные запросы
- **Пагинация** - постраничный вывод данных

## Запросы в TypeORM

### Простые CRUD операции

```typescript
import { Repository, getRepository } from 'typeorm';
import { User } from '../entity/User';

// Получение репозитория
const userRepository = getRepository(User);

// Создание записи
const newUser = new User();
newUser.email = 'john@example.com';
newUser.name = 'John Doe';
newUser.age = 30;

const savedUser = await userRepository.save(newUser);

// Чтение записей
const users = await userRepository.find({
  where: {
    age: 30
  },
  order: {
    createdAt: 'DESC'
  },
  take: 10 // Ограничение количества результатов
});

// Поиск по ID
const user = await userRepository.findOne(1);

// Обновление записи
await userRepository.update(1, { name: 'John Smith' });

// Удаление записи
await userRepository.delete(1);
```

### Запросы с JOIN

```typescript
// С использованием relations
const usersWithPosts = await userRepository.find({
  relations: ['posts'],
  where: {
    age: 30
  }
});

// С использованием QueryBuilder
const usersWithPostCount = await getRepository(User)
  .createQueryBuilder('user')
  .leftJoinAndSelect('user.posts', 'post')
  .addSelect('COUNT(post.id)', 'postCount')
  .groupBy('user.id')
  .having('COUNT(post.id) > :minPosts', { minPosts: 2 })
  .getMany();
```

### Агрегационные запросы

```typescript
// Подсчет записей
const userCount = await userRepository.count({
  where: {
    age: MoreThan(18)
  }
});

// Сумма, среднее, максимум, минимум
const result = await getRepository(User)
  .createQueryBuilder('user')
  .select('AVG(user.age)', 'averageAge')
  .addSelect('MAX(user.age)', 'maxAge')
  .addSelect('MIN(user.age)', 'minAge')
  .getRawOne();

console.log(result.averageAge, result.maxAge, result.minAge);
```

### Пагинация

```typescript
interface PaginationOptions {
  page: number;
  limit: number;
}

async function getUsersWithPagination(options: PaginationOptions) {
  const { page, limit } = options;
  const offset = (page - 1) * limit;
  
  const [users, total] = await userRepository.findAndCount({
    skip: offset,
    take: limit,
    order: {
      createdAt: 'DESC'
    }
  });
  
  return {
    data: users,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit)
  };
}
```

## Запросы в Sequelize

### Простые CRUD операции

```typescript
import { Op } from 'sequelize';
import { User } from '../models/User';

// Создание записи
const newUser = await User.create({
  email: 'john@example.com',
  name: 'John Doe',
  age: 30
});

// Чтение записей
const users = await User.findAll({
  where: {
    age: {
      [Op.gt]: 18
    }
  },
  order: [
    ['createdAt', 'DESC']
  ],
  limit: 10
});

// Поиск по ID
const user = await User.findByPk(1, {
  include: ['posts'] // Загрузка связанных данных
});

// Обновление записи
await User.update(
  { name: 'John Smith' },
  { where: { id: 1 } }
);

// Удаление записи
await User.destroy({
  where: { id: 1 }
});
```

### Запросы с JOIN

```typescript
// С использованием include
const usersWithPosts = await User.findAll({
  include: [{
    model: Post,
    as: 'posts',
    attributes: ['id', 'title', 'content']
  }]
});

// С использованием агрегации
const usersWithPostCount = await User.findAll({
  attributes: [
    'id',
    'name',
    [sequelize.fn('COUNT', sequelize.col('posts.id')), 'postCount']
  ],
  include: [{
    model: Post,
    as: 'posts',
    attributes: []
  }],
  group: ['User.id'],
  having: sequelize.where(sequelize.fn('COUNT', sequelize.col('posts.id')), { [Op.gt]: 2 })
});
```

### Raw SQL запросы

```typescript
// Выполнение сырого SQL запроса
const [results, metadata] = await sequelize.query(
  'SELECT u.name, COUNT(p.id) as postCount FROM users u LEFT JOIN posts p ON u.id = p.user_id GROUP BY u.id',
  { type: QueryTypes.SELECT }
);
```

## Запросы в Prisma

### Простые CRUD операции

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Создание записи
const newUser = await prisma.user.create({
  data: {
    email: 'john@example.com',
    name: 'John Doe',
    age: 30,
  },
});

// Чтение записей
const users = await prisma.user.findMany({
  where: {
    age: {
      gt: 18,
    },
  },
  orderBy: {
    createdAt: 'desc',
  },
  take: 10,
});

// Поиск по ID
const user = await prisma.user.findUnique({
  where: { id: 1 },
  include: { posts: true }, // Загрузка связанных данных
});

// Обновление записи
const updatedUser = await prisma.user.update({
  where: { id: 1 },
  data: { name: 'John Smith' },
});

// Удаление записи
const deletedUser = await prisma.user.delete({
  where: { id: 1 },
});
```

### Сложные запросы с отношениями

```typescript
// Запрос с фильтрацией связанных данных
const usersWithRecentPosts = await prisma.user.findMany({
  include: {
    posts: {
      where: {
        createdAt: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // За последние 7 дней
        },
      },
    },
  },
});

// Запрос с агрегацией
const usersWithPostCount = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    _count: {
      select: {
        posts: true,
      },
    },
  },
});
```

### Пагинация в Prisma

```typescript
interface PaginationOptions {
  page: number;
  limit: number;
}

async function getUsersWithPagination(options: PaginationOptions) {
  const { page, limit } = options;
  const skip = (page - 1) * limit;
  
  const [users, total] = await prisma.$transaction([
    prisma.user.findMany({
      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc',
      },
    }),
    prisma.user.count(),
  ]);
  
  return {
    data: users,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit)
  };
}
```

## Типизированные запросы

### Создание типизированных запросов

```typescript
// Тип для результата запроса
interface UserWithPostCount {
  id: number;
  name: string;
  email: string;
  postCount: number;
}

// Запрос с явной типизацией результата
async function getUsersWithPostCount(): Promise<UserWithPostCount[]> {
  const result = await getRepository(User)
    .createQueryBuilder('user')
    .select(['user.id', 'user.name', 'user.email'])
    .addSelect('COUNT(post.id)', 'postCount')
    .leftJoin('user.posts', 'post')
    .groupBy('user.id')
    .getRawMany<UserWithPostCount>();
    
  return result;
}
```

### Использование DTO для запросов

```typescript
interface UserFilter {
  email?: string;
  minAge?: number;
  maxAge?: number;
  name?: string;
}

interface UserQueryOptions {
  limit?: number;
  offset?: number;
  orderBy?: { field: keyof User; direction: 'ASC' | 'DESC' };
}

async function findUsers(
  filter: UserFilter,
  options?: UserQueryOptions
): Promise<User[]> {
  const queryBuilder = getRepository(User).createQueryBuilder('user');
  
  // Применение фильтров
  if (filter.email) {
    queryBuilder.andWhere('user.email = :email', { email: filter.email });
  }
  
  if (filter.minAge !== undefined) {
    queryBuilder.andWhere('user.age >= :minAge', { minAge: filter.minAge });
  }
  
  if (filter.maxAge !== undefined) {
    queryBuilder.andWhere('user.age <= :maxAge', { maxAge: filter.maxAge });
  }
  
  if (filter.name) {
    queryBuilder.andWhere('user.name LIKE :name', { name: `%${filter.name}%` });
  }
  
  // Применение опций
  if (options?.orderBy) {
    queryBuilder.orderBy(`user.${options.orderBy.field}`, options.orderBy.direction);
  }
  
  if (options?.limit) {
    queryBuilder.limit(options.limit);
  }
  
  if (options?.offset) {
    queryBuilder.offset(options.offset);
  }
  
  return await queryBuilder.getMany();
}
```

## Оптимизация запросов

### Избегание N+1 проблемы

```typescript
// Плохо - N+1 запросов
const users = await userRepository.find();
for (const user of users) {
  console.log(user.posts); // Каждый вызов posts приведет к отдельному запросу
}

// Хорошо - один запрос с JOIN
const users = await userRepository.find({
  relations: ['posts'] // Загружаем связанные данные в одном запросе
});
```

### Использование индексов

```typescript
// В TypeORM
@Entity()
@Index(['email']) // Создание индекса на поле email
@Index(['name', 'age']) // Создание составного индекса
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, index: true })
  email: string;

  @Column()
  name: string;

  @Column({ index: true })
  age: number;
}
```

### Оптимизация SELECT

```typescript
// Выбор только необходимых полей
const users = await getRepository(User).find({
  select: ['id', 'name', 'email'], // Выбираем только нужные поля
  where: {
    age: MoreThan(18)
  }
});
```

## Обработка ошибок запросов

```typescript
import { EntityNotFoundError } from 'typeorm';

async function getUserById(id: number): Promise<User | null> {
  try {
    const user = await userRepository.findOne(id);
    return user;
  } catch (error) {
    if (error instanceof EntityNotFoundError) {
      console.error('User not found:', id);
      return null;
    }
    
    console.error('Database error:', error);
    throw new Error('Failed to fetch user');
  }
}

// Обработка уникальных ограничений
async function createUser(userData: CreateUserInput): Promise<User> {
  try {
    const user = new User();
    Object.assign(user, userData);
    return await userRepository.save(user);
  } catch (error) {
    if (error.code === '23505') { // Код ошибки уникального ограничения в PostgreSQL
      throw new Error('User with this email already exists');
    }
    throw error;
  }
}
```

## Заключение

Запросы к базе данных в TypeScript обеспечивают безопасность типов и улучшают разработку благодаря автодополнению. Правильное использование ORM позволяет писать эффективные и читаемые запросы, избегая распространенных ошибок.

Следующие темы, связанные с запросами:
- [[ORM-с-TypeScript]]
- [[Типизация-моделей]]
- [[Миграции]]
- [[Транзакции]]

#typescript #database #queries #sql #typeorm #sequelize #prisma #backend #development