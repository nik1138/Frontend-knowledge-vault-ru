# shallowRef

## Определение
`shallowRef` - это функция в Composition API Vue 3, которая создает поверхностно реактивную ссылку. В отличие от `ref`, `shallowRef` не делает глубоко реактивным значение, хранящееся внутри, а реагирует только на изменение самого значения (замена на другой объект).

## Синтаксис
```javascript
import { shallowRef } from 'vue'

const ref = shallowRef(initialValue)
```

## Особенности
- Реактивно только изменение значения (не внутренних свойств)
- Вложенные объекты не становятся реактивными
- Лучшая производительность для больших/сложных объектов
- Полезно для хранения неизменяемых данных

## Примеры использования

### Сравнение с ref
```javascript
import { ref, shallowRef } from 'vue'

// Обычный ref: глубокая реактивность
const deepRef = ref({
  user: { name: 'John' }
})

// Изменение вложенного свойства вызывает реактивность
deepRef.value.user.name = 'Jane' // Реактивно


// shallowRef: поверхностная реактивность
const shallowRefValue = shallowRef({
  user: { name: 'John' }
})

// Изменение вложенного свойства НЕ вызывает реактивность
shallowRefValue.value.user.name = 'Jane' // Не реактивно!

// Но замена всего значения реактивна
shallowRefValue.value = { user: { name: 'Jane' } } // Реактивно
```

### Когда использовать
```javascript
import { shallowRef, onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    // Для хранения больших/сложных объектов
    const largeObject = shallowRef(null)
    
    onMounted(async () => {
      // Загрузка большого объекта данных
      largeObject.value = await fetchLargeDataset()
      // Изменения внутри объекта не вызывают реактивности,
      // что экономит производительность
    })
    
    return { largeObject }
  }
}
```

### С валидацией изменений
```javascript
import { shallowRef } from 'vue'

export default {
  setup() {
    const state = shallowRef({ items: [] })
    
    const updateState = (newData) => {
      // Проверяем, действительно ли данные отличаются перед обновлением
      if (newData !== state.value) {
        state.value = newData
      }
    }
    
    return { state, updateState }
  }
}
```

## Преимущества
- Лучшая производительность для больших объектов
- Избегает "оверхеда" глубокой реактивности
- Подходит для неизменяемых данных
- Удобен для хранения DOM элементов или внешних объектов

## Недостатки
- Не реагирует на изменения внутренних свойств
- Требует осторожного обращения с вложенными объектами

## Связь с другими концепциями
- [[ref]] - глубокая реактивность
- [[shallowReactive]] - поверхностная реактивность для объектов
- [[triggerRef]] - принудительное обновление shallowRef
- [[customRef]] - пользовательские ref'ы

## Практические применения
- Хранение DOM элементов
- Кэширование сложных/больших объектов данных
- Работа с внешними библиотеками, объектами которых не нужно делать реактивными
- Случаи, когда изменение значения происходит полностью (не частично)

## triggerRef
Для принудительного обновления компонентов при использовании shallowRef:

```javascript
import { shallowRef, triggerRef } from 'vue'

const state = shallowRef({ count: 1, data: [] })

// Ручное обновление после изменения внутренних данных
state.value.data.push(1)
triggerRef(state) // Принудительно вызывает обновление
```

## Примечания
- Используйте когда не нужно отслеживать изменение внутренних свойств
- Подходит для оптимизации производительности
- Часто используется с triggerRef для обновления при внутренних изменениях