# Связи между концепциями реактивности

## Основные связи

### ref ↔ reactive
- Оба создают реактивные значения
- `ref` для примитивов и объектов (фактически используется reactive, но возвращает его через value)
- `reactive` только для объектов (с глубокой реактивностью)
- `ref` требует `.value` для доступа, `reactive` - нет

### computed ↔ watch
- Оба реагируют на изменения реактивных значений
- `computed` создает производное значение с кэшированием
- `watch` выполняет побочные эффекты при изменениях
- `computed` лениво вычисляет, `watch` активно отслеживает

### watch ↔ watchEffect
- Оба выполняют побочные эффекты
- `watch` требует явного указания источника
- `watchEffect` автоматически отслеживает зависимости
- `watchEffect` запускается сразу, `watch` - только при изменении

## Вспомогательные функции

### toRefs ↔ toRef
- Оба преобразуют реактивные значения в refs
- `toRefs` преобразует все свойства объекта
- `toRef` преобразует одно свойство объекта

### shallowReactive ↔ shallowRef
- Оба обеспечивают поверхностную реактивность
- `shallowReactive` для объектов (без `.value`)
- `shallowRef` для ссылок (с `.value`)

## Схема преобразований

```
┌─────────────┐  toRefs  ┌─────────────┐
│  reactive   │───────►│     ref     │
│   object    │        │   array     │
└─────────────┘        └─────────────┘
       ▲                       │
       │                       ▼
       │                  ┌─────────────┐
       └───── toRef ──────┤   single    │
                         │    ref      │
                         └─────────────┘
```

## Рекомендации по использованию

### Для локального состояния:
- Примитивы → `ref`
- Объекты (глубокая реактивность) → `ref` можно `reactive` но удобнее по факту везде ref
- Объекты (поверхностная реактивность) → `shallowReactive`

### Для производных значений:
- С кэшированием → `computed`
- С побочными эффектами → `watchEffect` / `watch`

### Для взаимодействия с внешними системами:
- Большие объекты → `shallowRef`
- DOM элементы → `shallowRef`
- Внешние объекты → `shallowRef`

### Для передачи данных:
- Весь объект →  `ref\reactive` + `toRefs`
- Отдельные свойства → `toRef`
- Деструктуризация → `toRefs`

## Частые паттерны

1. Создание состояния: `ref`/`reactive` в `setup()`
2. Производные значения: `computed`
3. Побочные эффекты: `watch`/`watchEffect`
4. Возвращение из `setup()`: `toRefs` для сохранения реактивности
5. Оптимизация: `shallowRef`/`shallowReactive` для производительности