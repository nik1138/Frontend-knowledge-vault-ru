---
aliases: [Built-in Transitions in Vue, Встроенные переходы в Vue]
tags: [vue, transitions, animation, frontend]
---

# Встроенные переходы в Vue.js

## Обзор

Встроенные переходы в Vue.js позволяют анимировать появление, исчезновение и изменение элементов и компонентов без необходимости подключения внешних библиотек. Vue предоставляет компоненты `<transition>` и `<transition-group>`, которые автоматически применяют CSS-классы во время анимационных процессов.

## Компонент `<transition>`

Компонент `<transition>` используется для анимации одиночных элементов или компонентов при их появлении или исчезновении.

### Простой пример

```vue
<template>
  <div>
    <button @click="show = !show">Переключить</button>
    <transition name="fade">
      <p v-if="show">Привет, встроенные переходы!</p>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: true
    }
  }
}
</script>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.5s;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}
</style>
```

## CSS-классы переходов

Vue автоматически добавляет следующие CSS-классы во время переходов:

- `v-enter-from` - начальное состояние для появления
- `v-enter-active` - активное состояние для появления
- `v-enter-to` - конечное состояние для появления
- `v-leave-from` - начальное состояние для исчезновения
- `v-leave-active` - активное состояние для исчезновения
- `v-leave-to` - конечное состояние для исчезновения

При использовании именованных переходов (например, `name="my-transition"`), классы будут иметь префикс имени: `my-transition-enter-from` и т.д.

## Типы переходов

### Переходы появления

Для анимации при первом рендеринге компонента используйте атрибут `appear`:

```vue
<transition name="fade" appear>
  <p>Этот элемент будет анимирован при первом рендеринге</p>
</transition>
```

### Переходы между элементами

Для анимации переключения между элементами используйте `mode`:

```vue
<template>
  <div>
    <button @click="toggle">Переключить</button>
    <transition name="cross-fade" mode="out-in">
      <component :is="currentView" class="view"></component>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      currentView: 'Home'
    }
  },
  methods: {
    toggle() {
      this.currentView = this.currentView === 'Home' ? 'About' : 'Home'
    }
  },
  components: {
    Home: { template: '<div>Главная страница</div>' },
    About: { template: '<div>О нас</div>' }
  }
}
</script>

<style>
.cross-fade-enter-active {
  transition: all 0.3s ease;
}
.cross-fade-leave-active {
  transition: all 0.3s cubic-bezier(1, 0.5, 0.8, 1);
}
.cross-fade-enter-from {
  opacity: 0;
  transform: translateX(30px);
}
.cross-fade-leave-to {
  opacity: 0;
  transform: translateX(-30px);
}
</style>
```

## Компонент `<transition-group>`

Компонент `<transition-group>` используется для анимации списков элементов. В отличие от `<transition>`, он рендерит реальный элемент DOM (по умолчанию `<span>`), который можно настроить с помощью атрибута `tag`.

### Пример анимации списка

```vue
<template>
  <div>
    <button @click="addItem">Добавить элемент</button>
    <transition-group name="list" tag="ul" class="list-container">
      <li v-for="item in items" :key="item.id" class="list-item">
        {{ item.text }}
        <button @click="removeItem(item.id)">Удалить</button>
      </li>
    </transition-group>
  </div>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { id: 1, text: 'Элемент 1' },
        { id: 2, text: 'Элемент 2' },
        { id: 3, text: 'Элемент 3' }
      ],
      nextId: 4
    }
  },
  methods: {
    addItem() {
      this.items.push({ id: this.nextId++, text: `Элемент ${this.nextId - 1}` })
    },
    removeItem(id) {
      this.items = this.items.filter(item => item.id !== id)
    }
  }
}
</script>

<style>
.list-container {
  position: relative;
  overflow: hidden;
}

.list-item {
  display: block;
  margin-right: 10px;
}

.list-enter-active, .list-leave-active {
  transition: all 1s ease;
}
.list-enter-from {
  opacity: 0;
  transform: translateX(30px);
}
.list-leave-to {
  opacity: 0;
  transform: translateX(-30px);
  position: absolute;
}
.list-move {
  transition: transform 1s;
}
</style>
```

## JavaScript-хуки переходов

В дополнение к CSS-анимациям, можно использовать JavaScript-хуки для выполнения кода в определенные моменты перехода:

```vue
<template>
  <div>
    <button @click="show = !show">Переключить</button>
    <transition
      @before-enter="beforeEnter"
      @enter="enter"
      @leave="leave"
      :css="false"
    >
      <p v-if="show">JavaScript-переходы!</p>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: true
    }
  },
  methods: {
    beforeEnter(el) {
      el.style.opacity = 0
      el.style.transform = 'translateX(-30px)'
    },
    enter(el, done) {
      // Анимация с использованием CSS
      el.style.transition = 'all 0.5s ease'
      el.style.opacity = 1
      el.style.transform = 'translateX(0)'
      
      // Завершаем переход после анимации
      el.addEventListener('transitionend', done)
    },
    leave(el, done) {
      el.style.transition = 'all 0.5s ease'
      el.style.opacity = 0
      el.style.transform = 'translateX(30px)'
      
      el.addEventListener('transitionend', done)
    }
  }
}
</script>
```

## Совместимость с российскими реалиями 2025

В 2025 году при использовании встроенных переходов в Vue.js в российских условиях важно учитывать:

1. **Производительность на слабых устройствах** - простые CSS-переходы более предпочтительны, чем сложные JavaScript-анимации
2. **Скорость интернета** - легковесные решения без внешних зависимостей
3. **Доступность** - поддержка системной настройки `prefers-reduced-motion`
4. **Совместимость с отечественными браузерами** - все основные переходы должны корректно работать в Яндекс.Браузере, KukuRuzo и других

### Учет предпочтений пользователя

```vue
<template>
  <transition 
    :name="animationName" 
    :appear="!reducedMotion"
  >
    <div>Анимированный элемент</div>
  </transition>
</template>

<script>
export default {
  data() {
    return {
      reducedMotion: false
    }
  },
  computed: {
    animationName() {
      return this.reducedMotion ? 'no-animation' : 'fade'
    }
  },
  mounted() {
    // Проверяем системные настройки пользователя
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')
      this.reducedMotion = mediaQuery.matches
      
      // Следим за изменениями настроек
      mediaQuery.addEventListener('change', (e) => {
        this.reducedMotion = e.matches
      })
    }
  }
}
</script>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.5s;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

.no-animation-enter-active, .no-animation-leave-active {
  transition: none;
}
.no-animation-enter-from, .no-animation-leave-to {
  opacity: 1;
}
</style>
```

## Расширенные возможности

### Анимация при перемещении элементов

При использовании `<transition-group>` можно анимировать перемещение элементов с помощью CSS-класса `v-move`:

```css
.list-move {
  transition: transform 1s;
}
```

### Использование атрибута `duration`

Для точного контроля времени перехода можно использовать атрибут `duration`:

```vue
<transition 
  name="fade" 
  :duration="{ enter: 300, leave: 800 }"
>
  <p v-if="show">Элемент с разной продолжительностью анимации</p>
</transition>
```

## Лучшие практики

1. Используйте встроенные переходы для простых анимаций вместо внешних библиотек
2. Учитывайте предпочтения пользователя на анимации
3. Тестируйте производительность на слабых устройствах
4. Используйте `transform` и `opacity` для лучшей производительности
5. Не забывайте про доступность и семантику

## Связанные темы

- [[CSS-анимации]]
- [[JavaScript-анимации]]
- [[Библиотеки-анимаций]]
- [[Пользовательские-анимации]]

## Заключение

Встроенные переходы в Vue.js предоставляют мощный и гибкий способ анимирования элементов без необходимости подключения внешних библиотек. Они идеально подходят для большинства сценариев анимации интерфейсов и особенно полезны в условиях, когда важна производительность и отсутствие внешних зависимостей, что актуально для российских реалий 2025 года.