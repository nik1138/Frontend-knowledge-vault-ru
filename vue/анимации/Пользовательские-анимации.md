---
aliases: [Custom Animations in Vue, Пользовательские анимации в Vue]
tags: [vue, animation, custom, frontend]
---

# Пользовательские анимации в Vue.js

## Обзор

Пользовательские анимации в Vue.js позволяют создавать уникальные анимационные эффекты, специфичные для конкретного приложения. Они могут сочетать в себе CSS-анимации, JavaScript-анимации и сторонние библиотеки для достижения желаемого результата.

## Создание пользовательских анимаций

### Комбинация CSS и JavaScript

Пользовательские анимации часто создаются с использованием как CSS, так и JavaScript для максимальной гибкости:

```vue
<template>
  <div>
    <button @click="triggerCustomAnimation">Запустить анимацию</button>
    <div 
      ref="customAnimatedElement" 
      class="custom-animated-element"
      :class="{ 'animated': isAnimated }"
    >
      Пользовательская анимация
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isAnimated: false
    }
  },
  methods: {
    triggerCustomAnimation() {
      // Сбрасываем класс анимации
      this.isAnimated = false
      
      // Дожидаемся следующего цикла рендеринга
      this.$nextTick(() => {
        // Запускаем анимацию
        this.isAnimated = true
        
        // Сбрасываем состояние после завершения анимации
        setTimeout(() => {
          this.isAnimated = false
        }, 2000)
      })
    }
  }
}
</script>

<style>
.custom-animated-element {
  width: 100px;
  height: 100px;
  background-color: #42b983;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  margin: 20px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.custom-animated-element.animated {
  animation: customAnimation 2s ease-in-out;
}

@keyframes customAnimation {
  0% {
    transform: scale(1) rotate(0deg);
    background-color: #42b983;
  }
  25% {
    transform: scale(1.2) rotate(90deg);
    background-color: #FFF;
  }
  50% {
    transform: scale(0.8) rotate(180deg);
    background-color: #f8f8f8;
  }
  75% {
    transform: scale(1.1) rotate(270deg);
    background-color: #e0e0e0;
  }
  100% {
    transform: scale(1) rotate(360deg);
    background-color: #42b983;
  }
}
</style>
```

### Анимации с использованием Composition API

```vue
<template>
  <div>
    <button @click="animateElement">Анимировать элемент</button>
    <div ref="elementRef" class="box">Composition API Анимация</div>
  </div>
</template>

<script>
import { ref, onMounted } from 'vue'
import anime from 'animejs'

export default {
  setup() {
    const elementRef = ref(null)
    
    const animateElement = () => {
      anime({
        targets: elementRef.value,
        translateX: 250,
        rotate: 180,
        borderRadius: ['0%', '50%'],
        backgroundColor: '#FFF',
        duration: 2000,
        direction: 'alternate',
        loop: true,
        complete: () => {
          console.log('Анимация завершена')
        }
      })
    }
    
    return {
      elementRef,
      animateElement
    }
  }
}
</script>

<style>
.box {
  width: 100px;
  height: 100px;
  background-color: #42b983;
  margin: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
}
</style>
```

## Анимации на основе данных

Пользовательские анимации могут динамически изменяться на основе данных приложения:

```vue
<template>
  <div>
    <div class="controls">
      <label>
        Скорость: 
        <input type="range" v-model="speed" min="100" max="3000" />
        {{ speed }}ms
      </label>
      <label>
        <input type="checkbox" v-model="reverse" /> Реверс
      </label>
    </div>
    <div 
      ref="dataDrivenElement" 
      class="data-driven-element"
      :style="elementStyle"
    >
      Анимация на основе данных
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      speed: 1000,
      reverse: false,
      position: 0
    }
  },
  computed: {
    elementStyle() {
      const direction = this.reverse ? -1 : 1
      return {
        transform: `translateX(${this.position * direction}px)`,
        transition: `transform ${this.speed / 1000}s ease-in-out`
      }
    }
  },
  methods: {
    moveElement() {
      // Анимация позиции элемента на основе данных
      this.position = this.position === 0 ? 200 : 0
    }
  },
  mounted() {
    // Анимация при изменении данных
    setInterval(() => {
      this.moveElement()
    }, this.speed)
  }
}
</script>

<style>
.data-driven-element {
  width: 100px;
  height: 100px;
  background-color: #42b983;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  margin: 20px;
  border-radius: 8px;
}

.controls {
  margin: 20px;
}

.controls label {
  display: block;
  margin-bottom: 10px;
}
</style>
```

## Пользовательские анимации для специфичных сценариев

### Анимация загрузки данных

```vue
<template>
  <div class="loading-container">
    <div v-if="loading" class="loading-spinner">
      <div 
        v-for="n in 12" 
        :key="n" 
        class="spinner-line"
        :style="{ transform: `rotate(${n * 30}deg) translateY(-40%)` }"
      ></div>
    </div>
    <div v-else class="content" v-motion-slide-visible>
      <h2>Данные загружены!</h2>
      <p v-for="item in data" :key="item.id">{{ item.name }}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      loading: true,
      data: []
    }
  },
  mounted() {
    // Симуляция загрузки данных
    setTimeout(() => {
      this.data = [
        { id: 1, name: 'Элемент 1' },
        { id: 2, name: 'Элемент 2' },
        { id: 3, name: 'Элемент 3' }
      ]
      this.loading = false
    }, 3000)
  }
}
</script>

<style>
.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
}

.loading-spinner {
  position: relative;
  width: 50px;
  height: 50px;
}

.spinner-line {
  position: absolute;
  left: 43%;
  top: 40%;
  width: 6%;
  height: 20%;
  background: #42b983;
  border-radius: 50%;
  animation: spinner-line 1.2s cubic-bezier(0.65, 0, 0.35, 1) infinite;
}

@for $i from 1 through 12 {
  .spinner-line:nth-child(#{$i}) {
    animation-delay: -1.2s + (1.2s / 12) * $i;
  }
}

@keyframes spinner-line {
  0% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

.content {
  text-align: center;
}
</style>
```

### Анимация прогресса

```vue
<template>
  <div class="progress-container">
    <div class="progress-bar-container">
      <div 
        class="progress-bar" 
        :style="{ width: progress + '%' }"
        :class="{ completed: progress >= 100 }"
      >
        <span class="progress-text">{{ progress }}%</span>
      </div>
    </div>
    <button @click="startProgress" :disabled="progress > 0">Начать</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      progress: 0,
      progressInterval: null
    }
  },
  methods: {
    startProgress() {
      this.progress = 0
      this.progressInterval = setInterval(() => {
        this.progress += 1
        if (this.progress >= 100) {
          clearInterval(this.progressInterval)
        }
      }, 50)
    }
  },
  beforeUnmount() {
    if (this.progressInterval) {
      clearInterval(this.progressInterval)
    }
  }
}
</script>

<style>
.progress-container {
  padding: 20px;
}

.progress-bar-container {
  width: 100%;
  height: 30px;
  background-color: #f0f0f0;
  border-radius: 15px;
  overflow: hidden;
  margin-bottom: 10px;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #42b983, #2196f3);
  width: 0;
  transition: width 0.3s ease, background 0.3s ease;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
}

.progress-bar.completed {
  background: linear-gradient(90deg, #4caf50, #2e7d32);
}

.progress-text {
  font-size: 12px;
}
</style>
```

## Совместимость с российскими реалиями 2025

При создании пользовательских анимаций в 2025 году в российских условиях важно учитывать:

1. **Производительность на бюджетных устройствах** - оптимизация сложных анимаций
2. **Низкая пропускная способность интернета** - минимизация использования тяжелых библиотек
3. **Предпочтения пользователей** - учет системных настроек на анимации
4. **Совместимость с отечественными браузерами** - тестирование в Яндекс.Браузере, KukuRuzo и др.

### Оптимизация для слабых устройств

```javascript
// Определение слабого устройства
const isLowEndDevice = () => {
  return navigator.hardwareConcurrency <= 2 || 
         (navigator.deviceMemory && navigator.deviceMemory < 2)
}

// Упрощение анимаций на слабых устройствах
export default {
  computed: {
    animationDuration() {
      return isLowEndDevice() ? 300 : 600 // мс
    },
    animationQuality() {
      return isLowEndDevice() ? 'low' : 'high'
    }
  },
  methods: {
    runAnimation() {
      const config = {
        duration: this.animationDuration,
        easing: 'ease-out'
      }
      
      // Упрощенная анимация для слабых устройств
      if (this.animationQuality === 'low') {
        // Используем только transform и opacity
        Object.assign(config, {
          properties: ['transform', 'opacity']
        })
      }
      
      // Запуск анимации с оптимизацией
      this.$refs.animatedElement.animate([
        { transform: 'translateX(0)', opacity: 1 },
        { transform: 'translateX(200px)', opacity: 0.5 }
      ], config)
    }
  }
}
```

## Адаптивные анимации

Создание анимаций, которые адаптируются к различным условиям:

```vue
<template>
  <div class="adaptive-animation-container">
    <div 
      ref="adaptiveElement" 
      class="adaptive-element"
      :class="{ 'mobile-animation': isMobile }"
    >
      Адаптивная анимация
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isMobile: false
    }
  },
  mounted() {
    this.checkDevice()
    window.addEventListener('resize', this.checkDevice)
  },
  methods: {
    checkDevice() {
      // Определение мобильного устройства
      this.isMobile = window.innerWidth <= 768
    }
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.checkDevice)
  }
}
</script>

<style>
.adaptive-animation-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
}

.adaptive-element {
  width: 100px;
  height: 100px;
  background-color: #42b983;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  border-radius: 8px;
  animation: desktopAnimation 2s infinite;
}

.mobile-animation {
  animation: mobileAnimation 1.5s infinite;
}

@keyframes desktopAnimation {
  0% { transform: scale(1) rotate(0deg); }
  50% { transform: scale(1.2) rotate(180deg); }
  100% { transform: scale(1) rotate(360deg); }
}

@keyframes mobileAnimation {
  0% { transform: translateX(0); }
  50% { transform: translateX(50px); }
  100% { transform: translateX(0); }
}
</style>
```

## Лучшие практики

1. Используйте `transform` и `opacity` для более плавных анимаций
2. Избегайте анимации свойств, вызывающих reflow/repaint
3. Обеспечьте опции отключения анимаций для пользователей
4. Тестируйте производительность на слабых устройствах
5. Используйте аппаратное ускорение с `will-change` и `transform: translateZ(0)`

## Связанные темы

- [[CSS-анимации]]
- [[JavaScript-анимации]]
- [[Встроенные-переходы]]
- [[Библиотеки-анимаций]]

## Заключение

Пользовательские анимации в Vue.js позволяют создавать уникальные и эффективные интерактивные интерфейсы. При правильной реализации они могут значительно улучшить пользовательский опыт, особенно когда адаптированы под конкретные условия использования, такие как российские реалии 2025 года, включая производительность на бюджетных устройствах и предпочтения пользователей.