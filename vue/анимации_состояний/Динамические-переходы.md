---
aliases: [Динамические переходы, Динамический переход]
tags: [vue, animation, transition, dynamic, state]
---

# Динамические-переходы

## Обзор

Динамические переходы в Vue позволяют изменять параметры анимаций на основе состояния приложения или входных данных. Это дает возможность создавать более гибкие и адаптивные анимации, которые реагируют на изменения в приложении.

## Основные концепции

Динамические переходы позволяют изменять свойства анимаций (продолжительность, easing, направление и т.д.) во время выполнения приложения. Это достигается за счет привязки свойств переходов к переменным состояния или вычисляемым значениям.

## Динамические параметры переходов

В Vue можно изменять параметры переходов в зависимости от состояния:

```vue
<template>
  <div class="dynamic-transition-container">
    <h2>Динамические параметры переходов</h2>
    
    <div class="controls">
      <label>
        Продолжительность: 
        <input 
          type="range" 
          v-model.number="duration" 
          min="100" 
          max="2000" 
          step="100"
        >
        {{ duration }}ms
      </label>
      
      <label>
        Тип анимации:
        <select v-model="transitionType">
          <option value="fade">Затухание</option>
          <option value="slide">Скольжение</option>
          <option value="scale">Масштабирование</option>
        </select>
      </label>
    </div>
    
    <transition 
      :name="transitionType" 
      :duration="duration"
      mode="out-in"
    >
      <div v-if="showElement" key="visible" class="animated-box">
        Анимированный элемент
      </div>
      <div v-else key="hidden" class="animated-box hidden">
        Скрытый элемент
      </div>
    </transition>
    
    <button @click="toggleElement">Переключить элемент</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      showElement: true,
      duration: 500,
      transitionType: 'fade'
    }
  },
  methods: {
    toggleElement() {
      this.showElement = !this.showElement;
    }
  }
}
</script>

<style scoped>
.dynamic-transition-container {
  padding: 20px;
  text-align: center;
}

.controls {
  margin-bottom: 20px;
}

.controls label {
  display: block;
  margin-bottom: 10px;
}

.animated-box {
  width: 200px;
  height: 200px;
  background-color: #42b983;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  border-radius: 8px;
  margin: 20px auto;
  transition-property: opacity, transform;
}

.hidden {
  background-color: #e74c3c;
}

.fade-enter-active, .fade-leave-active {
  transition: opacity 0.5s;
}

.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

.slide-enter-active, .slide-leave-active {
  transition: all 0.5s;
}

.slide-enter-from {
  transform: translateX(-100%);
  opacity: 0;
}

.slide-leave-to {
  transform: translateX(100%);
  opacity: 0;
}

.scale-enter-active, .scale-leave-active {
  transition: all 0.5s;
}

.scale-enter-from, .scale-leave-to {
  transform: scale(0.8);
  opacity: 0;
}

button {
  padding: 10px 20px;
  background-color: #34495e;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #2c3e50;
}
</style>
```

## Динамические CSS-классы переходов

Можно динамически изменять CSS-классы переходов:

```vue
<template>
  <div class="dynamic-class-container">
    <h2>Динамические CSS-классы переходов</h2>
    
    <div class="controls">
      <label>
        Выберите стиль перехода:
        <select v-model="selectedTransition">
          <option value="bounce">Отскок</option>
          <option value="swing">Качание</option>
          <option value="pulse">Пульсация</option>
        </select>
      </label>
    </div>
    
    <transition 
      :enter-active-class="`${selectedTransition}-enter-active`"
      :leave-active-class="`${selectedTransition}-leave-active`"
      :enter-from-class="`${selectedTransition}-enter-from`"
      :leave-to-class="`${selectedTransition}-leave-to`"
    >
      <div v-if="showElement" class="animated-element">
        Динамический переход
      </div>
    </transition>
    
    <button @click="toggleElement">Переключить</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      showElement: true,
      selectedTransition: 'bounce'
    }
  },
  methods: {
    toggleElement() {
      this.showElement = !this.showElement;
    }
  }
}
</script>

<style scoped>
.dynamic-class-container {
  padding: 20px;
  text-align: center;
}

.controls {
  margin-bottom: 20px;
}

.animated-element {
  width: 200px;
  height: 200px;
  background-color: #3498db;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  border-radius: 8px;
  margin: 20px auto;
}

/* Анимация отскока */
.bounce-enter-active {
  animation: bounce-in 0.8s;
}

.bounce-leave-active {
  animation: bounce-in 0.8s reverse;
}

@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}

/* Анимация качания */
.swing-enter-active {
  animation: swing-in 0.5s;
}

.swing-leave-active {
  animation: swing-in 0.5s reverse;
}

@keyframes swing-in {
  0% {
    transform: translateX(-50px) rotate(-10deg);
    opacity: 0;
  }
  100% {
    transform: translateX(0) rotate(0);
    opacity: 1;
  }
}

/* Анимация пульсации */
.pulse-enter-active {
  animation: pulse 0.6s;
}

.pulse-leave-active {
  animation: pulse 0.6s reverse;
}

@keyframes pulse {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

button {
  padding: 10px 20px;
  background-color: #34495e;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #2c3e50;
}
</style>
```

## Динамические переходы с использованием JavaScript

Для более сложных анимаций можно использовать JavaScript с динамическими параметрами:

```vue
<template>
  <div class="js-dynamic-container">
    <h2>Динамические переходы с JavaScript</h2>
    
    <div class="controls">
      <label>
        Скорость анимации:
        <input 
          type="range" 
          v-model.number="speed" 
          min="1" 
          max="10" 
          step="0.5"
        >
        {{ speed }}x
      </label>
      
      <label>
        Тип анимации:
        <select v-model="animationType">
          <option value="spring">Пружина</option>
          <option value="bounce">Отскок</option>
          <option value="elastic">Эластичная</option>
        </select>
      </label>
    </div>
    
    <transition
      v-on:before-enter="beforeEnter"
      v-on:enter="enter"
      v-on:leave="leave"
      v-bind:css="false"
    >
      <div v-if="showElement" class="js-animated-element">
        JS Анимированный элемент
      </div>
    </transition>
    
    <button @click="toggleElement">Переключить</button>
  </div>
</template>

<script>
import { SpringTransition, BounceTransition, ElasticTransition } from './transitions';

export default {
  data() {
    return {
      showElement: true,
      speed: 2,
      animationType: 'spring'
    }
  },
  methods: {
    toggleElement() {
      this.showElement = !this.showElement;
    },
    beforeEnter(el) {
      el.style.opacity = 0;
      el.style.transform = 'scale(0.5)';
    },
    enter(el, done) {
      // Выбираем тип анимации в зависимости от состояния
      let animation;
      
      switch(this.animationType) {
        case 'spring':
          animation = new SpringTransition(el, this.speed);
          break;
        case 'bounce':
          animation = new BounceTransition(el, this.speed);
          break;
        case 'elastic':
          animation = new ElasticTransition(el, this.speed);
          break;
        default:
          animation = new SpringTransition(el, this.speed);
      }
      
      animation.animateIn(done);
    },
    leave(el, done) {
      // Выбираем тип анимации в зависимости от состояния
      let animation;
      
      switch(this.animationType) {
        case 'spring':
          animation = new SpringTransition(el, this.speed);
          break;
        case 'bounce':
          animation = new BounceTransition(el, this.speed);
          break;
        case 'elastic':
          animation = new ElasticTransition(el, this.speed);
          break;
        default:
          animation = new SpringTransition(el, this.speed);
      }
      
      animation.animateOut(done);
    }
  }
}

// Пример классов для различных типов анимаций
class BaseTransition {
  constructor(el, speed) {
    this.el = el;
    this.speed = speed || 1;
  }
  
  animateIn(done) {
    // Базовая реализация
    done();
  }
  
  animateOut(done) {
    // Базовая реализация
    done();
  }
}

class SpringTransition extends BaseTransition {
  animateIn(done) {
    const duration = 800 / this.speed;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Spring easing function
      const springProgress = 1 - Math.pow(1 - progress, 3) * Math.exp(-progress * 3);
      
      this.el.style.opacity = springProgress;
      this.el.style.transform = `scale(${springProgress})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  animateOut(done) {
    const duration = 600 / this.speed;
    const startTime = performance.now();
    const startOpacity = parseFloat(this.el.style.opacity) || 1;
    const startScale = parseFloat(this.el.style.transform.replace('scale(', '').replace(')', '')) || 1;
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Spring easing function
      const springProgress = 1 - Math.pow(1 - progress, 3) * Math.exp(-progress * 3);
      
      this.el.style.opacity = startOpacity * (1 - springProgress);
      this.el.style.transform = `scale(${startScale * (1 - springProgress)})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
}

class BounceTransition extends BaseTransition {
  animateIn(done) {
    const duration = 1000 / this.speed;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Bounce easing function
      let bounceProgress;
      if (progress < 1/2.75) {
        bounceProgress = 7.5625 * progress * progress;
      } else if (progress < 2/2.75) {
        const p = progress - 1.5/2.75;
        bounceProgress = 7.5625 * p * p + 0.75;
      } else if (progress < 2.5/2.75) {
        const p = progress - 2.25/2.75;
        bounceProgress = 7.5625 * p * p + 0.9375;
      } else {
        const p = progress - 2.625/2.75;
        bounceProgress = 7.5625 * p * p + 0.984375;
      }
      
      this.el.style.opacity = bounceProgress;
      this.el.style.transform = `scale(${bounceProgress})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  animateOut(done) {
    // Упрощенная реализация для выхода
    const duration = 500 / this.speed;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      this.el.style.opacity = 1 - progress;
      this.el.style.transform = `scale(${1 - progress * 0.5})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
}

class ElasticTransition extends BaseTransition {
  animateIn(done) {
    const duration = 1000 / this.speed;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Elastic easing function
      const c4 = (2 * Math.PI) / 3;
      let elasticProgress;
      
      if (progress === 0) {
        elasticProgress = 0;
      } else if (progress === 1) {
        elasticProgress = 1;
      } else {
        elasticProgress = Math.pow(2, -10 * progress) * Math.sin((progress * 10 - 0.75) * c4) + 1;
      }
      
      this.el.style.opacity = elasticProgress;
      this.el.style.transform = `scale(${elasticProgress})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
  
  animateOut(done) {
    // Упрощенная реализация для выхода
    const duration = 600 / this.speed;
    const startTime = performance.now();
    
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      this.el.style.opacity = 1 - progress;
      this.el.style.transform = `scale(${1 - progress * 0.7})`;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        done();
      }
    };
    
    requestAnimationFrame(animate);
  }
}
</script>

<style scoped>
.js-dynamic-container {
  padding: 20px;
  text-align: center;
}

.controls {
  margin-bottom: 20px;
}

.js-animated-element {
  width: 200px;
  height: 200px;
  background-color: #9b59b6;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  border-radius: 8px;
  margin: 20px auto;
}

button {
  padding: 10px 20px;
  background-color: #34495e;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #2c3e50;
}
</style>
```

## Динамические переходы на основе данных

Переходы могут изменяться в зависимости от типа данных или их значений:

```vue
<template>
  <div class="data-driven-container">
    <h2>Переходы на основе данных</h2>
    
    <div class="data-controls">
      <button @click="addItem">Добавить элемент</button>
      <button @click="removeItem">Удалить элемент</button>
      <button @click="shuffleItems">Перемешать</button>
    </div>
    
    <transition-group 
      name="list"
      tag="ul"
      class="item-list"
    >
      <li 
        v-for="item in items" 
        :key="item.id"
        :class="getItemClass(item)"
      >
        {{ item.text }} ({{ item.type }})
      </li>
    </transition-group>
  </div>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { id: 1, text: 'Элемент 1', type: 'primary' },
        { id: 2, text: 'Элемент 2', type: 'secondary' },
        { id: 3, text: 'Элемент 3', type: 'warning' },
        { id: 4, text: 'Элемент 4', type: 'danger' }
      ],
      nextId: 5
    }
  },
  methods: {
    addItem() {
      const types = ['primary', 'secondary', 'warning', 'danger'];
      const randomType = types[Math.floor(Math.random() * types.length)];
      
      this.items.push({
        id: this.nextId++,
        text: `Элемент ${this.nextId - 1}`,
        type: randomType
      });
    },
    removeItem() {
      if (this.items.length > 0) {
        this.items.pop();
      }
    },
    shuffleItems() {
      // Простое перемешивание массива
      for (let i = this.items.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this.items[i], this.items[j]] = [this.items[j], this.items[i]];
      }
    },
    getItemClass(item) {
      // Возвращаем разные классы в зависимости от типа элемента
      return `item-${item.type}`;
    }
  }
}
</script>

<style scoped>
.data-driven-container {
  padding: 20px;
}

.data-controls {
  margin-bottom: 20px;
  text-align: center;
}

.data-controls button {
  margin: 0 5px;
  padding: 8px 16px;
  background-color: #34495e;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.data-controls button:hover {
  background-color: #2c3e50;
}

.item-list {
  list-style: none;
  padding: 0;
}

.item-list li {
  padding: 10px;
  margin: 5px 0;
  border-radius: 4px;
  color: white;
  text-align: center;
  transition: all 0.5s ease;
}

.item-primary {
  background-color: #3498db;
}

.item-secondary {
  background-color: #95a5a6;
}

.item-warning {
  background-color: #f39c12;
}

.item-danger {
  background-color: #e74c3c;
}

/* Анимации для списка */
.list-enter-active, .list-leave-active {
  transition: all 0.5s ease;
}
.list-enter-from, .list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

/* Анимация перемещения */
.list-move {
  transition: transform 0.5s ease;
}
</style>
```

## Лучшие практики

- Используйте динамические переходы для создания более адаптивного UX
- Избегайте чрезмерной сложности анимаций, чтобы не перегружать интерфейс
- Обеспечьте доступность - предоставьте опцию отключения анимаций
- Оптимизируйте производительность при изменении параметров анимаций
- Тестируйте различные комбинации параметров для обеспечения плавности

## Российские особенности

- Учитывайте разнообразие устройств и их производительность
- Обеспечьте корректную работу анимаций при низкой скорости интернета
- Соответствие требованиям доступности в соответствии с российскими стандартами

## Связанные темы

- [[Интерполяции-состояния]]
- [[Плавные-переходы-состояний]]
- [[Анимация-данных]]
- [[Библиотеки-анимации-состояний]]
- [[Анимации-переходов]]

## Ключевые теги

#vue #анимация #переход #динамический #state #frontend #javascript #webdev #ruweb #transition