---
aliases: [Custom Transitions, Пользовательские анимации, Переходы с JavaScript]
tags: [vue, animation, custom, frontend]
---

# Пользовательские-переходы

## Обзор

Пользовательские переходы в Vue.js позволяют реализовать сложные анимации с использованием JavaScript, CSS или комбинации обоих подходов. Они дают полный контроль над процессом анимации и позволяют создавать уникальные эффекты, недоступные с помощью встроенных CSS-переходов.

## Реализация через JavaScript

### Hooks для JavaScript-анимаций

Для создания пользовательских переходов на основе JavaScript используются специальные хуки:

```vue
<template>
  <transition
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
    :css="false"
  >
    <div v-if="show" class="custom-element">
      Элемент с пользовательской анимацией
    </div>
  </transition>
</template>

<script>
import gsap from 'gsap'

export default {
  data() {
    return {
      show: true
    }
  },
  methods: {
    beforeEnter(el) {
      // Установка начального состояния
      el.style.opacity = 0
      el.style.transform = 'translateY(-20px)'
    },
    enter(el, done) {
      // Анимация появления элемента
      gsap.to(el, {
        opacity: 1,
        y: 0,
        duration: 0.5,
        onComplete: done
      })
    },
    leave(el, done) {
      // Анимация исчезновения элемента
      gsap.to(el, {
        opacity: 0,
        y: -20,
        duration: 0.3,
        onComplete: done
      })
    }
  }
}
</script>
```

## Использование сторонних библиотек

### GreenSock (GSAP)

GSAP - мощная библиотека для создания сложных анимаций:

```vue
<template>
  <div>
    <button @click="toggle">Переключить элемент</button>
    <transition
      @enter="enterWithGsap"
      @leave="leaveWithGsap"
      :css="false"
    >
      <div v-if="isVisible" class="animated-box">
        GSAP Анимация
      </div>
    </transition>
  </div>
</template>

<script>
import { gsap } from 'gsap'

export default {
  data() {
    return {
      isVisible: true
    }
  },
  methods: {
    toggle() {
      this.isVisible = !this.isVisible
    },
    enterWithGsap(el, done) {
      gsap.fromTo(el, 
        { 
          scale: 0.5, 
          opacity: 0,
          rotation: -15 
        },
        { 
          scale: 1, 
          opacity: 1,
          rotation: 0,
          duration: 0.8,
          ease: 'elastic.out(1.2, 0.5)',
          onComplete: done
        }
      )
    },
    leaveWithGsap(el, done) {
      gsap.to(el, {
        scale: 0.3,
        opacity: 0,
        rotation: 15,
        duration: 0.5,
        ease: 'power2.in',
        onComplete: done
      })
    }
  }
}
</script>
```

### Framer Motion (через Vue-обертку)

Хотя Framer Motion изначально для React, существуют Vue-обертки:

```vue
<template>
  <transition
    @enter="framerEnter"
    @leave="framerLeave"
    :css="false"
  >
    <div v-if="show" class="motion-element">
      Framer-подобная анимация
    </div>
  </transition>
</template>

<script>
// Используем простую реализацию, имитирующую Framer Motion
export default {
  data() {
    return {
      show: false
    }
  },
  methods: {
    async framerEnter(el, done) {
      // Имитация Framer Motion анимации
      el.style.opacity = '0'
      el.style.transform = 'translateY(20px) scale(0.95)'
      
      await this.$nextTick()
      
      // Анимация появления
      const animation = el.animate([
        { opacity: 0, transform: 'translateY(20px) scale(0.95)' },
        { opacity: 1, transform: 'translateY(0) scale(1)' }
      ], {
        duration: 300,
        easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)'
      })
      
      animation.onfinish = done
    },
    async framerLeave(el, done) {
      // Имитация Framer Motion исчезновения
      const animation = el.animate([
        { opacity: 1, transform: 'translateY(0) scale(1)' },
        { opacity: 0, transform: 'translateY(20px) scale(0.95)' }
      ], {
        duration: 200,
        easing: 'ease-in'
      })
      
      animation.onfinish = () => {
        done()
      }
    }
  }
}
</script>
```

## Сложные анимации с Web Animations API

Использование встроенного Web Animations API для создания пользовательских переходов:

```vue
<template>
  <div>
    <button @click="animateElement">Анимировать</button>
    <transition
      @enter="webAnimationsEnter"
      @leave="webAnimationsLeave"
      :css="false"
    >
      <div v-if="isVisible" ref="animatedElement" class="web-anim-element">
        Элемент с Web Animation API
      </div>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isVisible: false
    }
  },
  methods: {
    animateElement() {
      this.isVisible = !this.isVisible
    },
    webAnimationsEnter(el, done) {
      const animation = el.animate([
        { transform: 'translateX(-100%)', opacity: 0 },
        { transform: 'translateX(0)', opacity: 1 }
      ], {
        duration: 500,
        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
      })
      
      animation.onfinish = done
    },
    webAnimationsLeave(el, done) {
      const animation = el.animate([
        { transform: 'translateX(0)', opacity: 1 },
        { transform: 'translateX(100%)', opacity: 0 }
      ], {
        duration: 300,
        easing: 'ease-in-out'
      })
      
      animation.onfinish = done
    }
  }
}
</script>
```

## Пользовательские функции анимации

Создание переиспользуемых функций для анимаций:

```javascript
// composables/useCustomTransitions.js
import { ref } from 'vue'

export function useCustomTransitions() {
  const animateSlide = (el, done, direction = 'in') => {
    const animation = el.animate(
      direction === 'in' 
        ? [
            { transform: 'translateX(-100%)', opacity: 0 },
            { transform: 'translateX(0)', opacity: 1 }
          ]
        : [
            { transform: 'translateX(0)', opacity: 1 },
            { transform: 'translateX(100%)', opacity: 0 }
          ],
      {
        duration: 300,
        easing: 'ease-in-out'
      }
    )
    
    animation.onfinish = done
  }

  const animateFade = (el, done, direction = 'in') => {
    const animation = el.animate(
      direction === 'in'
        ? [{ opacity: 0 }, { opacity: 1 }]
        : [{ opacity: 1 }, { opacity: 0 }],
      {
        duration: 200,
        easing: 'ease-out'
      }
    )
    
    animation.onfinish = done
  }

  return {
    animateSlide,
    animateFade
  }
}
```

Использование в компоненте:

```vue
<template>
  <div>
    <button @click="toggle">Переключить</button>
    <transition
      @enter="handleEnter"
      @leave="handleLeave"
      :css="false"
    >
      <div v-if="show" ref="elementRef" class="transition-element">
        Переиспользуемая анимация
      </div>
    </transition>
  </div>
</template>

<script>
import { useCustomTransitions } from '@/composables/useCustomTransitions'

export default {
  setup() {
    const { animateSlide } = useCustomTransitions()
    
    const show = ref(false)
    const elementRef = ref(null)
    
    const toggle = () => {
      show.value = !show.value
    }
    
    const handleEnter = (el, done) => {
      animateSlide(el, done, 'in')
    }
    
    const handleLeave = (el, done) => {
      animateSlide(el, done, 'out')
    }
    
    return {
      show,
      elementRef,
      toggle,
      handleEnter,
      handleLeave
    }
  }
}
</script>
```

## Анимации с Canvas

Для сложных визуальных эффектов можно использовать Canvas:

```vue
<template>
  <div class="canvas-container">
    <canvas ref="canvas" width="400" height="300"></canvas>
    <transition
      @enter="canvasEnter"
      @leave="canvasLeave"
      :css="false"
    >
      <div v-if="show" class="overlay-content">
        Содержимое поверх Canvas
      </div>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: true,
      animationFrameId: null
    }
  },
  mounted() {
    this.startCanvasAnimation()
  },
  methods: {
    startCanvasAnimation() {
      const canvas = this.$refs.canvas
      const ctx = canvas.getContext('2d')
      
      let time = 0
      const animate = () => {
        time += 0.05
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        
        // Рисуем анимированные элементы
        ctx.fillStyle = `hsl(${time * 20 % 360}, 70%, 50%)`
        ctx.beginPath()
        ctx.arc(
          200 + Math.sin(time) * 50, 
          150 + Math.cos(time) * 30, 
          30, 0, Math.PI * 2
        )
        ctx.fill()
        
        this.animationFrameId = requestAnimationFrame(animate)
      }
      animate()
    },
    canvasEnter(el, done) {
      // Анимация появления поверх Canvas
      el.style.opacity = '0'
      el.style.transform = 'scale(0.8)'
      
      setTimeout(() => {
        el.style.transition = 'all 0.5s ease-out'
        el.style.opacity = '1'
        el.style.transform = 'scale(1)'
        
        setTimeout(done, 500)
      }, 10)
    },
    canvasLeave(el, done) {
      // Анимация исчезновения поверх Canvas
      el.style.transition = 'all 0.3s ease-in'
      el.style.opacity = '0'
      el.style.transform = 'scale(0.8)'
      
      setTimeout(done, 300)
    }
  },
  beforeUnmount() {
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId)
    }
  }
}
</script>
```

## Особенности реализации в российских условиях (2025)

При реализации пользовательских переходов в российских условиях в 2025 году:

1. **Производительность** - особенно важно учитывать при использовании JavaScript-анимаций на слабых устройствах
2. **Поддержка браузеров** - проверять совместимость с Яндекс.Браузером, КриптоПро Browser и другими отечественными решениями
3. **Снижение нагрузки** - при слабом интернете или на бюджетных устройствах отключать сложные анимации

```javascript
// Проверка производительности устройства
export function shouldReduceMotion() {
  // Проверяем настройки доступности
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    return true
  }
  
  // Определяем производительность устройства
  const isLowEndDevice = navigator.hardwareConcurrency < 4 || 
                        (navigator.deviceMemory && navigator.deviceMemory < 4)
  
  return isLowEndDevice
}
```

## Связанные темы

- [[Встроенные-переходы]]
- [[Параметризованные-переходы]]
- [[Локальные-переходы]]
- [[Библиотеки-переходов]]
- [[Vue-Animation-Composables]]
- [[GSAP-интеграция-с-Vue]]