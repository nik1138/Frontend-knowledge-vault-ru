---
aliases: [Локальные анимации, Компонентные переходы, Внутренние переходы]
tags: [vue, transition, local, component, frontend]
---

# Локальные-переходы

## Обзор

Локальные переходы в Vue.js - это анимации, определенные непосредственно внутри компонента, а не глобально в приложении. Они позволяют создавать специфичные для компонента анимации, изолированные от остальной части приложения, что улучшает модульность и переиспользуемость компонентов.

## Определение локальных переходов

### Внутри компонента с Options API

Локальные переходы можно определить прямо в компоненте, используя вычисляемые свойства или методы:

```vue
<template>
  <div class="local-transition-component">
    <button @click="toggleContent">Переключить контент</button>
    
    <!-- Используем локальный компонент Transition -->
    <component 
      :is="localTransitionComponent" 
      name="local-fade"
      mode="out-in"
    >
      <div v-if="showContent" :key="contentKey" class="content">
        Локальный контент с анимацией
      </div>
    </component>
  </div>
</template>

<script>
// Локальный компонент Transition
const LocalTransition = {
  name: 'LocalTransition',
  render() {
    return this.$slots.default ? 
      this.$slots.default()[0] : 
      this.$slots.default
  }
}

export default {
  components: {
    LocalTransition
  },
  data() {
    return {
      showContent: true,
      contentKey: 0
    }
  },
  computed: {
    localTransitionComponent() {
      return {
        name: 'transition',
        props: ['name', 'mode'],
        render() {
          // Используем встроенный компонент Transition
          return h('transition', {
            name: this.name || 'local-fade',
            mode: this.mode || 'out-in'
          }, this.$slots.default)
        }
      }
    }
  },
  methods: {
    toggleContent() {
      this.showContent = !this.showContent
      this.contentKey += 1
    }
  }
}
</script>

<style>
/* Локальные стили перехода */
.local-fade-enter-active, .local-fade-leave-active {
  transition: opacity 0.3s ease;
}
.local-fade-enter-from, .local-fade-leave-to {
  opacity: 0;
}
</style>
```

### С использованием Composition API

Более элегантный подход с Composition API:

```vue
<template>
  <div class="composition-local-transition">
    <button @click="toggleContent">Переключить</button>
    
    <transition 
      :name="localTransitionName"
      :mode="localTransitionMode"
      @before-enter="onBeforeEnter"
      @enter="onEnter"
      @leave="onLeave"
    >
      <div v-if="isVisible" class="local-content">
        Контент с локальной анимацией
      </div>
    </transition>
  </div>
</template>

<script>
import { ref, computed, onMounted } from 'vue'

export default {
  setup() {
    const isVisible = ref(true)
    const animationSpeed = ref('normal') // 'slow', 'normal', 'fast'
    
    const localTransitionName = computed(() => `local-${animationSpeed.value}`)
    const localTransitionMode = computed(() => 'out-in')
    
    const toggleContent = () => {
      isVisible.value = !isVisible.value
    }
    
    // Локальные хуки анимации
    const onBeforeEnter = (el) => {
      console.log('Начало входа элемента')
      el.style.opacity = '0'
    }
    
    const onEnter = (el, done) => {
      // Локальная анимация с использованием CSS
      setTimeout(() => {
        el.style.transition = `opacity ${getDuration()} ease-out`
        el.style.opacity = '1'
        setTimeout(done, getDuration())
      }, 10)
    }
    
    const onLeave = (el, done) => {
      // Локальная анимация исчезновения
      el.style.transition = `opacity ${getDuration()} ease-in`
      el.style.opacity = '0'
      setTimeout(done, getDuration())
    }
    
    const getDuration = () => {
      switch(animationSpeed.value) {
        case 'slow': return 600
        case 'fast': return 200
        default: return 400
      }
    }
    
    onMounted(() => {
      console.log('Компонент с локальным переходом смонтирован')
    })
    
    return {
      isVisible,
      localTransitionName,
      localTransitionMode,
      toggleContent,
      onBeforeEnter,
      onEnter,
      onLeave
    }
  }
}
</script>

<style>
/* Локальные стили для различных скоростей */
.local-slow-enter-active, .local-slow-leave-active {
  transition: opacity 0.6s ease;
}
.local-slow-enter-from, .local-slow-leave-to {
  opacity: 0;
}

.local-normal-enter-active, .local-normal-leave-active {
  transition: opacity 0.4s ease;
}
.local-normal-enter-from, .local-normal-leave-to {
  opacity: 0;
}

.local-fast-enter-active, .local-fast-leave-active {
  transition: opacity 0.2s ease;
}
.local-fast-enter-from, .local-fast-leave-to {
  opacity: 0;
}
</style>
```

## Локальные компоненты Transition

### Создание специализированного компонента Transition

Можно создать локальный компонент, инкапсулирующий конкретную анимацию:

```vue
<!-- LocalSlideTransition.vue -->
<template>
  <transition
    :name="transitionName"
    :mode="mode"
    :duration="duration"
    @before-enter="beforeEnter"
    @enter="enter"
    @leave="leave"
  >
    <slot></slot>
  </transition>
</template>

<script>
export default {
  name: 'LocalSlideTransition',
  props: {
    direction: {
      type: String,
      default: 'right',
      validator: value => ['left', 'right', 'up', 'down'].includes(value)
    },
    duration: {
      type: Number,
      default: 300
    },
    mode: {
      type: String,
      default: 'out-in'
    }
  },
  computed: {
    transitionName() {
      return `slide-${this.direction}`
    }
  },
  methods: {
    beforeEnter(el) {
      // Локальная настройка начального состояния
      switch(this.direction) {
        case 'left':
          el.style.transform = 'translateX(20px)'
          break
        case 'right':
          el.style.transform = 'translateX(-20px)'
          break
        case 'up':
          el.style.transform = 'translateY(20px)'
          break
        case 'down':
          el.style.transform = 'translateY(-20px)'
          break
      }
      el.style.opacity = '0'
    },
    enter(el, done) {
      // Локальная анимация появления
      requestAnimationFrame(() => {
        el.style.transition = `all ${this.duration}ms ease`
        el.style.transform = 'translate(0, 0)'
        el.style.opacity = '1'
        
        el.addEventListener('transitionend', done, { once: true })
      })
    },
    leave(el, done) {
      // Локальная анимация исчезновения
      el.style.transition = `all ${this.duration}ms ease`
      
      switch(this.direction) {
        case 'left':
          el.style.transform = 'translateX(-20px)'
          break
        case 'right':
          el.style.transform = 'translateX(20px)'
          break
        case 'up':
          el.style.transform = 'translateY(-20px)'
          break
        case 'down':
          el.style.transform = 'translateY(20px)'
          break
      }
      
      el.style.opacity = '0'
      el.addEventListener('transitionend', done, { once: true })
    }
  }
}
</script>

<style>
/* Стили для слайд-переходов */
.slide-left-enter-active, .slide-left-leave-active,
.slide-right-enter-active, .slide-right-leave-active,
.slide-up-enter-active, .slide-up-leave-active,
.slide-down-enter-active, .slide-down-leave-active {
  transition: all 0.3s ease;
}

.slide-left-enter-from {
  transform: translateX(-20px);
  opacity: 0;
}
.slide-left-leave-to {
  transform: translateX(20px);
  opacity: 0;
}

.slide-right-enter-from {
  transform: translateX(20px);
  opacity: 0;
}
.slide-right-leave-to {
  transform: translateX(-20px);
  opacity: 0;
}

.slide-up-enter-from {
  transform: translateY(-20px);
  opacity: 0;
}
.slide-up-leave-to {
  transform: translateY(20px);
  opacity: 0;
}

.slide-down-enter-from {
  transform: translateY(20px);
  opacity: 0;
}
.slide-down-leave-to {
  transform: translateY(-20px);
  opacity: 0;
}
</style>
```

### Использование локального компонента Transition

```vue
<template>
  <div class="local-transition-usage">
    <div class="controls">
      <select v-model="direction">
        <option value="left">Слева</option>
        <option value="right">Справа</option>
        <option value="up">Сверху</option>
        <option value="down">Снизу</option>
      </select>
      
      <input 
        type="range" 
        v-model.number="duration" 
        min="100" 
        max="800" 
        step="50"
      >
      {{ duration }}ms
    </div>
    
    <!-- Используем локальный компонент Transition -->
    <LocalSlideTransition
      :direction="direction"
      :duration="duration"
      mode="out-in"
    >
      <div :key="contentVersion" class="transition-content">
        Контент с локальным слайд-переходом: {{ direction }}
      </div>
    </LocalSlideTransition>
  </div>
</template>

<script>
import LocalSlideTransition from './LocalSlideTransition.vue'

export default {
  components: {
    LocalSlideTransition
  },
  data() {
    return {
      direction: 'right',
      duration: 300,
      contentVersion: 0
    }
  },
  methods: {
    changeContent() {
      this.contentVersion += 1
    }
  },
  mounted() {
    // Автоматически меняем контент каждые 3 секунды для демонстрации
    setInterval(() => {
      this.contentVersion += 1
    }, 3000)
  }
}
</script>
```

## Локальные анимации с JavaScript

### Локальные JavaScript-анимации

Создание сложных локальных анимаций с использованием JavaScript:

```vue
<template>
  <div class="js-local-animation">
    <button @click="toggleAnimation">Переключить анимацию</button>
    
    <transition
      @before-enter="beforeEnterLocal"
      @enter="enterLocal"
      @leave="leaveLocal"
      :css="false"
    >
      <div v-if="showElement" ref="animatedElement" class="js-animated-element">
        Элемент с локальной JavaScript-анимацией
      </div>
    </transition>
  </div>
</template>

<script>
import { ref, onMounted, nextTick } from 'vue'

export default {
  setup() {
    const showElement = ref(true)
    const animatedElement = ref(null)
    const animationType = ref('wave') // 'wave', 'pulse', 'bounce'
    
    const toggleAnimation = () => {
      showElement.value = !showElement.value
    }
    
    // Локальные JavaScript-анимации
    const beforeEnterLocal = (el) => {
      // Устанавливаем начальное состояние
      el.style.opacity = '0'
      el.style.transform = 'scale(0.8) translateY(20px)'
    }
    
    const enterLocal = async (el, done) => {
      // Ждем следующего тика для правильной анимации
      await nextTick()
      
      // Выбираем тип анимации
      switch(animationType.value) {
        case 'wave':
          animateWave(el, done)
          break
        case 'pulse':
          animatePulse(el, done)
          break
        case 'bounce':
          animateBounce(el, done)
          break
        default:
          animateDefault(el, done)
      }
    }
    
    const leaveLocal = (el, done) => {
      // Анимация исчезновения
      const animation = el.animate([
        { opacity: 1, transform: 'scale(1) translateY(0)' },
        { opacity: 0, transform: 'scale(0.8) translateY(-20px)' }
      ], {
        duration: 300,
        easing: 'ease-in-out'
      })
      
      animation.onfinish = done
    }
    
    // Определение локальных анимаций
    const animateWave = (el, done) => {
      const animation = el.animate([
        { opacity: 0, transform: 'scale(0.8) translateY(20px)' },
        { opacity: 0.5, transform: 'scale(1.05) translateY(-10px)', offset: 0.5 },
        { opacity: 1, transform: 'scale(1) translateY(0)' }
      ], {
        duration: 500,
        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
      })
      
      animation.onfinish = done
    }
    
    const animatePulse = (el, done) => {
      const animation = el.animate([
        { opacity: 0, transform: 'scale(0.8)' },
        { opacity: 1, transform: 'scale(1.05)', offset: 0.7 },
        { opacity: 1, transform: 'scale(1)' }
      ], {
        duration: 400,
        easing: 'ease-out'
      })
      
      animation.onfinish = done
    }
    
    const animateBounce = (el, done) => {
      const animation = el.animate([
        { opacity: 0, transform: 'scale(0.3) translateY(20px)' },
        { opacity: 0.5, transform: 'scale(1.05) translateY(-10px)', offset: 0.6 },
        { opacity: 1, transform: 'scale(0.9) translateY(2px)', offset: 0.8 },
        { opacity: 1, transform: 'scale(1) translateY(0)' }
      ], {
        duration: 600,
        easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
      })
      
      animation.onfinish = done
    }
    
    const animateDefault = (el, done) => {
      const animation = el.animate([
        { opacity: 0, transform: 'scale(0.8) translateY(20px)' },
        { opacity: 1, transform: 'scale(1) translateY(0)' }
      ], {
        duration: 300,
        easing: 'ease-out'
      })
      
      animation.onfinish = done
    }
    
    onMounted(() => {
      console.log('Компонент с локальной JS-анимацией смонтирован')
    })
    
    return {
      showElement,
      animatedElement,
      toggleAnimation,
      beforeEnterLocal,
      enterLocal,
      leaveLocal
    }
  }
}
</script>
```

## Локальные анимации в компонентах с разными состояниями

### Анимации для различных состояний компонента

Создание локальных анимаций, зависящих от состояния компонента:

```vue
<template>
  <div class="state-dependent-animation">
    <div class="state-controls">
      <button @click="setState('loading')">Загрузка</button>
      <button @click="setState('success')">Успех</button>
      <button @click="setState('error')">Ошибка</button>
      <button @click="setState('normal')">Нормальное</button>
    </div>
    
    <transition
      :name="getTransitionName"
      @enter="stateEnter"
      @leave="stateLeave"
      mode="out-in"
    >
      <div :key="currentState" class="state-content" :class="currentState">
        <div v-if="currentState === 'loading'" class="loading-content">
          <div class="spinner"></div>
          Загрузка...
        </div>
        <div v-else-if="currentState === 'success'" class="success-content">
          ✅ Успешно выполнено!
        </div>
        <div v-else-if="currentState === 'error'" class="error-content">
          ❌ Произошла ошибка
        </div>
        <div v-else class="normal-content">
          Нормальное состояние
        </div>
      </div>
    </transition>
  </div>
</template>

<script>
import { ref } from 'vue'

export default {
  setup() {
    const currentState = ref('normal')
    
    const setState = (state) => {
      currentState.value = state
    }
    
    const getTransitionName = () => {
      // Возвращаем разные имена переходов в зависимости от состояния
      const transitions = {
        'normal-success': 'fade-up',
        'loading-success': 'pop',
        'error-success': 'shake',
        'success-error': 'shake',
        'loading-error': 'fade-down',
        'normal-error': 'fade-down',
        'error-normal': 'fade-up',
        'success-normal': 'fade-up',
        'loading-normal': 'fade-up',
        'normal-loading': 'fade-down',
        'success-loading': 'fade-down',
        'error-loading': 'fade-down'
      }
      
      const transitionKey = `${currentState.value}-${currentState.value}`
      return transitions[transitionKey] || 'fade'
    }
    
    const stateEnter = (el, done) => {
      // Локальная логика входа в зависимости от состояния
      console.log(`Вход в состояние: ${currentState.value}`)
      done()
    }
    
    const stateLeave = (el, done) => {
      // Локальная логика выхода из состояния
      console.log(`Выход из состояния: ${currentState.value}`)
      done()
    }
    
    return {
      currentState,
      setState,
      getTransitionName,
      stateEnter,
      stateLeave
    }
  }
}
</script>

<style>
.state-content {
  padding: 20px;
  border-radius: 8px;
  text-align: center;
  min-height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.loading-content, .normal-content {
  background-color: #f0f8ff;
  color: #333;
}

.success-content {
  background-color: #f0fff0;
  color: #2e7d32;
}

.error-content {
  background-color: #fff8f8;
  color: #c62828;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 10px;
  display: inline-block;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Переходы для разных состояний */
.fade-up-enter-active, .fade-up-leave-active {
  transition: all 0.3s ease;
}
.fade-up-enter-from {
  opacity: 0;
  transform: translateY(20px);
}
.fade-up-leave-to {
  opacity: 0;
  transform: translateY(-20px);
}

.fade-down-enter-active, .fade-down-leave-active {
  transition: all 0.3s ease;
}
.fade-down-enter-from {
  opacity: 0;
  transform: translateY(-20px);
}
.fade-down-leave-to {
  opacity: 0;
  transform: translateY(20px);
}

.pop-enter-active, .pop-leave-active {
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.pop-enter-from {
  opacity: 0;
  transform: scale(0.8);
}
.pop-leave-to {
  opacity: 0;
  transform: scale(1.1);
}

.shake-enter-active {
  animation: shake 0.5s ease-in-out;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20%, 60% { transform: translateX(-5px); }
  40%, 80% { transform: translateX(5px); }
}
</style>
```

## Особенности реализации в российских условиях (2025)

При реализации локальных переходов в российских условиях в 2025 году:

1. **Производительность** - локальные анимации должны быть оптимизированы для слабых устройств, особенно если компонент будет часто использоваться
2. **Модульность** - локальные переходы улучшают переиспользуемость компонентов, что особенно ценно при разработке библиотек компонентов
3. **Тестирование** - локальные анимации легче тестировать изолированно

```javascript
// Утилита для определения необходимости упрощения анимаций
export function shouldSimplifyAnimations() {
  // Проверяем настройки пользователя
  if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    return true
  }
  
  // Определяем производительность устройства
  const isLowEndDevice = navigator.hardwareConcurrency < 4 || 
                        (navigator.deviceMemory && navigator.deviceMemory < 4)
  
  // Проверяем версию браузера (для отечественных браузеров)
  const userAgent = navigator.userAgent
  const isOldBrowser = userAgent.includes('YaBrowser') && 
                      !userAgent.includes('Chrome/120') // Пример для Яндекс.Браузера
  
  return isLowEndDevice || isOldBrowser
}
```

## Связанные темы

- [[Встроенные-переходы]]
- [[Пользовательские-переходы]]
- [[Параметризованные-переходы]]
- [[Библиотеки-переходов]]
- [[Vue-компоненты-и-анимации]]
- [[Composition-API-в-переходах]]