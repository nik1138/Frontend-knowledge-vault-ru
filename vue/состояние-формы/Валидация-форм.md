---
aliases: [Валидация форм, Проверка форм, Валидация данных]
tags: [vue, forms, validation, frontend, security]
---

# Валидация форм в Vue 2025

## Введение

Валидация форм - это процесс проверки корректности введенных пользователем данных перед их обработкой или отправкой на сервер. В 2025 году требования к валидации форм становятся всё более строгими, особенно в свете необходимости соответствия требованиям безопасности и доступности, а также учета российских стандартов обработки данных.

## Основы валидации форм

### Клиентская валидация

Клиентская валидация выполняется в браузере и предоставляет мгновенную обратную связь пользователю:

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div class="form-group">
      <label for="email">Email</label>
      <input 
        id="email" 
        v-model="form.email" 
        type="email"
        :class="{ 'error': errors.email }"
        @blur="validateField('email')"
      />
      <span v-if="errors.email" class="error-message">
        {{ errors.email }}
      </span>
    </div>
    
    <div class="form-group">
      <label for="phone">Телефон</label>
      <input 
        id="phone" 
        v-model="form.phone" 
        :class="{ 'error': errors.phone }"
        @input="formatPhone"
        @blur="validateField('phone')"
      />
      <span v-if="errors.phone" class="error-message">
        {{ errors.phone }}
      </span>
    </div>
    
    <button type="submit" :disabled="!formValid">Отправить</button>
  </form>
</template>

<script setup>
import { reactive, computed } from 'vue';

const form = reactive({
  email: '',
  phone: ''
});

const errors = reactive({});

const validateField = (fieldName) => {
  switch (fieldName) {
    case 'email':
      if (!form.email) {
        errors.email = 'Email обязателен';
      } else if (!isValidEmail(form.email)) {
        errors.email = 'Некорректный email';
      } else {
        delete errors.email;
      }
      break;
      
    case 'phone':
      if (!form.phone) {
        errors.phone = 'Телефон обязателен';
      } else if (!isValidPhone(form.phone)) {
        errors.phone = 'Некорректный телефон';
      } else {
        delete errors.phone;
      }
      break;
  }
};

const formValid = computed(() => {
  return form.email && 
         form.phone && 
         !errors.email && 
         !errors.phone;
});

const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const isValidPhone = (phone) => {
  // Проверка российского формата телефона
  const phoneRegex = /^(\+7|8)?[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/;
  return phoneRegex.test(phone);
};

const formatPhone = () => {
  // Форматирование телефона в российский формат
  let cleaned = form.phone.replace(/\D/g, '');
  if (cleaned.length > 10) cleaned = cleaned.substring(0, 11);
  
  let formatted = '';
  if (cleaned.length > 0) {
    formatted = cleaned.length > 10 ? '+7 (' : '8 (';
    formatted += cleaned.substring(0, 3);
    if (cleaned.length >= 4) formatted += ') ' + cleaned.substring(3, 6);
    if (cleaned.length >= 7) formatted += '-' + cleaned.substring(6, 8);
    if (cleaned.length >= 9) formatted += '-' + cleaned.substring(8, 10);
  }
  
  form.phone = formatted;
};

const handleSubmit = () => {
  if (formValid.value) {
    console.log('Форма отправлена:', form);
  }
};
</script>
```

### Серверная валидация

Серверная валидация обязательна для обеспечения безопасности и целостности данных:

```javascript
// api/formService.js
export const submitForm = async (formData) => {
  try {
    const response = await fetch('/api/form', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': getCSRFToken()
      },
      body: JSON.stringify(formData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new FormValidationError(errorData.errors);
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof FormValidationError) {
      // Обработка ошибок валидации
      throw error;
    }
    throw new Error('Ошибка отправки формы');
  }
};
```

## Паттерны валидации

### Валидация с использованием Composables

Создание переиспользуемых валидационных логик через composables:

```javascript
// composables/useValidation.js
import { reactive, computed } from 'vue';

export function useValidation(initialData, rules) {
  const form = reactive({
    data: { ...initialData },
    errors: {},
    touched: {}
  });

  const validateField = (field, value) => {
    if (!rules[field]) return true;
    
    for (const rule of rules[field]) {
      const error = rule(value, form.data);
      if (error) {
        form.errors[field] = error;
        return false;
      }
    }
    
    delete form.errors[field];
    return true;
  };

  const validateAll = () => {
    let isValid = true;
    for (const field in rules) {
      if (!validateField(field, form.data[field])) {
        isValid = false;
      }
    }
    return isValid;
  };

  const isFieldValid = (field) => !form.errors[field];
  
  const markAsTouched = (field) => {
    form.touched[field] = true;
  };

  return {
    form,
    validateField,
    validateAll,
    isFieldValid,
    markAsTouched
  };
}

// Валидационные правила
export const validationRules = {
  required: (value) => {
    if (!value || value.trim() === '') {
      return 'Обязательное поле';
    }
    return null;
  },
  
  email: (value) => {
    if (value && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Некорректный email';
    }
    return null;
  },
  
  minLength: (min) => (value) => {
    if (value && value.length < min) {
      return `Минимум ${min} символов`;
    }
    return null;
  },
  
  phone: (value) => {
    if (value && !/^(\+7|8)?[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/.test(value.replace(/\D/g, ''))) {
      return 'Некорректный телефон';
    }
    return null;
  }
};
```

### Асинхронная валидация

Для проверки уникальности данных или сложных бизнес-правил:

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div class="form-group">
      <label for="username">Имя пользователя</label>
      <input 
        id="username" 
        v-model="form.username" 
        :class="{ 'error': errors.username, 'validating': validating.username }"
        @blur="validateUsername"
      />
      <span v-if="errors.username" class="error-message">
        {{ errors.username }}
      </span>
      <span v-else-if="validating.username" class="validating-message">
        Проверка...
      </span>
    </div>
  </form>
</template>

<script setup>
import { reactive } from 'vue';

const form = reactive({
  username: ''
});

const errors = reactive({});
const validating = reactive({});

let validationTimeout;

const validateUsername = async () => {
  if (!form.username) {
    errors.username = 'Имя пользователя обязательно';
    return;
  }
  
  // Отмена предыдущей проверки
  if (validationTimeout) {
    clearTimeout(validationTimeout);
  }
  
  validating.username = true;
  errors.username = '';
  
  // Дебаунс для избежания частых запросов
  validationTimeout = setTimeout(async () => {
    try {
      const isAvailable = await checkUsernameAvailability(form.username);
      if (!isAvailable) {
        errors.username = 'Имя пользователя занято';
      }
    } catch (error) {
      errors.username = 'Ошибка проверки имени пользователя';
    } finally {
      validating.username = false;
    }
  }, 500);
};

const checkUsernameAvailability = async (username) => {
  // API-запрос для проверки уникальности
  const response = await fetch(`/api/check-username/${username}`);
  const data = await response.json();
  return data.isAvailable;
};
</script>
```

## Валидация с использованием внешних библиотек

### VeeValidate

Одна из популярных библиотек для валидации форм в Vue:

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <div>
      <Field name="email" type="email" class="form-control" />
      <ErrorMessage name="email" class="error-message" />
    </div>
    
    <div>
      <Field name="password" type="password" class="form-control" />
      <ErrorMessage name="password" class="error-message" />
    </div>
    
    <button type="submit">Отправить</button>
  </Form>
</template>

<script setup>
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().required('Email обязателен').email('Некорректный email'),
  password: yup.string().required('Пароль обязателен').min(8, 'Минимум 8 символов')
});

const onSubmit = (values) => {
  console.log('Данные формы:', values);
};
</script>
```

## Российские особенности валидации

### Форматы данных

- **Телефоны**: Поддержка российских форматов (8-800, +7-9xx, и т.д.)
- **Адреса**: Проверка почтовых индексов (6 цифр)
- **ИНН/КПП**: Специфические правила валидации
- **Банковские реквизиты**: Номера счетов, БИК, ИНН организаций

```javascript
// Российские форматы валидации
export const ruValidationRules = {
  inn: (value) => {
    if (!value) return null;
    
    const inn = value.replace(/\D/g, '');
    if (inn.length !== 10 && inn.length !== 12) {
      return 'Некорректный ИНН';
    }
    
    // Проверка контрольных цифр
    const checkDigit = (inn, coefficients) => {
      return coefficients.reduce((sum, coeff, i) => sum + coeff * +inn[i], 0) % 11 % 10;
    };
    
    if (inn.length === 10) {
      // Для 10-значного ИНН
      const controlDigit = checkDigit(inn, [2, 4, 10, 3, 5, 9, 4, 6, 8]);
      if (+inn[9] !== controlDigit) {
        return 'Некорректный ИНН';
      }
    } else if (inn.length === 12) {
      // Для 12-значного ИНН
      const controlDigit1 = checkDigit(inn, [7, 2, 4, 10, 3, 5, 9, 4, 6, 8]);
      const controlDigit2 = checkDigit(inn, [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8]);
      if (+inn[10] !== controlDigit1 || +inn[11] !== controlDigit2) {
        return 'Некорректный ИНН';
      }
    }
    
    return null;
  },
  
  postalCode: (value) => {
    if (!value) return null;
    const postalCode = value.replace(/\D/g, '');
    if (postalCode.length !== 6) {
      return 'Почтовый индекс должен содержать 6 цифр';
    }
    return null;
  }
};
```

### Соответствие требованиям 152-ФЗ

- Проверка согласия на обработку персональных данных
- Обязательные поля для сбора персональных данных
- Защита конфиденциальной информации

## Практические рекомендации

### UX-рекомендации

- Показывайте ошибки валидации сразу после ввода
- Используйте понятные сообщения об ошибках
- Подсвечивайте проблемные поля
- Предоставляйте подсказки по формату ввода

### Безопасность

- Всегда проводите серверную валидацию
- Не полагайтесь только на клиентскую валидацию
- Используйте CSRF-токены
- Санитизируйте данные перед сохранением

## Заключение

Эффективная валидация форм в Vue 2025 должна сочетать в себе надежность, удобство использования и соответствие требованиям безопасности. Современные подходы позволяют создавать гибкие и мощные системы валидации, адаптированные под специфические требования российского рынка.

## См. также

- [[Управление-состоянием-форм]]
- [[Композиция-состояния-форм]]
- [[Внешние-библиотеки]]
- [[Безопасность-в-Vue]]
- [[Доступность-форм]]
- [[Типизация-в-Vue]]