---
aliases: [Composables форм, Композиция форм, Повторное использование форм]
tags: [vue, forms, composition-api, composables, frontend]
---

# Композиция состояния форм в Vue 2025

## Введение

Композиция состояния форм - это подход к созданию переиспользуемых логических блоков (composables) для управления формами в Vue. В 2025 году этот подход стал стандартом де-факто благодаря гибкости Composition API и возможности разделения логики между компонентами. Композиция позволяет создавать универсальные решения для форм, которые можно легко адаптировать под различные сценарии использования.

## Основы Composables для форм

### Создание базового Composable для формы

```javascript
// composables/useForm.js
import { reactive, computed } from 'vue';

export function useForm(initialData, validationRules = {}) {
  const form = reactive({
    data: { ...initialData },
    errors: {},
    touched: {},
    isValid: false,
    isSubmitting: false,
    isSubmitted: false
  });

  const validateField = (fieldName, value) => {
    if (!validationRules[fieldName]) return true;
    
    for (const rule of validationRules[fieldName]) {
      const error = rule(value, form.data);
      if (error) {
        form.errors[fieldName] = error;
        return false;
      }
    }
    
    delete form.errors[fieldName];
    return true;
  };

  const validateAll = () => {
    let isValid = true;
    for (const field in validationRules) {
      const fieldValue = form.data[field];
      if (!validateField(field, fieldValue)) {
        isValid = false;
      }
    }
    form.isValid = isValid;
    return isValid;
  };

  const updateField = (fieldName, value) => {
    form.data[fieldName] = value;
    form.touched[fieldName] = true;
    
    // Валидация только измененного поля
    if (validationRules[fieldName]) {
      validateField(fieldName, value);
      validateAll(); // Полная валидация для обновления общего состояния
    }
  };

  const reset = () => {
    Object.keys(form.data).forEach(key => {
      form.data[key] = initialData[key];
    });
    form.errors = {};
    form.touched = {};
    form.isValid = false;
    form.isSubmitting = false;
    form.isSubmitted = false;
  };

  return {
    form,
    validateField,
    validateAll,
    updateField,
    reset
  };
}
```

### Использование базового Composable

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div class="form-group">
      <label for="name">Имя</label>
      <input 
        id="name" 
        :value="form.data.name" 
        @input="updateField('name', $event.target.value)"
        :class="{ 'error': form.errors.name }"
        placeholder="Введите имя"
      />
      <span v-if="form.errors.name" class="error-message">
        {{ form.errors.name }}
      </span>
    </div>
    
    <div class="form-group">
      <label for="email">Email</label>
      <input 
        id="email" 
        :value="form.data.email" 
        @input="updateField('email', $event.target.value)"
        :class="{ 'error': form.errors.email }"
        placeholder="Введите email"
      />
      <span v-if="form.errors.email" class="error-message">
        {{ form.errors.email }}
      </span>
    </div>
    
    <button 
      type="submit" 
      :disabled="!form.isValid || form.isSubmitting"
    >
      {{ form.isSubmitting ? 'Отправка...' : 'Отправить' }}
    </button>
  </form>
</template>

<script setup>
import { useForm } from '@/composables/useForm';
import { required, email } from '@/validators/rules';

const { form, updateField, validateAll, reset } = useForm(
  { name: '', email: '' },
  {
    name: [required],
    email: [required, email]
  }
);

const handleSubmit = async () => {
  if (!validateAll()) return;
  
  form.isSubmitting = true;
  try {
    // Отправка данных на сервер
    await submitForm(form.data);
    form.isSubmitted = true;
    console.log('Форма успешно отправлена');
  } catch (error) {
    console.error('Ошибка отправки формы:', error);
  } finally {
    form.isSubmitting = false;
  }
};
</script>
```

## Расширенные Composables

### Composable с асинхронной валидацией

```javascript
// composables/useAsyncForm.js
import { reactive, ref } from 'vue';

export function useAsyncForm(initialData, asyncValidationRules = {}) {
  const form = reactive({
    data: { ...initialData },
    errors: {},
    touched: {},
    isValid: false,
    isSubmitting: false,
    isSubmitted: false
  });

  const validatingFields = ref(new Set());

  const validateFieldAsync = async (fieldName, value) => {
    if (!asyncValidationRules[fieldName]) return true;
    
    validatingFields.value.add(fieldName);
    
    try {
      for (const rule of asyncValidationRules[fieldName]) {
        const error = await rule(value, form.data);
        if (error) {
          form.errors[fieldName] = error;
          return false;
        }
      }
      
      delete form.errors[fieldName];
      return true;
    } finally {
      validatingFields.value.delete(fieldName);
    }
  };

  const validateAllAsync = async () => {
    const validationPromises = [];
    
    for (const field in asyncValidationRules) {
      const promise = validateFieldAsync(field, form.data[field])
        .then(isValid => ({ field, isValid }));
      validationPromises.push(promise);
    }
    
    const results = await Promise.all(validationPromises);
    const allValid = results.every(result => result.isValid);
    
    form.isValid = allValid;
    return allValid;
  };

  const updateField = async (fieldName, value) => {
    form.data[fieldName] = value;
    form.touched[fieldName] = true;
    
    if (asyncValidationRules[fieldName]) {
      await validateFieldAsync(fieldName, value);
      await validateAllAsync();
    }
  };

  return {
    form,
    validatingFields,
    validateFieldAsync,
    validateAllAsync,
    updateField
  };
}
```

### Composable для вложенных форм

```javascript
// composables/useNestedForm.js
import { reactive, computed } from 'vue';

export function useNestedForm(initialData, validationRules = {}) {
  const form = reactive({
    data: { ...initialData },
    errors: {},
    touched: {},
    isValid: false
  });

  const validateNestedField = (path, value) => {
    const rule = validationRules[path];
    if (!rule) return true;
    
    for (const r of rule) {
      const error = r(value, form.data);
      if (error) {
        setNestedError(path, error);
        return false;
      }
    }
    
    clearNestedError(path);
    return true;
  };

  const setNestedError = (path, error) => {
    const pathParts = path.split('.');
    let current = form.errors;
    
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      if (!current[part]) current[part] = {};
      current = current[part];
    }
    
    current[pathParts[pathParts.length - 1]] = error;
  };

  const clearNestedError = (path) => {
    const pathParts = path.split('.');
    let current = form.errors;
    
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      if (!current[part]) return;
      current = current[part];
    }
    
    delete current[pathParts[pathParts.length - 1]];
  };

  const updateNestedField = (path, value) => {
    const pathParts = path.split('.');
    let current = form.data;
    
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      if (!current[part]) current[part] = {};
      current = current[part];
    }
    
    current[pathParts[pathParts.length - 1]] = value;
    
    if (validationRules[path]) {
      validateNestedField(path, value);
    }
  };

  const getNestedValue = (path) => {
    const pathParts = path.split('.');
    let current = form.data;
    
    for (const part of pathParts) {
      if (current && typeof current === 'object') {
        current = current[part];
      } else {
        return undefined;
      }
    }
    
    return current;
  };

  return {
    form,
    validateNestedField,
    updateNestedField,
    getNestedValue
  };
}
```

## Специфические Composables для российских форм

### Composable для форм с персональными данными

```javascript
// composables/usePersonalDataForm.js
import { useForm } from './useForm';
import { required, email, phone, inn } from '@/validators/ru-rules';

export function usePersonalDataForm() {
  const personalDataRules = {
    fullName: [required],
    email: [required, email],
    phone: [required, phone],
    inn: [inn], // Необязательный, но если есть - должен быть корректным
    consent: [(value) => value === true || 'Необходимо согласие на обработку персональных данных']
  };

  return useForm(
    { 
      fullName: '', 
      email: '', 
      phone: '', 
      inn: '', 
      consent: false 
    },
    personalDataRules
  );
}
```

### Composable для банковских форм

```javascript
// composables/useBankingForm.js
import { useForm } from './useForm';
import { required, minLength, maxLength } from '@/validators/rules';

export function useBankingForm() {
  const bankingRules = {
    accountNumber: [
      required,
      (value) => /^\d{20}$/.test(value) || 'Номер счета должен содержать 20 цифр'
    ],
    bic: [
      required,
      (value) => /^\d{9}$/.test(value) || 'БИК должен содержать 9 цифр'
    ],
    bankName: [required, minLength(2), maxLength(100)]
  };

  return useForm(
    { 
      accountNumber: '', 
      bic: '', 
      bankName: '' 
    },
    bankingRules
  );
}
```

## Практические примеры использования

### Форма регистрации пользователя

```vue
<template>
  <div class="registration-form">
    <h2>Регистрация</h2>
    
    <form @submit.prevent="handleRegister">
      <div class="form-row">
        <div class="form-group">
          <label for="firstName">Имя</label>
          <input 
            id="firstName" 
            :value="form.data.firstName" 
            @input="updateField('firstName', $event.target.value)"
            :class="{ 'error': form.errors.firstName }"
            placeholder="Иван"
          />
          <span v-if="form.errors.firstName" class="error-message">
            {{ form.errors.firstName }}
          </span>
        </div>
        
        <div class="form-group">
          <label for="lastName">Фамилия</label>
          <input 
            id="lastName" 
            :value="form.data.lastName" 
            @input="updateField('lastName', $event.target.value)"
            :class="{ 'error': form.errors.lastName }"
            placeholder="Иванов"
          />
          <span v-if="form.errors.lastName" class="error-message">
            {{ form.errors.lastName }}
          </span>
        </div>
      </div>
      
      <div class="form-group">
        <label for="email">Email</label>
        <input 
          id="email" 
          :value="form.data.email" 
          @input="updateField('email', $event.target.value)"
          :class="{ 'error': form.errors.email }"
          placeholder="email@example.com"
        />
        <span v-if="form.errors.email" class="error-message">
          {{ form.errors.email }}
        </span>
      </div>
      
      <div class="form-group">
        <label for="phone">Телефон</label>
        <input 
          id="phone" 
          :value="form.data.phone" 
          @input="handlePhoneInput"
          :class="{ 'error': form.errors.phone }"
          placeholder="+7 (999) 999-99-99"
        />
        <span v-if="form.errors.phone" class="error-message">
          {{ form.errors.phone }}
        </span>
      </div>
      
      <div class="form-group">
        <label class="checkbox-label">
          <input 
            type="checkbox" 
            :checked="form.data.consent"
            @change="updateField('consent', $event.target.checked)"
          />
          Я согласен на обработку персональных данных
        </label>
        <span v-if="form.errors.consent" class="error-message">
          {{ form.errors.consent }}
        </span>
      </div>
      
      <button 
        type="submit" 
        :disabled="!form.isValid || form.isSubmitting"
        class="submit-btn"
      >
        {{ form.isSubmitting ? 'Регистрация...' : 'Зарегистрироваться' }}
      </button>
    </form>
  </div>
</template>

<script setup>
import { usePersonalDataForm } from '@/composables/usePersonalDataForm';

const { form, updateField, validateAll } = usePersonalDataForm();

const handlePhoneInput = (event) => {
  let value = event.target.value.replace(/\D/g, '');
  if (value.length > 11) value = value.substring(0, 11);
  
  let formatted = '';
  if (value.length > 0) {
    formatted = value.length > 10 ? '+7 (' : '8 (';
    formatted += value.substring(0, 3);
    if (value.length >= 4) formatted += ') ' + value.substring(3, 6);
    if (value.length >= 7) formatted += '-' + value.substring(6, 8);
    if (value.length >= 9) formatted += '-' + value.substring(8, 10);
  }
  
  updateField('phone', formatted);
};

const handleRegister = async () => {
  if (!validateAll()) return;
  
  form.isSubmitting = true;
  try {
    // Регистрация пользователя
    await registerUser(form.data);
    form.isSubmitted = true;
    console.log('Пользователь успешно зарегистрирован');
  } catch (error) {
    console.error('Ошибка регистрации:', error);
    // Обработка ошибки
  } finally {
    form.isSubmitting = false;
  }
};
</script>
```

### Форма с динамическими полями

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div v-for="(item, index) in form.data.items" :key="index" class="item-row">
      <div class="form-group">
        <label>Название</label>
        <input 
          :value="item.name" 
          @input="updateItemField(index, 'name', $event.target.value)"
          :class="{ 'error': hasError(`items[${index}].name`) }"
        />
        <span v-if="hasError(`items[${index}].name`)" class="error-message">
          {{ getError(`items[${index}].name`) }}
        </span>
      </div>
      
      <div class="form-group">
        <label>Количество</label>
        <input 
          type="number" 
          :value="item.quantity" 
          @input="updateItemField(index, 'quantity', $event.target.value)"
          :class="{ 'error': hasError(`items[${index}].quantity`) }"
        />
        <span v-if="hasError(`items[${index}].quantity`)" class="error-message">
          {{ getError(`items[${index}].quantity`) }}
        </span>
      </div>
      
      <button type="button" @click="removeItem(index)">Удалить</button>
    </div>
    
    <button type="button" @click="addItem">Добавить элемент</button>
    
    <button type="submit" :disabled="!form.isValid">Отправить</button>
  </form>
</template>

<script setup>
import { useNestedForm } from '@/composables/useNestedForm';

const { form, updateNestedField, getNestedValue } = useNestedForm({
  items: [{ name: '', quantity: 1 }]
});

const updateItemField = (index, field, value) => {
  updateNestedField(`items[${index}].${field}`, value);
};

const addItem = () => {
  form.data.items.push({ name: '', quantity: 1 });
};

const removeItem = (index) => {
  form.data.items.splice(index, 1);
};

const hasError = (path) => {
  return getNestedValue(`errors.${path}`) !== undefined;
};

const getError = (path) => {
  return getNestedValue(`errors.${path}`);
};

const handleSubmit = () => {
  console.log('Данные формы:', form.data);
};
</script>
```

## Паттерны композиции форм

### Фабрика форм

```javascript
// composables/formFactory.js
import { useForm } from './useForm';

export function createForm(type, options = {}) {
  switch (type) {
    case 'registration':
      return useRegistrationForm(options);
    case 'login':
      return useLoginForm(options);
    case 'contact':
      return useContactForm(options);
    case 'payment':
      return usePaymentForm(options);
    default:
      throw new Error(`Неизвестный тип формы: ${type}`);
  }
}

function useRegistrationForm(options) {
  const defaultRules = {
    email: [required, email],
    password: [required, minLength(8)],
    confirmPassword: [(value, formData) => 
      value === formData.password || 'Пароли не совпадают'
    ]
  };
  
  return useForm(
    { email: '', password: '', confirmPassword: '' },
    { ...defaultRules, ...options.rules }
  );
}

function useLoginForm(options) {
  const defaultRules = {
    email: [required, email],
    password: [required]
  };
  
  return useForm(
    { email: '', password: '' },
    { ...defaultRules, ...options.rules }
  );
}
```

### Композиция с локальным хранилищем

```javascript
// composables/usePersistentForm.js
import { useStorage } from '@vueuse/core';
import { reactive } from 'vue';

export function usePersistentForm(key, initialData, validationRules = {}) {
  const savedData = useStorage(key, initialData);
  const form = reactive({
    data: { ...savedData.value },
    errors: {},
    isValid: false
  });

  // Сохранение данных формы при изменении
  const updateField = (fieldName, value) => {
    form.data[fieldName] = value;
    savedData.value[fieldName] = value; // Автоматическое сохранение
    
    // Валидация
    if (validationRules[fieldName]) {
      let isValid = true;
      for (const rule of validationRules[fieldName]) {
        const error = rule(value, form.data);
        if (error) {
          form.errors[fieldName] = error;
          isValid = false;
          break;
        }
      }
      
      if (isValid) {
        delete form.errors[fieldName];
      }
    }
  };

  return {
    form,
    updateField,
    reset: () => {
      Object.keys(form.data).forEach(key => {
        form.data[key] = initialData[key];
        savedData.value[key] = initialData[key];
      });
      form.errors = {};
    }
  };
}
```

## Российские особенности и требования

### Соответствие 152-ФЗ

При создании composables для форм, работающих с персональными данными, необходимо учитывать требования 152-ФЗ:

```javascript
// composables/usePDForm.js
import { useForm } from './useForm';

export function usePDForm(initialData, validationRules = {}) {
  // Добавляем обязательные поля для персональных данных
  const extendedData = {
    ...initialData,
    consent: false,
    consentDate: null
  };
  
  const extendedRules = {
    ...validationRules,
    consent: [(value) => value === true || 'Требуется согласие на обработку персональных данных']
  };
  
  const formComposable = useForm(extendedData, extendedRules);
  
  const submitWithPD = async (submitFn) => {
    // Устанавливаем дату согласия
    formComposable.updateField('consentDate', new Date().toISOString());
    
    if (formComposable.validateAll()) {
      return await submitFn(formComposable.form.data);
    }
  };
  
  return {
    ...formComposable,
    submitWithPD
  };
}
```

## Лучшие практики

### Организация Composables

- Разделяйте логику по функциональности
- Используйте префиксы для именования (useForm, useValidation и т.д.)
- Документируйте параметры и возвращаемые значения
- Обеспечивайте типизацию (TypeScript)

### Тестирование Composables

```javascript
// tests/composables/useForm.spec.js
import { describe, it, expect } from 'vitest';
import { useForm } from '@/composables/useForm';
import { required } from '@/validators/rules';

describe('useForm', () => {
  it('should initialize with correct initial data', () => {
    const { form } = useForm({ name: 'John', email: '' });
    expect(form.data.name).toBe('John');
    expect(form.data.email).toBe('');
  });

  it('should validate required field', () => {
    const { form, updateField, validateAll } = useForm(
      { name: '' },
      { name: [required] }
    );
    
    updateField('name', '');
    validateAll();
    
    expect(form.errors.name).toBe('Обязательное поле');
    expect(form.isValid).toBe(false);
  });

  it('should update field value correctly', () => {
    const { form, updateField } = useForm({ name: '' });
    
    updateField('name', 'New Name');
    
    expect(form.data.name).toBe('New Name');
  });
});
```

## Заключение

Композиция состояния форм в Vue 2025 предоставляет мощный инструмент для создания переиспользуемых, гибких и масштабируемых решений для управления формами. Правильное использование composables позволяет значительно упростить разработку, улучшить качество кода и обеспечить соответствие требованиям безопасности и доступности, особенно при учете российских стандартов.

## См. также

- [[Управление-состоянием-форм]]
- [[Валидация-форм]]
- [[Внешние-библиотеки]]
- [[Оптимизация-форм]]
- [[Composition-API]]
- [[Типизация-в-Vue]]
- [[Тестирование-в-Vue]]