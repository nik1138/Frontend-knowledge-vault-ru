---
aliases: [Vue бенчмарки, Производительность Vue, Vue Performance Benchmarks]
tags: [vue, performance, benchmarking, testing]
---

# Бенчмарки

## Обзор

Бенчмарки (benchmarking) в контексте Vue.js приложений - это методы измерения производительности компонентов и приложений с целью выявления узких мест и оптимизации производительности. В 2025 году бенчмарки остаются важной частью разработки высокопроизводительных Vue приложений, особенно в условиях увеличения сложности современных интерфейсов.

## Типы бенчмарков

### 1. Компонентные бенчмарки

Компонентные бенчмарки измеряют производительность отдельных компонентов Vue. Это включает:

- Время монтирования компонента
- Время обновления при изменении данных
- Время разрушения компонента
- Потребление памяти компонентом

### 2. Сценарные бенчмарки

Сценарные бенчмарки тестируют производительность при выполнении реальных пользовательских сценариев:

- Открытие страницы
- Поиск и фильтрация данных
- Взаимодействие с формами
- Навигация между разделами

### 3. Макро-бенчмарки

Макро-бенчмарки оценивают производительность всего приложения:

- Время загрузки приложения
- Время до интерактивности
- Время выполнения сложных операций

## Инструменты для бенчмарков

### Vue Benchmark

Vue Benchmark - это специализированный инструмент для тестирования производительности Vue компонентов:

```javascript
import { benchmark } from '@vue/benchmark'

benchmark('List rendering', () => {
  const { mount } = createApp(ListComponent)
  const startTime = performance.now()
  
  mount('#app')
  
  return {
    time: performance.now() - startTime
  }
})
```

### Benchmark.js

Классический инструмент для бенчмарков, который можно использовать с Vue:

```javascript
const Benchmark = require('benchmark')

const suite = new Benchmark.Suite

suite
  .add('Vue component render', function() {
    // Тестируем рендер компонента
    const vm = new Vue({
      template: '<div>{{ message }}</div>',
      data: { message: 'Hello' }
    })
    vm.$mount()
  })
  .on('cycle', function(event) {
    console.log(String(event.target))
  })
  .run({ 'async': true })
```

### Web Performance API

Современные браузеры предоставляют встроенные API для измерения производительности:

```javascript
// Измерение времени выполнения
performance.mark('start-render')

// Код для измерения
const app = createApp(App)
app.mount('#app')

performance.mark('end-render')
performance.measure('render', 'start-render', 'end-render')

// Получение результатов
const measures = performance.getEntriesByName('render')
console.log('Render time:', measures[0].duration)
```

## Практические примеры бенчмарков

### Бенчмарк рендеринга списка

```javascript
import { createApp } from 'vue'

function benchmarkListRender() {
  const startTime = performance.now()
  
  const app = createApp({
    template: `
      <div>
        <div v-for="item in items" :key="item.id">
          {{ item.name }}
        </div>
      </div>
    `,
    data() {
      return {
        items: Array.from({ length: 1000 }, (_, i) => ({
          id: i,
          name: `Item ${i}`
        }))
      }
    }
  })
  
  app.mount('#benchmark-container')
  
  const endTime = performance.now()
  return endTime - startTime
}

// Запуск бенчмарка
const renderTime = benchmarkListRender()
console.log(`List render time: ${renderTime}ms`)
```

### Бенчмарк обновления данных

```javascript
import { createApp } from 'vue'

function benchmarkDataUpdate() {
  const app = createApp({
    template: `
      <div>{{ count }}</div>
    `,
    data() {
      return {
        count: 0
      }
    }
  })
  
  const vm = app.mount('#benchmark-container')
  
  const startTime = performance.now()
  
  // Обновление данных 1000 раз
  for (let i = 0; i < 1000; i++) {
    vm.count = i
  }
  
  const endTime = performance.now()
  return endTime - startTime
}

const updateTime = benchmarkDataUpdate()
console.log(`Data update time: ${updateTime}ms`)
```

## Автоматизация бенчмарков

### Использование GitHub Actions

Для автоматизации бенчмарков в CI/CD можно использовать GitHub Actions:

```yaml
name: Performance Benchmarks
on: [push, pull_request]
jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      - name: Run benchmarks
        run: npm run benchmark
      - name: Store benchmark results
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'customSmallerIsBetter'
          output-file-path: benchmark-results.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
```

### Сравнение результатов

Для отслеживания регрессий производительности важно сравнивать результаты бенчмарков:

```javascript
// benchmark-compare.js
const fs = require('fs')

function compareBenchmarks(current, previous) {
  const regressions = []
  
  for (const [name, currentResult] of Object.entries(current)) {
    const previousResult = previous[name]
    
    if (previousResult) {
      const change = ((currentResult - previousResult) / previousResult) * 100
      
      if (change > 5) { // Если ухудшение более 5%
        regressions.push({
          name,
          previous: previousResult,
          current: currentResult,
          change: `${change.toFixed(2)}%`
        })
      }
    }
  }
  
  return regressions
}

// Использование
const currentResults = JSON.parse(fs.readFileSync('current-benchmark.json', 'utf8'))
const previousResults = JSON.parse(fs.readFileSync('previous-benchmark.json', 'utf8'))

const regressions = compareBenchmarks(currentResults, previousResults)

if (regressions.length > 0) {
  console.log('Найдены регрессии производительности:')
  regressions.forEach(r => {
    console.log(`${r.name}: ${r.previous}ms → ${r.current}ms (${r.change})`)
  })
}
```

## Лучшие практики

### 1. Измерение в реалистичных условиях

- Используйте данные, близкие к реальным
- Тестируйте на разных устройствах и браузерах
- Учитывайте сетевые задержки и ограничения

### 2. Стабильность результатов

- Запускайте бенчмарки несколько раз и усредняйте результаты
- Избегайте фоновых процессов во время тестирования
- Используйте стабильную среду тестирования

### 3. Отслеживание изменений

- Сохраняйте результаты бенчмарков
- Сравнивайте результаты между сборками
- Настройте оповещения о регрессиях

## Российские особенности

В 2025 году в России при тестировании производительности Vue приложений важно учитывать:

- Разнообразие сетевых условий (от высокоскоростного 5G до медленных 3G в удаленных регионах)
- Широкий спектр используемых устройств (включая старые смартфоны и бюджетные планшеты)
- Локализованные требования к времени отклика (например, для банковских приложений)
- Регулирование и требования к хранению данных пользователей

## Связанные темы

- [[Тестирование-производительности-компонентов]]
- [[Веб-визиталс]]
- [[Оптимизация-метрик]]
- [[Мониторинг-производительности]]
- [[Vue компоненты]]
- [[Асинхронные компоненты]]

## Ключевые метрики

- First Contentful Paint (FCP)
- Largest Contentful Paint (LCP)
- Cumulative Layout Shift (CLS)
- Interaction to Next Paint (INP)
- Time to Interactive (TTI)

## Заключение

Бенчмарки - важный инструмент для обеспечения высокой производительности Vue приложений. Регулярное тестирование и анализ результатов позволяет выявлять проблемы до их попадания в продакшн и поддерживать высокое качество пользовательского опыта.