---
aliases: ["Vue Lifecycle", "Жизненный цикл", "Vue Component Lifecycle"]
tags: ["#vue", "#frontend", "#lifecycle", "#javascript", "#web-development"]
---

# Жизненный цикл компонента Vue

## Обзор

Жизненный цикл компонента Vue - это последовательность этапов, через которые проходит каждый компонент от создания до уничтожения. Понимание жизненного цикла критически важно для разработчиков, позволяя им выполнять действия в нужное время и эффективно управлять состоянием компонентов.

## Основные фазы жизненного цикла

### 1. Создание (Creation)

Эти хуки вызываются до того, как компонент будет смонтирован в DOM:

- `beforeCreate` - вызывается сразу после инициализации компонента, до настройки наблюдения за данными и событиями
- `created` - вызывается после настройки наблюдения за данными, вычисляемых свойств и методов

```javascript
export default {
  data() {
    return {
      message: 'Привет, Vue!'
    }
  },
  beforeCreate() {
    console.log('Компонент еще не создан, data и методы не инициализированы')
  },
  created() {
    console.log('Компонент создан, data и методы инициализированы')
    console.log(this.message) // 'Привет, Vue!'
  }
}
```

### 2. Монтирование (Mounting)

Эти хуки отвечают за создание DOM-элементов компонента:

- `beforeMount` - вызывается перед монтированием, после компиляции шаблона
- `mounted` - вызывается после монтирования, когда компонент вставлен в DOM

```javascript
export default {
  mounted() {
    // Хорошее место для выполнения запросов к API
    this.fetchUserData()
    
    // Инициализация сторонних библиотек
    this.initChart()
  },
  methods: {
    async fetchUserData() {
      try {
        const response = await fetch('/api/user')
        this.userData = await response.json()
      } catch (error) {
        console.error('Ошибка при получении данных пользователя:', error)
      }
    },
    initChart() {
      // Инициализация графиков, календарей и т.д.
    }
  }
}
```

### 3. Обновление (Updating)

Вызываются при изменении реактивных данных компонента:

- `beforeUpdate` - вызывается перед обновлением DOM
- `updated` - вызывается после обновления DOM

```javascript
export default {
  data() {
    return {
      count: 0
    }
  },
  beforeUpdate() {
    console.log('Компонент будет обновлен')
  },
  updated() {
    console.log('Компонент обновлен')
    // Избегайте изменения состояния здесь, чтобы предотвратить бесконечный цикл
  },
  methods: {
    increment() {
      this.count++
    }
  }
}
```

### 4. Уничтожение (Destruction)

Последние хуки жизненного цикла:

- `beforeUnmount` - вызывается перед размонтированием компонента
- `unmounted` - вызывается после уничтожения компонента

```javascript
export default {
  data() {
    return {
      intervalId: null
    }
  },
  mounted() {
    // Установка интервала, который нужно очистить
    this.intervalId = setInterval(() => {
      console.log('Прошла секунда')
    }, 1000)
  },
  beforeUnmount() {
    console.log('Компонент будет уничтожен')
  },
  unmounted() {
    // Очистка ресурсов
    if (this.intervalId) {
      clearInterval(this.intervalId)
    }
    
    // Удаление слушателей событий
    window.removeEventListener('resize', this.handleResize)
  }
}
```

## Практические рекомендации

### Использование Composition API

В Vue 3 рекомендуется использовать Composition API для управления жизненным циклом:

```javascript
import { onMounted, onUpdated, onUnmounted } from 'vue'

export default {
  setup() {
    onMounted(() => {
      console.log('Компонент смонтирован')
    })
    
    onUpdated(() => {
      console.log('Компонент обновлен')
    })
    
    onUnmounted(() => {
      console.log('Компонент уничтожен')
    })
    
    // Возвращаем реактивные данные и методы
    return {}
  }
}
```

### Частые ошибки и решения

1. **Забытая очистка ресурсов**:
   - Всегда очищайте интервалы, таймеры и слушатели событий в `beforeUnmount` или `unmounted`
   - Используйте `AbortController` для отмены сетевых запросов

2. **Выполнение асинхронных операций в неподходящем хуке**:
   - Выполняйте асинхронные запросы в `mounted`, а не в `created`
   - Избегайте изменения состояния в `updated` (может вызвать бесконечный цикл)

3. **Работа с DOM в неподходящем месте**:
   - Доступ к DOM только после `mounted`
   - Используйте `$nextTick` для доступа к обновленному DOM в `updated`

## Современные практики (2025)

С 2025 года в российской разработке на Vue все чаще используются следующие практики:

1. **Предпочтение Composition API** - более гибкий подход к логике компонентов
2. **Использование `<script setup>`** - сокращает boilerplate код
3. **Типизация с помощью TypeScript** - для лучшей поддержки кода

```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'

const count = ref(0)
let intervalId: number | null = null

onMounted(() => {
  intervalId = window.setInterval(() => {
    count.value++
  }, 1000)
})

onUnmounted(() => {
  if (intervalId) {
    clearInterval(intervalId)
  }
})
</script>
```

## Связанные темы

- [[Пользовательские-события]]
- [[Асинхронные-компоненты]]
- [[Vue Composition API]]
- [[Состояние-компонента]]

## Заключение

Понимание жизненного цикла компонентов Vue позволяет эффективно управлять состоянием приложения, предотвращать утечки памяти и правильно организовывать логику компонентов. В современной разработке (2025) рекомендуется использовать Composition API для более гибкой и масштабируемой архитектуры компонентов.