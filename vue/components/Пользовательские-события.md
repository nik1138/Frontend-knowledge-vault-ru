---
aliases: ["Custom Events", "Vue Events", "Пользовательские события", "События компонентов"]
tags: ["#vue", "#frontend", "#events", "#javascript", "#web-development", "#communication"]
---

# Пользовательские события в Vue

## Обзор

Пользовательские события в Vue позволяют компонентам взаимодействовать друг с другом, передавая информацию от дочернего компонента к родительскому. Это важный механизм для построения модульных и масштабируемых приложений.

## Основы пользовательских событий

### В Vue 2 и 3 (Options API)

Дочерний компонент может вызывать пользовательские события с помощью метода `$emit`:

```javascript
// ChildComponent.vue
export default {
  name: 'ChildComponent',
  data() {
    return {
      message: 'Привет от дочернего компонента!'
    }
  },
  methods: {
    sendMessage() {
      // Вызов пользовательского события с передачей данных
      this.$emit('message-sent', this.message, Date.now())
    }
  }
}
```

Родительский компонент может слушать эти события:

```javascript
// ParentComponent.vue
export default {
  name: 'ParentComponent',
  methods: {
    handleMessageSent(message, timestamp) {
      console.log('Получено сообщение:', message)
      console.log('Время получения:', new Date(timestamp))
    }
  }
}
```

В шаблоне родителя:

```html
<template>
  <ChildComponent @message-sent="handleMessageSent" />
</template>
```

### В Vue 3 (Composition API)

С 2025 года предпочтительно использовать Composition API для определения событий:

```vue
<!-- ChildComponent.vue -->
<template>
  <button @click="sendMessage">Отправить сообщение</button>
</template>

<script setup>
// Определение событий, которые компонент может вызывать
const emit = defineEmits(['message-sent', 'error'])

const message = ref('Привет от дочернего компонента!')

const sendMessage = () => {
  emit('message-sent', message.value, {
    timestamp: Date.now(),
    type: 'notification'
  })
}
</script>
```

Родительский компонент:

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    @message-sent="handleMessageSent" 
    @error="handleError"
  />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const receivedMessages = ref([])

const handleMessageSent = (message, metadata) => {
  receivedMessages.value.push({ message, timestamp: metadata.timestamp })
  console.log('Сообщение получено:', message)
}

const handleError = (error) => {
  console.error('Произошла ошибка:', error)
}
</script>
```

## Валидация событий

В Vue 3 можно валидировать пользовательские события:

```javascript
// В Options API
export default {
  emits: {
    // Простая проверка
    'message-sent': null,
    
    // Проверка с валидацией
    'update-count': (value) => {
      if (value && typeof value === 'number') {
        return true
      } else {
        console.warn('Неверный тип значения для update-count')
        return false
      }
    }
  }
}
```

```vue
<!-- В Composition API -->
<script setup>
const emit = defineEmits({
  'message-sent': (message) => {
    if (typeof message === 'string') {
      return true
    } else {
      console.warn('Сообщение должно быть строкой')
      return false
    }
  },
  'update-count': (count) => {
    if (typeof count === 'number' && count >= 0) {
      return true
    } else {
      console.warn('Count должен быть положительным числом')
      return false
    }
  }
})
</script>
```

## Практические примеры использования

### 1. Формы и валидация

```vue
<!-- FormField.vue -->
<template>
  <div class="form-field">
    <input 
      :value="modelValue" 
      @input="updateValue"
      @blur="validate"
      :class="{ error: hasError }"
    />
    <span v-if="hasError" class="error-message">{{ errorMessage }}</span>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  modelValue: String,
  rules: Array
})

const emit = defineEmits(['update:modelValue', 'validate'])

const hasError = ref(false)
const errorMessage = ref('')

const updateValue = (event) => {
  emit('update:modelValue', event.target.value)
  hasError.value = false
}

const validate = () => {
  if (props.rules) {
    for (const rule of props.rules) {
      if (!rule.test(props.modelValue)) {
        hasError.value = true
        errorMessage.value = rule.message
        emit('validate', { valid: false, message: rule.message })
        return
      }
    }
  }
  hasError.value = false
  emit('validate', { valid: true })
}
</script>
```

### 2. Кастомные элементы управления

```vue
<!-- ToggleSwitch.vue -->
<template>
  <div 
    class="toggle-switch" 
    :class="{ active: modelValue }"
    @click="toggle"
  >
    <div class="switch-handle"></div>
  </div>
</template>

<script setup>
const props = defineProps({
  modelValue: Boolean
})

const emit = defineEmits(['update:modelValue'])

const toggle = () => {
  emit('update:modelValue', !props.modelValue)
}
</script>
```

## Распространенные паттерны

### 1. События с несколькими параметрами

```javascript
// Вызов события с несколькими параметрами
emit('user-action', userId, actionType, additionalData)

// Прием в родительском компоненте
const handleUserAction = (userId, actionType, additionalData) => {
  // Обработка действия пользователя
}
```

### 2. События с объектами

```javascript
// Передача объекта с данными
emit('form-submitted', {
  formData: this.form,
  timestamp: Date.now(),
  userAgent: navigator.userAgent
})
```

### 3. События для глобальной коммуникации

```javascript
// Использование внешнего события для связи компонентов без родительско-дочерной связи
import { emitter } from '@/utils/eventBus'

// В компоненте A
emitter.emit('global-notification', { type: 'success', message: 'Операция выполнена' })

// В компоненте B
emitter.on('global-notification', (data) => {
  showNotification(data)
})
```

## Современные практики (2025)

С 2025 года в российской разработке на Vue рекомендуются следующие практики:

1. **Использование TypeScript для типизации событий**:

```vue
<script setup lang="ts">
interface Emits {
  (e: 'message-sent', message: string, timestamp: number): void
  (e: 'error', error: Error): void
}

const emit = defineEmits<Emits>()
</script>
```

2. **Использование директивы `v-model` для двусторонней связи**:

```vue
<!-- В дочернем компоненте -->
<template>
  <input 
    :value="modelValue" 
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>

<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>

<!-- В родительском компоненте -->
<ChildComponent v-model="inputValue" />
```

3. **Использование Composition API с `<script setup>`** для более чистого кода

## Связанные темы

- [[Жизненный-цикл-компонента]]
- [[Асинхронные-компоненты]]
- [[Vue Composition API]]
- [[Состояние-компонента]]
- [[Vuex и управление состоянием]]

## Заключение

Пользовательские события - мощный инструмент для связи компонентов в Vue. Они позволяют создавать гибкие и переиспользуемые компоненты, передавая данные от дочерних компонентов к родительским. В современной разработке (2025) рекомендуется использовать Composition API и TypeScript для лучшей типизации и поддержки кода.