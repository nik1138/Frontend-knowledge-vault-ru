---
aliases: ["Защита маршрутов Vue", "Аутентификация Vue", "Vue Router guards"]
tags: [vue, routing, security, authentication, authorization]
---

# Защита маршрутов в Vue.js

Защита маршрутов (route guards) в Vue.js позволяет контролировать доступ к определенным страницам приложения на основе аутентификации, авторизации и других условий. Это критически важный аспект безопасности современных веб-приложений.

## Типы route guards

Vue Router предоставляет несколько типов guards:

1. **Global Before Guards** - глобальные guards, выполняются перед каждым навигационным переходом
2. **Global Resolve Guards** - глобальные guards, выполняются перед завершением навигации
3. **Global After Hooks** - глобальные hooks, выполняются после завершения навигации
4. **Per-Route Guards** - guards, определенные для конкретного маршрута
5. **Component Guards** - guards, определенные внутри компонентов

## Глобальные guards

### Global Before Guards

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // ... маршруты
  ]
})

// Глобальный guard для проверки аутентификации
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Проверяем, требует ли маршрут аутентификации
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    // Перенаправляем на страницу входа
    next({
      name: 'Login',
      query: { redirect: to.fullPath }
    })
  } else if (to.meta.requiresAuth && authStore.isAuthenticated) {
    // Проверяем права доступа
    if (to.meta.role && !authStore.hasRole(to.meta.role)) {
      next({ name: 'Forbidden' })
    } else {
      next()
    }
  } else {
    next()
  }
})

// Global Resolve Guard
router.beforeResolve(async (to, from, next) => {
  // Выполняется перед завершением навигации
  // Полезен для асинхронной загрузки данных
  if (to.meta.requiresUserData) {
    try {
      await loadUserData()
      next()
    } catch (error) {
      next({ name: 'Error' })
    }
  } else {
    next()
  }
})

// Global After Hook
router.afterEach((to, from) => {
  // Выполняется после завершения навигации
  // Полезен для аналитики, обновления заголовков и т.д.
  document.title = to.meta.title || 'Vue App'
})
```

## Защита конкретных маршрутов

```javascript
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: Login,
    meta: { 
      requiresGuest: true, // Только для неаутентифицированных пользователей
      layout: 'auth'
    }
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: Dashboard,
    meta: { 
      requiresAuth: true,
      title: 'Панель управления'
    }
  },
  {
    path: '/admin',
    name: 'Admin',
    component: AdminPanel,
    meta: { 
      requiresAuth: true,
      role: 'admin',
      permissions: ['manage_users', 'view_reports']
    }
  },
  {
    path: '/profile',
    name: 'Profile',
    component: Profile,
    meta: { 
      requiresAuth: true,
      title: 'Профиль пользователя'
    }
  }
]
```

## Практическая реализация аутентификации

### Store для управления аутентификацией

```javascript
// stores/auth.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import api from '@/services/api'

export const useAuthStore = defineStore('auth', () => {
  const user = ref(null)
  const token = ref(localStorage.getItem('token'))
  const loading = ref(false)
  
  const isAuthenticated = computed(() => !!token.value)
  const userRole = computed(() => user.value?.role)
  
  const login = async (credentials) => {
    loading.value = true
    try {
      const response = await api.post('/auth/login', credentials)
      token.value = response.data.token
      user.value = response.data.user
      localStorage.setItem('token', token.value)
      api.defaults.headers.common['Authorization'] = `Bearer ${token.value}`
    } finally {
      loading.value = false
    }
  }
  
  const logout = () => {
    token.value = null
    user.value = null
    localStorage.removeItem('token')
    delete api.defaults.headers.common['Authorization']
  }
  
  const hasRole = (role) => {
    return userRole.value === role
  }
  
  const hasPermission = (permission) => {
    return user.value?.permissions?.includes(permission)
  }
  
  const checkPermissions = (requiredPermissions) => {
    if (!Array.isArray(requiredPermissions)) {
      requiredPermissions = [requiredPermissions]
    }
    return requiredPermissions.every(perm => hasPermission(perm))
  }
  
  return {
    user,
    token,
    loading,
    isAuthenticated,
    userRole,
    login,
    logout,
    hasRole,
    hasPermission,
    checkPermissions
  }
})
```

### Улучшенный guard с проверкой прав

```javascript
// router/guards.js
import { useAuthStore } from '@/stores/auth'

export const authGuard = async (to, from, next) => {
  const authStore = useAuthStore()
  
  // Проверяем, требует ли маршрут аутентификации
  if (to.meta.requiresAuth) {
    // Если пользователь не аутентифицирован
    if (!authStore.isAuthenticated) {
      // Сохраняем путь для редиректа после входа
      next({
        name: 'Login',
        query: { redirect: to.fullPath }
      })
      return
    }
    
    // Проверяем роль, если указана
    if (to.meta.role && !authStore.hasRole(to.meta.role)) {
      next({ name: 'Forbidden' })
      return
    }
    
    // Проверяем разрешения, если указаны
    if (to.meta.permissions && !authStore.checkPermissions(to.meta.permissions)) {
      next({ name: 'Forbidden' })
      return
    }
  }
  
  // Проверяем, требует ли маршрут гостевого состояния (например, страница входа)
  if (to.meta.requiresGuest && authStore.isAuthenticated) {
    next({ name: 'Dashboard' })
    return
  }
  
  next()
}

// Регистрируем guard в роутере
router.beforeEach(authGuard)
```

## Component Guards

Component guards определяются непосредственно в компонентах:

```vue
<template>
  <div class="admin-panel">
    <h1>Административная панель</h1>
    <!-- Содержимое -->
  </div>
</template>

<script>
import { useAuthStore } from '@/stores/auth'

export default {
  name: 'AdminPanel',
  async beforeRouteEnter(to, from, next) {
    // Выполняется до входа в маршрут
    const authStore = useAuthStore()
    
    if (authStore.isAuthenticated && authStore.hasRole('admin')) {
      next()
    } else {
      next({ name: 'Forbidden' })
    }
  },
  
  async beforeRouteUpdate(to, from, next) {
    // Выполняется при обновлении параметров маршрута
    const authStore = useAuthStore()
    
    if (to.meta.requiresAuth && !authStore.isAuthenticated) {
      next({ name: 'Login' })
    } else {
      next()
    }
  },
  
  beforeRouteLeave(to, from, next) {
    // Выполняется при покидании маршрута
    // Например, для подтверждения выхода
    const answer = window.confirm('Вы уверены, что хотите покинуть страницу?')
    if (answer) {
      next()
    } else {
      next(false)
    }
  }
}
</script>
```

## Composition API guards

В Composition API можно использовать специальные хуки:

```vue
<template>
  <div class="profile">
    <h1>Профиль пользователя</h1>
    <!-- Содержимое -->
  </div>
</template>

<script>
import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

export default {
  name: 'UserProfile',
  setup() {
    // Guard при обновлении маршрута
    onBeforeRouteUpdate(async (to, from) => {
      const authStore = useAuthStore()
      
      if (to.params.id !== from.params.id) {
        // Проверяем доступ к новому профилю
        if (to.params.id !== authStore.user.id) {
          // Проверяем права на просмотр чужого профиля
          if (!authStore.hasPermission('view_other_profiles')) {
            return false // Отменяем переход
          }
        }
      }
    })
    
    // Guard при покидании маршрута
    onBeforeRouteLeave((to, from) => {
      const answer = window.confirm('Сохранить изменения перед выходом?')
      if (!answer) return false
    })
    
    return {}
  }
}
</script>
```

## Защита динамических маршрутов

```javascript
// router/index.js
router.beforeEach(async (to, from, next) => {
  if (to.name === 'UserProfile' && to.params.id) {
    try {
      // Проверяем, может ли текущий пользователь просматривать этот профиль
      const profile = await api.get(`/users/${to.params.id}`)
      
      if (profile.data.visibility === 'private') {
        const authStore = useAuthStore()
        if (!authStore.isAuthenticated || 
            (authStore.user.id !== profile.data.id && 
             !authStore.hasRole('admin'))) {
          next({ name: 'Forbidden' })
          return
        }
      }
    } catch (error) {
      next({ name: 'NotFound' })
      return
    }
  }
  
  next()
})
```

## Обработка ошибок аутентификации

```javascript
// services/api.js
import axios from 'axios'

const api = axios.create({
  baseURL: process.env.VUE_APP_API_URL
})

// Перехватчик для обработки 401 ошибок
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      // Токен истек или недействителен
      const authStore = useAuthStore()
      authStore.logout()
      
      // Перенаправляем на страницу входа
      router.push({ 
        name: 'Login',
        query: { 
          redirect: router.currentRoute.value.fullPath,
          expired: 'true'
        }
      })
    }
    return Promise.reject(error)
  }
)

export default api
```

## Практические рекомендации

> [!TIP]
> В российских реалиях 2025 года при реализации защиты маршрутов:
> - Обязательно используйте HTTPS для передачи токенов аутентификации
> - Реализуйте механизм обновления токенов
> - Проверяйте права доступа как на клиенте, так и на сервере
> - Обрабатывайте случаи истечения срока действия токенов
> - Предусмотрите возможность "тихого" обновления токенов

### Обновление токенов

```javascript
// services/auth.js
import api from './api'
import { useAuthStore } from '@/stores/auth'

let isRefreshing = false
let failedQueue = []

const processQueue = (error, token = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error)
    } else {
      prom.resolve(token)
    }
  })
  
  failedQueue = []
}

export const refreshToken = async () => {
  if (isRefreshing) {
    return new Promise((resolve, reject) => {
      failedQueue.push({ resolve, reject })
    })
  }
  
  isRefreshing = true
  const authStore = useAuthStore()
  
  try {
    const response = await api.post('/auth/refresh', {
      refreshToken: localStorage.getItem('refreshToken')
    })
    
    const { token } = response.data
    authStore.token = token
    localStorage.setItem('token', token)
    api.defaults.headers.common['Authorization'] = `Bearer ${token}`
    
    processQueue(null, token)
    return token
  } catch (error) {
    authStore.logout()
    processQueue(error, null)
    throw error
  } finally {
    isRefreshing = false
  }
}
```

## Страницы ошибок доступа

```vue
<!-- views/Forbidden.vue -->
<template>
  <div class="error-page">
    <h1>403 - Доступ запрещен</h1>
    <p>У вас нет прав для доступа к этой странице.</p>
    <router-link to="/dashboard">Вернуться на главную</router-link>
  </div>
</template>

<script>
export default {
  name: 'Forbidden'
}
</script>
```

## Тестирование защиты маршрутов

```javascript
// tests/unit/route-guards.spec.js
import { mount } from '@vue/test-utils'
import { createRouter, createWebHistory } from 'vue-router'
import { createTestingPinia } from '@pinia/testing'
import { setActivePinia } from 'pinia'
import { beforeEach, describe, expect, it, vi } from 'vitest'

describe('Route Guards', () => {
  beforeEach(() => {
    setActivePinia(createTestingPinia())
  })
  
  it('должен перенаправить неаутентифицированного пользователя', async () => {
    const router = createRouter({
      history: createWebHistory(),
      routes: [
        {
          path: '/admin',
          name: 'Admin',
          component: { template: '<div>Admin</div>' },
          meta: { requiresAuth: true }
        },
        {
          path: '/login',
          name: 'Login',
          component: { template: '<div>Login</div>' }
        }
      ]
    })
    
    router.beforeEach(authGuard)
    
    await router.push('/admin')
    expect(router.currentRoute.value.name).toBe('Login')
  })
})
```

## Связанные темы

- [[Основы-роутинга]]
- [[Динамические-маршруты]]
- [[Вложенные-маршруты]]
- [[Vue Composition API]]
- [[Vue Pinia store]]

## Заключение

Защита маршрутов является критически важным аспектом безопасности веб-приложений. Правильная реализация route guards позволяет контролировать доступ к защищенным ресурсам, обеспечивать безопасность данных пользователей и предотвращать несанкционированный доступ к функционалу приложения.