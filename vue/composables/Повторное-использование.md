---
aliases: ["Повторное использование Composables", "Переиспользование логики", "Shared Logic Vue"]
tags: ["#vue", "#composables", "#reuse", "#architecture", "#frontend-development"]
---

# Повторное использование логики с Composables в Vue 3

## Введение

Одним из ключевых преимуществ системы Composables в Vue 3 является возможность повторного использования логики между компонентами. Это особенно актуально для российских разработчиков, которые часто сталкиваются с задачами создания масштабируемых приложений с высокой степенью переиспользования компонентов и бизнес-логики.

## Принципы повторного использования

### 1. Инкапсуляция состояния

Каждый Composable должен инкапсулировать свое состояние, чтобы избежать конфликтов между компонентами:

```javascript
// composables/useCounter.js
import { ref } from 'vue'

export function useCounter(initialValue = 0) {
  // Каждый вызов useCounter создает новую реактивную ссылку
  const count = ref(initialValue)
  const increment = () => count.value++
  const decrement = () => count.value--
  
  return { count, increment, decrement }
}
```

### 2. Независимость экземпляров

Каждый компонент получает свою копию состояния:

```vue
<!-- CounterA.vue -->
<template>
  <div>
    <p>Счетчик A: {{ count }}</p>
    <button @click="increment">+</button>
  </div>
</template>

<script setup>
import { useCounter } from '@/composables/useCounter'

const { count, increment } = useCounter(0)
</script>
```

```vue
<!-- CounterB.vue -->
<template>
  <div>
    <p>Счетчик B: {{ count }}</p>
    <button @click="increment">+</button>
  </div>
</template>

<script setup>
import { useCounter } from '@/composables/useCounter'

const { count, increment } = useCounter(10)
</script>
```

## Практические примеры повторного использования

### 1. Управление формой

```javascript
// composables/useForm.js
import { reactive, computed } from 'vue'

export function useForm(initialValues, validationRules = {}) {
  const form = reactive({ ...initialValues })
  const errors = reactive({})
  const isSubmitting = ref(false)

  const isValid = computed(() => Object.keys(errors).length === 0)

  const validate = () => {
    // Логика валидации
    for (const [field, rules] of Object.entries(validationRules)) {
      errors[field] = []
      
      for (const rule of rules) {
        const result = rule(form[field])
        if (!result.isValid) {
          errors[field].push(result.message)
        }
      }
    }
    
    return isValid.value
  }

  const reset = () => {
    Object.assign(form, initialValues)
    Object.keys(errors).forEach(key => delete errors[key])
  }

  return {
    form,
    errors,
    isValid,
    isSubmitting,
    validate,
    reset
  }
}
```

### 2. Управление данными с API

```javascript
// composables/useApiResource.js
import { ref, onMounted } from 'vue'

export function useApiResource(apiFunction, resourceId = null) {
  const data = ref(null)
  const loading = ref(false)
  const error = ref(null)

  const fetchResource = async () => {
    loading.value = true
    error.value = null

    try {
      const result = await apiFunction(resourceId)
      data.value = result
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }

  onMounted(() => {
    if (resourceId) {
      fetchResource()
    }
  })

  return {
    data,
    loading,
    error,
    fetchResource
  }
}
```

### 3. Управление пользовательскими настройками

```javascript
// composables/useUserPreferences.js
import { ref, watch } from 'vue'

export function useUserPreferences() {
  const preferences = ref({
    theme: 'light',
    language: 'ru',
    notifications: true
  })

  // Загрузка предпочтений из localStorage
  const loadPreferences = () => {
    const saved = localStorage.getItem('userPreferences')
    if (saved) {
      preferences.value = JSON.parse(saved)
    }
  }

  // Сохранение предпочтений
  const savePreferences = () => {
    localStorage.setItem('userPreferences', JSON.stringify(preferences.value))
  }

  // Отслеживание изменений и автоматическое сохранение
  watch(preferences, savePreferences, { deep: true })

  // Загрузка при инициализации
  loadPreferences()

  return {
    preferences,
    updatePreference: (key, value) => {
      preferences.value[key] = value
    }
  }
}
```

## Повторное использование между разными типами компонентов

### Формы и модальные окна

```javascript
// composables/useFormModal.js
import { ref } from 'vue'
import { useForm } from './useForm'

export function useFormModal(formConfig) {
  const isOpen = ref(false)
  const { form, errors, validate, reset } = useForm(formConfig.initialValues)

  const open = () => {
    reset()
    isOpen.value = true
  }

  const close = () => {
    isOpen.value = false
    reset()
  }

  const submit = async () => {
    if (validate()) {
      await formConfig.onSubmit(form)
      close()
    }
  }

  return {
    isOpen,
    form,
    errors,
    open,
    close,
    submit
  }
}
```

### Списки и фильтрация

```javascript
// composables/useListWithFilters.js
import { ref, computed } from 'vue'

export function useListWithFilters(items, filterConfig = {}) {
  const allItems = ref([...items])
  const filters = ref({})

  // Применение фильтров
  const filteredItems = computed(() => {
    return allItems.value.filter(item => {
      return Object.entries(filters.value).every(([key, value]) => {
        if (!value) return true
        return item[key]?.toString().toLowerCase().includes(value.toLowerCase())
      })
    })
  })

  const updateFilter = (key, value) => {
    filters.value[key] = value
  }

  const resetFilters = () => {
    Object.keys(filters.value).forEach(key => {
      filters.value[key] = ''
    })
  }

  return {
    items: filteredItems,
    filters,
    updateFilter,
    resetFilters
  }
}
```

## Повторное использование в крупных приложениях

### Модульная архитектура

```javascript
// composables/auth/useAuth.js
import { ref } from 'vue'
import { useLocalStorage } from '../utils/useLocalStorage'

export function useAuth() {
  const { getItem, setItem, removeItem } = useLocalStorage()
  const user = ref(null)
  const isAuthenticated = ref(false)

  const login = async (credentials) => {
    // Логика аутентификации
    const userData = await authenticate(credentials)
    user.value = userData
    isAuthenticated.value = true
    setItem('user', JSON.stringify(userData))
  }

  const logout = () => {
    user.value = null
    isAuthenticated.value = false
    removeItem('user')
  }

  // Загрузка данных пользователя при инициализации
  const init = () => {
    const savedUser = getItem('user')
    if (savedUser) {
      user.value = JSON.parse(savedUser)
      isAuthenticated.value = true
    }
  }

  init()

  return {
    user,
    isAuthenticated,
    login,
    logout
  }
}
```

### Композиция Composables

```javascript
// composables/useUserProfile.js
import { useAuth } from './auth/useAuth'
import { useApiResource } from './useApiResource'

export function useUserProfile() {
  const { user: authUser, isAuthenticated } = useAuth()
  const { data: profile, loading, error, fetchResource } = useApiResource(
    fetchUserProfile,
    computed(() => isAuthenticated.value ? authUser.value?.id : null)
  )

  return {
    profile,
    loading,
    error,
    isAuthenticated,
    refreshProfile: fetchResource
  }
}
```

## Рекомендации российских разработчиков

### 1. Организация структуры

- Группируйте Composables по функциональности
- Используйте папки для логической группировки
- Поддерживайте единообразие в названиях

### 2. Документирование

```javascript
/**
 * Composable для управления фильтрами списка
 * Используется в компонентах списка товаров, пользователей и т.д.
 * 
 * @param {Array} items - Исходный массив элементов
 * @param {Object} defaultFilters - Объект с фильтрами по умолчанию
 * @returns {Object} Объект с отфильтрованными элементами и методами управления фильтрами
 */
export function useListFilters(items, defaultFilters) {
  // реализация
}
```

### 3. Тестирование

Обеспечьте тестирование Composables отдельно от компонентов:

```javascript
// tests/composables/useListFilters.test.js
import { useListFilters } from '@/composables/useListFilters'

describe('useListFilters', () => {
  test('фильтрует элементы по заданным критериям', () => {
    const items = [
      { name: 'Товар 1', category: 'электроника' },
      { name: 'Товар 2', category: 'одежда' }
    ]
    
    const { items: filtered, updateFilter } = useListFilters(items, {})
    updateFilter('category', 'электроника')
    
    expect(filtered.value).toHaveLength(1)
    expect(filtered.value[0].name).toBe('Товар 1')
  })
})
```

## Заключение

Повторное использование логики через Composables в Vue 3 значительно упрощает разработку и поддержку приложений. Правильная организация и архитектура Composables позволяет создавать гибкие и масштабируемые приложения, что особенно важно в условиях российской разработки, где часто требуется быстрая адаптация к изменяющимся требованиям.

## См. также

- [[Создание-кастомных-хуков]]
- [[Тестирование-Composables]]
- [[Реактивные-объявления]]
- [[Состояние-формы]]
- [[Стейт-менеджмент]]