---
aliases: [Тестирование обработки ошибок, Тесты обработки ошибок, Проверка обработки ошибок]
tags: [vue, error-handling-testing, testing, frontend, javascript]
---

# Тестирование обработки ошибок в Vue.js

## Введение

Тестирование обработки ошибок в Vue.js - это критический аспект обеспечения надежности и стабильности веб-приложений. В условиях российской разработки 2025 года, когда требования к качеству и надежности приложений становятся все более строгими, тестирование сценариев ошибок позволяет убедиться, что приложение корректно реагирует на различные сбои и предоставляет пользователям адекватный пользовательский опыт даже в случае проблем.

## Зачем тестировать обработку ошибок

1. **Обеспечение стабильности** - приложение должно продолжать работать при ошибках
2. **Проверка UX при ошибках** - пользователь должен получать понятные сообщения
3. **Валидация систем логирования** - ошибки должны быть корректно зафиксированы
4. **Проверка механизмов восстановления** - приложение должно восстанавливаться после ошибок
5. **Соответствие требованиям** - во многих системах требуется корректная обработка ошибок

## Подходы к тестированию обработки ошибок

### Модульное тестирование

Тестирование обработки ошибок на уровне отдельных компонентов:

```javascript
// tests/unit/components/DataComponent.spec.js
import { mount } from '@vue/test-utils'
import DataComponent from '@/components/DataComponent.vue'
import { vi, describe, it, expect, beforeEach } from 'vitest'

describe('DataComponent.vue - Обработка ошибок', () => {
  let wrapper
  
  beforeEach(() => {
    // Сброс любых моков перед каждым тестом
    vi.clearAllMocks()
  })
  
  it('должен отобразить сообщение об ошибке при неудачной загрузке данных', async () => {
    // Мокаем fetch для симуляции ошибки
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))
    
    wrapper = mount(DataComponent)
    
    // Ожидаем, что компонент пытается загрузить данные
    await wrapper.vm.$nextTick()
    
    // Проверяем, что отображается сообщение об ошибке
    expect(wrapper.find('.error-message').exists()).toBe(true)
    expect(wrapper.find('.error-message').text()).toContain('Network error')
  })
  
  it('должен вызвать глобальный обработчик ошибок при исключении', async () => {
    const errorHandlerSpy = vi.fn()
    
    // Устанавливаем глобальный обработчик ошибок
    const originalErrorHandler = globalThis.console.error
    globalThis.console.error = errorHandlerSpy
    
    // Мокаем fetch для симуляции ошибки
    global.fetch = vi.fn().mockRejectedValue(new Error('Test error'))
    
    wrapper = mount(DataComponent)
    await wrapper.vm.$nextTick()
    
    // Проверяем, что глобальный обработчик был вызван
    expect(errorHandlerSpy).toHaveBeenCalledWith(
      expect.stringContaining('Test error')
    )
    
    // Восстанавливаем оригинальный обработчик
    globalThis.console.error = originalErrorHandler
  })
  
  it('должен корректно обработать ошибку валидации', async () => {
    // Мокаем функцию, которая выбрасывает ошибку валидации
    const validationError = new Error('Validation failed')
    validationError.name = 'ValidationError'
    
    global.fetch = vi.fn().mockImplementation(() => {
      throw validationError
    })
    
    wrapper = mount(DataComponent)
    await wrapper.vm.$nextTick()
    
    // Проверяем, что отображается специфическое сообщение для ошибки валидации
    expect(wrapper.find('.validation-error').exists()).toBe(true)
  })
})
```

### Тестирование с использованием Error Boundary

```javascript
// tests/unit/components/ErrorBoundary.spec.js
import { mount } from '@vue/test-utils'
import ErrorBoundary from '@/components/ErrorBoundary.vue'
import FaultyComponent from '@/components/FaultyComponent.vue'

describe('ErrorBoundary.vue', () => {
  it('должен перехватить ошибку от дочернего компонента', async () => {
    // Мокаем компонент, который выбрасывает ошибку
    const mockComponent = {
      template: '<div>{{ throw_error() }}</div>',
      methods: {
        throw_error() {
          throw new Error('Test error from child')
        }
      }
    }
    
    const wrapper = mount(ErrorBoundary, {
      slots: {
        default: mockComponent
      }
    })
    
    // Ожидаем, что ошибка будет перехвачена
    await wrapper.vm.$nextTick()
    
    // Проверяем, что отображается fallback UI
    expect(wrapper.find('.error-boundary-fallback').exists()).toBe(true)
    expect(wrapper.find('.error-boundary-fallback h2').text()).toBe('Произошла ошибка')
  })
  
  it('должен предоставить возможность повторной попытки', async () => {
    const mockComponent = {
      template: '<div @click="throw_error">Click me</div>',
      methods: {
        throw_error() {
          throw new Error('Test error')
        }
      }
    }
    
    const wrapper = mount(ErrorBoundary, {
      slots: {
        default: mockComponent
      }
    })
    
    // Вызываем ошибку
    await wrapper.find('div').trigger('click')
    await wrapper.vm.$nextTick()
    
    // Проверяем, что отображается кнопка повтора
    const retryButton = wrapper.find('.retry-button')
    expect(retryButton.exists()).toBe(true)
    
    // Нажимаем кнопку повтора
    await retryButton.trigger('click')
    
    // Проверяем, что fallback UI исчез
    expect(wrapper.find('.error-boundary-fallback').exists()).toBe(false)
  })
})
```

## Тестирование асинхронных ошибок

### Тестирование ошибок в Promise

```javascript
// tests/unit/composables/useDataFetching.spec.js
import { mount } from '@vue/test-utils'
import { ref, nextTick } from 'vue'
import { describe, it, expect, vi } from 'vitest'

// Тестируемый composable
function useDataFetching() {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(false)
  
  const fetchData = async (url) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      data.value = await response.json()
    } catch (err) {
      error.value = err
    } finally {
      loading.value = false
    }
  }
  
  return { data, error, loading, fetchData }
}

// Компонент для тестирования
const TestComponent = {
  template: `
    <div>
      <div v-if="loading">Loading...</div>
      <div v-if="error" class="error">{{ error.message }}</div>
      <div v-if="data" class="data">{{ JSON.stringify(data) }}</div>
      <button @click="fetchData('/api/data')" class="fetch-btn">Fetch</button>
    </div>
  `,
  setup() {
    const { data, error, loading, fetchData } = useDataFetching()
    return { data, error, loading, fetchData }
  }
}

describe('useDataFetching composable', () => {
  it('должен корректно обрабатывать ошибки сети', async () => {
    // Мокаем fetch для возврата ошибки
    const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'))
    global.fetch = mockFetch
    
    const wrapper = mount(TestComponent)
    
    // Вызываем загрузку данных
    await wrapper.find('.fetch-btn').trigger('click')
    
    // Ждем завершения асинхронной операции
    await nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))
    
    // Проверяем, что отображается ошибка
    expect(wrapper.find('.error').exists()).toBe(true)
    expect(wrapper.find('.error').text()).toContain('Network error')
  })
  
  it('должен обрабатывать HTTP ошибки', async () => {
    // Мокаем fetch для возврата HTTP ошибки
    const mockFetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 500,
      json: () => Promise.resolve({ error: 'Server error' })
    })
    global.fetch = mockFetch
    
    const wrapper = mount(TestComponent)
    
    await wrapper.find('.fetch-btn').trigger('click')
    await nextTick()
    await new Promise(resolve => setTimeout(resolve, 0))
    
    expect(wrapper.find('.error').exists()).toBe(true)
    expect(wrapper.find('.error').text()).toContain('HTTP error! status: 500')
  })
})
```

## Интеграционное тестирование

### Тестирование с реальными API

```javascript
// tests/integration/error-handling.spec.js
import { mount } from '@vue/test-utils'
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import MainApp from '@/App.vue'

describe('Интеграционное тестирование обработки ошибок', () => {
  let originalFetch
  
  beforeEach(() => {
    originalFetch = global.fetch
    global.fetch = vi.fn()
  })
  
  afterEach(() => {
    global.fetch = originalFetch
    vi.clearAllMocks()
  })
  
  it('должен корректно обрабатывать ошибки при загрузке конфигурации', async () => {
    // Мокаем ошибку при загрузке конфигурации
    global.fetch.mockImplementation((url) => {
      if (url.includes('/config')) {
        return Promise.reject(new Error('Config load failed'))
      }
      return Promise.resolve(new Response(JSON.stringify({})))
    })
    
    const wrapper = mount(MainApp)
    
    // Ждем, пока приложение попытается загрузить конфигурацию
    await new Promise(resolve => setTimeout(resolve, 100))
    
    // Проверяем, что приложение продолжает работать
    expect(wrapper.vm.$data).toBeDefined()
    
    // Проверяем, что ошибка была зафиксирована
    // (предполагаем, что ошибка логируется в консоль или в хранилище)
    expect(console.error).toHaveBeenCalled()
  })
  
  it('должен восстанавливаться после сетевой ошибки', async () => {
    // Сначала возвращаем ошибку, затем успешный ответ
    let callCount = 0
    global.fetch.mockImplementation(() => {
      callCount++
      if (callCount === 1) {
        return Promise.reject(new Error('First call failed'))
      }
      return Promise.resolve(new Response(
        JSON.stringify({ data: 'success' }),
        { status: 200 }
      ))
    })
    
    const wrapper = mount(MainApp)
    
    // Выполняем операцию, которая вызывает fetch
    await wrapper.vm.$nextTick()
    
    // Имитируем повторную попытку
    // (предполагаем, что в приложении реализована логика повторных попыток)
    await new Promise(resolve => setTimeout(resolve, 200))
    
    // Проверяем, что вторая попытка прошла успешно
    expect(callCount).toBe(2)
  })
})
```

## Тестирование глобальных обработчиков ошибок

### Тестирование errorHandler

```javascript
// tests/unit/global-error-handler.spec.js
import { createApp } from 'vue'
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

describe('Глобальный обработчик ошибок', () => {
  let errorHandlerSpy
  let originalErrorHandler
  let app
  
  beforeEach(() => {
    errorHandlerSpy = vi.fn()
    originalErrorHandler = console.error
    console.error = vi.fn()
    
    app = createApp({
      template: '<div>{{ throwError() }}</div>',
      methods: {
        throwError() {
          throw new Error('Test global error')
        }
      }
    })
    
    // Устанавливаем глобальный обработчик
    app.config.errorHandler = errorHandlerSpy
  })
  
  afterEach(() => {
    console.error = originalErrorHandler
  })
  
  it('должен вызвать глобальный обработчик при ошибке в компоненте', () => {
    expect(() => {
      app.mount(document.createElement('div'))
    }).not.toThrow()
    
    // Проверяем, что глобальный обработчик был вызван
    expect(errorHandlerSpy).toHaveBeenCalledWith(
      expect.any(Error),
      expect.anything(), // instance
      expect.stringContaining('render function')
    )
  })
  
  it('должен передавать правильную информацию об ошибке', () => {
    const errorComponent = {
      template: '<div>{{ brokenMethod() }}</div>',
      methods: {
        brokenMethod() {
          throw new Error('Component error')
        }
      }
    }
    
    const localApp = createApp(errorComponent)
    const spy = vi.fn()
    localApp.config.errorHandler = spy
    
    localApp.mount(document.createElement('div'))
    
    // Проверяем аргументы, переданные в обработчик
    const [error, instance, info] = spy.mock.calls[0]
    
    expect(error.message).toBe('Component error')
    expect(instance).toBeDefined()
    expect(info).toContain('render function')
  })
})
```

## Тестирование с использованием специфических инструментов

### Использование Testing Library

```javascript
// tests/unit/testing-library-error-handling.spec.js
import { render, screen, waitFor } from '@testing-library/vue'
import userEvent from '@testing-library/user-event'
import ErrorProneComponent from '@/components/ErrorProneComponent.vue'

describe('Testing Library - Обработка ошибок', () => {
  it('должен отобразить сообщение об ошибке при нажатии кнопки', async () => {
    const user = userEvent.setup()
    
    render(ErrorProneComponent)
    
    // Находим и нажимаем кнопку, которая вызывает ошибку
    const errorButton = screen.getByRole('button', { name: /ошибка/i })
    await user.click(errorButton)
    
    // Ожидаем появления сообщения об ошибке
    await waitFor(() => {
      expect(screen.getByText(/произошла ошибка/i)).toBeInTheDocument()
    })
  })
  
  it('должен предоставить возможность повторной попытки', async () => {
    const user = userEvent.setup()
    
    render(ErrorProneComponent)
    
    // Вызываем ошибку
    const errorButton = screen.getByRole('button', { name: /ошибка/i })
    await user.click(errorButton)
    
    // Ждем сообщения об ошибке
    await screen.findByText(/произошла ошибка/i)
    
    // Находим и нажимаем кнопку повтора
    const retryButton = screen.getByRole('button', { name: /повторить/i })
    await user.click(retryButton)
    
    // Проверяем, что сообщение об ошибке исчезло
    await waitFor(() => {
      expect(screen.queryByText(/произошла ошибка/i)).not.toBeInTheDocument()
    })
  })
})
```

## Тестирование производительности при ошибках

```javascript
// tests/performance/error-handling-performance.spec.js
import { mount } from '@vue/test-utils'
import { describe, it, expect } from 'vitest'
import HeavyComponent from '@/components/HeavyComponent.vue'

describe('Производительность при обработке ошибок', () => {
  it('не должен значительно замедляться при частых ошибках', async () => {
    const start = performance.now()
    
    // Мокаем fetch для частых ошибок
    global.fetch = vi.fn().mockRejectedValue(new Error('Frequent error'))
    
    const wrapper = mount(HeavyComponent)
    
    // Вызываем операции, которые могут привести к ошибке
    for (let i = 0; i < 100; i++) {
      try {
        await wrapper.vm.someAsyncOperation()
      } catch (e) {
        // Ошибки обрабатываются нормально
      }
    }
    
    const end = performance.now()
    const duration = end - start
    
    // Проверяем, что время выполнения в пределах разумных пределов
    expect(duration).toBeLessThan(2000) // Меньше 2 секунд для 100 операций
  })
  
  it('должен корректно очищать ресурсы при ошибках', () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Cleanup test'))
    
    const wrapper = mount(HeavyComponent)
    
    // Вызываем ошибку
    wrapper.vm.triggerError()
    
    // Проверяем, что ресурсы корректно очищаются
    expect(wrapper.vm.activeRequests).toBe(0)
    expect(wrapper.vm.eventListeners).toBe(0)
  })
})
```

## Практические рекомендации по тестированию

### Типы ошибок для тестирования

```javascript
// utils/testErrorTypes.js
export const ErrorTypes = {
  NETWORK: {
    name: 'NetworkError',
    message: 'Network error',
    mock: () => new Error('Network error')
  },
  VALIDATION: {
    name: 'ValidationError',
    message: 'Validation failed',
    mock: () => {
      const error = new Error('Validation failed')
      error.name = 'ValidationError'
      return error
    }
  },
  AUTH: {
    name: 'AuthError',
    message: 'Authentication required',
    mock: () => {
      const error = new Error('Authentication required')
      error.name = 'AuthError'
      return error
    }
  },
  TIMEOUT: {
    name: 'TimeoutError',
    message: 'Request timeout',
    mock: () => {
      const error = new Error('Request timeout')
      error.name = 'TimeoutError'
      return error
    }
  }
}
```

### Универсальный тестовый хелпер

```javascript
// utils/testHelpers.js
import { mount } from '@vue/test-utils'

export async function testErrorHandling(component, errorScenario) {
  const wrapper = mount(component)
  
  // Вызываем сценарий ошибки
  await errorScenario(wrapper)
  
  // Проверяем, что ошибка была корректно обработана
  expect(wrapper.find('.error-message').exists()).toBe(true)
  
  // Проверяем, что состояние компонента корректно
  expect(wrapper.vm.loading).toBe(false)
  expect(wrapper.vm.error).toBeDefined()
  
  return wrapper
}

// Пример использования
/*
test('должен корректно обрабатывать сетевые ошибки', async () => {
  await testErrorHandling(MyComponent, async (wrapper) => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))
    await wrapper.vm.fetchData()
  })
})
*/
```

## Лучшие практики тестирования ошибок

1. **Тестировать все возможные сценарии ошибок** - сетевые, валидации, бизнес-логики
2. **Использовать моки для симуляции ошибок** - контролируемое тестирование
3. **Проверять UX при ошибках** - пользователь должен получать понятные сообщения
4. **Тестировать восстановление после ошибок** - приложение должно возвращаться в рабочее состояние
5. **Проверять логирование ошибок** - ошибки должны быть корректно зафиксированы
6. **Тестировать производительность при ошибках** - обработка ошибок не должна замедлять приложение

## Связь с другими концепциями

- [[Обработка-ошибок]] - основы обработки ошибок
- [[Логирование-ошибок]] - системы логирования ошибок
- [[Глобальная-обработка]] - централизованная обработка ошибок
- [[Восстановление-после-ошибок]] - восстановление после ошибок

## Заключение

Тестирование обработки ошибок в Vue.js - это важный аспект обеспечения качества и надежности веб-приложений. В условиях российской разработки 2025 года, когда требования к стабильности и контролируемости систем становятся все более строгими, тщательное тестирование сценариев ошибок позволяет:

1. Убедиться в корректной работе механизмов обработки ошибок
2. Проверить пользовательский опыт при возникновении проблем
3. Убедиться в надежности систем логирования и мониторинга
4. Подтвердить работоспособность механизмов восстановления

Эффективное тестирование обработки ошибок требует комплексного подхода, включающего модульное, интеграционное и сквозное тестирование различных сценариев сбоев.