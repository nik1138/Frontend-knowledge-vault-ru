---
aliases: ["Мобильные паттерны", "Паттерны мобильной разработки", "Mobile Patterns"]
tags: ["#mobile", "#patterns", "#architecture", "#vue", "#ux"]
---

# Мобильные-паттерны

## Общее описание

Мобильные паттерны - это повторяющиеся решения архитектурных и UX задач, которые возникают при разработке мобильных приложений. Понимание и применение этих паттернов позволяет создавать более удобные, интуитивно понятные и эффективные мобильные приложения на Vue.js.

## Основные архитектурные паттерны

### 1. MVVM (Model-View-ViewModel)

MVVM особенно хорошо подходит для Vue.js приложений благодаря встроенной системе реактивности:

```javascript
// Пример реализации MVVM в мобильном приложении
class UserModel {
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.email = data.email;
  }
  
  async updateProfile(newData) {
    // Обновление профиля пользователя
    const response = await fetch(`/api/users/${this.id}`, {
      method: 'PUT',
      body: JSON.stringify(newData)
    });
    return response.json();
  }
}

class UserViewModel {
  constructor(userModel) {
    this.model = userModel;
    this.isEditing = false;
    this.tempData = { ...this.model };
  }
  
  toggleEdit() {
    this.isEditing = !this.isEditing;
    if (!this.isEditing) {
      this.cancelEdit();
    }
  }
  
  async saveChanges() {
    try {
      const updatedUser = await this.model.updateProfile(this.tempData);
      Object.assign(this.model, updatedUser);
      this.isEditing = false;
    } catch (error) {
      console.error('Ошибка сохранения:', error);
    }
  }
  
  cancelEdit() {
    this.tempData = { ...this.model };
    this.isEditing = false;
  }
}
```

### 2. Repository Pattern

Repository паттерн помогает изолировать логику доступа к данным:

```javascript
// Repository для работы с данными
class UserRepository {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async getUser(id) {
    const response = await this.apiClient.get(`/users/${id}`);
    return new UserModel(response.data);
  }
  
  async getUsers() {
    const response = await this.apiClient.get('/users');
    return response.data.map(userData => new UserModel(userData));
  }
  
  async saveUser(user) {
    const response = await this.apiClient.post('/users', user);
    return new UserModel(response.data);
  }
}
```

## Паттерны навигации

### 1. Stack Navigation

Стековая навигация - наиболее распространенный паттерн для мобильных приложений:

```vue
<template>
  <div class="stack-container">
    <transition-group name="slide" tag="div">
      <component 
        v-for="screen in screenStack" 
        :key="screen.id" 
        :is="screen.component" 
        :data="screen.data"
        @back="goBack"
        @navigate="navigate"
      />
    </transition-group>
  </div>
</template>

<script>
export default {
  data() {
    return {
      screenStack: [
        { id: 1, component: 'HomeScreen', data: {} }
      ]
    }
  },
  methods: {
    navigate(component, data = {}) {
      const newScreen = {
        id: Date.now(),
        component,
        data
      };
      this.screenStack.push(newScreen);
    },
    
    goBack() {
      if (this.screenStack.length > 1) {
        this.screenStack.pop();
      }
    }
  }
}
</script>

<style>
.slide-enter-active, .slide-leave-active {
  transition: transform 0.3s ease;
}
.slide-enter-from {
  transform: translateX(100%);
}
.slide-leave-to {
  transform: translateX(-100%);
}
</style>
```

### 2. Tab Navigation

Вкладки для навигации между основными разделами приложения:

```vue
<template>
  <div class="tab-container">
    <div class="tab-bar">
      <button 
        v-for="tab in tabs" 
        :key="tab.id"
        :class="{ active: currentTab === tab.id }"
        @click="switchTab(tab.id)"
      >
        {{ tab.title }}
      </button>
    </div>
    
    <div class="tab-content">
      <keep-alive>
        <component :is="currentTabComponent" />
      </keep-alive>
    </div>
  </div>
</template>

<script>
import HomeTab from './tabs/HomeTab.vue';
import ProfileTab from './tabs/ProfileTab.vue';
import SettingsTab from './tabs/SettingsTab.vue';

export default {
  components: {
    HomeTab,
    ProfileTab,
    SettingsTab
  },
  data() {
    return {
      currentTab: 'home',
      tabs: [
        { id: 'home', title: 'Главная', component: 'HomeTab' },
        { id: 'profile', title: 'Профиль', component: 'ProfileTab' },
        { id: 'settings', title: 'Настройки', component: 'SettingsTab' }
      ]
    }
  },
  computed: {
    currentTabComponent() {
      const tab = this.tabs.find(t => t.id === this.currentTab);
      return tab ? tab.component : 'HomeTab';
    }
  },
  methods: {
    switchTab(tabId) {
      this.currentTab = tabId;
    }
  }
}
</script>
```

## UX паттерны

### 1. Pull-to-Refresh

Паттерн обновления данных свайпом вниз:

```vue
<template>
  <div class="refresh-container" @touchstart="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd">
    <div class="refresh-indicator" :style="{ height: refreshHeight + 'px' }">
      <div v-if="refreshHeight > 30">
        {{ refreshStatus }}
      </div>
    </div>
    
    <div class="content">
      <slot></slot>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      startY: 0,
      currentY: 0,
      refreshHeight: 0,
      isRefreshing: false,
      refreshStatus: 'Потяните для обновления'
    }
  },
  methods: {
    handleTouchStart(e) {
      if (this.isRefreshing) return;
      this.startY = e.touches[0].clientY;
    },
    
    handleTouchMove(e) {
      if (this.isRefreshing) return;
      this.currentY = e.touches[0].clientY;
      const diff = this.currentY - this.startY;
      
      if (diff > 0) {
        this.refreshHeight = Math.min(diff / 2, 60);
        
        if (this.refreshHeight > 30) {
          this.refreshStatus = 'Отпустите для обновления';
        } else {
          this.refreshStatus = 'Потяните для обновления';
        }
      }
    },
    
    async handleTouchEnd() {
      if (this.refreshHeight > 30) {
        this.isRefreshing = true;
        this.refreshStatus = 'Обновление...';
        
        try {
          await this.$emit('refresh');
        } catch (error) {
          console.error('Ошибка обновления:', error);
        } finally {
          this.isRefreshing = false;
          this.refreshHeight = 0;
          this.refreshStatus = 'Потяните для обновления';
        }
      } else {
        this.refreshHeight = 0;
      }
    }
  }
}
</script>
```

### 2. Infinite Scroll

Паттерн подгрузки данных при прокрутке:

```javascript
// Компонент с бесконечной прокруткой
export default {
  name: 'InfiniteScrollList',
  data() {
    return {
      items: [],
      page: 1,
      loading: false,
      hasMore: true,
      observer: null
    }
  },
  async mounted() {
    await this.loadItems();
    
    // Настройка Intersection Observer для отслеживания последнего элемента
    this.observer = new IntersectionObserver(this.handleIntersection, {
      root: null,
      rootMargin: '0px',
      threshold: 1.0
    });
    
    this.$nextTick(() => {
      const sentinel = this.$refs.sentinel;
      if (sentinel) {
        this.observer.observe(sentinel);
      }
    });
  },
  methods: {
    async loadItems() {
      if (this.loading || !this.hasMore) return;
      
      this.loading = true;
      try {
        const response = await this.$http.get(`/api/items?page=${this.page}&limit=20`);
        const newItems = response.data.items;
        
        this.items = [...this.items, ...newItems];
        this.hasMore = response.data.hasMore;
        this.page++;
      } catch (error) {
        console.error('Ошибка загрузки элементов:', error);
      } finally {
        this.loading = false;
      }
    },
    
    handleIntersection(entries) {
      const [entry] = entries;
      if (entry.isIntersecting && this.hasMore && !this.loading) {
        this.loadItems();
      }
    }
  },
  beforeUnmount() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}
```

## Российские особенности UX

В 2025 году в России при разработке мобильных приложений важно учитывать следующие особенности:

### 1. Поддержка российских сервисов

Интеграция с популярными российскими сервисами:

```javascript
// Интеграция с российскими социальными сетями
const shareToSocial = async (content) => {
  // Поддержка ВКонтакте, Одноклассники и др.
  if (isMobile()) {
    // Использование нативных шаринг API
    if (Capacitor.isNativePlatform()) {
      await Share.share({
        title: 'Поделиться',
        text: content.text,
        url: content.url,
        dialogTitle: 'Поделиться с помощью'
      });
    } else {
      // Веб-версия с поддержкой российских соцсетей
      const shareUrl = `https://vk.com/share.php?url=${encodeURIComponent(content.url)}`;
      window.open(shareUrl, '_blank');
    }
  }
};
```

### 2. Локализация и адаптация

Важно учитывать особенности русского языка и культурные особенности:

```javascript
// Компонент с поддержкой русской локализации
export default {
  data() {
    return {
      locale: 'ru'
    }
  },
  computed: {
    localizedMessages() {
      const messages = {
        ru: {
          items_count: (count) => {
            // Правильное склонение в русском языке
            const cases = [2, 0, 1, 1, 1, 2];
            const titles = ['элемент', 'элемента', 'элементов'];
            const idx = count % 100 > 4 && count % 100 < 20 ? 2 : cases[count % 10 < 5 ? count % 10 : 5];
            return `${count} ${titles[idx]}`;
          }
        },
        en: {
          items_count: (count) => `${count} item${count !== 1 ? 's' : ''}`
        }
      };
      
      return messages[this.locale];
    }
  }
}
```

## Паттерны производительности

### 1. Virtual Scrolling

Для отображения больших списков:

```vue
<template>
  <div class="virtual-list" @scroll="handleScroll" :style="{ height: containerHeight + 'px' }">
    <div :style="{ height: totalHeight + 'px' }" class="scroll-area">
      <div 
        v-for="item in visibleItems" 
        :key="item.id"
        :style="{ 
          position: 'absolute',
          top: item.top + 'px',
          height: itemHeight + 'px'
        }"
        class="list-item"
      >
        {{ item.content }}
      </div>
    </div>
  </div>
</template>

<script>
export default {
  props: {
    items: Array,
    itemHeight: {
      type: Number,
      default: 50
    },
    containerHeight: {
      type: Number,
      default: 400
    }
  },
  data() {
    return {
      scrollTop: 0
    }
  },
  computed: {
    totalHeight() {
      return this.items.length * this.itemHeight;
    },
    visibleStartIndex() {
      return Math.floor(this.scrollTop / this.itemHeight);
    },
    visibleEndIndex() {
      const visibleCount = Math.ceil(this.containerHeight / this.itemHeight);
      return Math.min(this.visibleStartIndex + visibleCount + 5, this.items.length);
    },
    visibleItems() {
      return this.items
        .slice(this.visibleStartIndex, this.visibleEndIndex)
        .map((item, index) => ({
          ...item,
          top: (this.visibleStartIndex + index) * this.itemHeight
        }));
    }
  },
  methods: {
    handleScroll(e) {
      this.scrollTop = e.target.scrollTop;
    }
  }
}
</script>
```

### 2. Lazy Loading изображений

```vue
<template>
  <img 
    :src="loaded ? src : placeholder" 
    @load="onLoad" 
    @error="onError"
    v-bind="$attrs"
    :class="{ loaded }"
  />
</template>

<script>
export default {
  props: {
    src: String,
    placeholder: {
      type: String,
      default: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2NjYyIvPjwvc3ZnPg=='
    }
  },
  data() {
    return {
      loaded: false,
      error: false
    }
  },
  methods: {
    onLoad() {
      this.loaded = true;
    },
    onError() {
      this.error = true;
    }
  }
}
</script>
```

## Заключение

Мобильные паттерны играют важную роль в создании качественных и удобных приложений. Понимание и правильное применение этих паттернов позволяет создавать приложения, которые интуитивно понятны пользователям и эффективно работают на мобильных устройствах.

См. также: [[Vue-Native]], [[Ionic-Vue]], [[Quasar]], [[Capacitor]]