---
aliases: [Кастомные переходы, Custom Transitions, Vue Animation]
tags: [vue, transition, animation, custom, frontend]
---

# Кастомные переходы

## Обзор

Кастомные переходы в Vue позволяют полностью контролировать процесс анимации через JavaScript, предоставляя максимальную гибкость для создания сложных анимационных эффектов. Это особенно актуально для российских проектов в 2025 году, где требуются уникальные пользовательские интерфейсы с индивидуальными анимациями, отличающимися от стандартных решений.

## Основы кастомных переходов

Кастомные переходы реализуются через JavaScript-события компонента `<transition>`, которые позволяют:

- Полностью контролировать анимацию через Web Animations API или CSS
- Создавать сложные последовательные анимации
- Интегрировать с внешними анимационными библиотеками
- Реализовывать логику анимации на основе данных приложения

### Пример кастомного перехода

```vue
<template>
  <div class="custom-transition-example">
    <button @click="toggleElement">Переключить элемент</button>
    
    <transition
      :css="false"
      @before-enter="beforeEnter"
      @enter="enter"
      @leave="leave"
    >
      <div v-if="showElement" class="custom-element">
        Элемент с кастомной анимацией
      </div>
    </transition>
  </div>
</template>

<script>
export default {
  name: 'CustomTransitionExample',
  data() {
    return {
      showElement: true
    }
  },
  methods: {
    toggleElement() {
      this.showElement = !this.showElement
    },
    beforeEnter(el) {
      // Подготовка элемента перед анимацией
      el.style.opacity = 0
      el.style.transform = 'scale(0.8) rotate(-10deg)'
    },
    enter(el, done) {
      // Кастомная анимация появления
      const animation = el.animate([
        { opacity: 0, transform: 'scale(0.8) rotate(-10deg)', borderRadius: '50%' },
        { opacity: 1, transform: 'scale(1.05) rotate(2deg)', borderRadius: '10%' },
        { opacity: 1, transform: 'scale(1) rotate(0)', borderRadius: '0%' }
      ], {
        duration: 600,
        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
      })
      
      animation.onfinish = done
    },
    leave(el, done) {
      // Кастомная анимация исчезновения
      const animation = el.animate([
        { opacity: 1, transform: 'scale(1) rotate(0)', borderRadius: '0%' },
        { opacity: 0.8, transform: 'scale(1.05) rotate(2deg)', borderRadius: '10%' },
        { opacity: 0, transform: 'scale(0.8) rotate(-10deg)', borderRadius: '50%' }
      ], {
        duration: 400,
        easing: 'ease-in'
      })
      
      animation.onfinish = done
    }
  }
}
</script>

<style>
.custom-transition-example {
  padding: 20px;
}

.custom-element {
  padding: 20px;
  background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 8px;
  text-align: center;
  margin-top: 20px;
}
</style>
```

## Практическое применение

### 1. Кастомный переход с использованием сторонних библиотек

```vue
<!-- AdvancedTransition.vue -->
<template>
  <div class="advanced-transition-container">
    <div class="controls">
      <button @click="animateIn">Анимировать появление</button>
      <button @click="animateOut">Анимировать исчезновение</button>
      <button @click="toggleBoth">Переключить оба</button>
    </div>
    
    <transition
      :css="false"
      @before-enter="beforeEnterAdvanced"
      @enter="enterAdvanced"
      @before-leave="beforeLeaveAdvanced"
      @leave="leaveAdvanced"
    >
      <div v-if="isVisible" class="advanced-element" ref="advancedElement">
        <h3>Кастомный элемент</h3>
        <p>С продвинутой анимацией</p>
      </div>
    </transition>
  </div>
</template>

<script>
// Имитация использования библиотеки для анимации
// В реальном проекте можно использовать GSAP, Framer Motion и т.д.
export default {
  name: 'AdvancedTransition',
  data() {
    return {
      isVisible: true
    }
  },
  methods: {
    animateIn() {
      this.isVisible = true
    },
    animateOut() {
      this.isVisible = false
    },
    toggleBoth() {
      this.isVisible = !this.isVisible
    },
    beforeEnterAdvanced(el) {
      // Подготовка элемента перед анимацией
      el.style.opacity = '0'
      el.style.transform = 'translateY(50px) rotate(5deg)'
      el.style.filter = 'blur(5px)'
    },
    enterAdvanced(el, done) {
      // Сложная анимация появления с последовательными эффектами
      const duration = 800
      const startTime = performance.now()
      
      const animate = (currentTime) => {
        const elapsed = currentTime - startTime
        const progress = Math.min(elapsed / duration, 1)
        
        // Кривая Безье для плавной анимации
        const easeOutCubic = 1 - Math.pow(1 - progress, 3)
        
        // Комбинированные эффекты
        const translateY = 50 * (1 - easeOutCubic)
        const rotate = 5 * (1 - easeOutCubic)
        const blur = 5 * (1 - easeOutCubic)
        const opacity = easeOutCubic
        
        el.style.opacity = opacity
        el.style.transform = `translateY(${translateY}px) rotate(${rotate}deg)`
        el.style.filter = `blur(${blur}px)`
        
        if (progress < 1) {
          requestAnimationFrame(animate)
        } else {
          el.style.filter = 'blur(0px)'
          done()
        }
      }
      
      requestAnimationFrame(animate)
    },
    beforeLeaveAdvanced(el) {
      // Подготовка перед анимацией исчезновения
    },
    leaveAdvanced(el, done) {
      // Сложная анимация исчезновения
      const duration = 600
      const startTime = performance.now()
      
      const animate = (currentTime) => {
        const elapsed = currentTime - startTime
        const progress = Math.min(elapsed / duration, 1)
        
        // Обратная кривая для исчезновения
        const easeInCubic = Math.pow(progress, 3)
        
        const translateY = 50 * easeInCubic
        const rotate = 5 * easeInCubic
        const blur = 5 * easeInCubic
        const opacity = 1 - easeInCubic
        
        el.style.opacity = opacity
        el.style.transform = `translateY(${translateY}px) rotate(${rotate}deg)`
        el.style.filter = `blur(${blur}px)`
        
        if (progress < 1) {
          requestAnimationFrame(animate)
        } else {
          done()
        }
      }
      
      requestAnimationFrame(animate)
    }
  }
}
</script>

<style>
.advanced-transition-container {
  padding: 20px;
}

.controls {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.advanced-element {
  padding: 20px;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border-radius: 12px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}
</style>
```

### 2. Кастомный переход для списка с последовательной анимацией

```vue
<!-- SequentialListTransition.vue -->
<template>
  <div class="sequential-list-container">
    <div class="controls">
      <button @click="addItem">Добавить элемент</button>
      <button @click="removeItem">Удалить элемент</button>
      <button @click="shuffleItems">Перемешать</button>
    </div>
    
    <transition-group
      tag="div"
      class="sequential-list"
      :css="false"
      @before-enter="beforeEnterItem"
      @enter="enterItem"
      @leave="leaveItem"
    >
      <div 
        v-for="(item, index) in items" 
        :key="item.id" 
        class="list-item"
        :data-index="index"
        ref="listItems"
      >
        {{ item.text }}
      </div>
    </transition-group>
  </div>
</template>

<script>
export default {
  name: 'SequentialListTransition',
  data() {
    return {
      items: [
        { id: 1, text: 'Элемент 1' },
        { id: 2, text: 'Элемент 2' },
        { id: 3, text: 'Элемент 3' }
      ],
      nextId: 4
    }
  },
  methods: {
    addItem() {
      const newItem = {
        id: this.nextId++,
        text: `Элемент ${this.nextId - 1}`
      }
      this.items.push(newItem)
    },
    removeItem() {
      if (this.items.length > 0) {
        this.items.pop()
      }
    },
    shuffleItems() {
      // Простая реализация перемешивания
      this.items = [...this.items].sort(() => Math.random() - 0.5)
    },
    beforeEnterItem(el) {
      // Подготовка элемента перед анимацией
      el.style.opacity = '0'
      el.style.transform = 'translateX(-30px) scale(0.8)'
      el.style.height = '0'
      el.style.padding = '0'
    },
    enterItem(el, done) {
      // Получаем индекс элемента для последовательной анимации
      const index = parseInt(el.dataset.index)
      const delay = index * 100 // Задержка для каждого элемента
      
      // Устанавливаем высоту элемента
      el.style.height = el.scrollHeight + 'px'
      el.style.padding = '10px'
      
      // Запускаем анимацию с задержкой
      setTimeout(() => {
        const animation = el.animate([
          { opacity: 0, transform: 'translateX(-30px) scale(0.8)' },
          { opacity: 1, transform: 'translateX(0) scale(1)' }
        ], {
          duration: 500,
          easing: 'ease-out'
        })
        
        animation.onfinish = done
      }, delay)
    },
    leaveItem(el, done) {
      // Анимация исчезновения с последовательностью
      const index = Array.from(el.parentNode.children).indexOf(el)
      const delay = (this.items.length - index - 1) * 50 // Обратная последовательность
      
      setTimeout(() => {
        const animation = el.animate([
          { opacity: 1, transform: 'translateX(0) scale(1)', height: el.scrollHeight + 'px' },
          { opacity: 0, transform: 'translateX(30px) scale(0.8)', height: '0' }
        ], {
          duration: 400,
          easing: 'ease-in'
        })
        
        animation.onfinish = () => {
          el.style.height = '0'
          el.style.padding = '0'
          done()
        }
      }, delay)
    }
  }
}
</script>

<style>
.sequential-list-container {
  padding: 20px;
}

.controls {
  margin-bottom: 20px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.sequential-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.list-item {
  padding: 10px;
  background: #e3f2fd;
  border: 1px solid #bbdefb;
  border-radius: 6px;
  text-align: center;
  transition: height 0.4s ease, padding 0.4s ease;
}
</style>
```

## Практические рекомендации

### 1. Производительность

При создании кастомных переходов в российских условиях:

- Используйте `requestAnimationFrame` для плавных анимаций
- Минимизируйте изменения DOM во время анимаций
- Оптимизируйте анимации для слабых устройств
- Учитывайте предпочтения пользователей относительно анимаций

### 2. Совместимость с доступностью

- Обеспечьте возможность отключения анимаций
- Используйте ARIA-атрибуты для описания анимационных состояний
- Учитывайте медиа-запрос `prefers-reduced-motion`

### 3. Отладка и тестирование

- Используйте инструменты разработчика для анализа производительности анимаций
- Тестируйте анимации на различных устройствах и браузерах
- Документируйте сложные анимационные логики

## Продвинутые возможности

### Кастомный переход с анимацией на основе данных

```vue
<!-- DataDrivenTransition.vue -->
<template>
  <div class="data-driven-container">
    <div class="controls">
      <label>
        Интенсивность анимации:
        <input 
          type="range" 
          min="1" 
          max="10" 
          v-model.number="intensity"
        >
        {{ intensity }}
      </label>
      
      <label>
        Тип анимации:
        <select v-model="animationType">
          <option value="wave">Волна</option>
          <option value="cascade">Каскад</option>
          <option value="random">Случайная</option>
        </select>
      </label>
    </div>
    
    <transition-group
      tag="div"
      class="data-driven-list"
      :css="false"
      @before-enter="beforeEnterDataDriven"
      @enter="enterDataDriven"
      @leave="leaveDataDriven"
    >
      <div 
        v-for="(item, index) in items" 
        :key="item.id" 
        class="data-driven-item"
        :ref="`item-${item.id}`"
        :data-index="index"
      >
        {{ item.text }}
      </div>
    </transition-group>
  </div>
</template>

<script>
export default {
  name: 'DataDrivenTransition',
  data() {
    return {
      items: [
        { id: 1, text: 'Элемент A' },
        { id: 2, text: 'Элемент B' },
        { id: 3, text: 'Элемент C' },
        { id: 4, text: 'Элемент D' },
        { id: 5, text: 'Элемент E' }
      ],
      intensity: 5,
      animationType: 'wave',
      nextId: 6
    }
  },
  methods: {
    addItem() {
      this.items.push({
        id: this.nextId++,
        text: `Элемент ${String.fromCharCode(64 + this.nextId)}`
      })
    },
    removeItem() {
      if (this.items.length > 0) {
        this.items.pop()
      }
    },
    beforeEnterDataDriven(el) {
      el.style.opacity = '0'
      el.style.transform = 'scale(0.5) rotate(180deg)'
      el.style.position = 'relative'
    },
    enterDataDriven(el, done) {
      const index = parseInt(el.dataset.index)
      let delay = 0
      
      // Различные типы последовательности анимации
      switch (this.animationType) {
        case 'wave':
          delay = Math.abs(this.items.length / 2 - index) * (50 / this.intensity)
          break
        case 'cascade':
          delay = index * (100 / this.intensity)
          break
        case 'random':
          delay = Math.random() * (200 / this.intensity)
          break
      }
      
      setTimeout(() => {
        const animation = el.animate([
          { opacity: 0, transform: 'scale(0.5) rotate(180deg)' },
          { opacity: 0.5, transform: 'scale(1.1) rotate(90deg)' },
          { opacity: 1, transform: 'scale(1) rotate(0)' }
        ], {
          duration: 800 / this.intensity,
          easing: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'
        })
        
        animation.onfinish = done
      }, delay)
    },
    leaveDataDriven(el, done) {
      const index = Array.from(el.parentNode.children).indexOf(el)
      const delay = (this.items.length - index - 1) * (30 / this.intensity)
      
      setTimeout(() => {
        const animation = el.animate([
          { opacity: 1, transform: 'scale(1) rotate(0)' },
          { opacity: 0.5, transform: 'scale(0.9) rotate(-90deg)' },
          { opacity: 0, transform: 'scale(0.5) rotate(-180deg)' }
        ], {
          duration: 600 / this.intensity,
          easing: 'ease-in'
        })
        
        animation.onfinish = done
      }, delay)
    }
  }
}
</script>

<style>
.data-driven-container {
  padding: 20px;
}

.controls {
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.controls label {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.data-driven-list {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

.data-driven-item {
  padding: 12px 20px;
  background: #4caf50;
  color: white;
  border-radius: 20px;
  text-align: center;
  min-width: 100px;
}
</style>
```

## Связанные темы

- [[Transition]]
- [[Transition-group]]
- [[Параметризованные-переходы]]
- [[Локальные-переходы]]

## Заключение

Кастомные переходы предоставляют максимальную гибкость для создания уникальных анимационных эффектов в Vue-приложениях. Они позволяют реализовать сложные анимационные сценарии, которые невозможно достичь с помощью стандартных CSS-анимаций. При разработке в российских условиях в 2025 году важно учитывать производительность, доступность и возможность адаптации анимаций под различные требования пользователей и устройств.