---
aliases: ["Синтаксис Vue", "Шаблоны Vue", "Директивы Vue"]
tags: [vue, syntax, templates, directives]
---

# Синтаксис Vue.js

Синтаксис Vue.js представляет собой расширение HTML, которое позволяет декларативно связывать отображаемый DOM с базовыми данными приложения. Это делает создание интерактивных интерфейсов интуитивно понятным процессом.

## Интерполяция данных

### Текст
Самый простой способ вывода данных — односторонняя привязка с помощью двойных фигурных скобок:

```vue
<template>
  <p>{{ message }}</p>
</template>

<script>
export default {
  data() {
    return {
      message: 'Привет, Vue!'
    }
  }
}
</script>
```

### Однократная интерполяция
Используйте `v-once` для вывода значения один раз без реактивности:

```vue
<template>
  <p v-once>{{ message }}</p>
</template>
```

### HTML
Для вывода HTML-содержимого используйте `v-html`:

```vue
<template>
  <div v-html="rawHtml"></div>
</template>

<script>
export default {
  data() {
    return {
      rawHtml: '<span style="color: red">Это красный текст</span>'
    }
  }
}
</script>
```

> [!warning] Важно
> Будьте осторожны при использовании `v-html`, так как это может привести к XSS-атакам. Убедитесь, что HTML-содержимое надежно.

## Выражения JavaScript

В шаблонах можно использовать JavaScript-выражения:

```vue
<template>
  <p>{{ message.split('').reverse().join('') }}</p>
  <p>{{ count > 10 ? 'Больше 10' : 'Меньше или равно 10' }}</p>
</template>
```

## Директивы

Директивы — это специальные атрибуты с префиксом `v-`, значения которых являются JavaScript-выражениями.

### Условия
- `v-if` — условный рендеринг
- `v-else` — альтернативный блок для `v-if`
- `v-else-if` — альтернативное условие
- `v-show` — показ/скрытие элемента

```vue
<template>
  <div v-if="type === 'A'">
    Условие A
  </div>
  <div v-else-if="type === 'B'">
    Условие B
  </div>
  <div v-else>
    Другое условие
  </div>
  
  <p v-show="show">Это будет скрыто/показано</p>
</template>

<script>
export default {
  data() {
    return {
      type: 'A',
      show: true
    }
  }
}
</script>
```

> [!tip] Совет
> Используйте `v-if` если условие редко меняется, и `v-show` если элемент часто переключается между видимым и скрытым состоянием.

### Циклы
- `v-for` — для повторения элементов

```vue
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
  
  <div v-for="(value, key) in object" :key="key">
    {{ key }}: {{ value }}
  </div>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { id: 1, name: 'Яблоко' },
        { id: 2, name: 'Банан' },
        { id: 3, name: 'Апельсин' }
      ],
      object: {
        title: 'Мой сайт',
        url: 'https://example.com'
      }
    }
  }
}
</script>
```

> [!note] Важно
> Всегда используйте атрибут `:key` с `v-for` для корректной работы виртуального DOM.

### Обработчики событий
- `v-on` или `@` — для обработки событий

```vue
<template>
  <button @click="counter++">Счетчик: {{ counter }}</button>
  <button @click="greet">Приветствие</button>
  <button @click="say('привет')">Сказать привет</button>
</template>

<script>
export default {
  data() {
    return {
      counter: 0
    }
  },
  methods: {
    greet(event) {
      alert(`Привет! ${event.target.tagName}`)
    },
    say(message) {
      alert(message)
    }
  }
}
</script>
```

Модификаторы событий:
- `.stop` — вызывает `event.stopPropagation()`
- `.prevent` — вызывает `event.preventDefault()`
- `.capture` — добавляет прослушивание в фазе захвата
- `.self` — вызывает обработчик только если событие произошло на этом элементе
- `.once` — обработчик выполнится только один раз

```vue
<template>
  <form @submit.prevent="onSubmit">
    <button @click.stop="doThis">Это не вызовет событие родителя</button>
    <button @click.once="doThisOnce">Это сработает только один раз</button>
  </form>
</template>
```

### Двусторонняя привязка данных
- `v-model` — создает двустороннюю привязку данных

```vue
<template>
  <input v-model="message" placeholder="Введите сообщение">
  <p>Сообщение: {{ message }}</p>
  
  <textarea v-model="textarea"></textarea>
  
  <input type="checkbox" id="checkbox" v-model="checked">
  <label for="checkbox">{{ checked }}</label>
</template>

<script>
export default {
  data() {
    return {
      message: '',
      textarea: '',
      checked: false
    }
  }
}
</script>
```

## Атрибуты
- `v-bind` или `:` — динамическая привязка атрибутов

```vue
<template>
  <img :src="imageSrc" :alt="imageAlt" :class="{ active: isActive }">
  <button :disabled="isButtonDisabled">Кнопка</button>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }">Текст</div>
</template>

<script>
export default {
  data() {
    return {
      imageSrc: '/path/to/image.jpg',
      imageAlt: 'Описание изображения',
      isActive: true,
      isButtonDisabled: false,
      activeColor: 'red',
      fontSize: 14
    }
  }
}
</script>
```

## Вычисляемые свойства и методы

### Вычисляемые свойства
- `computed` — кэшируются и пересчитываются только при изменении зависимостей

```vue
<template>
  <p>Обратное сообщение: {{ reversedMessage }}</p>
  <p>Количество слов: {{ wordCount }}</p>
</template>

<script>
export default {
  data() {
    return {
      message: 'Привет Vue!'
    }
  },
  computed: {
    reversedMessage() {
      return this.message.split('').reverse().join('')
    },
    wordCount() {
      return this.message.split(' ').length
    }
  }
}
</script>
```

### Методы
- `methods` — не кэшируются, вызываются при каждом рендере

```vue
<template>
  <p>{{ reverseMessage() }}</p>
</template>

<script>
export default {
  data() {
    return {
      message: 'Привет Vue!'
    }
  },
  methods: {
    reverseMessage() {
      return this.message.split('').reverse().join('')
    }
  }
}
</script>
```

## Наблюдатели
- `watch` — для реакции на изменения данных

```vue
<template>
  <div>
    <p>Сообщение: {{ question }}</p>
    <p>Ответ: {{ answer }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      question: '',
      answer: 'Задайте вопрос, и я постараюсь ответить'
    }
  },
  watch: {
    question(newQuestion, oldQuestion) {
      if (newQuestion.indexOf('?') > -1) {
        this.getAnswer()
      }
    }
  },
  methods: {
    async getAnswer() {
      this.answer = 'Думаю...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer
      } catch (error) {
        this.answer = 'Ошибка! Не могу получить ответ:('
      }
    }
  }
}
</script>
```

## Российские особенности и практики

В 2025 году российские разработчики активно используют Vue.js в коммерческих проектах. Синтаксис Vue, благодаря своей интуитивности, особенно популярен среди начинающих разработчиков в России. Многие компании, такие как Сбер и Авито, используют Vue для создания интерактивных интерфейсов.

При работе с русскоязычными интерфейсами важно учитывать особенности локализации, и синтаксис Vue позволяет легко интегрировать системы локализации, такие как vue-i18n.

## Заключение

Синтаксис Vue.js позволяет создавать динамические и интерактивные интерфейсы с минимальными усилиями. Понимание основных директив и возможностей шаблонов — ключ к эффективной разработке на Vue.

Для углубленного изучения рекомендуется ознакомиться с [[Реактивность]] и [[Компоненты]].