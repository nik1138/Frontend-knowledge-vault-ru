---
aliases: ["Реактивность Vue", "Система реактивности", "Reactivity in Vue"]
tags: [vue, reactivity, javascript, state-management]
---

# Реактивность в Vue.js

Система реактивности — это одна из ключевых особенностей Vue.js, которая позволяет автоматически обновлять DOM при изменении данных приложения. Это делает разработку интерактивных интерфейсов интуитивно понятной и эффективной.

## Основы реактивности

### Что такое реактивность?

Реактивность в Vue означает, что когда вы изменяете данные приложения, пользовательский интерфейс автоматически обновляется для отражения этих изменений. Это происходит без необходимости вручную манипулировать DOM.

```vue
<template>
  <div>
    <p>Счетчик: {{ counter }}</p>
    <button @click="increment">Увеличить</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      counter: 0
    }
  },
  methods: {
    increment() {
      this.counter++ // Интерфейс автоматически обновится
    }
  }
}
</script>
```

## Как работает реактивность

Vue отслеживает зависимости при вычислении вычисляемых свойств и при рендеринге компонентов. Когда изменяется реактивное свойство, Vue автоматически обновляет все зависимости, которые зависят от этого свойства.

### Внутреннее устройство

В Vue 3 реактивность реализована с использованием `Proxy` объектов, что позволяет отслеживать доступ к свойствам и изменения. В предыдущих версиях использовались `Object.defineProperty`.

```javascript
// Пример внутреннего механизма (упрощенно)
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key) // Отслеживание зависимости
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key) // Уведомление об изменениях
      return true
    }
  })
}
```

## API реактивности

### ref и reactive

Vue предоставляет два основных способа создания реактивных данных:

#### ref
`ref` используется для оборачивания примитивных значений:

```vue
<template>
  <div>
    <p>Счетчик: {{ counter }}</p>
    <p>Имя: {{ name }}</p>
    <button @click="increment">Увеличить</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const counter = ref(0)
const name = ref('Vue')

function increment() {
  counter.value++ // Обратите внимание на .value
}

// В шаблоне .value автоматически добавляется
</script>
```

#### reactive
`reactive` используется для создания реактивного объекта:

```vue
<template>
  <div>
    <p>Имя: {{ state.user.name }}</p>
    <p>Возраст: {{ state.user.age }}</p>
    <button @click="updateUser">Обновить пользователя</button>
  </div>
</template>

<script setup>
import { reactive } from 'vue'

const state = reactive({
  user: {
    name: 'Алексей',
    age: 25
  }
})

function updateUser() {
  state.user.age++ // Изменение реактивного объекта
}
</script>
```

## Вычисляемые свойства

Вычисляемые свойства автоматически отслеживают зависимости и кэшируются:

```vue
<template>
  <div>
    <p>Исходное сообщение: {{ message }}</p>
    <p>Обратное сообщение: {{ reversedMessage }}</p>
    <p>Количество слов: {{ wordCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const message = ref('Привет, мир!')

// Вычисляемое свойство с кэшированием
const reversedMessage = computed(() => {
  return message.value.split('').reverse().join('')
})

// Вычисляемое свойство с геттером и сеттером
const wordCount = computed({
  get: () => message.value.split(' ').length,
  set: (value) => {
    message.value = ' '.repeat(value).split(' ').join('слово ')
  }
})
</script>
```

## Наблюдатели

Наблюдатели позволяют реагировать на изменения данных:

```vue
<template>
  <div>
    <input v-model="question" placeholder="Задайте вопрос">
    <p>{{ answer }}</p>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Задайте вопрос, и я постараюсь ответить')

// Наблюдатель за одиночным значением
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.indexOf('?') > -1) {
    answer.value = 'Думаю...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Ошибка! Не могу получить ответ :('
    }
  }
})

// Наблюдатель за глубокими изменениями
const user = ref({
  profile: {
    name: 'Иван',
    email: 'ivan@example.com'
  }
})

watch(
  () => user.value.profile.name,
  (newName) => {
    console.log(`Имя изменилось на: ${newName}`)
  }
)
</script>
```

## Функции реактивности

### toRefs и toRef

`toRefs` преобразует реактивный объект в объект, где каждое свойство является ref:

```vue
<script setup>
import { reactive, toRefs } from 'vue'

const state = reactive({
  firstName: 'Иван',
  lastName: 'Иванов',
  age: 30
})

// Теперь можно использовать firstName, lastName, age как ref
const { firstName, lastName, age } = toRefs(state)

// Полезно при деструктуризации реактивных объектов
</script>
```

### customRef

Создание пользовательских ref с кастомной логикой отслеживания:

```vue
<script setup>
import { customRef } from 'vue'

function debounceRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track() // Отслеживание зависимости
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger() // Уведомление об изменении
        }, delay)
      }
    }
  })
}

const searchQuery = debounceRef('', 500)
</script>
```

## Композиционные функции

Композиционные функции позволяют переиспользовать логику реактивности:

```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

// Композиционная функция для отслеживания времени
function useCurrentTime() {
  const time = ref(new Date())

  const update = () => {
    time.value = new Date()
  }

  onMounted(() => {
    const timer = setInterval(update, 1000)
    onUnmounted(() => clearInterval(timer))
  })

  return { time }
}

// Использование в компоненте
const { time } = useCurrentTime()
</script>
```

## Оптимизация реактивности

### v-memo (Vue 3.2+)

Для оптимизации рендеринга списков:

```vue
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.selected]">
    <CustomListItem :item="item" :selected="item.selected">
      <p>{{ item.title }}</p>
    </CustomListItem>
  </div>
</template>
```

### readonly

Для создания неизменяемой реактивной копии:

```javascript
import { reactive, readonly } from 'vue'

const original = reactive({ count: 0 })
const copy = readonly(original)

// copy.count++ вызовет ошибку в режиме разработки
```

## Российские особенности и практики

В 2025 году российские разработчики активно используют систему реактивности Vue в крупных проектах. Компании, такие как Сбер и Яндекс, применяют продвинутые паттерны реактивности для создания масштабируемых приложений.

В российском Vue-сообществе популярны следующие практики:
- Использование Composition API для лучшей организации кода
- Создание кастомных хуков для переиспользуемой логики
- Интеграция с системами управления состоянием, такими как Pinia

## Заключение

Система реактивности Vue — это мощный инструмент, который позволяет создавать динамические интерфейсы с минимальными усилиями. Понимание принципов работы реактивности позволяет писать более эффективный и предсказуемый код.

> [!tip] Совет
> Используйте `ref` для примитивных значений и `reactive` для объектов. В Composition API предпочтительно использовать `ref`, так как он лучше работает с TypeScript.

Для продолжения изучения рекомендуется ознакомиться с [[Компоненты]] и [[Жизненный-цикл]].