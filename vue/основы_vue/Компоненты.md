---
aliases: ["Компоненты Vue", "Vue компоненты", "Архитектура компонентов"]
tags: [vue, components, architecture, reusability]
---

# Компоненты в Vue.js

Компоненты — это переиспользуемые экземпляры Vue с именем. Они позволяют разбивать пользовательский интерфейс на независимые, многократно используемые части и думать о каждой части изолированно. Это основа архитектуры приложений на Vue.js.

## Основы компонентов

### Создание компонента

Компоненты можно создавать несколькими способами:

#### В однофайловом компоненте (SFC)

```vue
<!-- ButtonCounter.vue -->
<template>
  <button @click="count++">
    Вы нажали {{ count }} раз
  </button>
</template>

<script>
export default {
  name: 'ButtonCounter',
  data() {
    return {
      count: 0
    }
  }
}
</script>

<style scoped>
button {
  padding: 5px 10px;
  background-color: #42b883;
  border: 1px solid #3da57a;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

#### Регистрация компонента

```vue
<template>
  <div>
    <button-counter />
    <button-counter />
    <button-counter />
  </div>
</template>

<script>
import ButtonCounter from './ButtonCounter.vue'

export default {
  components: {
    ButtonCounter
  }
}
</script>
```

## Composition API vs Options API

### Composition API

```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <button @click="updateUser">Обновить</button>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  initialUser: {
    type: Object,
    required: true
  }
})

const user = ref({ ...props.initialUser })

const isUpdated = computed(() => user.value.lastUpdated !== undefined)

function updateUser() {
  user.value.lastUpdated = new Date().toISOString()
}
</script>
```

### Options API

```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <button @click="updateUser">Обновить</button>
  </div>
</template>

<script>
export default {
  name: 'UserCard',
  props: {
    initialUser: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      user: { ...this.initialUser }
    }
  },
  computed: {
    isUpdated() {
      return this.user.lastUpdated !== undefined
    }
  },
  methods: {
    updateUser() {
      this.user.lastUpdated = new Date().toISOString()
    }
  }
}
</script>
```

## Параметры (Props)

Props — это пользовательские атрибуты, которые вы можете зарегистрировать в компоненте:

```vue
<!-- UserProfile.vue -->
<template>
  <div>
    <h2>{{ title }}</h2>
    <p>Имя: {{ name }}</p>
    <p>Возраст: {{ age }}</p>
    <p v-if="active" class="status">Статус: активен</p>
  </div>
</template>

<script setup>
defineProps({
  title: {
    type: String,
    default: 'Профиль пользователя'
  },
  name: {
    type: String,
    required: true
  },
  age: {
    type: Number,
    default: 0
  },
  active: Boolean
})
</script>
```

### Валидация props

```javascript
defineProps({
  // Простая проверка типа
  age: Number,
  
  // Несколько типов
  value: [String, Number],
  
  // Обязательное значение
  name: {
    type: String,
    required: true
  },
  
  // С дефолтным значением
  status: {
    type: String,
    default: 'active'
  },
  
  // Кастомная валидация
  rating: {
    type: Number,
    default: 0,
    validator: (value) => {
      return value >= 0 && value <= 10
    }
  }
})
```

## События (Events)

Компоненты могут генерировать пользовательские события:

```vue
<!-- ChildComponent.vue -->
<template>
  <button @click="notifyParent">Отправить сообщение родителю</button>
</template>

<script setup>
const emit = defineEmits(['message'])

function notifyParent() {
  emit('message', 'Привет от ребенка!')
}
</script>
```

```vue
<!-- ParentComponent.vue -->
<template>
  <div>
    <child-component @message="handleMessage" />
    <p>Сообщение от ребенка: {{ childMessage }}</p>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const childMessage = ref('')

function handleMessage(message) {
  childMessage.value = message
}
</script>
```

## Слоты (Slots)

Слоты позволяют создавать компоненты с расширяемым содержимым:

### Простой слот

```vue
<!-- AlertBox.vue -->
<template>
  <div class="alert-box">
    <slot>
      Содержимое по умолчанию
    </slot>
  </div>
</template>

<style scoped>
.alert-box {
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #f9f9f9;
}
</style>
```

```vue
<!-- Использование -->
<template>
  <alert-box>
    <strong>Это важное сообщение!</strong>
  </alert-box>
</template>
```

### Именованные слоты

```vue
<!-- Layout.vue -->
<template>
  <div class="layout">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

```vue
<!-- Использование -->
<template>
  <layout>
    <template #header>
      <h1>Заголовок</h1>
    </template>
    
    <p>Основное содержимое</p>
    
    <template #footer>
      <p>Футер</p>
    </template>
  </layout>
</template>
```

### Слоты с ограниченной областью видимости

```vue
<!-- UserList.vue -->
<template>
  <ul>
    <li v-for="user in users" :key="user.id">
      <slot :user="user" :index="user.index" :is-admin="user.role === 'admin'">
        {{ user.name }}
      </slot>
    </li>
  </ul>
</template>

<script setup>
import { ref } from 'vue'

const users = ref([
  { id: 1, name: 'Алексей', role: 'admin', index: 0 },
  { id: 2, name: 'Мария', role: 'user', index: 1 },
  { id: 3, name: 'Иван', role: 'user', index: 2 }
])
</script>
```

```vue
<!-- Использование -->
<template>
  <user-list v-slot="{ user, is-admin }">
    <span :class="{ admin: is-admin }">{{ user.name }}</span>
    <span v-if="is-admin">(администратор)</span>
  </user-list>
</template>
```

## Асинхронные компоненты

Для ленивой загрузки компонентов:

```javascript
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() => 
  import('./MyComponent.vue')
)

// С опциями
const AsyncComponentWithOptions = defineAsyncComponent({
  loader: () => import('./MyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
})
```

## Рекурсивные компоненты

Компонент может рекурсивно вызывать себя:

```vue
<!-- TreeNode.vue -->
<template>
  <ul>
    <li>
      {{ node.name }}
      <tree-node 
        v-for="child in node.children" 
        :key="child.id" 
        :node="child" 
      />
    </li>
  </ul>
</template>

<script setup>
defineProps({
  node: {
    type: Object,
    required: true
  }
})
</script>
```

## Динамические компоненты

Использование `<component>` для динамического переключения между компонентами:

```vue
<template>
  <div>
    <button @click="currentTab = 'Home'">Главная</button>
    <button @click="currentTab = 'About'">О нас</button>
    <button @click="currentTab = 'Contact'">Контакты</button>
    
    <component :is="currentTabComponent" />
  </div>
</template>

<script setup>
import { computed } from 'vue'
import Home from './Home.vue'
import About from './About.vue'
import Contact from './Contact.vue'

const currentTab = ref('Home')

const currentTabComponent = computed(() => {
  return {
    Home,
    About,
    Contact
  }[currentTab.value]
})
</script>
```

## Специальные компоненты

### `<keep-alive>`
Кэширует динамические компоненты:

```vue
<template>
  <keep-alive>
    <component :is="currentView" />
  </keep-alive>
</template>
```

### `<transition>`
Анимация переходов:

```vue
<template>
  <transition name="fade" mode="out-in">
    <component :is="currentView" />
  </transition>
</template>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.5s;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}
</style>
```

## Российские особенности и практики

В 2025 году российские разработчики активно используют компонентный подход Vue.js в крупных проектах. Компании, такие как Сбер, Авито и Яндекс, применяют компонентную архитектуру для создания масштабируемых пользовательских интерфейсов.

Основные практики в российском Vue-сообществе:
- Использование Composition API для лучшей организации кода
- Создание библиотек компонентов для переиспользования
- Строгая типизация с использованием TypeScript
- Использование ESLint и Prettier для поддержания качества кода

## Архитектурные паттерны

### Паттерн "Container/Presenter"
Разделение логики и представления:

```vue
<!-- UserListContainer.vue -->
<template>
  <user-list-presenter 
    :users="users" 
    :loading="loading" 
    @load-users="loadUsers"
  />
</template>

<script setup>
import { ref, onMounted } from 'vue'
import UserListPresenter from './UserListPresenter.vue'

const users = ref([])
const loading = ref(false)

async function loadUsers() {
  loading.value = true
  try {
    // Загрузка данных
    users.value = await fetchUsers()
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  loadUsers()
})
</script>
```

### Паттерн "Render Props" (через слоты)
Передача логики в компонент через слоты:

```vue
<!-- DataFetcher.vue -->
<template>
  <slot 
    :data="data" 
    :loading="loading" 
    :error="error"
    :refetch="refetch"
  />
</template>

<script setup>
import { ref } from 'vue'

const props = defineProps(['url'])
const data = ref(null)
const loading = ref(false)
const error = ref(null)

const refetch = async () => {
  loading.value = true
  try {
    data.value = await fetch(props.url).then(r => r.json())
    error.value = null
  } catch (e) {
    error.value = e
  } finally {
    loading.value = false
  }
}
</script>
```

## Заключение

Компоненты — это фундаментальная часть Vue.js, позволяющая создавать модульные, переиспользуемые и легко тестируемые пользовательские интерфейсы. Понимание принципов работы компонентов и их взаимодействия критически важно для эффективной разработки на Vue.

> [!tip] Совет
> Разделяйте компоненты по ответственности: компоненты-контейнеры для логики и компоненты-презентаторы для отображения. Это упрощает тестирование и поддержку кода.

Для продолжения изучения рекомендуется ознакомиться с [[Жизненный-цикл]] и [[Реактивность]].