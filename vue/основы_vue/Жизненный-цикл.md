---
aliases: ["Жизненный цикл Vue", "Хуки жизненного цикла", "Lifecycle hooks"]
tags: [vue, lifecycle, hooks, component-lifecycle]
---

# Жизненный цикл компонентов в Vue.js

Жизненный цикл компонента в Vue.js — это последовательность этапов, через которые проходит каждый компонент от создания до уничтожения. Понимание жизненного цикла позволяет эффективно управлять состоянием компонента, устанавливать и очищать ресурсы, а также оптимизировать производительность приложения.

## Этапы жизненного цикла

### 1. Создание (Creation)

Этапы создания происходят до того, как компонент будет добавлен в DOM. Эти хуки полезны для настройки компонента до его отображения.

#### beforeCreate
- Вызывается сразу после инициализации экземпляра
- На этом этапе еще не доступны `data`, `methods`, `computed` и `watch`
- Редко используется на практике

```vue
<script>
export default {
  data() {
    return {
      message: 'Привет, Vue!'
    }
  },
  beforeCreate() {
    console.log('beforeCreate: this.message недоступно', this.message) // undefined
  }
}
</script>
```

#### created
- Вызывается после создания экземпляра
- Доступны `data`, `methods`, `computed`, `watch`
- Не доступен `$el` (DOM-элемент компонента)
- Подходит для инициализации данных, выполнения API-запросов

```vue
<script setup>
import { ref, onCreated } from 'vue'

const users = ref([])
const loading = ref(false)

// В Composition API используем onMounted вместо created
onMounted(async () => {
  loading.value = true
  try {
    // Загрузка данных при создании компонента
    users.value = await fetch('/api/users').then(r => r.json())
  } finally {
    loading.value = false
  }
})
</script>
```

### 2. Монтирование (Mounting)

Этапы монтирования происходят при добавлении компонента в DOM.

#### beforeMount
- Вызывается перед монтированием
- `$el` еще не создан
- Шаблон еще не скомпилирован

```vue
<script>
export default {
  data() {
    return {
      message: 'Привет, мир!'
    }
  },
  beforeMount() {
    console.log('beforeMount: DOM еще не обновлен')
  }
}
</script>
```

#### mounted
- Вызывается после монтирования
- `$el` доступен
- Подходит для доступа к DOM, установки таймеров, выполнения запросов к API, которые требуют наличия DOM

```vue
<script>
import Chart from 'chart.js'

export default {
  data() {
    return {
      chart: null
    }
  },
  mounted() {
    // Инициализация сторонней библиотеки, требующей DOM
    this.chart = new Chart(this.$refs.canvas, {
      type: 'bar',
      data: {
        labels: ['Янв', 'Фев', 'Мар'],
        datasets: [{
          label: 'Продажи',
          data: [12, 19, 3]
        }]
      }
    })
  },
  beforeUnmount() {
    // Очистка ресурсов
    if (this.chart) {
      this.chart.destroy()
    }
  }
}
</script>
```

### 3. Обновление (Updating)

Этапы обновления происходят при изменении реактивных данных компонента.

#### beforeUpdate
- Вызывается перед обновлением DOM
- Подходит для подготовки к обновлению

```vue
<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  beforeUpdate() {
    console.log('beforeUpdate: DOM еще не обновлен, this.count:', this.count)
  }
}
</script>
```

#### updated
- Вызывается после обновления DOM
- Подходит для выполнения операций, требующих обновленного DOM
- Не вызывается при изменении компонентов потомков

```vue
<script>
export default {
  data() {
    return {
      list: []
    }
  },
  updated() {
    // Доступ к обновленному DOM
    console.log('updated: DOM обновлен')
    // Избегайте изменения состояния здесь, это может вызвать бесконечный цикл
  }
}
</script>
```

### 4. Уничтожение (Unmounting)

Этапы уничтожения происходят при удалении компонента из DOM.

#### beforeUnmount
- Вызывается перед уничтожением экземпляра
- Подходит для очистки ресурсов (таймеры, подписки, соединения)

```vue
<script>
export default {
  data() {
    return {
      timer: null
    }
  },
  mounted() {
    // Установка таймера
    this.timer = setInterval(() => {
      console.log('Таймер сработал')
    }, 1000)
  },
  beforeUnmount() {
    // Очистка таймера
    if (this.timer) {
      clearInterval(this.timer)
    }
  }
}
</script>
```

#### unmounted
- Вызывается после уничтожения экземпляра
- Все директивы экземпляра отвязаны
- Все подписчики событий удалены

## Composition API и жизненный цикл

В Composition API хуки жизненного цикла импортируются и используются как функции:

```vue
<script setup>
import { 
  onMounted, 
  onUpdated, 
  onUnmounted, 
  onBeforeMount, 
  onBeforeUpdate, 
  onBeforeUnmount 
} from 'vue'

// beforeCreate и created не нужны в Composition API

onBeforeMount(() => {
  console.log('beforeMount эквивалент')
})

onMounted(() => {
  console.log('mounted эквивалент')
})

onBeforeUpdate(() => {
  console.log('beforeUpdate эквивалент')
})

onUpdated(() => {
  console.log('updated эквивалент')
})

onBeforeUnmount(() => {
  console.log('beforeUnmount эквивалент')
})

onUnmounted(() => {
  console.log('unmounted эквивалент')
})
</script>
```

## Практические примеры использования хуков

### Загрузка данных при монтировании

```vue
<template>
  <div>
    <div v-if="loading">Загрузка...</div>
    <div v-else-if="error">Ошибка: {{ error }}</div>
    <div v-else>
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'

const user = ref({})
const loading = ref(false)
const error = ref(null)
const route = useRoute()

onMounted(async () => {
  loading.value = true
  try {
    const response = await fetch(`/api/users/${route.params.id}`)
    user.value = await response.json()
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
</script>
```

### Управление подписками

```vue
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const count = ref(0)

let intervalId = null

onMounted(() => {
  // Установка подписки
  intervalId = setInterval(() => {
    count.value++
  }, 1000)
})

onBeforeUnmount(() => {
  // Очистка подписки
  if (intervalId) {
    clearInterval(intervalId)
  }
})
</script>
```

### Работа с DOM-элементами

```vue
<template>
  <div ref="containerRef">
    <p>Содержимое компонента</p>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const containerRef = ref(null)

onMounted(() => {
  // Доступ к DOM-элементу
  if (containerRef.value) {
    containerRef.value.style.backgroundColor = '#f0f0f0'
  }
})
</script>
```

## Асинхронные компоненты и жизненный цикл

При работе с асинхронными компонентами важно учитывать особенности жизненного цикла:

```javascript
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent({
  loader: () => import('./MyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000,
  suspensible: false // Позволяет использовать Suspense
})
```

## Обработка ошибок в жизненном цикле

Vue предоставляет хуки для обработки ошибок:

```vue
<script>
export default {
  errorCaptured(err, instance, info) {
    // Перехватывает ошибки из дочерних компонентов
    console.error('Ошибка в компоненте:', err, info)
    // Верните false, чтобы остановить распространение ошибки
    return false
  }
}
</script>
```

## Российские особенности и практики

В 2025 году российские разработчики активно используют хуки жизненного цикла Vue для создания надежных и производительных приложений. Компании, такие как Сбер, Авито и Яндекс, применяют следующие практики:

- Использование `onMounted` для инициализации внешних библиотек
- Очистка ресурсов в `onBeforeUnmount` для предотвращения утечек памяти
- Логирование жизненного цикла для отладки производительности
- Использование Composition API для лучшей организации кода

В российском Vue-сообществе популярны следующие подходы:
- Создание кастомных хуков для повторного использования логики жизненного цикла
- Интеграция с системами мониторинга для отслеживания производительности
- Использование TypeScript для строгой типизации хуков

## Оптимизация производительности

### Избегайте тяжелых операций в хуках

```vue
<script setup>
import { ref, onMounted } from 'vue'

onMounted(() => {
  // Плохо: тяжелые вычисления в mounted
  // heavyComputation()
  
  // Хорошо: использование nextTick для отложенного выполнения
  nextTick(() => {
    // heavyComputation()
  })
})
</script>
```

### Правильная очистка ресурсов

```vue
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const eventHandlers = []

onMounted(() => {
  const handler = () => console.log('Событие!')
  window.addEventListener('resize', handler)
  eventHandlers.push({ element: window, type: 'resize', handler })
})

onBeforeUnmount(() => {
  // Очистка всех подписок
  eventHandlers.forEach(({ element, type, handler }) => {
    element.removeEventListener(type, handler)
  })
})
</script>
```

## Заключение

Понимание жизненного цикла компонентов Vue.js критически важно для создания эффективных и надежных приложений. Правильное использование хуков позволяет оптимизировать производительность, избежать утечек памяти и создать более предсказуемое поведение приложения.

> [!tip] Совет
> Всегда очищайте ресурсы (таймеры, подписки, соединения) в хуках `onBeforeUnmount` или `beforeUnmount`, чтобы избежать утечек памяти и нежелательного поведения.

Для углубленного изучения рекомендуется ознакомиться с [[Компоненты]] и [[Реактивность]].