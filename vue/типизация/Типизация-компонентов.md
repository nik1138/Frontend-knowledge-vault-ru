---
aliases: ["Типизация Vue компонентов", "Компоненты с TypeScript", "Типизированные компоненты Vue"]
tags: ["vue", "typescript", "components", "frontend", "programming"]
---

# Типизация компонентов

## Обзор

Типизация компонентов в Vue.js с использованием TypeScript позволяет обеспечить безопасность типов при передаче данных между компонентами, улучшить автодополнение в IDE и снизить количество ошибок во время выполнения. В 2025 году это стало критически важным аспектом разработки масштабируемых приложений.

## Типизация Props

### Использование defineProps

```typescript
import { defineComponent } from 'vue'

interface Props {
  title: string
  count: number
  disabled?: boolean
  items: string[]
  callback?: () => void
}

export default defineComponent({
  props: {
    title: {
      type: String,
      required: true
    },
    count: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    items: {
      type: Array as PropType<string[]>,
      default: () => []
    }
  },
  setup(props: Props) {
    // props теперь типизированы
  }
})
```

### Использование синтаксиса с generics

```typescript
<script setup lang="ts">
interface Props {
  title: string
  count: number
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  count: 0,
  disabled: false
})
</script>
```

## Типизация Emits

### Использование defineEmits

```typescript
<script setup lang="ts">
interface Emits {
  (e: 'update:modelValue', value: string): void
  (e: 'click', event: MouseEvent): void
  (e: 'submit', data: { name: string; email: string }): void
}

const emit = defineEmits<Emits>()
</script>
```

## Типизация слотов

```typescript
<script setup lang="ts">
interface Slots {
  default: (props: { item: string; index: number }) => any
  header: (props: { title: string }) => any
  footer?: () => any
}

defineSlots<Slots>()
</script>
```

## Типизация реактивных данных

```typescript
import { ref, computed, reactive } from 'vue'

// Типизация ref
const count = ref<number>(0)

// Типизация computed
const doubleCount = computed<number>(() => count.value * 2)

// Типизация reactive
interface User {
  name: string
  age: number
}

const user = reactive<User>({
  name: 'John',
  age: 30
})
```

## Типизация методов и computed

```typescript
import { defineComponent, ref, computed } from 'vue'

interface User {
  name: string
  email: string
}

export default defineComponent({
  setup() {
    const users = ref<User[]>([])
    
    const activeUsers = computed<User[]>(() => 
      users.value.filter(user => user.name.length > 0)
    )
    
    const addUser = (user: User): void => {
      users.value.push(user)
    }
    
    return {
      users,
      activeUsers,
      addUser
    }
  }
})
```

## Рекомендации по типизации компонентов

- Используйте строгую типизацию для всех props
- Определяйте интерфейсы для сложных типов данных
- Используйте `withDefaults` для установки значений по умолчанию
- Применяйте типы для emits и слотов
- Документируйте сложные типы с помощью JSDoc

## Типизация асинхронных компонентов

```typescript
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() => 
  import('./MyComponent.vue') as Promise<{ default: typeof import('./MyComponent.vue')['default'] }>
)
```

## Типизация динамических компонентов

```typescript
import { defineComponent, ref } from 'vue'
import type { Component } from 'vue'

interface ComponentMap {
  'text-field': typeof import('./TextField.vue')['default']
  'select-field': typeof import('./SelectField.vue')['default']
  'checkbox-field': typeof import('./CheckboxField.vue')['default']
}

export default defineComponent({
  setup() {
    const currentComponent = ref<ComponentMap[keyof ComponentMap]>()
    
    return {
      currentComponent
    }
  }
})
```

## Связанные темы

- [[TypeScript-в-Vue]]
- [[Типизация-хранилищ]]
- [[Типизация-директив]]
- [[Утилиты-для-типизации]]
- [[Composition API]]
- [[Props и Emits]]

## Заключение

Правильная типизация компонентов Vue.js с использованием TypeScript значительно повышает надежность и поддерживаемость кода. В условиях российского рынка, где часто требуется высокая надежность решений, это становится особенно важным.