---
aliases: ["Утилиты типизации Vue", "TypeScript утилиты для Vue", "Вспомогательные типы Vue"]
tags: ["vue", "typescript", "utilities", "frontend", "programming"]
---

# Утилиты для типизации

## Обзор

Утилиты для типизации в Vue.js с использованием TypeScript предоставляют вспомогательные типы и функции, которые упрощают работу с типами в приложениях Vue. В 2025 году экосистема Vue предоставляет богатый набор встроенных утилит типизации, а также возможности для создания пользовательских утилит.

## Встроенные утилиты типизации Vue

### PropType

Утилита `PropType` используется для точной типизации пропсов, особенно когда тип не может быть определен автоматически:

```typescript
import { defineComponent, PropType } from 'vue'

interface User {
  name: string
  email: string
}

export default defineComponent({
  props: {
    // Типизация массива объектов
    users: {
      type: Array as PropType<User[]>,
      default: () => []
    },
    // Типизация функции
    callback: {
      type: Function as PropType<(user: User) => void>,
      required: true
    },
    // Типизация union типа
    status: {
      type: String as PropType<'active' | 'inactive' | 'pending'>,
      default: 'pending'
    },
    // Типизация сложного объекта
    config: {
      type: Object as PropType<{
        apiUrl: string
        timeout: number
        retries: number
      }>,
      required: true
    }
  }
})
```

### ExtractPropTypes

Утилита `ExtractPropTypes` позволяет извлекать типы пропсов из определения компонента:

```typescript
import { defineComponent } from 'vue'
import type { ExtractPropTypes } from 'vue'

const componentProps = {
  title: {
    type: String,
    required: true
  },
  count: {
    type: Number,
    default: 0
  },
  disabled: Boolean
} as const

// Извлечение типов пропсов
type ComponentProps = ExtractPropTypes<typeof componentProps>

// Использование в компоненте
export default defineComponent({
  props: componentProps,
  setup(props: ComponentProps) {
    // props теперь имеет точный тип
  }
})
```

### ComponentCustomProperties

Расширение глобальных свойств компонентов:

```typescript
// types/vue.d.ts
import { CustomProperties } from './custom'

declare module '@vue/runtime-core' {
  export interface ComponentCustomProperties {
    $http: typeof import('axios').default
    $filters: CustomProperties['filters']
    $utils: CustomProperties['utils']
  }
}
```

## Утилиты для работы с реактивностью

### UnwrapRef

Утилита `UnwrapRef` помогает получить "развернутый" тип реактивной ссылки:

```typescript
import { ref, UnwrapRef } from 'vue'

const userRef = ref({ name: 'John', age: 30 })

// Тип userRef.value будет { name: string; age: number }
type UnwrappedUser = UnwrapRef<typeof userRef.value>
```

### ComputedRef

Тип `ComputedRef` используется для типизации вычисляемых свойств:

```typescript
import { computed, ComputedRef } from 'vue'

const count = ref(0)

const doubleCount: ComputedRef<number> = computed(() => count.value * 2)
```

## Утилиты для типизации событий

### EmitFn

Утилита `EmitFn` используется для типизации функции эмиттера:

```typescript
import { defineComponent } from 'vue'
import type { EmitFn } from 'vue'

interface Emits {
  (e: 'update:modelValue', value: string): void
  (e: 'change', value: number): void
  (e: 'submit', data: { name: string; email: string }): void
}

export default defineComponent({
  setup(props, { emit }) {
    const typedEmit = emit as EmitFn<Emits>
    
    const handleSubmit = (data: { name: string; email: string }) => {
      typedEmit('submit', data)
    }
    
    return {
      handleSubmit
    }
  }
})
```

## Универсальные утилиты типизации

### Conditional Types

Условные типы для работы с Vue API:

```typescript
// Утилита для определения типа реактивного объекта
type ReactiveType<T> = T extends Ref<infer R> 
  ? R 
  : T extends ComputedRef<infer R> 
    ? R 
    : T

// Пример использования
const countRef = ref(0)
const countValue: ReactiveType<typeof countRef> = 5 // number

const doubleCount = computed(() => countRef.value * 2)
const doubleValue: ReactiveType<typeof doubleCount> = 10 // number
```

### Mapped Types

Сопоставленные типы для преобразования пропсов:

```typescript
// Утилита для создания необязательных пропсов
type OptionalProps<T> = {
  [K in keyof T]?: T[K]
}

// Утилита для создания пропсов только для чтения
type ReadOnlyProps<T> = {
  readonly [K in keyof T]: T[K]
}

// Пример использования
interface UserProps {
  name: string
  email: string
  age: number
}

type PartialUserProps = OptionalProps<UserProps>
type ReadOnlyUserProps = ReadOnlyProps<UserProps>
```

## Пользовательские утилиты типизации

### Тип для валидации пропсов

```typescript
// Утилита для типизации валидации пропсов
type PropValidator<T> = (value: T) => boolean

interface ValidatedProp<T> {
  type: PropType<T>
  required?: boolean
  default?: T
  validator?: PropValidator<T>
}

// Пример использования
const validatedProps = {
  email: {
    type: String,
    required: true,
    validator: (value: string) => /\S+@\S+\.\S+/.test(value)
  } as ValidatedProp<string>,
  age: {
    type: Number,
    default: 0,
    validator: (value: number) => value >= 0 && value <= 120
  } as ValidatedProp<number>
}
```

### Утилита для типизации событий компонента

```typescript
// Утилита для создания типа событий компонента
type ComponentEvents<T> = {
  [K in keyof T]: T[K] extends (...args: infer A) => any ? A : never
}

// Пример использования
interface ComponentEmits {
  update: (value: string) => void
  change: (id: number, name: string) => void
  delete: () => void
}

type EventArgs = ComponentEvents<ComponentEmits>
// {
//   update: [string],
//   change: [number, string],
//   delete: []
// }
```

## Утилиты для работы с композаблами

```typescript
// Утилита для типизации возвращаемого значения композабла
type UseReturn<T> = {
  [K in keyof T]: T[K] extends (...args: any[]) => any 
    ? T[K] 
    : Ref<T[K]> | ComputedRef<T[K]> | T[K]
}

// Пример композабла с типизацией
interface UseCounterReturn {
  count: number
  doubleCount: number
  increment: () => void
  decrement: () => void
}

const useCounter = (initialValue = 0): UseReturn<UseCounterReturn> => {
  const count = ref(initialValue)
  const doubleCount = computed(() => count.value * 2)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  
  return {
    count,
    doubleCount,
    increment,
    decrement
  }
}
```

## Утилиты для типизации роутинга

```typescript
// Утилита для типизации параметров маршрута
type RouteParams<T extends string = string> = {
  [K in T]: string | string[] | undefined
}

// Утилита для типизации маршрутов
interface RouteDefinition {
  name: string
  path: string
  params?: Record<string, any>
  query?: Record<string, any>
}

// Пример использования с Vue Router
const routes: RouteDefinition[] = [
  {
    name: 'user-profile',
    path: '/user/:id',
    params: {
      id: '123'
    }
  },
  {
    name: 'search',
    path: '/search',
    query: {
      q: 'vue',
      page: '1'
    }
  }
]
```

## Рекомендации по использованию утилит типизации

- Используйте встроенные утилиты Vue для типизации пропсов и событий
- Создавайте пользовательские утилиты для часто используемых паттернов
- Применяйте условные и сопоставленные типы для гибкой типизации
- Документируйте сложные утилиты типизации
- Используйте generics для универсальных утилит
- Следите за обновлениями TypeScript и Vue для новых возможностей типизации

## Связанные темы

- [[TypeScript-в-Vue]]
- [[Типизация-компонентов]]
- [[Типизация-хранилищ]]
- [[Типизация-директив]]
- [[TypeScript Utilities]]
- [[Advanced TypeScript]]

## Заключение

Утилиты для типизации в Vue.js с использованием TypeScript значительно упрощают создание надежных и типизированных приложений. В российском контексте 2025 года, когда требования к качеству кода и надежности решений особенно высоки, знание и применение этих утилит становится критически важным.