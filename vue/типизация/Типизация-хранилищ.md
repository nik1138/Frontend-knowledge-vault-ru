---
aliases: ["Типизация хранилищ Vue", "Vuex с TypeScript", "Pinia с TypeScript", "Типизированные хранилища"]
tags: ["vue", "typescript", "state-management", "vuex", "pinia", "frontend", "programming"]
---

# Типизация хранилищ

## Обзор

Типизация хранилищ в Vue.js с использованием TypeScript обеспечивает безопасность типов при работе с глобальным состоянием приложения. В 2025 году основными решениями для управления состоянием остаются Vuex 4 и Pinia, оба из которых поддерживают полноценную типизацию.

## Типизация Vuex

### Базовая типизация

```typescript
import { createStore, Store as VuexStore, CommitOptions, DispatchOptions } from 'vuex'

// Интерфейсы для состояния, мутаций, действий и геттеров
interface State {
  count: number
  user: {
    name: string
    email: string
  } | null
}

// Мутации
enum MutationTypes {
  INCREMENT = 'INCREMENT',
  SET_USER = 'SET_USER'
}

// Действия
enum ActionTypes {
  INCREMENT_ASYNC = 'INCREMENT_ASYNC',
  FETCH_USER = 'FETCH_USER'
}

// Геттеры
enum GetterTypes {
  DOUBLE_COUNT = 'DOUBLE_COUNT',
  IS_USER_LOGGED_IN = 'IS_USER_LOGGED_IN'
}

// Определение мутаций
const mutations = {
  [MutationTypes.INCREMENT](state: State) {
    state.count++
  },
  [MutationTypes.SET_USER](state: State, user: State['user']) {
    state.user = user
  }
}

// Определение действий
const actions = {
  async [ActionTypes.INCREMENT_ASYNC]({ commit }: { commit: any }) {
    setTimeout(() => {
      commit(MutationTypes.INCREMENT)
    }, 1000)
  },
  async [ActionTypes.FETCH_USER]({ commit }: { commit: any }) {
    // Симуляция асинхронного запроса
    const user = await fetch('/api/user').then(res => res.json())
    commit(MutationTypes.SET_USER, user)
  }
}

// Определение геттеров
const getters = {
  [GetterTypes.DOUBLE_COUNT]: (state: State): number => state.count * 2,
  [GetterTypes.IS_USER_LOGGED_IN]: (state: State): boolean => !!state.user
}

// Создание хранилища
const store = createStore<State>({
  state: {
    count: 0,
    user: null
  },
  mutations,
  actions,
  getters
})

export default store
```

### Расширенная типизация Vuex

```typescript
import { createStore, Store as VuexStore, CommitOptions, DispatchOptions } from 'vuex'

// Интерфейсы для состояния
interface State {
  count: number
  user: {
    name: string
    email: string
  } | null
}

// Типы для мутаций
type Mutations = {
  [MutationTypes.INCREMENT]: undefined
  [MutationTypes.SET_USER]: State['user']
}

// Типы для действий
type Actions = {
  [ActionTypes.INCREMENT_ASYNC]: undefined
  [ActionTypes.FETCH_USER]: undefined
}

// Типы для геттеров
type Getters = {
  [GetterTypes.DOUBLE_COUNT]: number
  [GetterTypes.IS_USER_LOGGED_IN]: boolean
}

// Расширенный тип хранилища
type MyStore = Omit<VuexStore<State>, 'getters' | 'commit' | 'dispatch'> & {
  commit<K extends keyof Mutations>(
    key: K,
    payload: Mutations[K],
    options?: CommitOptions
  ): void
} & {
  dispatch<K extends keyof Actions>(
    key: K,
    payload: Actions[K],
    options?: DispatchOptions
  ): Promise<void>
} & {
  getters: {
    [K in keyof Getters]: Getters[K]
  }
}

// Применение типизации к хранилищу
const typedStore = store as MyStore
```

## Типизация Pinia

### Определение хранилища

```typescript
import { defineStore } from 'pinia'

interface User {
  name: string
  email: string
}

interface State {
  count: number
  user: User | null
}

export const useMainStore = defineStore('main', {
  state: (): State => ({
    count: 0,
    user: null
  }),
  
  getters: {
    doubleCount: (state) => state.count * 2,
    isUserLoggedIn: (state) => !!state.user
  },
  
  actions: {
    increment() {
      this.count++
    },
    
    async incrementAsync() {
      await new Promise(resolve => setTimeout(resolve, 1000))
      this.count++
    },
    
    setUser(user: User) {
      this.user = user
    },
    
    async fetchUser() {
      // Симуляция асинхронного запроса
      const user = await fetch('/api/user').then(res => res.json())
      this.user = user
    }
  }
})
```

### Использование хранилища с типизацией

```typescript
<script setup lang="ts">
import { useMainStore } from '@/stores/main'
import { storeToRefs } from 'pinia'

const mainStore = useMainStore()

// Деструктуризация с сохранением реактивности и типизации
const { count, user } = storeToRefs(mainStore)
const { increment, setUser } = mainStore

// Типы автоматически выводятся из определения хранилища
</script>
```

## Типизация модулей Vuex

```typescript
// Модуль пользователя
import { Module } from 'vuex'
import { State as RootState } from '@/store'

interface UserState {
  profile: {
    name: string
    email: string
  } | null
  preferences: {
    theme: 'light' | 'dark'
    language: string
  }
}

const userModule: Module<UserState, RootState> = {
  namespaced: true,
  
  state: {
    profile: null,
    preferences: {
      theme: 'light',
      language: 'ru'
    }
  },
  
  mutations: {
    SET_PROFILE(state, profile: UserState['profile']) {
      state.profile = profile
    },
    SET_PREFERENCES(state, preferences: Partial<UserState['preferences']>) {
      state.preferences = { ...state.preferences, ...preferences }
    }
  },
  
  actions: {
    async loadProfile({ commit }) {
      const profile = await fetch('/api/profile').then(res => res.json())
      commit('SET_PROFILE', profile)
    }
  },
  
  getters: {
    isLoggedIn: (state) => !!state.profile
  }
}

export default userModule
```

## Типизация асинхронных хранилищ

```typescript
import { defineStore } from 'pinia'

interface AsyncState {
  data: any[] | null
  loading: boolean
  error: string | null
}

export const useAsyncStore = defineStore('async', {
  state: (): AsyncState => ({
    data: null,
    loading: false,
    error: null
  }),
  
  actions: {
    async fetchData() {
      this.loading = true
      this.error = null
      
      try {
        const response = await fetch('/api/data')
        if (!response.ok) throw new Error('Failed to fetch data')
        this.data = await response.json()
      } catch (error: any) {
        this.error = error.message
      } finally {
        this.loading = false
      }
    }
  }
})
```

## Рекомендации по типизации хранилищ

- Всегда определяйте интерфейсы для состояния
- Используйте строгую типизацию для мутаций, действий и геттеров
- Применяйте enum для имен мутаций и действий
- Используйте Pinia для новых проектов - она имеет лучшую интеграцию с TypeScript
- Типизируйте асинхронные операции с обработкой ошибок

## Связанные темы

- [[TypeScript-в-Vue]]
- [[Типизация-компонентов]]
- [[Типизация-директив]]
- [[Утилиты-для-типизации]]
- [[State Management]]
- [[Pinia]]
- [[Vuex]]

## Заключение

Правильная типизация хранилищ в Vue.js с использованием TypeScript обеспечивает безопасность типов при работе с глобальным состоянием, что особенно важно для крупных приложений. В российском контексте 2025 года это позволяет повысить надежность и поддерживаемость корпоративных решений.