---
aliases: ["Типизация директив Vue", "Кастомные директивы с TypeScript", "Типизированные директивы"]
tags: ["vue", "typescript", "directives", "frontend", "programming"]
---

# Типизация директив

## Обзор

Типизация директив в Vue.js с использованием TypeScript позволяет обеспечить безопасность типов при создании и использовании как встроенных, так и кастомных директив. В 2025 году это особенно важно при разработке переиспользуемых компонентов и библиотек, где точная типизация повышает надежность и удобство использования.

## Типизация встроенных директив

### v-model

```typescript
<script setup lang="ts">
import { ref } from 'vue'

// Типизация v-model для простого значения
const inputValue = ref<string>('')

// Типизация v-model для сложного объекта
interface User {
  name: string
  email: string
}

const user = ref<User>({
  name: '',
  email: ''
})
</script>

<template>
  <input v-model="inputValue" type="text" />
  <input v-model="user.name" type="text" placeholder="Имя" />
  <input v-model="user.email" type="email" placeholder="Email" />
</template>
```

### v-for с типизацией

```typescript
<script setup lang="ts">
interface Item {
  id: number
  name: string
  description: string
}

const items = ref<Item[]>([
  { id: 1, name: 'Элемент 1', description: 'Описание 1' },
  { id: 2, name: 'Элемент 2', description: 'Описание 2' }
])
</script>

<template>
  <div v-for="item of items" :key="item.id">
    <h3>{{ item.name }}</h3>
    <p>{{ item.description }}</p>
  </div>
</template>
```

## Типизация кастомных директив

### Определение кастомной директивы

```typescript
import { Directive, DirectiveBinding } from 'vue'

interface TooltipDirective extends HTMLElement {
  tooltipInstance?: {
    destroy: () => void
  }
}

const vTooltip: Directive<TooltipDirective, string> = {
  mounted(el, binding: DirectiveBinding<string>) {
    const tooltipText = binding.value
    
    // Создание элемента тултипа
    const tooltip = document.createElement('div')
    tooltip.textContent = tooltipText
    tooltip.style.cssText = `
      position: absolute;
      background: #333;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 9999;
      display: none;
    `
    
    document.body.appendChild(tooltip)
    
    // Сохранение ссылки на тултип
    el.tooltipInstance = {
      destroy: () => {
        if (tooltip.parentNode) {
          tooltip.parentNode.removeChild(tooltip)
        }
      }
    }
    
    const showTooltip = () => {
      tooltip.style.display = 'block'
      const rect = el.getBoundingClientRect()
      tooltip.style.left = rect.left + 'px'
      tooltip.style.top = rect.top - tooltip.offsetHeight - 5 + 'px'
    }
    
    const hideTooltip = () => {
      tooltip.style.display = 'none'
    }
    
    el.addEventListener('mouseenter', showTooltip)
    el.addEventListener('mouseleave', hideTooltip)
  },
  
  updated(el, binding: DirectiveBinding<string>) {
    // Обновление текста тултипа при изменении значения
    if (el.tooltipInstance) {
      const tooltip = el.querySelector('div[style*="position: absolute"]') as HTMLElement
      if (tooltip) {
        tooltip.textContent = binding.value
      }
    }
  },
  
  unmounted(el) {
    // Очистка при удалении элемента
    if (el.tooltipInstance) {
      el.tooltipInstance.destroy()
      delete el.tooltipInstance
    }
  }
}

export default vTooltip
```

### Использование кастомной директивы с типизацией

```typescript
<script setup lang="ts">
import { createApp } from 'vue'
import vTooltip from './directives/vTooltip'

const app = createApp({})
app.directive('tooltip', vTooltip)

// Локальное использование
const tooltipText = ref('Это подсказка')
</script>

<template>
  <div v-tooltip="tooltipText">Наведи на меня</div>
</template>
```

## Типизация аргументов и модификаторов директив

```typescript
import { Directive, DirectiveBinding } from 'vue'

interface FocusDirective extends HTMLElement {
  _focusHandler?: (e: Event) => void
}

const vFocus: Directive<FocusDirective> = {
  mounted(el, binding: DirectiveBinding) {
    // binding.arg содержит аргумент директивы
    // binding.modifiers содержит модификаторы
    const shouldFocus = binding.arg !== 'no'
    const isDelayed = binding.modifiers.delayed
    
    if (shouldFocus) {
      if (isDelayed) {
        setTimeout(() => el.focus(), 100)
      } else {
        el.focus()
      }
    }
    
    // binding.value содержит значение, переданное директиве
    if (binding.value) {
      el.addEventListener('focus', binding.value)
    }
  },
  
  updated(el, binding: DirectiveBinding) {
    if (binding.value !== binding.oldValue) {
      if (el._focusHandler) {
        el.removeEventListener('focus', el._focusHandler)
      }
      if (binding.value) {
        el.addEventListener('focus', binding.value)
        el._focusHandler = binding.value
      }
    }
  }
}
```

## Расширение глобальных свойств для директив

```typescript
// types/vue.d.ts
import { TooltipOptions } from './directives/vTooltip'

declare module '@vue/runtime-core' {
  export interface ComponentCustomProperties {
    $tooltip: (el: HTMLElement, options: TooltipOptions) => void
  }
  
  export interface GlobalComponents {
    // Расширение глобальных компонентов при необходимости
  }
  
  export interface ComponentCustomOptions {
    // Расширение опций компонента при необходимости
  }
}
```

## Типизация функциональных директив

```typescript
import { Directive } from 'vue'

interface ClickOutsideDirective extends HTMLElement {
  clickOutsideHandler?: (event: Event) => void
}

const vClickOutside: Directive<ClickOutsideDirective, () => void> = (
  el: ClickOutsideDirective,
  binding: { value: () => void }
) => {
  el.clickOutsideHandler = (event: Event) => {
    if (el && !el.contains(event.target as Node)) {
      binding.value()
    }
  }
  
  document.addEventListener('click', el.clickOutsideHandler)
}

// Для функциональных директив также можно использовать объектный синтаксис
const vClickOutsideObj: Directive<ClickOutsideDirective, () => void> = {
  mounted(el, binding) {
    el.clickOutsideHandler = (event: Event) => {
      if (el && !el.contains(event.target as Node)) {
        binding.value()
      }
    }
    
    document.addEventListener('click', el.clickOutsideHandler)
  },
  
  unmounted(el) {
    if (el.clickOutsideHandler) {
      document.removeEventListener('click', el.clickOutsideHandler)
      delete el.clickOutsideHandler
    }
  }
}
```

## Продвинутая типизация директив

```typescript
import { Directive, DirectiveBinding } from 'vue'

// Общий тип для всех директив
type DirectiveValue<T = any> = T | (() => T)

// Интерфейс для опций директивы
interface LazyImageOptions {
  defaultImage?: string
  errorImage?: string
  rootMargin?: string
  threshold?: number
}

// Типизированная директива для ленивой загрузки изображений
const vLazyImage: Directive<HTMLImageElement, DirectiveValue<LazyImageOptions>> = {
  mounted(el: HTMLImageElement, binding: DirectiveBinding<DirectiveValue<LazyImageOptions>>) {
    const options: LazyImageOptions = typeof binding.value === 'function' 
      ? { defaultImage: binding.value() } 
      : binding.value || {}
    
    const defaultImage = options.defaultImage || '/default-image.png'
    const errorImage = options.errorImage || '/error-image.png'
    const rootMargin = options.rootMargin || '0px'
    const threshold = options.threshold || 0.1
    
    // Установка изображения по умолчанию
    el.src = defaultImage
    el.style.opacity = '0'
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const originalSrc = el.dataset.src
          
          if (originalSrc) {
            const img = new Image()
            img.onload = () => {
              el.src = originalSrc
              el.style.transition = 'opacity 0.3s'
              el.style.opacity = '1'
              observer.unobserve(el)
            }
            img.onerror = () => {
              el.src = errorImage
              observer.unobserve(el)
            }
            img.src = originalSrc
          }
        }
      })
    }, { rootMargin, threshold })
    
    observer.observe(el)
  }
}
```

## Рекомендации по типизации директив

- Всегда определяйте типы для значений, передаваемых директиве
- Используйте интерфейсы для сложных опций директив
- Типизируйте аргументы и модификаторы директив
- Расширяйте глобальные типы при необходимости
- Используйте generics для универсальных директив
- Документируйте сложные директивы с помощью JSDoc

## Связанные темы

- [[TypeScript-в-Vue]]
- [[Типизация-компонентов]]
- [[Типизация-хранилищ]]
- [[Утилиты-для-типизации]]
- [[Custom Directives]]
- [[Composition API]]

## Заключение

Правильная типизация директив в Vue.js с использованием TypeScript повышает надежность и удобство использования компонентов, особенно при создании переиспользуемых библиотек. В российском контексте 2025 года это способствует созданию более стабильных и предсказуемых решений.