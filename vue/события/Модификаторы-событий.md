---
aliases: [Модификаторы событий в Vue, Событийные модификаторы]
tags: [vue, events, modifiers, frontend]
---

# Модификаторы-событий

## Введение

Модификаторы событий в Vue - это специальные постфиксы, разделенные точкой, которые указывают Vue как обрабатывать событие. Они обеспечивают удобный способ обработки распространенных задач при работе с событиями, таких как предотвращение всплытия, предотвращение стандартного поведения браузера и другие.

## Основные модификаторы событий

### .stop

Модификатор `.stop` вызывает `event.stopPropagation()`, предотвращая всплытие события дальше по DOM-дереву.

```vue
<template>
  <div @click="outerClick">
    Внешний div
    <button @click.stop="innerClick">Кнопка</button>
    <!-- Клик по кнопке не вызовет outerClick -->
  </div>
</template>

<script>
export default {
  methods: {
    outerClick() {
      console.log('Внешний div кликнут')
    },
    innerClick() {
      console.log('Кнопка кликнута')
      // outerClick не будет вызван из-за .stop
    }
  }
}
</script>
```

### .prevent

Модификатор `.prevent` вызывает `event.preventDefault()`, предотвращая стандартное поведение элемента.

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <input type="text" name="username" />
    <button type="submit">Отправить</button>
  </form>
  <!-- Форма не будет отправлена стандартным способом -->
</template>

<script>
export default {
  methods: {
    handleSubmit() {
      console.log('Форма отправлена через JavaScript')
      // Обработка отправки формы
    }
  }
}
</script>
```

### .capture

Модификатор `.capture` добавляет слушатель события в фазе захвата вместо фазы всплытия.

```vue
<template>
  <div @click.capture="divClick">
    Div
    <button @click="buttonClick">Кнопка</button>
  </div>
  <!-- divClick будет вызван перед buttonClick -->
</template>

<script>
export default {
  methods: {
    divClick() {
      console.log('Div кликнут (фаза захвата)')
    },
    buttonClick() {
      console.log('Кнопка кликнута')
    }
  }
}
</script>
```

### .self

Модификатор `.self` ограничивает вызов обработчика только тем случаем, когда событие произошло непосредственно на этом элементе, а не на его потомках.

```vue
<template>
  <div @click.self="divClick" class="container">
    Контейнер
    <button @click="buttonClick">Кнопка</button>
  </div>
  <!-- divClick будет вызван только при клике непосредственно на div, но не на кнопке -->
</template>

<script>
export default {
  methods: {
    divClick() {
      console.log('Клик на контейнере (не на потомке)')
    },
    buttonClick() {
      console.log('Кнопка кликнута')
    }
  }
}
</script>
```

### .once

Модификатор `.once` гарантирует, что обработчик будет вызван только один раз.

```vue
<template>
  <button @click.once="handleClick">Кликни меня</button>
  <!-- После первого клика обработчик будет удален -->
</template>

<script>
export default {
  methods: {
    handleClick() {
      console.log('Это сообщение появится только один раз')
    }
  }
}
</script>
```

### .passive

Модификатор `.passive` указывает браузеру, что событие не будет вызывать `preventDefault()`. Это важно для производительности, особенно для событий прокрутки.

```vue
<template>
  <div @scroll.passive="handleScroll" style="height: 200px; overflow: auto;">
    <!-- Содержимое для прокрутки -->
  </div>
</template>

<script>
export default {
  methods: {
    handleScroll() {
      // Обработка прокрутки
      // .passive указывает, что preventDefault не будет вызван
    }
  }
}
</script>
```

## Модификаторы клавиш

### Основные модификаторы клавиш

```vue
<template>
  <input 
    @keyup.enter="submitForm"
    @keyup.esc="cancelForm"
    @keydown.space.prevent="handleSpace"
    placeholder="Нажмите Enter для отправки"
  />
</template>

<script>
export default {
  methods: {
    submitForm() {
      console.log('Форма отправлена')
    },
    cancelForm() {
      console.log('Форма отменена')
    },
    handleSpace() {
      console.log('Пробел нажат')
    }
  }
}
</script>
```

### Системные модификаторы

```vue
<template>
  <div>
    <input @keydown.ctrl="handleCtrl" placeholder="Ctrl + клавиша" />
    <input @keydown.alt="handleAlt" placeholder="Alt + клавиша" />
    <input @keydown.shift="handleShift" placeholder="Shift + клавиша" />
    <input @keydown.meta="handleMeta" placeholder="Cmd/Win + клавиша" />
    
    <!-- Комбинации клавиш -->
    <input @keydown.ctrl.s.prevent="save" placeholder="Ctrl+S для сохранения" />
    <input @keydown.ctrl.alt.delete="deleteItem" placeholder="Ctrl+Alt+Delete" />
  </div>
</template>

<script>
export default {
  methods: {
    handleCtrl() {
      console.log('Ctrl нажат')
    },
    handleAlt() {
      console.log('Alt нажат')
    },
    handleShift() {
      console.log('Shift нажат')
    },
    handleMeta() {
      console.log('Meta (Cmd/Win) нажат')
    },
    save() {
      console.log('Сохранение...')
    },
    deleteItem() {
      console.log('Удаление элемента...')
    }
  }
}
</script>
```

### Модификаторы клавиш мыши

```vue
<template>
  <div>
    <button @click.left="handleLeftClick">Левый клик</button>
    <button @click.right="handleRightClick">Правый клик</button>
    <button @click.middle="handleMiddleClick">Средняя кнопка</button>
  </div>
</template>

<script>
export default {
  methods: {
    handleLeftClick() {
      console.log('Левый клик')
    },
    handleRightClick() {
      console.log('Правый клик')
    },
    handleMiddleClick() {
      console.log('Средняя кнопка мыши')
    }
  }
}
</script>
```

## Комбинации модификаторов

Модификаторы можно комбинировать:

```vue
<template>
  <div>
    <!-- Остановить всплытие И предотвратить стандартное поведение -->
    <button @click.stop.prevent="doSomething">Кнопка</button>
    
    <!-- Вызвать обработчик только один раз, но остановить всплытие -->
    <button @click.stop.once="doOnce">Один раз</button>
    
    <!-- Комбинация клавиш с другими модификаторами -->
    <input @keydown.ctrl.enter.prevent="submitForm" />
  </div>
</template>
```

## Пользовательские модификаторы клавиш

Vue позволяет определять пользовательские модификаторы клавиш:

```javascript
// Глобальная настройка модификатора
Vue.config.keyCodes = {
  f1: 112,
  'arrow-up': 38
}

// Или в компоненте (Vue 3)
app.config.globalProperties.$keyCodes = {
  f1: 112,
  'arrow-up': 38
}
```

```vue
<template>
  <input @keydown.f1="showHelp" @keydown.arrow-up="moveUp" />
</template>
```

### В Composition API

```vue
<template>
  <input @keydown.enter="submitForm" @keydown.esc="cancelForm" />
</template>

<script setup>
const submitForm = () => {
  console.log('Форма отправлена')
}

const cancelForm = () => {
  console.log('Форма отменена')
}
</script>
```

## Практические примеры

### 1. Форма с модификаторами

```vue
<template>
  <form @submit.prevent="handleSubmit" class="form">
    <input 
      v-model="username"
      @keydown.enter.prevent
      placeholder="Имя пользователя"
    />
    <input 
      v-model="password"
      type="password"
      @keydown.enter="handleSubmit"
      placeholder="Пароль"
    />
    <div class="form-actions">
      <button 
        type="button" 
        @click="resetForm"
        @keydown.esc="resetForm"
      >
        Сброс
      </button>
      <button type="submit">Войти</button>
    </div>
  </form>
</template>

<script setup>
import { ref } from 'vue'

const username = ref('')
const password = ref('')

const handleSubmit = () => {
  console.log('Отправка формы:', { username: username.value, password: password.value })
}

const resetForm = () => {
  username.value = ''
  password.value = ''
}
</script>
```

### 2. Модальное окно с модификаторами

```vue
<template>
  <div v-if="showModal" class="modal-overlay" @click.self="closeModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Модальное окно</h2>
        <button @click="closeModal" class="close-btn">×</button>
      </div>
      <div class="modal-body">
        <p>Содержимое модального окна</p>
        <input 
          @keydown.esc="closeModal"
          @keydown.enter="confirmAction"
          placeholder="Нажмите Enter или Esc"
        />
      </div>
      <div class="modal-footer">
        <button @click="confirmAction">Подтвердить</button>
        <button @click="closeModal">Отмена</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const showModal = ref(false)

const closeModal = () => {
  showModal.value = false
}

const confirmAction = () => {
  console.log('Действие подтверждено')
  closeModal()
}
</script>
```

### 3. Компонент с горячими клавишами

```vue
<template>
  <div 
    class="editor"
    @keydown.ctrl.s.prevent="save"
    @keydown.ctrl.z.prevent="undo"
    @keydown.ctrl.shift.z.prevent="redo"
    @keydown.ctrl.f.prevent="search"
    tabindex="0"
  >
    <div class="toolbar">
      <button @click="save">Сохранить (Ctrl+S)</button>
      <button @click="undo">Отменить (Ctrl+Z)</button>
      <button @click="redo">Повторить (Ctrl+Shift+Z)</button>
      <button @click="search">Поиск (Ctrl+F)</button>
    </div>
    <textarea v-model="content" placeholder="Текст редактора"></textarea>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const content = ref('')

const save = () => {
  console.log('Сохранение документа...')
}

const undo = () => {
  console.log('Отмена последнего действия...')
}

const redo = () => {
  console.log('Повтор последнего действия...')
}

const search = () => {
  console.log('Открытие поиска...')
}
</script>
```

## Современные практики (2025)

### 1. Использование Composition API с модификаторами

```vue
<template>
  <div class="app">
    <input 
      v-model="searchQuery"
      @keydown.enter="performSearch"
      @keydown.esc="clearSearch"
      placeholder="Поиск..."
    />
    <div class="results">
      <div 
        v-for="item in filteredItems"
        :key="item.id"
        @click="selectItem(item)"
        @keydown.enter="selectItem(item)"
        @keydown.space="selectItem(item)"
        tabindex="0"
        class="result-item"
      >
        {{ item.name }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const searchQuery = ref('')
const items = ref([
  { id: 1, name: 'Элемент 1' },
  { id: 2, name: 'Элемент 2' },
  { id: 3, name: 'Элемент 3' }
])

const filteredItems = computed(() => {
  if (!searchQuery.value) return items.value
  return items.value.filter(item => 
    item.name.toLowerCase().includes(searchQuery.value.toLowerCase())
  )
})

const performSearch = () => {
  console.log('Поиск:', searchQuery.value)
}

const clearSearch = () => {
  searchQuery.value = ''
}

const selectItem = (item) => {
  console.log('Выбран элемент:', item)
}
</script>
```

### 2. Модификаторы в пользовательских компонентах

```vue
<!-- CustomButton.vue -->
<template>
  <button 
    :class="buttonClass"
    @click="handleClick"
    @keydown.enter="handleClick"
    @keydown.space="handleClick"
    :disabled="disabled"
    :type="type"
    tabindex="0"
  >
    <slot></slot>
  </button>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  type: { type: String, default: 'button' },
  disabled: Boolean,
  variant: { type: String, default: 'primary' }
})

const emit = defineEmits(['click'])

const buttonClass = computed(() => [
  'custom-button',
  `custom-button--${props.variant}`,
  { 'custom-button--disabled': props.disabled }
])

const handleClick = (event) => {
  if (!props.disabled) {
    emit('click', event)
  }
}
</script>
```

## Потенциальные проблемы и решения

### 1. Проблема с .passive и .prevent

```vue
<!-- ПЛОХО: .passive и .prevent противоречат друг другу -->
<div @touchstart.prevent.passive="handleTouch">...</div>

<!-- ХОРОШО: используйте только один из модификаторов -->
<div @touchstart.passive="handleTouch">...</div>
```

### 2. Неправильное использование .self

```vue
<template>
  <!-- ПЛОХО: .self не работает с нативными событиями на компонентах -->
  <MyComponent @click.self="handler" />
  
  <!-- ХОРОШО: используйте на нативных элементах -->
  <div @click.self="handler">
    <MyComponent @click="childHandler" />
  </div>
</template>
```

## Заключение

Модификаторы событий в Vue предоставляют мощный и удобный способ обработки распространенных задач при работе с событиями. Они упрощают код и делают его более читаемым, позволяя сосредоточиться на бизнес-логике, а не на деталях обработки событий.

## См. также

- [[Обработка-событий]]
- [[Пользовательские-события]]
- [[Передача-данных]]
- [[Оптимизация-событий]]
- [[Vue Composition API]]