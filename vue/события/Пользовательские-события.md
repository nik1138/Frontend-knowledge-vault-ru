---
aliases: [Пользовательские события в Vue, Кастомные события]
tags: [vue, events, components, frontend]
---

# Пользовательские-события

## Введение

Пользовательские события в Vue позволяют компонентам общаться друг с другом, передавая информацию от дочернего компонента родительскому. Это важный механизм для построения модульных и поддерживаемых приложений на Vue.

## Основы пользовательских событий

В отличие от нативных DOM-событий, пользовательские события используются для коммуникации между компонентами Vue. Они позволяют дочернему компоненту уведомлять родительский компонент о произошедших изменениях или событиях.

## Определение пользовательских событий

### В Options API

```vue
<!-- ChildComponent.vue -->
<template>
  <button @click="notifyParent">Уведомить родителя</button>
</template>

<script>
export default {
  emits: ['custom-event', 'data-updated'],
  methods: {
    notifyParent() {
      // Вызов пользовательского события
      this.$emit('custom-event', 'данные для передачи')
      
      // Передача нескольких значений
      this.$emit('data-updated', { id: 1, name: 'Новый элемент' })
    }
  }
}
</script>
```

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    @custom-event="handleCustomEvent"
    @data-updated="handleDataUpdate"
  />
</template>

<script>
import ChildComponent from './ChildComponent.vue'

export default {
  components: {
    ChildComponent
  },
  methods: {
    handleCustomEvent(data) {
      console.log('Получены данные от ребенка:', data)
    },
    handleDataUpdate(payload) {
      console.log('Данные обновлены:', payload)
    }
  }
}
</script>
```

### В Composition API

```vue
<!-- ChildComponent.vue -->
<template>
  <button @click="notifyParent">Уведомить родителя</button>
</template>

<script setup>
// Определение пользовательских событий
const emit = defineEmits(['custom-event', 'data-updated'])

const notifyParent = () => {
  emit('custom-event', 'данные для передачи')
  emit('data-updated', { id: 1, name: 'Новый элемент' })
}
</script>
```

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    @custom-event="handleCustomEvent"
    @data-updated="handleDataUpdate"
  />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const handleCustomEvent = (data) => {
  console.log('Получены данные от ребенка:', data)
}

const handleDataUpdate = (payload) => {
  console.log('Данные обновлены:', payload)
}
</script>
```

## Типизация пользовательских событий (TypeScript)

### В Options API с TypeScript

```vue
<script lang="ts">
import { defineComponent } from 'vue'

interface ChildComponentEmits {
  (e: 'custom-event', data: string): void
  (e: 'data-updated', payload: { id: number; name: string }): void
}

export default defineComponent({
  emits: {
    'custom-event': (data: string) => typeof data === 'string',
    'data-updated': (payload: { id: number; name: string }) => payload !== undefined
  },
  methods: {
    notifyParent() {
      this.$emit('custom-event', 'данные для передачи')
    }
  }
})
</script>
```

### В Composition API с TypeScript

```vue
<script setup lang="ts">
interface Emits {
  (e: 'custom-event', data: string): void
  (e: 'data-updated', payload: { id: number; name: string }): void
}

const emit = defineEmits<Emits>()

const notifyParent = () => {
  emit('custom-event', 'данные для передачи')
  emit('data-updated', { id: 1, name: 'Новый элемент' })
}
</script>
```

## Распространенные паттерны использования

### 1. Обновление данных в родительском компоненте

```vue
<!-- ChildComponent.vue -->
<template>
  <div>
    <input v-model="localValue" @input="updateValue" />
    <button @click="save">Сохранить</button>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'

const props = defineProps<{ value: string }>()
const emit = defineEmits(['update:value', 'save'])

const localValue = ref(props.value)

// Синхронизация с пропсом
watch(() => props.value, (newValue) => {
  localValue.value = newValue
})

const updateValue = () => {
  emit('update:value', localValue.value)
}

const save = () => {
  emit('save', localValue.value)
}
</script>
```

### 2. События жизненного цикла

```vue
<!-- LifecycleAwareComponent.vue -->
<template>
  <div>Компонент с жизненным циклом</div>
</template>

<script setup>
import { onMounted, onUnmounted } from 'vue'

const emit = defineEmits(['mounted', 'unmounted'])

onMounted(() => {
  emit('mounted')
})

onUnmounted(() => {
  emit('unmounted')
})
</script>
```

### 3. События ошибок

```vue
<!-- ErrorBoundary.vue -->
<template>
  <div>
    <slot v-if="!hasError"></slot>
    <div v-else>
      <p>Произошла ошибка: {{ error.message }}</p>
      <button @click="retry">Повторить</button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const emit = defineEmits(['error'])

const hasError = ref(false)
const error = ref(null)

const handleError = (err) => {
  hasError.value = true
  error.value = err
  emit('error', err)
}

const retry = () => {
  hasError.value = false
  error.value = null
}
</script>
```

## Лучшие практики

### 1. Явное определение событий

Всегда определяйте пользовательские события в опции `emits`:

```javascript
// Хорошо
emits: ['update:modelValue', 'change', 'validate']

// Плохо - без определения
emits: {} // или не указано вообще
```

### 2. Использование префиксов для событий

Используйте префиксы для улучшения читаемости:

```vue
<!-- Хорошо -->
<ChildComponent @user-login="handleLogin" @user-logout="handleLogout" />

<!-- Может быть неочевидно -->
<ChildComponent @login="handleLogin" @logout="handleLogout" />
```

### 3. Валидация данных при эмите

```javascript
// Валидация перед эмитом
const emitValidatedData = (data) => {
  if (typeof data === 'object' && data !== null) {
    emit('data-updated', data)
  } else {
    console.warn('Неверный формат данных для события data-updated')
  }
}
```

## Примеры из российских практик разработки (2025)

### 1. Форма регистрации с валидацией

```vue
<!-- RegistrationForm.vue -->
<template>
  <form @submit.prevent="submitForm">
    <input v-model="email" @blur="validateEmail" placeholder="Email" />
    <input v-model="password" @blur="validatePassword" type="password" placeholder="Пароль" />
    <button type="submit" :disabled="!isFormValid">Зарегистрироваться</button>
  </form>
</template>

<script setup>
import { ref, computed } from 'vue'

const emit = defineEmits(['success', 'error'])

const email = ref('')
const password = ref('')
const emailValid = ref(true)
const passwordValid = ref(true)

const validateEmail = () => {
  emailValid.value = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email.value)
}

const validatePassword = () => {
  passwordValid.value = password.value.length >= 8
}

const isFormValid = computed(() => emailValid.value && passwordValid.value)

const submitForm = async () => {
  try {
    // Отправка данных на сервер
    await registerUser({ email: email.value, password: password.value })
    emit('success', 'Регистрация прошла успешно')
  } catch (error) {
    emit('error', error.message)
  }
}
</script>
```

### 2. Компонент уведомлений

```vue
<!-- NotificationComponent.vue -->
<template>
  <div v-if="show" class="notification" :class="notificationType">
    <span>{{ message }}</span>
    <button @click="close">×</button>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps({
  message: String,
  type: { type: String, default: 'info' },
  duration: { type: Number, default: 5000 }
})

const emit = defineEmits(['close'])

const show = ref(true)

const notificationType = computed(() => `notification--${props.type}`)

const close = () => {
  show.value = false
  emit('close')
}

onMounted(() => {
  if (props.duration > 0) {
    setTimeout(close, props.duration)
  }
})
</script>
```

## Миграция с Vue 2

### В Vue 2:

```javascript
// Вызов события
this.$emit('custom-event', data)

// Определение событий
export default {
  props: ['value'],
  methods: {
    updateValue(newValue) {
      this.$emit('input', newValue) // для v-model
    }
  }
}
```

### В Vue 3:

```javascript
// Вызов события
emit('custom-event', data)

// Определение событий
const emit = defineEmits(['update:modelValue'])
const updateValue = (newValue) => {
  emit('update:modelValue', newValue)
}
```

## Заключение

Пользовательские события - это мощный инструмент для создания модульных компонентов в Vue. Они позволяют эффективно управлять потоком данных между компонентами и создавать гибкие интерфейсы. Правильное использование пользовательских событий способствует созданию более поддерживаемого и масштабируемого кода.

## См. также

- [[Обработка-событий]]
- [[Модификаторы-событий]]
- [[Передача-данных]]
- [[Оптимизация-событий]]
- [[Vue компоненты]]
- [[Vue Composition API]]