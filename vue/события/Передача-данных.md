---
aliases: [Передача данных в Vue, Данные между компонентами]
tags: [vue, events, data, components, frontend]
---

# Передача-данных

## Введение

Передача данных между компонентами - одна из ключевых концепций в разработке приложений на Vue.js. Правильная организация передачи данных обеспечивает чистую архитектуру, предсказуемое поведение приложения и легкую поддержку кода.

## Основные способы передачи данных

### 1. Props (свойства компонента)

Props - это основной способ передачи данных от родительского компонента к дочернему. Это однонаправленный поток данных (unidirectional data flow).

#### В Options API

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    :message="parentMessage"
    :user="userInfo"
    :count="itemCount"
    :is-active="isActive"
  />
</template>

<script>
import ChildComponent from './ChildComponent.vue'

export default {
  components: {
    ChildComponent
  },
  data() {
    return {
      parentMessage: 'Привет от родителя',
      userInfo: {
        name: 'Иван',
        age: 30
      },
      itemCount: 5,
      isActive: true
    }
  }
}
</script>
```

```vue
<!-- ChildComponent.vue -->
<template>
  <div>
    <h2>{{ message }}</h2>
    <p>Имя: {{ user.name }}, Возраст: {{ user.age }}</p>
    <p>Количество: {{ count }}</p>
    <p :class="{ active: isActive }">Статус: {{ isActive ? 'Активен' : 'Неактивен' }}</p>
  </div>
</template>

<script>
export default {
  props: {
    message: {
      type: String,
      required: true
    },
    user: {
      type: Object,
      default: () => ({})
    },
    count: {
      type: Number,
      default: 0
    },
    isActive: {
      type: Boolean,
      default: false
    }
  }
}
</script>
```

#### В Composition API

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    :message="parentMessage"
    :user="userInfo"
    :count="itemCount"
    :is-active="isActive"
  />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentMessage = ref('Привет от родителя')
const userInfo = ref({
  name: 'Иван',
  age: 30
})
const itemCount = ref(5)
const isActive = ref(true)
</script>
```

```vue
<!-- ChildComponent.vue -->
<template>
  <div>
    <h2>{{ message }}</h2>
    <p>Имя: {{ user.name }}, Возраст: {{ user.age }}</p>
    <p>Количество: {{ count }}</p>
    <p :class="{ active: isActive }">Статус: {{ isActive ? 'Активен' : 'Неактивен' }}</p>
  </div>
</template>

<script setup>
import { toRefs } from 'vue'

const props = defineProps({
  message: {
    type: String,
    required: true
  },
  user: {
    type: Object,
    default: () => ({})
  },
  count: {
    type: Number,
    default: 0
  },
  isActive: {
    type: Boolean,
    default: false
  }
})

// Деструктуризация пропсов
const { message, user, count, isActive } = toRefs(props)
</script>
```

### 2. Пользовательские события (Custom Events)

Для передачи данных от дочернего компонента к родительскому используются пользовательские события.

```vue
<!-- ChildComponent.vue -->
<template>
  <div>
    <input v-model="localValue" @input="updateValue" />
    <button @click="notifyParent">Уведомить родителя</button>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'

const props = defineProps(['value'])
const emit = defineEmits(['update:value', 'custom-event'])

const localValue = ref(props.value)

// Синхронизация с пропсом
watch(() => props.value, (newValue) => {
  localValue.value = newValue
})

const updateValue = () => {
  emit('update:value', localValue.value)
}

const notifyParent = () => {
  emit('custom-event', {
    type: 'notification',
    data: localValue.value
  })
}
</script>
```

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent 
    :value="parentValue"
    @update:value="updateParentValue"
    @custom-event="handleCustomEvent"
  />
  <p>Значение родителя: {{ parentValue }}</p>
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentValue = ref('Начальное значение')

const updateParentValue = (newValue) => {
  parentValue.value = newValue
}

const handleCustomEvent = (payload) => {
  console.log('Получено событие:', payload)
}
</script>
```

### 3. v-model для двусторонней привязки

Vue предоставляет удобный способ создания двусторонней привязки данных с помощью v-model.

```vue
<!-- ChildComponent.vue -->
<template>
  <input 
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
    :class="inputClass"
  />
</template>

<script setup>
defineProps({
  modelValue: String,
  inputClass: {
    type: String,
    default: 'default-input'
  }
})

defineEmits(['update:modelValue'])
</script>
```

```vue
<!-- ParentComponent.vue -->
<template>
  <ChildComponent v-model="inputValue" />
  <p>Значение: {{ inputValue }}</p>
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const inputValue = ref('Начальное значение')
</script>
```

## Продвинутые методы передачи данных

### 1. Provide / Inject

Provide/Inject используется для передачи данных между компонентами, которые не находятся в прямом родительско-дочернем отношении.

```vue
<!-- RootComponent.vue -->
<template>
  <div>
    <HeaderComponent />
    <MainComponent />
  </div>
</template>

<script setup>
import { provide, ref } from 'vue'
import HeaderComponent from './HeaderComponent.vue'
import MainComponent from './MainComponent.vue'

const theme = ref('dark')
const user = ref({ name: 'Алексей', role: 'admin' })

provide('theme', theme)
provide('user', user)
provide('updateTheme', (newTheme) => {
  theme.value = newTheme
})
</script>
```

```vue
<!-- HeaderComponent.vue -->
<template>
  <header :class="`header--${currentTheme}`">
    <h1>Заголовок для {{ currentUser.name }}</h1>
    <button @click="toggleTheme">Сменить тему</button>
  </header>
</template>

<script setup>
import { inject } from 'vue'

const currentTheme = inject('theme')
const currentUser = inject('user')
const updateTheme = inject('updateTheme')

const toggleTheme = () => {
  updateTheme(currentTheme.value === 'dark' ? 'light' : 'dark')
}
</script>
```

### 2. Vuex / Pinia (глобальное состояние)

Для сложных приложений с множеством компонентов, которым нужно делиться данными, используются библиотеки управления состоянием.

```javascript
// stores/userStore.js (Pinia)
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    profile: null,
    isLoggedIn: false,
    permissions: []
  }),
  
  getters: {
    fullName: (state) => {
      return state.profile ? `${state.profile.firstName} ${state.profile.lastName}` : ''
    },
    isAdmin: (state) => {
      return state.permissions.includes('admin')
    }
  },
  
  actions: {
    async login(credentials) {
      try {
        const response = await api.login(credentials)
        this.profile = response.data.user
        this.isLoggedIn = true
        this.permissions = response.data.permissions
      } catch (error) {
        throw error
      }
    },
    
    logout() {
      this.profile = null
      this.isLoggedIn = false
      this.permissions = []
    }
  }
})
```

```vue
<!-- Component.vue -->
<template>
  <div>
    <p>Добро пожаловать, {{ userStore.fullName }}!</p>
    <button v-if="userStore.isAdmin" @click="adminAction">Админ-действие</button>
  </div>
</template>

<script setup>
import { useUserStore } from '@/stores/userStore'

const userStore = useUserStore()
</script>
```

### 3. Teleport для передачи DOM

Teleport позволяет рендерить часть компонента в другом месте DOM, что полезно для модальных окон, тултипов и других оверлеев.

```vue
<!-- ModalComponent.vue -->
<template>
  <Teleport to="body">
    <div v-if="isOpen" class="modal-overlay" @click="closeModal">
      <div class="modal" @click.stop>
        <div class="modal-header">
          <slot name="header"></slot>
          <button @click="closeModal">×</button>
        </div>
        <div class="modal-body">
          <slot></slot>
        </div>
        <div class="modal-footer">
          <slot name="footer"></slot>
        </div>
      </div>
    </div>
  </Teleport>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  modelValue: Boolean
})

const emit = defineEmits(['update:modelValue'])

const isOpen = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value)
})

const closeModal = () => {
  isOpen.value = false
}
</script>
```

## Типизация данных (TypeScript)

### В Options API

```vue
<script lang="ts">
import { defineComponent } from 'vue'

interface User {
  id: number
  name: string
  email: string
}

export default defineComponent({
  props: {
    user: {
      type: Object as () => User,
      required: true
    },
    count: {
      type: Number,
      default: 0
    }
  },
  emits: {
    'user-updated': (user: User) => user !== undefined
  },
  methods: {
    updateUser(newUser: User) {
      this.$emit('user-updated', newUser)
    }
  }
})
</script>
```

### В Composition API

```vue
<script setup lang="ts">
interface User {
  id: number
  name: string
  email: string
}

interface Props {
  user: User
  count?: number
}

const props = withDefaults(defineProps<Props>(), {
  count: 0
})

interface Emits {
  (e: 'user-updated', user: User): void
}

const emit = defineEmits<Emits>()

const updateUser = (newUser: User) => {
  emit('user-updated', newUser)
}
</script>
```

## Практические примеры из российских реалий (2025)

### 1. Форма заказа с валидацией

```vue
<!-- OrderForm.vue -->
<template>
  <form @submit.prevent="submitOrder">
    <div class="form-group">
      <label for="name">Имя:</label>
      <input 
        id="name"
        v-model="formData.name"
        @blur="validateField('name')"
        :class="{ error: errors.name }"
      />
      <span v-if="errors.name" class="error-message">{{ errors.name }}</span>
    </div>
    
    <div class="form-group">
      <label for="phone">Телефон:</label>
      <input 
        id="phone"
        v-model="formData.phone"
        @blur="validateField('phone')"
        :class="{ error: errors.phone }"
        placeholder="+7 (XXX) XXX-XX-XX"
      />
      <span v-if="errors.phone" class="error-message">{{ errors.phone }}</span>
    </div>
    
    <div class="form-group">
      <label for="address">Адрес доставки:</label>
      <textarea 
        id="address"
        v-model="formData.address"
        @blur="validateField('address')"
        :class="{ error: errors.address }"
      ></textarea>
      <span v-if="errors.address" class="error-message">{{ errors.address }}</span>
    </div>
    
    <button type="submit" :disabled="!isFormValid">Оформить заказ</button>
  </form>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

interface OrderData {
  name: string
  phone: string
  address: string
}

interface Errors {
  [key: string]: string | undefined
}

const formData = ref<OrderData>({
  name: '',
  phone: '',
  address: ''
})

const errors = ref<Errors>({})

const validateField = (field: keyof OrderData) => {
  switch (field) {
    case 'name':
      if (!formData.value.name.trim()) {
        errors.value.name = 'Имя обязательно'
      } else if (formData.value.name.length < 2) {
        errors.value.name = 'Имя должно содержать минимум 2 символа'
      } else {
        delete errors.value.name
      }
      break
      
    case 'phone':
      const phoneRegex = /^(\+7|8)[\s-]?\(?[\d]{3}\)?[\s-]?[\d]{3}[\s-]?[\d]{2}[\s-]?[\d]{2}$/
      if (!formData.value.phone.trim()) {
        errors.value.phone = 'Телефон обязателен'
      } else if (!phoneRegex.test(formData.value.phone)) {
        errors.value.phone = 'Неверный формат телефона'
      } else {
        delete errors.value.phone
      }
      break
      
    case 'address':
      if (!formData.value.address.trim()) {
        errors.value.address = 'Адрес обязателен'
      } else if (formData.value.address.length < 10) {
        errors.value.address = 'Адрес должен содержать минимум 10 символов'
      } else {
        delete errors.value.address
      }
      break
  }
}

const isFormValid = computed(() => {
  return !Object.keys(errors.value).length && 
         formData.value.name.trim() && 
         formData.value.phone.trim() && 
         formData.value.address.trim()
})

const submitOrder = async () => {
  if (isFormValid.value) {
    try {
      // Отправка данных на сервер
      await submitOrderToServer(formData.value)
      console.log('Заказ успешно оформлен')
    } catch (error) {
      console.error('Ошибка при оформлении заказа:', error)
    }
  }
}

// Функция отправки на сервер (заглушка)
const submitOrderToServer = async (data: OrderData) => {
  // Здесь будет вызов API
  return Promise.resolve()
}
</script>
```

### 2. Компонент чата с передачей сообщений

```vue
<!-- ChatComponent.vue -->
<template>
  <div class="chat-container">
    <div class="messages" ref="messagesContainer">
      <div 
        v-for="message in messages" 
        :key="message.id"
        :class="['message', { 'message--own': message.isOwn }]"
      >
        <div class="message-content">{{ message.text }}</div>
        <div class="message-time">{{ formatTime(message.timestamp) }}</div>
      </div>
    </div>
    
    <form @submit.prevent="sendMessage" class="message-form">
      <input 
        v-model="newMessage" 
        placeholder="Введите сообщение..."
        @keydown.enter.exact="sendMessage"
        @keydown.ctrl.enter.exact="addNewLine"
      />
      <button type="submit">Отправить</button>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick, watch } from 'vue'

interface Message {
  id: string
  text: string
  isOwn: boolean
  timestamp: Date
}

const props = defineProps<{
  initialMessages: Message[]
}>()

const emit = defineEmits<{
  'send-message': [text: string]
}>()

const messages = ref<Message[]>(props.initialMessages)
const newMessage = ref('')
const messagesContainer = ref<HTMLElement | null>(null)

const sendMessage = () => {
  if (newMessage.value.trim()) {
    const message: Message = {
      id: Date.now().toString(),
      text: newMessage.value,
      isOwn: true,
      timestamp: new Date()
    }
    
    messages.value.push(message)
    emit('send-message', newMessage.value)
    newMessage.value = ''
    
    // Прокрутка к последнему сообщению
    nextTick(() => scrollToBottom())
  }
}

const addNewLine = () => {
  newMessage.value += '\n'
}

const scrollToBottom = () => {
  if (messagesContainer.value) {
    messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
  }
}

const formatTime = (date: Date) => {
  return date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })
}

// Автоматическая прокрутка при новых сообщениях
watch(messages, () => {
  nextTick(() => scrollToBottom())
}, { deep: true })
</script>
```

## Лучшие практики

### 1. Минимизация пропсов

```vue
<!-- ПЛОХО: слишком много пропсов -->
<ComplexComponent 
  :prop1="value1"
  :prop2="value2"
  :prop3="value3"
  :prop4="value4"
  :prop5="value5"
/>

<!-- ХОРОШО: группировка связанных данных -->
<ComplexComponent :config="componentConfig" />

<script setup>
const componentConfig = {
  settings: {
    prop1: value1,
    prop2: value2
  },
  options: {
    prop3: value3,
    prop4: value4
  },
  features: {
    prop5: value5
  }
}
</script>
```

### 2. Использование v-model для форм

```vue
<!-- ПЛОХО: много v-model и событий -->
<input :value="name" @input="updateName" />
<input :value="email" @input="updateEmail" />

<!-- ХОРОШО: использование v-model -->
<input v-model="name" />
<input v-model="email" />
```

### 3. Валидация пропсов

```javascript
// Хорошая валидация пропсов
props: {
  size: {
    type: String,
    default: 'medium',
    validator: (value) => ['small', 'medium', 'large'].includes(value)
  },
  items: {
    type: Array,
    default: () => [],
    validator: (items) => items.every(item => typeof item === 'object' && item.id)
  }
}
```

## Заключение

Передача данных в Vue - это мощный механизм, который позволяет создавать модульные, поддерживаемые и масштабируемые приложения. Понимание различных способов передачи данных и их правильное применение критически важно для разработки качественного кода.

## См. также

- [[Обработка-событий]]
- [[Пользовательские-события]]
- [[Модификаторы-событий]]
- [[Оптимизация-событий]]
- [[Vue компоненты]]
- [[Vue Composition API]]