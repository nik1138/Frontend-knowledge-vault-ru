---
aliases: ["Тестирование форм Vue", "Проверка форм", "Тесты валидации форм"]
tags: [vue, forms, validation, testing, unit-tests]
---

# Тестирование форм

## Обзор

Тестирование форм в Vue.js - это комплексная практика, направленная на обеспечение корректной работы валидации, обработки пользовательского ввода и взаимодействия с интерфейсом. В 2025 году тестирование форм включает unit-тесты, интеграционные тесты и end-to-end тесты для обеспечения надежности и качества пользовательского опыта.

## Типы тестов для форм

### Unit-тесты

Unit-тесты проверяют отдельные компоненты и функции валидации:

```javascript
// tests/unit/form-validator.spec.js
import { validateEmail, validatePassword, validateRussianPhone } from '@/utils/form-validators'

describe('Form Validators', () => {
  describe('validateEmail', () => {
    it('should return true for valid email', () => {
      expect(validateEmail('user@example.com')).toBe(true)
      expect(validateEmail('test.user+tag@domain.co.uk')).toBe(true)
    })

    it('should return false for invalid email', () => {
      expect(validateEmail('')).toBe(false)
      expect(validateEmail('invalid-email')).toBe(false)
      expect(validateEmail('@domain.com')).toBe(false)
      expect(validateEmail('user@')).toBe(false)
    })
  })

  describe('validatePassword', () => {
    it('should return true for valid password', () => {
      expect(validatePassword('ValidPass123')).toBe(true)
      expect(validatePassword('AnotherP4ss')).toBe(true)
    })

    it('should return false for invalid password', () => {
      expect(validatePassword('')).toBe(false)
      expect(validatePassword('short')).toBe(false)
      expect(validatePassword('nouppercase123')).toBe(false)
      expect(validatePassword('NOLOWERCASE123')).toBe(false)
      expect(validatePassword('NoNumbers')).toBe(false)
    })
  })

  describe('validateRussianPhone', () => {
    it('should return true for valid Russian phone numbers', () => {
      expect(validateRussianPhone('+7 (999) 123-45-67')).toBe(true)
      expect(validateRussianPhone('8 (999) 123-45-67')).toBe(true)
      expect(validateRussianPhone('+79991234567')).toBe(true)
      expect(validateRussianPhone('89991234567')).toBe(true)
    })

    it('should return false for invalid Russian phone numbers', () => {
      expect(validateRussianPhone('')).toBe(false)
      expect(validateRussianPhone('1234567890')).toBe(false)
      expect(validateRussianPhone('+7 (123) 456-78-9')).toBe(false) // Too short
      expect(validateRussianPhone('+7 (123) 456-78-901')).toBe(false) // Too long
    })
  })
})
```

### Тестирование компонентов форм

```javascript
// tests/unit/LoginForm.spec.js
import { mount } from '@vue/test-utils'
import LoginForm from '@/components/LoginForm.vue'

describe('LoginForm Component', () => {
  let wrapper

  beforeEach(() => {
    wrapper = mount(LoginForm)
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('should render correctly', () => {
    expect(wrapper.find('form').exists()).toBe(true)
    expect(wrapper.find('#email').exists()).toBe(true)
    expect(wrapper.find('#password').exists()).toBe(true)
    expect(wrapper.find('button[type="submit"]').exists()).toBe(true)
  })

  it('should have initial form data', () => {
    const expectedFormData = {
      email: '',
      password: ''
    }
    expect(wrapper.vm.form).toEqual(expectedFormData)
  })

  it('should update form data on input', async () => {
    const emailInput = wrapper.find('#email')
    const passwordInput = wrapper.find('#password')

    await emailInput.setValue('test@example.com')
    await passwordInput.setValue('password123')

    expect(wrapper.vm.form.email).toBe('test@example.com')
    expect(wrapper.vm.form.password).toBe('password123')
  })

  it('should show validation errors for invalid email', async () => {
    const emailInput = wrapper.find('#email')
    await emailInput.setValue('invalid-email')
    await emailInput.trigger('blur')

    await wrapper.vm.$nextTick()

    expect(wrapper.vm.errors.email).toBe('Некорректный формат email')
    expect(wrapper.find('.error-message').text()).toBe('Некорректный формат email')
  })

  it('should show validation errors for empty password', async () => {
    const passwordInput = wrapper.find('#password')
    await passwordInput.setValue('')
    await passwordInput.trigger('blur')

    await wrapper.vm.$nextTick()

    expect(wrapper.vm.errors.password).toBe('Пароль обязателен')
  })

  it('should clear validation errors when input is corrected', async () => {
    const emailInput = wrapper.find('#email')
    
    // Trigger error
    await emailInput.setValue('invalid-email')
    await emailInput.trigger('blur')
    await wrapper.vm.$nextTick()
    
    expect(wrapper.vm.errors.email).toBe('Некорректный формат email')
    
    // Correct the input
    await emailInput.setValue('valid@example.com')
    await wrapper.vm.$nextTick()
    
    expect(wrapper.vm.errors.email).toBeUndefined()
  })

  it('should not submit form with validation errors', async () => {
    const submitSpy = jest.spyOn(wrapper.vm, 'submitForm')
    const form = wrapper.find('form')
    
    await form.trigger('submit.prevent')
    
    expect(submitSpy).toHaveBeenCalled()
    // Проверяем, что форма не отправляется при наличии ошибок
    expect(wrapper.vm.isFormValid).toBe(false)
  })
})
```

### Тестирование пользовательских валидаторов

```javascript
// tests/unit/custom-validators.spec.js
import { isRussianINN, isSnils, isOGRN } from '@/utils/custom-validators'

describe('Custom Validators', () => {
  describe('isRussianINN', () => {
    it('should validate 10-digit INN correctly', () => {
      // Valid INN
      expect(isRussianINN('7707083893')).toBe(true)
      expect(isRussianINN('1656046511')).toBe(true)
      
      // Invalid INN
      expect(isRussianINN('1234567890')).toBe(false) // Incorrect control digit
      expect(isRussianINN('123456789')).toBe(false)  // Too short
      expect(isRussianINN('12345678901')).toBe(false) // Too long
    })

    it('should validate 12-digit INN correctly', () => {
      // Valid INN
      expect(isRussianINN('325200197050')).toBe(true)
      expect(isRussianINN('771014063001')).toBe(true)
      
      // Invalid INN
      expect(isRussianINN('123456789012')).toBe(false) // Incorrect control digits
      expect(isRussianINN('12345678901')).toBe(false)  // Too short
      expect(isRussianINN('1234567890123')).toBe(false) // Too long
    })

    it('should return false for empty or invalid input', () => {
      expect(isRussianINN('')).toBe(false)
      expect(isRussianINN(null)).toBe(false)
      expect(isRussianINN(undefined)).toBe(false)
      expect(isRussianINN('abc123def456')).toBe(false)
    })
  })

  describe('isSnils', () => {
    it('should validate SNILS correctly', () => {
      expect(isSnils('123-456-789 00')).toBe(true)
      expect(isSnils('112-233-445 95')).toBe(true)
      
      expect(isSnils('123-456-789 01')).toBe(false) // Incorrect control number
      expect(isSnils('1234567890')).toBe(false)     // Missing formatting
      expect(isSnils('12-345-678-901')).toBe(false) // Wrong format
    })
  })

  describe('isOGRN', () => {
    it('should validate 13-digit OGRN correctly', () => {
      expect(isOGRN('1167746124795')).toBe(true)
      expect(isOGRN('1234567890123')).toBe(false) // Incorrect control digit
    })

    it('should validate 15-digit OGRNIP correctly', () => {
      expect(isOGRN('315774645854276')).toBe(true)
      expect(isOGRN('315774645854277')).toBe(false) // Incorrect control digit
    })
  })
})
```

## Интеграционные тесты

### Тестирование взаимодействия компонентов

```javascript
// tests/integration/form-integration.spec.js
import { mount } from '@vue/test-utils'
import UserRegistrationForm from '@/components/UserRegistrationForm.vue'
import FormValidator from '@/mixins/FormValidator'

describe('User Registration Form Integration', () => {
  it('should properly validate and submit form data', async () => {
    const wrapper = mount(UserRegistrationForm, {
      global: {
        mixins: [FormValidator]
      }
    })

    // Заполняем форму корректными данными
    await wrapper.find('#fullName').setValue('Иванов Иван Иванович')
    await wrapper.find('#email').setValue('ivan@example.com')
    await wrapper.find('#phone').setValue('+7 (999) 123-45-67')
    await wrapper.find('#password').setValue('SecurePass123')
    await wrapper.find('#confirmPassword').setValue('SecurePass123')

    // Проверяем, что все поля прошли валидацию
    await wrapper.vm.$nextTick()
    
    expect(wrapper.vm.errors.fullName).toBeUndefined()
    expect(wrapper.vm.errors.email).toBeUndefined()
    expect(wrapper.vm.errors.phone).toBeUndefined()
    expect(wrapper.vm.errors.password).toBeUndefined()
    expect(wrapper.vm.errors.confirmPassword).toBeUndefined()

    // Отправляем форму
    const submitBtn = wrapper.find('button[type="submit"]')
    await submitBtn.trigger('click')

    // Проверяем, что форма отправлена с правильными данными
    expect(wrapper.emitted().submit).toBeTruthy()
    const emittedData = wrapper.emitted().submit[0][0]
    expect(emittedData).toEqual({
      fullName: 'Иванов Иван Иванович',
      email: 'ivan@example.com',
      phone: '+7 (999) 123-45-67',
      password: 'SecurePass123'
    })
  })

  it('should show all validation errors for incorrect data', async () => {
    const wrapper = mount(UserRegistrationForm)

    // Заполняем форму некорректными данными
    await wrapper.find('#fullName').setValue('') // Пустое имя
    await wrapper.find('#email').setValue('invalid-email')
    await wrapper.find('#phone').setValue('invalid-phone')
    await wrapper.find('#password').setValue('short')
    await wrapper.find('#confirmPassword').setValue('different')

    // Триггерим валидацию
    await wrapper.vm.validateForm()
    await wrapper.vm.$nextTick()

    // Проверяем наличие всех ошибок
    expect(wrapper.vm.errors.fullName).toBe('Ф.И.О. обязательно')
    expect(wrapper.vm.errors.email).toBe('Некорректный формат email')
    expect(wrapper.vm.errors.phone).toBe('Некорректный формат российского номера телефона')
    expect(wrapper.vm.errors.password).toBe('Пароль должен содержать не менее 8 символов')
    expect(wrapper.vm.errors.confirmPassword).toBe('Пароли не совпадают')
  })
})
```

## End-to-End тесты

### Тестирование формы регистрации с Cypress

```javascript
// tests/e2e/specs/registration-form.cy.js
describe('Registration Form E2E Tests', () => {
  beforeEach(() => {
    cy.visit('/register')
  })

  it('should successfully register a new user with valid data', () => {
    // Заполняем форму корректными данными
    cy.get('#fullName').type('Петров Петр Петрович')
    cy.get('#email').type('petr@example.com')
    cy.get('#phone').type('+7 (987) 654-32-10')
    cy.get('#password').type('StrongPass456')
    cy.get('#confirmPassword').type('StrongPass456')

    // Отправляем форму
    cy.get('form').submit()

    // Проверяем успешную регистрацию
    cy.url().should('include', '/dashboard')
    cy.contains('Добро пожаловать, Петров Петр Петрович!')
  })

  it('should show validation errors for invalid email', () => {
    cy.get('#email').type('invalid-email')
    cy.get('#email').blur()

    cy.contains('Некорректный формат email').should('be.visible')
  })

  it('should show validation errors for mismatched passwords', () => {
    cy.get('#password').type('password123')
    cy.get('#confirmPassword').type('different123')
    
    cy.get('#confirmPassword').blur()
    
    cy.contains('Пароли не совпадают').should('be.visible')
  })

  it('should prevent form submission with validation errors', () => {
    // Отправляем форму без заполнения
    cy.get('form').submit()
    
    // Проверяем, что мы остались на той же странице
    cy.url().should('include', '/register')
    
    // Проверяем наличие ошибок валидации
    cy.contains('Ф.И.О. обязательно').should('be.visible')
    cy.contains('Email обязателен').should('be.visible')
    cy.contains('Пароль обязателен').should('be.visible')
  })

  it('should properly format Russian phone number', () => {
    cy.get('#phone').type('89991234567')
    cy.get('#phone').should('have.value', '8 (999) 123-45-67')
  })

  it('should validate Russian passport format', () => {
    cy.get('#passport').type('1234 567890')
    cy.get('#passport').blur()
    
    // Проверяем, что нет ошибки валидации
    cy.get('.error-message').should('not.contain', 'Некорректный формат паспорта')
  })
})
```

### Тестирование формы с Puppeteer

```javascript
// tests/e2e/puppeteer/form-test.js
const puppeteer = require('puppeteer')

describe('Form E2E Tests with Puppeteer', () => {
  let browser
  let page

  beforeAll(async () => {
    browser = await puppeteer.launch({ headless: true })
    page = await browser.newPage()
    await page.goto('http://localhost:3000/register')
  })

  afterAll(async () => {
    await browser.close()
  })

  it('should validate form inputs correctly', async () => {
    // Проверяем начальное состояние формы
    const initialErrors = await page.evaluate(() => {
      return Array.from(document.querySelectorAll('.error-message')).map(el => el.textContent)
    })
    expect(initialErrors).toHaveLength(0)

    // Вводим невалидный email
    await page.type('#email', 'invalid-email')
    await page.focus('#password') // Убираем фокус с email для триггера валидации
    
    // Ожидаем появление ошибки
    await page.waitForSelector('.error-message', { visible: true })
    
    const errorText = await page.$eval('.error-message', el => el.textContent)
    expect(errorText).toBe('Некорректный формат email')
  })

  it('should submit form with valid data', async () => {
    // Очищаем предыдущие значения
    await page.type('#email', 'test@example.com', { delay: 10 })
    await page.type('#password', 'ValidPass123', { delay: 10 })
    
    // Отправляем форму
    await page.click('button[type="submit"]')
    
    // Ожидаем редирект или успешное сообщение
    await page.waitForNavigation()
    const url = page.url()
    expect(url).toContain('/dashboard')
  }, 15000) // Увеличиваем таймаут для сетевых операций
})
```

## Тестирование асинхронной валидации

### Тестирование асинхронных валидаторов

```javascript
// tests/unit/async-validators.spec.js
import { isUniqueEmail, isUsernameAvailable } from '@/utils/async-validators'
import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

describe('Async Validators', () => {
  let mock

  beforeAll(() => {
    mock = new MockAdapter(axios)
  })

  afterEach(() => {
    mock.reset()
  })

  afterAll(() => {
    mock.restore()
  })

  describe('isUniqueEmail', () => {
    it('should return true for unique email', async () => {
      mock.onGet('/api/check-email/test@example.com').reply(200, {
        isUnique: true
      })

      const result = await isUniqueEmail('test@example.com')
      expect(result).toBe(true)
    })

    it('should return false for non-unique email', async () => {
      mock.onGet('/api/check-email/existing@example.com').reply(200, {
        isUnique: false
      })

      const result = await isUniqueEmail('existing@example.com')
      expect(result).toBe(false)
    })

    it('should handle API errors gracefully', async () => {
      mock.onGet('/api/check-email/error@example.com').reply(500)

      const result = await isUniqueEmail('error@example.com')
      // В случае ошибки API возвращаем true, чтобы не блокировать форму
      expect(result).toBe(true)
    })
  })

  describe('isUsernameAvailable', () => {
    it('should return true for available username', async () => {
      mock.onPost('/api/check-username').reply(200, {
        isAvailable: true
      })

      const result = await isUsernameAvailable('unique_user')
      expect(result).toBe(true)
    })

    it('should return false for taken username', async () => {
      mock.onPost('/api/check-username').reply(200, {
        isAvailable: false
      })

      const result = await isUsernameAvailable('taken_user')
      expect(result).toBe(false)
    })
  })
})
```

### Тестирование компонента с асинхронной валидацией

```javascript
// tests/unit/AsyncValidationForm.spec.js
import { mount } from '@vue/test-utils'
import AsyncValidationForm from '@/components/AsyncValidationForm.vue'
import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

describe('AsyncValidationForm Component', () => {
  let wrapper
  let mock

  beforeAll(() => {
    mock = new MockAdapter(axios)
  })

  beforeEach(() => {
    mock.reset()
    wrapper = mount(AsyncValidationForm)
  })

  afterEach(() => {
    wrapper.unmount()
  })

  afterAll(() => {
    mock.restore()
  })

  it('should show checking status during async validation', async () => {
    mock.onGet('/api/check-username/testuser').reply(200, {
      isAvailable: true
    })

    const usernameInput = wrapper.find('#username')
    await usernameInput.setValue('testuser')
    
    // Проверяем статус проверки
    await new Promise(resolve => setTimeout(resolve, 100)) // Даем время для debounce
    expect(wrapper.vm.validationStatus.username).toBe('checking')
    
    // Ждем завершения проверки
    await new Promise(resolve => setTimeout(resolve, 1100)) // Ждем завершения асинхронной операции
    await wrapper.vm.$nextTick()
    
    expect(wrapper.vm.validationStatus.username).toBe('available')
  })

  it('should show error for unavailable username', async () => {
    mock.onGet('/api/check-username/takenuser').reply(200, {
      isAvailable: false
    })

    const usernameInput = wrapper.find('#username')
    await usernameInput.setValue('takenuser')
    
    await new Promise(resolve => setTimeout(resolve, 1100))
    await wrapper.vm.$nextTick()
    
    expect(wrapper.vm.errors.username).toBe('Имя пользователя уже занято')
  })

  it('should handle validation errors gracefully', async () => {
    mock.onGet('/api/check-username/erroruser').reply(500)

    const usernameInput = wrapper.find('#username')
    await usernameInput.setValue('erroruser')
    
    await new Promise(resolve => setTimeout(resolve, 1100))
    await wrapper.vm.$nextTick()
    
    // При ошибке API форма не должна блокироваться
    expect(wrapper.vm.errors.username).toBeUndefined()
  })
})
```

## Тестирование UX аспектов

### Тестирование пользовательского опыта

```javascript
// tests/unit/ux-validation.spec.js
import { mount } from '@vue/test-utils'
import UXValidationForm from '@/components/UXValidationForm.vue'

describe('UX Validation Form', () => {
  let wrapper

  beforeEach(() => {
    wrapper = mount(UXValidationForm)
  })

  afterEach(() => {
    wrapper.unmount()
  })

  it('should show progress indicator', async () => {
    expect(wrapper.vm.getProgressPercentage).toBe(0)
    
    await wrapper.setData({
      form: { email: 'test@example.com', password: 'ValidPass123' },
      isValid: { email: true, password: true }
    })
    
    expect(wrapper.vm.getProgressPercentage).toBe(100)
  })

  it('should provide positive feedback for valid inputs', async () => {
    const emailInput = wrapper.find('#email')
    await emailInput.setValue('valid@example.com')
    await emailInput.trigger('blur')
    
    await wrapper.vm.$nextTick()
    
    const successMessage = wrapper.find('.success-message')
    expect(successMessage.text()).toBe('Email выглядит корректно')
  })

  it('should show password requirements as user types', async () => {
    const passwordInput = wrapper.find('#password')
    await passwordInput.setValue('a')
    
    // Проверяем, что требования отображаются
    const requirements = wrapper.findAll('.requirement')
    expect(requirements).toHaveLength(4)
    
    // Проверяем статус каждого требования
    const requirementClasses = requirements.wrappers.map(req => req.classes())
    expect(requirementClasses[0]).toContain('invalid') // length
    expect(requirementClasses[1]).toContain('invalid') // upper
    expect(requirementClasses[2]).toContain('invalid') // lower
    expect(requirementClasses[3]).toContain('invalid') // number
  })

  it('should format Russian phone number as user types', async () => {
    const phoneInput = wrapper.find('#phone')
    await phoneInput.setValue('89991234567')
    
    expect(phoneInput.element.value).toBe('8 (999) 123-45-67')
  })
})
```

## Российские реалии 2025

В 2025 году при тестировании форм для российских проектов необходимо учитывать:

- **Тестирование российских форматов данных**: ИНН, ОГРН, СНИЛС, паспортные данные
- **Локализация тестов**: Все тестовые сообщения на русском языке
- **Соответствие требованиям ФЗ-152**: Тестирование обработки персональных данных
- **Мобильная оптимизация**: Тестирование форм на мобильных устройствах
- **Скорость интернета**: Тестирование производительности при медленном соединении

## Лучшие практики тестирования

1. **Покрытие 100%**: Стремиться к полному покрытию кода валидации тестами
2. **Тестирование граничных условий**: Проверка крайних значений и форматов
3. **Асинхронные тесты**: Правильная обработка асинхронных операций
4. **Mock-объекты**: Использование моков для внешних зависимостей
5. **CI/CD интеграция**: Автоматизация тестирования в процессе разработки

## Заключение

Тестирование форм - критически важная часть разработки надежных Vue-приложений. Комплексный подход к тестированию, включающий unit-тесты, интеграционные и end-to-end тесты, обеспечивает высокое качество пользовательского опыта и надежность работы форм.

## См. также

- [[Валидация на клиенте]]
- [[Валидация на сервере]]
- [[Пользовательские валидаторы]]
- [[UX валидации]]