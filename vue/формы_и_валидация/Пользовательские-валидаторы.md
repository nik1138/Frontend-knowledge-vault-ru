---
aliases: ["Кастомные валидаторы", "Пользовательские правила валидации", "Свои валидаторы"]
tags: [vue, forms, validation, custom-validators]
---

# Пользовательские валидаторы

## Обзор

Пользовательские валидаторы позволяют разработчикам создавать собственные правила проверки данных, выходящие за рамки стандартных валидационных правил. В контексте Vue.js они особенно полезны для реализации бизнес-логики и специфических требований приложения.

## Принципы создания пользовательских валидаторов

Пользовательские валидаторы должны:

- Быть переиспользуемыми в разных компонентах
- Возвращать логическое значение или объект с ошибкой
- Быть легко тестируемыми
- Поддерживать параметры для гибкости

## Реализация пользовательских валидаторов

### Простой пользовательский валидатор

```javascript
// validators.js
export const isRussianPhone = (value) => {
  if (!value) return false;
  
  // Проверяем формат российского номера телефона
  const phoneRegex = /^(\+7|8)[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/;
  return phoneRegex.test(value);
};

export const isRussianINN = (value) => {
  if (!value) return false;
  
  // Проверка ИНН (10 или 12 цифр)
  const innRegex = /^\d{10}$|^\d{12}$/;
  if (!innRegex.test(value)) return false;
  
  // Алгоритм проверки контрольных цифр
  const digits = value.split('').map(Number);
  
  if (value.length === 10) {
    // Проверка для 10-значного ИНН
    const checkDigits = [2, 4, 10, 3, 5, 9, 4, 6, 8];
    const sum = checkDigits.reduce((acc, multiplier, index) => 
      acc + multiplier * digits[index], 0) % 11 % 10;
    return sum === digits[9];
  } else if (value.length === 12) {
    // Проверка для 12-значного ИНН
    const checkDigits1 = [7, 2, 4, 10, 3, 5, 9, 4, 6, 8];
    const checkDigits2 = [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8];
    
    const sum1 = checkDigits1.reduce((acc, multiplier, index) => 
      acc + multiplier * digits[index], 0) % 11 % 10;
    
    const sum2 = checkDigits2.reduce((acc, multiplier, index) => 
      acc + multiplier * digits[index], 0) % 11 % 10;
    
    return sum1 === digits[10] && sum2 === digits[11];
  }
  
  return false;
};

export const isNotBannedWord = (value, bannedWords = []) => {
  if (!value) return true;
  
  const lowerValue = value.toLowerCase();
  return !bannedWords.some(word => lowerValue.includes(word.toLowerCase()));
};
```

### Использование в компоненте Vue

```vue
<template>
  <form @submit.prevent="submitForm">
    <div class="form-group">
      <label for="phone">Телефон:</label>
      <input 
        id="phone"
        v-model="formData.phone" 
        type="tel" 
        @blur="validatePhone"
        :class="{ 'is-invalid': errors.phone }"
      />
      <div v-if="errors.phone" class="invalid-feedback">
        {{ errors.phone }}
      </div>
    </div>
    
    <div class="form-group">
      <label for="inn">ИНН:</label>
      <input 
        id="inn"
        v-model="formData.inn" 
        type="text" 
        maxlength="12"
        @blur="validateINN"
        :class="{ 'is-invalid': errors.inn }"
      />
      <div v-if="errors.inn" class="invalid-feedback">
        {{ errors.inn }}
      </div>
    </div>
    
    <div class="form-group">
      <label for="comment">Комментарий:</label>
      <textarea 
        id="comment"
        v-model="formData.comment" 
        @blur="validateComment"
        :class="{ 'is-invalid': errors.comment }"
      ></textarea>
      <div v-if="errors.comment" class="invalid-feedback">
        {{ errors.comment }}
      </div>
    </div>
    
    <button type="submit" :disabled="!isFormValid">Отправить</button>
  </form>
</template>

<script>
import { isRussianPhone, isRussianINN, isNotBannedWord } from './validators'

export default {
  data() {
    return {
      formData: {
        phone: '',
        inn: '',
        comment: ''
      },
      errors: {},
      bannedWords: ['спам', 'реклама', 'бот']
    }
  },
  computed: {
    isFormValid() {
      return Object.keys(this.errors).length === 0;
    }
  },
  methods: {
    validatePhone() {
      if (!this.formData.phone) {
        this.errors.phone = 'Телефон обязателен';
      } else if (!isRussianPhone(this.formData.phone)) {
        this.errors.phone = 'Некорректный формат российского номера телефона';
      } else {
        delete this.errors.phone;
      }
    },
    
    validateINN() {
      if (!this.formData.inn) {
        this.errors.inn = 'ИНН обязателен';
      } else if (!isRussianINN(this.formData.inn)) {
        this.errors.inn = 'Некорректный ИНН';
      } else {
        delete this.errors.inn;
      }
    },
    
    validateComment() {
      if (!this.formData.comment) {
        this.errors.comment = 'Комментарий обязателен';
      } else if (!isNotBannedWord(this.formData.comment, this.bannedWords)) {
        this.errors.comment = 'Комментарий содержит запрещенные слова';
      } else if (this.formData.comment.length > 500) {
        this.errors.comment = 'Комментарий слишком длинный (максимум 500 символов)';
      } else {
        delete this.errors.comment;
      }
    },
    
    submitForm() {
      this.validatePhone();
      this.validateINN();
      this.validateComment();
      
      if (this.isFormValid) {
        console.log('Форма валидна', this.formData);
        // Отправка формы
      }
    }
  }
}
</script>
```

## Использование с VeeValidate

### Регистрация пользовательского валидатора в VeeValidate

```javascript
import { defineRule } from 'vee-validate';
import { isRussianPhone, isRussianINN, isNotBannedWord } from './validators';

// Регистрация пользовательских правил
defineRule('russianPhone', (value) => {
  if (!value) return 'Телефон обязателен';
  if (!isRussianPhone(value)) return 'Некорректный формат российского номера телефона';
  return true;
});

defineRule('russianINN', (value) => {
  if (!value) return 'ИНН обязателен';
  if (!isRussianINN(value)) return 'Некорректный ИНН';
  return true;
});

defineRule('noBannedWords', (value, [bannedWords]) => {
  if (!value) return true;
  if (!isNotBannedWord(value, bannedWords)) return 'Содержит запрещенные слова';
  return true;
});
```

### Использование в шаблоне

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <div class="form-group">
      <Field 
        name="phone" 
        type="tel" 
        class="form-control" 
        :class="{ 'is-invalid': errors.phone }"
      />
      <ErrorMessage name="phone" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <Field 
        name="inn" 
        type="text" 
        maxlength="12"
        class="form-control" 
        :class="{ 'is-invalid': errors.inn }"
      />
      <ErrorMessage name="inn" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <Field 
        name="comment" 
        as="textarea" 
        class="form-control" 
        :class="{ 'is-invalid': errors.comment }"
      />
      <ErrorMessage name="comment" class="invalid-feedback" />
    </div>
    
    <button type="submit">Отправить</button>
  </Form>
</template>

<script>
import { Form, Field, ErrorMessage } from 'vee-validate'
import * as yup from 'yup'

// Регистрация пользовательской схемы валидации
const schema = yup.object({
  phone: yup
    .string()
    .required('Телефон обязателен')
    .test('russian-phone', 'Некорректный формат российского номера телефона', function(value) {
      return isRussianPhone(value);
    }),
  inn: yup
    .string()
    .required('ИНН обязателен')
    .test('russian-inn', 'Некорректный ИНН', function(value) {
      return isRussianINN(value);
    }),
  comment: yup
    .string()
    .required('Комментарий обязателен')
    .max(500, 'Комментарий слишком длинный')
    .test('no-banned-words', 'Содержит запрещенные слова', function(value) {
      return isNotBannedWord(value, ['спам', 'реклама', 'бот']);
    })
});

export default {
  components: {
    Form,
    Field,
    ErrorMessage
  },
  setup() {
    return {
      schema
    }
  },
  methods: {
    onSubmit(values) {
      console.log('Форма отправлена', values);
    }
  }
}
</script>
```

## Валидаторы с параметрами

### Создание валидатора с параметрами

```javascript
// validators/conditional.js
export const isAfterDate = (value, startDate) => {
  if (!value) return true;
  if (!startDate) return true;
  
  const valueDate = new Date(value);
  const startValue = new Date(startDate);
  
  return valueDate > startValue;
};

export const matchesField = (value, otherFieldValue) => {
  return value === otherFieldValue;
};

export const isInRange = (value, min, max) => {
  const numValue = Number(value);
  return numValue >= min && numValue <= max;
};

// Валидатор для российских почтовых индексов
export const isRussianPostalCode = (value) => {
  if (!value) return false;
  const postalRegex = /^\d{6}$/;
  return postalRegex.test(value);
};

// Валидатор для российских серий и номеров паспорта
export const isRussianPassport = (value) => {
  if (!value) return false;
  const passportRegex = /^\d{4}\s\d{6}$/;
  return passportRegex.test(value);
};
```

### Использование валидаторов с параметрами

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <div class="form-group">
      <label for="startDate">Дата начала:</label>
      <Field 
        id="startDate"
        name="startDate" 
        type="date" 
        class="form-control"
      />
      <ErrorMessage name="startDate" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <label for="endDate">Дата окончания:</label>
      <Field 
        id="endDate"
        name="endDate" 
        type="date" 
        class="form-control"
      />
      <ErrorMessage name="endDate" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <label for="password">Пароль:</label>
      <Field 
        id="password"
        name="password" 
        type="password" 
        class="form-control"
      />
      <ErrorMessage name="password" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <label for="confirmPassword">Подтверждение пароля:</label>
      <Field 
        id="confirmPassword"
        name="confirmPassword" 
        type="password" 
        class="form-control"
      />
      <ErrorMessage name="confirmPassword" class="invalid-feedback" />
    </div>
    
    <div class="form-group">
      <label for="age">Возраст:</label>
      <Field 
        id="age"
        name="age" 
        type="number" 
        class="form-control"
      />
      <ErrorMessage name="age" class="invalid-feedback" />
    </div>
    
    <button type="submit">Отправить</button>
  </Form>
</template>

<script>
import { Form, Field, ErrorMessage } from 'vee-validate'
import * as yup from 'yup'
import { isAfterDate, matchesField, isInRange } from './validators/conditional'

const schema = yup.object({
  startDate: yup.date().required('Дата начала обязательна'),
  endDate: yup
    .date()
    .required('Дата окончания обязательна')
    .test(
      'is-after-start-date',
      'Дата окончания должна быть позже даты начала',
      function(value) {
        const { startDate } = this.parent;
        return isAfterDate(value, startDate);
      }
    ),
  password: yup
    .string()
    .min(8, 'Пароль должен содержать не менее 8 символов')
    .required('Пароль обязателен'),
  confirmPassword: yup
    .string()
    .required('Подтверждение пароля обязательно')
    .oneOf([yup.ref('password')], 'Пароли не совпадают'),
  age: yup
    .number()
    .required('Возраст обязателен')
    .test(
      'is-in-range',
      'Возраст должен быть от 18 до 100 лет',
      function(value) {
        return isInRange(value, 18, 100);
      }
    )
});

export default {
  components: {
    Form,
    Field,
    ErrorMessage
  },
  setup() {
    return {
      schema
    }
  },
  methods: {
    onSubmit(values) {
      console.log('Форма отправлена', values);
    }
  }
}
</script>
```

## Валидаторы для специфических российских данных

### Валидатор для СНИЛС

```javascript
export const isSnils = (value) => {
  if (!value) return false;
  
  // Удаляем все нецифровые символы
  const cleanValue = value.replace(/\D/g, '');
  
  if (cleanValue.length !== 11) return false;
  
  // Проверяем контрольное число
  const digits = cleanValue.split('').map(Number);
  const controlSum = digits.slice(0, 9).reduce((sum, digit, index) => 
    sum + digit * (9 - index), 0);
  
  const controlDigit = controlSum % 101;
  const expectedControl = controlDigit > 99 ? 0 : controlDigit;
  
  return digits[9] * 10 + digits[10] === expectedControl;
};
```

### Валидатор для ОГРН

```javascript
export const isOGRN = (value) => {
  if (!value) return false;
  
  const cleanValue = value.replace(/\D/g, '');
  
  // ОГРН должен содержать 13 или 15 цифр
  if (cleanValue.length !== 13 && cleanValue.length !== 15) return false;
  
  // Алгоритм проверки контрольного числа
  const mainPart = cleanValue.slice(0, -1);
  const controlDigit = parseInt(cleanValue.slice(-1));
  
  if (cleanValue.length === 13) {
    // Проверка для ОГРН юридического лица
    const calculatedControl = parseInt(mainPart) % 11 % 10;
    return calculatedControl === controlDigit;
  } else if (cleanValue.length === 15) {
    // Проверка для ОГРНИП
    const calculatedControl = parseInt(mainPart) % 13 % 10;
    return calculatedControl === controlDigit;
  }
  
  return false;
};
```

## Асинхронные валидаторы

### Проверка уникальности данных

```javascript
import axios from 'axios';

export const isUniqueEmail = async (email) => {
  if (!email) return true;
  
  try {
    const response = await axios.get(`/api/check-email/${email}`);
    return response.data.isUnique;
  } catch (error) {
    // В случае ошибки запроса, считаем валидным для избежания блокировки формы
    console.warn('Ошибка проверки уникальности email:', error);
    return true;
  }
};

export const isUsernameAvailable = async (username) => {
  if (!username) return true;
  
  try {
    const response = await axios.post('/api/check-username', { username });
    return response.data.isAvailable;
  } catch (error) {
    console.warn('Ошибка проверки доступности username:', error);
    return true;
  }
};
```

### Использование асинхронных валидаторов в VeeValidate

```vue
<template>
  <Form @submit="onSubmit" :validation-schema="schema">
    <div class="form-group">
      <Field 
        name="email" 
        type="email" 
        class="form-control"
        :class="{ 'is-invalid': errors.email }"
      />
      <ErrorMessage name="email" class="invalid-feedback" />
      <div v-if="emailCheckStatus === 'checking'" class="text-info">
        Проверка...
      </div>
      <div v-else-if="emailCheckStatus === 'available'" class="text-success">
        Email доступен
      </div>
    </div>
    
    <button type="submit">Отправить</button>
  </Form>
</template>

<script>
import { Form, Field, ErrorMessage, useField } from 'vee-validate'
import * as yup from 'yup'
import { isUniqueEmail } from './validators/async'

const schema = yup.object({
  email: yup
    .string()
    .email('Некорректный формат email')
    .required('Email обязателен')
    .test(
      'unique-email',
      'Email уже используется',
      async function(value) {
        if (!value) return true;
        return await isUniqueEmail(value);
      }
    )
});

export default {
  components: {
    Form,
    Field,
    ErrorMessage
  },
  setup() {
    const { value: email, errorMessage: emailError } = useField('email');
    
    // Состояния для UI-индикации
    const emailCheckStatus = ref('');
    
    watch(email, async (newEmail) => {
      if (newEmail && !emailError.value) {
        emailCheckStatus.value = 'checking';
        const isUnique = await isUniqueEmail(newEmail);
        emailCheckStatus.value = isUnique ? 'available' : 'taken';
      } else {
        emailCheckStatus.value = '';
      }
    });
    
    return {
      schema,
      emailCheckStatus
    }
  },
  methods: {
    async onSubmit(values) {
      console.log('Форма отправлена', values);
    }
  }
}
</script>
```

## Российские реалии 2025

В 2025 году при создании пользовательских валидаторов для российских проектов необходимо учитывать:

- **Форматы российских данных**: ИНН, ОГРН, СНИЛС, паспортные данные
- **Локализация**: Валидационные сообщения на русском языке
- **Соответствие законодательству**: Проверка корректности персональных данных
- **Требования к форматам**: Соответствие форматам, установленным российскими стандартами

## Лучшие практики

1. **Централизованное хранение**: Размещение валидаторов в отдельных модулях
2. **Тестирование**: Написание unit-тестов для каждого валидатора
3. **Документация**: Комментирование логики работы валидаторов
4. **Производительность**: Оптимизация сложных валидаций
5. **Повторное использование**: Создание универсальных валидаторов

## Заключение

Пользовательские валидаторы позволяют реализовать сложную бизнес-логику проверки данных в Vue-приложениях. Правильная архитектура и реализация обеспечивают гибкость, надежность и удобство сопровождения кода.

## См. также

- [[Валидация на клиенте]]
- [[Валидация на сервере]]
- [[UX валидации]]
- [[Тестирование форм]]