---
aliases: ["Переиспользование элементов", "DOM-элементы и ключи", "Vue DOM reuse"]
tags: ["#vue", "#v-for", "#key", "#rendering", "#performance"]
---

# Переиспользование элементов

## Обзор

[Vue.js](https://ru.vuejs.org/guide/essentials/list.html#maintaining-state-with-key) стремится переиспользовать DOM-элементы при обновлении списков, отображаемых с помощью `v-for`. Это поведение по умолчанию улучшает производительность, но может привести к нежелательным эффектам, если элементы содержат состояние или данные, которые не должны быть переиспользованы. Атрибут `key` позволяет контролировать этот процесс, указывая Vue, какие элементы уникальны и должны быть обновлены независимо.

## Как работает переиспользование

Когда список элементов обновляется, Vue сопоставляет элементы нового списка с элементами старого списка. Без атрибута `key` Vue сопоставляет элементы по их позиции в списке (на основе индекса). Это означает, что если элементы перемещаются, Vue может попытаться переиспользовать DOM-элементы, просто изменив их содержимое, вместо того чтобы перемещать или создавать новые элементы. Это может привести к сбросу состояния компонентов (например, значение полей ввода) или неправильной анимации.

## Роль атрибута `key`

Атрибут `key` предоставляет уникальный идентификатор для каждого элемента в списке. Vue использует этот идентификатор для отслеживания идентичности элемента. Если `key` изменяется, Vue создает новый элемент. Если `key` остается прежним, Vue может переиспользовать существующий DOM-элемент, но обновит его содержимое в соответствии с новыми данными.

## Практические рекомендации

- **Используйте `key` для списков**: Всегда используйте атрибут `key` в `v-for`, особенно если элементы содержат состояние (например, `<input>`, `<textarea>`, компоненты с внутренним состоянием).
- **Избегайте `index` как `key` при изменении списка**: Если список может быть отсортирован, отфильтрован или в него могут быть добавлены/удалены элементы, использование индекса в качестве ключа может привести к неправильному переиспользованию элементов.
- **Убедитесь в уникальности `key`**: Значения `key` должны быть уникальными в пределах одного `v-for`. Дубликаты могут вызвать ошибки и непредсказуемое поведение.
- **Используйте стабильные идентификаторы**: Используйте уникальные и стабильные идентификаторы из ваших данных (например, `item.id`) в качестве `key`.

## Примеры

### Проблема без `key` при сортировке

```vue
<template>
  <!-- Без :key Vue будет переиспользовать элементы по индексу -->
  <div v-for="item in sortedItems">
    <input v-model="item.value" placeholder="Введите значение">
    <p>{{ item.name }}: {{ item.value }}</p>
  </div>
  <button @click="sortItems">Сортировать</button>
</template>

<script>
export default {
  data() {
    return {
      items: [
        { id: 1, name: 'Элемент A', value: 'Значение A' },
        { id: 2, name: 'Элемент B', value: 'Значение B' },
        { id: 3, name: 'Элемент C', value: 'Значение C' }
      ]
    }
  },
  computed: {
    sortedItems() {
      return this.items.slice().sort((a, b) => a.name.localeCompare(b.name));
    }
  },
  methods: {
    sortItems() {
      // Изменение данных вызывает перерендеринг
    }
  }
}
</script>
```
При сортировке значения ввода могут "перемешаться" между элементами, так как Vue переиспользует DOM-элементы по индексу.

### Решение с использованием `key`

```vue
<template>
  <!-- С :key Vue будет корректно обновлять элементы -->
  <div v-for="item in sortedItems" :key="item.id">
    <input v-model="item.value" placeholder="Введите значение">
    <p>{{ item.name }}: {{ item.value }}</p>
  </div>
  <button @click="sortItems">Сортировать</button>
</template>
```
Теперь при сортировке каждый элемент будет корректно связан со своим DOM-элементом, и состояние ввода сохранится правильно.

## Связанные темы

- [[v-for-с-ключами]]
- [[Уникальные-ключи]]
- [[Лучшие-практики-рендеринга]]
- [[Оптимизация-рендеринга]]

## Заключение

Понимание и правильное использование атрибута `key` позволяет контролировать переиспользование DOM-элементов в Vue, что критически важно для сохранения состояния компонентов и обеспечения корректного поведения интерфейса при изменении списков.
