---
aliases: ["Очистка побочных эффектов", "Effect Cleanup", "Управление эффектами"]
tags: ["#vue", "#effects", "#cleanup", "#reactivity", "#frontend"]
---

# Очистка эффектов

## Обзор

Очистка эффектов в Vue.js - это процесс корректного завершения побочных эффектов, таких как подписки, таймеры, асинхронные операции и другие внешние взаимодействия, чтобы предотвратить утечки памяти и нежелательное поведение приложения. Это критически важный аспект управления жизненным циклом компонентов.

## Принципы очистки эффектов

В Vue эффекты могут возникать в нескольких контекстах:
- При использовании `watch` и `watchEffect`
- При выполнении асинхронных операций
- При создании подписок на события
- При установке таймеров
- При взаимодействии с внешними библиотеками

## Очистка в watch и watchEffect

В Composition API функции `watch` и `watchEffect` поддерживают возврат функции очистки:

```javascript
import { watch, watchEffect, ref } from 'vue'

export default {
  setup() {
    const sourceData = ref('initial')
    const externalResource = ref(null)

    // watch с функцией очистки
    watch(sourceData, (newVal, oldVal, onInvalidate) => {
      let cancelled = false
      
      // Отметить задачу как недействительную при следующем изменении
      onInvalidate(() => {
        cancelled = true
      })
      
      // Асинхронная операция
      fetchData(newVal).then(result => {
        if (!cancelled) {
          externalResource.value = result
        }
      })
    })

    // watchEffect с функцией очистки
    watchEffect((onInvalidate) => {
      const subscription = subscribeToSource(sourceData.value)
      
      // Функция очистки
      onInvalidate(() => {
        subscription.unsubscribe()
      })
    })

    return { sourceData, externalResource }
  }
}

// Вспомогательные функции
function fetchData(value) {
  return new Promise(resolve => {
    setTimeout(() => resolve(`Данные для ${value}`), 1000)
  })
}

function subscribeToSource(source) {
  // Возвращаем объект с методом отписки
  return {
    unsubscribe: () => console.log(`Отписка от ${source}`)
  }
}
```

## Очистка при размонтировании компонента

Критически важно очищать эффекты при размонтировании компонента:

```javascript
import { ref, onMounted, onUnmounted, watchEffect } from 'vue'

export default {
  setup() {
    const intervalId = ref(null)
    const externalSubscription = ref(null)
    const asyncTaskController = ref(null)

    onMounted(() => {
      // Установка интервала
      intervalId.value = setInterval(() => {
        console.log('Выполняется интервал')
      }, 1000)

      // Подписка на внешний ресурс
      externalSubscription.value = subscribeToExternalService()

      // Асинхронная задача с контроллером отмены
      asyncTaskController.value = new AbortController()
      fetchDataWithAbort(asyncTaskController.value.signal)
    })

    onUnmounted(() => {
      // Очистка всех эффектов при размонтировании
      if (intervalId.value) {
        clearInterval(intervalId.value)
        intervalId.value = null
      }

      if (externalSubscription.value) {
        externalSubscription.value.unsubscribe()
        externalSubscription.value = null
      }

      if (asyncTaskController.value) {
        asyncTaskController.value.abort()
        asyncTaskController.value = null
      }
    })

    return { /* ... */ }
  }
}

function subscribeToExternalService() {
  return {
    unsubscribe: () => console.log('Отписка от внешнего сервиса')
  }
}

async function fetchDataWithAbort(signal) {
  try {
    const response = await fetch('/api/data', { signal })
    const data = await response.json()
    console.log('Данные получены:', data)
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Запрос отменен')
    } else {
      console.error('Ошибка запроса:', error)
    }
  }
}
```

## Очистка в Composables

Часто логику очистки эффектов выносят в composables:

```javascript
// composables/useSubscription.js
import { onUnmounted } from 'vue'

export function useSubscription(subscriptionFactory) {
  const subscription = subscriptionFactory()
  
  onUnmounted(() => {
    if (subscription && typeof subscription.unsubscribe === 'function') {
      subscription.unsubscribe()
    }
  })
  
  return subscription
}

// composables/useInterval.js
import { onUnmounted, ref } from 'vue'

export function useInterval(callback, delay) {
  const intervalId = ref(null)
  
  const start = () => {
    if (intervalId.value) {
      clearInterval(intervalId.value)
    }
    
    intervalId.value = setInterval(callback, delay)
  }
  
  const stop = () => {
    if (intervalId.value) {
      clearInterval(intervalId.value)
      intervalId.value = null
    }
  }
  
  onUnmounted(() => {
    stop()
  })
  
  return {
    start,
    stop,
    intervalId
  }
}

// composables/useAsyncState.js
import { ref, onUnmounted } from 'vue'

export function useAsyncState(asyncFunction) {
  const state = ref(null)
  const loading = ref(false)
  const error = ref(null)
  const abortController = ref(null)
  
  const execute = async () => {
    if (abortController.value) {
      abortController.value.abort()
    }
    
    abortController.value = new AbortController()
    loading.value = true
    error.value = null
    
    try {
      const result = await asyncFunction(abortController.value.signal)
      if (!abortController.value.signal.aborted) {
        state.value = result
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        error.value = err
      }
    } finally {
      loading.value = false
    }
  }
  
  onUnmounted(() => {
    if (abortController.value) {
      abortController.value.abort()
    }
  })
  
  return {
    state,
    loading,
    error,
    execute
  }
}
```

## Управление несколькими эффектами

Для управления несколькими эффектами можно использовать массив очистки:

```javascript
import { onUnmounted } from 'vue'

export default {
  setup() {
    const cleanupFunctions = []
    
    // Добавление различных эффектов
    const intervalId = setInterval(() => console.log('Интервал'), 1000)
    cleanupFunctions.push(() => clearInterval(intervalId))
    
    const subscription = subscribeToEvents()
    cleanupFunctions.push(() => subscription.unsubscribe())
    
    const observer = new MutationObserver(callback)
    observer.observe(targetElement, options)
    cleanupFunctions.push(() => observer.disconnect())
    
    // Очистка всех эффектов при размонтировании
    onUnmounted(() => {
      cleanupFunctions.forEach(cleanup => cleanup())
      cleanupFunctions.length = 0 // Очистка массива
    })
    
    return { /* ... */ }
  }
}

function subscribeToEvents() {
  return {
    unsubscribe: () => console.log('Отписка от событий')
  }
}
```

## Очистка при изменении зависимостей

Важно очищать эффекты не только при размонтировании, но и при изменении зависимостей:

```javascript
import { ref, watch, onUnmounted } from 'vue'

export default {
  props: {
    userId: {
      type: Number,
      required: true
    }
  },
  
  setup(props) {
    const userData = ref(null)
    const currentRequest = ref(null)
    
    const fetchUserData = async (userId) => {
      // Отмена предыдущего запроса
      if (currentRequest.value) {
        currentRequest.value.abort()
      }
      
      const controller = new AbortController()
      currentRequest.value = controller
      
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal
        })
        
        if (!controller.signal.aborted) {
          userData.value = await response.json()
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Ошибка получения данных пользователя:', error)
        }
      }
    }
    
    // Отслеживание изменений userId
    watch(
      () => props.userId,
      (newUserId) => {
        fetchUserData(newUserId)
      },
      { immediate: true }
    )
    
    onUnmounted(() => {
      if (currentRequest.value) {
        currentRequest.value.abort()
      }
    })
    
    return { userData }
  }
}
```

## Очистка в глубоких наблюдателях

При работе с глубокими наблюдателями также важна очистка:

```javascript
import { ref, watch } from 'vue'

export default {
  setup() {
    const complexObject = ref({
      items: [],
      settings: { enabled: true }
    })
    
    // Глубокое наблюдение с очисткой
    watch(
      complexObject,
      (newVal, oldVal, onInvalidate) => {
        let hasBeenInvalidated = false
        
        onInvalidate(() => {
          hasBeenInvalidated = true
        })
        
        // Выполнение асинхронной операции
        processData(newVal).then(result => {
          if (!hasBeenInvalidated) {
            console.log('Обработанные данные:', result)
          }
        })
      },
      { deep: true }
    )
    
    return { complexObject }
  }
}

async function processData(obj) {
  return new Promise(resolve => {
    setTimeout(() => resolve(`Обработано: ${JSON.stringify(obj)}`), 500)
  })
}
```

## Лучшие практики очистки эффектов

- **Используйте onUnmounted**: Всегда очищайте эффекты в `onUnmounted` (Composition API) или `beforeUnmount` (Options API)
- **Возвращайте функцию очистки**: В `watch` и `watchEffect` используйте функцию очистки через `onInvalidate`
- **Храните ссылки на ресурсы**: Сохраняйте ссылки на таймеры, подписки и другие ресурсы для последующей очистки
- **Отменяйте асинхронные операции**: Используйте `AbortController` для отмены fetch-запросов
- **Проверяйте существование**: Перед очисткой проверяйте, что ресурс существует
- **Используйте Composables**: Для повторного использования логики очистки эффектов

## Связь с другими концепциями

- [[Async-операции]] - для понимания очистки асинхронных эффектов
- [[Подписки]] - для понимания очистки подписок как разновидности эффектов
- [[Таймеры]] - для понимания очистки таймеров как эффектов
- [[Управление-ресурсами]] - для понимания общего подхода к управлению ресурсами

> [!warning] Важно
> Неправильная очистка эффектов может привести к утечкам памяти, нежелательному поведению приложения и ошибкам при обращении к размонтированным компонентам.

> [!tip] Совет
> Используйте библиотеки вроде `@vueuse/core`, которые предоставляют готовые решения для управления эффектами с правильной очисткой.