---
aliases: ["Управление таймерами", "JavaScript Timers", "setTimeout и setInterval"]
tags: ["#vue", "#timers", "#effects", "#javascript", "#frontend"]
---

# Таймеры

## Обзор

Таймеры в Vue.js - это побочные эффекты, связанные с использованием `setTimeout` и `setInterval` для выполнения кода через определенные промежутки времени. Правильное управление таймерами критически важно для предотвращения утечек памяти и нежелательного поведения компонентов.

## Использование setTimeout в компонентах

В Vue компонентах таймеры должны управляться с учетом жизненного цикла компонента:

```javascript
// Options API
export default {
  data() {
    return {
      timerId: null,
      seconds: 0
    }
  },
  
  mounted() {
    this.timerId = setTimeout(() => {
      console.log('Таймер сработал')
      this.seconds = 10
    }, 5000)
  },
  
  beforeUnmount() {
    // Обязательная очистка таймера при размонтировании
    if (this.timerId) {
      clearTimeout(this.timerId)
    }
  }
}
```

## Использование setInterval в компонентах

Работа с интервальными таймерами требует особого внимания:

```javascript
// Options API
export default {
  data() {
    return {
      intervalId: null,
      counter: 0
    }
  },
  
  mounted() {
    this.intervalId = setInterval(() => {
      this.counter++
      console.log(`Счетчик: ${this.counter}`)
    }, 1000)
  },
  
  beforeUnmount() {
    // Обязательная остановка интервала при размонтировании
    if (this.intervalId) {
      clearInterval(this.intervalId)
    }
  },
  
  methods: {
    stopTimer() {
      if (this.intervalId) {
        clearInterval(this.intervalId)
        this.intervalId = null
      }
    },
    
    startTimer() {
      if (!this.intervalId) {
        this.intervalId = setInterval(() => {
          this.counter++
        }, 1000)
      }
    }
  }
}
```

## Таймеры в Composition API

В Composition API управление таймерами осуществляется с помощью хуков жизненного цикла:

```javascript
import { ref, onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    const seconds = ref(0)
    const timerId = ref(null)

    onMounted(() => {
      timerId.value = setTimeout(() => {
        seconds.value = 10
      }, 5000)
    })

    onUnmounted(() => {
      if (timerId.value) {
        clearTimeout(timerId.value)
      }
    })

    return { seconds }
  }
}
```

## Управление интервальными таймерами в Composition API

```javascript
import { ref, onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    const counter = ref(0)
    const intervalId = ref(null)

    const startTimer = () => {
      if (!intervalId.value) {
        intervalId.value = setInterval(() => {
          counter.value++
        }, 1000)
      }
    }

    const stopTimer = () => {
      if (intervalId.value) {
        clearInterval(intervalId.value)
        intervalId.value = null
      }
    }

    onMounted(() => {
      startTimer()
    })

    onUnmounted(() => {
      stopTimer()
    })

    return {
      counter,
      startTimer,
      stopTimer
    }
  }
}
```

## Сложные сценарии с таймерами

Иногда требуется более сложное управление таймерами:

```javascript
import { ref, onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    const timeLeft = ref(60)
    const intervalId = ref(null)
    const isRunning = ref(false)

    const startTimer = () => {
      if (isRunning.value) return
      
      isRunning.value = true
      intervalId.value = setInterval(() => {
        timeLeft.value--
        
        if (timeLeft.value <= 0) {
          stopTimer()
          timeLeft.value = 0
          console.log('Таймер завершен')
        }
      }, 1000)
    }

    const stopTimer = () => {
      if (intervalId.value) {
        clearInterval(intervalId.value)
        intervalId.value = null
        isRunning.value = false
      }
    }

    const resetTimer = () => {
      stopTimer()
      timeLeft.value = 60
    }

    onUnmounted(() => {
      stopTimer()
    })

    return {
      timeLeft,
      isRunning,
      startTimer,
      stopTimer,
      resetTimer
    }
  }
}
```

## Таймеры с динамическим интервалом

```javascript
import { ref, onMounted, onUnmounted, watch } from 'vue'

export default {
  props: {
    interval: {
      type: Number,
      default: 1000
    }
  },
  
  setup(props) {
    const count = ref(0)
    const intervalId = ref(null)

    const startTimer = () => {
      if (intervalId.value) {
        clearInterval(intervalId.value)
      }
      
      intervalId.value = setInterval(() => {
        count.value++
      }, props.interval)
    }

    onMounted(() => {
      startTimer()
    })

    // Перезапуск таймера при изменении интервала
    watch(() => props.interval, () => {
      startTimer()
    })

    onUnmounted(() => {
      if (intervalId.value) {
        clearInterval(intervalId.value)
      }
    })

    return { count }
  }
}
```

## Composable для управления таймерами

Для повторного использования логики управления таймерами создадим composable:

```javascript
// composables/useTimer.js
import { ref, onUnmounted } from 'vue'

export function useTimeout(callback, delay) {
  const timeoutId = ref(null)

  const start = () => {
    if (timeoutId.value) {
      clearTimeout(timeoutId.value)
    }
    
    timeoutId.value = setTimeout(callback, delay)
  }

  const clear = () => {
    if (timeoutId.value) {
      clearTimeout(timeoutId.value)
      timeoutId.value = null
    }
  }

  // Автоматическая очистка при размонтировании
  onUnmounted(() => {
    clear()
  })

  return {
    start,
    clear,
    timeoutId
  }
}

export function useInterval(callback, delay) {
  const intervalId = ref(null)

  const start = () => {
    if (intervalId.value) {
      clearInterval(intervalId.value)
    }
    
    intervalId.value = setInterval(callback, delay)
  }

  const stop = () => {
    if (intervalId.value) {
      clearInterval(intervalId.value)
      intervalId.value = null
    }
  }

  // Автоматическая остановка при размонтировании
  onUnmounted(() => {
    stop()
  })

  return {
    start,
    stop,
    intervalId
  }
}
```

## Использование таймеров с реактивными данными

```javascript
import { ref, watch, onUnmounted } from 'vue'

export default {
  setup() {
    const userInput = ref('')
    const debouncedValue = ref('')
    let debounceTimer = null

    // Дебаунс ввода пользователя
    watch(userInput, (newValue) => {
      if (debounceTimer) {
        clearTimeout(debounceTimer)
      }
      
      debounceTimer = setTimeout(() => {
        debouncedValue.value = newValue
        // Выполнить действие с дебаунсом
        console.log('Дебаунсед значение:', newValue)
      }, 500)
    })

    onUnmounted(() => {
      if (debounceTimer) {
        clearTimeout(debounceTimer)
      }
    })

    return {
      userInput,
      debouncedValue
    }
  }
}
```

## Лучшие практики

- **Обязательная очистка**: Всегда очищайте таймеры в `beforeUnmount` (Options API) или `onUnmounted` (Composition API)
- **Проверка существования**: Перед очисткой таймера проверяйте, что он существует
- **Используйте ref**: В Composition API храните идентификаторы таймеров в ref для реактивности
- **Избегайте утечек**: Не забывайте очищать таймеры при изменении условий или размонтировании
- **Используйте Composables**: Для повторного использования логики управления таймерами

## Связь с другими концепциями

- [[Async-операции]] - для понимания асинхронных эффектов
- [[Подписки]] - для понимания общих принципов управления побочными эффектами
- [[Очистка-эффектов]] - для понимания общих принципов очистки эффектов
- [[Управление-ресурсами]] - для понимания общего подхода к управлению ресурсами

> [!warning] Важно
> Забытые таймеры могут продолжать выполняться даже после размонтирования компонента, что приводит к утечкам памяти и нежелательному поведению.

> [!tip] Совет
> Используйте библиотеки вроде `@vueuse/core` для удобного управления таймерами в Vue 3 приложениях, которые уже включают в себя правильную очистку.