---
aliases: ["Кеширование страниц в SSR", "HTTP кеширование в Vue", "Стратегии кеширования"]
tags: [vue, ssr, кеширование, производительность, http, frontend]
---

# Кеширование страниц в Vue.js SSR приложениях

## Введение

Кеширование страниц - ключевой аспект оптимизации производительности серверно-рендеримых приложений на Vue.js. В условиях российского рынка 2025 года, где важна как скорость загрузки, так и эффективность использования ресурсов, правильная стратегия кеширования может значительно улучшить пользовательский опыт и снизить нагрузку на серверы.

## Типы кеширования

### Клиентское кеширование

Клиентское кеширование происходит в браузере пользователя и регулируется HTTP заголовками:

```javascript
// Пример HTTP заголовков кеширования
app.use((req, res, next) => {
  // Кеширование статических ресурсов на 1 год
  if (req.url.startsWith('/static/') || req.url.match(/\.(js|css|png|jpg|jpeg|gif|ico|svg)$/)) {
    res.setHeader('Cache-Control', 'public, max-age=31536000');
  } else {
    // Для HTML страниц - без кеширования или короткое кеширование
    res.setHeader('Cache-Control', 'no-cache');
  }
  next();
});
```

### Серверное кеширование

Серверное кеширование позволяет хранить результаты рендеринга на сервере:

```javascript
// server.js
const LRU = require('lru-cache');
const microCache = new LRU({
  max: 100,
  maxAge: 1000 * 60 * 5 // 5 минут
});

app.get('*', async (req, res) => {
  const cacheKey = req.url + req.headers.cookie;
  const cached = microCache.get(cacheKey);
  
  if (cached) {
    res.setHeader('X-Cache', 'HIT');
    res.send(cached);
    return;
  }
  
  const html = await renderVueApp(req.url);
  microCache.set(cacheKey, html);
  res.setHeader('X-Cache', 'MISS');
  res.send(html);
});
```

### CDN кеширование

Использование CDN для кеширования контента:

```javascript
// nuxt.config.js
export default defineNuxtConfig({
  nitro: {
    // Конфигурация для различных провайдеров
    preset: 'vercel'
  },
  hooks: {
    'render:html': (html) => {
      // Добавление заголовков для CDN кеширования
      html.head.unshift(`
        <meta http-equiv="Cache-Control" content="public, max-age=3600">
      `);
    }
  }
});
```

## Кеширование на уровне компонентов

### Кеширование вычисляемых свойств

Vue.js автоматически кеширует вычисляемые свойства:

```javascript
export default {
  data() {
    return {
      items: []
    }
  },
  computed: {
    expensiveValue() {
      // Результат будет кеширован до изменения зависимостей
      console.log('Вычисление expensiveValue');
      return this.items
        .filter(item => item.active)
        .map(item => item.value)
        .reduce((sum, value) => sum + value, 0);
    }
  }
}
```

### Кеширование с использованием memoization

Для сложных вычислений можно использовать memoization:

```javascript
// utils/memoize.js
export function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// В компоненте
export default {
  methods: {
    expensiveCalculation: memoize(function(a, b, c) {
      // Сложное вычисление
      return a * b + c;
    })
  }
}
```

## Кеширование данных

### Кеширование API данных

Для SSR приложений важно кешировать данные на сервере:

```javascript
// composables/useCachedData.js
export const useCachedData = (key, fetcher, options = {}) => {
  const { maxAge = 60000 } = options; // 1 минута по умолчанию
  
  // Серверный кеш
  if (process.server) {
    const cache = useRuntimeConfig().serverCache || new Map();
    const cached = cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < maxAge) {
      return Promise.resolve(cached.data);
    }
    
    return fetcher().then(data => {
      cache.set(key, {
        data,
        timestamp: Date.now()
      });
      return data;
    });
  }
  
  // На клиенте используем стандартный asyncData
  return useAsyncData(key, fetcher, options);
};
```

### Кеширование в Vuex/Pinia

Для управления состоянием с кешированием:

```javascript
// stores/data.js
export const useDataStore = defineStore('data', () => {
  const cache = ref(new Map());
  const cacheTimeouts = ref(new Map());
  
  const getData = async (id, fetcher, cacheTime = 300000) => { // 5 минут
    const cached = cache.value.get(id);
    
    if (cached && Date.now() - cached.timestamp < cacheTime) {
      return cached.data;
    }
    
    // Очистка старого таймера
    if (cacheTimeouts.value.has(id)) {
      clearTimeout(cacheTimeouts.value.get(id));
    }
    
    const data = await fetcher(id);
    
    cache.value.set(id, {
      data,
      timestamp: Date.now()
    });
    
    // Автоматическая очистка кеша
    const timeout = setTimeout(() => {
      cache.value.delete(id);
      cacheTimeouts.value.delete(id);
    }, cacheTime);
    
    cacheTimeouts.value.set(id, timeout);
    
    return data;
  };
  
  return {
    getData
  };
});
```

## HTTP заголовки кеширования

### Cache-Control

Наиболее важный заголовок для кеширования:

```javascript
// Примеры заголовков Cache-Control
res.setHeader('Cache-Control', 'public, max-age=3600'); // Публичное кеширование на 1 час
res.setHeader('Cache-Control', 'private, max-age=300'); // Приватное кеширование на 5 минут
res.setHeader('Cache-Control', 'no-cache'); // Не кешировать
res.setHeader('Cache-Control', 'no-store'); // Не хранить вовсе
res.setHeader('Cache-Control', 'must-revalidate'); // Проверять актуальность
```

### ETags

Использование ETags для эффективной валидации кеша:

```javascript
const crypto = require('crypto');

function generateETag(content) {
  return `"${crypto.createHash('md5').update(content).digest('hex')}"`;
}

app.use(async (req, res, next) => {
  const originalSend = res.send;
  
  res.send = function(body) {
    const etag = generateETag(body);
    res.setHeader('ETag', etag);
    
    // Проверка If-None-Match
    if (req.headers['if-none-match'] === etag) {
      res.status(304).end();
      return;
    }
    
    originalSend.call(this, body);
  };
  
  next();
});
```

## Кеширование в Nuxt.js

### Кеширование страниц

Nuxt.js предоставляет встроенные возможности кеширования:

```vue
<!-- pages/articles/[id].vue -->
<template>
  <div>
    <h1>{{ article.title }}</h1>
    <div v-html="article.content"></div>
  </div>
</template>

<script setup>
// Кеширование данных страницы
const { data: article } = await useAsyncData('article-' + route.params.id, async () => {
  return await $fetch(`/api/articles/${route.params.id}`)
}, {
  // Время жизни кеша в миллисекундах
  maxAge: 60 * 60, // 1 час
  // Проверка на стороне клиента
  serverCache: true
})

// Кеширование на уровне страницы
definePageMeta({
  pageTransition: false,
  key: route => route.fullPath
})
</script>
```

### Кеширование компонентов

Кеширование компонентов с помощью `client:only`:

```vue
<!-- components/CachedComponent.vue -->
<template>
  <div>
    <h2>Кешируемый компонент</h2>
    <p>{{ computedData }}</p>
  </div>
</template>

<script setup>
const props = defineProps(['id'])

// Кеширование вычислений
const computedData = computed(() => {
  // Вычисления, которые будут кешироваться
  return expensiveCalculation(props.id)
})
</script>
```

## Стратегии кеширования

### Cache-Aside

Данные загружаются по требованию и кешируются:

```javascript
class CacheAsideService {
  constructor(cacheProvider) {
    this.cache = cacheProvider;
    this.db = new Database();
  }
  
  async getData(key) {
    // Сначала проверяем кеш
    let data = await this.cache.get(key);
    
    if (!data) {
      // Если в кеше нет, загружаем из базы
      data = await this.db.get(key);
      // Сохраняем в кеш
      await this.cache.set(key, data, 300); // 5 минут
    }
    
    return data;
  }
}
```

### Write-Through

Данные одновременно записываются в кеш и в основное хранилище:

```javascript
class WriteThroughCache {
  constructor(cacheProvider, db) {
    this.cache = cacheProvider;
    this.db = db;
  }
  
  async setData(key, value) {
    // Записываем в базу данных
    await this.db.set(key, value);
    // Одновременно записываем в кеш
    await this.cache.set(key, value);
  }
}
```

## Инструменты кеширования

### Redis для серверного кеширования

Использование Redis для распределенного кеширования:

```javascript
// plugins/redis-cache.js
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

export const redisCache = {
  async get(key) {
    const cached = await redis.get(`cache:${key}`);
    return cached ? JSON.parse(cached) : null;
  },
  
  async set(key, value, ttl = 3600) { // 1 час по умолчанию
    await redis.setex(`cache:${key}`, ttl, JSON.stringify(value));
  },
  
  async delete(key) {
    await redis.del(`cache:${key}`);
  }
};

export default defineNuxtPlugin(() => {
  return {
    provide: {
      cache: redisCache
    }
  };
});
```

### Локальное кеширование в браузере

Использование localStorage/sessionStorage:

```javascript
// composables/useBrowserCache.js
export const useBrowserCache = (storage = 'localStorage') => {
  const get = (key) => {
    if (process.client) {
      const item = window[storage].getItem(key);
      if (item) {
        const parsed = JSON.parse(item);
        // Проверяем срок годности
        if (!parsed.expiry || parsed.expiry > Date.now()) {
          return parsed.value;
        } else {
          // Удаляем просроченный кеш
          window[storage].removeItem(key);
        }
      }
    }
    return null;
  };
  
  const set = (key, value, ttl = 3600000) => { // 1 час по умолчанию
    if (process.client) {
      const item = {
        value: value,
        expiry: ttl ? Date.now() + ttl : null
      };
      window[storage].setItem(key, JSON.stringify(item));
    }
  };
  
  return { get, set };
};
```

## Кеширование для российских реалий

### Работа с отечественными CDN

В 2025 году в России важно учитывать использование отечественных CDN:

```javascript
// plugins/russian-cdn.js
export default defineNuxtPlugin(() => {
  const isRussianUser = computed(() => {
    // Определение местоположения пользователя
    return useCookie('country').value === 'RU';
  });
  
  const getCdnUrl = (path) => {
    if (isRussianUser.value) {
      return `https://cdn-ru.example.com${path}`;
    }
    return `https://cdn.example.com${path}`;
  };
  
  return {
    provide: {
      cdn: getCdnUrl
    }
  };
});
```

### Локализация и кеширование

Кеширование с учетом локализации:

```javascript
// composables/useLocalizedCache.js
export const useLocalizedCache = () => {
  const locale = useCookie('locale').value || 'ru';
  
  const getCacheKey = (baseKey) => {
    return `${baseKey}:${locale}`;
  };
  
  const getCachedData = async (key, fetcher, options = {}) => {
    const cacheKey = getCacheKey(key);
    const cached = await $fetch(`/api/cache/${cacheKey}`);
    
    if (cached) {
      return cached;
    }
    
    const data = await fetcher();
    await $fetch(`/api/cache/${cacheKey}`, {
      method: 'POST',
      body: { data, ...options }
    });
    
    return data;
  };
  
  return { getCacheKey, getCachedData };
};
```

## Мониторинг кеширования

### Метрики кеширования

Отслеживание эффективности кеширования:

```javascript
// plugins/cache-metrics.js
export default defineNuxtPlugin(() => {
  const cacheHits = ref(0);
  const cacheMisses = ref(0);
  
  const getCacheRatio = computed(() => {
    const total = cacheHits.value + cacheMisses.value;
    return total > 0 ? (cacheHits.value / total) * 100 : 0;
  });
  
  if (process.server) {
    // На сервере можно отслеживать заголовки кеширования
    const originalRender = ssrContext => {
      const original = ssrContext.render;
      ssrContext.render = function() {
        // Добавление метрик к рендерингу
        const result = original.apply(this, arguments);
        // Логика подсчета метрик
        return result;
      };
    };
  }
  
  return {
    provide: {
      cacheMetrics: {
        hits: cacheHits,
        misses: cacheMisses,
        ratio: getCacheRatio
      }
    }
  };
});
```

## Заключение

Эффективное кеширование в SSR приложениях на Vue.js требует комплексного подхода, включающего кеширование на разных уровнях: HTTP, компонентов, данных и на уровне CDN. В условиях российского рынка 2025 года особенно важно учитывать особенности инфраструктуры, локализацию и требования к производительности.

Правильная стратегия кеширования может значительно улучшить пользовательский опыт и снизить нагрузку на серверы, что особенно актуально при высокой нагрузке на веб-приложения.

## См. также

- [[Nuxt.js-и-SSR]]
- [[Оптимизация-рендеринга]]
- [[Асинхронные-данные-в-Vue]]
- [[Состояние-приложения-во-Vue]]
- [[Vue.js-и-SSR]]
- [[HTTP-кеширование]]
- [[CDN-стратегии]]