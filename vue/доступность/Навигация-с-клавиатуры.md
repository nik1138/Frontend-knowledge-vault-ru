---
aliases: ["Клавиатурная навигация", "Доступная навигация", "Focus Management"]
tags: ["vue", "accessibility", "keyboard", "navigation", "focus"]
---

# Навигация с клавиатуры в Vue-приложениях

## Введение

Навигация с клавиатуры - это фундаментальный аспект доступности, который позволяет пользователям взаимодействовать с веб-приложением без использования мыши. Это особенно важно для пользователей с моторными нарушениями, слепых пользователей, использующих скринридеры, и других групп пользователей с ограниченными возможностями.

## Основные принципы клавиатурной навигации

### 1. Управление фокусом

Все интерактивные элементы должны быть доступны с клавиатуры:

```vue
<template>
  <div class="keyboard-navigation-example">
    <!-- Правильно: элементы получают фокус по Tab -->
    <button @click="handleClick">Кнопка 1</button>
    <a href="/link">Ссылка</a>
    <input type="text" placeholder="Поле ввода">
    
    <!-- Для несемантических элементов используем tabindex -->
    <div 
      class="custom-button" 
      tabindex="0" 
      @click="handleCustomClick"
      @keydown.enter="handleCustomClick"
      @keydown.space="handleCustomClick">
      Кастомная кнопка
    </div>
  </div>
</template>

<script>
export default {
  name: 'KeyboardNavigationExample',
  methods: {
    handleClick() {
      console.log('Обычная кнопка нажата');
    },
    handleCustomClick() {
      console.log('Кастомная кнопка нажата');
    }
  }
}
</script>
```

### 2. Визуальная индикация фокуса

Важно обеспечить четкую визуализацию элемента в фокусе:

```vue
<template>
  <button class="accessible-button" @click="handleClick">
    {{ buttonText }}
  </button>
</template>

<style scoped>
.accessible-button {
  padding: 10px 15px;
  border: 2px solid #007cba;
  background-color: #007cba;
  color: white;
  cursor: pointer;
}

.accessible-button:focus {
  outline: 3px solid #ffbf47;
  outline-offset: 2px;
  /* Не удаляем outline - это важно для доступности */
}

.accessible-button:focus:not(:focus-visible) {
  outline: none;
}

.accessible-button:focus-visible {
  outline: 3px solid #ffbf47;
  outline-offset: 2px;
}
</style>
```

## Управление фокусом в Vue

### 1. Использование ref для управления фокусом

```vue
<template>
  <div>
    <input ref="firstInput" type="text" placeholder="Первое поле">
    <button @click="focusNext">Перейти к следующему полю</button>
    <input ref="secondInput" type="text" placeholder="Второе поле">
    <button @click="focusFirst">Вернуться к первому полю</button>
  </div>
</template>

<script>
export default {
  name: 'FocusManagement',
  methods: {
    focusNext() {
      this.$refs.secondInput.focus();
    },
    focusFirst() {
      this.$refs.firstInput.focus();
    }
  }
}
</script>
```

### 2. Управление фокусом в модальных окнах

```vue
<template>
  <div>
    <button @click="openModal">Открыть модальное окно</button>
    
    <div v-if="isModalOpen" class="modal-overlay" @keydown.esc="closeModal">
      <div 
        class="modal"
        role="dialog"
        aria-modal="true"
        :aria-labelledby="modalTitleId"
        ref="modal">
        <h2 :id="modalTitleId">Модальное окно</h2>
        <p>Содержимое модального окна</p>
        
        <button @click="closeModal" ref="closeButton">Закрыть</button>
        <button ref="confirmButton">Подтвердить</button>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'ModalWithKeyboardNavigation',
  data() {
    return {
      isModalOpen: false,
      originalFocusedElement: null
    }
  },
  computed: {
    modalTitleId() {
      return `modal-title-${this._uid}`;
    }
  },
  watch: {
    isModalOpen(isOpen) {
      if (isOpen) {
        this.openModal();
      } else {
        this.closeModal();
      }
    }
  },
  methods: {
    openModal() {
      this.originalFocusedElement = document.activeElement;
      this.isModalOpen = true;
      
      // Фокус на модальное окно
      this.$nextTick(() => {
        this.$refs.modal.focus();
      });
    },
    closeModal() {
      this.isModalOpen = false;
      
      // Возвращаем фокус на элемент, который был в фокусе до открытия модального окна
      if (this.originalFocusedElement) {
        this.originalFocusedElement.focus();
      }
    }
  },
  mounted() {
    // Перехватываем Tab внутри модального окна
    this.$refs.modal.addEventListener('keydown', this.handleModalKeydown);
  },
  beforeUnmount() {
    if (this.$refs.modal) {
      this.$refs.modal.removeEventListener('keydown', this.handleModalKeydown);
    }
  },
  methods: {
    handleModalKeydown(event) {
      if (event.key === 'Tab') {
        this.trapFocus(event);
      }
    },
    trapFocus(event) {
      const focusableElements = this.$refs.modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length === 0) return;
      
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];
      
      if (event.shiftKey && document.activeElement === firstElement) {
        lastElement.focus();
        event.preventDefault();
      } else if (!event.shiftKey && document.activeElement === lastElement) {
        firstElement.focus();
        event.preventDefault();
      }
    }
  }
}
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal {
  background: white;
  padding: 20px;
  border-radius: 8px;
  min-width: 300px;
  outline: none;
}
</style>
```

## Практические примеры

### 1. Кастомный селект с клавиатурной навигацией

```vue
<template>
  <div class="custom-select" :class="{ 'is-open': isOpen }">
    <div 
      class="select-trigger"
      :tabindex="disabled ? -1 : 0"
      :aria-expanded="isOpen"
      :aria-haspopup="true"
      role="combobox"
      aria-autocomplete="none"
      :aria-owns="listId"
      @click="toggleDropdown"
      @keydown="handleKeydown">
      <span>{{ selectedOption ? selectedOption.label : placeholder }}</span>
      <span class="arrow" :class="{ 'rotated': isOpen }">▼</span>
    </div>
    
    <ul 
      v-show="isOpen"
      :id="listId"
      class="select-options"
      role="listbox">
      <li 
        v-for="(option, index) in options"
        :key="option.value"
        :ref="`option-${index}`"
        class="select-option"
        :class="{ 'is-selected': selectedValue === option.value }"
        role="option"
        :aria-selected="selectedValue === option.value"
        @click="selectOption(option)"
        @mousedown="preventBlur">
        {{ option.label }}
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  name: 'AccessibleSelect',
  props: {
    modelValue: String,
    options: {
      type: Array,
      default: () => []
    },
    placeholder: {
      type: String,
      default: 'Выберите опцию'
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:modelValue'],
  data() {
    return {
      isOpen: false,
      focusedIndex: -1
    }
  },
  computed: {
    selectedValue() {
      return this.modelValue;
    },
    selectedOption() {
      return this.options.find(opt => opt.value === this.selectedValue);
    },
    listId() {
      return `select-options-${this._uid}`;
    }
  },
  methods: {
    toggleDropdown() {
      if (this.disabled) return;
      this.isOpen = !this.isOpen;
      if (this.isOpen) {
        this.$nextTick(() => {
          this.focusOption(0);
        });
      }
    },
    selectOption(option) {
      this.$emit('update:modelValue', option.value);
      this.isOpen = false;
      this.focusedIndex = -1;
    },
    handleKeydown(event) {
      switch (event.key) {
        case 'Enter':
        case ' ':
          event.preventDefault();
          this.toggleDropdown();
          break;
        case 'ArrowDown':
          event.preventDefault();
          this.navigateOptions(1);
          break;
        case 'ArrowUp':
          event.preventDefault();
          this.navigateOptions(-1);
          break;
        case 'Escape':
          this.isOpen = false;
          this.focusedIndex = -1;
          break;
        case 'Home':
          event.preventDefault();
          this.focusOption(0);
          break;
        case 'End':
          event.preventDefault();
          this.focusOption(this.options.length - 1);
          break;
      }
    },
    navigateOptions(direction) {
      if (!this.isOpen) {
        this.isOpen = true;
        this.$nextTick(() => {
          this.focusOption(0);
        });
        return;
      }

      let newIndex = this.focusedIndex + direction;
      
      if (newIndex < 0) {
        newIndex = this.options.length - 1;
      } else if (newIndex >= this.options.length) {
        newIndex = 0;
      }
      
      this.focusOption(newIndex);
    },
    focusOption(index) {
      this.focusedIndex = index;
      const optionRef = this.$refs[`option-${index}`];
      if (optionRef && optionRef[0]) {
        optionRef[0].focus();
      }
    },
    preventBlur(event) {
      // Предотвращаем потерю фокуса при клике на опцию
      event.preventDefault();
    }
  },
  mounted() {
    document.addEventListener('click', this.handleDocumentClick);
  },
  beforeUnmount() {
    document.removeEventListener('click', this.handleDocumentClick);
  },
  methods: {
    handleDocumentClick(event) {
      if (!this.$el.contains(event.target)) {
        this.isOpen = false;
        this.focusedIndex = -1;
      }
    }
  }
}
</script>

<style scoped>
.custom-select {
  position: relative;
  width: 200px;
}

.select-trigger {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border: 2px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  background: white;
}

.select-trigger:focus {
  outline: 3px solid #ffbf47;
  outline-offset: 2px;
}

.arrow {
  transition: transform 0.2s;
}

.arrow.rotated {
  transform: rotate(180deg);
}

.select-options {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 2px solid #ccc;
  border-top: none;
  max-height: 200px;
  overflow-y: auto;
  z-index: 1000;
  margin: 0;
  padding: 0;
}

.select-option {
  padding: 8px 12px;
  list-style: none;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

.select-option:focus {
  background-color: #e6f7ff;
  outline: 2px solid #1890ff;
}

.select-option:last-child {
  border-bottom: none;
}
</style>
```

### 2. Клавиатурная навигация в табличных данных

```vue
<template>
  <div class="accessible-table">
    <table role="grid">
      <thead>
        <tr role="row">
          <th role="columnheader" scope="col">Имя</th>
          <th role="columnheader" scope="col">Email</th>
          <th role="columnheader" scope="col">Действия</th>
        </tr>
      </thead>
      <tbody>
        <tr 
          v-for="(item, rowIndex) in tableData" 
          :key="item.id"
          role="row"
          :ref="`row-${rowIndex}`"
          :tabindex="rowIndex === 0 ? 0 : -1"
          @keydown="handleRowKeydown($event, rowIndex)">
          <td role="gridcell">{{ item.name }}</td>
          <td role="gridcell">{{ item.email }}</td>
          <td role="gridcell">
            <button 
              @click="editRow(rowIndex)"
              :aria-label="`Редактировать ${item.name}`">
              Редактировать
            </button>
            <button 
              @click="deleteRow(rowIndex)"
              :aria-label="`Удалить ${item.name}`">
              Удалить
            </button>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script>
export default {
  name: 'AccessibleTable',
  data() {
    return {
      tableData: [
        { id: 1, name: 'Иван Иванов', email: 'ivan@example.com' },
        { id: 2, name: 'Мария Смирнова', email: 'maria@example.com' },
        { id: 3, name: 'Алексей Петров', email: 'alexey@example.com' }
      ],
      currentRow: 0
    }
  },
  methods: {
    handleRowKeydown(event, rowIndex) {
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          this.focusRow((rowIndex + 1) % this.tableData.length);
          break;
        case 'ArrowUp':
          event.preventDefault();
          this.focusRow((rowIndex - 1 + this.tableData.length) % this.tableData.length);
          break;
        case 'Enter':
        case ' ':
          event.preventDefault();
          this.editRow(rowIndex);
          break;
      }
    },
    focusRow(rowIndex) {
      const rowRef = this.$refs[`row-${rowIndex}`];
      if (rowRef && rowRef[0]) {
        rowRef[0].focus();
        this.currentRow = rowIndex;
      }
    },
    editRow(rowIndex) {
      console.log(`Редактировать строку ${rowIndex}`);
    },
    deleteRow(rowIndex) {
      console.log(`Удалить строку ${rowIndex}`);
    }
  }
}
</script>
```

## Особенности для российских разработчиков

### Требования законодательства

С 2025 года в России усилен контроль за доступностью веб-сайтов согласно:

- Федеральный закон №419-ФЗ от 25.11.2024
- ГОСТ Р 52872-2022 (новая редакция)
- Указания ФСТЭК и Роскомнадзора

### Рекомендации по реализации

1. **Используйте стандартные клавиатурные комбинации**
   - Tab/Shift+Tab для навигации
   - Enter/Space для активации
   - Arrow keys для навигации внутри компонентов

2. **Обеспечьте логический порядок навигации**
   - Следуйте структуре DOM
   - Не изменяйте порядок фокуса с помощью tabindex без необходимости

3. **Обрабатывайте все клавиатурные события**
   - Реализуйте обработку Enter, Space, Arrow keys, Escape и т.д.

## Наилучшие практики

1. **Проверяйте навигацию только с клавиатуры**
   - Отключите мышь и пройдите весь интерфейс

2. **Используйте логический порядок табуляции**
   - Следуйте структуре страницы: заголовок → навигация → основной контент → боковая панель → футер

3. **Обеспечьте видимую индикацию фокуса**
   - Не удаляйте outline
   - Используйте :focus и :focus-visible

4. **Управляйте фокусом при динамических изменениях**
   - Перемещайте фокус при открытии модальных окон
   - Возвращайте фокус после закрытия

## Заключение

Клавиатурная навигация - это ключевой элемент доступности, который должен быть реализован в каждом Vue-приложении. Правильное управление фокусом и обработка клавиатурных событий делает приложение доступным для широкого круга пользователей.

Следующие темы для изучения:
- [[Семантическая-разметка]]
- [[ARIA-атрибуты]]
- [[Контрастность]]
- [[Тестирование-доступности]]

## Ключевые теги
#vue #accessibility #keyboard #navigation #frontend #web-development