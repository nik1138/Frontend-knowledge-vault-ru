---
aliases: ["Методы жизненного цикла в Vue", "Жизненный цикл Vue", "Vue lifecycle"]
tags: ["vue", "lifecycle", "javascript", "frontend", "компонента", "создание", "уничтожение"]
---

# Методы жизненного цикла в Vue.js

## Введение

Методы жизненного цикла (lifecycle hooks) в Vue.js — это специальные функции, которые вызываются на определённых этапах существования компонента. Они позволяют выполнять код в ключевые моменты: при создании, монтировании, обновлении и уничтожении компонента. Эти хуки дают разработчику контроль над поведением компонента на каждом этапе его "жизни", что особенно полезно для инициализации, подписки на события, очистки ресурсов и т.д.

## Диаграмма жизненного цикла

Жизненный цикл компонента включает следующие основные этапы:

1. **beforeCreate** — вызывается сразу после инициализации экземпляра, до настройки реактивности и событий.
2. **created** — вызывается после инициализации экземпляра, реактивных данных, вычисляемых свойств и методов.
3. **beforeMount** — вызывается перед первым монтированием компонента.
4. **mounted** — вызывается после монтирования компонента (DOM создан и вставлен в документ).
5. **beforeUpdate** — вызывается перед обновлением компонента (до перерисовки DOM).
6. **updated** — вызывается после обновления компонента (DOM уже обновлён).
7. **beforeUnmount** — вызывается перед размонтированием компонента.
8. **unmounted** — вызывается после размонтирования компонента.

## Подробное описание хуков

### beforeCreate и created

Эти хуки вызываются до и после инициализации компонента. В `beforeCreate` реактивные данные ещё не установлены, а в `created` — уже доступны.

```javascript
export default {
  data() {
    return {
      message: 'Привет'
    }
  },
  beforeCreate() {
    console.log('beforeCreate: компонент ещё не инициализирован');
  },
  created() {
    console.log('created: компонент инициализирован, доступ к данным:', this.message);
    // Подходит для инициализации данных, подписки на события
  }
}
```

### beforeMount и mounted

`beforeMount` вызывается перед монтированием, а `mounted` — после. В `mounted` DOM уже доступен, что позволяет работать с элементами напрямую.

```javascript
mounted() {
  console.log('Компонент смонтирован, DOM доступен');
  // Подходит для инициализации сторонних библиотек, получения DOM-элементов
  this.$nextTick(() => {
    // Убедиться, что DOM полностью обновлён
  });
}
```

> [!tip] Совет
> Используйте `mounted` для выполнения действий, требующих доступа к DOM, например, инициализации Canvas или сторонних библиотек.

### beforeUpdate и updated

Эти хуки вызываются при изменении реактивных данных. `beforeUpdate` — до перерисовки, `updated` — после.

```javascript
data() {
  return {
    count: 0
  }
},
beforeUpdate() {
  console.log('beforeUpdate: данные изменились, но DOM ещё не обновлён');
},
updated() {
  console.log('updated: DOM обновлён, счётчик:', this.count);
}
```

> [!warning] Внимание
> Избегайте изменения данных в `updated`, так как это может вызвать бесконечный цикл обновлений.

### beforeUnmount и unmounted

Используются для очистки ресурсов, отписки от событий и других действий, необходимых перед уничтожением компонента.

```javascript
mounted() {
  this.timer = setInterval(() => {
    console.log('Тик');
  }, 1000);
},
beforeUnmount() {
  clearInterval(this.timer); // Очистка таймера
}
```

## Практические примеры использования

### Загрузка данных при монтировании

```javascript
export default {
  data() {
    return {
      users: []
    }
  },
  async mounted() {
    try {
      const response = await fetch('/api/users');
      this.users = await response.json();
    } catch (error) {
      console.error('Ошибка загрузки пользователей:', error);
    }
  }
}
```

### Подписка и отписка от событий

```javascript
export default {
  data() {
    return {
      windowWidth: window.innerWidth
    }
  },
  mounted() {
    window.addEventListener('resize', this.handleResize);
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize);
  },
  methods: {
    handleResize() {
      this.windowWidth = window.innerWidth;
    }
  }
}
```

## Сравнение с Composition API

В Composition API хуки жизненного цикла доступны как импортируемые функции:

```javascript
import { onMounted, onUnmounted, onUpdated } from 'vue';

export default {
  setup() {
    onMounted(() => {
      console.log('Компонент смонтирован');
    });

    onUnmounted(() => {
      console.log('Компонент размонтирован');
    });

    // ...
  }
}
```

## Лучшие практики

- Используйте `created` для инициализации данных и API-запросов.
- Используйте `mounted` для работы с DOM и инициализации сторонних библиотек.
- Обязательно очищайте ресурсы в `beforeUnmount` или `unmounted`.
- Не изменяйте данные в `updated`, чтобы избежать циклических обновлений.
- Всегда отписывайтесь от глобальных событий, таймеров и веб-сокетов.

## Связь с другими концепциями Vue

- [[Состояние-компонента]] — хуки позволяют управлять состоянием на разных этапах.
- [[API-requests]] — часто используются в `created` или `mounted` для загрузки данных.
- [[Обработка-событий]] — в хуках можно подписываться и отписываться от событий.
- [[Composition-API]] — альтернативный подход к использованию хуков жизненного цикла.

## Заключение

Методы жизненного цикла в Vue.js — это мощный инструмент для управления поведением компонентов. Правильное использование хуков позволяет создавать более предсказуемые и производительные приложения. В российской разработке, как и в международной, знание жизненного цикла компонентов является важной частью понимания Vue.js.
