---
aliases: ["Кэширование в PWA", "PWA Caching", "Offline Caching"]
tags: [pwa, caching, service-worker, performance, offline]
---

# Кэширование

Кэширование — это ключевой аспект прогрессивных веб-приложений (PWA), который позволяет хранить ресурсы локально на устройстве пользователя для обеспечения быстрой загрузки и работы в автономном режиме. Эффективное кэширование значительно улучшает пользовательский опыт, особенно в условиях нестабильного интернет-соединения.

## Типы кэширования в PWA

### 1. HTTP-кэширование

Традиционное кэширование через HTTP-заголовки:

- `Cache-Control`
- `ETag`
- `Last-Modified`

Этот тип кэширования работает на уровне браузера и сервера, но не обеспечивает автономную работу.

### 2. Кэширование через Cache API

Используется в сочетании с [[Service Workers]] для хранения ресурсов локально:

```javascript
// Открытие кэша
caches.open('my-cache-v1')
  .then((cache) => {
    // Добавление ресурсов в кэш
    return cache.addAll([
      '/',
      '/styles/main.css',
      '/scripts/main.js',
      '/images/logo.png'
    ]);
  });
```

### 3. Кэширование через IndexedDB

Для хранения больших объемов структурированных данных:

```javascript
const request = indexedDB.open('MyPWA', 1);

request.onsuccess = (event) => {
  const db = event.target.result;
  // Работа с базой данных
};
```

## Стратегии кэширования

### Cache First (Кэш в приоритете)

Сначала проверяется кэш, только если ресурс не найден — делается сетевой запрос:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});
```

**Преимущества:**
- Быстрая загрузка
- Работа в автономном режиме

**Недостатки:**
- Возможна устаревшая информация
- Требует обновления кэша при изменениях

### Network First (Сеть в приоритете)

Сначала делается сетевой запрос, только при его неудаче — используется кэш:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => {
        return caches.match(event.request);
      })
  );
});
```

**Преимущества:**
- Всегда актуальные данные
- Резервное копирование кэшем

**Недостатки:**
- Медленная загрузка при слабом соединении
- Не работает без интернета

### Stale While Revalidate (Использовать устаревшее, но обновлять)

Возвращает кэшированный ресурс, но параллельно обновляет его:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        // Обновление кэша в фоне
        const fetchPromise = fetch(event.request)
          .then((networkResponse) => {
            caches.open('my-cache-v1')
              .then((cache) => {
                cache.put(event.request, networkResponse.clone());
              });
            return networkResponse;
          });

        return cachedResponse || fetchPromise;
      })
  );
});
```

**Преимущества:**
- Быстрая загрузка
- Всегда обновленные данные
- Работа в автономном режиме

### Cache Only (Только кэш)

Возвращает только кэшированные ресурсы:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
  );
});
```

**Преимущества:**
- Максимальная скорость
- Не зависит от сети

**Недостатки:**
- Не обновляет данные
- Ограниченная применимость

### Network Only (Только сеть)

Не использует кэш, всегда делает сетевой запрос:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
  );
});
```

**Преимущества:**
- Всегда актуальные данные

**Недостатки:**
- Зависит от сети
- Медленная загрузка при слабом соединении

## Практические рекомендации по кэшированию

### 1. Классификация ресурсов

Разделяйте ресурсы по типам и применению различных стратегий:

- **Статические ресурсы** (CSS, JS, изображения) → Cache First
- **Динамические данные** (API) → Network First или Stale While Revalidate
- **Контент** (статьи, новости) → Stale While Revalidate
- **Аутентификация** → Network Only

### 2. Версионирование кэша

Для предотвращения проблем с устаревшими данными используйте версионирование:

```javascript
const CACHE_VERSION = 'v1.2.3';
const CACHE_NAME = `my-pwa-cache-${CACHE_VERSION}`;

// При обновлении - очистка старых кэшей
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              return caches.delete(cacheName);
            }
          })
        );
      })
  );
});
```

### 3. Оптимизация размера кэша

Следите за размером кэша, особенно в условиях ограниченного хранилища:

```javascript
// Ограничение размера кэша
const MAX_CACHE_SIZE = 50; // в МБ

async function trimCache(cacheName) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  if (keys.length > MAX_CACHE_SIZE) {
    await cache.delete(keys[0]); // Удаление старейшего элемента
  }
}
```

### 4. Управление кэшем

Реализуйте механизм очистки кэша по необходимости:

```javascript
// Очистка кэша по требованию
function clearCache() {
  caches.keys()
    .then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          return caches.delete(cacheName);
        })
      );
    });
}
```

## Кэширование для российского рынка

В России 2025 года при реализации кэширования в PWA следует учитывать:

- Нестабильность интернет-соединения в некоторых регионах
- Ограничения на доступ к зарубежным CDN
- Необходимость хранения критически важных данных локально
- Требования к защите персональных данных (ФЗ-152)
- Ограничения на использование определенных сервисов

## Мониторинг и отладка кэширования

Для отладки кэширования в Chrome DevTools:

1. Application → Storage → Cache Storage
2. Используйте консоль для логирования операций кэширования
3. Application → Storage → IndexedDB (для IndexedDB кэширования)
4. Network → отфильтрованные запросы для проверки работы стратегий

## Пример комплексной стратегии кэширования

```javascript
const staticCacheName = 'static-v1.5.2';
const dynamicCacheName = 'dynamic-v1.0.0';

// Кэширование статических ресурсов
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(staticCacheName)
      .then((cache) => {
        return cache.addAll([
          '/',
          '/styles/main.css',
          '/scripts/main.js',
          '/images/logo.png',
          '/offline.html'
        ]);
      })
  );
});

// Стратегия кэширования для разных типов запросов
self.addEventListener('fetch', (event) => {
  const requestUrl = new URL(event.request.url);

  // Кэширование статических ресурсов
  if (requestUrl.origin === location.origin) {
    if (requestUrl.pathname.startsWith('/api/')) {
      // Для API - сеть в приоритете с резервом кэша
      event.respondWith(networkFirstStrategy(event.request));
    } else {
      // Для статики - кэш в приоритете
      event.respondWith(cacheFirstStrategy(event.request));
    }
  } else {
    // Для сторонних ресурсов - сеть в приоритете
    event.respondWith(networkFirstStrategy(event.request));
  }
});

function cacheFirstStrategy(request) {
  return caches.match(request)
    .then((response) => {
      return response || fetch(request);
    });
}

function networkFirstStrategy(request) {
  return fetch(request)
    .then((response) => {
      return caches.open(dynamicCacheName)
        .then((cache) => {
          cache.put(request, response.clone());
          return response;
        });
    })
    .catch(() => {
      return caches.match(request) || caches.match('/offline.html');
    });
}
```

## Заключение

Кэширование в PWA — это мощный инструмент для улучшения производительности и обеспечения автономной работы. Правильный выбор стратегии кэширования в зависимости от типа ресурса и условий использования позволяет создать приложение, которое работает быстро и надежно даже в сложных сетевых условиях.

> [!tip] Совет
> Используйте комбинацию различных стратегий кэширования в зависимости от типа ресурса для оптимальной производительности.

> [!warning] Важно
> В России требования к хранению и защите данных строже, чем в других странах, поэтому учитывайте ФЗ-152 при кэшировании персональных данных.

Следующие темы: [[Введение в PWA]], [[Service Workers]], [[Web App Manifest]], [[Оффлайн работа]]