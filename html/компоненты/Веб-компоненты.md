---
aliases: ["Веб-компоненты", "Web Components", "Кастомные элементы", "HTML компоненты"]
tags: [html/components, web-components, custom-elements, frontend]
---

# Веб-компоненты

## Введение

Веб-компоненты - это набор веб-технологий, позволяющих создавать переиспользуемые пользовательские элементы с изолированной функциональностью. В 2025 году веб-компоненты становятся всё более зрелой технологией, обеспечивающей кроссплатформенную совместимость и независимость от фреймворков.

## Архитектура веб-компонентов

Веб-компоненты состоят из четырех основных технологий:

1. **Кастомные элементы (Custom Elements)** - позволяют определять новые HTML теги
2. **Shadow DOM** - обеспечивает инкапсуляцию стилей и разметки
3. **HTML Templates** - позволяют создавать переиспользуемую разметку
4. **ES Modules** - обеспечивают модульную загрузку компонентов

### 1. Кастомные элементы

Кастомные элементы позволяют создавать новые HTML теги с определенным поведением:

```javascript
// Определение кастомного элемента
class UserProfile extends HTMLElement {
  constructor() {
    super();
    
    // Создание Shadow DOM для инкапсуляции
    this.attachShadow({ mode: 'open' });
  }

  // Список наблюдаемых атрибутов
  static get observedAttributes() {
    return ['user-id', 'show-avatar', 'theme'];
  }

  // Вызывается при добавлении элемента в DOM
  connectedCallback() {
    this.render();
  }

  // Вызывается при изменении наблюдаемого атрибута
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  // Вызывается при удалении элемента из DOM
  disconnectedCallback() {
    // Очистка ресурсов
  }

  render() {
    const userId = this.getAttribute('user-id');
    const showAvatar = this.hasAttribute('show-avatar');
    const theme = this.getAttribute('theme') || 'light';
    
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          font-family: Arial, sans-serif;
        }
        .profile-card {
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 16px;
          background: ${theme === 'dark' ? '#333' : '#fff'};
          color: ${theme === 'dark' ? '#fff' : '#333'};
        }
        .avatar {
          width: 50px;
          height: 50px;
          border-radius: 50%;
          margin-right: 16px;
        }
        .info {
          display: flex;
          align-items: center;
        }
      </style>
      <div class="profile-card">
        ${showAvatar ? '<img class="avatar" src="avatar.jpg" alt="Avatar">' : ''}
        <div class="info">
          <div class="name">Имя пользователя</div>
          <div class="id">ID: ${userId}</div>
        </div>
      </div>
    `;
  }
}

// Регистрация кастомного элемента
customElements.define('user-profile', UserProfile);
```

Использование:

```html
<user-profile user-id="123" show-avatar theme="dark"></user-profile>
```

### 2. Shadow DOM

Shadow DOM обеспечивает инкапсуляцию стилей и разметки:

```javascript
class CardComponent extends HTMLElement {
  constructor() {
    super();
    // Создание теневого DOM с открытым режимом
    this.shadowRoot = this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    // Стили в Shadow DOM не влияют на внешний DOM
    this.shadowRoot.innerHTML = `
      <style>
        /* Эти стили применяются только внутри компонента */
        .card {
          background: white;
          border: 1px solid #ccc;
          border-radius: 8px;
          padding: 16px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Стили для слотов */
        ::slotted(*) {
          margin: 8px 0;
        }
        
        /* Стили для частей компонента */
        .header {
          font-weight: bold;
          margin-bottom: 8px;
        }
      </style>
      <div class="card">
        <div class="header">
          <slot name="header">Заголовок по умолчанию</slot>
        </div>
        <div class="content">
          <slot name="content">Содержимое по умолчанию</slot>
        </div>
        <div class="footer">
          <slot name="footer">Футер по умолчанию</slot>
        </div>
      </div>
    `;
  }
}

customElements.define('card-component', CardComponent);
```

### 3. HTML Templates

Шаблоны для переиспользуемой разметки:

```html
<template id="user-card-template">
  <style>
    .user-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 16px;
      margin: 8px;
      background: white;
    }
    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      float: left;
      margin-right: 12px;
    }
    .info { overflow: hidden; }
  </style>
  <div class="user-card">
    <img class="avatar" src="" alt="Avatar">
    <div class="info">
      <div class="name"></div>
      <div class="email"></div>
    </div>
  </div>
</template>
```

```javascript
class UserCard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Использование шаблона
    const template = document.getElementById('user-card-template');
    this.shadowRoot.appendChild(template.content.cloneNode(true));
  }

  connectedCallback() {
    this.updateContent();
  }

  updateContent() {
    const avatar = this.shadowRoot.querySelector('.avatar');
    const name = this.shadowRoot.querySelector('.name');
    const email = this.shadowRoot.querySelector('.email');
    
    avatar.src = this.getAttribute('avatar') || 'default-avatar.png';
    name.textContent = this.getAttribute('name') || 'Имя не указано';
    email.textContent = this.getAttribute('email') || 'Email не указан';
  }
}

customElements.define('user-card', UserCard);
```

## Продвинутые паттерны веб-компонентов

### 1. Компонент с асинхронной загрузкой данных

```javascript
class AsyncDataComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.loading = false;
    this.data = null;
  }

  static get observedAttributes() {
    return ['data-source', 'auto-load'];
  }

  connectedCallback() {
    this.render();
    
    if (this.hasAttribute('auto-load')) {
      this.loadData();
    }
  }

  async loadData() {
    if (this.loading) return;
    
    this.loading = true;
    this.render();
    
    try {
      const source = this.getAttribute('data-source');
      const response = await fetch(source);
      this.data = await response.json();
      this.loading = false;
      this.render();
      
      // Уведомление о загрузке данных
      this.dispatchEvent(new CustomEvent('data-loaded', {
        detail: { data: this.data },
        bubbles: true,
        composed: true
      }));
    } catch (error) {
      this.loading = false;
      this.error = error;
      this.render();
      
      this.dispatchEvent(new CustomEvent('data-error', {
        detail: { error },
        bubbles: true,
        composed: true
      }));
    }
  }

  render() {
    if (this.loading) {
      this.shadowRoot.innerHTML = `
        <style>
          .loading { text-align: center; padding: 20px; }
          .spinner { 
            width: 24px; 
            height: 24px; 
            border: 3px solid #f3f3f3; 
            border-top: 3px solid #3498db; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin: 0 auto; 
          }
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
        <div class="loading">
          <div class="spinner"></div>
          <p>Загрузка данных...</p>
        </div>
      `;
      return;
    }

    if (this.error) {
      this.shadowRoot.innerHTML = `
        <style>
          .error { color: #e74c3c; padding: 20px; text-align: center; }
        </style>
        <div class="error">
          <p>Ошибка загрузки данных: ${this.error.message}</p>
          <button id="retry-btn">Повторить</button>
        </div>
      `;
      this.shadowRoot.getElementById('retry-btn').onclick = () => this.loadData();
      return;
    }

    if (this.data) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; }
          .data-container { padding: 16px; }
        </style>
        <div class="data-container">
          <pre>${JSON.stringify(this.data, null, 2)}</pre>
        </div>
      `;
    } else {
      this.shadowRoot.innerHTML = `
        <style>
          .placeholder { padding: 20px; text-align: center; color: #999; }
        </style>
        <div class="placeholder">
          <p>Данные не загружены</p>
          <button id="load-btn">Загрузить данные</button>
        </div>
      `;
      this.shadowRoot.getElementById('load-btn').onclick = () => this.loadData();
    }
  }
}

customElements.define('async-data-component', AsyncDataComponent);
```

### 2. Компонент с состоянием и управлением жизненным циклом

```javascript
class StatefulComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Инициализация состояния
    this.state = {
      count: 0,
      items: [],
      selected: null,
      loading: false
    };
    
    // Привязка методов к экземпляру
    this.increment = this.increment.bind(this);
    this.decrement = this.decrement.bind(this);
  }

  static get observedAttributes() {
    return ['initial-count', 'max-count'];
  }

  connectedCallback() {
    this.initState();
    this.render();
    this.addEventListeners();
  }

  disconnectedCallback() {
    this.removeEventListeners();
  }

  initState() {
    const initialCount = parseInt(this.getAttribute('initial-count')) || 0;
    this.state.count = initialCount;
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'initial-count' && oldValue !== newValue) {
      this.state.count = parseInt(newValue) || 0;
      this.render();
    }
  }

  increment() {
    const maxCount = parseInt(this.getAttribute('max-count')) || Infinity;
    if (this.state.count < maxCount) {
      this.state.count++;
      this.render();
      this.dispatchStateChange();
    }
  }

  decrement() {
    if (this.state.count > 0) {
      this.state.count--;
      this.render();
      this.dispatchStateChange();
    }
  }

  dispatchStateChange() {
    this.dispatchEvent(new CustomEvent('state-change', {
      detail: { ...this.state },
      bubbles: true,
      composed: true
    }));
  }

  addEventListeners() {
    // Добавление глобальных слушателей при необходимости
  }

  removeEventListeners() {
    // Удаление глобальных слушателей
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        .counter { 
          padding: 16px; 
          border: 1px solid #ddd; 
          border-radius: 4px; 
          text-align: center; 
        }
        .count { 
          font-size: 2em; 
          font-weight: bold; 
          margin: 16px 0; 
          color: #007bff; 
        }
        .buttons { display: flex; gap: 8px; justify-content: center; }
        button { 
          padding: 8px 16px; 
          border: 1px solid #007bff; 
          background: #007bff; 
          color: white; 
          border-radius: 4px; 
          cursor: pointer; 
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
      </style>
      <div class="counter">
        <div class="count">${this.state.count}</div>
        <div class="buttons">
          <button id="decrement" ${this.state.count <= 0 ? 'disabled' : ''}>-</button>
          <button id="increment">+</button>
        </div>
      </div>
    `;
    
    // Привязка событий после рендеринга
    this.shadowRoot.getElementById('increment').onclick = this.increment;
    this.shadowRoot.getElementById('decrement').onclick = this.decrement;
  }
}

customElements.define('stateful-component', StatefulComponent);
```

## Совместимость и поддержка

### Современные браузеры (2025)

В 2025 году веб-компоненты поддерживаются во всех современных браузерах:

- Chrome/Edge: Полная поддержка
- Firefox: Полная поддержка
- Safari: Полная поддержка
- Opera: Полная поддержка

### Поддержка в старых браузерах

Для поддержки старых браузеров используются полифилы:

```html
<!-- Загрузка полифилов для веб-компонентов -->
<script src="https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2/webcomponents-loader.min.js"></script>
<script>
  // Код компонентов будет выполнен только после загрузки полифилов
  if ('customElements' in window) {
    // Регистрация компонентов
    customElements.define('my-component', MyComponent);
  }
</script>
```

## Практические применения

### 1. UI библиотека на основе веб-компонентов

```javascript
// ui-library.js
import { Button } from './components/Button.js';
import { Card } from './components/Card.js';
import { Modal } from './components/Modal.js';
import { FormInput } from './components/FormInput.js';

// Регистрация всех компонентов
customElements.define('ui-button', Button);
customElements.define('ui-card', Card);
customElements.define('ui-modal', Modal);
customElements.define('ui-form-input', FormInput);

// Экспорт для использования в других модулях
export { Button, Card, Modal, FormInput };
```

### 2. Темизация веб-компонентов

```javascript
// themes.js
export const themes = {
  light: {
    '--primary-color': '#007bff',
    '--secondary-color': '#6c757d',
    '--background-color': '#ffffff',
    '--text-color': '#333333'
  },
  dark: {
    '--primary-color': '#0d6efd',
    '--secondary-color': '#6c757d',
    '--background-color': '#212529',
    '--text-color': '#ffffff'
  },
  corporate: {
    '--primary-color': '#28a745',
    '--secondary-color': '#ffc107',
    '--background-color': '#f8f9fa',
    '--text-color': '#212529'
  }
};

// Использование тем в компонентах
class ThemedComponent extends HTMLElement {
  static get observedAttributes() {
    return ['theme'];
  }

  connectedCallback() {
    this.applyTheme();
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'theme') {
      this.applyTheme();
    }
  }

  applyTheme() {
    const themeName = this.getAttribute('theme') || 'light';
    const theme = themes[themeName] || themes.light;
    
    Object.entries(theme).forEach(([property, value]) => {
      this.style.setProperty(property, value);
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          background: var(--background-color);
          color: var(--text-color);
          padding: 16px;
          border-radius: 8px;
        }
        .primary-element {
          color: var(--primary-color);
        }
        .secondary-element {
          color: var(--secondary-color);
        }
      </style>
      <div class="primary-element">Элемент с основным цветом</div>
      <div class="secondary-element">Элемент с второстепенным цветом</div>
    `;
  }
}
```

## Российские особенности использования

В 2025 году в российской веб-разработке веб-компоненты используются с учетом следующих факторов:

1. **Совместимость с отечественными браузерами** - компоненты должны корректно работать в российских браузерах
2. **Локализация** - компоненты должны поддерживать кириллицу и российские форматы данных
3. **Соответствие требованиям** - компоненты должны соответствовать российским требованиям к веб-доступности и безопасности
4. **Работа в условиях ограничений** - компоненты должны быть оптимизированы для работы в условиях ограниченного интернет-доступа

## Лучшие практики

### 1. Организация кода компонентов

```javascript
// Хорошая структура файла компонента
class WellStructuredComponent extends HTMLElement {
  // 1. Статические свойства
  static get observedAttributes() {
    return ['title', 'disabled', 'theme'];
  }

  // 2. Конструктор
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.state = { initialized: false };
  }

  // 3. Жизненные циклы
  connectedCallback() {
    this.init();
  }

  disconnectedCallback() {
    this.destroy();
  }

  // 4. Обработчики атрибутов
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.handleAttributeChange(name, newValue);
    }
  }

  // 5. Приватные методы инициализации
  init() {
    if (this.state.initialized) return;
    this.render();
    this.addEventListeners();
    this.state.initialized = true;
  }

  // 6. Приватные методы рендеринга
  render() {
    this.shadowRoot.innerHTML = this.template;
  }

  get template() {
    return `
      <style>${this.styles}</style>
      <div class="component">${this.content}</div>
    `;
  }

  get styles() {
    return `
      :host { display: block; }
      .component { padding: 16px; }
    `;
  }

  get content() {
    return `<slot></slot>`;
  }

  // 7. Приватные методы обработки
  handleAttributeChange(name, value) {
    switch (name) {
      case 'theme':
        this.applyTheme(value);
        break;
      case 'disabled':
        this.setDisabled(value !== null);
        break;
    }
  }

  // 8. Приватные методы управления
  applyTheme(theme) {
    // Логика применения темы
  }

  setDisabled(disabled) {
    // Логика установки состояния отключения
  }

  // 9. Приватные методы очистки
  destroy() {
    this.removeEventListeners();
    this.state.initialized = false;
  }

  // 10. Публичные методы API
  reset() {
    // Публичный метод сброса состояния
  }
}
```

### 2. Тестирование веб-компонентов

```javascript
// Пример теста для веб-компонента
describe('UserProfile Component', () => {
  let element;

  beforeEach(() => {
    element = document.createElement('user-profile');
    document.body.appendChild(element);
  });

  afterEach(() => {
    document.body.removeChild(element);
  });

  test('должен отображать имя пользователя', () => {
    element.setAttribute('name', 'Иван Иванов');
    const nameElement = element.shadowRoot.querySelector('.name');
    expect(nameElement.textContent).toBe('Иван Иванов');
  });

  test('должен реагировать на изменение атрибута', () => {
    element.setAttribute('theme', 'dark');
    expect(element.getAttribute('theme')).toBe('dark');
  });

  test('должен генерировать событие при клике', () => {
    const mockCallback = jest.fn();
    element.addEventListener('profile-click', mockCallback);
    
    const profileElement = element.shadowRoot.querySelector('.profile-card');
    profileElement.click();
    
    expect(mockCallback).toHaveBeenCalled();
  });
});
```

## Заключение

Веб-компоненты в 2025 году представляют собой зрелую технологию для создания переиспользуемых и изолированных компонентов. Их независимость от фреймворков делает их идеальным выбором для создания кроссплатформенных библиотек компонентов и долгосрочных проектов. Правильное использование веб-компонентов позволяет создавать масштабируемые, поддерживаемые и переиспользуемые решения.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Вложенные-компоненты]]
- [[Параметризация]]
- [[Жизненный-цикл-компонентов]]