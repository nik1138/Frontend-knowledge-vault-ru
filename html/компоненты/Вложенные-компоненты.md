---
aliases: ["Вложенные компоненты", "Композиция компонентов", "HTML компоненты"]
tags: [html/components, nesting, composition, frontend]
---

# Вложенные компоненты

## Введение

Вложенные компоненты - это компоненты, которые содержат другие компоненты в своей структуре. В 2025 году композиция компонентов является ключевым подходом к созданию сложных пользовательских интерфейсов из простых строительных блоков.

## Принципы вложенности

### 1. Иерархическая структура

Компоненты могут включать другие компоненты, создавая иерархическую структуру:

```html
<app-layout>
  <header-component>
    <navigation-menu>
      <menu-item>Главная</menu-item>
      <menu-item>О нас</menu-item>
      <menu-item>Контакты</menu-item>
    </navigation-menu>
  </header-component>
  
  <main-content>
    <article-card>
      <card-header>Заголовок статьи</card-header>
      <card-body>Содержимое статьи</card-body>
      <card-footer>
        <social-share></social-share>
      </card-footer>
    </article-card>
  </main-content>
  
  <footer-component></footer-component>
</app-layout>
```

### 2. Контентная проекция (Slots)

Использование `<slot>` для вставки контента в компоненты:

```javascript
class CardComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        .card {
          border: 1px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
        }
        .card-header { 
          background: #f8f9fa; 
          padding: 16px; 
          border-bottom: 1px solid #ddd; 
        }
        .card-body { padding: 16px; }
        .card-footer { 
          background: #f8f9fa; 
          padding: 16px; 
          border-top: 1px solid #ddd; 
        }
      </style>
      <div class="card">
        <div class="card-header">
          <slot name="header"></slot>
        </div>
        <div class="card-body">
          <slot name="body"></slot>
        </div>
        <div class="card-footer">
          <slot name="footer"></slot>
        </div>
      </div>
    `;
  }
}

customElements.define('card-component', CardComponent);
```

## Практические примеры вложенных компонентов

### 1. Компонент навигационного меню

```javascript
class NavigationMenu extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        nav { background: #343a40; padding: 1rem; }
        ul { list-style: none; margin: 0; padding: 0; display: flex; }
        li { margin-right: 1rem; }
        a { color: white; text-decoration: none; padding: 0.5rem 1rem; border-radius: 4px; }
        a:hover { background: #495057; }
      </style>
      <nav>
        <ul>
          <slot></slot>
        </ul>
      </nav>
    `;
  }
}

class MenuItem extends HTMLElement {
  connectedCallback() {
    const link = document.createElement('a');
    link.href = this.getAttribute('href') || '#';
    link.textContent = this.getAttribute('label') || this.textContent;
    this.innerHTML = '';
    this.appendChild(link);
  }
}

customElements.define('navigation-menu', NavigationMenu);
customElements.define('menu-item', MenuItem);
```

Использование:

```html
<navigation-menu>
  <menu-item href="/" label="Главная"></menu-item>
  <menu-item href="/about" label="О нас"></menu-item>
  <menu-item href="/contact" label="Контакты"></menu-item>
</navigation-menu>
```

### 2. Компонент галереи

```javascript
class Gallery extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; }
        ::slotted(img) { width: 100%; height: auto; border-radius: 4px; }
      </style>
      <div class="gallery">
        <slot></slot>
      </div>
    `;
  }
}

class GalleryItem extends HTMLElement {
  connectedCallback() {
    const img = document.createElement('img');
    img.src = this.getAttribute('src');
    img.alt = this.getAttribute('alt') || '';
    this.appendChild(img);
  }
}

customElements.define('gallery-component', Gallery);
customElements.define('gallery-item', GalleryItem);
```

### 3. Компонент формы с вложенными полями

```javascript
class FormComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        form { max-width: 600px; margin: 0 auto; padding: 2rem; }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        ::slotted(input), ::slotted(textarea), ::slotted(select) {
          width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;
        }
      </style>
      <form>
        <slot></slot>
      </form>
    `;
  }
}

class FormGroup extends HTMLElement {
  connectedCallback() {
    const label = document.createElement('label');
    label.textContent = this.getAttribute('label');
    
    const container = document.createElement('div');
    container.className = 'form-group';
    container.appendChild(label);
    
    // Перемещаем содержимое внутрь группы
    while (this.firstChild) {
      container.appendChild(this.firstChild);
    }
    
    this.appendChild(container);
  }
}

customElements.define('form-component', FormComponent);
customElements.define('form-group', FormGroup);
```

## Расширенные паттерны вложенности

### 1. Паттерн "Контейнер-ячейка"

```javascript
class ListContainer extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        .list { list-style: none; padding: 0; margin: 0; }
        ::slotted(*) { border-bottom: 1px solid #eee; padding: 1rem; }
        ::slotted(:last-child) { border-bottom: none; }
      </style>
      <ul class="list">
        <slot></slot>
      </ul>
    `;
  }
}

class ListItem extends HTMLElement {
  connectedCallback() {
    const li = document.createElement('li');
    li.className = 'list-item';
    
    // Копируем содержимое
    while (this.firstChild) {
      li.appendChild(this.firstChild);
    }
    
    this.appendChild(li);
  }
}

customElements.define('list-container', ListContainer);
customElements.define('list-item', ListItem);
```

### 2. Паттерн "Таблица с вложенными компонентами"

```javascript
class TableComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f8f9fa; font-weight: bold; }
      </style>
      <table>
        <thead>
          <slot name="header"></slot>
        </thead>
        <tbody>
          <slot name="body"></slot>
        </tbody>
      </table>
    `;
  }
}

class TableRow extends HTMLElement {
  connectedCallback() {
    const tr = document.createElement('tr');
    
    // Перемещаем содержимое в строку
    while (this.firstChild) {
      tr.appendChild(this.firstChild);
    }
    
    this.appendChild(tr);
  }
}

class TableCell extends HTMLElement {
  connectedCallback() {
    const tag = this.getAttribute('header') ? 'th' : 'td';
    const cell = document.createElement(tag);
    
    // Копируем содержимое
    while (this.firstChild) {
      cell.appendChild(this.firstChild);
    }
    
    this.appendChild(cell);
  }
}

customElements.define('table-component', TableComponent);
customElements.define('table-row', TableRow);
customElements.define('table-cell', TableCell);
```

## Управление вложенными компонентами

### 1. Доступ к дочерним компонентам

```javascript
class ParentComponent extends HTMLElement {
  connectedCallback() {
    // После подключения компонента и рендеринга
    this.updateChildComponents();
  }

  updateChildComponents() {
    // Находим все дочерние компоненты
    const childComponents = this.querySelectorAll('child-component');
    
    childComponents.forEach((child, index) => {
      // Устанавливаем атрибуты или свойства
      child.setAttribute('index', index);
      child.updateData(this.getDataForChild(index));
    });
  }

  getDataForChild(index) {
    // Возвращаем данные для конкретного дочернего компонента
    return this.data[index] || null;
  }
}
```

### 2. Обработка событий во вложенных компонентах

```javascript
class ContainerComponent extends HTMLElement {
  connectedCallback() {
    this.addEventListener('child-event', this.handleChildEvent.bind(this));
  }

  handleChildEvent(event) {
    // Обработка события от дочернего компонента
    console.log('Событие от дочернего компонента:', event.detail);
    
    // Возможность всплытия события наверх
    this.dispatchEvent(new CustomEvent('container-event', {
      detail: event.detail,
      bubbles: true,
      composed: true
    }));
  }
}

class ChildComponent extends HTMLElement {
  connectedCallback() {
    // Генерация события, которое всплывает до родительского компонента
    this.dispatchEvent(new CustomEvent('child-event', {
      detail: { message: 'Сообщение от дочернего компонента' },
      bubbles: true,
      composed: true
    }));
  }
}
```

## Лучшие практики вложенных компонентов

### 1. Ограничение глубины вложенности

Не рекомендуется создавать слишком глубокую иерархию компонентов:

```javascript
// Плохо: слишком глубокая вложенность
<app>
  <page>
    <section>
      <container>
        <wrapper>
          <component>
            <subcomponent>
              <element>Содержимое</element>
            </subcomponent>
          </component>
        </wrapper>
      </container>
    </section>
  </page>
</app>

// Хорошо: разумная глубина вложенности
<app>
  <layout>
    <header></header>
    <main>
      <article-card>
        <card-content>Содержимое</card-content>
      </article-card>
    </main>
    <footer></footer>
  </layout>
</app>
```

### 2. Явное определение интерфейсов

```javascript
class DataDisplay extends HTMLElement {
  static get observedAttributes() {
    return ['data-source', 'format'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data-source') {
      this.loadData(newValue);
    } else if (name === 'format') {
      this.applyFormat(newValue);
    }
  }

  loadData(source) {
    // Загрузка данных из указанного источника
  }

  applyFormat(format) {
    // Применение формата к отображению
  }
}
```

### 3. Использование контекста

```javascript
// Простая реализация контекста для передачи данных между компонентами
class ContextProvider extends HTMLElement {
  constructor() {
    super();
    this.context = {};
  }

  setContext(key, value) {
    this.context[key] = value;
    this.propagateContext();
  }

  propagateContext() {
    // Рассылка контекста всем дочерним компонентам
    const children = this.querySelectorAll('[context-consumer]');
    children.forEach(child => {
      if (child.updateContext) {
        child.updateContext(this.context);
      }
    });
  }
}

class ContextConsumer extends HTMLElement {
  connectedCallback() {
    // Найти ближайший контекст-провайдер
    const provider = this.closest('[context-provider]');
    if (provider && provider.context) {
      this.updateContext(provider.context);
    }
  }

  updateContext(context) {
    // Обновление компонента на основе контекста
    this.context = context;
    this.render();
  }
}
```

## Российские особенности и практики

В 2025 году при создании вложенных компонентов в российских проектах важно учитывать:

1. **Локализация** - компоненты должны поддерживать мультиязычность, включая кириллицу
2. **Производительность** - при работе с большими наборами данных компоненты должны эффективно обрабатывать вложенность
3. **Совместимость** - компоненты должны корректно работать в различных российских браузерах и условиях сетевых ограничений

## Заключение

Вложенные компоненты позволяют создавать сложные интерфейсы из простых строительных блоков. Правильная архитектура вложенных компонентов делает код более читаемым, поддерживаемым и переиспользуемым. В 2025 году важна не только функциональность, но и производительность, доступность и совместимость компонентов.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Параметризация]]
- [[Коммуникация-между-компонентами]]
- [[Жизненный-цикл-компонентов]]