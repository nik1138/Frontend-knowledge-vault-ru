---
aliases: ["Параметризация компонентов", "Конфигурация компонентов", "HTML компоненты"]
tags: [html/components, parameters, configuration, frontend]
---

# Параметризация компонентов

## Введение

Параметризация компонентов позволяет настраивать их поведение, внешний вид и функциональность без изменения исходного кода компонента. В 2025 году гибкая параметризация является ключевым фактором переиспользуемости и адаптивности компонентов в различных контекстах.

## Основы параметризации

### 1. HTML атрибуты

Использование HTML атрибутов для настройки компонентов:

```javascript
class ConfigurableButton extends HTMLElement {
  static get observedAttributes() {
    return ['variant', 'size', 'disabled', 'icon'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  get variant() {
    return this.getAttribute('variant') || 'primary';
  }

  get size() {
    return this.getAttribute('size') || 'medium';
  }

  get disabled() {
    return this.hasAttribute('disabled');
  }

  get icon() {
    return this.getAttribute('icon');
  }

  render() {
    const disabled = this.disabled ? 'disabled' : '';
    const sizeClass = `btn-${this.size}`;
    const variantClass = `btn-${this.variant}`;
    
    this.shadowRoot.innerHTML = `
      <style>
        .btn {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          border: none;
          border-radius: 4px;
          cursor: ${this.disabled ? 'not-allowed' : 'pointer'};
          opacity: ${this.disabled ? '0.6' : '1'};
          padding: ${this.size === 'small' ? '4px 8px' : this.size === 'large' ? '12px 24px' : '8px 16px'};
          background: ${this.variant === 'secondary' ? '#6c757d' : 
                       this.variant === 'danger' ? '#dc3545' : '#007bff'};
          color: white;
        }
        .btn-icon { margin-right: 8px; }
      </style>
      <button class="btn ${sizeClass} ${variantClass}" ${disabled}>
        ${this.icon ? `<span class="btn-icon">${this.icon}</span>` : ''}
        <slot name="label">Кнопка</slot>
      </button>
    `;
  }
}

customElements.define('configurable-button', ConfigurableButton);
```

Использование:

```html
<configurable-button variant="primary" size="large" icon="✅">
  <span slot="label">Сохранить</span>
</configurable-button>

<configurable-button variant="secondary" size="small" disabled>
  <span slot="label">Отмена</span>
</configurable-button>
```

### 2. Свойства JavaScript

Параметризация через свойства JavaScript:

```javascript
class DynamicCard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Инициализация свойств по умолчанию
    this._title = '';
    this._content = '';
    this._showBorder = true;
    this._theme = 'light';
  }

  // Геттеры и сеттеры для свойств
  get title() { return this._title; }
  set title(value) {
    this._title = value;
    this.updateRender();
  }

  get content() { return this._content; }
  set content(value) {
    this._content = value;
    this.updateRender();
  }

  get showBorder() { return this._showBorder; }
  set showBorder(value) {
    this._showBorder = Boolean(value);
    this.updateRender();
  }

  get theme() { return this._theme; }
  set theme(value) {
    this._theme = value;
    this.updateRender();
  }

  connectedCallback() {
    this.render();
  }

  updateRender() {
    if (this.shadowRoot) {
      this.render();
    }
  }

  render() {
    const borderColor = this._theme === 'dark' ? '#444' : '#ddd';
    
    this.shadowRoot.innerHTML = `
      <style>
        .card {
          border: ${this._showBorder ? `1px solid ${borderColor}` : 'none'};
          border-radius: 8px;
          padding: 16px;
          background: ${this._theme === 'dark' ? '#333' : '#fff'};
          color: ${this._theme === 'dark' ? '#fff' : '#333'};
        }
        .card-title { font-size: 1.2em; margin-bottom: 8px; }
        .card-content { line-height: 1.5; }
      </style>
      <div class="card">
        <div class="card-title">${this._title}</div>
        <div class="card-content">${this._content}</div>
      </div>
    `;
  }
}

customElements.define('dynamic-card', DynamicCard);
```

Использование через JavaScript:

```javascript
const card = document.querySelector('dynamic-card');
card.title = 'Новый заголовок';
card.content = 'Новое содержимое';
card.theme = 'dark';
card.showBorder = false;
```

## Расширенные методы параметризации

### 1. Конфигурационный объект

Использование объекта конфигурации для сложных компонентов:

```javascript
class AdvancedTable extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.config = {
      columns: [],
      data: [],
      sortable: false,
      filterable: false,
      pageSize: 10,
      currentPage: 1,
      theme: 'default'
    };
  }

  setConfig(config) {
    this.config = { ...this.config, ...config };
    this.render();
  }

  connectedCallback() {
    // Загрузка конфигурации из атрибута data-config
    const configAttr = this.getAttribute('data-config');
    if (configAttr) {
      try {
        const config = JSON.parse(configAttr);
        this.setConfig(config);
      } catch (e) {
        console.error('Ошибка парсинга конфигурации:', e);
      }
    }
    this.render();
  }

  render() {
    const { columns, data, theme } = this.config;
    
    this.shadowRoot.innerHTML = `
      <style>
        table { width: 100%; border-collapse: collapse; }
        th, td { 
          padding: 8px; 
          text-align: left; 
          border-bottom: 1px solid ${theme === 'dark' ? '#444' : '#ddd'}; 
        }
        th { 
          background: ${theme === 'dark' ? '#444' : '#f8f9fa'}; 
          font-weight: bold; 
        }
      </style>
      <table>
        <thead>
          <tr>
            ${columns.map(col => `<th>${col.title || col.key}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${data.map(row => `
            <tr>
              ${columns.map(col => `<td>${row[col.key]}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  }
}

customElements.define('advanced-table', AdvancedTable);
```

### 2. Параметры через dataset

Использование dataset для передачи сложных параметров:

```javascript
class ChartComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.parseDataset();
    this.render();
  }

  parseDataset() {
    // Парсинг всех data-* атрибутов
    this.options = {};
    
    for (let attr of this.attributes) {
      if (attr.name.startsWith('data-')) {
        const key = attr.name.substring(5); // Убираем 'data-'
        try {
          // Пытаемся распарсить как JSON, если не получается - используем как строку
          this.options[key] = JSON.parse(attr.value);
        } catch {
          // Если не JSON, проверяем на числовое значение
          if (!isNaN(attr.value) && !isNaN(parseFloat(attr.value))) {
            this.options[key] = parseFloat(attr.value);
          } else {
            // Для булевых значений
            if (attr.value === 'true') {
              this.options[key] = true;
            } else if (attr.value === 'false') {
              this.options[key] = false;
            } else {
              this.options[key] = attr.value;
            }
          }
        }
      }
    }
  }

  render() {
    const { 
      type = 'line', 
      width = 400, 
      height = 300, 
      data = [], 
      showLegend = true 
    } = this.options;
    
    this.shadowRoot.innerHTML = `
      <style>
        .chart-container { 
          width: ${width}px; 
          height: ${height}px; 
          border: 1px solid #ccc; 
          position: relative; 
        }
      </style>
      <div class="chart-container">
        <div>График типа: ${type}</div>
        <div>Количество точек: ${data.length}</div>
        <div>Легенда: ${showLegend ? 'показана' : 'скрыта'}</div>
      </div>
    `;
  }
}

customElements.define('chart-component', ChartComponent);
```

Использование:

```html
<chart-component 
  data-type="bar" 
  data-width="500" 
  data-height="400" 
  data-data="[10, 20, 15, 25, 30]" 
  data-show-legend="true">
</chart-component>
```

### 3. Параметры через события

Использование событий для динамической настройки:

```javascript
class ConfigurableModal extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    this.config = {
      title: 'Модальное окно',
      closable: true,
      width: '500px',
      height: 'auto',
      backdrop: true
    };
  }

  connectedCallback() {
    // Слушаем событие настройки извне
    this.addEventListener('modal-config', this.handleConfigEvent.bind(this));
    this.render();
  }

  handleConfigEvent(event) {
    this.config = { ...this.config, ...event.detail };
    this.render();
  }

  render() {
    const { title, closable, width, height, backdrop } = this.config;
    
    this.shadowRoot.innerHTML = `
      <style>
        .modal-backdrop {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: ${backdrop ? 'rgba(0,0,0,0.5)' : 'transparent'};
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        }
        .modal {
          background: white;
          border-radius: 8px;
          width: ${width};
          max-width: 90vw;
          max-height: 90vh;
          overflow: auto;
        }
        .modal-header {
          padding: 16px;
          border-bottom: 1px solid #eee;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .modal-body {
          padding: 16px;
        }
        .close-btn {
          background: none;
          border: none;
          font-size: 1.5em;
          cursor: pointer;
        }
      </style>
      <div class="modal-backdrop">
        <div class="modal" style="height: ${height}">
          <div class="modal-header">
            <h3>${title}</h3>
            ${closable ? '<button class="close-btn" onclick="this.dispatchEvent(new CustomEvent(\'modal-close\', {bubbles: true}))">×</button>' : ''}
          </div>
          <div class="modal-body">
            <slot name="content"></slot>
          </div>
        </div>
      </div>
    `;
  }
}

customElements.define('configurable-modal', ConfigurableModal);
```

## Практические примеры параметризации

### 1. Компонент формы с валидацией

```javascript
class ValidatedInput extends HTMLElement {
  static get observedAttributes() {
    return ['type', 'required', 'pattern', 'minlength', 'maxlength', 'placeholder'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    this.validationMessages = {
      required: 'Поле обязательно для заполнения',
      pattern: 'Неверный формат данных',
      minlength: 'Слишком короткое значение',
      maxlength: 'Слишком длинное значение'
    };
  }

  connectedCallback() {
    this.render();
    this.setupValidation();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.setupValidation();
    }
  }

  setupValidation() {
    const input = this.shadowRoot.querySelector('input');
    if (input) {
      input.addEventListener('blur', () => this.validate());
      input.addEventListener('input', () => {
        // Очистка ошибки при вводе
        this.shadowRoot.querySelector('.error-message').textContent = '';
      });
    }
  }

  validate() {
    const input = this.shadowRoot.querySelector('input');
    const errorElement = this.shadowRoot.querySelector('.error-message');
    
    let errorMessage = '';
    
    if (this.hasAttribute('required') && !input.value.trim()) {
      errorMessage = this.validationMessages.required;
    } else if (this.hasAttribute('pattern') && input.value && 
               !new RegExp(this.getAttribute('pattern')).test(input.value)) {
      errorMessage = this.validationMessages.pattern;
    } else if (this.hasAttribute('minlength') && 
               input.value.length < parseInt(this.getAttribute('minlength'))) {
      errorMessage = this.validationMessages.minlength;
    } else if (this.hasAttribute('maxlength') && 
               input.value.length > parseInt(this.getAttribute('maxlength'))) {
      errorMessage = this.validationMessages.maxlength;
    }
    
    errorElement.textContent = errorMessage;
    input.setCustomValidity(errorMessage);
    
    return !errorMessage;
  }

  render() {
    const type = this.getAttribute('type') || 'text';
    const required = this.hasAttribute('required');
    const placeholder = this.getAttribute('placeholder') || '';
    const minlength = this.getAttribute('minlength');
    const maxlength = this.getAttribute('maxlength');
    const pattern = this.getAttribute('pattern');
    
    this.shadowRoot.innerHTML = `
      <style>
        .input-container { margin-bottom: 1rem; }
        input { 
          width: 100%; 
          padding: 0.5rem; 
          border: 1px solid #ddd; 
          border-radius: 4px; 
        }
        input:invalid { border-color: #dc3545; }
        .error-message { 
          color: #dc3545; 
          font-size: 0.875rem; 
          margin-top: 0.25rem; 
          display: block; 
        }
      </style>
      <div class="input-container">
        <input 
          type="${type}"
          ${required ? 'required' : ''}
          ${minlength ? `minlength="${minlength}"` : ''}
          ${maxlength ? `maxlength="${maxlength}"` : ''}
          ${pattern ? `pattern="${pattern}"` : ''}
          placeholder="${placeholder}"
        >
        <span class="error-message"></span>
      </div>
    `;
  }
}

customElements.define('validated-input', ValidatedInput);
```

### 2. Компонент с условным рендерингом

```javascript
class ConditionalComponent extends HTMLElement {
  static get observedAttributes() {
    return ['condition', 'show-when', 'hide-when'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  shouldShow() {
    const condition = this.getAttribute('condition');
    const showWhen = this.getAttribute('show-when');
    const hideWhen = this.getAttribute('hide-when');
    
    // Проверка условия отображения
    if (showWhen !== null) {
      return condition === showWhen;
    }
    
    // Проверка условия скрытия
    if (hideWhen !== null) {
      return condition !== hideWhen;
    }
    
    // По умолчанию показываем
    return true;
  }

  render() {
    const show = this.shouldShow();
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: ${show ? 'revert' : 'none'}; }
      </style>
      ${show ? '<slot></slot>' : ''}
    `;
  }
}

customElements.define('conditional-component', ConditionalComponent);
```

## Лучшие практики параметризации

### 1. Явные и понятные имена параметров

```javascript
// Хорошо: понятные имена параметров
class GoodComponent extends HTMLElement {
  static get observedAttributes() {
    return [
      'title',           // Заголовок компонента
      'show-header',     // Показывать ли заголовок
      'theme',          // Тема оформления
      'data-source',    // Источник данных
      'auto-refresh'    // Автоматическое обновление
    ];
  }
}

// Плохо: неясные имена параметров
class BadComponent extends HTMLElement {
  static get observedAttributes() {
    return ['a', 'b', 'c', 'd', 'e']; // Неясно, что означают параметры
  }
}
```

### 2. Валидация параметров

```javascript
class ValidatedComponent extends HTMLElement {
  static get observedAttributes() {
    return ['size', 'variant', 'data-limit'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      switch (name) {
        case 'size':
          if (!['small', 'medium', 'large'].includes(newValue)) {
            console.warn(`Недопустимое значение для атрибута size: ${newValue}`);
            this.setAttribute(name, 'medium'); // значение по умолчанию
          }
          break;
        case 'variant':
          if (!['primary', 'secondary', 'danger'].includes(newValue)) {
            console.warn(`Недопустимое значение для атрибута variant: ${newValue}`);
            this.setAttribute(name, 'primary');
          }
          break;
        case 'data-limit':
          const limit = parseInt(newValue);
          if (isNaN(limit) || limit <= 0) {
            console.warn(`Недопустимое значение для атрибута data-limit: ${newValue}`);
            this.setAttribute(name, '10');
          }
          break;
      }
      this.render();
    }
  }
}
```

### 3. Поддержка значений по умолчанию

```javascript
class ComponentWithDefaults extends HTMLElement {
  get title() {
    return this.getAttribute('title') || 'Заголовок по умолчанию';
  }
  
  get size() {
    const size = this.getAttribute('size');
    return ['small', 'medium', 'large'].includes(size) ? size : 'medium';
  }
  
  get theme() {
    const theme = this.getAttribute('theme');
    return ['light', 'dark', 'auto'].includes(theme) ? theme : 'light';
  }
  
  get itemsLimit() {
    const limit = parseInt(this.getAttribute('items-limit'));
    return isNaN(limit) || limit <= 0 ? 10 : limit;
  }
}
```

## Российские особенности параметризации

В 2025 году при параметризации компонентов в российских проектах важно учитывать:

1. **Локализация** - параметры должны поддерживать русскоязычные значения и форматы
2. **Совместимость** - параметры должны корректно работать в различных российских браузерах
3. **Регулирование** - компоненты должны соответствовать российским требованиям к веб-доступности и безопасности

## Заключение

Параметризация компонентов - ключевой аспект создания гибких и переиспользуемых элементов интерфейса. В 2025 году правильно спроектированные параметры позволяют компонентам адаптироваться к различным требованиям и контекстам использования, обеспечивая масштабируемость и поддерживаемость кода.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Вложенные-компоненты]]
- [[Документирование]]
- [[Коммуникация-между-компонентами]]