---
aliases: ["Коммуникация между компонентами", "Взаимодействие компонентов", "HTML компоненты"]
tags: [html/components, communication, frontend]
---

# Коммуникация между компонентами

## Введение

Коммуникация между компонентами - это ключевой аспект архитектуры современных веб-приложений. В 2025 году эффективное взаимодействие между компонентами обеспечивает создание сложных, но при этом понятных и поддерживаемых пользовательских интерфейсов. Правильная организация коммуникации позволяет компонентам обмениваться данными, синхронизировать состояние и реагировать на события друг друга.

## Основные паттерны коммуникации

### 1. Передача данных через атрибуты

Самый простой способ передачи данных от родительского компонента к дочернему:

```javascript
// Родительский компонент
class ParentComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.user = {
      id: 1,
      name: 'Иван Иванов',
      email: 'ivan@example.com'
    };
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
      </style>
      <child-component 
        user-id="${this.user.id}" 
        user-name="${this.user.name}" 
        user-email="${this.user.email}">
      </child-component>
    `;
  }
}

// Дочерний компонент
class ChildComponent extends HTMLElement {
  static get observedAttributes() {
    return ['user-id', 'user-name', 'user-email'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  render() {
    const userId = this.getAttribute('user-id');
    const userName = this.getAttribute('user-name');
    const userEmail = this.getAttribute('user-email');
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; border: 1px solid #ccc; }
      </style>
      <div>
        <h3>Информация о пользователе</h3>
        <p>ID: ${userId}</p>
        <p>Имя: ${userName}</p>
        <p>Email: ${userEmail}</p>
      </div>
    `;
  }
}

customElements.define('parent-component', ParentComponent);
customElements.define('child-component', ChildComponent);
```

### 2. Генерация и обработка событий

Компоненты могут взаимодействовать через пользовательские события:

```javascript
// Дочерний компонент, генерирующий события
class EventEmitterComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.addEventListeners();
  }

  addEventListeners() {
    this.shadowRoot.addEventListener('click', () => {
      // Генерация события с деталями
      this.dispatchEvent(new CustomEvent('user-action', {
        detail: {
          action: 'click',
          timestamp: new Date().toISOString(),
          component: this.tagName.toLowerCase()
        },
        bubbles: true,  // Событие всплывает
        composed: true  // Событие проходит через границы Shadow DOM
      }));
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; background: #f0f8ff; cursor: pointer; }
      </style>
      <div>Кликните на меня для генерации события</div>
    `;
  }
}

// Родительский компонент, обрабатывающий события
class EventListenerComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    
    // Обработка события от дочернего компонента
    this.addEventListener('user-action', this.handleUserAction.bind(this));
  }

  handleUserAction(event) {
    console.log('Получено событие от дочернего компонента:', event.detail);
    
    // Генерация события для родительских компонентов
    this.dispatchEvent(new CustomEvent('parent-action', {
      detail: {
        originalEvent: event.detail,
        processedBy: this.tagName.toLowerCase()
      },
      bubbles: true,
      composed: true
    }));
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
      </style>
      <div>
        <h3>Компонент-слушатель событий</h3>
        <event-emitter-component></event-emitter-component>
      </div>
    `;
  }
}

customElements.define('event-emitter', EventEmitterComponent);
customElements.define('event-listener', EventListenerComponent);
```

### 3. Коммуникация через слоты

Использование слотов для передачи данных и компонентов:

```javascript
class SlotCommunicationParent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.data = { message: 'Привет из родительского компонента!' };
  }

  connectedCallback() {
    this.render();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
        .container { border: 1px solid #ddd; padding: 16px; }
      </style>
      <div class="container">
        <h3>Родительский компонент</h3>
        <div class="content">
          <slot name="child" data-message="${this.data.message}"></slot>
        </div>
      </div>
    `;
  }
}

class SlotCommunicationChild extends HTMLElement {
  connectedCallback() {
    this.render();
    this.receiveDataFromParent();
  }

  receiveDataFromParent() {
    // Получение данных из родительского компонента через слот
    const parent = this.parentElement;
    if (parent && parent.tagName === 'SLOT-COMMUNICATION-PARENT') {
      const parentInstance = parent.closest('slot-communication-parent');
      if (parentInstance) {
        this.parentData = parentInstance.data;
        this.updateDisplay();
      }
    }
  }

  updateDisplay() {
    if (this.parentData) {
      const messageElement = this.shadowRoot.querySelector('.message');
      if (messageElement) {
        messageElement.textContent = this.parentData.message;
      }
    }
  }

  render() {
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; background: #f8f9fa; }
      </style>
      <div>
        <h4>Дочерний компонент</h4>
        <div class="message">Сообщение будет загружено...</div>
      </div>
    `;
  }
}

customElements.define('slot-parent', SlotCommunicationParent);
customElements.define('slot-child', SlotCommunicationChild);
```

## Продвинутые паттерны коммуникации

### 1. Паттерн "Публикация-Подписка" (Pub/Sub)

Создание системы событий для коммуникации между несвязанными компонентами:

```javascript
// Централизованный EventBus
class EventBus {
  constructor() {
    this.events = {};
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
    
    // Возвращаем функцию отписки
    return () => {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    };
  }

  publish(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }
}

// Глобальный экземпляр EventBus
const globalEventBus = new EventBus();

// Компонент-издатель
class PublisherComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.addEventListeners();
  }

  addEventListeners() {
    this.shadowRoot.addEventListener('click', () => {
      // Публикация события в EventBus
      globalEventBus.publish('user-updated', {
        id: Date.now(),
        name: 'Новый пользователь',
        timestamp: new Date().toISOString()
      });
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; background: #d4edda; cursor: pointer; }
      </style>
      <div>Кликните для публикации события</div>
    `;
  }
}

// Компонент-подписчик
class SubscriberComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.unsubscribe = null;
  }

  connectedCallback() {
    this.render();
    
    // Подписка на событие
    this.unsubscribe = globalEventBus.subscribe('user-updated', (data) => {
      this.handleUserUpdate(data);
    });
  }

  disconnectedCallback() {
    // Отписка при удалении компонента
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }

  handleUserUpdate(data) {
    const updateElement = this.shadowRoot.querySelector('.update-info');
    if (updateElement) {
      updateElement.innerHTML = `
        <div><strong>Имя:</strong> ${data.name}</div>
        <div><strong>ID:</strong> ${data.id}</div>
        <div><strong>Время:</strong> ${data.timestamp}</div>
      `;
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; background: #f8d7da; }
      </style>
      <div>
        <h4>Подписчик на события</h4>
        <div class="update-info">Ожидание обновления...</div>
      </div>
    `;
  }
}

customElements.define('publisher-component', PublisherComponent);
customElements.define('subscriber-component', SubscriberComponent);
```

### 2. Паттерн "Контекст" (Context)

Создание контекста для передачи данных глубоко вложенными компонентам:

```javascript
// Контекст-провайдер
class ContextProvider extends HTMLElement {
  constructor() {
    super();
    this.context = {};
    this.consumers = new Set();
  }

  setContext(key, value) {
    this.context[key] = value;
    this.notifyConsumers();
  }

  getContext(key) {
    return this.context[key];
  }

  registerConsumer(consumer) {
    this.consumers.add(consumer);
    // Передача текущего контекста новому потребителю
    consumer.updateContext(this.context);
  }

  unregisterConsumer(consumer) {
    this.consumers.delete(consumer);
  }

  notifyConsumers() {
    this.consumers.forEach(consumer => {
      consumer.updateContext(this.context);
    });
  }

  connectedCallback() {
    // Делаем этот элемент контекст-провайдером
    this.setAttribute('context-provider', '');
  }
}

// Контекст-потребитель
class ContextConsumer extends HTMLElement {
  constructor() {
    super();
    this.context = {};
  }

  connectedCallback() {
    // Поиск ближайшего контекст-провайдера
    this.provider = this.closest('[context-provider]');
    
    if (this.provider) {
      // Регистрация в провайдере
      this.provider.registerConsumer(this);
    }
  }

  disconnectedCallback() {
    if (this.provider) {
      this.provider.unregisterConsumer(this);
    }
  }

  updateContext(context) {
    this.context = { ...context };
    this.onContextUpdate();
  }

  onContextUpdate() {
    // Переопределить в наследниках
    this.render();
  }

  render() {
    // Переопределить в наследниках
  }
}

// Конкретная реализация контекста аутентификации
class AuthContextProvider extends ContextProvider {
  connectedCallback() {
    super.connectedCallback();
    this.setContext('user', null);
    this.setContext('isAuthenticated', false);
  }

  login(userData) {
    this.setContext('user', userData);
    this.setContext('isAuthenticated', true);
    this.setContext('loginTime', new Date().toISOString());
  }

  logout() {
    this.setContext('user', null);
    this.setContext('isAuthenticated', false);
    this.setContext('loginTime', null);
  }
}

class AuthContextConsumer extends ContextConsumer {
  onContextUpdate() {
    super.onContextUpdate();
    this.render();
  }

  render() {
    this.attachShadow({ mode: 'open' });
    
    const { user, isAuthenticated } = this.context;
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
        .auth-info { padding: 12px; border: 1px solid #ddd; border-radius: 4px; }
        .authenticated { background: #d4edda; color: #155724; }
        .not-authenticated { background: #f8d7da; color: #721c24; }
      </style>
      <div class="auth-info ${isAuthenticated ? 'authenticated' : 'not-authenticated'}">
        <div><strong>Аутентифицирован:</strong> ${isAuthenticated ? 'Да' : 'Нет'}</div>
        ${user ? `<div><strong>Пользователь:</strong> ${user.name || user.email}</div>` : ''}
      </div>
    `;
  }
}

customElements.define('auth-provider', AuthContextProvider);
customElements.define('auth-consumer', AuthContextConsumer);
```

### 3. Паттерн "Хранилище состояния" (State Store)

Централизованное управление состоянием приложения:

```javascript
// Простой Store для управления состоянием
class ComponentStore {
  constructor(initialState = {}) {
    this.state = { ...initialState };
    this.listeners = [];
  }

  getState() {
    return { ...this.state };
  }

  setState(newState) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...newState };
    this.notifyListeners(prevState, this.state);
  }

  subscribe(listener) {
    this.listeners.push(listener);
    
    // Возвращаем функцию отписки
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notifyListeners(prevState, currentState) {
    this.listeners.forEach(listener => {
      listener(currentState, prevState);
    });
  }

  // Метод для выполнения действий с возможностью асинхронности
  dispatch(action) {
    if (typeof action === 'function') {
      // Поддержка асинхронных действий
      return action(this.getState.bind(this), this.setState.bind(this));
    }
    
    // Простое обновление состояния
    this.setState(action);
  }
}

// Глобальный Store
const appStore = new ComponentStore({
  users: [],
  currentUser: null,
  loading: false,
  error: null
});

// Компонент, использующий Store
class StoreConnectedComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.unsubscribe = null;
  }

  connectedCallback() {
    this.render();
    
    // Подписка на изменения Store
    this.unsubscribe = appStore.subscribe((newState, prevState) => {
      this.handleStateChange(newState, prevState);
    });
  }

  disconnectedCallback() {
    // Отписка при удалении компонента
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }

  handleStateChange(newState, prevState) {
    // Проверяем, изменилось ли состояние, важное для этого компонента
    if (newState.users !== prevState.users || 
        newState.currentUser !== prevState.currentUser ||
        newState.loading !== prevState.loading) {
      this.render();
    }
  }

  async loadUsers() {
    appStore.setState({ loading: true, error: null });
    
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      
      appStore.setState({ 
        users, 
        loading: false 
      });
    } catch (error) {
      appStore.setState({ 
        error: error.message, 
        loading: false 
      });
    }
  }

  render() {
    const { users, currentUser, loading, error } = appStore.getState();
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
        .user-list { list-style: none; padding: 0; }
        .user-item { padding: 8px; border-bottom: 1px solid #eee; }
        .loading { color: #007bff; }
        .error { color: #dc3545; }
      </style>
      <div>
        <h3>Список пользователей</h3>
        ${loading ? '<div class="loading">Загрузка...</div>' : ''}
        ${error ? '<div class="error">Ошибка: ' + error + '</div>' : ''}
        <ul class="user-list">
          ${users.map(user => `
            <li class="user-item">
              ${user.name} ${currentUser && currentUser.id === user.id ? '(текущий)' : ''}
            </li>
          `).join('')}
        </ul>
        <button id="load-btn">Загрузить пользователей</button>
      </div>
    `;
    
    // Добавляем обработчик кнопки после рендеринга
    this.shadowRoot.getElementById('load-btn').onclick = () => this.loadUsers();
  }
}

customElements.define('store-connected', StoreConnectedComponent);
```

## Практические примеры коммуникации

### 1. Форма с валидацией и зависимыми полями

```javascript
// Компонент формы
class ValidationForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.formState = {
      email: '',
      password: '',
      confirmPassword: '',
      agreeToTerms: false
    };
  }

  connectedCallback() {
    this.render();
    this.setupFormValidation();
  }

  setupFormValidation() {
    // Слушаем события валидации от дочерних компонентов
    this.addEventListener('field-change', this.handleFieldChange.bind(this));
    this.addEventListener('field-validate', this.handleFieldValidate.bind(this));
  }

  handleFieldChange(event) {
    const { name, value } = event.detail;
    this.formState[name] = value;
    this.validateForm();
  }

  handleFieldValidate(event) {
    const { name, isValid } = event.detail;
    // Обработка результата валидации поля
    this.dispatchEvent(new CustomEvent('form-field-validated', {
      detail: { name, isValid },
      bubbles: true
    }));
  }

  validateForm() {
    const isValid = this.formState.email && 
                   this.formState.password && 
                   this.formState.password === this.formState.confirmPassword &&
                   this.formState.agreeToTerms;
    
    this.dispatchEvent(new CustomEvent('form-validate', {
      detail: { isValid, state: this.formState },
      bubbles: true
    }));
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; max-width: 400px; margin: 0 auto; padding: 16px; }
        .form-group { margin-bottom: 16px; }
        .form-actions { text-align: center; }
        .submit-btn { padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .submit-btn:disabled { opacity: 0.6; cursor: not-allowed; }
      </style>
      <form>
        <div class="form-group">
          <validated-input 
            name="email" 
            type="email" 
            label="Email" 
            required>
          </validated-input>
        </div>
        <div class="form-group">
          <validated-input 
            name="password" 
            type="password" 
            label="Пароль" 
            required 
            minlength="6">
          </validated-input>
        </div>
        <div class="form-group">
          <validated-input 
            name="confirmPassword" 
            type="password" 
            label="Подтверждение пароля" 
            required>
          </validated-input>
        </div>
        <div class="form-group">
          <validated-checkbox 
            name="agreeToTerms" 
            label="Согласен с условиями">
          </validated-checkbox>
        </div>
        <div class="form-actions">
          <button type="submit" class="submit-btn" id="submit-btn" disabled>Зарегистрироваться</button>
        </div>
      </form>
    `;
  }
}

// Компонент валидируемого поля ввода
class ValidatedInput extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'type', 'label', 'required', 'minlength', 'pattern'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.setupValidation();
  }

  setupValidation() {
    const input = this.shadowRoot.querySelector('input');
    
    input.addEventListener('input', (e) => {
      // Уведомляем родительскую форму об изменении
      this.dispatchEvent(new CustomEvent('field-change', {
        detail: { name: this.getAttribute('name'), value: e.target.value },
        bubbles: true
      }));
      
      // Валидируем поле
      this.validateField(e.target.value);
    });
    
    input.addEventListener('blur', () => {
      this.validateField(input.value);
    });
  }

  validateField(value) {
    let isValid = true;
    let errorMessage = '';
    
    if (this.hasAttribute('required') && !value.trim()) {
      isValid = false;
      errorMessage = 'Поле обязательно для заполнения';
    } else if (this.hasAttribute('minlength') && 
               value.length < parseInt(this.getAttribute('minlength'))) {
      isValid = false;
      errorMessage = `Минимум ${this.getAttribute('minlength')} символов`;
    } else if (this.hasAttribute('pattern') && 
               value && !new RegExp(this.getAttribute('pattern')).test(value)) {
      isValid = false;
      errorMessage = 'Неверный формат';
    }
    
    // Обновляем состояние поля
    const input = this.shadowRoot.querySelector('input');
    input.setCustomValidity(errorMessage);
    
    // Показываем ошибку
    this.shadowRoot.querySelector('.error-message').textContent = errorMessage;
    
    // Уведомляем родительскую форму о результате валидации
    this.dispatchEvent(new CustomEvent('field-validate', {
      detail: { 
        name: this.getAttribute('name'), 
        isValid,
        value
      },
      bubbles: true
    }));
  }

  render() {
    const name = this.getAttribute('name') || '';
    const type = this.getAttribute('type') || 'text';
    const label = this.getAttribute('label') || name;
    const required = this.hasAttribute('required');
    
    this.shadowRoot.innerHTML = `
      <style>
        .input-group { margin-bottom: 8px; }
        label { display: block; margin-bottom: 4px; font-weight: bold; }
        input { 
          width: 100%; 
          padding: 8px; 
          border: 1px solid #ddd; 
          border-radius: 4px; 
        }
        input:invalid { border-color: #dc3545; }
        .error-message { 
          color: #dc3545; 
          font-size: 0.8em; 
          margin-top: 4px; 
          display: block; 
        }
      </style>
      <div class="input-group">
        <label>${label}${required ? ' *' : ''}</label>
        <input 
          name="${name}"
          type="${type}"
          ${required ? 'required' : ''}
        >
        <div class="error-message"></div>
      </div>
    `;
  }
}

// Компонент чекбокса с валидацией
class ValidatedCheckbox extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'label'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.setupValidation();
  }

  setupValidation() {
    const checkbox = this.shadowRoot.querySelector('input[type="checkbox"]');
    
    checkbox.addEventListener('change', (e) => {
      // Уведомляем родительскую форму об изменении
      this.dispatchEvent(new CustomEvent('field-change', {
        detail: { name: this.getAttribute('name'), value: e.target.checked },
        bubbles: true
      }));
    });
  }

  render() {
    const name = this.getAttribute('name') || '';
    const label = this.getAttribute('label') || name;
    
    this.shadowRoot.innerHTML = `
      <style>
        .checkbox-group { display: flex; align-items: center; }
        input[type="checkbox"] { margin-right: 8px; }
      </style>
      <div class="checkbox-group">
        <input type="checkbox" name="${name}" id="cb-${name}">
        <label for="cb-${name}">${label}</label>
      </div>
    `;
  }
}

customElements.define('validation-form', ValidationForm);
customElements.define('validated-input', ValidatedInput);
customElements.define('validated-checkbox', ValidatedCheckbox);
```

### 2. Компонент навигации с синхронизацией состояния

```javascript
// Панель навигации
class NavigationPanel extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.activeTab = 'home';
  }

  connectedCallback() {
    this.render();
    this.setupNavigation();
  }

  setupNavigation() {
    // Слушаем события переключения вкладок
    this.addEventListener('tab-change', this.handleTabChange.bind(this));
    
    // Слушаем события от контента вкладок
    this.addEventListener('content-ready', this.handleContentReady.bind(this));
  }

  handleTabChange(event) {
    const { tabId } = event.detail;
    this.setActiveTab(tabId);
  }

  handleContentReady(event) {
    const { tabId, content } = event.detail;
    // Обработка готовности контента вкладки
    console.log(`Контент вкладки ${tabId} готов:`, content);
  }

  setActiveTab(tabId) {
    this.activeTab = tabId;
    
    // Обновляем UI
    this.render();
    
    // Уведомляем остальные компоненты о смене вкладки
    this.dispatchEvent(new CustomEvent('navigation-change', {
      detail: { activeTab: tabId },
      bubbles: true,
      composed: true
    }));
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        .nav-tabs { display: flex; border-bottom: 1px solid #ddd; }
        .nav-tab { 
          padding: 12px 24px; 
          cursor: pointer; 
          border: 1px solid transparent; 
          border-bottom: none; 
          background: #f8f9fa;
          margin-right: 4px;
        }
        .nav-tab.active { 
          background: white; 
          border-color: #ddd; 
          border-bottom: 1px solid white; 
          margin-bottom: -1px; 
        }
        .tab-content { padding: 16px; }
      </style>
      <div class="nav-tabs">
        <div class="nav-tab ${this.activeTab === 'home' ? 'active' : ''}" data-tab="home">Главная</div>
        <div class="nav-tab ${this.activeTab === 'profile' ? 'active' : ''}" data-tab="profile">Профиль</div>
        <div class="nav-tab ${this.activeTab === 'settings' ? 'active' : ''}" data-tab="settings">Настройки</div>
      </div>
      <div class="tab-content">
        <slot name="tab-content"></slot>
      </div>
    `;
    
    // Добавляем обработчики кликов по вкладкам
    this.shadowRoot.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.getAttribute('data-tab');
        this.setActiveTab(tabId);
      });
    });
  }
}

// Компонент вкладки
class NavigationTab extends HTMLElement {
  static get observedAttributes() {
    return ['tab-id', 'active'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.checkActiveState();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'active' && oldValue !== newValue) {
      this.checkActiveState();
    }
  }

  checkActiveState() {
    const isActive = this.hasAttribute('active');
    this.style.display = isActive ? 'block' : 'none';
    
    // Уведомляем родительскую навигацию о готовности контента
    if (isActive) {
      this.dispatchEvent(new CustomEvent('content-ready', {
        detail: { 
          tabId: this.getAttribute('tab-id'), 
          content: this.innerHTML 
        },
        bubbles: true,
        composed: true
      }));
    }
  }

  render() {
    const tabId = this.getAttribute('tab-id');
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
      </style>
      <div class="tab-pane">
        <h3>Вкладка: ${tabId}</h3>
        <slot></slot>
      </div>
    `;
  }
}

customElements.define('navigation-panel', NavigationPanel);
customElements.define('navigation-tab', NavigationTab);
```

## Российские особенности коммуникации компонентов

В 2025 году при организации коммуникации между компонентами в российских проектах важно учитывать:

1. **Совместимость с отечественными решениями** - системы коммуникации должны работать в российской IT-инфраструктуре
2. **Безопасность передачи данных** - коммуникация между компонентами должна соответствовать требованиям безопасности
3. **Локализация** - системы коммуникации должны поддерживать передачу данных на русском языке
4. **Регулирование** - коммуникация между компонентами должна соответствовать российским требованиям к обработке персональных данных

## Лучшие практики коммуникации

### 1. Четкое определение интерфейсов

```javascript
// Хорошо: четко определенный интерфейс коммуникации
/**
 * Интерфейс для компонента списка пользователей
 * События:
 * - user-selected: { userId: string, userData: object }
 * - users-loaded: { users: array, totalCount: number }
 * - user-action: { userId: string, action: string, data: object }
 */
class UserListComponent extends HTMLElement {
  // Реализация компонента
}

// Плохо: неясный интерфейс
class UnclearComponent extends HTMLElement {
  // Компонент без четко определенного интерфейса коммуникации
}
```

### 2. Использование типизированных событий

```javascript
// Определение типов событий
const ComponentEvents = {
  USER_SELECTED: 'user-selected',
  DATA_LOADED: 'data-loaded',
  ERROR_OCCURRED: 'error-occurred',
  STATE_CHANGED: 'state-changed'
};

// Использование типизированных событий
class TypedEventComponent extends HTMLElement {
  emitUserSelected(userId, userData) {
    this.dispatchEvent(new CustomEvent(ComponentEvents.USER_SELECTED, {
      detail: { userId, userData },
      bubbles: true,
      composed: true
    }));
  }
  
  emitDataLoaded(data) {
    this.dispatchEvent(new CustomEvent(ComponentEvents.DATA_LOADED, {
      detail: { data },
      bubbles: true,
      composed: true
    }));
  }
}
```

### 3. Централизованное управление состоянием

```javascript
// Централизованное управление состоянием
class StateManager {
  constructor() {
    this.state = {};
    this.subscribers = new Map();
  }

  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;

    // Уведомление подписчиков
    const subscribers = this.subscribers.get(key) || [];
    subscribers.forEach(callback => callback(value, oldValue));
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, []);
    }
    this.subscribers.get(key).push(callback);

    // Возврат функции отписки
    return () => {
      const subscribers = this.subscribers.get(key) || [];
      const index = subscribers.indexOf(callback);
      if (index > -1) {
        subscribers.splice(index, 1);
      }
    };
  }

  getState(key) {
    return this.state[key];
  }
}

// Глобальный экземпляр
const stateManager = new StateManager();
```

## Заключение

Коммуникация между компонентами - это фундаментальный аспект архитектуры современных веб-приложений. В 2025 году правильная организация коммуникации позволяет создавать гибкие, масштабируемые и поддерживаемые интерфейсы. Выбор подходящего паттерна коммуникации зависит от сложности взаимодействия, архитектуры приложения и требований к производительности.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Вложенные-компоненты]]
- [[Параметризация]]
- [[Жизненный-цикл-компонентов]]
- [[Тестирование-компонентов]]