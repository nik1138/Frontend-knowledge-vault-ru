---
aliases: ["Доступность компонентов", "A11y компоненты", "Доступные компоненты", "HTML компоненты"]
tags: [html/components, accessibility, a11y, frontend]
---

# А11y-компоненты

## Введение

А11y (доступность) компонентов - это практика создания веб-компонентов, которые могут использоваться людьми с различными ограничениями и особенностями. В 2025 году доступность становится неотъемлемой частью разработки, а не дополнительной функцией. Создание доступных компонентов обеспечивает равный доступ к информации и функциям веб-приложений для всех пользователей.

## Основы доступности компонентов

### 1. Семантическая разметка

Использование правильных HTML-элементов и ARIA-атрибутов:

```javascript
class AccessibleButton extends HTMLElement {
  static get observedAttributes() {
    return ['label', 'disabled', 'aria-expanded', 'aria-pressed'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.setupAccessibility();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.updateAccessibility();
    }
  }

  setupAccessibility() {
    // Установка ролей и свойств доступности
    this.shadowRoot.querySelector('button').setAttribute('role', 'button');
    
    // Обеспечение фокуса
    this.shadowRoot.querySelector('button').setAttribute('tabindex', '0');
    
    // Обработка клавиатурных событий
    this.addEventListener('keydown', this.handleKeydown.bind(this));
  }

  updateAccessibility() {
    const button = this.shadowRoot.querySelector('button');
    
    if (this.hasAttribute('disabled')) {
      button.setAttribute('aria-disabled', 'true');
      button.setAttribute('tabindex', '-1');
    } else {
      button.removeAttribute('aria-disabled');
      button.setAttribute('tabindex', '0');
    }
    
    // Обновление других ARIA-атрибутов
    ['aria-expanded', 'aria-pressed', 'label'].forEach(attr => {
      if (this.hasAttribute(attr)) {
        button.setAttribute(attr, this.getAttribute(attr));
      } else {
        button.removeAttribute(attr);
      }
    });
  }

  handleKeydown(event) {
    // Обработка клавиатурных событий для доступности
    switch (event.key) {
      case 'Enter':
      case ' ':
        event.preventDefault();
        this.click();
        break;
      case 'Escape':
        this.blur();
        break;
    }
  }

  render() {
    const label = this.getAttribute('label') || 'Кнопка';
    const disabled = this.hasAttribute('disabled');
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: inline-block; }
        button {
          padding: 8px 16px;
          border: 2px solid #007bff;
          background: white;
          color: #007bff;
          border-radius: 4px;
          cursor: ${disabled ? 'not-allowed' : 'pointer'};
          opacity: ${disabled ? '0.6' : '1'};
        }
        button:focus {
          outline: 2px solid #0056b3;
          outline-offset: 2px;
        }
        button[aria-pressed="true"] {
          background: #007bff;
          color: white;
        }
      </style>
      <button 
        type="button"
        ?disabled="${disabled}"
        aria-label="${label}"
      >
        <slot name="content">${label}</slot>
      </button>
    `;
  }
}

customElements.define('accessible-button', AccessibleButton);
```

### 2. Управление фокусом

Правильное управление фокусом для клавиатурных пользователей:

```javascript
class AccessibleModal extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.focusedElementBeforeModal = null;
  }

  connectedCallback() {
    this.render();
    this.setupFocusManagement();
  }

  disconnectedCallback() {
    this.restoreFocus();
  }

  setupFocusManagement() {
    // Сохраняем элемент, который имел фокус до открытия модального окна
    this.focusedElementBeforeModal = document.activeElement;
  }

  open() {
    this.style.display = 'block';
    
    // Устанавливаем фокус на первый интерактивный элемент в модальном окне
    const firstFocusable = this.shadowRoot.querySelector(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (firstFocusable) {
      firstFocusable.focus();
    }
    
    // Запрещаем фокусировку на элементах за пределами модального окна
    this.trapFocus();
  }

  close() {
    this.style.display = 'none';
    // Восстанавливаем фокус на элементе, который имел фокус до открытия модального окна
    if (this.focusedElementBeforeModal) {
      this.focusedElementBeforeModal.focus();
    }
  }

  trapFocus() {
    // Ограничиваем фокусировку только внутри модального окна
    const focusableElements = this.shadowRoot.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    // Обработка Tab и Shift+Tab
    this.addEventListener('keydown', (event) => {
      if (event.key === 'Tab') {
        if (event.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          }
        } else {
          // Tab
          if (document.activeElement === lastElement) {
            event.preventDefault();
            firstElement.focus();
          }
        }
      } else if (event.key === 'Escape') {
        this.close();
      }
    });
  }

  restoreFocus() {
    if (this.focusedElementBeforeModal) {
      this.focusedElementBeforeModal.focus();
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        .modal-backdrop {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        }
        .modal-content {
          background: white;
          padding: 20px;
          border-radius: 8px;
          min-width: 300px;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
        }
        .close-btn {
          float: right;
          background: none;
          border: none;
          font-size: 1.5em;
          cursor: pointer;
          color: #333;
        }
      </style>
      <div class="modal-backdrop">
        <div class="modal-content" role="dialog" aria-modal="true">
          <button class="close-btn" aria-label="Закрыть модальное окно">×</button>
          <slot name="content"></slot>
        </div>
      </div>
    `;
    
    // Обработка закрытия модального окна
    this.shadowRoot.querySelector('.close-btn').addEventListener('click', () => {
      this.close();
    });
  }
}

customElements.define('accessible-modal', AccessibleModal);
```

### 3. Контрастность и визуальные индикаторы

Обеспечение достаточной контрастности и визуальных индикаторов:

```javascript
class AccessibleCard extends HTMLElement {
  static get observedAttributes() {
    return ['theme', 'highlighted'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.setupAccessibilityFeatures();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  setupAccessibilityFeatures() {
    // Обеспечение визуального индикатора фокуса
    const style = document.createElement('style');
    style.textContent = `
      :host(*) button:focus,
      :host(*) input:focus,
      :host(*) a:focus {
        outline: 2px solid #0056b3;
        outline-offset: 2px;
      }
      
      /* Обеспечение контрастности */
      :host([theme="dark"]) {
        --text-color: #ffffff;
        --bg-color: #333333;
        --border-color: #555555;
      }
      
      :host([theme="light"]) {
        --text-color: #333333;
        --bg-color: #ffffff;
        --border-color: #dddddd;
      }
      
      :host(*) {
        color: var(--text-color);
      }
    `;
    
    this.shadowRoot.appendChild(style);
  }

  render() {
    const theme = this.getAttribute('theme') || 'light';
    const highlighted = this.hasAttribute('highlighted');
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        .card {
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 16px;
          background: var(--bg-color);
          transition: all 0.2s ease;
        }
        .card.highlighted {
          border: 2px solid #007bff;
          box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .card:focus-within {
          outline: 2px solid #0056b3;
          outline-offset: -2px;
        }
        .card-header {
          font-weight: bold;
          margin-bottom: 8px;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 8px;
        }
        .card-content {
          line-height: 1.5;
        }
      </style>
      <div class="card ${highlighted ? 'highlighted' : ''}" tabindex="0">
        <div class="card-header">
          <slot name="header"></slot>
        </div>
        <div class="card-content">
          <slot name="content"></slot>
        </div>
        <div class="card-actions">
          <slot name="actions"></slot>
        </div>
      </div>
    `;
  }
}

customElements.define('accessible-card', AccessibleCard);
```

## Продвинутые паттерны доступности

### 1. Компонент списка с клавиатурной навигацией

```javascript
class AccessibleListbox extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.selectedIndex = -1;
  }

  connectedCallback() {
    this.render();
    this.setupKeyboardNavigation();
    this.setupAccessibility();
  }

  setupKeyboardNavigation() {
    this.addEventListener('keydown', this.handleKeydown.bind(this));
  }

  setupAccessibility() {
    // Установка ARIA-ролей и свойств
    const listbox = this.shadowRoot.querySelector('[role="listbox"]');
    listbox.setAttribute('aria-activedescendant', '');
    
    // Установка уникального ID если не задан
    if (!this.id) {
      this.id = `accessible-listbox-${Date.now()}`;
    }
    listbox.setAttribute('id', this.id);
  }

  handleKeydown(event) {
    const options = this.shadowRoot.querySelectorAll('[role="option"]');
    
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        this.selectedIndex = (this.selectedIndex + 1) % options.length;
        this.updateSelection();
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        this.selectedIndex = 
          (this.selectedIndex - 1 + options.length) % options.length;
        this.updateSelection();
        break;
        
      case 'Home':
        event.preventDefault();
        this.selectedIndex = 0;
        this.updateSelection();
        break;
        
      case 'End':
        event.preventDefault();
        this.selectedIndex = options.length - 1;
        this.updateSelection();
        break;
        
      case 'Enter':
      case ' ':
        event.preventDefault();
        if (this.selectedIndex >= 0) {
          this.selectOption(this.selectedIndex);
        }
        break;
    }
  }

  updateSelection() {
    const options = this.shadowRoot.querySelectorAll('[role="option"]');
    
    // Снимаем выделение со всех опций
    options.forEach((option, index) => {
      option.setAttribute('aria-selected', 'false');
      option.classList.remove('selected');
      
      if (index === this.selectedIndex) {
        option.setAttribute('aria-selected', 'true');
        option.classList.add('selected');
        option.focus();
        
        // Обновляем активный потомок для ARIA
        const listbox = this.shadowRoot.querySelector('[role="listbox"]');
        listbox.setAttribute('aria-activedescendant', option.id);
      }
    });
  }

  selectOption(index) {
    const options = this.shadowRoot.querySelectorAll('[role="option"]');
    if (options[index]) {
      const option = options[index];
      this.dispatchEvent(new CustomEvent('option-selected', {
        detail: {
          index,
          value: option.getAttribute('data-value'),
          text: option.textContent
        },
        bubbles: true,
        composed: true
      }));
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        [role="listbox"] {
          border: 1px solid #ccc;
          border-radius: 4px;
          max-height: 200px;
          overflow-y: auto;
          background: white;
        }
        [role="option"] {
          padding: 8px 12px;
          cursor: pointer;
          border-bottom: 1px solid #eee;
        }
        [role="option"]:last-child {
          border-bottom: none;
        }
        [role="option"]:hover,
        [role="option"].selected {
          background-color: #007bff;
          color: white;
        }
        [role="option"]:focus {
          outline: 2px solid #0056b3;
          outline-offset: -2px;
        }
      </style>
      <div role="listbox" aria-label="Список опций">
        <div role="option" id="option-0" data-value="option1" tabindex="-1">
          Опция 1
        </div>
        <div role="option" id="option-1" data-value="option2" tabindex="-1">
          Опция 2
        </div>
        <div role="option" id="option-2" data-value="option3" tabindex="-1">
          Опция 3
        </div>
      </div>
    `;
    
    // Добавляем обработчики кликов для каждой опции
    this.shadowRoot.querySelectorAll('[role="option"]').forEach((option, index) => {
      option.addEventListener('click', () => {
        this.selectedIndex = index;
        this.updateSelection();
        this.selectOption(index);
      });
    });
  }
}

customElements.define('accessible-listbox', AccessibleListbox);
```

### 2. Компонент вкладок с доступностью

```javascript
class AccessibleTabs extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.currentTab = 0;
  }

  connectedCallback() {
    this.render();
    this.setupAccessibility();
  }

  setupAccessibility() {
    // Установка ARIA-ролей и свойств
    const tablist = this.shadowRoot.querySelector('[role="tablist"]');
    tablist.setAttribute('aria-label', 'Навигация по вкладкам');
    
    const tabs = this.shadowRoot.querySelectorAll('[role="tab"]');
    const panels = this.shadowRoot.querySelectorAll('[role="tabpanel"]');
    
    // Связывание вкладок с панелями
    tabs.forEach((tab, index) => {
      const panel = panels[index];
      if (panel) {
        const panelId = panel.id || `tabpanel-${Date.now()}-${index}`;
        const tabId = tab.id || `tab-${Date.now()}-${index}`;
        
        panel.id = panelId;
        tab.id = tabId;
        
        tab.setAttribute('aria-controls', panelId);
        panel.setAttribute('aria-labelledby', tabId);
      }
    });
    
    this.updateTabState();
    this.setupKeyboardNavigation();
  }

  setupKeyboardNavigation() {
    const tabs = this.shadowRoot.querySelectorAll('[role="tab"]');
    
    tabs.forEach((tab, index) => {
      tab.addEventListener('keydown', (event) => {
        switch (event.key) {
          case 'ArrowRight':
            event.preventDefault();
            this.currentTab = (this.currentTab + 1) % tabs.length;
            this.updateTabState();
            tabs[this.currentTab].focus();
            break;
            
          case 'ArrowLeft':
            event.preventDefault();
            this.currentTab = 
              (this.currentTab - 1 + tabs.length) % tabs.length;
            this.updateTabState();
            tabs[this.currentTab].focus();
            break;
            
          case 'Home':
            event.preventDefault();
            this.currentTab = 0;
            this.updateTabState();
            tabs[0].focus();
            break;
            
          case 'End':
            event.preventDefault();
            this.currentTab = tabs.length - 1;
            this.updateTabState();
            tabs[tabs.length - 1].focus();
            break;
            
          case 'Enter':
          case ' ':
            event.preventDefault();
            this.currentTab = index;
            this.updateTabState();
            break;
        }
      });
    });
  }

  updateTabState() {
    const tabs = this.shadowRoot.querySelectorAll('[role="tab"]');
    const panels = this.shadowRoot.querySelectorAll('[role="tabpanel"]');
    
    tabs.forEach((tab, index) => {
      const isSelected = index === this.currentTab;
      
      tab.setAttribute('aria-selected', isSelected);
      tab.setAttribute('tabindex', isSelected ? '0' : '-1');
      tab.classList.toggle('active', isSelected);
    });
    
    panels.forEach((panel, index) => {
      panel.hidden = index !== this.currentTab;
      panel.setAttribute('aria-hidden', index !== this.currentTab);
    });
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        [role="tablist"] {
          display: flex;
          border-bottom: 1px solid #ddd;
        }
        [role="tab"] {
          padding: 12px 24px;
          cursor: pointer;
          border: 1px solid transparent;
          border-bottom: none;
          background: #f8f9fa;
          margin-right: 4px;
        }
        [role="tab"]:focus {
          outline: 2px solid #0056b3;
          outline-offset: -2px;
        }
        [role="tab"].active {
          background: white;
          border-color: #ddd;
          border-bottom: 1px solid white;
          margin-bottom: -1px;
        }
        [role="tabpanel"] {
          padding: 16px;
          border: 1px solid #ddd;
          border-top: none;
        }
      </style>
      <div role="tablist">
        <div role="tab" tabindex="0">Вкладка 1</div>
        <div role="tab" tabindex="-1">Вкладка 2</div>
        <div role="tab" tabindex="-1">Вкладка 3</div>
      </div>
      <div role="tabpanel" id="panel-1">Содержимое первой вкладки</div>
      <div role="tabpanel" id="panel-2" hidden>Содержимое второй вкладки</div>
      <div role="tabpanel" id="panel-3" hidden>Содержимое третьей вкладки</div>
    `;
    
    // Добавляем обработчики кликов по вкладкам
    const tabs = this.shadowRoot.querySelectorAll('[role="tab"]');
    tabs.forEach((tab, index) => {
      tab.addEventListener('click', () => {
        this.currentTab = index;
        this.updateTabState();
      });
    });
  }
}

customElements.define('accessible-tabs', AccessibleTabs);
```

## Практические примеры доступных компонентов

### 1. Доступная форма с валидацией

```javascript
class AccessibleForm extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.state = {
      errors: {},
      submitted: false
    };
  }

  connectedCallback() {
    this.render();
    this.setupAccessibility();
  }

  setupAccessibility() {
    // Установка ARIA-атрибутов для формы
    const form = this.shadowRoot.querySelector('form');
    form.setAttribute('aria-label', 'Регистрационная форма');
    
    // Установка уникальных ID для полей и их описаний
    this.setupFieldAccessibility();
  }

  setupFieldAccessibility() {
    const fields = this.shadowRoot.querySelectorAll('input, textarea, select');
    
    fields.forEach(field => {
      const fieldName = field.getAttribute('name');
      if (fieldName) {
        const fieldId = `field-${fieldName}-${Date.now()}`;
        field.id = fieldId;
        
        // Связывание метки с полем
        const label = this.shadowRoot.querySelector(`label[for="${fieldName}"]`);
        if (label) {
          label.setAttribute('for', fieldId);
        }
      }
    });
  }

  validateField(fieldName, value) {
    const errors = { ...this.state.errors };
    
    switch (fieldName) {
      case 'email':
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!value.trim()) {
          errors.email = 'Email обязателен для заполнения';
        } else if (!emailRegex.test(value)) {
          errors.email = 'Введите корректный email адрес';
        } else {
          delete errors.email;
        }
        break;
        
      case 'name':
        if (!value.trim()) {
          errors.name = 'Имя обязательно для заполнения';
        } else if (value.length < 2) {
          errors.name = 'Имя должно содержать не менее 2 символов';
        } else {
          delete errors.name;
        }
        break;
    }
    
    this.state.errors = errors;
    this.render();
    
    // Уведомление о статусе валидации с помощью ARIA
    this.announceValidationStatus(fieldName, errors[fieldName]);
  }

  announceValidationStatus(fieldName, error) {
    // Создание временного элемента для ARIA-объявления
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.style.position = 'absolute';
    announcement.style.left = '-9999px';
    announcement.textContent = error ? 
      `Ошибка в поле ${fieldName}: ${error}` : 
      `Поле ${fieldName} заполнено корректно`;
    
    this.shadowRoot.appendChild(announcement);
    
    // Удаление элемента после объявления
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.parentNode.removeChild(announcement);
      }
    }, 1000);
  }

  async submitForm(event) {
    event.preventDefault();
    
    // Сбор данных формы
    const formData = new FormData(event.target);
    const data = Object.fromEntries(formData);
    
    // Валидация всех полей
    Object.entries(data).forEach(([key, value]) => {
      this.validateField(key, value);
    });
    
    // Проверка наличия ошибок
    if (Object.keys(this.state.errors).length === 0) {
      this.state.submitted = true;
      
      try {
        // Отправка данных
        const response = await fetch('/api/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        if (response.ok) {
          this.showSuccessMessage();
        } else {
          throw new Error('Ошибка сервера при регистрации');
        }
      } catch (error) {
        this.state.errors.submit = error.message;
        this.render();
      }
    } else {
      // Фокус на первое поле с ошибкой
      const firstErrorField = Object.keys(this.state.errors)[0];
      const errorField = this.shadowRoot.querySelector(`[name="${firstErrorField}"]`);
      if (errorField) {
        errorField.focus();
        
        // Объявление ошибки
        this.announceValidationStatus(firstErrorField, this.state.errors[firstErrorField]);
      }
    }
  }

  showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.setAttribute('role', 'alert');
    successMessage.setAttribute('aria-live', 'assertive');
    successMessage.textContent = 'Регистрация прошла успешно!';
    successMessage.style.cssText = `
      background: #d4edda;
      color: #155724;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 16px;
      border: 1px solid #c3e6cb;
    `;
    
    const form = this.shadowRoot.querySelector('form');
    form.insertBefore(successMessage, form.firstChild);
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; max-width: 500px; margin: 0 auto; }
        form { background: white; padding: 24px; border-radius: 8px; }
        .form-group { margin-bottom: 16px; }
        label { 
          display: block; 
          margin-bottom: 4px; 
          font-weight: bold; 
          color: #333;
        }
        input, select, textarea {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 16px; /* Для лучшей читаемости */
        }
        input:focus, select:focus, textarea:focus {
          outline: 2px solid #0056b3;
          outline-offset: 2px;
          border-color: #007bff;
        }
        .error { 
          color: #dc3545; 
          font-size: 0.875rem; 
          margin-top: 4px; 
          display: block;
        }
        .submit-btn { 
          background: #007bff; 
          color: white; 
          border: none; 
          padding: 10px 20px; 
          border-radius: 4px; 
          cursor: pointer; 
          font-size: 16px;
        }
        .submit-btn:focus {
          outline: 2px solid #0056b3;
          outline-offset: 2px;
        }
        .required { color: #dc3545; }
      </style>
      <form>
        <div class="form-group">
          <label for="name">Имя <span class="required" aria-label="обязательное поле">*</span></label>
          <input 
            type="text" 
            name="name" 
            required
            aria-describedby="name-error"
          >
          <div id="name-error" class="error" role="alert">
            ${this.state.errors.name || ''}
          </div>
        </div>
        
        <div class="form-group">
          <label for="email">Email <span class="required" aria-label="обязательное поле">*</span></label>
          <input 
            type="email" 
            name="email" 
            required
            aria-describedby="email-error"
          >
          <div id="email-error" class="error" role="alert">
            ${this.state.errors.email || ''}
          </div>
        </div>
        
        <div class="form-group">
          <label for="phone">Телефон</label>
          <input 
            type="tel" 
            name="phone"
            aria-describedby="phone-description"
          >
          <div id="phone-description" class="error" style="color: #6c757d; font-size: 0.8em;">
            Формат: +7 (XXX) XXX-XX-XX
          </div>
        </div>
        
        <div class="form-group">
          <label for="message">Сообщение</label>
          <textarea 
            name="message" 
            rows="4"
            aria-describedby="message-description"
          ></textarea>
          <div id="message-description" class="error" style="color: #6c757d; font-size: 0.8em;">
            Максимум 500 символов
          </div>
        </div>
        
        <button type="submit" class="submit-btn">
          Отправить
        </button>
        
        ${this.state.errors.submit ? 
          `<div class="error" role="alert">${this.state.errors.submit}</div>` : 
          ''}
      </form>
    `;
    
    // Добавляем обработчик отправки формы
    this.shadowRoot.querySelector('form').addEventListener('submit', 
      this.submitForm.bind(this));
    
    // Добавляем обработчики изменения полей
    const fields = this.shadowRoot.querySelectorAll('input, textarea, select');
    fields.forEach(field => {
      field.addEventListener('blur', (e) => {
        this.validateField(e.target.name, e.target.value);
      });
      
      // Обработка удаления ошибки при вводе
      field.addEventListener('input', (e) => {
        if (this.state.errors[e.target.name]) {
          // Очищаем ошибку при вводе
          const errors = { ...this.state.errors };
          delete errors[e.target.name];
          this.state.errors = errors;
          
          const errorElement = this.shadowRoot.querySelector(
            `#${e.target.name}-error`
          );
          if (errorElement) {
            errorElement.textContent = '';
          }
        }
      });
    });
  }
}

customElements.define('accessible-form', AccessibleForm);
```

### 2. Доступный компонент автодополнения

```javascript
class AccessibleAutocomplete extends HTMLElement {
  static get observedAttributes() {
    return ['source', 'min-length', 'delay'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.options = [];
    this.filteredOptions = [];
    this.selectedIndex = -1;
    this.isOpen = false;
    this.searchTimeout = null;
  }

  connectedCallback() {
    this.render();
    this.setupAccessibility();
  }

  setupAccessibility() {
    // Установка ARIA-атрибутов
    const input = this.shadowRoot.querySelector('input');
    const listbox = this.shadowRoot.querySelector('[role="listbox"]');
    
    const autocompleteId = `autocomplete-${Date.now()}`;
    input.id = autocompleteId;
    
    listbox.id = `listbox-${autocompleteId}`;
    input.setAttribute('aria-owns', listbox.id);
    input.setAttribute('aria-autocomplete', 'list');
    input.setAttribute('aria-expanded', 'false');
    input.setAttribute('role', 'combobox');
  }

  async search(query) {
    if (query.length < parseInt(this.getAttribute('min-length') || '2')) {
      this.filteredOptions = [];
      this.selectedIndex = -1;
      this.isOpen = false;
      this.render();
      return;
    }
    
    try {
      // Имитация поиска - в реальном приложении будет запрос к API
      const response = await fetch(`${this.getAttribute('source')}?q=${query}`);
      this.options = await response.json();
      this.filterOptions(query);
    } catch (error) {
      console.error('Ошибка поиска:', error);
      this.filteredOptions = [];
    }
  }

  filterOptions(query) {
    const lowerQuery = query.toLowerCase();
    this.filteredOptions = this.options.filter(option => 
      option.label.toLowerCase().includes(lowerQuery)
    );
    
    this.selectedIndex = -1;
    this.isOpen = this.filteredOptions.length > 0;
    this.render();
  }

  handleInput(event) {
    const query = event.target.value;
    
    // Очистка предыдущего таймера
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
    }
    
    // Установка нового таймера с задержкой
    this.searchTimeout = setTimeout(() => {
      this.search(query);
    }, parseInt(this.getAttribute('delay') || '300'));
  }

  handleKeydown(event) {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        if (this.isOpen && this.filteredOptions.length > 0) {
          this.selectedIndex = 
            (this.selectedIndex + 1) % this.filteredOptions.length;
          this.updateAriaActivedescendant();
        }
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        if (this.isOpen && this.filteredOptions.length > 0) {
          this.selectedIndex = 
            (this.selectedIndex - 1 + this.filteredOptions.length) % 
            this.filteredOptions.length;
          this.updateAriaActivedescendant();
        }
        break;
        
      case 'Enter':
        event.preventDefault();
        if (this.selectedIndex >= 0 && this.isOpen) {
          this.selectOption(this.selectedIndex);
        }
        break;
        
      case 'Escape':
        this.isOpen = false;
        this.selectedIndex = -1;
        this.render();
        break;
        
      case 'Tab':
        if (this.isOpen) {
          this.selectOption(this.selectedIndex);
        }
        break;
    }
  }

  updateAriaActivedescendant() {
    const input = this.shadowRoot.querySelector('input');
    const option = this.shadowRoot.querySelector(
      `[data-index="${this.selectedIndex}"]`
    );
    
    if (option) {
      input.setAttribute('aria-activedescendant', option.id);
    } else {
      input.removeAttribute('aria-activedescendant');
    }
  }

  selectOption(index) {
    if (index >= 0 && index < this.filteredOptions.length) {
      const selectedOption = this.filteredOptions[index];
      const input = this.shadowRoot.querySelector('input');
      
      input.value = selectedOption.label;
      this.selectedIndex = -1;
      this.isOpen = false;
      
      // Генерация события с выбранными данными
      this.dispatchEvent(new CustomEvent('option-selected', {
        detail: selectedOption,
        bubbles: true,
        composed: true
      }));
    }
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; position: relative; }
        .autocomplete-container {
          position: relative;
        }
        input {
          width: 100%;
          padding: 8px 12px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 16px;
        }
        input:focus {
          outline: 2px solid #0056b3;
          outline-offset: 2px;
        }
        [role="listbox"] {
          position: absolute;
          top: 100%;
          left: 0;
          right: 0;
          background: white;
          border: 1px solid #ddd;
          border-top: none;
          border-radius: 0 0 4px 4px;
          max-height: 200px;
          overflow-y: auto;
          z-index: 1000;
          display: ${this.isOpen ? 'block' : 'none'};
        }
        [role="option"] {
          padding: 8px 12px;
          cursor: pointer;
          border-bottom: 1px solid #eee;
        }
        [role="option"]:last-child {
          border-bottom: none;
        }
        [role="option"]:hover,
        [role="option"].selected {
          background-color: #007bff;
          color: white;
        }
        [role="option"]:focus {
          outline: 2px solid #0056b3;
          outline-offset: -2px;
        }
      </style>
      <div class="autocomplete-container">
        <input 
          type="text" 
          placeholder="Начните вводить для поиска..."
          aria-label="Поле поиска"
        >
        <div role="listbox" aria-label="Результаты поиска">
          ${this.filteredOptions.map((option, index) => `
            <div 
              role="option" 
              id="option-${Date.now()}-${index}"
              data-index="${index}"
              tabindex="-1"
              aria-selected="${this.selectedIndex === index}"
            >
              ${option.label}
            </div>
          `).join('')}
        </div>
      </div>
    `;
    
    // Добавляем обработчики событий
    const input = this.shadowRoot.querySelector('input');
    input.addEventListener('input', this.handleInput.bind(this));
    input.addEventListener('keydown', this.handleKeydown.bind(this));
    
    // Обработчики для опций
    const options = this.shadowRoot.querySelectorAll('[role="option"]');
    options.forEach((option, index) => {
      option.addEventListener('click', () => {
        this.selectOption(index);
      });
      
      option.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Предотвращаем потерю фокуса с инпута
        this.selectOption(index);
      });
    });
  }
}

customElements.define('accessible-autocomplete', AccessibleAutocomplete);
```

## Российские особенности доступности

В 2025 году при создании доступных компонентов в российских проектах важно учитывать:

1. **ГОСТ Р 52872-2018** - компоненты должны соответствовать российскому стандарту доступности
2. **Локализация** - текстовые метки, описания и сообщения об ошибках должны быть на русском языке
3. **Кириллица** - компоненты должны корректно обрабатывать и отображать кириллический текст
4. **Регулирование** - доступность должна соответствовать требованиям законодательства РФ

## Тестирование доступности

### 1. ARIA-валидация

```javascript
// Вспомогательная функция для проверки ARIA-атрибутов
function validateA11y(element) {
  const issues = [];
  
  // Проверка наличия необходимых ARIA-атрибутов
  if (element.hasAttribute('role')) {
    const role = element.getAttribute('role');
    
    // Проверка соответствия атрибутов роли
    switch (role) {
      case 'button':
        if (!element.hasAttribute('tabindex')) {
          issues.push('Кнопка должна иметь tabindex');
        }
        break;
        
      case 'listbox':
        if (!element.hasAttribute('aria-label') && !element.hasAttribute('aria-labelledby')) {
          issues.push('Listbox должна иметь aria-label или aria-labelledby');
        }
        break;
    }
  }
  
  return issues;
}

// Использование в тестах
test('компонент имеет правильные ARIA-атрибуты', () => {
  const element = document.createElement('accessible-button');
  document.body.appendChild(element);
  
  const a11yIssues = validateA11y(element.shadowRoot.querySelector('button'));
  expect(a11yIssues).toHaveLength(0);
});
```

### 2. Проверка контрастности

```javascript
// Вспомогательная функция для проверки контрастности
function checkContrast(element) {
  const style = window.getComputedStyle(element);
  const bgColor = style.backgroundColor;
  const textColor = style.color;
  
  // Простая проверка контрастности (в реальном приложении использовать полноценный алгоритм)
  const bg = parseColor(bgColor);
  const text = parseColor(textColor);
  
  const contrastRatio = calculateContrastRatio(bg, text);
  return contrastRatio >= 4.5; // Минимальный коэффициент для нормального текста
}

function parseColor(colorString) {
  // Парсинг цвета из строки
  const match = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (match) {
    return {
      r: parseInt(match[1]) / 255,
      g: parseInt(match[2]) / 255,
      b: parseInt(match[3]) / 255
    };
  }
  return { r: 0, g: 0, b: 0 };
}

function calculateContrastRatio(color1, color2) {
  const l1 = getLuminance(color1);
  const l2 = getLuminance(color2);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

function getLuminance(color) {
  const [r, g, b] = [color.r, color.g, color.b].map(c => {
    c = c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    return c;
  });
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}
```

## Лучшие практики доступности

### 1. Проверка доступности в процессе разработки

```javascript
// Пример конфигурации для проверки доступности
class AccessibleComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.accessibilityChecks = [];
  }

  connectedCallback() {
    this.render();
    this.performAccessibilityChecks();
  }

  performAccessibilityChecks() {
    // Проверка основных аспектов доступности
    this.checkSemanticStructure();
    this.checkFocusManagement();
    this.checkAriaAttributes();
    this.checkKeyboardNavigation();
  }

  checkSemanticStructure() {
    // Проверка семантической разметки
    const hasProperHeading = this.shadowRoot.querySelector('h1, h2, h3, h4, h5, h6');
    if (!hasProperHeading) {
      console.warn('Компонент не содержит заголовков', this.tagName);
    }
  }

  checkFocusManagement() {
    // Проверка управления фокусом
    const focusableElements = this.shadowRoot.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) {
      console.warn('Компонент не содержит фокусируемых элементов', this.tagName);
    }
  }

  checkAriaAttributes() {
    // Проверка ARIA-атрибутов
    const elementsWithRoles = this.shadowRoot.querySelectorAll('[role]');
    elementsWithRoles.forEach(el => {
      // Проверка соответствия атрибутов роли
      const role = el.getAttribute('role');
      // Добавить проверки для конкретных ролей
    });
  }

  checkKeyboardNavigation() {
    // Проверка клавиатурной навигации
    // Реализовать проверки в зависимости от типа компонента
  }

  render() {
    // Рендеринг компонента
  }
}
```

### 2. Использование инструментов доступности

```javascript
// Интеграция с axe-core для проверки доступности
import axe from 'axe-core';

async function checkComponentAccessibility(component) {
  const results = await axe.run(component);
  
  if (results.violations.length > 0) {
    console.error('Найдены нарушения доступности:', results.violations);
    return false;
  }
  
  return true;
}
```

## Заключение

Доступность компонентов в 2025 году является неотъемлемой частью разработки качественных веб-приложений. Создание доступных компонентов обеспечивает равный доступ к информации и функциям для всех пользователей, включая людей с ограниченными возможностями. Правильная реализация доступности требует понимания стандартов, практик и инструментов, но дает значительные преимущества для всех пользователей.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Вложенные-компоненты]]
- [[Параметризация]]
- [[Жизненный-цикл-компонентов]]
- [[Коммуникация-между-компонентами]]
- [[Тестирование-компонентов]]