---
aliases: ["Жизненный цикл компонентов", "Цикл жизни компонентов", "HTML компоненты"]
tags: [html/components, lifecycle, frontend]
---

# Жизненный цикл компонентов

## Введение

Жизненный цикл компонентов определяет последовательность событий и состояний, через которые проходит компонент от создания до уничтожения. В 2025 году понимание жизненного цикла компонентов критически важно для эффективной разработки, оптимизации производительности и правильного управления ресурсами.

## Основные этапы жизненного цикла

### 1. Создание (Construction)

Этап создания компонента происходит при вызове конструктора:

```javascript
class LifecycleDemo extends HTMLElement {
  constructor() {
    // Вызывается при создании экземпляра элемента
    super();
    
    // Инициализация свойств
    this.created = true;
    this.initialized = false;
    this.data = null;
    
    // Создание Shadow DOM
    this.attachShadow({ mode: 'open' });
    
    console.log('Компонент создан');
  }
}
```

### 2. Подключение к DOM (Connected)

Метод `connectedCallback` вызывается при добавлении элемента в DOM:

```javascript
class LifecycleDemo extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    // Вызывается при добавлении элемента в DOM
    console.log('Компонент подключен к DOM');
    
    // Инициализация компонента
    this.initializeComponent();
    
    // Загрузка данных
    this.loadData();
    
    // Установка слушателей событий
    this.addEventListeners();
    
    // Рендеринг компонента
    this.render();
    
    // Установка флага инициализации
    this.initialized = true;
  }

  initializeComponent() {
    // Логика инициализации
    console.log('Компонент инициализирован');
  }

  async loadData() {
    // Загрузка начальных данных
    try {
      const response = await fetch('/api/component-data');
      this.data = await response.json();
      console.log('Данные загружены');
    } catch (error) {
      console.error('Ошибка загрузки данных:', error);
    }
  }

  addEventListeners() {
    // Добавление слушателей событий
    this.addEventListener('click', this.handleClick.bind(this));
    this.addEventListener('focus', this.handleFocus.bind(this));
  }

  handleClick(event) {
    console.log('Клик по компоненту');
  }

  handleFocus(event) {
    console.log('Компонент получил фокус');
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; border: 1px solid #ccc; }
        .status { color: green; }
      </style>
      <div class="status">Компонент инициализирован</div>
      <slot></slot>
    `;
  }
}
```

### 3. Изменение атрибутов (Attribute Changes)

Метод `attributeChangedCallback` вызывается при изменении наблюдаемых атрибутов:

```javascript
class ConfigurableComponent extends HTMLElement {
  static get observedAttributes() {
    // Список атрибутов, за которыми нужно наблюдать
    return ['theme', 'size', 'disabled', 'data-source'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.config = {
      theme: 'light',
      size: 'medium',
      disabled: false
    };
  }

  connectedCallback() {
    this.applyConfiguration();
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // Вызывается при изменении наблюдаемого атрибута
    console.log(`Атрибут ${name} изменился с "${oldValue}" на "${newValue}"`);
    
    if (oldValue !== newValue) {
      this.handleAttributeChange(name, newValue);
    }
  }

  handleAttributeChange(name, value) {
    switch (name) {
      case 'theme':
        this.config.theme = value || 'light';
        this.applyTheme();
        break;
      case 'size':
        this.config.size = value || 'medium';
        this.applySize();
        break;
      case 'disabled':
        this.config.disabled = value !== null;
        this.applyDisabledState();
        break;
      case 'data-source':
        this.loadDataFromSource(value);
        break;
    }
    
    // Перерендер компонента при необходимости
    this.render();
  }

  applyTheme() {
    // Применение темы
    this.style.setProperty('--theme-color', 
      this.config.theme === 'dark' ? '#333' : '#fff');
  }

  applySize() {
    // Применение размера
    const sizeMap = {
      'small': '8px',
      'medium': '16px',
      'large': '24px'
    };
    this.style.setProperty('--padding-size', sizeMap[this.config.size] || '16px');
  }

  applyDisabledState() {
    // Применение состояния отключения
    if (this.config.disabled) {
      this.classList.add('disabled');
    } else {
      this.classList.remove('disabled');
    }
  }

  async loadDataFromSource(source) {
    if (!source) return;
    
    try {
      const response = await fetch(source);
      const data = await response.json();
      this.updateData(data);
    } catch (error) {
      console.error('Ошибка загрузки данных:', error);
    }
  }

  updateData(data) {
    // Обновление данных компонента
    this.data = data;
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          padding: var(--padding-size, 16px);
          background: var(--theme-color, #fff);
          border: 1px solid #ccc;
          border-radius: 4px;
        }
        :host(.disabled) {
          opacity: 0.6;
          pointer-events: none;
        }
      </style>
      <div class="content">
        <slot></slot>
      </div>
    `;
  }
}
```

### 4. Отключение от DOM (Disconnected)

Метод `disconnectedCallback` вызывается при удалении элемента из DOM:

```javascript
class ResourceManagingComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Инициализация ресурсов
    this.timer = null;
    this.observer = null;
    this.eventListeners = [];
    this.dataSubscriptions = [];
  }

  connectedCallback() {
    console.log('Компонент подключен');
    
    // Установка таймера
    this.timer = setInterval(() => {
      console.log('Таймер компонента');
    }, 1000);
    
    // Установка наблюдателя за изменениями
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log('Изменение в компоненте:', mutation);
      });
    });
    
    this.observer.observe(this, { childList: true, subtree: true });
    
    // Добавление слушателей событий
    const clickHandler = (e) => console.log('Клик:', e);
    this.addEventListener('click', clickHandler);
    this.eventListeners.push({ element: this, event: 'click', handler: clickHandler });
    
    this.render();
  }

  disconnectedCallback() {
    // Вызывается при удалении элемента из DOM
    console.log('Компонент отключен');
    
    // Очистка таймеров
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
      console.log('Таймер очищен');
    }
    
    // Остановка наблюдателей
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
      console.log('Наблюдатель отключен');
    }
    
    // Удаление слушателей событий
    this.eventListeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this.eventListeners = [];
    console.log('Слушатели событий удалены');
    
    // Отписка от подписок на данные
    this.dataSubscriptions.forEach(subscription => {
      if (subscription.unsubscribe) {
        subscription.unsubscribe();
      }
    });
    this.dataSubscriptions = [];
    console.log('Подписки на данные отменены');
    
    // Очистка других ресурсов
    this.cleanupResources();
  }

  cleanupResources() {
    // Дополнительная очистка ресурсов
    console.log('Ресурсы компонента очищены');
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; border: 1px solid #007bff; }
      </style>
      <div>Компонент с управлением ресурсами</div>
    `;
  }
}
```

## Продвинутые паттерны жизненного цикла

### 1. Управление состоянием компонента

```javascript
class StatefulComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Инициализация состояния
    this.state = {
      loading: false,
      error: null,
      data: null,
      initialized: false
    };
    
    // Привязка методов
    this.updateState = this.updateState.bind(this);
  }

  connectedCallback() {
    this.updateState({ initialized: true });
    this.loadData();
    this.render();
  }

  disconnectedCallback() {
    // Очистка асинхронных операций
    if (this.abortController) {
      this.abortController.abort();
    }
  }

  async loadData() {
    this.updateState({ loading: true, error: null });
    
    try {
      // Использование AbortController для отмены запросов
      this.abortController = new AbortController();
      
      const response = await fetch('/api/data', {
        signal: this.abortController.signal
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Проверка, не был ли компонент отключен во время запроса
      if (this.state.initialized) {
        this.updateState({ data, loading: false });
      }
    } catch (error) {
      if (error.name !== 'AbortError') {
        this.updateState({ error: error.message, loading: false });
      }
    }
  }

  updateState(newState) {
    // Обновление состояния и вызов рендеринга
    this.state = { ...this.state, ...newState };
    
    // Уведомление об изменении состояния
    this.dispatchEvent(new CustomEvent('state-change', {
      detail: { ...this.state },
      bubbles: true,
      composed: true
    }));
    
    // Перерендер при изменении состояния
    if (this.shadowRoot) {
      this.render();
    }
  }

  render() {
    const { loading, error, data, initialized } = this.state;
    
    if (!initialized) {
      this.shadowRoot.innerHTML = `
        <style>:host { display: block; }</style>
        <div>Инициализация...</div>
      `;
      return;
    }
    
    if (loading) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; text-align: center; padding: 20px; }
          .spinner { 
            width: 24px; 
            height: 24px; 
            border: 3px solid #f3f3f3; 
            border-top: 3px solid #3498db; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin: 0 auto; 
          }
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
        <div>
          <div class="spinner"></div>
          <p>Загрузка...</p>
        </div>
      `;
      return;
    }
    
    if (error) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; padding: 16px; }
          .error { color: #e74c3c; }
        </style>
        <div class="error">
          <p>Ошибка: ${error}</p>
          <button id="retry-btn">Повторить</button>
        </div>
      `;
      this.shadowRoot.getElementById('retry-btn').onclick = () => this.loadData();
      return;
    }
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 16px; }
        .data { background: #f8f9fa; padding: 16px; border-radius: 4px; }
      </style>
      <div class="data">
        <h3>Данные загружены</h3>
        <pre>${JSON.stringify(data, null, 2)}</pre>
      </div>
    `;
  }
}
```

### 2. Оптимизация производительности

```javascript
class OptimizedComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Оптимизация рендеринга
    this.renderQueued = false;
    this.pendingUpdates = {};
    
    // Кэш для производительности
    this.renderCache = new Map();
    this.attributeCache = new Map();
  }

  static get observedAttributes() {
    return ['data', 'config', 'theme'];
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      // Кэширование изменений атрибутов
      this.attributeCache.set(name, newValue);
      
      // Оптимизация обновлений
      this.pendingUpdates[name] = newValue;
      
      // Планирование обновления
      this.scheduleRender();
    }
  }

  scheduleRender() {
    // Планирование рендеринга с помощью requestAnimationFrame
    if (!this.renderQueued) {
      this.renderQueued = true;
      requestAnimationFrame(() => {
        this.performRender();
        this.renderQueued = false;
      });
    }
  }

  performRender() {
    // Объединение всех ожидающих обновлений
    const updates = { ...this.pendingUpdates };
    this.pendingUpdates = {};
    
    // Проверка необходимости рендеринга
    if (this.shouldRender(updates)) {
      this.render();
    }
  }

  shouldRender(updates) {
    // Логика определения необходимости рендеринга
    return Object.keys(updates).length > 0;
  }

  render() {
    // Генерация уникального ключа для кэширования
    const cacheKey = this.getRenderCacheKey();
    
    if (this.renderCache.has(cacheKey)) {
      // Использование кэшированного результата
      this.shadowRoot.innerHTML = this.renderCache.get(cacheKey);
      return;
    }
    
    // Фактический рендеринг
    const html = this.generateHTML();
    
    // Кэширование результата
    this.renderCache.set(cacheKey, html);
    this.shadowRoot.innerHTML = html;
  }

  getRenderCacheKey() {
    // Генерация ключа для кэширования
    return JSON.stringify({
      attributes: Object.fromEntries(this.attributeCache),
      state: this.getStateForCache()
    });
  }

  getStateForCache() {
    // Получение состояния, влияющего на рендеринг
    return {
      // Только значимые свойства для кэширования
    };
  }

  generateHTML() {
    // Генерация HTML-разметки
    const data = this.getAttribute('data');
    const config = this.getAttribute('config');
    const theme = this.getAttribute('theme') || 'light';
    
    return `
      <style>
        :host { display: block; }
        .component { 
          padding: 16px; 
          background: ${theme === 'dark' ? '#333' : '#fff'}; 
          color: ${theme === 'dark' ? '#fff' : '#333'}; 
        }
      </style>
      <div class="component">
        <div>Данные: ${data || 'не указаны'}</div>
        <div>Конфиг: ${config || 'не указан'}</div>
        <div>Тема: ${theme}</div>
      </div>
    `;
  }
}
```

## Практические примеры

### 1. Компонент с жизненным циклом асинхронных данных

```javascript
class AsyncDataComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    this.state = {
      loading: false,
      data: null,
      error: null,
      lastUpdated: null
    };
    
    this.retryCount = 0;
    this.maxRetries = 3;
    this.retryDelay = 1000;
  }

  static get observedAttributes() {
    return ['source', 'auto-refresh', 'refresh-interval'];
  }

  connectedCallback() {
    this.startAutoRefresh();
    this.loadData();
  }

  disconnectedCallback() {
    this.stopAutoRefresh();
    this.cancelPendingRequests();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      switch (name) {
        case 'source':
          this.loadData();
          break;
        case 'auto-refresh':
          if (newValue !== null) {
            this.startAutoRefresh();
          } else {
            this.stopAutoRefresh();
          }
          break;
        case 'refresh-interval':
          this.stopAutoRefresh();
          this.startAutoRefresh();
          break;
      }
    }
  }

  async loadData() {
    if (this.state.loading) return; // Предотвращение дублирующихся запросов
    
    this.updateState({ loading: true, error: null });
    
    try {
      const source = this.getAttribute('source');
      if (!source) {
        throw new Error('Не указан источник данных');
      }
      
      const response = await fetch(source);
      
      if (!response.ok) {
        throw new Error(`Ошибка сети: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      this.updateState({
        data,
        loading: false,
        lastUpdated: new Date()
      });
      
      this.retryCount = 0; // Сброс счётчика повторных попыток
      
      this.dispatchEvent(new CustomEvent('data-loaded', {
        detail: { data, timestamp: this.state.lastUpdated },
        bubbles: true,
        composed: true
      }));
    } catch (error) {
      this.updateState({ error: error.message, loading: false });
      
      // Автоматическая повторная попытка при ошибках
      if (this.retryCount < this.maxRetries) {
        this.retryCount++;
        setTimeout(() => this.loadData(), this.retryDelay * this.retryCount);
      } else {
        this.dispatchEvent(new CustomEvent('data-error', {
          detail: { error: error.message },
          bubbles: true,
          composed: true
        }));
      }
    }
  }

  updateState(newState) {
    this.state = { ...this.state, ...newState };
    
    if (this.shadowRoot) {
      this.render();
    }
  }

  startAutoRefresh() {
    const interval = parseInt(this.getAttribute('refresh-interval')) || 30000; // 30 секунд по умолчанию
    
    if (this.hasAttribute('auto-refresh')) {
      this.autoRefreshInterval = setInterval(() => {
        this.loadData();
      }, interval);
    }
  }

  stopAutoRefresh() {
    if (this.autoRefreshInterval) {
      clearInterval(this.autoRefreshInterval);
      this.autoRefreshInterval = null;
    }
  }

  cancelPendingRequests() {
    // Отмена всех pending fetch-запросов
    if (this.abortController) {
      this.abortController.abort();
    }
  }

  render() {
    const { loading, error, data, lastUpdated } = this.state;
    
    if (loading) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; padding: 16px; text-align: center; }
          .loading { display: flex; align-items: center; justify-content: center; gap: 8px; }
          .spinner { 
            width: 16px; 
            height: 16px; 
            border: 2px solid #f3f3f3; 
            border-top: 2px solid #3498db; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
          }
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
        <div class="loading">
          <div class="spinner"></div>
          <span>Загрузка данных...</span>
        </div>
      `;
      return;
    }
    
    if (error) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; padding: 16px; }
          .error { color: #e74c3c; background: #fdf2f2; padding: 12px; border-radius: 4px; }
          .retry-btn { margin-top: 8px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        </style>
        <div class="error">
          <div>Ошибка: ${error}</div>
          <button class="retry-btn" onclick="this.getRootNode().host.loadData()">Повторить</button>
        </div>
      `;
      return;
    }
    
    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; }
        .data-container { padding: 16px; background: #f8f9fa; border-radius: 4px; }
        .meta { font-size: 0.8em; color: #666; margin-bottom: 8px; }
      </style>
      <div class="data-container">
        <div class="meta">Последнее обновление: ${lastUpdated ? lastUpdated.toLocaleTimeString() : 'неизвестно'}</div>
        <div class="content">
          <pre>${JSON.stringify(data, null, 2)}</pre>
        </div>
      </div>
    `;
  }
}
```

### 2. Компонент с управлением производительностью

```javascript
class PerformanceOptimizedComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Оптимизация производительности
    this.renderScheduled = false;
    this.shouldUpdate = true;
    this.updateReasons = [];
    
    // Обработчики событий с оптимизацией
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleScroll = this.handleScroll.bind(this);
  }

  connectedCallback() {
    // Использование Intersection Observer для оптимизации
    this.intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.onBecomeVisible();
        } else {
          this.onBecomeHidden();
        }
      });
    });
    
    this.intersectionObserver.observe(this);
    
    // Использование Resize Observer
    this.resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        this.handleResize(entry.contentRect);
      }
    });
    
    this.resizeObserver.observe(this);
    
    this.render();
  }

  disconnectedCallback() {
    // Очистка наблюдателей
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
    }
    
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    
    // Очистка других ресурсов
    this.cleanup();
  }

  handleResize(rect) {
    // Оптимизированный обработчик изменения размера
    if (this.isVisible) {
      this.scheduleUpdate('resize');
    }
  }

  handleScroll() {
    // Оптимизированный обработчик прокрутки
    if (this.isVisible) {
      this.scheduleUpdate('scroll');
    }
  }

  onBecomeVisible() {
    this.isVisible = true;
    this.render(); // Рендер при появлении в области видимости
  }

  onBecomeHidden() {
    this.isVisible = false;
    // Можно приостановить ресурсоемкие операции
  }

  scheduleUpdate(reason) {
    this.updateReasons.push(reason);
    
    if (!this.renderScheduled) {
      this.renderScheduled = true;
      
      // Использование requestIdleCallback для оптимизации
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => {
          this.performUpdate();
          this.renderScheduled = false;
        });
      } else {
        // Резервный вариант для старых браузеров
        requestAnimationFrame(() => {
          this.performUpdate();
          this.renderScheduled = false;
        });
      }
    }
  }

  performUpdate() {
    // Объединение причин обновления
    const reasons = [...new Set(this.updateReasons)];
    this.updateReasons = [];
    
    // Проверка необходимости обновления
    if (this.shouldUpdate) {
      this.render();
    }
  }

  cleanup() {
    // Очистка всех ресурсов
    console.log('Компонент очищен');
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host { 
          display: block; 
          padding: 16px; 
          border: 1px solid #ddd; 
          background: white;
        }
      </style>
      <div>Производительно оптимизированный компонент</div>
      <div>Видимый: ${this.isVisible ? 'да' : 'нет'}</div>
    `;
  }
}
```

## Российские особенности и практики

В 2025 году при работе с жизненным циклом компонентов в российских проектах важно учитывать:

1. **Производительность в условиях ограниченных ресурсов** - компоненты должны эффективно управлять памятью и процессорным временем
2. **Совместимость с отечественными системами** - жизненный цикл должен корректно работать в российской экосистеме
3. **Безопасность** - при отключении компонентов необходимо корректно очищать все ресурсы и данные
4. **Регулирование** - компоненты должны соответствовать российским требованиям к обработке данных

## Лучшие практики

### 1. Правильная очистка ресурсов

```javascript
class ProperlyCleanedComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    // Хранение всех ресурсов для последующей очистки
    this.timers = new Set();
    this.observers = new Set();
    this.eventListeners = new Set();
    this.abortControllers = new Set();
  }

  connectedCallback() {
    // Установка таймера
    const timer = setInterval(() => {
      console.log('Таймер активен');
    }, 1000);
    this.timers.add(timer);
    
    // Установка наблюдателя
    const observer = new MutationObserver(() => {
      console.log('Изменения в DOM');
    });
    observer.observe(this, { childList: true, subtree: true });
    this.observers.add(observer);
    
    // Установка AbortController для fetch
    const abortController = new AbortController();
    this.abortControllers.add(abortController);
    
    fetch('/api/data', { signal: abortController.signal })
      .then(response => response.json())
      .then(data => console.log('Данные:', data))
      .catch(error => {
        if (error.name !== 'AbortError') {
          console.error('Ошибка:', error);
        }
      });
    
    this.render();
  }

  disconnectedCallback() {
    // Правильная очистка всех ресурсов
    this.timers.forEach(timer => clearInterval(timer));
    this.timers.clear();
    
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    this.abortControllers.forEach(controller => controller.abort());
    this.abortControllers.clear();
    
    // Очистка других ресурсов
    console.log('Все ресурсы очищены');
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>:host { display: block; padding: 16px; }</style>
      <div>Компонент с правильной очисткой ресурсов</div>
    `;
  }
}
```

### 2. Обработка ошибок жизненного цикла

```javascript
class ErrorHandlingComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.state = { error: null };
  }

  connectedCallback() {
    try {
      this.initializeComponent();
      this.render();
    } catch (error) {
      this.handleError(error, 'connectedCallback');
    }
  }

  disconnectedCallback() {
    try {
      this.cleanupResources();
    } catch (error) {
      console.error('Ошибка при очистке:', error);
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    try {
      if (oldValue !== newValue) {
        this.handleAttributeChange(name, newValue);
      }
    } catch (error) {
      this.handleError(error, 'attributeChangedCallback');
    }
  }

  handleError(error, context) {
    console.error(`Ошибка в ${context}:`, error);
    this.state.error = error.message;
    this.render();
    
    // Уведомление внешнего кода об ошибке
    this.dispatchEvent(new CustomEvent('component-error', {
      detail: { error, context },
      bubbles: true,
      composed: true
    }));
  }

  initializeComponent() {
    // Логика инициализации
  }

  cleanupResources() {
    // Логика очистки
  }

  handleAttributeChange(name, value) {
    // Логика обработки изменения атрибута
  }

  render() {
    if (this.state.error) {
      this.shadowRoot.innerHTML = `
        <style>
          :host { display: block; padding: 16px; color: #e74c3c; }
        </style>
        <div>Ошибка компонента: ${this.state.error}</div>
      `;
      return;
    }
    
    this.shadowRoot.innerHTML = `
      <style>:host { display: block; padding: 16px; }</style>
      <div>Компонент без ошибок</div>
    `;
  }
}
```

## Заключение

Жизненный цикл компонентов - это фундаментальная концепция, определяющая поведение компонентов на протяжении всего их существования. Правильное понимание и реализация жизненного цикла позволяет создавать эффективные, производительные и надежные компоненты. В 2025 году это особенно важно в условиях растущей сложности веб-приложений и требований к производительности.

## См. также

- [[Создание-компонентов]]
- [[Переиспользование]]
- [[Вложенные-компоненты]]
- [[Параметризация]]
- [[Веб-компоненты]]
- [[Коммуникация-между-компонентами]]