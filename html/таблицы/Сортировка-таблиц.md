---
aliases: [Сортировка HTML-таблиц, Интерактивные таблицы]
tags: [html, таблицы, сортировка, javascript, интерактивность]
---

# Сортировка HTML-таблиц

## Введение

Сортировка HTML-таблиц - это важная функция, которая позволяет пользователям упорядочивать данные по различным критериям. В 2025 году интерактивные таблицы с возможностью сортировки становятся стандартом для веб-приложений, особенно в системах управления данными, аналитических панелях и электронной коммерции.

## Основные подходы к сортировке

### Клиентская сортировка

Клиентская сортировка выполняется в браузере и не требует запросов к серверу:

```html
<table id="sortable-table">
  <thead>
    <tr>
      <th class="sortable" data-column="0">Имя</th>
      <th class="sortable" data-column="1">Возраст</th>
      <th class="sortable" data-column="2">Зарплата</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Иванов И.И.</td>
      <td>30</td>
      <td>75 000 ₽</td>
    </tr>
    <tr>
      <td>Петров П.П.</td>
      <td>25</td>
      <td>65 000 ₽</td>
    </tr>
    <tr>
      <td>Сидоров С.С.</td>
      <td>35</td>
      <td>90 000 ₽</td>
    </tr>
  </tbody>
</table>
```

```javascript
document.addEventListener('DOMContentLoaded', function() {
  const table = document.getElementById('sortable-table');
  const headers = table.querySelectorAll('th.sortable');
  
  headers.forEach(header => {
    header.addEventListener('click', function() {
      const columnIndex = parseInt(this.getAttribute('data-column'));
      sortTable(columnIndex);
    });
  });
  
  let sortDirection = {};
  
  function sortTable(columnIndex) {
    const tbody = table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    
    // Определяем направление сортировки
    const isAscending = sortDirection[columnIndex] !== false;
    sortDirection[columnIndex] = !isAscending;
    
    // Сортируем строки
    rows.sort((a, b) => {
      const aValue = a.cells[columnIndex].textContent.trim();
      const bValue = b.cells[columnIndex].textContent.trim();
      
      // Определяем тип данных для правильной сортировки
      let comparison = 0;
      
      // Проверяем, являются ли значения числами
      const aNum = parseFloat(aValue.replace(/[^\d.-]/g, ''));
      const bNum = parseFloat(bValue.replace(/[^\d.-]/g, ''));
      
      if (!isNaN(aNum) && !isNaN(bNum)) {
        comparison = aNum - bNum;
      } else {
        comparison = aValue.localeCompare(bValue, 'ru-RU');
      }
      
      return isAscending ? comparison : -comparison;
    });
    
    // Возвращаем отсортированные строки в tbody
    rows.forEach(row => tbody.appendChild(row));
    
    // Обновляем индикаторы сортировки
    updateSortIndicators(columnIndex, isAscending);
  }
  
  function updateSortIndicators(activeColumn, isAscending) {
    // Убираем индикаторы со всех заголовков
    headers.forEach(header => {
      header.classList.remove('sort-asc', 'sort-desc');
    });
    
    // Добавляем индикатор активной сортировки
    headers[activeColumn].classList.add(isAscending ? 'sort-asc' : 'sort-desc');
  }
});
```

### CSS для визуальных индикаторов

```css
.sortable {
  cursor: pointer;
  position: relative;
  user-select: none;
}

.sortable::after {
  content: ' ↕️';
  font-size: 0.8em;
  opacity: 0.5;
}

.sortable.sort-asc::after {
  content: ' ↑';
  opacity: 1;
  color: #007bff;
}

.sortable.sort-desc::after {
  content: ' ↓';
  opacity: 1;
  color: #007bff;
}
```

## Сортировка различных типов данных

### Сортировка чисел

```javascript
function sortNumeric(a, b, isAscending) {
  const aNum = parseFloat(a.textContent.replace(/[^\d.-]/g, ''));
  const bNum = parseFloat(b.textContent.replace(/[^\d.-]/g, ''));
  
  if (isNaN(aNum) || isNaN(bNum)) {
    // Если не числа, сортируем как строки
    return a.textContent.localeCompare(b.textContent, 'ru-RU');
  }
  
  return isAscending ? aNum - bNum : bNum - aNum;
}
```

### Сортировка дат

```javascript
function sortDates(a, b, isAscending) {
  const parseDate = (dateStr) => {
    // Поддержка разных форматов дат
    const date = new Date(dateStr);
    if (isNaN(date)) {
      // Если формат даты не стандартный, пытаемся его преобразовать
      const parts = dateStr.split(/[.\-\/]/);
      if (parts.length === 3) {
        // Предполагаем формат ДД.ММ.ГГГГ
        return new Date(parts[2], parts[1] - 1, parts[0]);
      }
    }
    return date;
  };
  
  const aDate = parseDate(a.textContent);
  const bDate = parseDate(b.textContent);
  
  return isAscending ? aDate - bDate : bDate - aDate;
}
```

### Сортировка валют

```javascript
function sortCurrency(a, b, isAscending) {
  const aValue = parseFloat(a.textContent.replace(/[^\d.-]/g, ''));
  const bValue = parseFloat(b.textContent.replace(/[^\d.-]/g, ''));
  
  return isAscending ? aValue - bValue : bValue - aValue;
}
```

## Продвинутая сортировка

### Многоуровневая сортировка

```javascript
function multiSort(rows, sortCriteria) {
  return rows.sort((a, b) => {
    for (let i = 0; i < sortCriteria.length; i++) {
      const { columnIndex, isAscending } = sortCriteria[i];
      const aVal = a.cells[columnIndex].textContent.trim();
      const bVal = b.cells[columnIndex].textContent.trim();
      
      let comparison = 0;
      
      // Определяем тип данных
      const aNum = parseFloat(aVal.replace(/[^\d.-]/g, ''));
      const bNum = parseFloat(bVal.replace(/[^\d.-]/g, ''));
      
      if (!isNaN(aNum) && !isNaN(bNum)) {
        comparison = aNum - bNum;
      } else {
        comparison = aVal.localeCompare(bVal, 'ru-RU');
      }
      
      if (comparison !== 0) {
        return isAscending ? comparison : -comparison;
      }
    }
    return 0;
  });
}
```

### Сортировка с сохранением состояния

```javascript
class TableSorter {
  constructor(tableId) {
    this.table = document.getElementById(tableId);
    this.headers = this.table.querySelectorAll('th.sortable');
    this.sortState = JSON.parse(sessionStorage.getItem(`tableSort_${tableId}`)) || {};
    this.init();
  }
  
  init() {
    this.headers.forEach(header => {
      const columnIndex = parseInt(header.getAttribute('data-column'));
      header.addEventListener('click', () => this.handleSort(columnIndex));
      
      // Восстанавливаем состояние сортировки
      if (this.sortState[columnIndex]) {
        header.classList.add(this.sortState[columnIndex].direction === 'asc' ? 'sort-asc' : 'sort-desc');
      }
    });
    
    // Применяем сохраненную сортировку при загрузке
    this.applySavedSort();
  }
  
  handleSort(columnIndex) {
    const isAscending = this.sortState[columnIndex]?.direction !== 'asc';
    
    // Сохраняем состояние сортировки
    this.sortState[columnIndex] = {
      direction: isAscending ? 'asc' : 'desc',
      timestamp: Date.now()
    };
    
    sessionStorage.setItem(`tableSort_${this.table.id}`, JSON.stringify(this.sortState));
    
    this.sortColumn(columnIndex, isAscending);
    this.updateIndicators(columnIndex, isAscending);
  }
  
  sortColumn(columnIndex, isAscending) {
    const tbody = this.table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    
    rows.sort((a, b) => {
      const aValue = a.cells[columnIndex].textContent.trim();
      const bValue = b.cells[columnIndex].textContent.trim();
      
      let comparison = 0;
      const aNum = parseFloat(aValue.replace(/[^\d.-]/g, ''));
      const bNum = parseFloat(bValue.replace(/[^\d.-]/g, ''));
      
      if (!isNaN(aNum) && !isNaN(bNum)) {
        comparison = aNum - bNum;
      } else {
        comparison = aValue.localeCompare(bValue, 'ru-RU');
      }
      
      return isAscending ? comparison : -comparison;
    });
    
    rows.forEach(row => tbody.appendChild(row));
  }
  
  updateIndicators(activeColumn, isAscending) {
    this.headers.forEach(header => {
      header.classList.remove('sort-asc', 'sort-desc');
    });
    
    this.headers[activeColumn].classList.add(isAscending ? 'sort-asc' : 'sort-desc');
  }
  
  applySavedSort() {
    // Находим последнюю сортировку
    let lastSort = null;
    for (const [colIndex, state] of Object.entries(this.sortState)) {
      if (!lastSort || state.timestamp > lastSort.timestamp) {
        lastSort = { colIndex: parseInt(colIndex), state };
      }
    }
    
    if (lastSort) {
      this.sortColumn(lastSort.colIndex, lastSort.state.direction === 'asc');
    }
  }
}

// Инициализация
document.addEventListener('DOMContentLoaded', () => {
  new TableSorter('sortable-table');
});
```

## Серверная сортировка

Для больших таблиц рекомендуется использовать серверную сортировку:

```javascript
async function serverSort(columnIndex, direction) {
  try {
    const response = await fetch(`/api/table-data?sort=${columnIndex}&order=${direction}&page=1`);
    const data = await response.json();
    
    updateTableBody(data.rows);
    updatePagination(data.pagination);
  } catch (error) {
    console.error('Ошибка при сортировке:', error);
  }
}

function updateTableBody(rows) {
  const tbody = document.querySelector('#sortable-table tbody');
  tbody.innerHTML = '';
  
  rows.forEach(rowData => {
    const row = document.createElement('tr');
    rowData.forEach(cellData => {
      const cell = document.createElement('td');
      cell.textContent = cellData;
      row.appendChild(cell);
    });
    tbody.appendChild(row);
  });
}
```

## Практические примеры

### Финансовая таблица с сортировкой

```html
<table id="financial-table">
  <thead>
    <tr>
      <th class="sortable" data-column="0" data-type="string">Наименование</th>
      <th class="sortable" data-column="1" data-type="currency">Доход</th>
      <th class="sortable" data-column="2" data-type="currency">Расход</th>
      <th class="sortable" data-column="3" data-type="currency">Прибыль</th>
      <th class="sortable" data-column="4" data-type="number">Рентабельность (%)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Продукт A</td>
      <td>1 200 000 ₽</td>
      <td>800 000 ₽</td>
      <td>400 000 ₽</td>
      <td>33.3</td>
    </tr>
    <tr>
      <td>Продукт B</td>
      <td>800 000 ₽</td>
      <td>500 000 ₽</td>
      <td>300 000 ₽</td>
      <td>37.5</td>
    </tr>
  </tbody>
</table>
```

```javascript
// Расширенный класс для сортировки финансовых данных
class FinancialTableSorter extends TableSorter {
  sortColumn(columnIndex, isAscending) {
    const tbody = this.table.querySelector('tbody');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    const header = this.headers[columnIndex];
    const dataType = header.getAttribute('data-type') || 'string';
    
    rows.sort((a, b) => {
      const aCell = a.cells[columnIndex];
      const bCell = b.cells[columnIndex];
      const aValue = aCell.textContent.trim();
      const bValue = bCell.textContent.trim();
      
      let comparison = 0;
      
      switch (dataType) {
        case 'currency':
          const aCurrency = parseFloat(aValue.replace(/[^\d.-]/g, ''));
          const bCurrency = parseFloat(bValue.replace(/[^\d.-]/g, ''));
          comparison = aCurrency - bCurrency;
          break;
          
        case 'number':
          const aNum = parseFloat(aValue);
          const bNum = parseFloat(bValue);
          comparison = aNum - bNum;
          break;
          
        case 'string':
        default:
          comparison = aValue.localeCompare(bValue, 'ru-RU');
          break;
      }
      
      return isAscending ? comparison : -comparison;
    });
    
    rows.forEach(row => tbody.appendChild(row));
  }
}
```

### Таблица с фильтрами и сортировкой

```html
<div class="table-controls">
  <input type="text" id="searchInput" placeholder="Поиск...">
  <select id="filterSelect">
    <option value="">Все категории</option>
    <option value="электроника">Электроника</option>
    <option value="одежда">Одежда</option>
  </select>
</div>

<table id="filterable-table">
  <thead>
    <tr>
      <th class="sortable" data-column="0">Название</th>
      <th class="sortable" data-column="1">Категория</th>
      <th class="sortable" data-column="2">Цена</th>
      <th class="sortable" data-column="3">Рейтинг</th>
    </tr>
  </thead>
  <tbody>
    <!-- Данные таблицы -->
  </tbody>
</table>
```

```javascript
class FilterableTable extends FinancialTableSorter {
  constructor(tableId) {
    super(tableId);
    this.searchInput = document.getElementById('searchInput');
    this.filterSelect = document.getElementById('filterSelect');
    this.originalData = this.getOriginalData();
    this.initFilters();
  }
  
  initFilters() {
    this.searchInput.addEventListener('input', () => this.applyFilters());
    this.filterSelect.addEventListener('change', () => this.applyFilters());
  }
  
  getOriginalData() {
    const tbody = this.table.querySelector('tbody');
    return Array.from(tbody.querySelectorAll('tr')).map(row => {
      return Array.from(row.cells).map(cell => cell.textContent);
    });
  }
  
  applyFilters() {
    const searchTerm = this.searchInput.value.toLowerCase();
    const filterValue = this.filterSelect.value;
    
    const filteredData = this.originalData.filter(row => {
      const matchesSearch = row.some(cell => 
        cell.toLowerCase().includes(searchTerm)
      );
      const matchesFilter = !filterValue || 
        row[1].toLowerCase().includes(filterValue); // предполагаем, что категория в колонке 1
      
      return matchesSearch && matchesFilter;
    });
    
    this.updateTableBody(filteredData);
  }
  
  updateTableBody(data) {
    const tbody = this.table.querySelector('tbody');
    tbody.innerHTML = '';
    
    data.forEach(rowData => {
      const row = document.createElement('tr');
      rowData.forEach(cellData => {
        const cell = document.createElement('td');
        cell.textContent = cellData;
        row.appendChild(cell);
      });
      tbody.appendChild(row);
    });
  }
}
```

## Доступность сортировки

### ARIA-атрибуты для сортировки

```html
<th 
  class="sortable" 
  data-column="0" 
  role="columnheader" 
  aria-sort="none"
  tabindex="0"
>
  Имя
</th>
```

```javascript
function updateAriaSort(activeColumn, direction) {
  this.headers.forEach((header, index) => {
    if (index === activeColumn) {
      header.setAttribute('aria-sort', direction === 'asc' ? 'ascending' : 'descending');
    } else {
      header.setAttribute('aria-sort', 'none');
    }
  });
}
```

## Заключение

Сортировка HTML-таблиц в 2025 году требует:
- Поддержки различных типов данных
- Сохранения состояния сортировки
- Обеспечения доступности для пользователей с вспомогательными технологиями
- Оптимизации производительности для больших наборов данных
- Интуитивно понятного интерфейса

Правильная реализация сортировки улучшает пользовательский опыт и делает данные более доступными для анализа.

Для более подробного изучения темы рекомендуется ознакомиться с разделами [[Структура-таблиц]], [[Адаптивные-таблицы]] и [[Доступность-таблиц]].

#html #таблицы #сортировка #javascript #интерактивность #доступность #best-practices