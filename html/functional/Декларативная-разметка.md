---
aliases: ["Декларативный HTML", "Функциональная разметка", "Декларативный подход"]
tags: [html, functional-programming, best-practices, frontend]
---

# Декларативная разметка в функциональном программировании

## Обзор

Декларативная разметка - это подход к созданию HTML, при котором разработчик описывает, **что** должно быть отображено, а не **как** это должно быть реализовано. В контексте функционального программирования декларативный подход позволяет создавать более предсказуемые, легко тестируемые и поддерживаемые компоненты пользовательского интерфейса.

В 2025 году декларативная разметка стала стандартом для современных фронтенд-фреймворков, таких как React, Vue и Svelte, и даже в чистом JavaScript можно применять принципы декларативного подхода к созданию HTML-разметки.

## Основные принципы декларативной разметки

### 1. Описание состояния, а не изменений

В декларативном подходе разработчик описывает желаемое состояние пользовательского интерфейса, а не последовательность действий для его достижения. Это контрастирует с императивным подходом, где разработчик должен явно указать все изменения DOM.

```javascript
// Императивный подход
const container = document.getElementById('container');
const button = document.createElement('button');
button.textContent = 'Нажми меня';
button.addEventListener('click', () => alert('Привет!'));
container.appendChild(button);

// Декларативный подход
function Button({ text, onClick }) {
  return `<button onclick="${onClick}">${text}</button>`;
}

function renderUI() {
  return `
    <div id="container">
      ${Button({ text: 'Нажми меня', onClick: '() => alert("Привет!")' })}
    </div>
  `;
}
```

### 2. Функции для генерации разметки

Использование функций для создания HTML-разметки позволяет создавать повторно используемые компоненты и упрощает тестирование:

```javascript
function Card({ title, content, footer }) {
  return `
    <div class="card">
      <h3 class="card-title">${title}</h3>
      <p class="card-content">${content}</p>
      <footer class="card-footer">${footer}</footer>
    </div>
  `;
}

function UserCard({ user }) {
  return Card({
    title: user.name,
    content: user.description,
    footer: `<a href="/users/${user.id}">Подробнее</a>`
  });
}
```

### 3. Иммутабельность данных

Для поддержания декларативного подхода важно использовать неизменяемые данные. Это позволяет предсказуемо обновлять интерфейс при изменении состояния:

```javascript
const initialState = {
  posts: [
    { id: 1, title: 'Первый пост', content: 'Содержимое первого поста' },
    { id: 2, title: 'Второй пост', content: 'Содержимое второго поста' }
  ]
};

function PostList({ posts }) {
  return `
    <div class="post-list">
      ${posts.map(post => Post(post)).join('')}
    </div>
  `;
}

function Post({ id, title, content }) {
  return `
    <article class="post" data-id="${id}">
      <h2>${title}</h2>
      <p>${content}</p>
    </article>
  `;
}
```

## Практические применения

### Веб-компоненты с декларативной разметкой

Современные веб-компоненты могут использовать декларативный подход для определения своей структуры:

```javascript
class ProductCard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  set product(value) {
    this._product = value;
    this.render();
  }

  get product() {
    return this._product;
  }

  render() {
    if (!this._product) return;
    
    this.shadowRoot.innerHTML = `
      <style>
        .product-card { 
          border: 1px solid #ddd; 
          padding: 1rem; 
          margin: 0.5rem; 
          border-radius: 4px; 
        }
        .product-title { font-weight: bold; }
        .product-price { color: #007bff; }
      </style>
      <div class="product-card">
        <h3 class="product-title">${this._product.title}</h3>
        <p class="product-description">${this._product.description}</p>
        <div class="product-price">${this._product.price} руб.</div>
        <button class="buy-button">Купить</button>
      </div>
    `;
  }
}

customElements.define('product-card', ProductCard);
```

### Использование шаблонов для декларативной разметки

HTML-шаблоны могут использоваться в сочетании с функциональным подходом:

```javascript
function createTemplate(htmlString) {
  const template = document.createElement('template');
  template.innerHTML = htmlString.trim();
  return template;
}

const cardTemplate = createTemplate(`
  <div class="card">
    <header class="card-header">
      <slot name="title"></slot>
    </header>
    <main class="card-body">
      <slot name="content"></slot>
    </main>
    <footer class="card-footer">
      <slot name="footer"></slot>
    </footer>
  </div>
`);

function renderCard(title, content, footer) {
  const clone = cardTemplate.content.cloneNode(true);
  clone.querySelector('[slot="title"]').textContent = title;
  clone.querySelector('[slot="content"]').textContent = content;
  clone.querySelector('[slot="footer"]').textContent = footer;
  return clone;
}
```

## Преимущества декларативной разметки

1. **Предсказуемость** - результат зависит только от входных данных
2. **Тестируемость** - функции легко тестировать изолированно
3. **Повторное использование** - компоненты можно использовать в разных контекстах
4. **Поддерживаемость** - изменения в одном месте влияют на все использование компонента
5. **Читаемость** - код описывает намерения, а не реализацию

## Лучшие практики

### 1. Чистые функции для разметки

Функции генерации разметки должны быть чистыми - они не должны изменять внешнее состояние:

```javascript
// Хорошо: чистая функция
function Button({ text, disabled = false }) {
  return `<button ${disabled ? 'disabled' : ''}>${text}</button>`;
}

// Плохо: функция изменяет внешнее состояние
let buttonCount = 0;
function BadButton({ text }) {
  buttonCount++; // Это изменение внешнего состояния
  return `<button>${text} (${buttonCount})</button>`;
}
```

### 2. Именованные параметры

Использование деструктуризации объекта для передачи параметров делает код более понятным:

```javascript
// Более понятно, какие параметры принимает компонент
function Avatar({ src, alt = 'Аватар', size = 'medium' }) {
  const sizeClass = `avatar-${size}`;
  return `<img class="avatar ${sizeClass}" src="${src}" alt="${alt}">`;
}
```

### 3. Композиция компонентов

Компоненты должны быть легко компонуемыми:

```javascript
function Layout({ header, sidebar, content, footer }) {
  return `
    <div class="layout">
      <header class="layout-header">${header}</header>
      <div class="layout-main">
        <aside class="layout-sidebar">${sidebar}</aside>
        <main class="layout-content">${content}</main>
      </div>
      <footer class="layout-footer">${footer}</footer>
    </div>
  `;
}

function App() {
  const header = Header({ title: 'Мое приложение' });
  const sidebar = Sidebar({ items: navigationItems });
  const content = MainContent({ data: appData });
  const footer = Footer({ copyright: '© 2025 Все права защищены' });
  
  return Layout({ header, sidebar, content, footer });
}
```

## Заключение

Декларативная разметка в сочетании с принципами функционального программирования позволяет создавать более надежные, предсказуемые и легко поддерживаемые пользовательские интерфейсы. В российском IT-ландшафте 2025 года этот подход становится стандартом для разработки современных веб-приложений, особенно в крупных компаниях, где важна поддерживаемость и масштабируемость кодовой базы.

Для успешного внедрения декларативного подхода в проектах рекомендуется:

- Использовать функции для генерации разметки
- Следовать принципам чистых функций
- Применять неизменяемые структуры данных
- Организовывать компоненты в иерархии
- Использовать систему типов для дополнительной проверки

> [!tip] Совет
> При переходе с императивного подхода к декларативному начните с выделения часто используемых частей интерфейса в отдельные функции-компоненты. Это позволит постепенно внедрить декларативный подход без полной переписки существующего кода.

> [!warning] Важно
> Декларативная разметка не исключает необходимости понимания DOM и работы с событиями. Важно сохранять баланс между декларативным подходом и знанием основных механизмов работы браузера.

## См. также

- [[Функции-высшего-порядка-в-HTML]]
- [[Чистые-компоненты]]
- [[Композиция-HTML-компонентов]]
- [[Неизменяемость-в-HTML]]
- [[HTML-шаблоны]]
- [[Веб-компоненты]]