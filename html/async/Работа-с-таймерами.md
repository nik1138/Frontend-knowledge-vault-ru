---
aliases: [Работа с таймерами, timers, setTimeout, setInterval, асинхронные таймеры]
tags: [javascript, html, timers, async, performance, web-development]
---

# Работа с таймерами

## Обзор

Таймеры в JavaScript (setTimeout, setInterval) являются важным инструментом асинхронного программирования, позволяющим откладывать выполнение кода или повторять его через определенные интервалы. В 2025 году знание таймеров особенно важно для создания интерактивных и производительных веб-приложений, соответствующих современным стандартам.

## Основные методы таймеров

### setTimeout

Метод `setTimeout` откладывает выполнение функции на определенное количество миллисекунд:

```javascript
// Простое использование
setTimeout(() => {
    console.log('Этот код выполнится через 2 секунды');
}, 2000);

// С передачей аргументов
setTimeout((message, count) => {
    console.log(`${message}: ${count}`);
}, 1000, 'Привет', 5);
```

### setInterval

Метод `setInterval` повторяет выполнение функции с определенным интервалом:

```javascript
// Повторение каждые 1000 миллисекунд (1 секунда)
const intervalId = setInterval(() => {
    console.log('Этот код выполняется каждую секунду');
}, 1000);

// Остановка интервала
clearInterval(intervalId);
```

### clearTimeout и clearInterval

Для отмены запланированных таймеров используются методы `clearTimeout` и `clearInterval`:

```javascript
// Отмена таймера
const timerId = setTimeout(() => {
    console.log('Этот код не выполнится');
}, 5000);

// Отменяем таймер до его выполнения
clearTimeout(timerId);

// Отмена интервала
const intervalId = setInterval(() => {
    console.log('Повторяющийся код');
}, 1000);

// Через 5 секунд останавливаем интервал
setTimeout(() => {
    clearInterval(intervalId);
    console.log('Интервал остановлен');
}, 5000);
```

## Современные подходы к работе с таймерами

### Promise с таймерами

Создание Promise-оберток для таймеров:

```javascript
// Задержка в виде Promise
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Использование с async/await
async function example() {
    console.log('Начало');
    await delay(2000); // Ждем 2 секунды
    console.log('Прошло 2 секунды');
    await delay(1000); // Ждем еще 1 секунду
    console.log('Прошло 3 секунды всего');
}

example();
```

### Таймер с возможностью отмены

```javascript
class CancelableTimer {
    constructor() {
        this.timeoutId = null;
        this.intervalId = null;
    }
    
    setTimeout(callback, delay) {
        this.clearTimeout();
        this.timeoutId = setTimeout(callback, delay);
        return this.timeoutId;
    }
    
    setInterval(callback, interval) {
        this.clearInterval();
        this.intervalId = setInterval(callback, interval);
        return this.intervalId;
    }
    
    clearTimeout() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }
    
    clearInterval() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }
    
    clearAll() {
        this.clearTimeout();
        this.clearInterval();
    }
}

// Использование
const timer = new CancelableTimer();
timer.setTimeout(() => console.log('Таймер'), 3000);
timer.clearTimeout(); // Отменяем таймер
```

## Практические примеры

### Динамическое обновление интерфейса

```javascript
// Обновление таймера на странице
class ClockDisplay {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.intervalId = null;
        this.isRunning = false;
    }
    
    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.intervalId = setInterval(() => {
            const now = new Date();
            this.element.textContent = now.toLocaleTimeString('ru-RU');
        }, 1000);
    }
    
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
            this.isRunning = false;
        }
    }
}

// Использование
const clock = new ClockDisplay('clock');
clock.start();
```

### Дебаунс и троттлинг

```javascript
// Функция дебаунса
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Функция троттлинга
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Пример использования при вводе текста
const input = document.getElementById('search-input');
const debouncedSearch = debounce((event) => {
    console.log('Поиск:', event.target.value);
    // Выполнение поиска
}, 300);

input.addEventListener('input', debouncedSearch);
```

## Российские особенности и лучшие практики

### Учет часовых поясов

В 2025 году при работе с таймерами в российском сегменте важно учитывать часовые пояса:

```javascript
// Отображение времени с учетом часового пояса пользователя
function formatTimeForRussia(date) {
    return date.toLocaleTimeString('ru-RU', {
        timeZone: 'Europe/Moscow',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

// Таймер с отображением московского времени
function startMoscowClock(elementId) {
    const element = document.getElementById(elementId);
    
    const updateClock = () => {
        const now = new Date();
        element.textContent = formatTimeForRussia(now);
    };
    
    updateClock(); // Обновляем сразу
    return setInterval(updateClock, 1000);
}
```

### Оптимизация для слабых устройств

```javascript
// Адаптивный таймер для слабых устройств
class AdaptiveTimer {
    constructor() {
        this.isLowEndDevice = this.checkLowEndDevice();
        this.baseInterval = this.isLowEndDevice ? 2000 : 1000;
    }
    
    checkLowEndDevice() {
        // Проверяем характеристики устройства
        const connection = navigator.connection;
        if (connection && (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g')) {
            return true;
        }
        
        // Дополнительные проверки
        return window.navigator.hardwareConcurrency < 4 || 
               window.deviceMemory < 4;
    }
    
    setInterval(callback, interval = this.baseInterval) {
        return setInterval(callback, this.isLowEndDevice ? interval * 2 : interval);
    }
}
```

## Современные альтернативы таймерам

### requestAnimationFrame

Для анимаций рекомендуется использовать `requestAnimationFrame` вместо `setTimeout`:

```javascript
// Анимация с requestAnimationFrame
function animateElement(element, targetPosition) {
    const startPosition = parseInt(getComputedStyle(element).left);
    const distance = targetPosition - startPosition;
    let startTime = null;
    
    function animation(currentTime) {
        if (!startTime) startTime = currentTime;
        const elapsed = currentTime - startTime;
        const duration = 1000; // 1 секунда
        
        const progress = Math.min(elapsed / duration, 1);
        const currentPosition = startPosition + distance * progress;
        
        element.style.left = currentPosition + 'px';
        
        if (progress < 1) {
            requestAnimationFrame(animation);
        }
    }
    
    requestAnimationFrame(animation);
}
```

### Web Workers для тяжелых задач

```javascript
// Использование Web Workers для тяжелых вычислений с таймером
function heavyComputationWithWorker() {
    const worker = new Worker('worker.js');
    
    worker.postMessage({ type: 'start', interval: 1000 });
    
    worker.onmessage = function(e) {
        if (e.data.type === 'update') {
            console.log('Обновление от воркера:', e.data.value);
        }
    };
    
    // Останавливаем через 10 секунд
    setTimeout(() => {
        worker.postMessage({ type: 'stop' });
        worker.terminate();
    }, 10000);
}
```

## Практические рекомендации

### Управление таймерами в компонентах

```javascript
// Компонент с автоматической очисткой таймеров
class ComponentWithTimers {
    constructor() {
        this.timers = new Set();
    }
    
    setTimeout(callback, delay) {
        const id = setTimeout(() => {
            callback();
            this.timers.delete(id);
        }, delay);
        
        this.timers.add(id);
        return id;
    }
    
    setInterval(callback, interval) {
        const id = setInterval(callback, interval);
        this.timers.add(id);
        return id;
    }
    
    destroy() {
        // Очищаем все таймеры при уничтожении компонента
        for (const timerId of this.timers) {
            clearTimeout(timerId);
            clearInterval(timerId);
        }
        this.timers.clear();
    }
}
```

> [!warning] Важно
> Всегда очищайте таймеры при уничтожении компонентов или переходе между страницами, чтобы избежать утечек памяти.

## Связанные темы

- [[Асинхронные-скрипты]]
- [[HTML-шаблоны-и-микрозадачи]]
- [[Promise-в-HTML-API]]
- [[Обработка-ошибок]]

## Источники

- [MDN Web Docs: Timers](https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
- [MDN Web Docs: requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame)
- [Google Developers: Debounce Your Input Handlers](https://developers.google.com/web/updates/2017/01/scrolling-intervention)