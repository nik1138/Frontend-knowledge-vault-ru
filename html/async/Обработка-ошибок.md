---
aliases: [Обработка ошибок, error handling, async errors, асинхронные ошибки]
tags: [javascript, html, error-handling, async, debugging, web-development]
---

# Обработка ошибок

## Обзор

Обработка ошибок в асинхронном программировании является критически важной частью разработки стабильных и надежных веб-приложений. В 2025 году, с ростом сложности веб-приложений и увеличением требований к надежности, правильная обработка асинхронных ошибок становится особенно важной для российских разработчиков.

## Типы асинхронных ошибок

### Ошибки в Promise

Асинхронные ошибки могут возникать в различных сценариях:

```javascript
// Ошибка в Promise
async function exampleWithError() {
    try {
        const response = await fetch('/api/data');
        if (!response.ok) {
            throw new Error(`HTTP ошибка! Статус: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Ошибка при получении данных:', error.message);
        // Обработка ошибки
        return null;
    }
}
```

### Необработанные ошибки Promise

Для перехвата необработанных ошибок Promise используются специальные события:

```javascript
// Перехват необработанных ошибок Promise
window.addEventListener('unhandledrejection', event => {
    console.error('Необработанная ошибка Promise:', event.reason);
    
    // Отправка ошибки в систему мониторинга
    sendErrorToMonitoring(event.reason);
    
    // Предотвращение стандартного поведения (вывода в консоль)
    event.preventDefault();
});

// Обработка ошибок в цепочке Promise
async function handleChainedPromises() {
    try {
        const data = await fetch('/api/users')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка сети');
                }
                return response.json();
            })
            .then(users => {
                if (!users || users.length === 0) {
                    throw new Error('Пользователи не найдены');
                }
                return users;
            });
        
        return data;
    } catch (error) {
        console.error('Ошибка в цепочке Promise:', error.message);
        throw error; // Передаем ошибку дальше
    }
}
```

## Современные подходы к обработке ошибок

### Централизованная обработка ошибок

```javascript
// Класс для централизованной обработки ошибок
class ErrorHandler {
    constructor() {
        this.errorHandlers = [];
        this.setupGlobalHandlers();
    }
    
    setupGlobalHandlers() {
        // Обработчик необработанных ошибок Promise
        window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
        
        // Обработчик ошибок JavaScript
        window.addEventListener('error', this.handleError.bind(this));
    }
    
    handleUnhandledRejection(event) {
        this.handleError({
            error: event.reason,
            message: event.reason?.message || 'Необработанная ошибка Promise',
            filename: event.reason?.stack || 'unknown',
            lineno: 0,
            colno: 0
        });
        
        event.preventDefault();
    }
    
    handleError(event) {
        const errorInfo = {
            message: event.message || event.error?.message,
            stack: event.error?.stack || event.reason?.stack,
            filename: event.filename || 'unknown',
            lineno: event.lineno || 0,
            colno: event.colno || 0,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent
        };
        
        // Вызов всех зарегистрированных обработчиков
        for (const handler of this.errorHandlers) {
            handler(errorInfo);
        }
    }
    
    addHandler(handler) {
        this.errorHandlers.push(handler);
    }
    
    removeHandler(handler) {
        const index = this.errorHandlers.indexOf(handler);
        if (index > -1) {
            this.errorHandlers.splice(index, 1);
        }
    }
}

// Использование
const errorHandler = new ErrorHandler();

// Добавляем обработчик для отправки ошибок в систему мониторинга
errorHandler.addHandler(errorInfo => {
    // Отправляем ошибку в систему мониторинга
    sendErrorToMonitoring(errorInfo);
});

// Добавляем обработчик для отображения пользователю
errorHandler.addHandler(errorInfo => {
    // Показываем пользователю сообщение об ошибке
    showUserError(errorInfo.message);
});
```

### Обработка ошибок с логированием

```javascript
// Класс для логирования ошибок
class ErrorLogger {
    constructor() {
        this.logs = [];
        this.maxLogs = 100;
    }
    
    log(error, context = {}) {
        const errorLog = {
            timestamp: new Date().toISOString(),
            error: {
                message: error.message,
                stack: error.stack,
                name: error.name
            },
            context,
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        
        this.logs.push(errorLog);
        
        // Ограничиваем количество логов
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }
        
        // Отправляем лог на сервер (асинхронно)
        this.sendLogToServer(errorLog);
    }
    
    async sendLogToServer(log) {
        try {
            await fetch('/api/error-logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(log)
            });
        } catch (sendError) {
            console.error('Ошибка при отправке лога:', sendError);
        }
    }
    
    getLogs() {
        return [...this.logs]; // Возвращаем копию массива
    }
    
    clearLogs() {
        this.logs = [];
    }
}

// Использование
const errorLogger = new ErrorLogger();

async function safeApiCall(url, options = {}) {
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ошибка ${response.status}: ${response.statusText}`);
        }
        
        return await response.json();
    } catch (error) {
        errorLogger.log(error, { url, options });
        throw error;
    }
}
```

## Российские особенности обработки ошибок

### Локализация сообщений об ошибках

В 2025 году важно учитывать российские реалии при обработке ошибок:

```javascript
// Класс для локализации ошибок
class LocalizedError {
    constructor() {
        this.errorMessages = {
            'ru': {
                'NETWORK_ERROR': 'Ошибка сети. Проверьте подключение к интернету.',
                'TIMEOUT_ERROR': 'Время ожидания запроса истекло.',
                'PARSE_ERROR': 'Ошибка обработки данных.',
                'VALIDATION_ERROR': 'Некорректные данные.',
                'AUTH_ERROR': 'Ошибка аутентификации. Пожалуйста, войдите снова.'
            },
            'en': {
                'NETWORK_ERROR': 'Network error. Please check your internet connection.',
                'TIMEOUT_ERROR': 'Request timeout.',
                'PARSE_ERROR': 'Data parsing error.',
                'VALIDATION_ERROR': 'Invalid data.',
                'AUTH_ERROR': 'Authentication error. Please log in again.'
            }
        };
        
        this.currentLocale = this.detectLocale();
    }
    
    detectLocale() {
        // Определяем локаль пользователя
        return navigator.language.startsWith('ru') ? 'ru' : 'en';
    }
    
    getLocalizedMessage(errorCode, customMessage = null) {
        const messages = this.errorMessages[this.currentLocale];
        return customMessage || messages[errorCode] || 'Неизвестная ошибка';
    }
    
    createLocalizedError(errorCode, customMessage = null) {
        const message = this.getLocalizedMessage(errorCode, customMessage);
        const error = new Error(message);
        error.code = errorCode;
        error.localizedMessage = message;
        return error;
    }
}

// Использование
const localizedError = new LocalizedError();

async function fetchWithLocalizedError(url) {
    try {
        const response = await fetch(url, { timeout: 10000 });
        
        if (!response.ok) {
            throw localizedError.createLocalizedError('NETWORK_ERROR');
        }
        
        return await response.json();
    } catch (error) {
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            throw localizedError.createLocalizedError('NETWORK_ERROR');
        }
        
        if (error.name === 'AbortError') {
            throw localizedError.createLocalizedError('TIMEOUT_ERROR');
        }
        
        throw error;
    }
}
```

### Работа с отечественными API

```javascript
// Обработка ошибок при работе с отечественными API
class DomesticApiErrorHandler {
    constructor() {
        this.retryAttempts = 3;
        this.retryDelay = 1000;
    }
    
    async fetchWithRetry(url, options = {}, attempts = this.retryAttempts) {
        try {
            // Устанавливаем таймаут для запроса
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            if (attempts > 1 && this.isRetryableError(error)) {
                console.warn(`Повторная попытка запроса (${this.retryAttempts - attempts + 1}/${this.retryAttempts})`);
                
                await this.delay(this.retryDelay);
                return this.fetchWithRetry(url, options, attempts - 1);
            }
            
            throw error;
        }
    }
    
    isRetryableError(error) {
        // Определяем, можно ли повторить запрос
        return error.name === 'TypeError' || // Ошибки сети
               error.message.includes('Failed to fetch') ||
               error.message.includes('NetworkError') ||
               error.name === 'AbortError'; // Ошибки таймаута
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

## Практические рекомендации

### Обработка ошибок в асинхронных компонентах

```javascript
// Компонент с обработкой ошибок
class AsyncComponent {
    constructor() {
        this.state = {
            loading: false,
            error: null,
            data: null
        };
        this.errorHandler = new ErrorHandler();
    }
    
    async loadData(url) {
        this.updateState({ loading: true, error: null });
        
        try {
            const data = await fetch(url).then(res => res.json());
            this.updateState({ loading: false, data });
        } catch (error) {
            this.updateState({ 
                loading: false, 
                error: this.formatError(error) 
            });
            
            // Логируем ошибку
            this.errorHandler.handleError({
                error,
                message: error.message,
                context: { component: this.constructor.name, url }
            });
        }
    }
    
    updateState(newState) {
        this.state = { ...this.state, ...newState };
        this.render();
    }
    
    formatError(error) {
        // Форматируем ошибку для отображения пользователю
        if (error.name === 'TypeError') {
            return 'Ошибка подключения к серверу';
        }
        
        if (error.message.includes('404')) {
            return 'Данные не найдены';
        }
        
        return error.message || 'Произошла ошибка';
    }
    
    render() {
        // Логика рендеринга компонента
        console.log('Состояние компонента:', this.state);
    }
}
```

### Структурированная обработка ошибок

```javascript
// Класс для структурированной обработки ошибок
class StructuredErrorHandler {
    constructor() {
        this.errorCategories = {
            network: ['TypeError', 'NetworkError', 'AbortError'],
            validation: ['ValidationError', 'SyntaxError'],
            server: ['ServerError', '5xx'],
            client: ['4xx', 'ReferenceError', 'TypeError']
        };
    }
    
    categorizeError(error) {
        const errorName = error.name || 'UnknownError';
        const statusCode = error.status || error.statusCode;
        
        for (const [category, patterns] of Object.entries(this.errorCategories)) {
            if (patterns.some(pattern => 
                errorName.includes(pattern) || 
                (statusCode && pattern.includes(statusCode.toString().charAt(0) + 'xx'))
            )) {
                return category;
            }
        }
        
        return 'unknown';
    }
    
    async handle(error, context = {}) {
        const category = this.categorizeError(error);
        
        switch (category) {
            case 'network':
                return this.handleNetworkError(error, context);
            case 'validation':
                return this.handleValidationError(error, context);
            case 'server':
                return this.handleServerError(error, context);
            case 'client':
                return this.handleClientError(error, context);
            default:
                return this.handleUnknownError(error, context);
        }
    }
    
    async handleNetworkError(error, context) {
        console.error('Сетевая ошибка:', error);
        
        // Попытка повторного подключения
        if (context.retriable !== false) {
            return this.retryOperation(context.operation, context);
        }
        
        return { success: false, error: 'network_error' };
    }
    
    async retryOperation(operation, context, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                return await operation();
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                
                // Задержка перед повторной попыткой
                await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
            }
        }
    }
    
    async handleValidationError(error, context) {
        console.error('Ошибка валидации:', error);
        return { success: false, error: 'validation_error', details: error.details };
    }
    
    async handleServerError(error, context) {
        console.error('Ошибка сервера:', error);
        return { success: false, error: 'server_error' };
    }
    
    async handleClientError(error, context) {
        console.error('Ошибка клиента:', error);
        return { success: false, error: 'client_error' };
    }
    
    async handleUnknownError(error, context) {
        console.error('Неизвестная ошибка:', error);
        return { success: false, error: 'unknown_error' };
    }
}
```

> [!tip] Совет
> Используйте централизованную систему обработки ошибок с логированием и мониторингом для быстрого выявления и устранения проблем в продакшене.

## Связанные темы

- [[Асинхронные-скрипты]]
- [[HTML-шаблоны-и-микрозадачи]]
- [[Promise-в-HTML-API]]
- [[Работа-с-таймерами]]

## Источники

- [MDN Web Docs: Error Handling](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Control_flow_and_error_handling)
- [MDN Web Docs: Promise Rejection Events](https://developer.mozilla.org/ru/docs/Web/API/Window/unhandledrejection_event)
- [Google Developers: Error Reporting](https://developers.google.com/web/tools/chrome-devtools/console/api#console.error)