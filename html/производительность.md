---
aliases: [performance, HTML Производительность]
---

# HTML Производительность

Производительность веб-страницы - это критический фактор для пользовательского опыта, SEO и общего успеха веб-сайта. Оптимизация производительности HTML включает в себя улучшение скорости загрузки, уменьшение времени до интерактивности и повышение общей плавности взаимодействия.

## Основы производительности HTML

### Структура документа и производительность

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Оптимизированная HTML структура</title>

    <!-- Оптимизированный порядок подключения ресурсов -->
    <link rel="preload" href="critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="critical.css"></noscript>

    <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>

    <!-- Критические стили встроены -->
    <style>
        /* Критические стили для верхней части страницы */
        body { font-family: system-ui, -apple-system, sans-serif; margin: 0; }
        .header { background: #007acc; color: white; padding: 1rem; }
        .main-content { min-height: 50vh; }
        .footer { background: #f8f9fa; padding: 1rem; }
    </style>

    <!-- Предзагрузка критических ресурсов -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="//api.example.com">

    <!-- Оптимизированный favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
</head>
<body>
    <!-- Семантическая структура -->
    <header class="header">
        <h1>Оптимизированный сайт</h1>
        <nav>
            <ul>
                <li><a href="/">Главная</a></li>
                <li><a href="/about">О нас</a></li>
                <li><a href="/contact">Контакты</a></li>
            </ul>
        </nav>
    </header>

    <main class="main-content">
        <article>
            <h2>Заголовок статьи</h2>
            <p>Содержимое статьи...</p>
        </article>
    </main>

    <footer class="footer">
        <p>&copy; 2023 Все права защищены</p>
    </footer>

    <!-- Скрипты подключаются в конце body -->
    <script src="app.js" defer></script>
</body>
</html>
```

## Оптимизация загрузки ресурсов

### Lazy Loading

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Ленивая загрузка</title>
</head>
<body>
    <h1>Ленивая загрузка ресурсов</h1>

    <!-- Ленивая загрузка изображений -->
    <img src="placeholder.jpg"
         data-src="actual-image.jpg"
         alt="Изображение"
         class="lazy-load"
         loading="lazy">

    <!-- Ленивая загрузка iframe -->
    <iframe src="video.html"
            loading="lazy"
            width="560"
            height="315">
    </iframe>

    <!-- Ленивая загрузка изображений с Intersection Observer -->
    <img src="placeholder.jpg"
         data-src="image1.jpg"
         alt="Изображение 1"
         class="lazy-image">

    <img src="placeholder.jpg"
         data-src="image2.jpg"
         alt="Изображение 2"
         class="lazy-image">

    <img src="placeholder.jpg"
         data-src="image3.jpg"
         alt="Изображение 3"
         class="lazy-image">

    <script>
        // Реализация ленивой загрузки с Intersection Observer
        class LazyLoader {
            constructor() {
                this.images = document.querySelectorAll('img[data-src]');
                this.setupObserver();
            }

            setupObserver() {
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.loadImage(entry.target);
                            this.observer.unobserve(entry.target);
                        }
                    });
                }, {
                    rootMargin: '50px' // Начинать загрузку за 50px до появления
                });

                this.images.forEach(img => this.observer.observe(img));
            }

            loadImage(img) {
                img.src = img.dataset.src;
                img.classList.remove('lazy-image');
                img.classList.add('loaded');

                // Удаляем data-src атрибут
                img.removeAttribute('data-src');
            }
        }

        // Инициализация при загрузке DOM
        document.addEventListener('DOMContentLoaded', () => {
            new LazyLoader();
        });
    </script>

    <style>
        .lazy-image {
            opacity: 0;
            transition: opacity 0.3s;
        }

        .loaded {
            opacity: 1;
        }

        /* Плейсхолдер для изображений */
        .lazy-image:not(.loaded) {
            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);
        }
    </style>
</body>
</html>
```

### Resource Hints

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Resource Hints</title>

    <!-- Preload критических ресурсов -->
    <link rel="preload" href="critical.css" as="style">
    <link rel="preload" href="hero-image.jpg" as="image">
    <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="main.js" as="script">

    <!-- Prefetch потенциально нужных ресурсов -->
    <link rel="prefetch" href="next-page.html">
    <link rel="prefetch" href="secondary-font.woff2">

    <!-- Preconnect для внешних доменов -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://api.example.com">

    <!-- DNS Prefetch -->
    <link rel="dns-prefetch" href="//analytics.google.com">
    <link rel="dns-prefetch" href="//cdn.example.com">

    <!-- Prerender следующей страницы (если уверены, что пользователь перейдет) -->
    <!-- <link rel="prerender" href="next-page.html"> -->

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Содержимое страницы -->
</body>
</html>
```

## Оптимизация DOM и рендеринга

### Эффективная работа с DOM

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Оптимизация DOM</title>
</head>
<body>
    <h1>Оптимизация DOM</h1>

    <div id="list-container"></div>

    <button id="add-items">Добавить 1000 элементов</button>
    <button id="clear-list">Очистить список</button>

    <script>
        class DOMOptimizer {
            constructor() {
                this.container = document.getElementById('list-container');
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('add-items').addEventListener('click', () => {
                    this.addItemsOptimized(1000);
                });

                document.getElementById('clear-list').addEventListener('click', () => {
                    this.clearList();
                });
            }

            // Плохо: множественные изменения DOM
            addItemsInefficient(count) {
                for (let i = 0; i < count; i++) {
                    const item = document.createElement('div');
                    item.textContent = `Элемент ${i + 1}`;
                    this.container.appendChild(item);
                }
            }

            // Хорошо: использование DocumentFragment
            addItemsOptimized(count) {
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < count; i++) {
                    const item = document.createElement('div');
                    item.textContent = `Элемент ${i + 1}`;
                    item.className = 'list-item';
                    fragment.appendChild(item);
                }

                this.container.appendChild(fragment);
            }

            // Хорошо: использование innerHTML для больших изменений
            addItemsWithInnerHTML(count) {
                let html = '';
                for (let i = 0; i < count; i++) {
                    html += `<div class="list-item">Элемент ${i + 1}</div>`;
                }
                this.container.innerHTML = html;
            }

            clearList() {
                this.container.innerHTML = '';
            }

            // Оптимизация стилей
            applyStylesOptimized() {
                // Группировка изменений стилей
                const container = this.container;

                // Сначала считываем все стили
                const computedStyle = window.getComputedStyle(container);
                const currentWidth = computedStyle.width;

                // Затем вносим все изменения
                container.style.cssText = `
                    width: 100%;
                    height: 500px;
                    background-color: #f0f0f0;
                    border: 1px solid #ccc;
                `;
            }

            // Использование CSS классов вместо inline стилей
            toggleTheme() {
                document.body.classList.toggle('dark-theme');
            }

            // Оптимизация перерисовки
            batchUpdates() {
                // Используем requestAnimationFrame для группировки изменений
                requestAnimationFrame(() => {
                    // Все изменения DOM в одном цикле обновления
                    this.updateElement1();
                    this.updateElement2();
                    this.updateElement3();
                });
            }

            updateElement1() { /* Обновление элемента 1 */ }
            updateElement2() { /* Обновление элемента 2 */ }
            updateElement3() { /* Обновление элемента 3 */ }
        }

        // Инициализация
        const domOptimizer = new DOMOptimizer();
    </script>

    <style>
        .list-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .list-item:nth-child(even) {
            background-color: #f9f9f9;
        }

        .dark-theme {
            background-color: #333;
            color: white;
        }
    </style>
</body>
</html>
```

### Virtual Scrolling

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Virtual Scrolling</title>
    <style>
        .virtual-list {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ccc;
            position: relative;
        }

        .list-container {
            position: relative;
        }

        .list-item {
            height: 50px;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .list-item:nth-child(even) {
            background-color: #f9f9f9;
        }

        .spacer {
            height: 1px;
        }
    </style>
</head>
<body>
    <h1>Виртуальный скроллинг</h1>

    <div class="virtual-list" id="virtual-list">
        <div class="list-container" id="list-container">
            <!-- Элементы будут добавляться сюда -->
        </div>
    </div>

    <script>
        class VirtualScroller {
            constructor(containerId, itemHeight = 50) {
                this.container = document.getElementById(containerId);
                this.itemHeight = itemHeight;
                this.visibleItems = Math.ceil(this.container.clientHeight / this.itemHeight) + 2;
                this.data = this.generateData(10000); // 10k элементов
                this.startIndex = 0;
                this.endIndex = this.visibleItems;

                this.setupEventListeners();
                this.render();
            }

            generateData(count) {
                return Array.from({ length: count }, (_, i) => ({
                    id: i,
                    text: `Элемент ${i + 1}`
                }));
            }

            setupEventListeners() {
                this.container.addEventListener('scroll', this.throttle(() => {
                    this.updateVisibleItems();
                }, 16)); // ~60fps
            }

            updateVisibleItems() {
                const scrollTop = this.container.scrollTop;
                const start = Math.floor(scrollTop / this.itemHeight);
                const end = start + this.visibleItems;

                if (start !== this.startIndex || end !== this.endIndex) {
                    this.startIndex = start;
                    this.endIndex = end;
                    this.render();
                }
            }

            render() {
                const container = document.getElementById('list-container');

                // Очистка контейнера
                container.innerHTML = '';

                // Добавление верхнего спейсера
                const topSpacer = document.createElement('div');
                topSpacer.style.height = `${this.startIndex * this.itemHeight}px`;
                topSpacer.className = 'spacer';
                container.appendChild(topSpacer);

                // Добавление видимых элементов
                for (let i = this.startIndex; i < Math.min(this.endIndex, this.data.length); i++) {
                    const item = document.createElement('div');
                    item.className = 'list-item';
                    item.textContent = this.data[i].text;
                    container.appendChild(item);
                }

                // Добавление нижнего спейсера
                const bottomHeight = (this.data.length - this.endIndex) * this.itemHeight;
                if (bottomHeight > 0) {
                    const bottomSpacer = document.createElement('div');
                    bottomSpacer.style.height = `${bottomHeight}px`;
                    bottomSpacer.className = 'spacer';
                    container.appendChild(bottomSpacer);
                }
            }

            throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        }

        // Инициализация виртуального скроллера
        const virtualScroller = new VirtualScroller('virtual-list');
    </script>
</body>
</html>
```

## Оптимизация форм

### Эффективные формы

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Оптимизация форм</title>
</head>
<body>
    <h1>Оптимизированные формы</h1>

    <form id="optimized-form">
        <div class="form-group">
            <label for="name">Имя:</label>
            <input type="text"
                   id="name"
                   name="name"
                   required
                   autocomplete="name"
                   inputmode="text">
        </div>

        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email"
                   id="email"
                   name="email"
                   required
                   autocomplete="email"
                   inputmode="email">
        </div>

        <div class="form-group">
            <label for="phone">Телефон:</label>
            <input type="tel"
                   id="phone"
                   name="phone"
                   autocomplete="tel"
                   inputmode="tel">
        </div>

        <div class="form-group">
            <label for="message">Сообщение:</label>
            <textarea id="message"
                      name="message"
                      rows="4"
                      inputmode="text"></textarea>
        </div>

        <button type="submit">Отправить</button>
    </form>

    <script>
        class OptimizedForm {
            constructor(formId) {
                this.form = document.getElementById(formId);
                this.setupOptimization();
            }

            setupOptimization() {
                // Оптимизация валидации
                this.debounceValidation();

                // Оптимизация отправки
                this.form.addEventListener('submit', this.debounce((e) => {
                    this.handleSubmit(e);
                }, 500));
            }

            debounceValidation() {
                // Дебаунс для валидации при вводе
                const inputs = this.form.querySelectorAll('input, textarea');

                inputs.forEach(input => {
                    let timeout;

                    input.addEventListener('input', (e) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            this.validateField(e.target);
                        }, 300);
                    });
                });
            }

            validateField(field) {
                // Оптимизированная валидация
                if (field.hasAttribute('required') && !field.value.trim()) {
                    this.showFieldError(field, 'Поле обязательно для заполнения');
                    return false;
                }

                if (field.type === 'email' && field.value && !this.isValidEmail(field.value)) {
                    this.showFieldError(field, 'Введите действительный email');
                    return false;
                }

                this.clearFieldError(field);
                return true;
            }

            isValidEmail(email) {
                const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return re.test(email);
            }

            showFieldError(field, message) {
                field.classList.add('error');
                field.setAttribute('aria-invalid', 'true');

                // Создаем элемент сообщения об ошибке
                let errorElement = field.parentNode.querySelector('.error-message');
                if (!errorElement) {
                    errorElement = document.createElement('div');
                    errorElement.className = 'error-message';
                    errorElement.setAttribute('role', 'alert');
                    field.parentNode.appendChild(errorElement);
                }

                errorElement.textContent = message;
            }

            clearFieldError(field) {
                field.classList.remove('error');
                field.setAttribute('aria-invalid', 'false');

                const errorElement = field.parentNode.querySelector('.error-message');
                if (errorElement) {
                    errorElement.remove();
                }
            }

            async handleSubmit(event) {
                event.preventDefault();

                // Оптимизированная проверка формы
                const inputs = this.form.querySelectorAll('input[required], textarea[required]');
                let isValid = true;

                for (const input of inputs) {
                    if (!this.validateField(input)) {
                        isValid = false;
                    }
                }

                if (isValid) {
                    await this.submitForm();
                }
            }

            async submitForm() {
                const submitBtn = this.form.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;

                // Показываем состояние загрузки
                submitBtn.textContent = 'Отправка...';
                submitBtn.disabled = true;

                try {
                    const formData = new FormData(this.form);

                    // Оптимизированная отправка
                    const response = await fetch('/submit', {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });

                    if (response.ok) {
                        alert('Форма успешно отправлена!');
                        this.form.reset();
                    } else {
                        throw new Error('Ошибка при отправке формы');
                    }
                } catch (error) {
                    alert('Ошибка: ' + error.message);
                } finally {
                    // Восстанавливаем кнопку
                    submitBtn.textContent = originalText;
                    submitBtn.disabled = false;
                }
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new OptimizedForm('optimized-form');
        });
    </script>

    <style>
        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: bold;
        }

        input, textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
        }

        input.error {
            border-color: #dc3545;
            background-color: #fff5f5;
        }

        .error-message {
            color: #dc3545;
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>
</body>
</html>
```

## Кеширование и оптимизация загрузки

### Service Worker для кеширования

```javascript
// sw.js - Service Worker для кеширования
const CACHE_NAME = 'html-performance-v1';
const urlsToCache = [
    '/',
    '/styles/main.css',
    '/scripts/app.js',
    '/images/logo.png',
    '/offline.html'
];

self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log('Кеширование файлов');
                return cache.addAll(urlsToCache);
            })
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // Возврат кешированного ответа или выполнение запроса
                return response || fetch(event.request);
            })
    );
});

self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
});
```

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Кеширование с Service Worker</title>
</head>
<body>
    <h1>Оптимизация с Service Worker</h1>

    <div id="content">
        <p>Содержимое страницы</p>
    </div>

    <button id="update-content">Обновить содержимое</button>

    <script>
        // Регистрация Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('Service Worker зарегистрирован:', registration.scope);
                })
                .catch(error => {
                    console.log('Ошибка регистрации Service Worker:', error);
                });
        }

        // Оптимизация загрузки контента
        class ContentLoader {
            constructor() {
                this.contentDiv = document.getElementById('content');
            }

            async loadContent(url) {
                try {
                    // Попытка загрузки с кешированием
                    const response = await fetch(url, {
                        cache: 'force-cache' // Используем кеш если доступен
                    });

                    if (response.ok) {
                        const content = await response.text();
                        this.contentDiv.innerHTML = content;
                    }
                } catch (error) {
                    console.error('Ошибка загрузки содержимого:', error);
                    this.contentDiv.innerHTML = '<p>Ошибка загрузки содержимого</p>';
                }
            }
        }

        document.getElementById('update-content').addEventListener('click', async () => {
            const loader = new ContentLoader();
            await loader.loadContent('/api/content');
        });
    </script>
</body>
</html>
```

### Кеширование данных с IndexedDB

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Кеширование с IndexedDB</title>
</head>
<body>
    <h1>Кеширование данных с IndexedDB</h1>

    <div id="data-container">
        <p>Данные будут загружены сюда</p>
    </div>

    <button id="load-data">Загрузить данные</button>
    <button id="clear-cache">Очистить кеш</button>

    <script>
        class DataCache {
            constructor(dbName = 'PerformanceCache', version = 1) {
                this.dbName = dbName;
                this.version = version;
                this.db = null;

                this.initDB();
            }

            initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = (event) => {
                        console.error('Ошибка открытия базы данных:', event.target.error);
                        reject(event.target.error);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log('База данных открыта');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        this.db = event.target.result;

                        if (!this.db.objectStoreNames.contains('cachedData')) {
                            const store = this.db.createObjectStore('cachedData', { keyPath: 'key' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            async set(key, data, ttl = 3600000) { // 1 час по умолчанию
                if (!this.db) await this.initDB();

                const transaction = this.db.transaction(['cachedData'], 'readwrite');
                const store = transaction.objectStore('cachedData');

                const record = {
                    key: key,
                    data: data,
                    timestamp: Date.now(),
                    ttl: ttl
                };

                return new Promise((resolve, reject) => {
                    const request = store.put(record);

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async get(key) {
                if (!this.db) await this.initDB();

                const transaction = this.db.transaction(['cachedData'], 'readonly');
                const store = transaction.objectStore('cachedData');
                const request = store.get(key);

                return new Promise((resolve, reject) => {
                    request.onsuccess = (event) => {
                        const record = event.target.result;

                        if (record && (Date.now() - record.timestamp) < record.ttl) {
                            resolve(record.data);
                        } else {
                            resolve(null); // Кеш просрочен или не найден
                        }
                    };

                    request.onerror = (event) => {
                        reject(event.target.error);
                    };
                });
            }

            async delete(key) {
                if (!this.db) await this.initDB();

                const transaction = this.db.transaction(['cachedData'], 'readwrite');
                const store = transaction.objectStore('cachedData');
                const request = store.delete(key);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async clear() {
                if (!this.db) await this.initDB();

                const transaction = this.db.transaction(['cachedData'], 'readwrite');
                const store = transaction.objectStore('cachedData');
                const request = store.clear();

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
        }

        class DataManager {
            constructor() {
                this.cache = new DataCache();
                this.dataContainer = document.getElementById('data-container');
            }

            async loadData() {
                // Сначала пытаемся получить из кеша
                let data = await this.cache.get('api-data');

                if (data) {
                    console.log('Данные загружены из кеша');
                    this.displayData(data);
                    return;
                }

                // Если нет в кеше, загружаем с сервера
                try {
                    console.log('Загрузка данных с сервера...');
                    const response = await fetch('/api/data');
                    data = await response.json();

                    // Сохраняем в кеш
                    await this.cache.set('api-data', data, 5 * 60 * 1000); // 5 минут

                    this.displayData(data);
                } catch (error) {
                    console.error('Ошибка загрузки данных:', error);
                    this.dataContainer.innerHTML = '<p>Ошибка загрузки данных</p>';
                }
            }

            displayData(data) {
                this.dataContainer.innerHTML = `
                    <h2>Загруженные данные</h2>
                    <pre>${JSON.stringify(data, null, 2)}</pre>
                `;
            }
        }

        // Инициализация
        const dataManager = new DataManager();

        document.getElementById('load-data').addEventListener('click', () => {
            dataManager.loadData();
        });

        document.getElementById('clear-cache').addEventListener('click', async () => {
            await dataManager.cache.clear();
            alert('Кеш очищен');
        });
    </script>
</body>
</html>
```

## Оптимизация изображений

### Современные форматы и техники

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Оптимизация изображений</title>
</head>
<body>
    <h1>Оптимизация изображений</h1>

    <!-- Использование современных форматов -->
    <picture>
        <source srcset="image.avif" type="image/avif">
        <source srcset="image.webp" type="image/webp">
        <source srcset="image.jpg" type="image/jpeg">
        <img src="image.jpg"
             alt="Описание изображения"
             loading="lazy"
             width="800"
             height="600">
    </picture>

    <!-- Responsive images -->
    <picture>
        <source media="(max-width: 768px)" srcset="mobile.jpg">
        <source media="(max-width: 1024px)" srcset="tablet.jpg">
        <img src="desktop.jpg"
             alt="Адаптивное изображение"
             sizes="(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw"
             loading="lazy">
    </picture>

    <!-- Изображения с низким качеством для предварительного просмотра -->
    <div class="image-container">
        <img class="preview-image"
             src="low-quality.jpg"
             data-src="high-quality.jpg"
             alt="Изображение с предзагрузкой"
             loading="lazy">
    </div>

    <script>
        class ImageOptimizer {
            constructor() {
                this.setupLazyLoading();
                this.setupLowQualityPlaceholder();
            }

            setupLazyLoading() {
                // Используем встроенный lazy loading или Intersection Observer
                if ('loading' in HTMLImageElement.prototype) {
                    // Поддерживается native lazy loading
                    console.log('Native lazy loading поддерживается');
                } else {
                    // Резервный вариант с Intersection Observer
                    this.fallbackLazyLoading();
                }
            }

            fallbackLazyLoading() {
                const images = document.querySelectorAll('img[loading="lazy"]');
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;

                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                            }

                            if (img.dataset.srcset) {
                                img.srcset = img.dataset.srcset;
                                img.removeAttribute('data-srcset');
                            }

                            observer.unobserve(img);
                        }
                    });
                });

                images.forEach(img => imageObserver.observe(img));
            }

            setupLowQualityPlaceholder() {
                const previewImages = document.querySelectorAll('.preview-image');

                previewImages.forEach(img => {
                    const originalSrc = img.dataset.src;

                    // Загружаем высококачественное изображение
                    const highResImg = new Image();
                    highResImg.onload = () => {
                        // Заменяем превью на оригинальное изображение
                        img.src = originalSrc;
                        img.classList.add('loaded');
                    };
                    highResImg.src = originalSrc;
                });
            }

            // Оптимизация для разных плотностей экрана
            optimizeForDevicePixelRatio() {
                const images = document.querySelectorAll('img[data-src-2x]');

                if (window.devicePixelRatio > 1) {
                    images.forEach(img => {
                        if (img.dataset.src2x) {
                            img.src = img.dataset.src2x;
                        }
                    });
                }
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new ImageOptimizer();
        });
    </script>

    <style>
        .image-container {
            position: relative;
            width: 300px;
            height: 200px;
            overflow: hidden;
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.3s;
        }

        .preview-image:not(.loaded) {
            filter: blur(5px);
        }

        .preview-image.loaded {
            opacity: 1;
        }
    </style>
</body>
</html>
```

## Производительность с Web Components

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Производительность Web Components</title>
</head>
<body>
    <h1>Производительность Web Components</h1>

    <optimized-card title="Заголовок" content="Содержимое"></optimized-card>
    <optimized-list></optimized-list>

    <script>
        // Оптимизированный кастомный элемент
        class OptimizedCard extends HTMLElement {
            constructor() {
                super();

                // Используем template для эффективного рендеринга
                if (!OptimizedCard.template) {
                    OptimizedCard.template = document.createElement('template');
                    OptimizedCard.template.innerHTML = `
                        <style>
                            :host {
                                display: block;
                                border: 1px solid #ddd;
                                border-radius: 8px;
                                padding: 1rem;
                                margin: 0.5rem 0;
                                background: white;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            }

                            .card-header {
                                font-weight: bold;
                                margin-bottom: 0.5rem;
                            }

                            .card-content {
                                color: #666;
                                line-height: 1.5;
                            }
                        </style>

                        <div class="card-header" id="header"></div>
                        <div class="card-content" id="content"></div>
                    `;
                }

                this.attachShadow({ mode: 'open' });
                this.shadowRoot.appendChild(OptimizedCard.template.content.cloneNode(true));

                this.headerElement = this.shadowRoot.getElementById('header');
                this.contentElement = this.shadowRoot.getElementById('content');
            }

            static get observedAttributes() {
                return ['title', 'content'];
            }

            attributeChangedCallback(name, oldValue, newValue) {
                if (oldValue !== newValue) {
                    switch(name) {
                        case 'title':
                            this.headerElement.textContent = newValue;
                            break;
                        case 'content':
                            this.contentElement.textContent = newValue;
                            break;
                    }
                }
            }

            connectedCallback() {
                // Оптимизированная инициализация
                this.headerElement.textContent = this.getAttribute('title') || '';
                this.contentElement.textContent = this.getAttribute('content') || '';
            }
        }

        // Оптимизированный список
        class OptimizedList extends HTMLElement {
            constructor() {
                super();

                this.attachShadow({ mode: 'open' });
                this.shadowRoot.innerHTML = `
                    <style>
                        :host {
                            display: block;
                        }

                        .list {
                            list-style: none;
                            padding: 0;
                            margin: 0;
                        }

                        .list-item {
                            padding: 0.75rem 1rem;
                            border-bottom: 1px solid #eee;
                        }

                        .list-item:last-child {
                            border-bottom: none;
                        }
                    </style>

                    <ul class="list" id="list-container"></ul>
                `;

                this.listContainer = this.shadowRoot.getElementById('list-container');
                this.items = [];
            }

            setItems(newItems) {
                this.items = newItems;

                // Используем DocumentFragment для эффективного обновления
                const fragment = document.createDocumentFragment();

                this.items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.textContent = item.text || item;
                    fragment.appendChild(li);
                });

                this.listContainer.innerHTML = '';
                this.listContainer.appendChild(fragment);
            }

            addItem(item) {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.textContent = item.text || item;
                this.listContainer.appendChild(li);
                this.items.push(item);
            }

            removeItem(index) {
                if (index >= 0 && index < this.items.length) {
                    this.listContainer.removeChild(this.listContainer.children[index]);
                    this.items.splice(index, 1);
                }
            }
        }

        // Регистрация элементов
        customElements.define('optimized-card', OptimizedCard);
        customElements.define('optimized-list', OptimizedList);

        // Демонстрация использования
        document.addEventListener('DOMContentLoaded', () => {
            const list = document.querySelector('optimized-list');
            const items = Array.from({ length: 1000 }, (_, i) => ({ text: `Элемент ${i + 1}` }));
            list.setItems(items);
        });
    </script>
</body>
</html>
```

## Асинхронная загрузка и оптимизация

### Code Splitting и динамические импорты

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Асинхронная загрузка</title>
</head>
<body>
    <h1>Асинхронная загрузка компонентов</h1>

    <button id="load-chart">Загрузить график</button>
    <button id="load-map">Загрузить карту</button>
    <button id="load-editor">Загрузить редактор</button>

    <div id="dynamic-container"></div>

    <script>
        class AsyncComponentLoader {
            constructor() {
                this.container = document.getElementById('dynamic-container');
                this.loadedComponents = new Set();

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('load-chart').addEventListener('click', () => {
                    this.loadComponent('chart');
                });

                document.getElementById('load-map').addEventListener('click', () => {
                    this.loadComponent('map');
                });

                document.getElementById('load-editor').addEventListener('click', () => {
                    this.loadComponent('editor');
                });
            }

            async loadComponent(componentName) {
                if (this.loadedComponents.has(componentName)) {
                    console.log(`${componentName} уже загружен`);
                    return;
                }

                try {
                    // Показываем индикатор загрузки
                    this.showLoading(componentName);

                    // Динамический импорт компонента
                    const { default: Component } = await import(`./components/${componentName}.js`);

                    // Создаем экземпляр компонента
                    const componentInstance = new Component();

                    // Очищаем контейнер и добавляем компонент
                    this.container.innerHTML = '';
                    this.container.appendChild(componentInstance.render());

                    // Отмечаем компонент как загруженный
                    this.loadedComponents.add(componentName);

                } catch (error) {
                    console.error(`Ошибка загрузки компонента ${componentName}:`, error);
                    this.showError(`Ошибка загрузки компонента: ${componentName}`);
                }
            }

            showLoading(componentName) {
                this.container.innerHTML = `
                    <div class="loading">
                        <p>Загрузка ${componentName}...</p>
                        <div class="spinner"></div>
                    </div>
                `;
            }

            showError(message) {
                this.container.innerHTML = `
                    <div class="error">
                        <p>${message}</p>
                    </div>
                `;
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new AsyncComponentLoader();
        });
    </script>

    <style>
        .loading {
            text-align: center;
            padding: 2rem;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #d32f2f;
            text-align: center;
            padding: 2rem;
        }
    </style>
</body>
</html>
```

## Проверка и мониторинг производительности

### Инструменты и метрики

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Мониторинг производительности</title>
</head>
<body>
    <h1>Мониторинг производительности</h1>

    <div id="performance-metrics"></div>

    <script>
        class PerformanceMonitor {
            constructor() {
                this.metrics = {};
                this.setupMonitoring();
            }

            setupMonitoring() {
                // Метрики загрузки страницы
                this.measureLoadMetrics();

                // Метрики взаимодействия
                this.setupInteractionMetrics();

                // Метрики рендеринга
                this.setupRenderingMetrics();

                // Регулярный мониторинг
                this.startContinuousMonitoring();
            }

            measureLoadMetrics() {
                // Время до первого байта (TTFB)
                const ttfb = performance.getEntriesByType('navigation')[0]?.responseStart -
                             performance.getEntriesByType('navigation')[0]?.requestStart;

                // Время до первого содержательного рендера (FCP)
                new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        this.metrics.fcp = entry.startTime;
                        console.log('FCP:', entry.startTime);
                    }
                }).observe({ entryTypes: ['paint'] });

                // Время до полной загрузки DOM (DOMContentLoaded)
                document.addEventListener('DOMContentLoaded', () => {
                    this.metrics.domContentLoaded = performance.now();
                });

                // Время до полной загрузки (load)
                window.addEventListener('load', () => {
                    this.metrics.loadComplete = performance.now();
                });
            }

            setupInteractionMetrics() {
                // Время до первого ввода (FID) / Общее время блокировки (TBT)
                let interactionCount = 0;

                ['click', 'keydown', 'touchstart'].forEach(eventType => {
                    document.addEventListener(eventType, (event) => {
                        interactionCount++;

                        // Измеряем задержку обработки события
                        const startTime = performance.now();

                        setTimeout(() => {
                            const processingTime = performance.now() - startTime;

                            if (processingTime > 100) { // > 100ms считается медленным
                                console.warn(`Медленная обработка события: ${eventType}, время: ${processingTime}ms`);
                            }
                        }, 0);
                    }, true);
                });
            }

            setupRenderingMetrics() {
                // Измеряем FPS
                let frameCount = 0;
                let lastTime = performance.now();

                const measureFPS = (currentTime) => {
                    frameCount++;

                    if (currentTime - lastTime >= 1000) { // Каждую секунду
                        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                        this.metrics.currentFPS = fps;

                        console.log(`FPS: ${fps}`);

                        frameCount = 0;
                        lastTime = currentTime;
                    }

                    requestAnimationFrame(measureFPS);
                };

                requestAnimationFrame(measureFPS);
            }

            startContinuousMonitoring() {
                // Мониторинг использования памяти (если доступно)
                setInterval(() => {
                    if (performance.memory) {
                        this.metrics.memory = {
                            used: performance.memory.usedJSHeapSize,
                            total: performance.memory.jsHeapSizeLimit
                        };
                    }

                    // Мониторинг долгих задач
                    if ('PerformanceObserver' in window) {
                        new PerformanceObserver((list) => {
                            for (const entry of list.getEntries()) {
                                if (entry.duration > 50) { // Задача дольше 50ms
                                    console.warn('Долгая задача:', entry);
                                }
                            }
                        }).observe({ entryTypes: ['longtask'] });
                    }

                    this.displayMetrics();
                }, 5000); // Обновляем каждые 5 секунд
            }

            displayMetrics() {
                const metricsElement = document.getElementById('performance-metrics');

                metricsElement.innerHTML = `
                    <h3>Метрики производительности:</h3>
                    <ul>
                        <li><strong>FCP:</strong> ${this.metrics.fcp?.toFixed(2) || 'N/A'} ms</li>
                        <li><strong>DOM Loaded:</strong> ${this.metrics.domContentLoaded?.toFixed(2) || 'N/A'} ms</li>
                        <li><strong>Page Load:</strong> ${this.metrics.loadComplete?.toFixed(2) || 'N/A'} ms</li>
                        <li><strong>Current FPS:</strong> ${this.metrics.currentFPS || 'N/A'}</li>
                        ${this.metrics.memory ? `
                            <li><strong>Memory:</strong>
                                ${(this.metrics.memory.used / 1024 / 1024).toFixed(2)} MB /
                                ${(this.metrics.memory.total / 1024 / 1024).toFixed(2)} MB
                            </li>
                        ` : ''}
                    </ul>
                `;
            }

            getMetrics() {
                return { ...this.metrics };
            }

            exportMetrics() {
                const dataStr = JSON.stringify(this.getMetrics(), null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

                const exportFile = document.createElement('a');
                exportFile.setAttribute('href', dataUri);
                exportFile.setAttribute('download', 'performance-metrics.json');
                exportFile.click();
            }
        }

        // Инициализация мониторинга
        const perfMonitor = new PerformanceMonitor();

        // Добавляем кнопку экспорта метрик
        const exportBtn = document.createElement('button');
        exportBtn.textContent = 'Экспортировать метрики';
        exportBtn.onclick = () => perfMonitor.exportMetrics();
        document.body.appendChild(exportBtn);
    </script>
</body>
</html>
```

## Лучшие практики производительности

### 1. Оптимизация загрузки
```html
<!-- Правильный порядок загрузки ресурсов -->
<head>
    <!-- Критические стили встроены -->
    <style>
        /* Критические стили для верхней части страницы */
        body { margin: 0; font-family: Arial, sans-serif; }
        .above-fold { height: 100vh; }
    </style>

    <!-- Предзагрузка критических ресурсов -->
    <link rel="preload" href="critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="hero-image.jpg" as="image">
    <link rel="preload" href="main.js" as="script">

    <!-- Подключение шрифтов с оптимизацией -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
</head>
```

### 2. Оптимизация рендеринга
```javascript
// Эффективное обновление DOM
class EfficientRenderer {
    constructor(container) {
        this.container = container;
        this.virtualDOM = null;
    }

    // Используем технику виртуального DOM для минимальных изменений
    render(newState) {
        const newVirtualDOM = this.createVirtualDOM(newState);

        if (this.virtualDOM) {
            const patches = this.diff(this.virtualDOM, newVirtualDOM);
            this.patch(this.container, patches);
        } else {
            this.container.innerHTML = this.renderToString(newVirtualDOM);
        }

        this.virtualDOM = newVirtualDOM;
    }

    createVirtualDOM(state) {
        // Создаем виртуальное DOM-дерево
        return {
            tag: 'div',
            props: { className: 'container' },
            children: state.items.map(item => ({
                tag: 'div',
                props: { className: 'item', 'data-id': item.id },
                children: [
                    { tag: 'h3', props: {}, children: [item.title] },
                    { tag: 'p', props: {}, children: [item.description] }
                ]
            }))
        };
    }

    diff(oldVNode, newVNode) {
        // Простая реализация diff-алгоритма
        const patches = [];

        // Сравниваем узлы и создаем патчи
        if (oldVNode.tag !== newVNode.tag) {
            patches.push({ type: 'REPLACE', node: newVNode });
        } else if (this.isTextNode(oldVNode) || this.isTextNode(newVNode)) {
            if (oldVNode !== newVNode) {
                patches.push({ type: 'TEXT', text: newVNode });
            }
        } else {
            // Сравниваем атрибуты
            const attrPatches = this.diffProps(oldVNode.props, newVNode.props);
            if (attrPatches.length > 0) {
                patches.push({ type: 'ATTRS', attrs: attrPatches });
            }

            // Сравниваем дочерние элементы
            const childPatches = this.diffChildren(oldVNode.children, newVNode.children);
            if (childPatches.length > 0) {
                patches.push({ type: 'CHILDREN', children: childPatches });
            }
        }

        return patches;
    }

    patch(container, patches) {
        // Применяем патчи к реальному DOM
        patches.forEach(patch => {
            switch(patch.type) {
                case 'REPLACE':
                    container.outerHTML = this.renderToString(patch.node);
                    break;
                case 'TEXT':
                    container.textContent = patch.text;
                    break;
                case 'ATTRS':
                    patch.attrs.forEach(attrPatch => {
                        container[attrPatch.name] = attrPatch.value;
                    });
                    break;
                case 'CHILDREN':
                    // Обновляем дочерние элементы
                    break;
            }
        });
    }

    renderToString(vNode) {
        if (typeof vNode === 'string') {
            return vNode;
        }

        let html = `<${vNode.tag}`;

        if (vNode.props) {
            Object.entries(vNode.props).forEach(([key, value]) => {
                html += ` ${key}="${value}"`;
            });
        }

        html += '>';

        if (vNode.children) {
            vNode.children.forEach(child => {
                html += this.renderToString(child);
            });
        }

        html += `</${vNode.tag}>`;

        return html;
    }
}
```

### 3. Управление памятью
```javascript
class MemoryEfficientComponent {
    constructor() {
        this.eventListeners = new Map();
        this.timers = new Set();
        this.intervals = new Set();
        this.observables = new Set();
    }

    addEventListener(element, event, handler) {
        element.addEventListener(event, handler);

        if (!this.eventListeners.has(element)) {
            this.eventListeners.set(element, []);
        }

        this.eventListeners.get(element).push({ event, handler });
    }

    setTimeout(callback, delay) {
        const timerId = window.setTimeout(() => {
            callback();
            this.timers.delete(timerId);
        }, delay);

        this.timers.add(timerId);
        return timerId;
    }

    setInterval(callback, interval) {
        const intervalId = window.setInterval(callback, interval);
        this.intervals.add(intervalId);
        return intervalId;
    }

    destroy() {
        // Очистка событий
        this.eventListeners.forEach((handlers, element) => {
            handlers.forEach(({ event, handler }) => {
                element.removeEventListener(event, handler);
            });
        });

        // Очистка таймеров
        this.timers.forEach(id => window.clearTimeout(id));
        this.intervals.forEach(id => window.clearInterval(id));

        // Очистка других ресурсов
        this.observables.forEach(obs => obs.unsubscribe?.());

        // Очистка коллекций
        this.eventListeners.clear();
        this.timers.clear();
        this.intervals.clear();
        this.observables.clear();
    }
}
```

## Современные возможности производительности

### Web Workers для тяжелых вычислений
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Web Workers и производительность</title>
</head>
<body>
    <h1>Web Workers для тяжелых вычислений</h1>

    <div class="worker-demo">
        <h2>Демонстрация Web Workers</h2>

        <div class="controls">
            <button id="start-heavy-task">Запустить тяжелую задачу</button>
            <button id="start-heavy-task-worker">Запустить с Web Worker</button>
            <button id="stop-workers">Остановить все Workers</button>
        </div>

        <div class="results">
            <div id="main-thread-result"></div>
            <div id="worker-result"></div>
        </div>

        <div class="performance-stats">
            <h3>Статистика производительности:</h3>
            <div id="stats-container"></div>
        </div>
    </div>

    <script>
        // Код Web Worker (в реальном приложении - отдельный файл)
        const workerCode = `
            // worker.js
            self.onmessage = function(e) {
                const { operation, data, taskId } = e.data;

                switch(operation) {
                    case 'calculate':
                        // Тяжелые вычисления
                        const startTime = performance.now();
                        const result = performHeavyCalculation(data);
                        const endTime = performance.now();

                        self.postMessage({
                            taskId: taskId,
                            result: result,
                            executionTime: endTime - startTime
                        });
                        break;

                    case 'processData':
                        // Обработка данных
                        const processedData = processData(data);
                        self.postMessage({
                            taskId: taskId,
                            result: processedData
                        });
                        break;
                }
            };

            function performHeavyCalculation(n) {
                // Сложные вычисления для демонстрации
                let result = 0;
                for (let i = 0; i < n; i++) {
                    result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);
                }
                return result;
            }

            function processData(data) {
                // Обработка массива данных
                return data.map(item => ({
                    ...item,
                    processed: true,
                    timestamp: Date.now()
                }));
            }
        `;

        class PerformanceOptimizer {
            constructor() {
                this.workers = [];
                this.taskIdCounter = 0;

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('start-heavy-task').addEventListener('click', () => {
                    this.performHeavyTaskMainThread();
                });

                document.getElementById('start-heavy-task-worker').addEventListener('click', () => {
                    this.performHeavyTaskWithWorker();
                });

                document.getElementById('stop-workers').addEventListener('click', () => {
                    this.terminateAllWorkers();
                });
            }

            async performHeavyTaskMainThread() {
                const startTime = performance.now();

                // Показываем индикатор загрузки
                document.getElementById('main-thread-result').innerHTML = '<div class="loading">Выполнение тяжелой задачи в основном потоке...</div>';

                try {
                    // Тяжелые вычисления (блокируют UI)
                    const result = this.performHeavyCalculation(10000000);
                    const endTime = performance.now();

                    document.getElementById('main-thread-result').innerHTML = `
                        <div class="result">
                            <h4>Результат (основной поток):</h4>
                            <p>Значение: ${result.toFixed(4)}</p>
                            <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                        </div>
                    `;

                    this.updateStats('main-thread', endTime - startTime);
                } catch (error) {
                    document.getElementById('main-thread-result').innerHTML = `<div class="error">Ошибка: ${error.message}</div>`;
                }
            }

            async performHeavyTaskWithWorker() {
                const startTime = performance.now();

                // Показываем индикатор загрузки
                document.getElementById('worker-result').innerHTML = '<div class="loading">Выполнение тяжелой задачи в Web Worker...</div>';

                try {
                    const worker = this.createWorker();
                    const taskId = ++this.taskIdCounter;

                    // Отправляем задачу в worker
                    worker.postMessage({
                        operation: 'calculate',
                        data: 10000000,
                        taskId: taskId
                    });

                    // Ожидаем результата
                    const result = await this.waitForWorkerResult(worker, taskId);
                    const endTime = performance.now();

                    document.getElementById('worker-result').innerHTML = `
                        <div class="result">
                            <h4>Результат (Web Worker):</h4>
                            <p>Значение: ${result.toFixed(4)}</p>
                            <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                        </div>
                    `;

                    this.updateStats('web-worker', endTime - startTime);
                } catch (error) {
                    document.getElementById('worker-result').innerHTML = `<div class="error">Ошибка: ${error.message}</div>`;
                }
            }

            createWorker() {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                this.workers.push(worker);
                return worker;
            }

            waitForWorkerResult(worker, taskId) {
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Таймаут выполнения задачи'));
                    }, 30000); // 30 секунд

                    worker.onmessage = (e) => {
                        if (e.data.taskId === taskId) {
                            clearTimeout(timeout);
                            resolve(e.data.result);
                        }
                    };

                    worker.onerror = (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    };
                });
            }

            performHeavyCalculation(n) {
                // Тяжелые вычисления в основном потоке
                let result = 0;
                for (let i = 0; i < n; i++) {
                    result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);
                }
                return result;
            }

            terminateAllWorkers() {
                this.workers.forEach(worker => {
                    worker.terminate();
                });
                this.workers = [];
                console.log('Все Web Workers остановлены');
            }

            updateStats(taskType, executionTime) {
                const statsContainer = document.getElementById('stats-container');

                const statEntry = document.createElement('div');
                statEntry.className = `stat-entry ${taskType}`;
                statEntry.innerHTML = `
                    <strong>${taskType === 'main-thread' ? 'Основной поток' : 'Web Worker'}:</strong>
                    <span>${executionTime.toFixed(2)}ms</span>
                `;

                statsContainer.appendChild(statEntry);
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new PerformanceOptimizer();
        });
    </script>

    <style>
        .worker-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #start-heavy-task {
            background-color: #dc3545;
            color: white;
        }

        #start-heavy-task-worker {
            background-color: #28a745;
            color: white;
        }

        #stop-workers {
            background-color: #ffc107;
            color: #212529;
        }

        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .loading {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .result {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 4px;
        }

        .error {
            background-color: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 4px;
        }

        .performance-stats {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }

        .stat-entry {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-entry.main-thread {
            color: #d32f2f;
        }

        .stat-entry.web-worker {
            color: #2e7d32;
        }
    </style>
</body>
</html>
```

### WebAssembly для высокопроизводительных операций
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebAssembly и производительность</title>
</head>
<body>
    <h1>WebAssembly для высокопроизводительных операций</h1>

    <div class="wasm-demo">
        <h2>Демонстрация WebAssembly</h2>

        <div class="controls">
            <button id="calculate-js">Вычисление на JavaScript</button>
            <button id="calculate-wasm">Вычисление на WebAssembly</button>
        </div>

        <div class="results">
            <div id="js-result"></div>
            <div id="wasm-result"></div>
        </div>

        <div class="comparison">
            <h3>Сравнение производительности:</h3>
            <div id="comparison-result"></div>
        </div>
    </div>

    <script>
        class WASMOptimizer {
            constructor() {
                this.wasmModule = null;
                this.setupEventListeners();
                this.loadWASM();
            }

            setupEventListeners() {
                document.getElementById('calculate-js').addEventListener('click', () => {
                    this.calculateWithJavaScript();
                });

                document.getElementById('calculate-wasm').addEventListener('click', () => {
                    this.calculateWithWASM();
                });
            }

            async loadWASM() {
                try {
                    // В реальном приложении это будет реальный WASM файл
                    // const wasmModule = await WebAssembly.instantiateStreaming(fetch('math.wasm'));

                    // Для демонстрации создаем mock-модуль
                    this.wasmModule = {
                        exports: {
                            fibonacci: (n) => this.fibonacciJS(n),
                            primeCheck: (n) => this.isPrimeJS(n),
                            factorial: (n) => this.factorialJS(n)
                        }
                    };

                    console.log('WebAssembly модуль загружен');
                } catch (error) {
                    console.error('Ошибка загрузки WebAssembly:', error);
                    // Резервный вариант - использовать JavaScript
                }
            }

            fibonacciJS(n) {
                if (n <= 1) return n;
                return this.fibonacciJS(n - 1) + this.fibonacciJS(n - 2);
            }

            isPrimeJS(n) {
                if (n <= 1) return false;
                if (n <= 3) return true;
                if (n % 2 === 0 || n % 3 === 0) return false;

                for (let i = 5; i * i <= n; i += 6) {
                    if (n % i === 0 || n % (i + 2) === 0) return false;
                }
                return true;
            }

            factorialJS(n) {
                if (n <= 1) return 1;
                return n * this.factorialJS(n - 1);
            }

            async calculateWithJavaScript() {
                const input = prompt('Введите число для вычисления факториала:', '10');
                const n = parseInt(input);

                if (isNaN(n) || n < 0) {
                    alert('Введите положительное число');
                    return;
                }

                const startTime = performance.now();

                // Вычисление на JavaScript
                const result = this.factorialJS(n);
                const endTime = performance.now();

                document.getElementById('js-result').innerHTML = `
                    <div class="result">
                        <h4>JavaScript результат:</h4>
                        <p>Факториал ${n} = ${result}</p>
                        <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                    </div>
                `;

                return { result, time: endTime - startTime };
            }

            async calculateWithWASM() {
                const input = prompt('Введите число для вычисления факториала (WebAssembly):', '10');
                const n = parseInt(input);

                if (isNaN(n) || n < 0) {
                    alert('Введите положительное число');
                    return;
                }

                const startTime = performance.now();

                try {
                    // Вычисление на WebAssembly
                    const result = this.wasmModule.exports.factorial(n);
                    const endTime = performance.now();

                    document.getElementById('wasm-result').innerHTML = `
                        <div class="result">
                            <h4>WebAssembly результат:</h4>
                            <p>Факториал ${n} = ${result}</p>
                            <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                        </div>
                    `;

                    return { result, time: endTime - startTime };
                } catch (error) {
                    document.getElementById('wasm-result').innerHTML = `<div class="error">Ошибка WebAssembly: ${error.message}</div>`;
                    return null;
                }
            }

            comparePerformance() {
                // Сравнение производительности
                const comparisonContainer = document.getElementById('comparison-result');

                // Здесь будет сравнение реальных результатов
                comparisonContainer.innerHTML = '<p>Сравнение производительности между JavaScript и WebAssembly</p>';
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new WASMOptimizer();
        });
    </script>

    <style>
        .wasm-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #calculate-js {
            background-color: #007acc;
            color: white;
        }

        #calculate-wasm {
            background-color: #6f42c1;
            color: white;
        }

        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .result {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 4px;
        }

        .error {
            background-color: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 4px;
        }

        .comparison {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
    </style>
</body>
</html>
```

### Оптимизация с помощью Intersection Observer
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Intersection Observer и производительность</title>
</head>
<body>
    <h1>Intersection Observer для оптимизации производительности</h1>

    <div class="observer-demo">
        <h2>Демонстрация Intersection Observer</h2>

        <div class="content-area">
            <p>Прокрутите вниз, чтобы увидеть элементы, загружающиеся при появлении в области видимости.</p>

            <div class="content-container" id="content-container">
                <!-- Элементы будут добавлены сюда -->
            </div>
        </div>

        <div class="stats">
            <h3>Статистика загрузки:</h3>
            <div id="observer-stats"></div>
        </div>
    </div>

    <script>
        class IntersectionObserverOptimizer {
            constructor() {
                this.container = document.getElementById('content-container');
                this.statsContainer = document.getElementById('observer-stats');
                this.visibleCount = 0;
                this.loadedCount = 0;

                this.createContent();
                this.setupObserver();
                this.updateStats();
            }

            createContent() {
                // Создаем много элементов для демонстрации
                const contentHTML = Array.from({ length: 50 }, (_, i) => `
                    <div class="content-item" data-index="${i + 1}">
                        <h3>Элемент ${i + 1}</h3>
                        <p>Этот элемент будет загружен при появлении в области видимости</p>
                        <img src="https://via.placeholder.com/300x200?text=Image+${i+1}"
                             alt="Изображение ${i + 1}"
                             class="lazy-image"
                             data-src="https://picsum.photos/300/200?random=${i+1}">
                        <p>Дополнительный текст для элемента ${i + 1}</p>
                    </div>
                `).join('');

                this.container.innerHTML = contentHTML;
            }

            setupObserver() {
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.onElementVisible(entry.target);
                        }
                    });
                }, {
                    rootMargin: '100px', // Начинать загрузку за 100px до появления
                    threshold: 0.1        // Загружать, когда 10% элемента видно
                });

                // Наблюдение за всеми элементами
                document.querySelectorAll('.content-item').forEach(item => {
                    this.observer.observe(item);
                });
            }

            onElementVisible(element) {
                this.visibleCount++;

                // Загрузка изображений при появлении в области видимости
                const lazyImages = element.querySelectorAll('.lazy-image');
                lazyImages.forEach(img => {
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                        this.loadedCount++;
                    }
                });

                // Добавление класса для визуального индикатора
                element.classList.add('loaded');

                // Остановка наблюдения за элементом после загрузки
                this.observer.unobserve(element);

                this.updateStats();
            }

            updateStats() {
                this.statsContainer.innerHTML = `
                    <p>Показано элементов: <strong>${this.visibleCount}</strong></p>
                    <p>Загружено изображений: <strong>${this.loadedCount}</strong></p>
                    <p>Эффективность: <strong>${((this.loadedCount / this.visibleCount) * 100 || 0).toFixed(2)}%</strong></p>
                `;
            }

            disconnect() {
                this.observer.disconnect();
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new IntersectionObserverOptimizer();
        });
    </script>

    <style>
        .observer-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .content-area {
            margin-bottom: 30px;
        }

        .content-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background-color: white;
            opacity: 0.7;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }

        .content-item.loaded {
            opacity: 1;
            transform: translateY(0);
        }

        .lazy-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 4px;
            margin: 10px 0;
        }

        .stats {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .stats p {
            margin: 5px 0;
        }
    </style>
</body>
</html>
```

### Оптимизация с помощью requestAnimationFrame

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>requestAnimationFrame и производительность</title>
</head>
<body>
    <h1>requestAnimationFrame для оптимизации анимаций</h1>

    <div class="raf-demo">
        <h2>Демонстрация requestAnimationFrame</h2>

        <div class="animation-controls">
            <button id="start-animation">Начать анимацию</button>
            <button id="stop-animation">Остановить анимацию</button>
            <button id="batch-update">Пакетное обновление</button>
        </div>

        <div class="animation-container">
            <div id="animated-box" class="animated-box"></div>
            <div id="fps-counter" class="fps-counter">FPS: 0</div>
        </div>

        <div class="performance-comparison">
            <h3>Сравнение производительности:</h3>
            <div class="comparison-section">
                <h4>Анимация с setInterval:</h4>
                <div id="setinterval-result"></div>
            </div>
            <div class="comparison-section">
                <h4>Анимация с requestAnimationFrame:</h4>
                <div id="raf-result"></div>
            </div>
        </div>
    </div>

    <script>
        class AnimationOptimizer {
            constructor() {
                this.animatedBox = document.getElementById('animated-box');
                this.fpsCounter = document.getElementById('fps-counter');
                this.isAnimating = false;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;

                this.setupEventListeners();
                this.startFPSCounter();
            }

            setupEventListeners() {
                document.getElementById('start-animation').addEventListener('click', () => {
                    this.startRAFAnimation();
                });

                document.getElementById('stop-animation').addEventListener('click', () => {
                    this.stopRAFAnimation();
                });

                document.getElementById('batch-update').addEventListener('click', () => {
                    this.batchDOMUpdates();
                });
            }

            startRAFAnimation() {
                if (this.isAnimating) return;

                this.isAnimating = true;
                this.animateFrame(performance.now());
            }

            animateFrame(currentTime) {
                if (!this.isAnimating) return;

                // Обновление позиции элемента
                const position = (currentTime / 10) % window.innerWidth;
                this.animatedBox.style.transform = `translateX(${position}px)`;

                // Обновление FPS счетчика
                this.frameCount++;
                if (currentTime - this.lastTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.fpsCounter.textContent = `FPS: ${this.fps}`;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }

                requestAnimationFrame((time) => this.animateFrame(time));
            }

            stopRAFAnimation() {
                this.isAnimating = false;
            }

            batchDOMUpdates() {
                // Пакетное обновление DOM для улучшения производительности
                const startTime = performance.now();

                // Группировка изменений DOM
                requestAnimationFrame(() => {
                    // Все изменения DOM происходят в одном цикле рендеринга
                    for (let i = 0; i < 100; i++) {
                        const element = document.createElement('div');
                        element.className = 'batch-element';
                        element.textContent = `Элемент ${i + 1}`;
                        element.style.position = 'absolute';
                        element.style.top = `${Math.random() * 300}px`;
                        element.style.left = `${Math.random() * 600}px`;

                        document.body.appendChild(element);
                    }

                    const endTime = performance.now();
                    document.getElementById('raf-result').innerHTML = `
                        <p>Пакетное обновление выполнено за: ${(endTime - startTime).toFixed(2)}ms</p>
                        <p>Количество элементов: 100</p>
                    `;
                });
            }

            startFPSCounter() {
                setInterval(() => {
                    // Обновление FPS каждую секунду
                    if (this.isAnimating) {
                        this.fpsCounter.style.color = this.fps > 55 ? '#2e7d32' : '#d32f2f';
                    }
                }, 1000);
            }

            // Сравнение с setInterval
            compareWithSetInterval() {
                const startTime = performance.now();
                let intervalFrames = 0;

                const intervalId = setInterval(() => {
                    // Обновление позиции с setInterval
                    const position = (intervalFrames * 10) % window.innerWidth;
                    this.animatedBox.style.transform = `translateX(${position}px)`;
                    intervalFrames++;

                    if (intervalFrames > 100) {
                        clearInterval(intervalId);
                        const endTime = performance.now();

                        document.getElementById('setinterval-result').innerHTML = `
                            <p>Анимация с setInterval выполнена за: ${(endTime - startTime).toFixed(2)}ms</p>
                            <p>Количество кадров: ${intervalFrames}</p>
                        `;
                    }
                }, 16); // ~60 FPS
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new AnimationOptimizer();
        });
    </script>

    <style>
        .raf-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .animation-controls {
            margin-bottom: 20px;
        }

        .animation-controls button {
            padding: 10px 20px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #start-animation {
            background-color: #28a745;
            color: white;
        }

        #stop-animation {
            background-color: #dc3545;
            color: white;
        }

        #batch-update {
            background-color: #007acc;
            color: white;
        }

        .animation-container {
            position: relative;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .animated-box {
            width: 50px;
            height: 50px;
            background-color: #007acc;
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            border-radius: 4px;
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        .performance-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .comparison-section {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .batch-element {
            width: 80px;
            height: 30px;
            background-color: #ffc107;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 0.8em;
        }
    </style>
</body>
</html>
```

## Практические примеры и шаблоны

### Шаблон для высокопроизводительной таблицы
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Высокопроизводительная таблица</title>
</head>
<body>
    <h1>Высокопроизводительная таблица данных</h1>

    <div class="table-container">
        <div class="table-controls">
            <input type="text" id="search-input" placeholder="Поиск...">
            <select id="sort-column">
                <option value="name">Имя</option>
                <option value="email">Email</option>
                <option value="date">Дата</option>
            </select>
            <button id="sort-direction">↑</button>
            <button id="add-row">Добавить строку</button>
        </div>

        <div class="virtual-table" id="virtual-table">
            <table>
                <thead id="table-header"></thead>
                <tbody id="table-body"></tbody>
            </table>
        </div>

        <div class="table-stats" id="table-stats"></div>
    </div>

    <script>
        class VirtualTable {
            constructor(containerId, options = {}) {
                this.container = document.getElementById(containerId);
                this.options = {
                    rowHeight: options.rowHeight || 40,
                    bufferSize: options.bufferSize || 5,
                    ...options
                };

                this.data = this.generateSampleData(10000); // 10k строк для демонстрации
                this.filteredData = [...this.data];
                this.visibleStart = 0;
                this.visibleEnd = 0;

                this.setupTable();
                this.setupVirtualScrolling();
            }

            generateSampleData(count) {
                const names = ['Иван', 'Мария', 'Алексей', 'Елена', 'Дмитрий', 'Анна', 'Сергей', 'Ольга'];
                const domains = ['example.com', 'mail.ru', 'gmail.com', 'yandex.ru'];

                return Array.from({ length: count }, (_, i) => ({
                    id: i + 1,
                    name: `${names[i % names.length]} ${names[(i + 1) % names.length]}${i % 100}`,
                    email: `user${i}@${domains[i % domains.length]}`,
                    date: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    status: ['active', 'inactive', 'pending'][i % 3]
                }));
            }

            setupTable() {
                this.renderHeaders();
                this.updateStats();
            }

            renderHeaders() {
                const header = document.getElementById('table-header');
                header.innerHTML = `
                    <tr>
                        <th data-column="id">ID</th>
                        <th data-column="name">Имя</th>
                        <th data-column="email">Email</th>
                        <th data-column="date">Дата</th>
                        <th data-column="status">Статус</th>
                    </tr>
                `;

                // Добавляем обработчики сортировки
                header.querySelectorAll('th').forEach(th => {
                    th.addEventListener('click', () => {
                        this.sortByColumn(th.dataset.column);
                    });
                });
            }

            setupVirtualScrolling() {
                const tableBody = document.getElementById('table-body');
                const virtualTable = document.getElementById('virtual-table');

                // Устанавливаем высоту контейнера для скроллинга
                virtualTable.style.height = '400px';
                virtualTable.style.overflow = 'auto';

                virtualTable.addEventListener('scroll', this.throttle(() => {
                    this.updateVisibleRows();
                }, 16)); // ~60 FPS

                this.updateVisibleRows();
            }

            updateVisibleRows() {
                const virtualTable = document.getElementById('virtual-table');
                const tableBody = document.getElementById('table-body');

                const visibleStart = Math.floor(virtualTable.scrollTop / this.options.rowHeight);
                const visibleCount = Math.ceil(virtualTable.clientHeight / this.options.rowHeight);

                this.visibleStart = Math.max(0, visibleStart - this.options.bufferSize);
                this.visibleEnd = Math.min(this.filteredData.length, visibleStart + visibleCount + this.options.bufferSize);

                // Очищаем и рендерим видимые строки
                tableBody.innerHTML = '';

                // Добавляем верхний спейсер
                const topSpacer = document.createElement('tr');
                topSpacer.style.height = `${this.visibleStart * this.options.rowHeight}px`;
                topSpacer.style.visibility = 'hidden';
                tableBody.appendChild(topSpacer);

                // Добавляем видимые строки
                for (let i = this.visibleStart; i < this.visibleEnd; i++) {
                    const row = this.createRow(this.filteredData[i], i);
                    tableBody.appendChild(row);
                }

                // Добавляем нижний спейсер
                const bottomHeight = (this.filteredData.length - this.visibleEnd) * this.options.rowHeight;
                if (bottomHeight > 0) {
                    const bottomSpacer = document.createElement('tr');
                    bottomSpacer.style.height = `${bottomHeight}px`;
                    bottomSpacer.style.visibility = 'hidden';
                    tableBody.appendChild(bottomSpacer);
                }
            }

            createRow(data, index) {
                const row = document.createElement('tr');
                row.dataset.index = index;

                row.innerHTML = `
                    <td>${data.id}</td>
                    <td>${data.name}</td>
                    <td>${data.email}</td>
                    <td>${data.date}</td>
                    <td><span class="status status-${data.status}">${data.status}</span></td>
                `;

                return row;
            }

            sortByColumn(column) {
                const direction = this.options.sortDirection === 'asc' ? 'desc' : 'asc';
                this.options.sortDirection = direction;
                this.options.sortColumn = column;

                this.filteredData.sort((a, b) => {
                    const aVal = a[column];
                    const bVal = b[column];

                    let result = 0;
                    if (aVal < bVal) result = -1;
                    if (aVal > bVal) result = 1;

                    return direction === 'asc' ? result : -result;
                });

                // Обновляем индикатор сортировки
                document.querySelectorAll('#table-header th').forEach(th => {
                    th.classList.remove('sorted-asc', 'sorted-desc');
                });

                const sortedHeader = document.querySelector(`#table-header th[data-column="${column}"]`);
                sortedHeader.classList.add(`sorted-${direction}`);

                this.updateVisibleRows();
                this.updateStats();
            }

            search(query) {
                if (!query) {
                    this.filteredData = [...this.data];
                } else {
                    this.filteredData = this.data.filter(row =>
                        Object.values(row).some(value =>
                            String(value).toLowerCase().includes(query.toLowerCase())
                        )
                    );
                }

                this.visibleStart = 0;
                this.updateVisibleRows();
                this.updateStats();
            }

            updateStats() {
                const stats = document.getElementById('table-stats');
                stats.innerHTML = `
                    <p>Всего строк: ${this.data.length}</p>
                    <p>Отфильтровано: ${this.filteredData.length}</p>
                    <p>Отображается: ${this.visibleEnd - this.visibleStart}</p>
                `;
            }

            throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }
        }

        // Инициализация таблицы
        let virtualTable;
        document.addEventListener('DOMContentLoaded', () => {
            virtualTable = new VirtualTable('virtual-table');

            // Настройка поиска
            document.getElementById('search-input').addEventListener('input', (e) => {
                virtualTable.search(e.target.value);
            });

            // Настройка добавления строк
            document.getElementById('add-row').addEventListener('click', () => {
                const newRow = {
                    id: virtualTable.data.length + 1,
                    name: `Новый пользователь ${virtualTable.data.length + 1}`,
                    email: `newuser${virtualTable.data.length + 1}@example.com`,
                    date: new Date().toISOString().split('T')[0],
                    status: 'pending'
                };

                virtualTable.data.push(newRow);
                virtualTable.filteredData.push(newRow);
                virtualTable.updateVisibleRows();
                virtualTable.updateStats();
            });
        });
    </script>

    <style>
        .table-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .table-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #search-input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
        }

        select, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007acc;
            color: white;
            cursor: pointer;
        }

        .virtual-table {
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background-color: #f8f9fa;
            position: sticky;
            top: 0;
            cursor: pointer;
        }

        th:hover {
            background-color: #e9ecef;
        }

        th.sorted-asc::after {
            content: ' ↑';
            color: #007acc;
        }

        th.sorted-desc::after {
            content: ' ↓';
            color: #007acc;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .status {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .status-active {
            background-color: #d4edda;
            color: #155724;
        }

        .status-inactive {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status-pending {
            background-color: #fff3cd;
            color: #856404;
        }

        .table-stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            display: flex;
            gap: 20px;
        }
    </style>
</body>
</html>
```

### Шаблон для оптимизированного кеширования данных
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Оптимизированное кеширование данных</title>
</head>
<body>
    <h1>Оптимизированное кеширование данных</h1>

    <div class="cache-demo">
        <div class="controls">
            <button id="load-data">Загрузить данные</button>
            <button id="clear-cache">Очистить кеш</button>
            <button id="show-stats">Показать статистику</button>
        </div>

        <div id="data-display"></div>
        <div id="cache-stats"></div>
    </div>

    <script>
        class OptimizedCache {
            constructor(options = {}) {
                this.cache = new Map();
                this.maxSize = options.maxSize || 100;
                this.defaultTTL = options.defaultTTL || 5 * 60 * 1000; // 5 минут
                this.stats = {
                    hits: 0,
                    misses: 0,
                    sets: 0,
                    evictions: 0
                };
            }

            async get(key, fetcher, ttl = this.defaultTTL) {
                const cached = this.cache.get(key);

                if (cached && Date.now() - cached.timestamp < ttl) {
                    this.stats.hits++;
                    console.log('Данные получены из кеша:', key);
                    return cached.data;
                }

                this.stats.misses++;
                console.log('Загрузка данных с сервера:', key);

                const data = await fetcher();

                this.set(key, data, ttl);
                return data;
            }

            set(key, data, ttl = this.defaultTTL) {
                if (this.cache.size >= this.maxSize) {
                    // Удаляем самый старый элемент
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                    this.stats.evictions++;
                }

                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now(),
                    ttl: ttl
                });

                this.stats.sets++;
            }

            delete(key) {
                return this.cache.delete(key);
            }

            clear() {
                this.cache.clear();
                this.resetStats();
            }

            has(key) {
                const cached = this.cache.get(key);
                return cached && Date.now() - cached.timestamp < cached.ttl;
            }

            resetStats() {
                this.stats = {
                    hits: 0,
                    misses: 0,
                    sets: 0,
                    evictions: 0
                };
            }

            getStats() {
                const totalRequests = this.stats.hits + this.stats.misses;
                const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests * 100).toFixed(2) : 0;

                return {
                    ...this.stats,
                    hitRate: `${hitRate}%`,
                    size: this.cache.size
                };
            }
        }

        class DataCacheManager {
            constructor() {
                this.cache = new OptimizedCache({
                    maxSize: 50,
                    defaultTTL: 10 * 60 * 1000 // 10 минут
                });

                this.dataDisplay = document.getElementById('data-display');
                this.statsDisplay = document.getElementById('cache-stats');

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('load-data').addEventListener('click', () => {
                    this.loadAndCacheData();
                });

                document.getElementById('clear-cache').addEventListener('click', () => {
                    this.cache.clear();
                    this.updateStats();
                });

                document.getElementById('show-stats').addEventListener('click', () => {
                    this.updateStats();
                });
            }

            async loadAndCacheData() {
                try {
                    this.showLoading('Загрузка данных...');

                    // Симуляция загрузки данных
                    const data = await this.cache.get('api-data', async () => {
                        const response = await fetch('/api/data');
                        return await response.json();
                    });

                    this.displayData(data);
                    this.updateStats();

                } catch (error) {
                    this.showError(`Ошибка загрузки данных: ${error.message}`);
                }
            }

            displayData(data) {
                this.dataDisplay.innerHTML = `
                    <div class="data-content">
                        <h3>Данные загружены:</h3>
                        <pre>${JSON.stringify(data, null, 2)}</pre>
                    </div>
                `;
            }

            showLoading(message) {
                this.dataDisplay.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>${message}</p>
                    </div>
                `;
            }

            showError(message) {
                this.dataDisplay.innerHTML = `
                    <div class="error">
                        <h3>Ошибка:</h3>
                        <p>${message}</p>
                    </div>
                `;
            }

            updateStats() {
                const stats = this.cache.getStats();

                this.statsDisplay.innerHTML = `
                    <div class="stats-content">
                        <h3>Статистика кеширования:</h3>
                        <ul>
                            <li>Размер кеша: ${stats.size}</li>
                            <li>Хиты: ${stats.hits}</li>
                            <li>Миссы: ${stats.misses}</li>
                            <li>Записи: ${stats.sets}</li>
                            <li>Удаления: ${stats.evictions}</li>
                            <li>Процент хитов: ${stats.hitRate}</li>
                        </ul>
                    </div>
                `;
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new DataCacheManager();
        });
    </script>

    <style>
        .cache-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #007acc;
            color: white;
        }

        .data-content, .loading, .error, .stats-content {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .loading {
            text-align: center;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background-color: #ffebee;
            color: #c62828;
        }

        .stats-content ul {
            list-style: none;
            padding: 0;
        }

        .stats-content li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .stats-content li:last-child {
            border-bottom: none;
        }

        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
    </style>
</body>
</html>
```

## Проверка и тестирование производительности

### Инструменты для проверки производительности:
1. **Chrome DevTools Performance** - для анализа производительности
2. **Lighthouse** - для комплексной проверки производительности
3. **WebPageTest** - для анализа загрузки страницы
4. **GTmetrix** - для анализа производительности и оптимизации
5. **PageSpeed Insights** - для рекомендаций по производительности
6. **BundlePhobia** - для проверки размера зависимостей
7. **Sizze** - для проверки размера файлов
8. **Calibre** - для мониторинга производительности

### Метрики производительности:
1. **First Contentful Paint (FCP)** - время до первого содержательного рендера
2. **Largest Contentful Paint (LCP)** - время до рендера самого большого элемента
3. **Cumulative Layout Shift (CLS)** - суммарный сдвиг макета
4. **First Input Delay (FID)** - задержка первого ввода
5. **Time to Interactive (TTI)** - время до интерактивности
6. **Total Blocking Time (TBT)** - общее время блокировки

### Проверка производительности DOM:
1. Избегать частых reflows и repaints
2. Использовать DocumentFragment для массовых изменений
3. Минимизировать манипуляции с DOM
4. Использовать CSS transform вместо изменения layout свойств
5. Оптимизировать обработку событий
6. Использовать делегирование событий
7. Использовать requestAnimationFrame для анимаций

### Проверка производительности ресурсов:
1. Оптимизация размера изображений
2. Использование современных форматов (WebP, AVIF)
3. lazy loading для изображений вне области видимости
4. Оптимизация размера JavaScript и CSS файлов
5. Использование tree shaking для удаления неиспользуемого кода
6. Минификация и сжатие ресурсов
7. Использование CDN для статических ресурсов
8. Оптимизация загрузки шрифтов

## Лучшие практики производительности HTML

### 1. Оптимизация структуры DOM
```html
<!-- Правильно: минимальная вложенность -->
<div class="content-wrapper">
    <h1>Заголовок</h1>
    <p>Содержимое</p>
</div>

<!-- Плохо: избыточная вложенность -->
<div class="outer-wrapper">
    <div class="inner-wrapper">
        <div class="content-container">
            <div class="content-wrapper">
                <h1>Заголовок</h1>
                <p>Содержимое</p>
            </div>
        </div>
    </div>
</div>
```

### 2. Эффективная работа с событиями
```javascript
// Правильно: делегирование событий
document.getElementById('list-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('list-item')) {
        handleItemClick(e.target);
    }
});

// Плохо: привязка обработчика к каждому элементу
document.querySelectorAll('.list-item').forEach(item => {
    item.addEventListener('click', () => handleItemClick(item));
});
```

### 3. Использование CSS для производительности
```css
/* Правильно: использование transform для анимаций */
.animated-element {
    transition: transform 0.3s ease;
}

.animated-element:hover {
    transform: scale(1.05);
}

/* Плохо: изменение layout свойств */
.bad-animation {
    transition: width 0.3s ease, height 0.3s ease;
}
```

### 4. Оптимизация загрузки шрифтов
```html
<!-- Оптимизация загрузки шрифтов -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
```

### 5. Использование современных форматов изображений
```html
<!-- Использование современных форматов -->
<picture>
    <source srcset="image.avif" type="image/avif">
    <source srcset="image.webp" type="image/webp">
    <img src="image.jpg" alt="Описание изображения" loading="lazy">
</picture>
```

## Современные возможности производительности HTML

### Web Workers для тяжелых вычислений

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Web Workers и производительность</title>
</head>
<body>
    <h1>Web Workers для тяжелых вычислений</h1>

    <div class="workers-demo">
        <div class="controls">
            <button id="compute-main">Вычисление в основном потоке</button>
            <button id="compute-worker">Вычисление в Web Worker</button>
            <button id="compare-performance">Сравнить производительность</button>
        </div>

        <div class="results">
            <div id="main-result"></div>
            <div id="worker-result"></div>
            <div id="comparison-result"></div>
        </div>
    </div>

    <script>
        // Код для Web Worker (в реальном приложении - отдельный файл)
        const workerCode = `
            // worker.js
            self.onmessage = function(e) {
                const { operation, data, id } = e.data;

                let result;

                switch(operation) {
                    case 'fibonacci':
                        result = calculateFibonacci(data);
                        break;
                    case 'sort':
                        result = data.sort((a, b) => a - b);
                        break;
                    case 'filter':
                        result = data.filter(num => num % 2 === 0);
                        break;
                    case 'hash':
                        result = calculateHash(data);
                        break;
                    case 'prime':
                        result = findPrimes(data);
                        break;
                    default:
                        result = 'Неизвестная операция';
                }

                self.postMessage({ operation, result, id, timestamp: Date.now() });
            };

            function calculateFibonacci(n) {
                if (n <= 1) return n;
                return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);
            }

            function calculateHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Конвертация в 32-битное целое
                }
                return hash;
            }

            function findPrimes(limit) {
                const primes = [];
                for (let i = 2; i <= limit; i++) {
                    if (isPrime(i)) {
                        primes.push(i);
                    }
                }
                return primes;
            }

            function isPrime(num) {
                for (let i = 2; i <= Math.sqrt(num); i++) {
                    if (num % i === 0) return false;
                }
                return num > 1;
            }
        `;

        class PerformanceOptimizer {
            constructor() {
                this.worker = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('compute-main').addEventListener('click', () => {
                    this.computeOnMainThread();
                });

                document.getElementById('compute-worker').addEventListener('click', () => {
                    this.computeOnWorkerThread();
                });

                document.getElementById('compare-performance').addEventListener('click', () => {
                    this.comparePerformance();
                });
            }

            async computeOnMainThread() {
                const startTime = performance.now();
                const resultElement = document.getElementById('main-result');

                resultElement.innerHTML = '<div class="loading">Вычисление в основном потоке...</div>';

                try {
                    // Тяжелое вычисление в основном потоке (блокирует UI)
                    const result = this.calculateFibonacci(35); // Это займет время и заблокирует UI

                    const endTime = performance.now();

                    resultElement.innerHTML = `
                        <div class="result">
                            <h3>Результат (основной поток):</h3>
                            <p>Число Фибоначчи: ${result}</p>
                            <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                            <p>Поток UI заблокирован</p>
                        </div>
                    `;
                } catch (error) {
                    resultElement.innerHTML = `<div class="error">Ошибка: ${error.message}</div>`;
                }
            }

            async computeOnWorkerThread() {
                const startTime = performance.now();
                const resultElement = document.getElementById('worker-result');

                resultElement.innerHTML = '<div class="loading">Вычисление в Web Worker...</div>';

                try {
                    if (!this.worker) {
                        const blob = new Blob([workerCode], { type: 'application/javascript' });
                        this.worker = new Worker(URL.createObjectURL(blob));

                        this.worker.onmessage = (e) => {
                            const { result, operation, timestamp } = e.data;
                            const endTime = performance.now();

                            resultElement.innerHTML = `
                                <div class="result">
                                    <h3>Результат (Web Worker):</h3>
                                    <p>Операция: ${operation}</p>
                                    <p>Результат: ${result}</p>
                                    <p>Время выполнения: ${(endTime - startTime).toFixed(2)}ms</p>
                                    <p>Поток UI не заблокирован</p>
                                </div>
                            `;
                        };
                    }

                    // Отправляем задачу в worker
                    this.worker.postMessage({
                        operation: 'fibonacci',
                        data: 35,
                        id: 'fibonacci-test'
                    });

                } catch (error) {
                    resultElement.innerHTML = `<div class="error">Ошибка: ${error.message}</div>`;
                }
            }

            async comparePerformance() {
                const comparisonElement = document.getElementById('comparison-result');
                comparisonElement.innerHTML = '<div class="loading">Сравнение производительности...</div>';

                const startTime = performance.now();

                // Вычисления в основном потоке
                const mainResult = this.calculateFibonacci(30);
                const mainThreadTime = performance.now() - startTime;

                // Вычисления в worker
                const workerStartTime = performance.now();
                const workerPromise = new Promise(resolve => {
                    if (!this.worker) {
                        const blob = new Blob([workerCode], { type: 'application/javascript' });
                        this.worker = new Worker(URL.createObjectURL(blob));

                        this.worker.onmessage = (e) => {
                            if (e.data.operation === 'fibonacci-compare') {
                                resolve(e.data.result);
                            }
                        };
                    }

                    this.worker.postMessage({
                        operation: 'fibonacci-compare',
                        data: 30,
                        id: 'compare-test'
                    });
                });

                const workerResult = await workerPromise;
                const workerTime = performance.now() - workerStartTime;

                comparisonElement.innerHTML = `
                    <div class="comparison-results">
                        <h3>Сравнение производительности:</h3>
                        <div class="comparison-item">
                            <strong>Основной поток:</strong> ${(mainThreadTime).toFixed(2)}ms
                        </div>
                        <div class="comparison-item">
                            <strong>Web Worker:</strong> ${(workerTime).toFixed(2)}ms
                        </div>
                        <div class="comparison-item">
                            <strong>Разница:</strong> ${Math.abs(mainThreadTime - workerTime).toFixed(2)}ms
                        </div>
                        <div class="comparison-item">
                            <strong>UI заблокирован:</strong> ${mainThreadTime > workerTime ? 'Да' : 'Нет'}
                        </div>
                    </div>
                `;
            }

            calculateFibonacci(n) {
                if (n <= 1) return n;
                return this.calculateFibonacci(n - 1) + this.calculateFibonacci(n - 2);
            }

            // Методы для других операций
            sortData(data) {
                return data.sort((a, b) => a - b);
            }

            filterData(data) {
                return data.filter(num => num % 2 === 0);
            }

            calculateHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash;
            }

            findPrimes(limit) {
                const primes = [];
                for (let i = 2; i <= limit; i++) {
                    if (this.isPrime(i)) {
                        primes.push(i);
                    }
                }
                return primes;
            }

            isPrime(num) {
                for (let i = 2; i <= Math.sqrt(num); i++) {
                    if (num % i === 0) return false;
                }
                return num > 1;
            }
        }

        // Инициализация
        const perfOptimizer = new PerformanceOptimizer();
    </script>

    <style>
        .workers-demo {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .result {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 20px;
            border-radius: 4px;
        }

        .comparison-results {
            background-color: #e8f5e8;
            border: 1px solid #c8e6c9;
            border-radius: 8px;
            padding: 20px;
        }

        .comparison-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-item:last-child {
            border-bottom: none;
        }
    </style>
</body>
</html>
```

### WebAssembly для высокопроизводительных операций

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebAssembly и производительность</title>
</head>
<body>
    <h1>WebAssembly для высокопроизводительных операций</h1>

    <div class="wasm-performance-demo">
        <div class="controls">
            <button onclick="computeWithJS()">Вычисления с JavaScript</button>
            <button onclick="computeWithWASM()">Вычисления с WebAssembly</button>
            <button onclick="comparePerformance()">Сравнить производительность</button>
        </div>

        <div class="results">
            <div id="js-result"></div>
            <div id="wasm-result"></div>
            <div id="performance-comparison"></div>
        </div>
    </div>

    <script>
        class WASMPerformanceOptimizer {
            constructor() {
                this.wasmModule = null;
                this.isWASMReady = false;

                this.loadWASM();
            }

            async loadWASM() {
                try {
                    // В реальном приложении загрузка настоящего WASM модуля
                    // const wasmModule = await WebAssembly.instantiateStreaming(fetch('math.wasm'));

                    // Для демонстрации создаем mock-модуль
                    this.wasmModule = {
                        exports: {
                            fibonacci: (n) => this.fibonacciJS(n),
                            primeCheck: (n) => this.isPrimeJS(n),
                            factorial: (n) => this.factorialJS(n),
                            matrixMultiply: (size) => this.matrixMultiplyJS(size)
                        }
                    };

                    this.isWASMReady = true;
                    console.log('WebAssembly mock-модуль загружен');
                } catch (error) {
                    console.error('Ошибка загрузки WebAssembly:', error);
                }
            }

            // Вычисления с JavaScript
            fibonacciJS(n) {
                if (n <= 1) return n;
                return this.fibonacciJS(n - 1) + this.fibonacciJS(n - 2);
            }

            isPrimeJS(n) {
                if (n <= 1) return false;
                if (n <= 3) return true;
                if (n % 2 === 0 || n % 3 === 0) return false;

                for (let i = 5; i * i <= n; i += 6) {
                    if (n % i === 0 || n % (i + 2) === 0) return false;
                }
                return true;
            }

            factorialJS(n) {
                if (n <= 1) return 1;
                return n * this.factorialJS(n - 1);
            }

            matrixMultiplyJS(size) {
                // Создаем две матрицы размером size x size
                const a = Array.from({ length: size }, () =>
                    Array.from({ length: size }, () => Math.random())
                );

                const b = Array.from({ length: size }, () =>
                    Array.from({ length: size }, () => Math.random())
                );

                const result = Array.from({ length: size }, () =>
                    Array.from({ length: size }, () => 0)
                );

                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        for (let k = 0; k < size; k++) {
                            result[i][j] += a[i][k] * b[k][j];
                        }
                    }
                }

                return result;
            }

            // Вычисления с WebAssembly (mock)
            async computeWithWASM(operation, data) {
                if (!this.isWASMReady) {
                    throw new Error('WebAssembly модуль не загружен');
                }

                const startTime = performance.now();

                let result;
                switch(operation) {
                    case 'fibonacci':
                        result = this.wasmModule.exports.fibonacci(data);
                        break;
                    case 'prime':
                        result = this.wasmModule.exports.primeCheck(data);
                        break;
                    case 'factorial':
                        result = this.wasmModule.exports.factorial(data);
                        break;
                    case 'matrix':
                        result = this.wasmModule.exports.matrixMultiply(data);
                        break;
                }

                const endTime = performance.now();

                return {
                    result: result,
                    time: endTime - startTime
                };
            }

            // Вычисления с JavaScript
            async computeWithJS(operation, data) {
                const startTime = performance.now();

                let result;
                switch(operation) {
                    case 'fibonacci':
                        result = this.fibonacciJS(data);
                        break;
                    case 'prime':
                        result = this.isPrimeJS(data);
                        break;
                    case 'factorial':
                        result = this.factorialJS(data);
                        break;
                    case 'matrix':
                        result = this.matrixMultiplyJS(data);
                        break;
                }

                const endTime = performance.now();

                return {
                    result: result,
                    time: endTime - startTime
                };
            }

            async comparePerformance() {
                const comparisonResult = document.getElementById('performance-comparison');
                comparisonResult.innerHTML = '<div class="loading">Сравнение производительности...</div>';

                try {
                    // Сравнение различных операций
                    const operations = [
                        { name: 'Фибоначчи', operation: 'fibonacci', data: 30 },
                        { name: 'Проверка простого числа', operation: 'prime', data: 982451653 },
                        { name: 'Факториал', operation: 'factorial', data: 20 },
                        { name: 'Умножение матриц', operation: 'matrix', data: 100 }
                    ];

                    let comparisonHTML = '<div class="comparison-results"><h3>Сравнение производительности:</h3>';

                    for (const op of operations) {
                        const jsResult = await this.computeWithJS(op.operation, op.data);
                        const wasmResult = await this.computeWithWASM(op.operation, op.data);

                        const improvement = ((jsResult.time - wasmResult.time) / jsResult.time * 100).toFixed(2);
                        const isFaster = wasmResult.time < jsResult.time;

                        comparisonHTML += `
                            <div class="operation-comparison">
                                <h4>${op.name}</h4>
                                <div class="comparison-row">
                                    <div class="comparison-item">
                                        <strong>JavaScript:</strong> ${jsResult.time.toFixed(2)}ms
                                    </div>
                                    <div class="comparison-item">
                                        <strong>WebAssembly:</strong> ${wasmResult.time.toFixed(2)}ms
                                    </div>
                                    <div class="comparison-item">
                                        <strong>Улучшение:</strong> ${improvement}% ${isFaster ? 'быстрее' : 'медленнее'}
                                    </div>
                                </div>
                            </div>
                        `;
                    }

                    comparisonHTML += '</div>';
                    comparisonResult.innerHTML = comparisonHTML;
                } catch (error) {
                    comparisonResult.innerHTML = `<div class="error">Ошибка сравнения: ${error.message}</div>`;
                }
            }
        }

        // Инициализация
        const wasmOptimizer = new WASMPerformanceOptimizer();

        async function computeWithJS() {
            const result = await wasmOptimizer.computeWithJS('fibonacci', 30);
            document.getElementById('js-result').innerHTML = `
                <div class="result">
                    <h3>JavaScript результат:</h3>
                    <p>Фибоначчи(30) = ${result.result}</p>
                    <p>Время: ${result.time.toFixed(2)}ms</p>
                </div>
            `;
        }

        async function computeWithWASM() {
            const result = await wasmOptimizer.computeWithWASM('fibonacci', 30);
            document.getElementById('wasm-result').innerHTML = `
                <div class="result">
                    <h3>WebAssembly результат:</h3>
                    <p>Фибоначчи(30) = ${result.result}</p>
                    <p>Время: ${result.time.toFixed(2)}ms</p>
                </div>
            `;
        }

        async function comparePerformance() {
            await wasmOptimizer.comparePerformance();
        }
    </script>

    <style>
        .wasm-performance-demo {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .result {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 20px;
            border-radius: 4px;
        }

        .comparison-results {
            background-color: #f0f8ff;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 20px;
        }

        .operation-comparison {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e3f2fd;
            border-radius: 4px;
        }

        .comparison-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .comparison-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-item:last-child {
            border-bottom: none;
        }
    </style>
</body>
</html>
```

### Intersection Observer для оптимизации производительности

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Intersection Observer и производительность</title>
</head>
<body>
    <h1>Intersection Observer для оптимизации производительности</h1>

    <div class="observer-demo">
        <div class="controls">
            <button onclick="addElements()">Добавить элементы</button>
            <button onclick="clearElements()">Очистить</button>
        </div>

        <div id="content-container">
            <div class="initial-content">
                <h2>Начальный контент</h2>
                <p>Прокрутите вниз, чтобы увидеть лениво загружаемые элементы.</p>
            </div>
        </div>
    </div>

    <script>
        class IntersectionOptimizer {
            constructor() {
                this.container = document.getElementById('content-container');
                this.elementsAdded = 0;
                this.setupObserver();
            }

            setupObserver() {
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.handleElementIntersection(entry.target);
                        }
                    });
                }, {
                    rootMargin: '100px', // Начинать загрузку за 100px до появления
                    threshold: 0.1       // 10% элемента должно быть видно
                });
            }

            addElements(count = 5) {
                for (let i = 0; i < count; i++) {
                    this.elementsAdded++;

                    const element = document.createElement('div');
                    element.className = 'lazy-element';
                    element.dataset.index = this.elementsAdded;
                    element.innerHTML = `
                        <div class="element-header">
                            <h3>Элемент ${this.elementsAdded}</h3>
                        </div>
                        <div class="element-content">
                            <p>Этот элемент будет загружен при появлении в области видимости.</p>
                            <img src="https://via.placeholder.com/300x200?text=Image+${this.elementsAdded}"
                                 alt="Изображение ${this.elementsAdded}"
                                 loading="lazy">
                        </div>
                    `;

                    // Добавляем элемент в DOM, но не загружаем его содержимое до пересечения
                    element.style.opacity = '0';
                    element.style.transform = 'translateY(20px)';
                    element.style.transition = 'opacity 0.3s, transform 0.3s';

                    this.container.appendChild(element);

                    // Наблюдаем за элементом
                    this.observer.observe(element);
                }
            }

            handleElementIntersection(element) {
                // Загрузка содержимого при пересечении
                element.style.opacity = '1';
                element.style.transform = 'translateY(0)';

                // Дополнительная логика загрузки
                this.loadElementContent(element);

                // Останавливаем наблюдение за элементом после загрузки
                this.observer.unobserve(element);
            }

            loadElementContent(element) {
                const index = element.dataset.index;

                // Имитация загрузки контента
                setTimeout(() => {
                    const contentDiv = element.querySelector('.element-content');
                    if (contentDiv) {
                        contentDiv.innerHTML += `
                            <p class="loaded-content">Контент элемента ${index} загружен при пересечении.</p>
                            <div class="element-stats">
                                <p>Время загрузки: ${new Date().toLocaleTimeString()}</p>
                                <p>Индекс: ${index}</p>
                            </div>
                        `;
                    }
                }, 100);
            }

            clearElements() {
                // Очищаем контейнер
                const initialContent = document.querySelector('.initial-content');
                this.container.innerHTML = '';
                this.container.appendChild(initialContent);

                // Очищаем наблюдатель
                this.observer.disconnect();

                this.elementsAdded = 0;
            }
        }

        // Инициализация
        const observerOptimizer = new IntersectionOptimizer();

        function addElements() {
            observerOptimizer.addElements(5);
        }

        function clearElements() {
            observerOptimizer.clearElements();
        }
    </script>

    <style>
        .observer-demo {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls button {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .initial-content {
            padding: 20px;
            background-color: #e3f2fd;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .lazy-element {
            padding: 20px;
            margin-bottom: 20px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .element-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .element-content img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 4px;
            margin-top: 15px;
        }

        .loaded-content {
            color: #2e7d32;
            font-weight: bold;
        }

        .element-stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</body>
</html>
```

## Практические примеры и шаблоны

### Шаблон производительной карточки товара
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Производительная карточка товара</title>
</head>
<body>
    <h1>Производительные карточки товаров</h1>

    <div id="products-grid" class="products-grid"></div>

    <template id="product-card-template">
        <div class="product-card" data-product-id="">
            <div class="product-image-container">
                <img class="product-image"
                     src=""
                     alt=""
                     loading="lazy"
                     decoding="async">
            </div>
            <div class="product-info">
                <h3 class="product-title"></h3>
                <p class="product-description"></p>
                <div class="product-price-container">
                    <span class="product-price"></span>
                    <span class="product-old-price" style="display: none;"></span>
                </div>
                <div class="product-rating">
                    <span class="rating-stars"></span>
                    <span class="rating-count"></span>
                </div>
                <div class="product-actions">
                    <button class="add-to-cart">Добавить в корзину</button>
                    <button class="add-to-wishlist">В избранное</button>
                </div>
            </div>
        </div>
    </template>

    <script>
        class OptimizedProductCard {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.template = document.getElementById('product-card-template');
                this.products = [];
            }

            addProduct(product) {
                const clone = this.template.content.cloneNode(true);

                // Заполнение данных
                const card = clone.querySelector('.product-card');
                card.dataset.productId = product.id;

                const image = clone.querySelector('.product-image');
                image.src = product.image;
                image.alt = product.title;

                clone.querySelector('.product-title').textContent = product.title;
                clone.querySelector('.product-description').textContent = product.description;
                clone.querySelector('.product-price').textContent = this.formatPrice(product.price);

                if (product.oldPrice) {
                    const oldPrice = clone.querySelector('.product-old-price');
                    oldPrice.textContent = this.formatPrice(product.oldPrice);
                    oldPrice.style.display = 'inline';
                    oldPrice.style.textDecoration = 'line-through';
                    oldPrice.style.marginLeft = '10px';
                }

                // Установка рейтинга
                if (product.rating) {
                    const stars = clone.querySelector('.rating-stars');
                    stars.innerHTML = this.generateStars(product.rating);

                    const count = clone.querySelector('.rating-count');
                    count.textContent = `(${product.reviewCount || 0} отзывов)`;
                }

                // Добавление обработчиков событий
                clone.querySelector('.add-to-cart').addEventListener('click', () => {
                    this.handleAddToCart(product);
                });

                clone.querySelector('.add-to-wishlist').addEventListener('click', () => {
                    this.handleAddToWishlist(product);
                });

                this.container.appendChild(clone);
            }

            formatPrice(price) {
                return new Intl.NumberFormat('ru-RU', {
                    style: 'currency',
                    currency: 'RUB'
                }).format(price);
            }

            generateStars(rating) {
                const fullStars = Math.floor(rating);
                const halfStar = rating % 1 >= 0.5;
                const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);

                let stars = '★'.repeat(fullStars);
                if (halfStar) stars += '☆';
                stars += '☆'.repeat(emptyStars);

                return stars;
            }

            handleAddToCart(product) {
                console.log('Добавление в корзину:', product.title);

                // В реальном приложении - добавление в корзину с оптимизацией
                this.optimizeCartUpdate(product);
            }

            handleAddToWishlist(product) {
                console.log('Добавление в избранное:', product.title);

                // В реальном приложении - добавление в избранное
            }

            optimizeCartUpdate(product) {
                // Оптимизация обновления корзины
                requestAnimationFrame(() => {
                    // Обновление DOM в следующем цикле рендеринга
                    this.updateCartBadge();
                });
            }

            updateCartBadge() {
                // Обновление индикатора корзины
                const badge = document.getElementById('cart-badge');
                if (badge) {
                    const currentCount = parseInt(badge.textContent) || 0;
                    badge.textContent = currentCount + 1;
                }
            }

            addProducts(products) {
                // Используем DocumentFragment для эффективного добавления
                const fragment = document.createDocumentFragment();

                products.forEach(product => {
                    const clone = this.template.content.cloneNode(true);

                    // Заполнение данных
                    clone.querySelector('.product-card').dataset.productId = product.id;
                    clone.querySelector('.product-image').src = product.image;
                    clone.querySelector('.product-image').alt = product.title;
                    clone.querySelector('.product-title').textContent = product.title;
                    clone.querySelector('.product-description').textContent = product.description;
                    clone.querySelector('.product-price').textContent = this.formatPrice(product.price);

                    if (product.oldPrice) {
                        const oldPrice = clone.querySelector('.product-old-price');
                        oldPrice.textContent = this.formatPrice(product.oldPrice);
                        oldPrice.style.display = 'inline';
                    }

                    if (product.rating) {
                        clone.querySelector('.rating-stars').innerHTML = this.generateStars(product.rating);
                        clone.querySelector('.rating-count').textContent = `(${product.reviewCount || 0} отзывов)`;
                    }

                    // Добавление обработчиков
                    clone.querySelector('.add-to-cart').addEventListener('click', () => {
                        this.handleAddToCart(product);
                    });

                    clone.querySelector('.add-to-wishlist').addEventListener('click', () => {
                        this.handleAddToWishlist(product);
                    });

                    fragment.appendChild(clone);
                });

                this.container.appendChild(fragment);
            }
        }

        // Инициализация
        const productCard = new OptimizedProductCard('products-grid');

        // Пример данных
        const sampleProducts = [
            {
                id: 1,
                title: 'Смартфон iPhone 15',
                description: 'Новейший iPhone с передовыми технологиями',
                price: 99990,
                image: 'https://via.placeholder.com/300x300/4ECDC4/FFFFFF?text=iPhone',
                rating: 4.8,
                reviewCount: 124
            },
            {
                id: 2,
                title: 'Ноутбук MacBook Air',
                description: 'Ультрабук для работы и развлечений',
                price: 89990,
                image: 'https://via.placeholder.com/300x300/45B7D1/FFFFFF?text=MacBook',
                rating: 4.7,
                reviewCount: 89
            },
            {
                id: 3,
                title: 'Планшет iPad Pro',
                description: 'Профессиональный планшет для творчества',
                price: 79990,
                oldPrice: 84990,
                image: 'https://via.placeholder.com/300x300/96CEB4/FFFFFF?text=iPad',
                rating: 4.9,
                reviewCount: 210
            }
        ];

        // Добавление продуктов
        productCard.addProducts(sampleProducts);
    </script>

    <style>
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            padding: 20px;
        }

        .product-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .product-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }

        .product-image-container {
            height: 200px;
            overflow: hidden;
        }

        .product-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s;
        }

        .product-card:hover .product-image {
            transform: scale(1.05);
        }

        .product-info {
            padding: 15px;
        }

        .product-title {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #333;
        }

        .product-description {
            color: #666;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .product-price-container {
            margin-bottom: 10px;
        }

        .product-price {
            font-size: 1.3em;
            font-weight: bold;
            color: #007acc;
        }

        .product-old-price {
            color: #999;
            margin-left: 10px;
        }

        .product-rating {
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .rating-stars {
            color: #ffc107;
        }

        .rating-count {
            color: #666;
            margin-left: 5px;
        }

        .product-actions {
            display: flex;
            gap: 10px;
        }

        .add-to-cart, .add-to-wishlist {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .add-to-cart {
            background-color: #007acc;
            color: white;
        }

        .add-to-wishlist {
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ddd;
        }
    </style>
</body>
</html>
```

### Производительная виртуальная таблица
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Производительная виртуальная таблица</title>
</head>
<body>
    <h1>Производительная виртуальная таблица</h1>

    <div class="table-container">
        <div class="table-controls">
            <input type="text" id="search-input" placeholder="Поиск...">
            <select id="sort-column">
                <option value="id">ID</option>
                <option value="name">Имя</option>
                <option value="email">Email</option>
                <option value="date">Дата</option>
            </select>
            <button id="sort-direction">↑</button>
        </div>

        <div class="virtual-table-container">
            <div id="virtual-table" class="virtual-table" style="height: 500px; overflow-y: auto;"></div>
        </div>

        <div id="table-stats" class="table-stats"></div>
    </div>

    <script>
        class VirtualTable {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.data = [];
                this.filteredData = [];
                this.visibleStart = 0;
                this.visibleEnd = 0;
                this.itemHeight = 50;
                this.sortColumn = 'id';
                this.sortDirection = 'asc';

                this.generateSampleData(10000); // 10k строк для демонстрации
                this.filteredData = [...this.data];

                this.setupEventListeners();
                this.render();
            }

            generateSampleData(count) {
                const names = ['Иван', 'Мария', 'Алексей', 'Елена', 'Дмитрий', 'Анна', 'Сергей', 'Ольга'];
                const domains = ['example.com', 'mail.ru', 'gmail.com', 'yandex.ru'];

                this.data = Array.from({ length: count }, (_, i) => ({
                    id: i + 1,
                    name: `${names[i % names.length]} ${names[(i + 1) % names.length]}${i % 100}`,
                    email: `user${i}@${domains[i % domains.length]}`,
                    date: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    status: ['active', 'inactive', 'pending'][i % 3]
                }));
            }

            setupEventListeners() {
                this.container.addEventListener('scroll', this.throttle(() => {
                    this.updateVisibleRange();
                }, 16)); // ~60fps

                document.getElementById('search-input').addEventListener('input', this.debounce((e) => {
                    this.filterData(e.target.value);
                }, 300));

                document.getElementById('sort-column').addEventListener('change', (e) => {
                    this.sortColumn = e.target.value;
                    this.sortData();
                });

                document.getElementById('sort-direction').addEventListener('click', () => {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    document.getElementById('sort-direction').textContent = this.sortDirection === 'asc' ? '↑' : '↓';
                    this.sortData();
                });
            }

            updateVisibleRange() {
                const scrollTop = this.container.scrollTop;
                const containerHeight = this.container.clientHeight;

                this.visibleStart = Math.floor(scrollTop / this.itemHeight);
                this.visibleEnd = Math.min(
                    this.filteredData.length,
                    Math.ceil((scrollTop + containerHeight) / this.itemHeight) + 1
                );

                this.render();
            }

            filterData(searchTerm) {
                if (!searchTerm) {
                    this.filteredData = [...this.data];
                } else {
                    const term = searchTerm.toLowerCase();
                    this.filteredData = this.data.filter(row =>
                        Object.values(row).some(value =>
                            String(value).toLowerCase().includes(term)
                        )
                    );
                }

                this.visibleStart = 0;
                this.visibleEnd = Math.min(50, this.filteredData.length); // 50 элементов по умолчанию
                this.render();
                this.updateStats();
            }

            sortData() {
                this.filteredData.sort((a, b) => {
                    const aVal = a[this.sortColumn];
                    const bVal = b[this.sortColumn];

                    let result = 0;
                    if (aVal < bVal) result = -1;
                    if (aVal > bVal) result = 1;

                    return this.sortDirection === 'asc' ? result : -result;
                });

                this.render();
            }

            render() {
                this.container.innerHTML = '';

                // Создаем верхний спейсер
                const topSpacer = document.createElement('div');
                topSpacer.style.height = `${this.visibleStart * this.itemHeight}px`;
                topSpacer.className = 'spacer';

                // Создаем видимые элементы
                for (let i = this.visibleStart; i < this.visibleEnd; i++) {
                    const row = this.createRow(this.filteredData[i], i);
                    this.container.appendChild(row);
                }

                // Создаем нижний спейсер
                const bottomHeight = (this.filteredData.length - this.visibleEnd) * this.itemHeight;
                if (bottomHeight > 0) {
                    const bottomSpacer = document.createElement('div');
                    bottomSpacer.style.height = `${bottomHeight}px`;
                    bottomSpacer.className = 'spacer';
                    this.container.appendChild(bottomSpacer);
                }

                this.container.prepend(topSpacer);
            }

            createRow(rowData, index) {
                const row = document.createElement('div');
                row.className = 'table-row';
                row.style.cssText = `
                    height: ${this.itemHeight}px;
                    display: flex;
                    align-items: center;
                    border-bottom: 1px solid #eee;
                    padding: 0 15px;
                `;

                row.innerHTML = `
                    <div class="cell" style="width: 10%;">${rowData.id}</div>
                    <div class="cell" style="width: 25%;">${rowData.name}</div>
                    <div class="cell" style="width: 30%;">${rowData.email}</div>
                    <div class="cell" style="width: 20%;">${rowData.date}</div>
                    <div class="cell" style="width: 15%;">
                        <span class="status status-${rowData.status}">${rowData.status}</span>
                    </div>
                `;

                return row;
            }

            updateStats() {
                const stats = document.getElementById('table-stats');
                stats.innerHTML = `
                    <p>Всего записей: ${this.filteredData.length}</p>
                    <p>Отображается: ${this.visibleEnd - this.visibleStart}</p>
                    <p>Видимый диапазон: ${this.visibleStart + 1} - ${this.visibleEnd}</p>
                `;
            }

            throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            new VirtualTable('virtual-table');
        });
    </script>

    <style>
        .table-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .table-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .table-controls input, .table-controls select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .table-controls button {
            padding: 8px 12px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .virtual-table-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .virtual-table {
            width: 100%;
        }

        .table-row {
            display: flex;
            border-bottom: 1px solid #eee;
        }

        .table-row:nth-child(even) {
            background-color: #f9f9f9;
        }

        .table-row:hover {
            background-color: #f0f8ff;
        }

        .cell {
            padding: 8px;
            flex: 1;
        }

        .status {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .status-active {
            background-color: #d4edda;
            color: #155724;
        }

        .status-inactive {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status-pending {
            background-color: #fff3cd;
            color: #856404;
        }

        .table-stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            display: flex;
            gap: 20px;
        }

        .spacer {
            width: 100%;
        }
    </style>
</body>
</html>
```

## Проверка и тестирование производительности

### Инструменты для проверки производительности:
1. **Chrome DevTools Performance** - для анализа производительности
2. **Lighthouse** - для комплексной проверки производительности
3. **WebPageTest** - для анализа загрузки страницы
4. **GTmetrix** - для анализа производительности и оптимизации
5. **PageSpeed Insights** - для рекомендаций по производительности
6. **BundlePhobia** - для проверки размера зависимостей
7. **Sizze** - для проверки размера файлов
8. **Calibre** - для мониторинга производительности
9. **Sitespeed.io** - для автоматизированного тестирования производительности
10. **Webhint** - для проверки рекомендаций по производительности

### Проверка производительности DOM:
1. Избегать частых reflows и repaints
2. Использовать DocumentFragment для массовых изменений
3. Минимизировать манипуляции с DOM
4. Использовать CSS transform вместо изменения layout свойств
5. Оптимизировать обработку событий
6. Использовать делегирование событий
7. Использовать requestAnimationFrame для анимаций
8. Использовать виртуальный скроллинг для больших списков

### Проверка производительности ресурсов:
1. Оптимизация размера изображений
2. Использование современных форматов (WebP, AVIF)
3. Lazy loading изображений вне области видимости
4. Оптимизация размера JavaScript и CSS файлов
5. Использование tree shaking для удаления неиспользуемого кода
6. Минификация и сжатие ресурсов
7. Использование CDN для статических ресурсов
8. Оптимизация загрузки шрифтов
9. Использование HTTP/2 для более эффективной загрузки
10. Оптимизация кеширования с помощью HTTP заголовков

### Проверка производительности JavaScript:
1. Использование Web Workers для тяжелых вычислений
2. Оптимизация алгоритмов и структур данных
3. Управление памятью и предотвращение утечек
4. Оптимизация циклов и обхода DOM
5. Использование эффективных методов массивов
6. Оптимизация обработки событий
7. Использование debounce и throttle для частых операций
8. Оптимизация асинхронных операций

## Лучшие практики производительности HTML

### 1. Оптимизация структуры DOM
```html
<!-- Правильно: минимальная вложенность -->
<div class="content-wrapper">
    <h1>Заголовок</h1>
    <p>Содержимое</p>
</div>

<!-- Плохо: избыточная вложенность -->
<div class="outer-wrapper">
    <div class="inner-wrapper">
        <div class="content-container">
            <div class="content-wrapper">
                <h1>Заголовок</h1>
                <p>Содержимое</p>
            </div>
        </div>
    </div>
</div>
```

### 2. Эффективная обработка событий
```javascript
// Правильно: делегирование событий
document.getElementById('list-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('list-item')) {
        handleItemClick(e.target);
    }
});

// Плохо: привязка обработчика к каждому элементу
document.querySelectorAll('.list-item').forEach(item => {
    item.addEventListener('click', () => handleItemClick(item));
});
```

### 3. Использование CSS для производительности
```css
/* Правильно: использование transform для анимаций */
.animated-element {
    transition: transform 0.3s ease;
}

.animated-element:hover {
    transform: scale(1.05);
}

/* Плохо: изменение layout свойств */
.bad-animation {
    transition: width 0.3s ease, height 0.3s ease;
}
```

### 4. Оптимизация загрузки шрифтов
```html
<!-- Оптимизация загрузки шрифтов -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
```

### 5. Использование современных форматов изображений
```html
<!-- Использование современных форматов -->
<picture>
    <source srcset="image.avif" type="image/avif">
    <source srcset="image.webp" type="image/webp">
    <img src="image.jpg" alt="Описание изображения" loading="lazy">
</picture>
```

### 6. Эффективное кеширование
```html
<!-- Кеширование с помощью Service Worker -->
<script>
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
        .then(registration => {
            console.log('SW зарегистрирован: ', registration.scope);
        })
        .catch(error => {
            console.log('SW регистрация не удалась: ', error);
        });
}
</script>
```

### 7. Оптимизация ресурсов с помощью resource hints
```html
<!-- Preload критических ресурсов -->
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="hero-image.jpg" as="image">
<link rel="preload" href="main.js" as="script">

<!-- Prefetch потенциально нужных ресурсов -->
<link rel="prefetch" href="next-page.html">

<!-- Preconnect для внешних доменов -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://api.example.com">
```

### 8. Использование современных API для производительности
```javascript
// Intersection Observer для ленивой загрузки
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            // Загрузка элемента при появлении в области видимости
            loadElement(entry.target);
            observer.unobserve(entry.target);
        }
    });
});

// RequestAnimationFrame для плавных анимаций
function animate() {
    // Обновление анимации
    updateAnimation();

    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// Web Workers для тяжелых вычислений
const worker = new Worker('heavy-computation.js');
worker.postMessage({ data: largeDataset });
worker.onmessage = (e) => {
    // Обработка результата
    processResult(e.data);
};
```

## Заключение

Производительность HTML-страниц - это комплексный подход, который включает в себя оптимизацию структуры документа, загрузки ресурсов, работы с DOM, валидации форм и других аспектов. Современные возможности, такие как Web Workers, WebAssembly, Intersection Observer, requestAnimationFrame и другие, позволяют создавать высокопроизводительные веб-приложения, которые обеспечивают отличный пользовательский опыт.

Ключевые аспекты производительности HTML:
1. Оптимизация загрузки ресурсов
2. Эффективная работа с DOM
3. Использование современных API
4. Кеширование данных и ресурсов
5. Оптимизация изображений
6. Асинхронная загрузка контента
7. Использование веб-компонентов
8. Управление памятью
9. Оптимизация CSS и JavaScript
10. Следование современным веб-стандартам
11. Регулярное тестирование производительности
12. Использование инструментов мониторинга
13. Оптимизация для мобильных устройств
14. Учет различных сетевых условий
15. Использование современных форматов и протоколов

Эти практики обеспечивают создание быстрых, отзывчивых и эффективных веб-приложений, которые работают хорошо на всех устройствах и в различных сетевых условиях.

Современные подходы к производительности включают:
- Использование Web Workers для тяжелых вычислений
- WebAssembly для высокопроизводительных операций
- Intersection Observer для ленивой загрузки
- Virtual scrolling для больших списков
- Efficient DOM manipulation techniques
- Proper caching strategies with Service Workers and IndexedDB
- Optimized resource loading with modern HTML attributes
- Performance monitoring and optimization
- Following web performance best practices and standards
- Using modern CSS layout methods (Grid, Flexbox) for better rendering performance
- Implementing progressive loading techniques
- Optimizing for Core Web Vitals metrics
- Reducing bundle sizes and improving code splitting
- Implementing proper error handling and fallbacks

Эти технологии позволяют создавать действительно высокопроизводительные веб-приложения, которые обеспечивают отличный пользовательский опыт независимо от устройства или условий подключения.

Ключевые принципы производительности:
1. Минимизация количества DOM-элементов
2. Оптимизация количества HTTP-запросов
3. Сокращение времени загрузки ресурсов
4. Эффективное кеширование
5. Оптимизация изображений и медиа
6. Использование современных форматов
7. Управление памятью и предотвращение утечек
8. Оптимизация JavaScript выполнения
9. Следование принципу progressive enhancement
10. Проверка производительности на различных устройствах

Эти принципы помогают создавать веб-приложения, которые быстро загружаются, плавно работают и эффективно используют ресурсы устройства пользователя.

## Следующие темы
- [[доступность]]
- [[совместимость]]
- [[безопасность]]

## Теги
#html #performance #optimization #web-development #frontend #speed #loading #rendering #memory-management #web-components #caching #lazy-loading #resource-hints #metrics #best-practices #web-workers #webassembly #intersection-observer #request-animation-frame #virtual-scrolling #indexeddb #service-workers #modern-web #accessibility #security #core-web-vitals #progressive-enhancement #responsive-design #mobile-optimization #network-conditions #http2 #cdn #compression