---
aliases: [Обработка ответов и ошибок, Обработка ошибок в сетевых запросах, Ошибки HTTP]
tags: [html, networking, javascript, web-development, error-handling]
---

# Обработка ответов и ошибок

## Введение в обработку ответов и ошибок

Обработка ответов и ошибок сетевых запросов является критически важной частью разработки веб-приложений. Неправильная обработка ошибок может привести к плохому пользовательскому опыту, утечке данных или даже безопасности приложения. В этой статье мы рассмотрим, как правильно обрабатывать ответы сервера и ошибки при использовании [[Fetch API]] и [[XMLHttpRequest]].

## Обработка ответов сервера

### Статусы HTTP-ответов

HTTP-ответы содержат статус, который указывает на результат запроса:

- `2xx` - Успешные ответы
  - `200` - OK
  - `201` - Created
  - `204` - No Content
- `3xx` - Перенаправления
  - `301` - Moved Permanently
  - `302` - Found
- `4xx` - Ошибки клиента
  - `400` - Bad Request
  - `401` - Unauthorized
  - `403` - Forbidden
  - `404` - Not Found
  - `422` - Unprocessable Entity
- `5xx` - Ошибки сервера
  - `500` - Internal Server Error
  - `502` - Bad Gateway
  - `503` - Service Unavailable

### Проверка статуса ответа в Fetch API

```javascript
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    
    // ВАЖНО: fetch не отклоняет Promise при HTTP-ошибках!
    if (!response.ok) {
      throw new Error(`HTTP ошибка! статус: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Ошибка при получении данных:', error);
    throw error;
  }
}
```

### Проверка статуса ответа в XMLHttpRequest

```javascript
function xhrRequest(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.open('GET', url);
    
    xhr.onload = function() {
      // Проверка статуса ответа
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const data = JSON.parse(xhr.responseText);
          resolve(data);
        } catch (e) {
          reject(new Error('Ошибка парсинга JSON'));
        }
      } else {
        reject(new Error(`HTTP ошибка: ${xhr.status} - ${xhr.statusText}`));
      }
    };
    
    xhr.onerror = function() {
      reject(new Error('Сетевая ошибка'));
    };
    
    xhr.send();
  });
}
```

## Обработка различных типов ответов

### JSON-ответы

```javascript
async function handleJsonResponse(response) {
  if (!response.ok) {
    // Обработка HTTP-ошибок
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `HTTP ошибка: ${response.status}`);
  }
  
  // Проверка Content-Type заголовка
  const contentType = response.headers.get('content-type');
  if (!contentType || !contentType.includes('application/json')) {
    throw new Error('Ответ не является JSON');
  }
  
  return await response.json();
}
```

### Текстовые ответы

```javascript
async function handleTextResponse(response) {
  if (!response.ok) {
    throw new Error(`HTTP ошибка: ${response.status}`);
  }
  
  return await response.text();
}
```

### Бинарные данные

```javascript
async function handleBlobResponse(response) {
  if (!response.ok) {
    throw new Error(`HTTP ошибка: ${response.status}`);
  }
  
  return await response.blob();
}
```

## Обработка ошибок

### Сетевые ошибки

Сетевые ошибки происходят при проблемах с подключением:

```javascript
async function handleNetworkErrors() {
  try {
    const response = await fetch('/api/data');
    
    if (!response.ok) {
      throw new Error(`HTTP ошибка: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof TypeError) {
      // Сетевая ошибка (например, потеря соединения)
      console.error('Сетевая ошибка:', error.message);
      showNetworkErrorMessage();
    } else {
      // Другие ошибки (включая HTTP-ошибки)
      console.error('Ошибка запроса:', error.message);
      showErrorMessage(error.message);
    }
  }
}

function showNetworkErrorMessage() {
  // Показать пользователю сообщение о сетевой ошибке
  alert('Проверьте подключение к интернету и повторите попытку');
}
```

### Ошибки таймаута

```javascript
// Fetch API не поддерживает таймауты напрямую, но можно реализовать:
async function fetchWithTimeout(url, options = {}, timeout = 8000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error('Время ожидания запроса истекло');
    }
    
    throw error;
  }
}

// Использование
async function fetchDataWithTimeout() {
  try {
    const response = await fetchWithTimeout('/api/data', {}, 5000);
    return await response.json();
  } catch (error) {
    console.error('Ошибка:', error.message);
    // Обработка ошибки таймаута
  }
}
```

### Обработка специфичных HTTP-ошибок

```javascript
async function handleSpecificErrors() {
  try {
    const response = await fetch('/api/protected-data');
    
    if (!response.ok) {
      switch (response.status) {
        case 400:
          const errorData = await response.json();
          throw new Error(`Неверный запрос: ${errorData.message}`);
        case 401:
          // Пользователь не авторизован
          redirectToLogin();
          return;
        case 403:
          throw new Error('У вас нет прав для доступа к этим данным');
        case 404:
          throw new Error('Запрашиваемый ресурс не найден');
        case 429:
          throw new Error('Слишком много запросов. Попробуйте позже');
        case 500:
          throw new Error('Внутренняя ошибка сервера. Попробуйте позже');
        default:
          throw new Error(`HTTP ошибка: ${response.status}`);
      }
    }
    
    return await response.json();
  } catch (error) {
    if (error.message.includes('Network Error')) {
      console.error('Сетевая ошибка:', error.message);
    } else {
      console.error('HTTP ошибка:', error.message);
    }
    throw error;
  }
}

function redirectToLogin() {
  window.location.href = '/login';
}
```

## Повторные попытки запросов

### Базовая реализация retry-логики

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        // Не пытаемся повторить запросы с 4xx ошибками
        if (response.status >= 400 && response.status < 500) {
          throw new Error(`HTTP ошибка: ${response.status}`);
        }
        throw new Error(`HTTP ошибка: ${response.status}`);
      }
      
      return response;
    } catch (error) {
      if (i === maxRetries) {
        // Все попытки исчерпаны
        throw error;
      }
      
      // Ожидание перед повторной попыткой
      await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
    }
  }
}

// Использование
async function getDataWithRetry() {
  try {
    const response = await fetchWithRetry('/api/data');
    return await response.json();
  } catch (error) {
    console.error('Запрос не удался после всех попыток:', error);
  }
}
```

### Продвинутая retry-логика с экспоненциальной задержкой

```javascript
async function fetchWithExponentialBackoff(url, options = {}, maxRetries = 3) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Повторяем только 5xx ошибки и ошибки подключения
      if (response.status < 500 && response.status !== 429) {
        throw new Error(`HTTP ошибка: ${response.status}`);
      }
      
      throw new Error(`HTTP ошибка: ${response.status}`);
    } catch (error) {
      if (i === maxRetries) {
        throw error;
      }
      
      // Экспоненциальная задержка: 1с, 2с, 4с и т.д.
      const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

## Обработка ошибок в цепочках Promise

### Использование .catch() для обработки ошибок

```javascript
fetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP ошибка: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    console.log('Данные получены:', data);
    // Обработка данных
  })
  .catch(error => {
    console.error('Ошибка в цепочке Promise:', error);
    // Обработка ошибки
  });
```

### Централизованная обработка ошибок

```javascript
class ApiClient {
  async request(url, options = {}) {
    try {
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      });
      
      const result = await this.handleResponse(response);
      return result;
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }
  
  async handleResponse(response) {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const error = new Error(errorData.message || `HTTP ошибка: ${response.status}`);
      error.status = response.status;
      throw error;
    }
    
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return await response.json();
    }
    
    return await response.text();
  }
  
  handleError(error) {
    console.error('API ошибка:', error);
    
    // Логирование ошибки для аналитики
    if (typeof window !== 'undefined') {
      // Отправка ошибки в систему мониторинга
      // например, Sentry, LogRocket и т.д.
    }
  }
}

// Использование
const apiClient = new ApiClient();

async function getData() {
  try {
    const data = await apiClient.request('/api/data');
    return data;
  } catch (error) {
    // Обработка ошибки на уровне приложения
    showErrorMessage(error.message);
  }
}
```

## Практические рекомендации для российских разработчиков (2025)

### Работа с российскими API

При интеграции с российскими API учитывайте:

- Специфичные HTTP-статусы, используемые API
- Форматы ошибок (часто отличаются от стандартов)
- Ограничения по количеству запросов (rate limiting)
- Требования к аутентификации

```javascript
// Пример обработки специфичных ошибок российского API
async function handleRussianApiErrors(response) {
  if (!response.ok) {
    const errorData = await response.json();
    
    switch (response.status) {
      case 422:
        // Российские API часто возвращают детализированные ошибки валидации
        const validationErrors = errorData.errors || {};
        const firstError = Object.values(validationErrors)[0]?.[0];
        throw new Error(firstError || 'Ошибка валидации данных');
      case 423:
        // 423 Locked - специфичная ошибка, часто используется в российских API
        throw new Error('Ресурс временно заблокирован');
      default:
        throw new Error(errorData.message || `HTTP ошибка: ${response.status}`);
    }
  }
  
  return await response.json();
}
```

### Локализация сообщений об ошибках

```javascript
const errorMessages = {
  400: 'Неверный запрос',
  401: 'Требуется авторизация',
  403: 'Доступ запрещен',
  404: 'Ресурс не найден',
  429: 'Слишком много запросов',
  500: 'Внутренняя ошибка сервера',
  'network': 'Ошибка подключения к интернету',
  'timeout': 'Время ожидания запроса истекло'
};

function getErrorMessage(error) {
  if (error.status && errorMessages[error.status]) {
    return errorMessages[error.status];
  }
  
  if (error.message.includes('Network Error')) {
    return errorMessages['network'];
  }
  
  if (error.message.includes('timeout')) {
    return errorMessages['timeout'];
  }
  
  return error.message || 'Неизвестная ошибка';
}
```

### Обработка ошибок в условиях нестабильного интернета

В российских реалиях часто сталкиваются с нестабильным интернет-соединением:

```javascript
async function robustFetch(url, options = {}) {
  const maxRetries = navigator.onLine ? 2 : 5; // Больше попыток при медленном интернете
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 секунд таймаут
      
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        return response;
      }
      
      // Повторяем только при определенных ошибках
      if ([500, 502, 503, 504].includes(response.status)) {
        continue; // Попробуем снова
      }
      
      throw new Error(`HTTP ошибка: ${response.status}`);
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error; // Последняя попытка
      }
      
      // Ожидание перед повторной попыткой
      await new Promise(resolve => setTimeout(resolve, 2000 * (i + 1)));
    }
  }
}
```

## Пользовательский интерфейс для ошибок

### Отображение сообщений об ошибках

```javascript
function showErrorMessage(message, type = 'error') {
  const errorContainer = document.getElementById('error-container');
  
  errorContainer.innerHTML = `
    <div class="alert alert-${type}">
      <span class="close-btn" onclick="this.parentElement.style.display='none'">&times;</span>
      ${message}
    </div>
  `;
  
  // Автоматическое скрытие через 5 секунд
  setTimeout(() => {
    if (errorContainer.firstChild) {
      errorContainer.innerHTML = '';
    }
  }, 5000);
}
```

### Индикаторы загрузки и ошибок

```javascript
class RequestManager {
  constructor() {
    this.loadingIndicators = new Map();
  }
  
  async request(url, options = {}, loadingElementId = null) {
    if (loadingElementId) {
      this.showLoading(loadingElementId);
    }
    
    try {
      const response = await fetch(url, options);
      
      if (loadingElementId) {
        this.hideLoading(loadingElementId);
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ошибка: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      if (loadingElementId) {
        this.hideLoading(loadingElementId);
      }
      
      // Показываем сообщение об ошибке
      showErrorMessage(error.message);
      throw error;
    }
  }
  
  showLoading(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
      element.innerHTML = '<div class="loading">Загрузка...</div>';
    }
  }
  
  hideLoading(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
      element.innerHTML = '';
    }
  }
}
```

## Полезные ресурсы

- [[Fetch-API-в-HTML]] - для понимания основных принципов работы с ответами
- [[XMLHttpRequest-в-HTML]] - для работы с унаследованным кодом
- [[CORS-и-безопасность-запросов]] - вопросы безопасности при обработке ошибок
- [[FormData-и-загрузка-файлов]] - специфичная обработка ошибок при загрузке файлов

## Заключение

Правильная обработка ответов и ошибок сетевых запросов критически важна для создания надежных и удобных веб-приложений. Важно учитывать как технические аспекты (HTTP-статусы, сетевые ошибки), так и пользовательский опыт (понятные сообщения об ошибках, индикаторы загрузки).

> [!tip] Совет
> Всегда тестируйте обработку ошибок в различных сценариях: отсутствие интернета, серверные ошибки, неверные данные от пользователя.

> [!warning] Важно
> Не показывайте детали внутренних ошибок сервера пользователям. Вместо этого предоставляйте понятные сообщения и логируйте реальные ошибки на сервере.