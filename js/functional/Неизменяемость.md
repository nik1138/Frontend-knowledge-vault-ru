---
aliases: ["Иммутабельность", "Immutability"]
tags: [programming, javascript, functional-programming, best-practices, performance]
---

# Неизменяемость

**Неизменяемость** (immutability) — это концепция, при которой данные не могут быть изменены после создания. Вместо изменения существующих данных, создаются новые структуры данных с нужными изменениями. Это ключевой принцип функционального программирования, особенно важный в российской разработке, где часто требуется высокая надежность и предсказуемость приложений.

## Основная концепция

При работе с неизменяемыми данными, любая "модификация" создает новую версию данных, оставляя оригинальные данные нетронутыми. Это исключает побочные эффекты и делает код более предсказуемым и легким для отладки.

## Преимущества неизменяемости

- **Предсказуемость**: Нет неожиданных изменений состояния
- **Простота отладки**: Легче отслеживать изменения данных
- **Безопасность в многопоточной среде**: Неизменяемые данные потокобезопасны
- **Упрощение тестирования**: Функции становятся более предсказуемыми
- **Оптимизация**: Легче реализовать эффективные алгоритмы сравнения и кэширования

## Практические примеры

### Работа с примитивными типами

```javascript
// Примитивные типы в JavaScript по умолчанию неизменяемы
let a = 5;
let b = a; // b получает копию значения
a = 10;
console.log(b); // 5 - значение b не изменилось
```

### Работа с массивами

```javascript
// Плохой пример - изменение исходного массива
let numbers = [1, 2, 3];
numbers.push(4); // Изменяет исходный массив
console.log(numbers); // [1, 2, 3, 4]

// Хороший пример - создание нового массива
const originalNumbers = [1, 2, 3];
const newNumbers = [...originalNumbers, 4]; // Создает новый массив
console.log(originalNumbers); // [1, 2, 3] - оригинальный массив не изменился
console.log(newNumbers); // [1, 2, 3, 4]
```

### Работа с объектами

```javascript
// Плохой пример - изменение исходного объекта
let user = { name: 'Иван', age: 30 };
user.age = 31; // Изменяет исходный объект
console.log(user); // { name: 'Иван', age: 31 }

// Хороший пример - создание нового объекта
const originalUser = { name: 'Иван', age: 30 };
const updatedUser = { ...originalUser, age: 31 }; // Создает новый объект
console.log(originalUser); // { name: 'Иван', age: 30 } - оригинальный объект не изменился
console.log(updatedUser); // { name: 'Иван', age: 31 }
```

## Практические утилиты для работы с неизменяемыми данными

### Создание неизменяемых массивов

```javascript
// Функция для добавления элемента в массив
const push = (arr, item) => [...arr, item];

// Функция для удаления элемента по индексу
const removeAt = (arr, index) => [
    ...arr.slice(0, index),
    ...arr.slice(index + 1)
];

// Функция для обновления элемента по индексу
const updateAt = (arr, index, newItem) => [
    ...arr.slice(0, index),
    newItem,
    ...arr.slice(index + 1)
];

// Пример использования
const originalArray = [1, 2, 3, 4];
const newArray = push(originalArray, 5);
const removedArray = removeAt(originalArray, 1);
const updatedArray = updateAt(originalArray, 2, 10);

console.log(originalArray); // [1, 2, 3, 4]
console.log(newArray); // [1, 2, 3, 4, 5]
console.log(removedArray); // [1, 3, 4]
console.log(updatedArray); // [1, 2, 10, 4]
```

### Создание неизменяемых объектов

```javascript
// Функция для обновления свойства объекта
const updateProp = (obj, key, value) => ({
    ...obj,
    [key]: value
});

// Функция для удаления свойства из объекта
const removeProp = (obj, key) => {
    const { [key]: deleted, ...rest } = obj;
    return rest;
};

// Функция для глубокого обновления вложенного свойства
const deepUpdate = (obj, path, value) => {
    const keys = path.split('.');
    const lastKey = keys.pop();
    
    if (keys.length === 0) {
        return { ...obj, [lastKey]: value };
    }
    
    const parentPath = keys.join('.');
    const parentValue = getNestedValue(obj, keys);
    
    return {
        ...obj,
        [parentPath]: deepUpdate(parentValue, lastKey, value)
    };
};

// Вспомогательная функция для получения вложенного значения
const getNestedValue = (obj, keys) => {
    return keys.reduce((current, key) => current[key], obj);
};

// Пример использования
const originalUser = {
    name: 'Иван',
    age: 30,
    address: {
        city: 'Москва',
        street: 'Тверская'
    }
};

const updatedUser = updateProp(originalUser, 'age', 31);
const userWithoutAge = removeProp(originalUser, 'age');
const userWithNewStreet = deepUpdate(originalUser, 'address.street', 'Арбат');

console.log(originalUser); // Оригинальный объект не изменился
console.log(updatedUser); // { name: 'Иван', age: 31, address: { city: 'Москва', street: 'Тверская' } }
```

## Применение в российских условиях

В российской разработке неизменяемость особенно важна при работе с:

- Финансовыми приложениями, где важна целостность данных
- Системами, обрабатывающими персональные данные (необходимо соблюдение 152-ФЗ)
- Приложениями, работающими с большими объемами данных
- Многопользовательскими системами с высокой нагрузкой

### Пример: работа с финансовыми данными

```javascript
// Создание неизменяемой транзакции
const createTransaction = (from, to, amount, date) => Object.freeze({
    id: Date.now(),
    from,
    to,
    amount,
    date: date || new Date(),
    status: 'pending'
});

// Обновление статуса транзакции
const updateTransactionStatus = (transaction, status) => ({
    ...transaction,
    status,
    timestamp: new Date()
});

// Пример использования
const transaction = createTransaction('Иванов', 'Петров', 10000);
const processedTransaction = updateTransactionStatus(transaction, 'completed');

console.log(transaction.status); // 'pending'
console.log(processedTransaction.status); // 'completed'
```

### Пример: управление пользовательским профилем

```javascript
// Создание неизменяемого профиля пользователя
const createUserProfile = (data) => Object.freeze({
    id: data.id,
    personalInfo: Object.freeze({
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        phone: data.phone
    }),
    preferences: Object.freeze({
        language: data.language || 'ru',
        timezone: data.timezone || 'Europe/Moscow',
        notifications: data.notifications || true
    }),
    createdAt: new Date(),
    updatedAt: new Date()
});

// Функция обновления профиля
const updateUserProfile = (profile, updates) => {
    return {
        ...profile,
        ...updates,
        updatedAt: new Date(),
        personalInfo: {
            ...profile.personalInfo,
            ...(updates.personalInfo || {})
        },
        preferences: {
            ...profile.preferences,
            ...(updates.preferences || {})
        }
    };
};

// Пример использования
const profile = createUserProfile({
    id: 1,
    firstName: 'Иван',
    lastName: 'Иванов',
    email: 'ivan@example.com',
    language: 'ru'
});

const updatedProfile = updateUserProfile(profile, {
    personalInfo: { email: 'ivan.new@example.com' },
    preferences: { notifications: false }
});

console.log(profile.personalInfo.email); // 'ivan@example.com'
console.log(updatedProfile.personalInfo.email); // 'ivan.new@example.com'
```

## Библиотеки для работы с неизменяемыми данными

### Immer

```javascript
import produce from 'immer';

const state = {
    users: [
        { id: 1, name: 'Иван', age: 30 },
        { id: 2, name: 'Мария', age: 25 }
    ]
};

// С использованием Immer можно "мутабельно" изменять данные,
// но на самом деле создается новый объект
const newState = produce(state, draft => {
    draft.users[0].age = 31;
    draft.users.push({ id: 3, name: 'Алексей', age: 28 });
});

console.log(state.users[0].age); // 30 - оригинальное состояние не изменилось
console.log(newState.users[0].age); // 31
```

### Ручная реализация с Object.freeze

```javascript
// Функция для полной заморозки объекта
const deepFreeze = (obj) => {
    // Получаем все свойства объекта
    Object.getOwnPropertyNames(obj).forEach(prop => {
        if (obj[prop] !== null && typeof obj[prop] === 'object') {
            deepFreeze(obj[prop]);
        }
    });
    
    return Object.freeze(obj);
};

// Пример использования
const frozenData = deepFreeze({
    name: 'Иван',
    details: {
        age: 30,
        hobbies: ['программирование', 'теннис']
    }
});

// Попытка изменения будет проигнорирована в strict mode
// frozenData.name = 'Мария'; // Ошибка в strict mode
```

## Практические советы

1. **Используйте спред-оператор**: Для создания копий массивов и объектов
2. **Избегайте мутаций**: Не используйте методы массивов, которые изменяют оригинальный массив
3. **Используйте Object.freeze()**: Для предотвращения изменений объектов
4. **Рассмотрите Immer**: Для удобной работы с неизменяемыми структурами данных
5. **Используйте TypeScript**: Для дополнительной безопасности типов

## Заключение

Неизменяемость — ключевой принцип функционального программирования, который помогает создавать более надежные, предсказуемые и легко тестируемые приложения. В российской практике разработки это особенно важно при создании корпоративных приложений, где важна целостность данных и надежность системы.

## См. также

- [[Каррирование]]
- [[Композиция-функций]]
- [[Чистые-функции]]
- [[Функции-высшего-порядка]]