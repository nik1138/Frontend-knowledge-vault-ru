---
aliases: [Защита от инъекций, Инъекции, SQL-инъекции, Command-инъекции]
tags: [javascript, безопасность, инъекции, sql-injection, command-injection]
---

# Защита от инъекций в JavaScript-приложениях

## Общее описание

Инъекции - это класс уязвимостей, при которых злоумышленник внедряет в приложение нежелательный код для манипуляции с системой. В 2025 году инъекции остаются одной из наиболее критических угроз для веб-приложений, особенно для приложений, работающих с базами данных и внешними системами в российской ИТ-инфраструктуре.

## Типы инъекций

### 1. SQL-инъекции

SQL-инъекция происходит, когда пользовательский ввод неправильно экранируется и становится частью SQL-запроса.

#### Пример уязвимости:
```javascript
// НЕБЕЗОПАСНЫЙ КОД
const express = require('express');
const { exec } = require('child_process');

app.get('/user', (req, res) => {
    // Уязвимый код для SQL-инъекции
    const userId = req.query.id;
    const query = `SELECT * FROM users WHERE id = ${userId}`;
    // Выполнение запроса к базе данных
    db.query(query, (err, results) => {
        res.json(results);
    });
});
```

Если злоумышленник передаст в параметре `id` значение `1 OR 1=1`, запрос станет:
```sql
SELECT * FROM users WHERE id = 1 OR 1=1
```
Это вернет всех пользователей из базы данных.

#### Защита от SQL-инъекций:
```javascript
// БЕЗОПАСНЫЙ КОД
const express = require('express');

app.get('/user', (req, res) => {
    // Использование подготовленных выражений (prepared statements)
    const userId = req.query.id;
    
    // С параметризацией
    const query = 'SELECT * FROM users WHERE id = ?';
    db.query(query, [userId], (err, results) => {
        if (err) {
            return res.status(500).json({ error: 'Database error' });
        }
        res.json(results);
    });
});

// Использование ORM с автоматической защитой
const { User } = require('./models');

app.get('/user/:id', async (req, res) => {
    try {
        const user = await User.findByPk(req.params.id);
        res.json(user);
    } catch (error) {
        res.status(500).json({ error: 'Database error' });
    }
});
```

### 2. Command-инъекции

Command-инъекция происходит, когда пользовательский ввод используется для формирования системных команд.

#### Пример уязвимости:
```javascript
// НЕБЕЗОПАСНЫЙ КОД
const { exec } = require('child_process');

app.get('/ping', (req, res) => {
    const host = req.query.host;
    // Уязвимый код для command-инъекции
    exec(`ping -c 4 ${host}`, (error, stdout, stderr) => {
        res.send(stdout);
    });
});
```

Если злоумышленник передаст в параметре `host` значение `; rm -rf / ;`, команда станет:
```bash
ping -c 4 ; rm -rf / ;
```

#### Защита от command-инъекций:
```javascript
// БЕЗОПАСНЫЙ КОД
const { spawn } = require('child_process');
const validator = require('validator');

app.get('/ping', (req, res) => {
    const host = req.query.host;
    
    // Валидация и санитизация входных данных
    if (!validator.isIP(host) && !validator.isFQDN(host)) {
        return res.status(400).json({ error: 'Invalid host' });
    }
    
    // Использование spawn вместо exec для лучшей безопасности
    const child = spawn('ping', ['-c', '4', host]);
    
    let output = '';
    child.stdout.on('data', (data) => {
        output += data.toString();
    });
    
    child.on('close', (code) => {
        res.send(output);
    });
});
```

### 3. NoSQL-инъекции

Для приложений, использующих MongoDB и другие NoSQL базы данных:

#### Пример уязвимости:
```javascript
// НЕБЕЗОПАСНЫЙ КОД
app.get('/user', (req, res) => {
    const username = req.query.username;
    // Уязвимый код для NoSQL-инъекции
    User.find({ username: username }, (err, users) => {
        res.json(users);
    });
});
```

#### Защита от NoSQL-инъекций:
```javascript
// БЕЗОПАСНЫЙ КОД
const mongoSanitize = require('mongo-sanitize');

app.get('/user', (req, res) => {
    const username = mongoSanitize(req.query.username);
    
    // Использование строгой проверки типа
    User.findOne({ username: String(username) }, (err, user) => {
        if (err) {
            return res.status(500).json({ error: 'Database error' });
        }
        res.json(user);
    });
});
```

## Общие методы защиты от инъекций

### 1. Санитизация и валидация входных данных

```javascript
// Централизованная функция санитизации
function sanitizeInput(input) {
    if (typeof input === 'string') {
        // Удаление потенциально опасных символов
        return input
            .replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (char) {
                switch (char) {
                    case "\0": return "\\0";
                    case "\x08": return "\\b";
                    case "\x09": return "\\t";
                    case "\x1a": return "\\z";
                    case "\n": return "\\n";
                    case "\r": return "\\r";
                    case "\"":
                    case "'":
                    case "\\":
                    case "%": return "\\" + char; // escape characters
                    default: return char;
                }
            });
    }
    return input;
}

// Валидация с использованием белого списка
function validateInput(input, allowedPattern) {
    if (!allowedPattern.test(input)) {
        throw new Error('Invalid input');
    }
    return sanitizeInput(input);
}
```

### 2. Использование подготовленных выражений

```javascript
// Для MySQL
const mysql = require('mysql2/promise');

async function getUserById(userId) {
    const connection = await mysql.createConnection(dbConfig);
    
    // Использование подготовленных выражений
    const [rows] = await connection.execute(
        'SELECT * FROM users WHERE id = ?',
        [userId]
    );
    
    await connection.end();
    return rows;
}

// Для PostgreSQL
const { Pool } = require('pg');

const pool = new Pool(pgConfig);

async function getUserByEmail(email) {
    // Использование параметризованных запросов
    const { rows } = await pool.query(
        'SELECT * FROM users WHERE email = $1',
        [email]
    );
    
    return rows;
}
```

### 3. Ограничение привилегий

```javascript
// Пример настройки соединения с ограниченными привилегиями
const limitedDbConfig = {
    host: process.env.DB_HOST,
    user: 'limited_user',  // Пользователь с минимальными привилегиями
    password: process.env.LIMITED_DB_PASSWORD,
    database: process.env.DB_NAME,
    // Ограничение времени выполнения запроса
    acquireTimeout: 10000,
    timeout: 10000
};
```

## Защита в различных контекстах

### 1. Защита в Node.js API

```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');

const app = express();

// Защита от инъекций в MongoDB
app.use(mongoSanitize());

// Защита от XSS (связана с инъекциями)
app.use(xss());

// Ограничение количества запросов
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Валидация и санитизация запросов
app.use((req, res, next) => {
    // Санитизация параметров URL
    if (req.query) {
        for (let key in req.query) {
            req.query[key] = sanitizeInput(req.query[key]);
        }
    }
    
    // Санитизация тела запроса
    if (req.body) {
        for (let key in req.body) {
            if (typeof req.body[key] === 'string') {
                req.body[key] = sanitizeInput(req.body[key]);
            }
        }
    }
    
    next();
});
```

### 2. Защита при работе с файлами

```javascript
const path = require('path');
const fs = require('fs').promises;

// Безопасное чтение файлов с предотвращением path traversal
async function secureFileRead(filePath, allowedDirectory) {
    // Разрешение только определенных директорий
    const resolvedPath = path.resolve(filePath);
    const resolvedAllowedDir = path.resolve(allowedDirectory);
    
    // Проверка, что путь находится в разрешенной директории
    if (!resolvedPath.startsWith(resolvedAllowedDir)) {
        throw new Error('Access denied: Path traversal detected');
    }
    
    // Проверка разрешенных расширений файлов
    const allowedExtensions = ['.txt', '.pdf', '.jpg', '.png'];
    const ext = path.extname(resolvedPath).toLowerCase();
    
    if (!allowedExtensions.includes(ext)) {
        throw new Error('Access denied: File type not allowed');
    }
    
    return await fs.readFile(resolvedPath, 'utf8');
}
```

### 3. Защита при работе с внешними API

```javascript
const axios = require('axios');

// Безопасный вызов внешнего API с валидацией параметров
async function secureExternalApiCall(endpoint, params) {
    // Валидация endpoint
    const allowedEndpoints = [
        'https://api.trusted-service.com/users',
        'https://api.trusted-service.com/orders'
    ];
    
    if (!allowedEndpoints.includes(endpoint)) {
        throw new Error('Access denied: Endpoint not allowed');
    }
    
    // Санитизация параметров
    const sanitizedParams = {};
    for (const [key, value] of Object.entries(params)) {
        // Проверка типа и длины параметров
        if (typeof value === 'string' && value.length > 100) {
            throw new Error(`Parameter ${key} too long`);
        }
        sanitizedParams[key] = sanitizeInput(value);
    }
    
    try {
        const response = await axios.get(endpoint, { 
            params: sanitizedParams,
            timeout: 5000 // Ограничение времени ожидания
        });
        return response.data;
    } catch (error) {
        throw new Error('External API call failed');
    }
}
```

## Современные инструменты защиты

### 1. OWASP ESAPI для JavaScript

```javascript
// Использование ESAPI для валидации и санитизации
const ESAPI = require('node-esapi');

function secureValidateAndSanitize(input) {
    // Валидация email
    if (!ESAPI.validator().isValidEmail('Email', input, true)) {
        throw new Error('Invalid email');
    }
    
    // Санитизация HTML
    return ESAPI.encoder().encodeForHTML(input);
}
```

### 2. Helmet.js для дополнительной защиты

```javascript
const helmet = require('helmet');

app.use(helmet({
    // Защита от различных типов атак
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"],
            scriptSrc: ["'self'"]
        }
    },
    dnsPrefetchControl: false,
    frameguard: { action: 'deny' },
    hidePoweredBy: true,
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    },
    ieNoOpen: false,
    noSniff: true,
    referrerPolicy: { policy: 'same-origin' }
}));
```

## Инъекции в российском контексте 2025

В 2025 году в России особое внимание уделяется защите критической информационной инфраструктуры от инъекций. Федеральная служба по техническому и экспортному контролю (ФСТЭК) и Центр обеспечения функционирования Государственной системы СОКРА (ЦСС) рекомендуют использовать многоуровневую защиту от инъекций.

Ключевые требования:
- Обязательная валидация всех входных данных
- Использование подготовленных выражений для работы с базами данных
- Санитизация всех пользовательских данных перед обработкой
- Регулярное тестирование на уязвимости инъекций

Согласно отчетам CERT России, инъекции составляют около 25% всех выявленных уязвимостей в отечественных веб-приложениях, что делает защиту от них приоритетной задачей для разработчиков.

## Лучшие практики

### 1. Принцип наименьших привилегий
```javascript
// Использование отдельных учетных записей для разных операций
const dbConnections = {
    readonly: {
        user: 'readonly_user',
        permissions: ['SELECT']
    },
    write: {
        user: 'write_user', 
        permissions: ['SELECT', 'INSERT', 'UPDATE']
    },
    admin: {
        user: 'admin_user',
        permissions: ['ALL']
    }
};
```

### 2. Логирование подозрительных действий
```javascript
// Логирование потенциальных попыток инъекций
function logSuspiciousActivity(activity) {
    const suspiciousPatterns = [
        /(\b(union|select|insert|delete|update|drop|create|alter|exec|execute|system|shell)\b)/i,
        /(;|\|\||&&)/,
        /('|"|`)/
    ];
    
    for (const pattern of suspiciousPatterns) {
        if (pattern.test(activity)) {
            console.warn('Suspicious activity detected:', {
                timestamp: new Date().toISOString(),
                activity,
                pattern: pattern.toString()
            });
            // Отправка алерта в систему мониторинга
            sendSecurityAlert('Potential injection attempt', activity);
            return true;
        }
    }
    return false;
}
```

### 3. Регулярное тестирование безопасности
```javascript
// Автоматизированное тестирование на уязвимости
const { exec } = require('child_process');

function runSecurityScan() {
    // Запуск сканера уязвимостей
    exec('npx eslint --config security-eslintrc.json src/', (error, stdout, stderr) => {
        if (error) {
            console.error('Security scan error:', error);
            return;
        }
        console.log('Security scan completed:', stdout);
    });
    
    // Использование специализированных инструментов
    exec('npx nsp check', (error, stdout, stderr) => {
        if (error) {
            console.error('Dependency security check error:', error);
            return;
        }
        console.log('Dependency security check completed:', stdout);
    });
}
```

## Заключение

Защита от инъекций требует комплексного подхода, включающего валидацию, санитизацию, использование безопасных методов работы с данными и регулярное тестирование. В 2025 году, особенно в российском контексте, это критически важно для обеспечения безопасности веб-приложений и защиты персональных данных.

См. также: [[XSS-защита]], [[CSRF-защита]], [[CSP]], [[Валидация-данных]]

> [!tip]
> Всегда используйте белый список разрешенных значений вместо черного списка запрещенных символов для максимальной безопасности.