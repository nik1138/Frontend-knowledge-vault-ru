---
aliases: ["modern-practices", "Современные практики разработки", "JS Modern Practices"]
tags: [javascript, best-practices, frontend, development]
---

# Современные практики разработки

Современные практики разработки на JavaScript включают в себя подходы, инструменты и методологии, которые помогают создавать высококачественный, поддерживаемый и масштабируемый код. В этом документе рассмотрены ключевые современные практики.

## Архитектурные паттерны

### 1. Чистая архитектура (Clean Architecture)

```javascript
// domain/user.js - сущность домена
class User {
  constructor({ id, name, email, password }) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.password = password;
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // Бизнес-логика
  updateProfile(updates) {
    if (updates.email && !this.isValidEmail(updates.email)) {
      throw new Error('Некорректный email');
    }

    Object.assign(this, updates);
    this.updatedAt = new Date();
  }

  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // Проверка прав доступа
  canUpdateProfile(userId) {
    return this.id === userId;
  }
}

// domain/user-repository.js - интерфейс репозитория
class UserRepositoryInterface {
  async findById(id) {
    throw new Error('Метод должен быть реализован');
  }

  async save(user) {
    throw new Error('Метод должен быть реализован');
  }

  async delete(id) {
    throw new Error('Метод должен быть реализован');
  }
}

// use-cases/get-user-use-case.js - use case
class GetUserUseCase {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }

  async execute(userId) {
    if (!userId) {
      throw new Error('ID пользователя обязателен');
    }

    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('Пользователь не найден');
    }

    return user;
  }
}

// use-cases/update-user-use-case.js - use case
class UpdateUserUseCase {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }

  async execute(userId, updates, requestingUserId) {
    if (!userId || !updates) {
      throw new Error('ID пользователя и обновления обязательны');
    }

    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('Пользователь не найден');
    }

    // Проверка прав доступа
    if (!user.canUpdateProfile(requestingUserId)) {
      throw new Error('Недостаточно прав для обновления профиля');
    }

    user.updateProfile(updates);
    return await this.userRepository.save(user);
  }
}

// infrastructure/repositories/user-repository.js - конкретная реализация
class UserRepository extends UserRepositoryInterface {
  constructor(database) {
    super();
    this.database = database;
  }

  async findById(id) {
    const userData = await this.database.users.findById(id);
    return userData ? new User(userData) : null;
  }

  async save(user) {
    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      password: user.password,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };

    await this.database.users.update(user.id, userData);
    return new User(userData);
  }

  async delete(id) {
    await this.database.users.delete(id);
  }
}
```

### 2. Модульный дизайн

```javascript
// modules/user/user-module.js - модуль пользователя
class UserModule {
  constructor(config) {
    this.config = config;
    this.services = new Map();
    this.repositories = new Map();
    this.useCases = new Map();
  }

  // Регистрация сервиса
  registerService(name, service) {
    this.services.set(name, service);
    return this;
  }

  // Регистрация репозитория
  registerRepository(name, repository) {
    this.repositories.set(name, repository);
    return this;
  }

  // Регистрация use case
  registerUseCase(name, useCase) {
    this.useCases.set(name, useCase);
    return this;
  }

  // Получение зависимости
  get(name) {
    if (this.services.has(name)) return this.services.get(name);
    if (this.repositories.has(name)) return this.repositories.get(name);
    if (this.useCases.has(name)) return this.useCases.get(name);

    throw new Error(`Зависимость ${name} не найдена`);
  }

  // Инициализация модуля
  async initialize() {
    // Здесь можно выполнить инициализацию модуля
    console.log(`Модуль ${this.config.name} инициализирован`);
  }
}

// modules/user/factories/user-factory.js - фабрика создания пользователей
class UserFactory {
  static create(userData) {
    const requiredFields = ['name', 'email'];

    for (const field of requiredFields) {
      if (!userData[field]) {
        throw new Error(`Поле ${field} обязательно`);
      }
    }

    return new User({
      ...userData,
      id: userData.id || this.generateId(),
      createdAt: userData.createdAt || new Date(),
      updatedAt: userData.updatedAt || new Date()
    });
  }

  static generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  static createFromRegistration(registrationData) {
    // Дополнительная логика для регистрации
    const hashedPassword = this.hashPassword(registrationData.password);

    return this.create({
      ...registrationData,
      password: hashedPassword
    });
  }

  static hashPassword(password) {
    // В реальном приложении используйте криптографически стойкие методы
    return btoa(password); // Пример (не использовать в продакшене!)
  }
}
```

## Функциональное программирование

### 1. Чистые функции и иммутабельность

```javascript
// utils/immutable.js - утилиты для работы с неизменяемыми данными
class ImmutableUtils {
  /**
   * Создает глубокую копию объекта
   * @param {object} obj - объект для копирования
   * @returns {object} - глубокая копия объекта
   */
  static deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }

    if (obj instanceof Array) {
      return obj.map(item => this.deepClone(item));
    }

    if (typeof obj === 'object') {
      const cloned = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }
  }

  /**
   * Обновляет свойства объекта, создавая новый объект
   * @param {object} obj - исходный объект
   * @param {object} updates - обновления
   * @returns {object} - новый объект с обновлениями
   */
  static updateObject(obj, updates) {
    return { ...obj, ...updates };
  }

  /**
   * Обновляет вложенное свойство объекта
   * @param {object} obj - исходный объект
   * @param {string} path - путь к свойству (например, 'user.profile.name')
   * @param {*} value - новое значение
   * @returns {object} - новый объект с обновленным свойством
   */
  static updateNestedProperty(obj, path, value) {
    const pathParts = path.split('.');
    const newObj = this.deepClone(obj);

    let current = newObj;
    for (let i = 0; i < pathParts.length - 1; i++) {
      current[pathParts[i]] = { ...current[pathParts[i]] };
      current = current[pathParts[i]];
    }

    current[pathParts[pathParts.length - 1]] = value;
    return newObj;
  }

  /**
   * Удаляет свойство из объекта, создавая новый объект
   * @param {object} obj - исходный объект
   * @param {string} key - ключ для удаления
   * @returns {object} - новый объект без указанного ключа
   */
  static removeObjectKey(obj, key) {
    const { [key]: removed, ...rest } = obj;
    return rest;
  }
}

// utils/function.js - функциональные утилиты
class FunctionUtils {
  /**
   * Каррирование функции
   * @param {function} fn - функция для каррирования
   * @returns {function} - каррированная функция
   */
  static curry(fn) {
    return function curried(...args) {
      if (args.length >= fn.length) {
        return fn.apply(this, args);
      } else {
        return function (...moreArgs) {
          return curried.apply(this, args.concat(moreArgs));
        };
      }
    };
  }

  /**
   * Композиция функций (справа налево)
   * @param {...function} fns - функции для композиции
   * @returns {function} - скомпонованная функция
   */
  static compose(...fns) {
    return (value) => fns.reduceRight((acc, fn) => fn(acc), value);
  }

  /**
   * Композиция функций (слева направо)
   * @param {...function} fns - функции для композиции
   * @returns {function} - скомпонованная функция
   */
  static pipe(...fns) {
    return (value) => fns.reduce((acc, fn) => fn(acc), value);
  }

  /**
   * Memoization функции
   * @param {function} fn - функция для мемоизации
   * @returns {function} - мемоизированная функция
   */
  static memoize(fn) {
    const cache = new Map();

    return function (...args) {
      const key = JSON.stringify(args);

      if (cache.has(key)) {
        return cache.get(key);
      }

      const result = fn.apply(this, args);
      cache.set(key, result);
      return result;
    };
  }

  /**
   * Создает частично примененную функцию
   * @param {function} fn - исходная функция
   * @param {...*} args - аргументы для частичного применения
   * @returns {function} - частично примененная функция
   */
  static partial(fn, ...args) {
    return function (...moreArgs) {
      return fn.apply(this, args.concat(moreArgs));
    };
  }
}

// Пример использования функциональных подходов
const calculateDiscount = (basePrice, discountPercent) => {
  return basePrice * (1 - discountPercent / 100);
};

const addTax = (price, taxRate) => {
  return price * (1 + taxRate / 100);
};

const formatPrice = (price) => {
  return `$${price.toFixed(2)}`;
};

// Композиция функций
const calculateFinalPrice = FunctionUtils.pipe(
  calculateDiscount,
  (price) => addTax(price, 10), // 10% налог
  formatPrice
);

// Использование
const finalPrice = calculateFinalPrice(100, 20); // Скидка 20%, налог 10%
console.log(finalPrice); // "$88.00"
```

### 2. Работа с массивами и потоками данных

```javascript
// utils/array.js - утилиты для работы с массивами
class ArrayUtils {
  /**
   * Фильтрация с предикатом
   * @param {Array} arr - массив для фильтрации
   * @param {function} predicate - функция-предикат
   * @returns {Array} - отфильтрованный массив
   */
  static filter(arr, predicate) {
    return arr.filter(predicate);
  }

  /**
   * Преобразование с маппером
   * @param {Array} arr - массив для преобразования
   * @param {function} mapper - функция преобразования
   * @returns {Array} - преобразованный массив
   */
  static map(arr, mapper) {
    return arr.map(mapper);
  }

  /**
   * Свертка массива
   * @param {Array} arr - массив для свертки
   * @param {function} reducer - функция свертки
   * @param {*} initialValue - начальное значение
   * @returns {*} - результат свертки
   */
  static reduce(arr, reducer, initialValue) {
    return arr.reduce(reducer, initialValue);
  }

  /**
   * Поток данных (fluent interface)
   */
  static stream(arr) {
    return new ArrayStream(arr);
  }

  /**
   * Группировка по ключу
   * @param {Array} arr - массив для группировки
   * @param {function} keySelector - функция выбора ключа
   * @returns {object} - объект с группами
   */
  static groupBy(arr, keySelector) {
    return arr.reduce((groups, item) => {
      const key = keySelector(item);
      if (!groups[key]) {
        groups[key] = [];
      }
      groups[key].push(item);
      return groups;
    }, {});
  }

  /**
   * Уникальные значения
   * @param {Array} arr - массив
   * @param {function} keySelector - функция выбора ключа для сравнения
   * @returns {Array} - массив уникальных значений
   */
  static distinct(arr, keySelector = item => item) {
    const seen = new Set();
    return arr.filter(item => {
      const key = keySelector(item);
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  /**
   * Трансформация с асинхронной функцией
   * @param {Array} arr - массив для трансформации
   * @param {function} asyncMapper - асинхронная функция трансформации
   * @returns {Array} - трансформированный массив
   */
  static async mapAsync(arr, asyncMapper) {
    const results = [];
    for (const item of arr) {
      results.push(await asyncMapper(item));
    }
    return results;
  }
}

// Класс для fluent interface
class ArrayStream {
  constructor(arr) {
    this.arr = arr;
  }

  filter(predicate) {
    return new ArrayStream(this.arr.filter(predicate));
  }

  map(mapper) {
    return new ArrayStream(this.arr.map(mapper));
  }

  sort(comparator) {
    return new ArrayStream([...this.arr].sort(comparator));
  }

  slice(start, end) {
    return new ArrayStream(this.arr.slice(start, end));
  }

  take(count) {
    return new ArrayStream(this.arr.slice(0, count));
  }

  skip(count) {
    return new ArrayStream(this.arr.slice(count));
  }

  reduce(reducer, initialValue) {
    return this.arr.reduce(reducer, initialValue);
  }

  toArray() {
    return this.arr;
  }
}

// Пример использования
const users = [
  { id: 1, name: 'John', age: 25, department: 'IT', salary: 50000 },
  { id: 2, name: 'Jane', age: 30, department: 'HR', salary: 45000 },
  { id: 3, name: 'Bob', age: 35, department: 'IT', salary: 60000 },
  { id: 4, name: 'Alice', age: 28, department: 'IT', salary: 55000 }
];

// Использование ArrayStream для сложных трансформаций
const highPaidItEmployees = ArrayUtils.stream(users)
  .filter(user => user.department === 'IT')
  .filter(user => user.salary > 50000)
  .sort((a, b) => b.salary - a.salary)
  .take(2)
  .map(user => ({ ...user, bonus: user.salary * 0.1 }))
  .toArray();

console.log(highPaidItEmployees);
```

## Асинхронное программирование

### 1. Современные подходы к асинхронности

```javascript
// utils/async.js - утилиты для асинхронного программирования
class AsyncUtils {
  /**
   * Параллельное выполнение промисов с ограничением
   * @param {Array} promises - массив промисов
   * @param {number} concurrency - максимальное количество параллельных выполнений
   * @returns {Promise} - промис с результатами
   */
  static async parallelLimited(promises, concurrency) {
    const results = [];

    for (let i = 0; i < promises.length; i += concurrency) {
      const batch = promises.slice(i, i + concurrency);
      const batchResults = await Promise.all(batch);
      results.push(...batchResults);
    }

    return results;
  }

  /**
   * Последовательное выполнение асинхронных операций
   * @param {Array} asyncFunctions - массив асинхронных функций
   * @returns {Promise} - промис с результатами
   */
  static async sequential(asyncFunctions) {
    const results = [];

    for (const asyncFn of asyncFunctions) {
      const result = await asyncFn();
      results.push(result);
    }

    return results;
  }

  /**
   * Повторная попытка выполнения асинхронной операции
   * @param {function} asyncFn - асинхронная функция
   * @param {number} maxRetries - максимальное количество попыток
   * @param {number} delay - задержка между попытками
   * @returns {*} - результат выполнения
   */
  static async retry(asyncFn, maxRetries = 3, delay = 1000) {
    let lastError;

    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await asyncFn();
      } catch (error) {
        lastError = error;
        if (i < maxRetries) {
          await this.delay(delay);
        }
      }
    }

    throw lastError;
  }

  /**
   * Таймаут для асинхронной операции
   * @param {Promise} promise - промис для таймаута
   * @param {number} timeout - время таймаута в миллисекундах
   * @returns {Promise} - промис с таймаутом
   */
  static timeout(promise, timeout) {
    return Promise.race([
      promise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Таймаут операции')), timeout)
      )
    ]);
  }

  /**
   * Задержка выполнения
   * @param {number} ms - время задержки в миллисекундах
   * @returns {Promise} - промис, который разрешится через указанное время
   */
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Асинхронный маппер с ограничением
   * @param {Array} arr - массив для маппинга
   * @param {function} asyncMapper - асинхронная функция маппинга
   * @param {number} concurrency - максимальное количество параллельных выполнений
   * @returns {Promise} - промис с результатами
   */
  static async mapWithConcurrency(arr, asyncMapper, concurrency) {
    const results = new Array(arr.length);
    const promises = [];

    for (let i = 0; i < arr.length; i += concurrency) {
      const batchPromises = arr.slice(i, i + concurrency)
        .map((item, batchIndex) => asyncMapper(item, i + batchIndex))
        .map((promise, batchIndex) =>
          promise.then(result => {
            results[i + batchIndex] = result;
          })
        );

      await Promise.all(batchPromises);
    }

    return results;
  }

  /**
   * Создает асинхронный итератор с буферизацией
   * @param {AsyncIterator} asyncIterator - асинхронный итератор
   * @param {number} bufferSize - размер буфера
   * @returns {AsyncIterator} - буферизованный асинхронный итератор
   */
  static asyncIteratorBuffer(asyncIterator, bufferSize = 10) {
    const buffer = [];
    let iteratorDone = false;
    let resolveBuffer = null;

    asyncIterator = asyncIterator[Symbol.asyncIterator]();

    const fillBuffer = async () => {
      while (buffer.length < bufferSize && !iteratorDone) {
        const { value, done } = await asyncIterator.next();
        if (done) {
          iteratorDone = true;
          break;
        }
        buffer.push(value);
      }

      if (resolveBuffer) {
        resolveBuffer();
        resolveBuffer = null;
      }
    };

    fillBuffer(); // Начальное заполнение

    return {
      async next() {
        while (buffer.length === 0 && !iteratorDone) {
          await new Promise(resolve => {
            resolveBuffer = resolve;
          });
        }

        if (buffer.length > 0) {
          return { value: buffer.shift(), done: false };
        }

        return { value: undefined, done: true };
      },

      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
}

// Пример использования асинхронных утилит
async function exampleAsyncOperations() {
  // Массив асинхронных операций
  const asyncOperations = [
    () => AsyncUtils.delay(100).then(() => 'result1'),
    () => AsyncUtils.delay(200).then(() => 'result2'),
    () => AsyncUtils.delay(50).then(() => 'result3'),
    () => AsyncUtils.delay(300).then(() => 'result4'),
    () => AsyncUtils.delay(150).then(() => 'result5')
  ];

  // Выполнение последовательно
  const sequentialResults = await AsyncUtils.sequential(asyncOperations);
  console.log('Последовательные результаты:', sequentialResults);

  // Выполнение с ограничением параллельности
  const limitedResults = await AsyncUtils.parallelLimited(
    asyncOperations.map(op => op()),
    2 // не более 2 параллельных операций
  );
  console.log('Результаты с ограничением:', limitedResults);

  // Повторная попытка с ошибкой
  let callCount = 0;
  const failingThenSucceeding = async () => {
    callCount++;
    if (callCount < 3) {
      throw new Error('Попытка не удалась');
    }
    return 'успех';
  };

  try {
    const result = await AsyncUtils.retry(failingThenSucceeding, 5, 100);
    console.log('Результат повторной попытки:', result);
  } catch (error) {
    console.error('Все попытки не удались:', error.message);
  }
}
```

### 2. Обработка ошибок в асинхронном коде

```javascript
// utils/error.js - утилиты для обработки ошибок
class ErrorUtils {
  /**
   * Создает кастомную ошибку
   * @param {string} message - сообщение об ошибке
   * @param {string} code - код ошибки
   * @param {*} details - дополнительные детали
   * @returns {Error} - кастомная ошибка
   */
  static createError(message, code, details = {}) {
    const error = new Error(message);
    error.code = code;
    error.details = details;
    error.timestamp = new Date().toISOString();
    return error;
  }

  /**
   * Обертка для безопасного выполнения асинхронной функции
   * @param {function} asyncFn - асинхронная функция
   * @returns {Promise} - промис с результатом или ошибкой
   */
  static async safeExecute(asyncFn) {
    try {
      const result = await asyncFn();
      return { success: true, result, error: null };
    } catch (error) {
      return { success: false, result: null, error };
    }
  }

  /**
   * Обертка для безопасного выполнения синхронной функции
   * @param {function} fn - синхронная функция
   * @returns {object} - объект с результатом или ошибкой
   */
  static safeExecuteSync(fn) {
    try {
      const result = fn();
      return { success: true, result, error: null };
    } catch (error) {
      return { success: false, result: null, error };
    }
  }

  /**
   * Обертка для функции с повторными попытками
   * @param {function} fn - функция для выполнения
   * @param {number} maxRetries - максимальное количество попыток
   * @param {number} delay - задержка между попытками
   * @returns {*} - результат выполнения
   */
  static async retryWithBackoff(fn, maxRetries = 3, delay = 1000) {
    let lastError;

    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        if (i < maxRetries) {
          // Экспоненциальный откат
          const backoffDelay = delay * Math.pow(2, i);
          await AsyncUtils.delay(backoffDelay);
        }
      }
    }

    throw lastError;
  }

  /**
   * Логирование ошибок
   * @param {Error} error - ошибка для логирования
   * @param {string} context - контекст ошибки
   */
  static logError(error, context = '') {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      code: error.code,
      details: error.details,
      context,
      timestamp: new Date().toISOString()
    };

    console.error('Ошибка:', errorInfo);

    // В реальном приложении отправлять в систему логирования
    // например, Sentry, LogRocket и т.д.
  }

  /**
   * Преобразование ошибки в сериализуемый объект
   * @param {Error} error - ошибка для преобразования
   * @returns {object} - сериализуемый объект ошибки
   */
  static serializeError(error) {
    const serialized = {
      name: error.name,
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    };

    // Добавляем кастомные свойства
    for (const key in error) {
      if (key !== 'name' && key !== 'message' && key !== 'stack') {
        serialized[key] = error[key];
      }
    }

    return serialized;
  }
}

// Пример использования обработки ошибок
async function exampleWithErrorHandling() {
  // Пример функции, которая может выбросить ошибку
  const riskyOperation = async (shouldFail = false) => {
    if (shouldFail) {
      throw ErrorUtils.createError(
        'Операция не удалась',
        'OPERATION_FAILED',
        { userId: 123, operation: 'updateProfile' }
      );
    }
    return 'операция выполнена успешно';
  };

  // Безопасное выполнение
  const { success, result, error } = await ErrorUtils.safeExecute(
    () => riskyOperation(true)
  );

  if (!success) {
    ErrorUtils.logError(error, 'riskyOperation');
  }

  // Повторная попытка с экспоненциальным откатом
  const failingOperation = async () => {
    throw new Error('Временная ошибка');
  };

  try {
    await ErrorUtils.retryWithBackoff(failingOperation, 3, 500);
  } catch (error) {
    console.error('Все попытки не удались:', error.message);
  }
}
```

## Безопасность и защита

### 1. Защита от XSS и других уязвимостей

```javascript
// utils/security.js - утилиты безопасности
class SecurityUtils {
  /**
   * Экранирование HTML
   * @param {string} str - строка для экранирования
   * @returns {string} - заэкранированная строка
   */
  static escapeHtml(str) {
    if (typeof str !== 'string') return '';

    const escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };

    return str.replace(/[&<>"'\/]/g, (match) => escapeMap[match]);
  }

  /**
   * Санитизация HTML с разрешенными тегами
   * @param {string} html - HTML для санитизации
   * @param {Array} allowedTags - разрешенные теги
   * @param {Array} allowedAttributes - разрешенные атрибуты
   * @returns {string} - санитизированный HTML
   */
  static sanitizeHtml(html, allowedTags = [], allowedAttributes = []) {
    // В реальном приложении использовать библиотеку типа DOMPurify
    // Этот пример показывает базовый подход

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    const walk = (node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();

        // Удаляем неразрешенные теги
        if (!allowedTags.includes(tagName)) {
          // Сохраняем дочерние элементы
          const children = Array.from(node.childNodes);
          for (const child of children) {
            node.parentNode.insertBefore(child, node);
          }
          node.remove();
          return;
        }

        // Удаляем неразрешенные атрибуты
        const attributes = Array.from(node.attributes);
        for (const attr of attributes) {
          if (!allowedAttributes.includes(attr.name)) {
            node.removeAttribute(attr.name);
          }
        }
      }

      // Рекурсивно обрабатываем дочерние узлы
      const children = Array.from(node.childNodes);
      for (const child of children) {
        walk(child);
      }
    };

    walk(tempDiv);
    return tempDiv.innerHTML;
  }

  /**
   * Генерация CSRF токена
   * @returns {string} - CSRF токен
   */
  static generateCsrfToken() {
    return Array.from(crypto.getRandomValues(new Uint8Array(32)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  /**
   * Валидация JWT токена (упрощенная)
   * @param {string} token - JWT токен
   * @returns {object} - декодированные данные или null
   */
  static validateJwt(token) {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) {
        return null;
      }

      const payload = JSON.parse(atob(parts[1]));

      // Проверка срока действия
      if (payload.exp && Date.now() >= payload.exp * 1000) {
        return null;
      }

      return payload;
    } catch (error) {
      return null;
    }
  }

  /**
   * Создание безопасного хэша пароля
   * @param {string} password - пароль
   * @returns {Promise<string>} - хэш пароля
   */
  static async hashPassword(password) {
    // В реальном приложении использовать bcrypt или scrypt
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Проверка пароля
   * @param {string} password - пароль
   * @param {string} hash - хэш для сравнения
   * @returns {Promise<boolean>} - результат проверки
   */
  static async verifyPassword(password, hash) {
    const passwordHash = await this.hashPassword(password);
    // Используем безопасное сравнение для предотвращения timing атак
    return this.timingSafeEqual(passwordHash, hash);
  }

  /**
   * Безопасное сравнение строк (предотвращение timing атак)
   * @param {string} a - первая строка
   * @param {string} b - вторая строка
   * @returns {boolean} - результат сравнения
   */
  static timingSafeEqual(a, b) {
    if (a.length !== b.length) {
      // Выполняем сравнение в любом случае для одинакового времени выполнения
      let result = 0;
      for (let i = 0; i < a.length; i++) {
        result |= a.charCodeAt(i) ^ b.charCodeAt(i);
      }
      return false;
    }

    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }

  /**
   * Проверка CSRF токена
   * @param {string} token - токен для проверки
   * @param {string} expectedToken - ожидаемый токен
   * @returns {boolean} - результат проверки
   */
  static validateCsrfToken(token, expectedToken) {
    if (!token || !expectedToken) {
      return false;
    }

    return this.timingSafeEqual(token, expectedToken);
  }

  /**
   * Создание безопасного сеанса
   * @param {object} userData - данные пользователя
   * @returns {string} - токен сеанса
   */
  static createSecureSession(userData) {
    const sessionData = {
      ...userData,
      createdAt: Date.now(),
      sessionId: this.generateSecureId()
    };

    // В реальном приложении шифровать данные сеанса
    return btoa(JSON.stringify(sessionData));
  }

  /**
   * Генерация криптографически безопасного ID
   * @returns {string} - безопасный ID
   */
  static generateSecureId() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
}

// Пример использования утилит безопасности
async function exampleSecurityUsage() {
  // Экранирование пользовательского ввода
  const userInput = '<script>alert("XSS")</script>';
  const safeOutput = SecurityUtils.escapeHtml(userInput);
  console.log('Безопасный вывод:', safeOutput);

  // Санитизация HTML
  const unsafeHtml = '<p>Безопасный текст</p><script>alert("XSS")</script>';
  const safeHtml = SecurityUtils.sanitizeHtml(unsafeHtml, ['p'], []);
  console.log('Санитизированный HTML:', safeHtml);

  // Генерация CSRF токена
  const csrfToken = SecurityUtils.generateCsrfToken();
  console.log('CSRF токен:', csrfToken);

  // Хэширование пароля
  const password = 'securePassword123';
  const passwordHash = await SecurityUtils.hashPassword(password);
  console.log('Хэш пароля:', passwordHash);

  // Проверка пароля
  const isValid = await SecurityUtils.verifyPassword(password, passwordHash);
  console.log('Проверка пароля:', isValid);
}
```

## Практические советы

### 1. Лучшие практики кодирования

```javascript
// best-practices.js - примеры лучших практик

// 1. Использование const/let вместо var
const PI = 3.14159;
let counter = 0;

// 2. Функции с одним предназначением
function calculateTotalPrice(items) {
  return items.reduce((total, item) => total + item.price, 0);
}

function applyDiscount(total, discountPercent) {
  return total * (1 - discountPercent / 100);
}

function formatPrice(price) {
  return price.toFixed(2);
}

// 3. Использование деструктуризации
function processUser({ name, email, age }) {
  console.log(`Имя: ${name}, Email: ${email}, Возраст: ${age}`);
}

// 4. Использование spread оператора
const baseConfig = { theme: 'dark', lang: 'ru' };
const userConfig = { ...baseConfig, notifications: true };

// 5. Использование async/await вместо Promise.then
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP ошибка: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Ошибка получения данных пользователя:', error);
    throw error;
  }
}

// 6. Правильная обработка ошибок
class ApiError extends Error {
  constructor(message, status, details = {}) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.details = details;
  }
}

async function apiCall(url, options = {}) {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new ApiError(
        errorData.message || 'Ошибка API',
        response.status,
        errorData
      );
    }

    return await response.json();
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }

    throw new ApiError('Сетевая ошибка', 0, { originalError: error });
  }
}

// 7. Использование валидации данных
function validateUser(userData) {
  const requiredFields = ['name', 'email'];
  const errors = [];

  for (const field of requiredFields) {
    if (!userData[field]) {
      errors.push(`Поле ${field} обязательно`);
    }
  }

  if (userData.email && !isValidEmail(userData.email)) {
    errors.push('Некорректный email');
  }

  if (errors.length > 0) {
    throw new Error(`Ошибки валидации: ${errors.join(', ')}`);
  }

  return true;
}

function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// 8. Использование модулей и экспорта
export class UserService {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }

  async getUser(id) {
    const userData = await this.apiClient.get(`/users/${id}`);
    return new User(userData);
  }

  async createUser(userData) {
    validateUser(userData);
    const createdUser = await this.apiClient.post('/users', userData);
    return new User(createdUser);
  }
}

// 9. Использование типов (JSDoc или TypeScript)
/**
 * Класс пользователя
 * @class
 */
export class User {
  /**
   * Создает пользователя
   * @param {object} data - данные пользователя
   * @param {number} data.id - ID пользователя
   * @param {string} data.name - имя пользователя
   * @param {string} data.email - email пользователя
   */
  constructor(data) {
    this.id = data.id;
    this.name = data.name;
    this.email = data.email;
    this.createdAt = new Date(data.createdAt);
  }

  /**
   * Проверяет, является ли пользователь администратором
   * @returns {boolean} - true если администратор
   */
  isAdmin() {
    return this.email.endsWith('@admin.com');
  }
}
```

### 2. Оптимизация производительности

```javascript
// performance-optimizations.js - примеры оптимизации производительности

// 1. Memoization для дорогостоящих вычислений
class Memoizer {
  constructor() {
    this.cache = new Map();
  }

  memoize(fn, keyFn = (...args) => JSON.stringify(args)) {
    return (...args) => {
      const key = keyFn(...args);

      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      const result = fn(...args);
      this.cache.set(key, result);
      return result;
    };
  }

  clear() {
    this.cache.clear();
  }
}

const memoizer = new Memoizer();

// Функция с дорогостоящими вычислениями
const expensiveCalculation = memoizer.memoize((n) => {
  let result = 0;
  for (let i = 0; i < n; i++) {
    result += Math.sqrt(i) * Math.sin(i);
  }
  return result;
});

// 2. Ленивая загрузка компонентов (в браузере)
class LazyLoader {
  static async loadComponent(url) {
    const response = await fetch(url);
    const componentCode = await response.text();

    // В реальном приложении использовать более безопасный способ
    // например, динамический import() или шаблонизатор
    const script = document.createElement('script');
    script.textContent = componentCode;
    document.head.appendChild(script);
  }

  static async loadModule(modulePath) {
    return await import(modulePath);
  }
}

// 3. Оптимизация рендеринга списков
class ListRenderer {
  constructor(container) {
    this.container = container;
    this.visibleItems = new Set();
  }

  // Рендеринг с виртуализацией
  renderVirtualizedList(items, renderItem, itemHeight) {
    const containerHeight = this.container.clientHeight;
    const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // +2 для буфера

    // Определяем диапазон видимых элементов
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(startIndex + visibleCount, items.length);

    // Очищаем контейнер
    this.container.innerHTML = '';

    // Создаем контейнер для позиционирования
    const listContainer = document.createElement('div');
    listContainer.style.height = `${items.length * itemHeight}px`;
    listContainer.style.position = 'relative';

    // Добавляем видимые элементы
    for (let i = startIndex; i < endIndex; i++) {
      const itemElement = renderItem(items[i], i);
      itemElement.style.position = 'absolute';
      itemElement.style.top = `${i * itemHeight}px`;
      itemElement.style.width = '100%';

      listContainer.appendChild(itemElement);
    }

    this.container.appendChild(listContainer);
  }

  // Рендеринг с батчингом
  async renderBatched(items, renderItem, batchSize = 10) {
    this.container.innerHTML = '';

    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);

      const batchElements = batch.map((item, index) =>
        renderItem(item, i + index)
      );

      batchElements.forEach(el => this.container.appendChild(el));

      // Даем браузеру время на рендеринг
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
}

// 4. Использование Web Workers для тяжелых вычислений
class WorkerManager {
  constructor() {
    this.workers = new Map();
  }

  createWorker(workerScript) {
    const worker = new Worker(workerScript);
    const workerId = Date.now().toString();

    this.workers.set(workerId, worker);
    return { workerId, worker };
  }

  async executeTask(workerId, task, data) {
    return new Promise((resolve, reject) => {
      const worker = this.workers.get(workerId);

      worker.onmessage = (event) => {
        if (event.data.error) {
          reject(new Error(event.data.error));
        } else {
          resolve(event.data.result);
        }
      };

      worker.onerror = (error) => {
        reject(error);
      };

      worker.postMessage({ task, data });
    });
  }

  terminateWorker(workerId) {
    const worker = this.workers.get(workerId);
    if (worker) {
      worker.terminate();
      this.workers.delete(workerId);
    }
  }
}

// 5. Оптимизация памяти
class MemoryOptimizer {
  // Использование WeakMap для предотвращения утечек памяти
  static createWeakCache() {
    return new WeakMap();
  }

  // Очистка ссылок для GC
  static cleanupReferences(obj) {
    for (const key in obj) {
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        obj[key] = null;
      }
    }
  }

  // Использование Object Pool для часто создаваемых объектов
  static createObjectPool(createFn, resetFn) {
    const pool = [];

    return {
      acquire() {
        if (pool.length > 0) {
          return pool.pop();
        }
        return createFn();
      },

      release(obj) {
        resetFn(obj);
        pool.push(obj);
      },

      size() {
        return pool.length;
      }
    };
  }
}
```

## Связанные темы

- [[javascript-best-practices]]
- [[security-considerations]]
- [[performance-optimization-techniques]]
- [[testing-strategies]]

Эти современные практики помогают создавать более надежные, производительные и поддерживаемые JavaScript приложения. Важно адаптировать их под конкретные требования проекта и контекст использования.