---
aliases: ["Error Handling", "API Error Management", "HTTP Error Handling"]
tags: [javascript, api, http, error-handling, frontend, web-development]
---

# Обработка ошибок при работе с API

## Типы ошибок при работе с API

При работе с API могут возникать различные типы ошибок:

1. **Сетевые ошибки** - проблемы с подключением к серверу
2. **HTTP-ошибки** - ошибки на уровне протокола (4xx, 5xx)
3. **Ошибки данных** - некорректные форматы данных
4. **Ошибки бизнес-логики** - логические ошибки в приложении

## Обработка сетевых ошибок

Сетевые ошибки возникают при проблемах с подключением к серверу:

```javascript
async function fetchWithNetworkErrorHandling(url) {
  try {
    const response = await fetch(url);
    return response;
  } catch (error) {
    // Сетевая ошибка (например, отсутствие подключения)
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      console.error('Ошибка сети:', error.message);
      throw new Error('Нет подключения к интернету или сервер недоступен');
    }
    throw error;
  }
}
```

## Обработка HTTP-ошибок

HTTP-ошибки требуют специфической обработки в зависимости от статуса:

```javascript
class ApiError extends Error {
  constructor(message, status, response = null) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.response = response;
  }
}

async function handleHttpErrors(response) {
  if (!response.ok) {
    let errorMessage = `HTTP ошибка! Статус: ${response.status}`;
    let errorData = null;
    
    try {
      errorData = await response.json();
      errorMessage = errorData.message || errorMessage;
    } catch (e) {
      // Если не удалось распарсить JSON, используем текст
      try {
        errorData = await response.text();
        errorMessage = errorData;
      } catch (e) {
        // Оставляем стандартное сообщение об ошибке
      }
    }
    
    throw new ApiError(errorMessage, response.status, errorData);
  }
  
  return response;
}

// Использование
async function fetchDataWithErrorHandling(url) {
  try {
    const response = await fetch(url);
    await handleHttpErrors(response);
    return await response.json();
  } catch (error) {
    if (error instanceof ApiError) {
      console.error(`HTTP ошибка ${error.status}:`, error.message);
      // Обработка конкретных HTTP-ошибок
      switch (error.status) {
        case 401:
          // Перенаправление на страницу авторизации
          window.location.href = '/login';
          break;
        case 403:
          console.error('Доступ запрещен');
          break;
        case 429:
          console.error('Слишком много запросов. Повторите позже.');
          break;
        case 500:
          console.error('Внутренняя ошибка сервера');
          break;
        default:
          console.error('Неизвестная ошибка:', error.message);
      }
    } else {
      console.error('Сетевая ошибка:', error.message);
    }
    throw error;
  }
}
```

## Повторные попытки запросов

В условиях нестабильного интернета в России полезно реализовать повторные попытки запросов:

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
  let lastError;
  
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      // Проверяем успешность ответа
      if (response.ok) {
        return response;
      }
      
      // Если статус ошибки не подлежит повтору, прерываем
      if (response.status >= 400 && response.status < 500 && response.status !== 429) {
        throw new ApiError(`Клиентская ошибка: ${response.status}`, response.status);
      }
      
      lastError = new ApiError(`HTTP ошибка: ${response.status}`, response.status);
    } catch (error) {
      lastError = error;
    }
    
    // Если это последняя попытка, выбрасываем ошибку
    if (i === maxRetries) {
      throw lastError;
    }
    
    // Ждем перед повторной попыткой
    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i))); // Экспоненциальная задержка
  }
}

// Использование
async function fetchDataWithRetry(url) {
  try {
    const response = await fetchWithRetry(url);
    return await response.json();
  } catch (error) {
    console.error('Ошибка после всех попыток:', error.message);
    throw error;
  }
}
```

## Обработка ошибок валидации

Ошибки валидации данных часто возвращаются с сервера:

```javascript
async function handleValidationErrors(response) {
  if (!response.ok) {
    const errorData = await response.json();
    
    if (response.status === 422) { // Unprocessable Entity
      // Обработка ошибок валидации
      if (errorData.errors) {
        const validationErrors = {};
        
        errorData.errors.forEach(error => {
          if (!validationErrors[error.field]) {
            validationErrors[error.field] = [];
          }
          validationErrors[error.field].push(error.message);
        });
        
        throw new Error('Ошибки валидации', { cause: validationErrors });
      }
    }
    
    throw new ApiError(errorData.message || 'Ошибка сервера', response.status);
  }
  
  return response;
}
```

## Централизованная обработка ошибок

Для сложных приложений полезно создать централизованный обработчик ошибок:

```javascript
class ApiErrorHandler {
  constructor() {
    this.handlers = new Map();
    this.defaultHandler = this.defaultErrorHandler.bind(this);
  }
  
  // Регистрация специфического обработчика для определенного типа ошибки
  registerHandler(errorType, handler) {
    this.handlers.set(errorType, handler);
  }
  
  // Обработка ошибки
  async handleError(error, context = {}) {
    // Определяем тип ошибки
    const errorType = this.determineErrorType(error);
    
    // Ищем специфический обработчик
    const handler = this.handlers.get(errorType) || this.defaultHandler;
    
    return await handler(error, context);
  }
  
  // Определение типа ошибки
  determineErrorType(error) {
    if (error instanceof ApiError) {
      return `http_${error.status}`;
    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
      return 'network';
    } else if (error.message.includes('timeout')) {
      return 'timeout';
    }
    return 'unknown';
  }
  
  // Стандартный обработчик ошибок
  async defaultErrorHandler(error, context) {
    console.error('Необработанная ошибка:', error);
    
    // Логирование ошибки для аналитики
    this.logError(error, context);
    
    // В зависимости от контекста можно показать пользователю сообщение
    if (context.showUserMessage) {
      this.showUserError(error);
    }
  }
  
  // Логирование ошибки
  logError(error, context) {
    // В реальном приложении это может быть отправка в систему мониторинга
    console.group('Ошибка API');
    console.error('Ошибка:', error.message);
    console.error('Контекст:', context);
    console.error('Стек:', error.stack);
    console.groupEnd();
  }
  
  // Показ ошибки пользователю
  showUserError(error) {
    // В реальном приложении это может быть показ уведомления
    alert(`Произошла ошибка: ${error.message}`);
  }
}

// Использование
const errorHandler = new ApiErrorHandler();

// Регистрация специфического обработчика для 401 ошибки
errorHandler.registerHandler('http_401', async (error) => {
  console.error('Пользователь не авторизован:', error.message);
  // Перенаправление на страницу авторизации
  window.location.href = '/login';
});

// Регистрация обработчика сетевых ошибок
errorHandler.registerHandler('network', async (error) => {
  console.error('Сетевая ошибка:', error.message);
  alert('Проверьте подключение к интернету');
});
```

## Обработка ошибок с использованием Axios

Если вы используете Axios, обработка ошибок может быть несколько иной:

```javascript
import axios from 'axios';

// Перехватчик ответов для обработки ошибок
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response) {
      // Сервер ответил с ошибочным статусом
      switch (error.response.status) {
        case 401:
          // Обработка неавторизованного доступа
          localStorage.removeItem('token');
          window.location.href = '/login';
          break;
        case 403:
          console.error('Доступ запрещен');
          break;
        case 429:
          console.error('Слишком много запросов');
          break;
        case 500:
          console.error('Внутренняя ошибка сервера');
          break;
      }
    } else if (error.request) {
      // Запрос был сделан, но ответ не получен (сетевая ошибка)
      console.error('Сетевая ошибка:', error.message);
    } else {
      // Что-то произошло при настройке запроса
      console.error('Ошибка настройки запроса:', error.message);
    }
    
    return Promise.reject(error);
  }
);
```

## Логирование ошибок

Для эффективной отладки важно логировать ошибки:

```javascript
class ApiLogger {
  static log(level, message, data = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      data,
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    // В реальном приложении это может быть отправка в систему логирования
    console[level](logEntry);
  }
  
  static error(message, error, additionalData = {}) {
    this.log('error', message, {
      ...additionalData,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    });
  }
  
  static warn(message, data = {}) {
    this.log('warn', message, data);
  }
}

// Использование в API-запросах
async function fetchWithErrorLogging(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      const error = new ApiError(`HTTP ошибка: ${response.status}`, response.status);
      ApiLogger.error('Ошибка API', error, { url, method: 'GET' });
      throw error;
    }
    return response;
  } catch (error) {
    ApiLogger.error('Сетевая ошибка', error, { url });
    throw error;
  }
}
```

## Пользовательские сообщения об ошибках

В российских проектах важно предоставлять понятные сообщения об ошибках на русском языке:

```javascript
const ERROR_MESSAGES = {
  400: 'Неверный запрос. Проверьте правильность введенных данных.',
  401: 'Требуется авторизация. Пожалуйста, войдите в систему.',
  403: 'Доступ запрещен. У вас недостаточно прав для выполнения операции.',
  404: 'Запрашиваемый ресурс не найден.',
  422: 'Данные не прошли валидацию. Проверьте правильность заполнения формы.',
  429: 'Слишком много запросов. Пожалуйста, повторите попытку позже.',
  500: 'Внутренняя ошибка сервера. Пожалуйста, повторите попытку позже.',
  502: 'Сервер временно недоступен. Пожалуйста, повторите попытку позже.',
  503: 'Сервис временно недоступен. Пожалуйста, повторите попытку позже.',
  network: 'Ошибка подключения к интернету. Проверьте соединение и повторите попытку.',
  timeout: 'Время ожидания запроса истекло. Проверьте соединение и повторите попытку.'
};

function getErrorMessage(error) {
  if (error instanceof ApiError) {
    return ERROR_MESSAGES[error.status] || `Ошибка: ${error.message}`;
  } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
    return ERROR_MESSAGES.network;
  } else if (error.message.includes('timeout')) {
    return ERROR_MESSAGES.timeout;
  }
  return error.message || 'Неизвестная ошибка';
}
```

## Заключение

Эффективная обработка ошибок при работе с API критически важна для создания надежных приложений. В российских условиях особенно важно учитывать нестабильность интернет-соединений и обеспечивать понятные сообщения об ошибках для пользователей.

См. также:
- [[Работа-с-API]]
- [[Обработка-ответов]]
- [[Авторизация-и-аутентификация]]
- [[Кэширование-запросов]]