---
aliases: ["Request Caching", "API Caching", "HTTP Caching", "Browser Cache"]
tags: [javascript, api, caching, performance, frontend, web-development]
---

# Кэширование запросов в JavaScript

## Введение в кэширование

Кэширование - это важная техника оптимизации производительности при работе с API, позволяющая уменьшить количество сетевых запросов и ускорить загрузку данных. В условиях российской инфраструктуры кэширование особенно важно для обеспечения быстрого отклика приложений.

## Типы кэширования

### 1. Кэширование на уровне браузера (HTTP кэш)

Браузер автоматически кэширует ответы с соответствующими заголовками:

```javascript
// Пример запроса с кэшированием
async function fetchWithBrowserCache(url) {
  const response = await fetch(url, {
    // Используем стандартную политику кэширования браузера
    cache: 'default' // или 'no-cache', 'reload', 'force-cache', 'only-if-cached'
  });
  
  return response.json();
}
```

### 2. Кэширование в памяти JavaScript

Простое кэширование в переменной для быстрого доступа:

```javascript
class InMemoryCache {
  constructor(ttl = 300000) { // 5 минут по умолчанию
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  set(key, value) {
    const expiration = Date.now() + this.ttl;
    this.cache.set(key, { value, expiration });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiration) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  has(key) {
    const item = this.cache.get(key);
    if (!item) return false;
    
    if (Date.now() > item.expiration) {
      this.cache.delete(key);
      return false;
    }
    
    return true;
  }
  
  delete(key) {
    return this.cache.delete(key);
  }
  
  clear() {
    this.cache.clear();
  }
}

// Использование
const memoryCache = new InMemoryCache(60000); // 1 минута
```

### 3. Кэширование в localStorage

Для долгосрочного хранения данных:

```javascript
class LocalStorageCache {
  constructor(namespace = 'api_cache') {
    this.namespace = namespace;
  }
  
  set(key, value, ttl = 3600000) { // 1 час по умолчанию
    const expiration = Date.now() + ttl;
    const item = {
      value: value,
      expiration: expiration
    };
    
    try {
      localStorage.setItem(`${this.namespace}:${key}`, JSON.stringify(item));
    } catch (error) {
      console.warn('Не удалось сохранить в localStorage:', error);
    }
  }
  
  get(key) {
    try {
      const item = localStorage.getItem(`${this.namespace}:${key}`);
      if (!item) return null;
      
      const parsed = JSON.parse(item);
      
      if (Date.now() > parsed.expiration) {
        localStorage.removeItem(`${this.namespace}:${key}`);
        return null;
      }
      
      return parsed.value;
    } catch (error) {
      console.error('Ошибка при чтении из localStorage:', error);
      return null;
    }
  }
  
  delete(key) {
    localStorage.removeItem(`${this.namespace}:${key}`);
  }
  
  clear() {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(`${this.namespace}:`)) {
        localStorage.removeItem(key);
      }
    }
  }
}

// Использование
const localStorageCache = new LocalStorageCache();
```

## Комплексное кэширование API

Создадим универсальный класс для кэширования API-запросов:

```javascript
class ApiCacheManager {
  constructor(options = {}) {
    this.memoryCache = new InMemoryCache(options.memoryTTL || 300000); // 5 минут
    this.storageCache = new LocalStorageCache(options.storageNamespace || 'api_cache');
    this.storageTTL = options.storageTTL || 3600000; // 1 час
    this.enableStorage = options.enableStorage !== false; // По умолчанию включено
  }
  
  // Генерация уникального ключа для кэша
  generateCacheKey(url, options = {}) {
    const params = new URLSearchParams();
    
    // Добавляем параметры из URL
    const urlObj = new URL(url, window.location.origin);
    for (const [key, value] of urlObj.searchParams) {
      params.append(key, value);
    }
    
    // Добавляем важные заголовки в ключ
    if (options.headers && options.headers.Authorization) {
      params.append('_auth', options.headers.Authorization);
    }
    
    // Добавляем метод запроса
    params.append('_method', options.method || 'GET');
    
    return `${urlObj.pathname}?${params.toString()}`;
  }
  
  // Получение данных из кэша
  getCachedData(key) {
    // Сначала проверяем память
    let data = this.memoryCache.get(key);
    if (data) {
      return { data, source: 'memory' };
    }
    
    // Затем проверяем storage
    if (this.enableStorage) {
      data = this.storageCache.get(key);
      if (data) {
        // Обновляем в памяти для быстрого доступа
        this.memoryCache.set(key, data);
        return { data, source: 'storage' };
      }
    }
    
    return null;
  }
  
  // Сохранение данных в кэш
  setCachedData(key, data) {
    // Сохраняем в память
    this.memoryCache.set(key, data);
    
    // Сохраняем в storage
    if (this.enableStorage) {
      this.storageCache.set(key, data, this.storageTTL);
    }
  }
  
  // Выполнение кэшированного запроса
  async cachedFetch(url, options = {}) {
    const cacheKey = this.generateCacheKey(url, options);
    
    // Проверяем кэш только для GET-запросов
    if ((options.method || 'GET').toUpperCase() === 'GET') {
      const cached = this.getCachedData(cacheKey);
      if (cached) {
        console.log(`Данные получены из ${cached.source} кэша:`, cacheKey);
        return cached.data;
      }
    }
    
    try {
      // Выполняем запрос
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Кэшируем только успешные GET-запросы
      if ((options.method || 'GET').toUpperCase() === 'GET') {
        this.setCachedData(cacheKey, data);
        console.log(`Данные закэшированы:`, cacheKey);
      }
      
      return data;
    } catch (error) {
      // В случае ошибки сетевого запроса, можно вернуть устаревшие данные из кэша
      if ((options.method || 'GET').toUpperCase() === 'GET') {
        const cached = this.getCachedData(cacheKey);
        if (cached) {
          console.warn('Возвращаем устаревшие данные из кэша из-за ошибки сети');
          return cached.data;
        }
      }
      throw error;
    }
  }
  
  // Инвалидация кэша
  invalidateCache(pattern) {
    // Инвалидация по шаблону (упрощенная реализация)
    if (pattern === 'all') {
      this.memoryCache.clear();
      this.storageCache.clear();
    } else {
      // Для конкретного ключа
      this.memoryCache.delete(pattern);
      this.storageCache.delete(pattern);
    }
  }
}

// Использование
const apiCache = new ApiCacheManager({
  memoryTTL: 60000,      // 1 минута в памяти
  storageTTL: 3600000,   // 1 час в storage
  enableStorage: true
});
```

## Умное кэширование с проверкой свежести

Для более сложных сценариев создадим кэш с проверкой свежести данных:

```javascript
class SmartCache {
  constructor(ttl = 300000, staleWhileRevalidate = 60000) {
    this.cache = new Map();
    this.ttl = ttl;
    this.staleWhileRevalidate = staleWhileRevalidate;
    this.pendingRequests = new Map(); // Для предотвращения дублирующихся запросов
  }
  
  async get(key, fetchFunction) {
    const now = Date.now();
    
    // Проверяем, есть ли уже ожидающий запрос
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }
    
    const cachedItem = this.cache.get(key);
    
    // Если данные есть и они свежие
    if (cachedItem && now < cachedItem.expiration) {
      return cachedItem.data;
    }
    
    // Если данные есть, но они устарели, но еще в периоде stale-while-revalidate
    if (cachedItem && now < cachedItem.expiration + this.staleWhileRevalidate) {
      // Возвращаем устаревшие данные, но запускаем обновление в фоне
      const pendingRequest = fetchFunction().then(data => {
        this.set(key, data);
        this.pendingRequests.delete(key);
        return data;
      }).catch(error => {
        this.pendingRequests.delete(key);
        throw error;
      });
      
      this.pendingRequests.set(key, pendingRequest);
      return cachedItem.data;
    }
    
    // Нет свежих данных, делаем запрос
    const pendingRequest = fetchFunction().then(data => {
      this.set(key, data);
      this.pendingRequests.delete(key);
      return data;
    }).catch(error => {
      this.pendingRequests.delete(key);
      throw error;
    });
    
    this.pendingRequests.set(key, pendingRequest);
    return pendingRequest;
  }
  
  set(key, data) {
    const expiration = Date.now() + this.ttl;
    this.cache.set(key, { data, expiration });
  }
  
  has(key) {
    const item = this.cache.get(key);
    if (!item) return false;
    return Date.now() < item.expiration;
  }
  
  delete(key) {
    this.cache.delete(key);
    if (this.pendingRequests.has(key)) {
      this.pendingRequests.get(key).cancel && this.pendingRequests.get(key).cancel();
      this.pendingRequests.delete(key);
    }
  }
}

// Использование
const smartCache = new SmartCache(60000, 30000); // 1 минута TTL, 30 секунд stale-while-revalidate

async function fetchUserData(userId) {
  return smartCache.get(`user_${userId}`, () => 
    fetch(`/api/users/${userId}`).then(r => r.json())
  );
}
```

## Кэширование с использованием IndexedDB

Для больших объемов данных используем IndexedDB:

```javascript
class IndexedDBCache {
  constructor(dbName = 'api_cache_db', version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('cache')) {
          const store = db.createObjectStore('cache', { keyPath: 'key' });
          store.createIndex('expiration', 'expiration', { unique: false });
        }
      };
    });
  }
  
  async set(key, value, ttl = 3600000) { // 1 час по умолчанию
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    const expiration = Date.now() + ttl;
    const item = { key, value, expiration };
    
    return new Promise((resolve, reject) => {
      const request = store.put(item);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  async get(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readonly');
    const store = transaction.objectStore('cache');
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => {
        const result = request.result;
        if (result && Date.now() < result.expiration) {
          resolve(result.value);
        } else {
          if (result) {
            // Удаляем просроченные данные
            this.delete(key);
          }
          resolve(null);
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  async delete(key) {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  // Очистка просроченных записей
  async cleanup() {
    if (!this.db) await this.init();
    
    const transaction = this.db.transaction(['cache'], 'readwrite');
    const store = transaction.objectStore('cache');
    const index = store.index('expiration');
    
    const now = Date.now();
    const range = IDBKeyRange.upperBound(now);
    
    return new Promise((resolve, reject) => {
      const request = index.openCursor(range);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        } else {
          resolve();
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
}

// Использование
const indexedDBCache = new IndexedDBCache();
```

## Кэширование с Service Worker

Для оффлайн-функциональности используем Service Worker:

```javascript
// Регистрация Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(registration => {
      console.log('Service Worker зарегистрирован:', registration.scope);
    })
    .catch(error => {
      console.error('Ошибка регистрации Service Worker:', error);
    });
}

// Пример содержимого sw.js
/*
const CACHE_NAME = 'api-cache-v1';
const urlsToCache = [
  '/api/users',
  '/api/posts'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Возврат кэшированного ответа или выполнение запроса
        return response || fetch(event.request);
      })
  );
});
*/
```

## Практические рекомендации по кэшированию

### 1. Выбор подходящего стратегии кэширования

```javascript
// Стратегии кэширования
const CacheStrategies = {
  // Network only - всегда запрашивать с сервера
  NETWORK_ONLY: 'network-only',
  
  // Cache only - только из кэша
  CACHE_ONLY: 'cache-only',
  
  // Cache first - сначала кэш, затем сеть
  CACHE_FIRST: 'cache-first',
  
  // Network first - сначала сеть, затем кэш
  NETWORK_FIRST: 'network-first',
  
  // Stale while revalidate - устаревшие данные + фоновое обновление
  STALE_WHILE_REVALIDATE: 'stale-while-revalidate'
};

class CacheStrategy {
  static async execute(strategy, key, fetchFunction, cacheManager) {
    switch (strategy) {
      case CacheStrategies.NETWORK_ONLY:
        return await fetchFunction();
        
      case CacheStrategies.CACHE_ONLY:
        const cached = cacheManager.get(key);
        if (cached) return cached;
        throw new Error('Данные отсутствуют в кэше');
        
      case CacheStrategies.CACHE_FIRST:
        const cachedFirst = cacheManager.get(key);
        if (cachedFirst) return cachedFirst;
        const networkFirst = await fetchFunction();
        cacheManager.set(key, networkFirst);
        return networkFirst;
        
      case CacheStrategies.NETWORK_FIRST:
        try {
          const network = await fetchFunction();
          cacheManager.set(key, network);
          return network;
        } catch (error) {
          const cachedNetwork = cacheManager.get(key);
          if (cachedNetwork) return cachedNetwork;
          throw error;
        }
        
      case CacheStrategies.STALE_WHILE_REVALIDATE:
        const stale = cacheManager.get(key);
        const fresh = fetchFunction().then(data => {
          cacheManager.set(key, data);
          return data;
        });
        
        return stale || fresh;
        
      default:
        throw new Error(`Неизвестная стратегия кэширования: ${strategy}`);
    }
  }
}
```

### 2. Управление размером кэша

```javascript
class SizeAwareCache {
  constructor(maxSize = 10 * 1024 * 1024) { // 10 МБ по умолчанию
    this.cache = new Map();
    this.size = 0;
    this.maxSize = maxSize;
  }
  
  estimateSize(value) {
    // Грубая оценка размера объекта в байтах
    return JSON.stringify(value).length;
  }
  
  set(key, value) {
    const itemSize = this.estimateSize(value);
    
    // Если добавление превысит максимальный размер, удаляем старые элементы
    while (this.size + itemSize > this.maxSize && this.cache.size > 0) {
      // Удаляем самый старый элемент (в реальном приложении может быть LRU или другая стратегия)
      const firstKey = this.cache.keys().next().value;
      const removedItem = this.cache.get(firstKey);
      this.size -= this.estimateSize(removedItem);
      this.cache.delete(firstKey);
    }
    
    if (itemSize <= this.maxSize) {
      this.cache.set(key, value);
      this.size += itemSize;
    } else {
      console.warn(`Элемент слишком большой для кэша: ${key}`);
    }
  }
  
  get(key) {
    return this.cache.get(key);
  }
  
  has(key) {
    return this.cache.has(key);
  }
  
  delete(key) {
    const item = this.cache.get(key);
    if (item) {
      this.size -= this.estimateSize(item);
      this.cache.delete(key);
    }
  }
}
```

## Заключение

Кэширование запросов - мощный инструмент для повышения производительности веб-приложений. В российских условиях, где качество интернет-соединения может быть нестабильным, эффективное кэширование особенно важно для обеспечения хорошего пользовательского опыта.

Выбор стратегии кэширования зависит от характера данных и требований к свежести информации. Для статичных данных подходит длительное кэширование, а для часто изменяемых данных - более короткие сроки жизни кэша или стратегия stale-while-revalidate.

См. также:
- [[Работа-с-API]]
- [[Обработка-ответов]]
- [[Обработка-ошибок]]
- [[Авторизация-и-аутентификация]]