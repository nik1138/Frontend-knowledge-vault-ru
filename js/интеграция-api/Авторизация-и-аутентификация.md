---
aliases: ["Authentication", "Authorization", "API Security", "JWT Authentication"]
tags: [javascript, api, security, authentication, authorization, jwt, frontend]
---

# Авторизация и аутентификация при работе с API

## Основные понятия

**Аутентификация** - процесс проверки личности пользователя (кто ты?)
**Авторизация** - процесс проверки прав доступа (что ты можешь делать?)

## Типы аутентификации

### 1. Токены (JWT - JSON Web Tokens)

JWT - наиболее распространенный метод аутентификации в современных приложениях:

```javascript
// Функция для аутентификации пользователя
async function login(credentials) {
  try {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(credentials)
    });
    
    if (!response.ok) {
      throw new Error('Неверные учетные данные');
    }
    
    const data = await response.json();
    
    // Сохраняем токен в localStorage или sessionStorage
    localStorage.setItem('token', data.token);
    
    return data;
  } catch (error) {
    console.error('Ошибка аутентификации:', error);
    throw error;
  }
}

// Функция для выхода из системы
function logout() {
  localStorage.removeItem('token');
  // Перенаправление на страницу входа
  window.location.href = '/login';
}

// Функция для проверки аутентификации
function isAuthenticated() {
  const token = localStorage.getItem('token');
  if (!token) return false;
  
  try {
    // Декодируем токен для проверки срока действия
    const payload = JSON.parse(atob(token.split('.')[1]));
    const currentTime = Math.floor(Date.now() / 1000);
    return payload.exp > currentTime;
  } catch (error) {
    return false;
  }
}
```

### 2. Управление токенами

Для безопасной работы с токенами создадим специальный класс:

```javascript
class TokenManager {
  static getToken() {
    return localStorage.getItem('token');
  }
  
  static setToken(token) {
    localStorage.setItem('token', token);
  }
  
  static removeToken() {
    localStorage.removeItem('token');
  }
  
  static isTokenExpired() {
    const token = this.getToken();
    if (!token) return true;
    
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp < currentTime;
    } catch (error) {
      return true;
    }
  }
  
  static getTokenExpirationTime() {
    const token = this.getToken();
    if (!token) return null;
    
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return new Date(payload.exp * 1000);
    } catch (error) {
      return null;
    }
  }
  
  static refreshToken() {
    return fetch('/api/auth/refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`
      }
    })
    .then(response => {
      if (response.ok) {
        return response.json();
      }
      throw new Error('Не удалось обновить токен');
    })
    .then(data => {
      this.setToken(data.token);
      return data.token;
    });
  }
}
```

## Централизованная функция запросов с авторизацией

Создадим универсальную функцию для выполнения запросов с автоматической обработкой авторизации:

```javascript
class ApiClient {
  constructor(baseURL = '') {
    this.baseURL = baseURL;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    // Устанавливаем заголовки по умолчанию
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };
    
    // Добавляем токен авторизации, если он существует
    const token = TokenManager.getToken();
    if (token && !TokenManager.isTokenExpired()) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    
    let response = await fetch(url, config);
    
    // Если токен истек и сервер вернул 401, пробуем обновить токен
    if (response.status === 401) {
      const refreshToken = TokenManager.getToken();
      if (refreshToken) {
        try {
          await TokenManager.refreshToken();
          // Повторяем запрос с новым токеном
          config.headers['Authorization'] = `Bearer ${TokenManager.getToken()}`;
          response = await fetch(url, config);
        } catch (refreshError) {
          // Если не удалось обновить токен, выходим из системы
          TokenManager.removeToken();
          window.location.href = '/login';
          throw new Error('Сессия истекла. Пожалуйста, войдите снова.');
        }
      } else {
        window.location.href = '/login';
        throw new Error('Требуется авторизация');
      }
    }
    
    return response;
  }
  
  async get(endpoint, options = {}) {
    return this.request(endpoint, { ...options, method: 'GET' });
  }
  
  async post(endpoint, data, options = {}) {
    return this.request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
  
  async put(endpoint, data, options = {}) {
    return this.request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }
  
  async delete(endpoint, options = {}) {
    return this.request(endpoint, { ...options, method: 'DELETE' });
  }
}

// Использование
const apiClient = new ApiClient('/api');
```

## Работа с HTTP-заголовками авторизации

Важно корректно устанавливать заголовки при каждом запросе:

```javascript
// Универсальная функция с автоматической авторизацией
async function authenticatedFetch(url, options = {}) {
  const token = TokenManager.getToken();
  
  const config = {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  };
  
  // Добавляем токен, если он существует и не истек
  if (token && !TokenManager.isTokenExpired()) {
    config.headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(url, config);
  
  // Обработка 401 ошибки
  if (response.status === 401) {
    // Пробуем обновить токен
    try {
      await TokenManager.refreshToken();
      // Повторяем запрос с новым токеном
      config.headers['Authorization'] = `Bearer ${TokenManager.getToken()}`;
      return await fetch(url, config);
    } catch (error) {
      // Если обновить токен не удалось, очищаем сессию
      TokenManager.removeToken();
      window.location.href = '/login';
      throw new Error('Сессия истекла');
    }
  }
  
  return response;
}
```

## Работа с сессиями и cookies

В некоторых российских проектах используется аутентификация через сессии:

```javascript
// Функция для работы с сессионными куками
async function loginWithSession(credentials) {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(credentials),
    credentials: 'include' // Отправляем куки с запросом
  });
  
  if (response.ok) {
    return await response.json();
  } else {
    throw new Error('Ошибка аутентификации');
  }
}

// Проверка сессии
async function checkSession() {
  const response = await fetch('/api/auth/session', {
    credentials: 'include'
  });
  
  return response.ok;
}
```

## Защита чувствительных данных

Важно безопасно хранить токены и другие чувствительные данные:

```javascript
// Более безопасное хранение токена с шифрованием (упрощенная версия)
class SecureTokenStorage {
  static encryptToken(token) {
    // В реальном приложении используйте криптографически стойкое шифрование
    return btoa(encodeURIComponent(token));
  }
  
  static decryptToken(encryptedToken) {
    try {
      return decodeURIComponent(atob(encryptedToken));
    } catch (error) {
      return null;
    }
  }
  
  static setToken(token) {
    const encryptedToken = this.encryptToken(token);
    sessionStorage.setItem('secure_token', encryptedToken);
  }
  
  static getToken() {
    const encryptedToken = sessionStorage.getItem('secure_token');
    if (!encryptedToken) return null;
    
    return this.decryptToken(encryptedToken);
  }
  
  static removeToken() {
    sessionStorage.removeItem('secure_token');
  }
}
```

## Работа с OAuth2 и OpenID Connect

Для интеграции с внешними провайдерами аутентификации:

```javascript
class OAuthClient {
  constructor(config) {
    this.config = config;
  }
  
  // Генерация URL для OAuth авторизации
  generateAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUri,
      response_type: 'code',
      scope: this.config.scopes.join(' '),
      state: this.generateState()
    });
    
    return `${this.config.authUrl}?${params}`;
  }
  
  generateState() {
    const state = Math.random().toString(36).substring(2, 15) + 
                  Math.random().toString(36).substring(2, 15);
    sessionStorage.setItem('oauth_state', state);
    return state;
  }
  
  // Обработка callback от OAuth провайдера
  async handleCallback() {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const state = urlParams.get('state');
    
    // Проверяем state параметр для безопасности
    const storedState = sessionStorage.getItem('oauth_state');
    if (state !== storedState) {
      throw new Error('Неверный state параметр');
    }
    
    // Обмениваем код на токен
    return this.exchangeCodeForToken(code);
  }
  
  async exchangeCodeForToken(code) {
    const response = await fetch(this.config.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: this.config.clientId,
        client_secret: this.config.clientSecret,
        code: code,
        redirect_uri: this.config.redirectUri
      })
    });
    
    if (!response.ok) {
      throw new Error('Не удалось получить токен');
    }
    
    const data = await response.json();
    TokenManager.setToken(data.access_token);
    
    // Удаляем state после успешной авторизации
    sessionStorage.removeItem('oauth_state');
    
    return data;
  }
}
```

## Защита от CSRF-атак

Важно реализовать защиту от CSRF-атак:

```javascript
// Генерация CSRF токена
function generateCSRFToken() {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15);
}

// Хранение CSRF токена
class CSRFTokenManager {
  static getToken() {
    let token = localStorage.getItem('csrf_token');
    if (!token) {
      token = generateCSRFToken();
      localStorage.setItem('csrf_token', token);
    }
    return token;
  }
  
  static attachTokenToRequest(options = {}) {
    const token = this.getToken();
    return {
      ...options,
      headers: {
        ...options.headers,
        'X-CSRF-Token': token
      }
    };
  }
}

// Использование CSRF токена в запросах
async function secureRequest(url, options = {}) {
  const secureOptions = CSRFTokenManager.attachTokenToRequest(options);
  return fetch(url, secureOptions);
}
```

## Многоуровневая аутентификация (MFA)

Для приложений с высокими требованиями к безопасности:

```javascript
class MFAClient {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  // Запрос на включение MFA
  async enableMFA() {
    const response = await this.apiClient.post('/api/mfa/enable');
    const data = await response.json();
    
    // Показываем QR-код для настройки приложения аутентификации
    this.displayQRCode(data.qrCodeUrl);
    return data.setupKey;
  }
  
  // Подтверждение MFA
  async confirmMFA(verificationCode) {
    const response = await this.apiClient.post('/api/mfa/confirm', {
      verificationCode
    });
    
    return response.ok;
  }
  
  // Проверка MFA при входе
  async verifyMFA(credentials, mfaCode) {
    const response = await fetch('/api/auth/login/mfa', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ...credentials,
        mfaCode
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      TokenManager.setToken(data.token);
      return data;
    }
    
    throw new Error('Неверный код MFA');
  }
}
```

## Заключение

Правильная реализация аутентификации и авторизации критически важна для безопасности приложений. В российских условиях особенно важно учитывать требования к защите персональных данных и использовать современные методы аутентификации с надежным хранением токенов.

См. также:
- [[Работа-с-API]]
- [[Обработка-ошибок]]
- [[Обработка-ответов]]
- [[Кэширование-запросов]]