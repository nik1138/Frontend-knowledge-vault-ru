---
aliases: [JavaScript функции, Функции JS, Определение функций, Вызов функций]
tags: [javascript, functions, programming, basics]
---

# Функции в JavaScript

Функции в JavaScript - это блоки кода, которые могут быть вызваны повторно. Они являются основой структурированного программирования и одной из ключевых особенностей языка. В 2025 году функции остаются центральным элементом как функционального, так и объектно-ориентированного программирования в JavaScript.

## Определение функций

### Функциональное объявление (Function Declaration)

```javascript
function greet(name) {
    return `Привет, ${name}!`;
}

// Вызов функции
console.log(greet("Алексей")); // "Привет, Алексей!"
```

> [!tip] Особенность
> Функциональные объявления подвергаются "поднятию" (hoisting), что позволяет вызывать их до их фактического определения в коде.

### Функциональное выражение (Function Expression)

```javascript
const multiply = function(a, b) {
    return a * b;
};

console.log(multiply(5, 3)); // 15
```

### Стрелочные функции (Arrow Functions)

Введены в ES6, стрелочные функции обеспечивают более краткий синтаксис и имеют лексическое связывание `this`.

```javascript
const square = x => x * x; // для одной переменной
const add = (a, b) => a + b; // для нескольких переменных
const greet = name => `Привет, ${name}!`; // возврат выражения
const doNothing = () => {}; // без параметров

// Многострочная стрелочная функция
const complexFunction = (x, y) => {
    const result = x * y;
    return result + 10;
};
```

> [!warning] Важное отличие
> Стрелочные функции не имеют собственного `this`, `arguments`, `super` или `new.target`. Они не могут использоваться как конструкторы.

## Параметры функций

### Параметры по умолчанию

```javascript
function greet(name = "Гость", greeting = "Привет") {
    return `${greeting}, ${name}!`;
}

console.log(greet()); // "Привет, Гость!"
console.log(greet("Мария")); // "Привет, Мария!"
console.log(greet("Мария", "Добро пожаловать")); // "Добро пожаловать, Мария!"
```

### Остаточные параметры (Rest Parameters)

```javascript
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
console.log(sum(10, 20)); // 30
```

### Деструктуризация параметров

```javascript
function displayUser({name, age, city = "Москва"}) {
    console.log(`Имя: ${name}, Возраст: ${age}, Город: ${city}`);
}

const user = {name: "Анна", age: 28};
displayUser(user); // "Имя: Анна, Возраст: 28, Город: Москва"
```

## Область видимости функций

Функции создают собственную область видимости:

```javascript
const globalVar = "Я глобальная";

function example() {
    const localVar = "Я локальная";
    console.log(globalVar); // "Я глобальная" - доступна
    console.log(localVar);  // "Я локальная" - доступна
}

console.log(globalVar); // "Я глобальная" - доступна
// console.log(localVar);  // Ошибка! localVar не определена в этой области
```

## Функции высшего порядка

Функции, которые принимают другие функции в качестве аргументов или возвращают функции, называются функциями высшего порядка.

```javascript
// Функция, принимающая другую функцию
function executeTwice(func, arg) {
    func(arg);
    func(arg);
}

function sayHello(name) {
    console.log(`Привет, ${name}!`);
}

executeTwice(sayHello, "Владимир"); 
// Выведет дважды: "Привет, Владимир!"

// Функция, возвращающая другую функцию
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(4)); // 12
```

## Замыкания

Функция имеет доступ к переменным из внешней области видимости даже после возвращения:

```javascript
function createCounter() {
    let count = 0;
    
    return function() {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

## Методы объектов

Функции могут быть свойствами объектов и в этом случае называются методами:

```javascript
const person = {
    name: "Елена",
    greet() {
        return `Привет, я ${this.name}`;
    },
    // Сокращенный синтаксис ES6
    introduce(greeting = "Привет") {
        return `${greeting}, меня зовут ${this.name}`;
    }
};

console.log(person.greet()); // "Привет, я Елена"
console.log(person.introduce("Здравствуйте")); // "Здравствуйте, меня зовут Елена"
```

## Контекст вызова (this)

Поведение `this` зависит от способа вызова функции:

```javascript
const obj = {
    name: "Объект",
    regularFunction: function() {
        console.log(this.name); // "Объект"
    },
    arrowFunction: () => {
        console.log(this.name); // undefined (лексическое связывание)
    }
};

obj.regularFunction(); // "Объект"
obj.arrowFunction();   // undefined
```

## Arguments

В обычных функциях (не стрелочных) доступен псевдомассив `arguments`, содержащий все переданные аргументы:

```javascript
function logArguments() {
    console.log(arguments); // Arguments(3) [1, 2, 3]
    console.log(Array.from(arguments)); // [1, 2, 3]
}

logArguments(1, 2, 3);
```

> [!tip] Альтернатива
> Вместо `arguments` лучше использовать остаточные параметры: `function(...args) { ... }`

## IIFE (Immediately Invoked Function Expression)

Функции, которые выполняются сразу после определения:

```javascript
(function() {
    console.log("Эта функция выполнится сразу!");
})();

// Или с параметрами
(function(name) {
    console.log(`Привет, ${name}!`);
})("Сергей");

// Или как стрелочная функция
(() => console.log("Привет из IIFE!"))();
```

## Async/await функции

В современном JavaScript часто используются асинхронные функции:

```javascript
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Ошибка при получении данных:', error);
    }
}

// Вызов асинхронной функции
fetchData().then(data => console.log(data));
```

## Практические рекомендации

1. Используйте стрелочные функции для кратких callback-функций
2. Избегайте использования `arguments`, предпочитая остаточные параметры
3. Будьте осторожны с `this` в различных контекстах
4. Используйте деструктуризацию параметров для улучшения читаемости
5. В российских проектах часто используется модульный подход, где функции экспортируются и импортируются между файлами

```javascript
// mathUtils.js
export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

// main.js
import { add, multiply } from './mathUtils.js';

console.log(add(2, 3)); // 5
console.log(multiply(4, 5)); // 20
```

> [!warning] Производительность
> Помните, что создание функций внутри циклов может негативно сказаться на производительности. Лучше выносите функции за пределы циклов.

## См. также

- [[Типы-данных]]
- [[Объекты]]
- [[Массивы]]
- [[Замыкания]]
- [[Область-видимости]]