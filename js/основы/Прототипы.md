---
aliases: [JavaScript прототипы, Прототипное наследование, Prototype, Прототипный стиль]
tags: [javascript, prototype, oop, programming, advanced]
---

# Прототипы в JavaScript

Прототипы - это один из фундаментальных механизмов JavaScript, который обеспечивает наследование и позволяет объектам наследовать свойства и методы от других объектов. В отличие от классического наследования, JavaScript использует прототипное наследование, которое является более гибким и мощным подходом.

## Понимание прототипов

Каждый объект в JavaScript имеет внутреннее свойство `[[Prototype]]`, которое указывает на другой объект - прототип. Этот прототип также может иметь свой прототип и так далее, образуя так называемую "цепочку прототипов".

### Свойство prototype

Функции-конструкторы имеют специальное свойство `prototype`, которое используется для создания `[[Prototype]]` новых объектов при использовании оператора `new`.

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Добавляем метод в прототип
Person.prototype.greet = function() {
    return `Привет, меня зовут ${this.name}`;
};

Person.prototype.introduce = function() {
    return `${this.greet()}, мне ${this.age} лет`;
};

const person1 = new Person("Алексей", 30);
const person2 = new Person("Мария", 25);

console.log(person1.greet()); // "Привет, меня зовут Алексей"
console.log(person2.introduce()); // "Привет, меня зовут Мария, мне 25 лет"
```

> [!tip] Важно
> Методы, определенные в `prototype`, разделяются между всеми экземплярами, что экономит память по сравнению с определением методов внутри конструктора.

## Цепочка прототипов

Когда вы пытаетесь получить доступ к свойству объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта, затем в прототипе прототипа и так далее, пока не достигнет конца цепочки.

```javascript
const animal = {
    eats: true,
    walk() {
        return "Животное идет";
    }
};

const rabbit = Object.create(animal);
rabbit.jumps = true;

const longEars = Object.create(rabbit);
longEars.color = "белый";

console.log(longEars.color); // "белый" - собственное свойство
console.log(longEars.jumps); // true - наследуется от rabbit
console.log(longEars.eats); // true - наследуется от animal
console.log(longEars.walk()); // "Животное идет" - наследуется от animal
```

## Методы для работы с прототипами

### Object.getPrototypeOf() и Object.setPrototypeOf()

```javascript
const parent = { name: "Родитель" };
const child = Object.create(parent);

console.log(Object.getPrototypeOf(child) === parent); // true

// Установка прототипа (редко используется на практике)
const newParent = { title: "Новый родитель" };
Object.setPrototypeOf(child, newParent);
console.log(child.title); // "Новый родитель"
console.log(child.name); // undefined (т.к. старый прототип больше не связан)
```

### Свойство __proto__

> [!warning] Устаревшее
> Свойство `__proto__` устарело, но все еще поддерживается во многих браузерах. Используйте `Object.getPrototypeOf()` и `Object.setPrototypeOf()` вместо него.

```javascript
const obj = {};
const parent = { name: "Родитель" };

obj.__proto__ = parent; // Не рекомендуется
// Лучше использовать:
Object.setPrototypeOf(obj, parent);

console.log(obj.name); // "Родитель"
```

### Object.create()

Метод `Object.create()` создает новый объект с указанным прототипом:

```javascript
// Создание объекта с прототипом
const animal = {
    eats: true,
    walk() {
        return "Животное идет";
    }
};

const rabbit = Object.create(animal);
rabbit.jumps = true;

// Создание объекта без прототипа
const objWithoutProto = Object.create(null);
console.log(objWithoutProto.toString); // undefined
// objWithoutProto не наследуется от Object.prototype
```

## Современные классы и прототипы

С приходом ES6 появились классы, которые на самом деле являются "синтаксическим сахаром" над прототипным наследованием:

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} издает звук`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // вызывает конструктор родительского класса
        this.breed = breed;
    }
    
    speak() {
        return `${this.name} лает`;
    }
    
    fetch() {
        return `${this.name} принес мяч`;
    }
}

const dog = new Dog("Бобик", "Лабрадор");
console.log(dog.speak()); // "Бобик лает"
console.log(dog.fetch()); // "Бобик принес мяч"
console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
```

## Функции-конструкторы и прототипы

### Создание функции-конструктора

```javascript
function Car(brand, model, year) {
    this.brand = brand;
    this.model = model;
    this.year = year;
    this.isRunning = false;
}

// Методы добавляются в прототип
Car.prototype.start = function() {
    this.isRunning = true;
    return `${this.brand} ${this.model} заведен`;
};

Car.prototype.stop = function() {
    this.isRunning = false;
    return `${this.brand} ${this.model} заглушен`;
};

Car.prototype.getInfo = function() {
    return `${this.year} ${this.brand} ${this.model}`;
};

const myCar = new Car("Toyota", "Camry", 2023);
console.log(myCar.getInfo()); // "2023 Toyota Camry"
console.log(myCar.start()); // "Toyota Camry заведен"
```

### Проверка на принадлежность

```javascript
console.log(myCar instanceof Car); // true
console.log(myCar instanceof Object); // true (все объекты наследуются от Object)

// Проверка наличия свойства в объекте (не в прототипе)
console.log(myCar.hasOwnProperty('brand')); // true
console.log(myCar.hasOwnProperty('start')); // false (метод в прототипе)
```

## Прототипы встроенных объектов

Все встроенные объекты JavaScript также используют прототипы:

```javascript
// Добавление метода ко всем строкам
String.prototype.reverse = function() {
    return this.split('').reverse().join('');
};

console.log("привет".reverse()); // "тевирп"

// Добавление метода ко всем массивам
Array.prototype.last = function() {
    return this[this.length - 1];
};

console.log([1, 2, 3].last()); // 3

// Полифил для отсутствующего метода
if (!String.prototype.includes) {
    String.prototype.includes = function(searchString) {
        return this.indexOf(searchString) !== -1;
    };
}
```

> [!warning] Изменение прототипов встроенных объектов
> Изменение прототипов встроенных объектов может вызвать конфликты с другими библиотеками и будущими версиями JavaScript. Используйте это осторожно.

## Продвинутые примеры

### Прототипное наследование с использованием функций

```javascript
// Родительский конструктор
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    return `${this.name} издает звук`;
};

// Дочерний конструктор
function Cat(name, color) {
    Animal.call(this, name); // вызов родительского конструктора
    this.color = color;
}

// Установка прототипа
Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat; // восстановление конструктора

// Добавление специфичных методов
Cat.prototype.speak = function() {
    return `${this.name} мяукает`;
};

Cat.prototype.purr = function() {
    return `${this.name} мурлычет`;
};

const myCat = new Cat("Мурка", "рыжий");
console.log(myCat.speak()); // "Мурка мяукает"
console.log(myCat.purr()); // "Мурка мурлычет"
console.log(myCat instanceof Cat); // true
console.log(myCat instanceof Animal); // true
```

### Прототипы и замыкания

```javascript
function createCounter(initialValue = 0) {
    function Counter(value) {
        this.value = value;
    }
    
    Counter.prototype.increment = function() {
        this.value++;
        return this.value;
    };
    
    Counter.prototype.decrement = function() {
        this.value--;
        return this.value;
    };
    
    Counter.prototype.getValue = function() {
        return this.value;
    };
    
    return new Counter(initialValue);
}

const counter = createCounter(10);
console.log(counter.increment()); // 11
console.log(counter.increment()); // 12
console.log(counter.decrement()); // 11
```

## Практические применения

### Создание библиотек и фреймворков

```javascript
// Простая библиотека для работы с DOM
function Element(selector) {
    this.element = document.querySelector(selector);
}

Element.prototype.addClass = function(className) {
    this.element.classList.add(className);
    return this; // для цепочки вызовов
};

Element.prototype.removeClass = function(className) {
    this.element.classList.remove(className);
    return this;
};

Element.prototype.setText = function(text) {
    this.element.textContent = text;
    return this;
};

// Использование
const header = new Element('#header');
header.addClass('active').setText('Новый заголовок');
```

### Миксины (Mixins)

```javascript
// Миксин для логирования
const LoggerMixin = {
    log(message) {
        console.log(`[${this.constructor.name}] ${message}`);
    },
    
    error(message) {
        console.error(`[${this.constructor.name}] ${message}`);
    }
};

// Миксин для валидации
const ValidationMixin = {
    validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
};

// Применение миксинов
function User(name, email) {
    this.name = name;
    this.email = email;
}

// Копирование методов миксинов в прототип
Object.assign(User.prototype, LoggerMixin, ValidationMixin);

const user = new User("Иван", "ivan@example.com");
user.log("Пользователь создан"); // [User] Пользователь создан
console.log(user.validateEmail(user.email)); // true
```

## Современные альтернативы

Хотя прототипы все еще важны для понимания, в современном JavaScript часто используются:

- [[Классы]] (ES6+)
- [[Функции]] с замыканиями
- Модульная система (ES6 modules)

```javascript
// Современный подход с классами (эквивалент прототипного подхода)
class ModernCar {
    constructor(brand, model, year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.isRunning = false;
    }
    
    start() {
        this.isRunning = true;
        return `${this.brand} ${this.model} заведен`;
    }
    
    stop() {
        this.isRunning = false;
        return `${this.brand} ${this.model} заглушен`;
    }
    
    get info() {
        return `${this.year} ${this.brand} ${this.model}`;
    }
}
```

## Практические рекомендации

1. Понимание прототипов критически важно для глубокого понимания JavaScript
2. В современных проектах чаще используются классы, но знание прототипов помогает понимать, как всё работает "под капотом"
3. В российских проектах часто встречается код, написанный в прототипном стиле, особенно в старых библиотеках
4. Избегайте изменения прототипов встроенных объектов в общем коде
5. Используйте `Object.create(null)` при создании "чистых" объектов-хранилищ

> [!tip] Совет
> Используйте `Object.getPrototypeOf(obj)` для получения прототипа объекта и `Object.prototype.isPrototypeOf()` для проверки, является ли объект прототипом другого.

## См. также

- [[Объекты]]
- [[Функции]]
- [[Замыкания]]
- [[Классы]]
- [[Область-видимости]]