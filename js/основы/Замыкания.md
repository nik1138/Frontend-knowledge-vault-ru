---
aliases: [Замыкания JavaScript, JavaScript closures, Замыкания JS, Лексическое окружение]
tags: [javascript, closures, scope, functions, advanced]
---

# Замыкания в JavaScript

Замыкание (closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Замыкания позволяют функции получать доступ к переменным из внешней (замыкающей) области видимости даже после возврата внешней функции. Это одна из самых мощных и важных концепций в JavaScript.

## Основы замыканий

### Простой пример замыкания

```javascript
function outerFunction(x) {
    // Внешняя переменная
    let outerVariable = x;
    
    // Внутренняя функция, которая "замыкает" внешнюю переменную
    function innerFunction(y) {
        return outerVariable + y; // использует переменную из внешней области
    }
    
    return innerFunction;
}

const closure = outerFunction(10);
console.log(closure(5)); // 15
```

### Замыкание с несколькими переменными

```javascript
function createCalculator(initialValue = 0) {
    let value = initialValue;
    
    return {
        add(num) {
            value += num;
            return this;
        },
        
        subtract(num) {
            value -= num;
            return this;
        },
        
        multiply(num) {
            value *= num;
            return this;
        },
        
        getValue() {
            return value;
        }
    };
}

const calc = createCalculator(10);
console.log(calc.add(5).multiply(2).getValue()); // 30
console.log(calc.subtract(10).getValue()); // 20
```

## Практические применения замыканий

### Приватные переменные и методы

```javascript
function createBankAccount(initialBalance = 0) {
    let balance = initialBalance; // приватная переменная
    const transactionHistory = []; // приватная переменная
    
    return {
        deposit(amount) {
            if (amount > 0) {
                balance += amount;
                transactionHistory.push({ type: 'deposit', amount, date: new Date() });
                return true;
            }
            return false;
        },
        
        withdraw(amount) {
            if (amount > 0 && balance >= amount) {
                balance -= amount;
                transactionHistory.push({ type: 'withdraw', amount, date: new Date() });
                return true;
            }
            return false;
        },
        
        getBalance() {
            return balance;
        },
        
        // Приватный метод доступен только внутри замыкания
        getTransactionHistory() {
            return [...transactionHistory]; // возвращаем копию
        }
    };
}

const account = createBankAccount(1000);
account.deposit(500);
account.withdraw(200);
console.log(account.getBalance()); // 1300
// console.log(account.balance); // undefined - приватная переменная
```

### Каррирование (Currying)

```javascript
// Функция, возвращающая каррированную версию
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

// Пример использования
function multiply(a, b, c) {
    return a * b * c;
}

const curriedMultiply = curry(multiply);
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(curriedMultiply(2, 3)(4)); // 24
console.log(curriedMultiply(2)(3, 4)); // 24

// Частичное применение
const multiplyByTwo = curriedMultiply(2);
const multiplyByTwoAndThree = multiplyByTwo(3);
console.log(multiplyByTwoAndThree(5)); // 30
```

### Создание счетчиков

```javascript
function createCounter(initialValue = 0, step = 1) {
    let count = initialValue;
    
    return {
        next() {
            count += step;
            return count;
        },
        
        current() {
            return count;
        },
        
        reset() {
            count = initialValue;
            return count;
        },
        
        setStep(newStep) {
            step = newStep;
        }
    };
}

const counter = createCounter(0, 2);
console.log(counter.next()); // 2
console.log(counter.next()); // 4
console.log(counter.current()); // 4
counter.setStep(5);
console.log(counter.next()); // 9
```

### Обработка событий с замыканиями

```javascript
// Пример использования замыканий для обработки событий
function attachListeners() {
    const buttons = document.querySelectorAll('.btn');
    
    buttons.forEach((button, index) => {
        // Замыкание сохраняет значение index для каждого обработчика
        button.addEventListener('click', function() {
            console.log(`Кнопка ${index} была нажата`);
        });
    });
}

// Аналогичный пример без DOM
function simulateButtonEvents() {
    const handlers = [];
    
    for (let i = 0; i < 3; i++) {
        // Каждая функция в замыкании сохраняет своё значение i
        handlers.push(function() {
            console.log(`Обработчик ${i} вызван`);
        });
    }
    
    // Вызов обработчиков
    handlers[0](); // "Обработчик 0 вызван"
    handlers[1](); // "Обработчик 1 вызван"
    handlers[2](); // "Обработчик 2 вызван"
}

simulateButtonEvents();
```

## Замыкания и циклы

### Классическая проблема с var

```javascript
// Проблема: все функции будут выводить 3
console.log("Проблема с var:");
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // Выведет 3, 3, 3
    }, 100);
}

// Решение 1: IIFE (Immediately Invoked Function Expression)
console.log("Решение с IIFE:");
for (var j = 0; j < 3; j++) {
    (function(index) {
        setTimeout(function() {
            console.log(index); // Выведет 0, 1, 2
        }, 200);
    })(j);
}

// Решение 2: let (рекомендуемое)
console.log("Решение с let:");
for (let k = 0; k < 3; k++) {
    setTimeout(function() {
        console.log(k); // Выведет 0, 1, 2
    }, 300);
}
```

### Создание фабрики функций

```javascript
function createValidator(type) {
    // Возвращаем функцию-валидатор, замыкающую тип проверки
    switch (type) {
        case 'email':
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return function(value) {
                return emailRegex.test(value);
            };
        
        case 'phone':
            const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;
            return function(value) {
                return phoneRegex.test(value);
            };
        
        case 'password':
            return function(value) {
                return value.length >= 8 && 
                       /[A-Z]/.test(value) && 
                       /[a-z]/.test(value) && 
                       /\d/.test(value);
            };
        
        default:
            return function() { return true; };
    }
}

const emailValidator = createValidator('email');
const passwordValidator = createValidator('password');

console.log(emailValidator('user@example.com')); // true
console.log(emailValidator('invalid-email')); // false
console.log(passwordValidator('weak')); // false
console.log(passwordValidator('StrongPass123')); // true
```

## Продвинутые примеры

### Мемоизация

```javascript
function memoize(fn) {
    const cache = new Map(); // приватное хранилище
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log('Взято из кэша');
            return cache.get(key);
        }
        
        console.log('Вычислено заново');
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

// Функция для вычисления чисел Фибоначчи
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Мемоизированная версия
const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(10)); // Вычислено заново, результат: 55
console.log(memoizedFib(10)); // Взято из кэша, результат: 55
```

### Событийный эмиттер с замыканиями

```javascript
function createEventEmitter() {
    const events = {}; // приватное хранилище событий
    
    return {
        on(event, listener) {
            if (!events[event]) {
                events[event] = [];
            }
            events[event].push(listener);
        },
        
        emit(event, ...args) {
            if (events[event]) {
                events[event].forEach(listener => listener(...args));
            }
        },
        
        off(event, listener) {
            if (events[event]) {
                const index = events[event].indexOf(listener);
                if (index > -1) {
                    events[event].splice(index, 1);
                }
            }
        },
        
        once(event, listener) {
            // Обертка, которая удаляет себя после первого вызова
            const wrappedListener = (...args) => {
                listener(...args);
                this.off(event, wrappedListener);
            };
            this.on(event, wrappedListener);
        }
    };
}

const emitter = createEventEmitter();

emitter.on('greet', (name) => {
    console.log(`Привет, ${name}!`);
});

emitter.once('farewell', (name) => {
    console.log(`До свидания, ${name}!`);
});

emitter.emit('greet', 'Алексей'); // "Привет, Алексей!"
emitter.emit('farewell', 'Мария'); // "До свидания, Мария!"
emitter.emit('farewell', 'Мария'); // Ничего не выводится (сработал once)
```

### Создание middleware системы

```javascript
function createMiddlewareChain() {
    const middlewares = [];
    
    return {
        use(middleware) {
            middlewares.push(middleware);
        },
        
        execute(context) {
            let index = 0;
            
            function next() {
                if (index < middlewares.length) {
                    const middleware = middlewares[index++];
                    middleware(context, next);
                }
            }
            
            next();
            return context;
        }
    };
}

const middlewareChain = createMiddlewareChain();

middlewareChain.use((context, next) => {
    console.log('Шаг 1: Начало обработки');
    context.startTime = Date.now();
    next();
    console.log('Шаг 1: Завершение обработки');
});

middlewareChain.use((context, next) => {
    console.log('Шаг 2: Валидация данных');
    context.validated = true;
    next();
});

middlewareChain.use((context, next) => {
    console.log('Шаг 3: Логирование');
    context.endTime = Date.now();
    context.duration = context.endTime - context.startTime;
    next();
});

const context = { data: 'some data' };
middlewareChain.execute(context);
console.log('Контекст:', context);
```

## Замыкания и производительность

### Утечки памяти

```javascript
// Опасный пример - потенциальная утечка памяти
function problematicClosure() {
    const largeData = new Array(1000000).fill('data');
    
    // Даже если возвращается маленькая функция, она держит ссылку на largeData
    return function() {
        return 'маленький результат';
    };
}

// Лучшее решение - освобождение ссылок
function betterClosure() {
    const largeData = new Array(1000000).fill('data');
    
    // Обрабатываем данные и освобождаем ссылку
    const processed = largeData.length;
    largeData.length = 0; // очищаем массив
    
    return function() {
        return processed; // возвращаем только нужное значение
    };
}
```

## Практические рекомендации

1. Используйте замыкания для создания приватных переменных и методов
2. Будьте осторожны с замыканиями в циклах - используйте `let` вместо `var`
3. Замыкания полезны для каррирования и частичного применения функций
4. В российских проектах часто используются замыкания для создания конфигурируемых функций и компонентов
5. Следите за потенциальными утечками памяти при использовании замыканий с большими объемами данных

```javascript
// Хорошая практика: использование замыканий для конфигурации
function createApiRequester(baseURL, defaultHeaders = {}) {
    return function(endpoint, options = {}) {
        const url = `${baseURL}${endpoint}`;
        const config = {
            headers: { ...defaultHeaders, ...options.headers },
            ...options
        };
        
        return fetch(url, config);
    };
}

const githubRequester = createApiRequester(
    'https://api.github.com', 
    { 'User-Agent': 'MyApp/1.0' }
);

// githubRequester('/users/octocat').then(response => response.json());
```

> [!tip] Совет
> Замыкания особенно полезны при создании функций высшего порядка и при работе с асинхронным кодом, где нужно сохранить контекст выполнения.

## См. также

- [[Область-видимости]]
- [[Функции]]
- [[Прототипы]]
- [[Объекты]]
- [[Массивы]]