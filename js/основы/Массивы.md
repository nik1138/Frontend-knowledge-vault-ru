---
aliases: [JavaScript массивы, Массивы JS, Работа с массивами, Методы массивов]
tags: [javascript, arrays, programming, basics]
---

# Массивы в JavaScript

Массивы в JavaScript - это особый тип объектов, предназначенный для хранения упорядоченных коллекций значений. В отличие от других языков, JavaScript позволяет хранить в массивах элементы разных типов. В 2025 году массивы остаются важной частью разработки, особенно при работе с данными и API.

## Создание массивов

### Литерал массива (рекомендуемый способ)

```javascript
const fruits = ["яблоко", "банан", "апельсин"];
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, "текст", true, {name: "Иван"}, [1, 2, 3]];
const empty = [];
```

### Конструктор Array

```javascript
const arr1 = new Array(); // пустой массив
const arr2 = new Array(5); // массив с 5 пустыми слотами
const arr3 = new Array(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]

// ВАЖНО: при передаче одного числового аргумента
console.log(arr2.length); // 5
console.log(arr2[0]); // undefined
```

### Метод Array.of()

```javascript
// Решает проблему с одним аргументом в конструкторе
const arr = Array.of(5); // [5] - массив с одним элементом 5
const arr2 = Array.of(1, 2, 3); // [1, 2, 3]
```

### Метод Array.from()

```javascript
// Из массивоподобного объекта
const arrayLike = {0: "a", 1: "b", 2: "c", length: 3};
const arr = Array.from(arrayLike); // ["a", "b", "c"]

// Из итерируемого объекта
const set = new Set([1, 2, 3]);
const arrFromSet = Array.from(set); // [1, 2, 3]

// С маппер-функцией
const doubled = Array.from([1, 2, 3], x => x * 2); // [2, 4, 6]
```

## Доступ к элементам массива

```javascript
const colors = ["красный", "зеленый", "синий"];

console.log(colors[0]); // "красный"
console.log(colors[1]); // "зеленый"
console.log(colors[2]); // "синий"
console.log(colors[10]); // undefined (элемента не существует)

// Доступ к последнему элементу
console.log(colors[colors.length - 1]); // "синий"

// Отрицательные индексы (с помощью вспомогательных методов)
const lastElement = colors.at(-1); // "синий" (ES2022)
const secondLast = colors.at(-2); // "зеленый"
```

## Изменение массивов

### Добавление элементов

```javascript
const numbers = [1, 2, 3];

// В конец массива
numbers.push(4); // [1, 2, 3, 4]
numbers.push(5, 6); // [1, 2, 3, 4, 5, 6]

// В начало массива
numbers.unshift(0); // [0, 1, 2, 3, 4, 5, 6]

// С помощью spread-оператора (создает новый массив)
const newNumbers = [...numbers, 7, 8]; // [0, 1, 2, 3, 4, 5, 6, 7, 8]
const prefixedNumbers = [-2, -1, ...numbers]; // [-2, -1, 0, 1, 2, 3, 4, 5, 6]
```

### Удаление элементов

```javascript
const letters = ["a", "b", "c", "d", "e"];

// Из конца массива
const removedFromEnd = letters.pop(); // "e", letters = ["a", "b", "c", "d"]

// Из начала массива
const removedFromStart = letters.shift(); // "a", letters = ["b", "c", "d"]

// Из произвольного места
const removed = letters.splice(1, 2); // ["c", "d"], letters = ["b"]
letters.splice(1, 0, "x", "y"); // вставка: ["b", "x", "y"]

// Удаление без изменения исходного массива
const withoutFirst = letters.slice(1); // ["x", "y"]
const withoutLast = letters.slice(0, -1); // ["b", "x"]
```

## Основные методы массивов

### Перебирающие методы

#### map() - преобразование элементов

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2); // [2, 4, 6, 8, 10]

const users = [
    {name: "Анна", age: 25},
    {name: "Борис", age: 30},
    {name: "Виктория", age: 28}
];

const names = users.map(user => user.name); // ["Анна", "Борис", "Виктория"]
```

#### filter() - фильтрация элементов

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = numbers.filter(num => num % 2 === 0); // [2, 4, 6, 8, 10]

const products = [
    {name: "Телефон", price: 50000, category: "электроника"},
    {name: "Книга", price: 1000, category: "литература"},
    {name: "Ноутбук", price: 100000, category: "электроника"}
];

const expensiveItems = products.filter(product => product.price > 10000);
```

#### reduce() - агрегация значений

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, num) => total + num, 0); // 15

// Подсчет количества элементов по условию
const grades = [5, 4, 3, 5, 4, 5, 2, 4];
const gradeCount = grades.reduce((acc, grade) => {
    acc[grade] = (acc[grade] || 0) + 1;
    return acc;
}, {}); // {2: 1, 3: 1, 4: 3, 5: 3}

// Группировка объектов
const employees = [
    {name: "Иван", department: "IT"},
    {name: "Мария", department: "HR"},
    {name: "Петр", department: "IT"},
    {name: "Анна", department: "HR"}
];

const groupedByDept = employees.reduce((acc, emp) => {
    const dept = emp.department;
    if (!acc[dept]) {
        acc[dept] = [];
    }
    acc[dept].push(emp);
    return acc;
}, {}); // {IT: [...], HR: [...]}
```

#### forEach() - выполнение действия для каждого элемента

```javascript
const fruits = ["яблоко", "банан", "апельсин"];
fruits.forEach((fruit, index) => {
    console.log(`${index}: ${fruit}`);
});

// ВАЖНО: forEach не возвращает новый массив, а просто выполняет действие
```

### Методы проверки

#### some() - проверяет, удовлетворяет ли хотя бы один элемент условию

```javascript
const ages = [16, 20, 25, 30];
const hasAdult = ages.some(age => age >= 18); // true
```

#### every() - проверяет, удовлетворяют ли все элементы условию

```javascript
const temperatures = [15, 18, 22, 25];
const isWarm = temperatures.every(temp => temp > 10); // true
```

#### find() и findIndex() - поиск элемента

```javascript
const users = [
    {id: 1, name: "Алексей"},
    {id: 2, name: "Марина"},
    {id: 3, name: "Сергей"}
];

const user = users.find(u => u.id === 2); // {id: 2, name: "Марина"}
const index = users.findIndex(u => u.name === "Сергей"); // 2
```

### Методы преобразования

#### flat() - расплющивание массива

```javascript
const nested = [1, [2, 3], [4, [5, 6]]];
const flatOnce = nested.flat(); // [1, 2, 3, 4, [5, 6]]
const flatAll = nested.flat(Infinity); // [1, 2, 3, 4, 5, 6]
```

#### flatMap() - комбинация map и flat

```javascript
const sentences = ["Привет мир", "Как дела", "Пока"];
const words = sentences.flatMap(sentence => sentence.split(" ")); 
// ["Привет", "мир", "Как", "дела", "Пока"]
```

## Деструктуризация массивов

```javascript
const colors = ["красный", "зеленый", "синий"];

// Простая деструктуризация
const [first, second, third] = colors;
console.log(first); // "красный"

// Пропуск элементов
const [a, , c] = colors; // "красный", "синий"

// Остаточные элементы
const [head, ...tail] = colors; // head: "красный", tail: ["зеленый", "синий"]

// Значения по умолчанию
const [x, y, z = "неизвестный"] = ["красный", "зеленый"];
console.log(z); // "зеленый"

const [p, q, r = "неизвестный"] = ["красный"];
console.log(r); // "неизвестный"

// Деструктуризация с вложенными массивами
const matrix = [[1, 2], [3, 4]];
const [[a1, a2], [b1, b2]] = matrix;
console.log(a1, a2, b1, b2); // 1 2 3 4
```

## Перебор массивов

### Цикл for...of

```javascript
const cities = ["Москва", "Санкт-Петербург", "Новосибирск"];

for (const city of cities) {
    console.log(city);
}

// С индексами
for (const [index, city] of cities.entries()) {
    console.log(`${index}: ${city}`);
}
```

### Методы entries(), keys(), values()

```javascript
const animals = ["кошка", "собака", "птица"];

// Получение пар индекс-значение
for (const [index, value] of animals.entries()) {
    console.log(index, value);
}

// Получение ключей
for (const key of animals.keys()) {
    console.log(key); // 0, 1, 2
}

// Получение значений
for (const value of animals.values()) {
    console.log(value); // "кошка", "собака", "птица"
}
```

## Сортировка и сравнение

```javascript
// Сортировка строк
const names = ["Иван", "Анна", "Елена", "Борис"];
names.sort(); // ["Анна", "Борис", "Елена", "Иван"]

// Сортировка чисел
const numbers = [10, 5, 40, 25, 1000, 1];
numbers.sort((a, b) => a - b); // [1, 5, 10, 25, 40, 1000] - по возрастанию
numbers.sort((a, b) => b - a); // [1000, 40, 25, 10, 5, 1] - по убыванию

// Сортировка объектов
const students = [
    {name: "Анна", grade: 85},
    {name: "Иван", grade: 92},
    {name: "Мария", grade: 78}
];

// По оценке
students.sort((a, b) => a.grade - b.grade);

// По имени
students.sort((a, b) => a.name.localeCompare(b.name));
```

## Практические примеры

### Работа с данными пользователей

```javascript
const users = [
    {id: 1, name: "Александр", age: 25, active: true},
    {id: 2, name: "Мария", age: 30, active: false},
    {id: 3, name: "Дмитрий", age: 22, active: true},
    {id: 4, name: "Елена", age: 28, active: true}
];

// Активные пользователи старше 25
const activeAdults = users
    .filter(user => user.active && user.age > 25)
    .map(user => ({name: user.name, age: user.age}));

// Средний возраст активных пользователей
const activeUsers = users.filter(user => user.active);
const avgAge = activeUsers.reduce((sum, user) => sum + user.age, 0) / activeUsers.length;

// Группировка по возрасту
const groupedByAge = users.reduce((acc, user) => {
    const ageGroup = user.age < 25 ? 'молодые' : user.age < 30 ? 'средние' : 'старшие';
    acc[ageGroup] = acc[ageGroup] || [];
    acc[ageGroup].push(user);
    return acc;
}, {});
```

### Работа с товарами в интернет-магазине

```javascript
const products = [
    {id: 1, name: "Смартфон", price: 50000, category: "электроника", inStock: true},
    {id: 2, name: "Книга", price: 1000, category: "литература", inStock: true},
    {id: 3, name: "Ноутбук", price: 100000, category: "электроника", inStock: false},
    {id: 4, name: "Наушники", price: 15000, category: "электроника", inStock: true}
];

// Общая стоимость товаров в наличии
const totalValue = products
    .filter(p => p.inStock)
    .reduce((sum, p) => sum + p.price, 0);

// Самый дорогой товар
const mostExpensive = products.reduce((max, product) => 
    product.price > max.price ? product : max
);

// Уникальные категории
const categories = [...new Set(products.map(p => p.category))];
```

## Практические рекомендации

1. Используйте методы массивов (map, filter, reduce) вместо традиционных циклов для более читаемого кода
2. Не мутируйте исходный массив, если это не требуется - используйте методы, возвращающие новые массивы
3. В российских проектах часто используются массивы для работы с API-ответами, формами и списками данных
4. Будьте осторожны с производительностью при работе с большими массивами
5. Используйте `Array.isArray()` для проверки, является ли значение массивом

```javascript
// Проверка на массив
function isArray(value) {
    return Array.isArray(value); // предпочтительнее чем typeof
}

// Пример проверки
const data = JSON.parse(response);
if (Array.isArray(data)) {
    // обработка массива
    data.forEach(item => processItem(item));
} else {
    // обработка одиночного объекта
    processItem(data);
}
```

> [!warning] Важно
> Методы массивов не обрабатывают "дыры" в массиве (sparse arrays), т.е. пустые слоты пропускаются.

## См. также

- [[Объекты]]
- [[Функции]]
- [[Типы-данных]]
- [[Замыкания]]
- [[Управляющие-конструкции]]