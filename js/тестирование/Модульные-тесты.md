---
aliases: ["Unit Tests", "Модульное тестирование", "Тестирование функций"]
tags: ["#javascript", "#testing", "#unit-testing", "#best-practices"]
---

# Модульные тесты

## Определение модульного тестирования

Модульное тестирование (unit testing) — это тип тестирования, при котором отдельные компоненты или "модули" программного обеспечения тестируются изолированно. В контексте JavaScript-приложений модульные тесты обычно проверяют отдельные функции, методы или классы.

## Цель модульных тестов

Цель модульного тестирования — убедиться, что каждый отдельный компонент работает правильно в изоляции. Это позволяет:
- Обнаруживать ошибки на ранних стадиях
- Упрощать процесс отладки
- Обеспечивать стабильность при рефакторинге
- Документировать поведение кода

## Принципы модульного тестирования

> [!tip] Принципы хорошего модульного тестирования
> - Тест должен проверять одну вещь
> - Тест должен быть изолированным от других тестов
> - Тест должен быть быстрым
> - Тест должен быть понятным
> - Тест должен быть стабильным

## Структура модульного теста

Классический модульный тест следует паттерну AAA:
- **Arrange** (подготовка) — настройка тестовых данных и зависимостей
- **Act** (действие) — выполнение тестируемой функции
- **Assert** (проверка) — проверка результата

```javascript
// Пример модульного теста с использованием Jest
describe('Калькулятор', () => {
  test('должен складывать два числа', () => {
    // Arrange
    const calculator = new Calculator();
    
    // Act
    const result = calculator.add(2, 3);
    
    // Assert
    expect(result).toBe(5);
  });
});
```

## Тестирование асинхронного кода

JavaScript часто работает с асинхронным кодом, и модульные тесты должны учитывать это:

```javascript
// Тестирование асинхронной функции
test('должен возвращать данные из API', async () => {
  // Arrange
  const mockData = { id: 1, name: 'Test' };
  jest.spyOn(global, 'fetch').mockResolvedValue({
    json: jest.fn().mockResolvedValue(mockData)
  });

  // Act
  const result = await fetchData(1);

  // Assert
  expect(result).toEqual(mockData);
  global.fetch.mockRestore();
});
```

## Использование моков и стабов

Для изоляции тестируемых компонентов используются моки (mocks) и стабы (stubs):

- **Stubs** — возвращают фиксированные значения
- **Mocks** — позволяют проверять вызовы методов и их параметры

```javascript
// Использование мока в Jest
test('должен вызвать обработчик при клике', () => {
  const handler = jest.fn();
  const button = new Button(handler);
  
  button.click();
  
  expect(handler).toHaveBeenCalledTimes(1);
});
```

## Популярные фреймворки для модульного тестирования

В 2025 году в российском IT-ландшафте популярны следующие фреймворки:

- [[Инструменты-тестирования#Jest]] — один из самых популярных фреймворков
- [[Инструменты-тестирования#Vitest]] — быстрый фреймворк от создателей Vite
- [[Инструменты-тестирования#Mocha]] — гибкий фреймворк с плагинами
- [[Инструменты-тестирования#Jasmine]] — BDD фреймворк

## Покрытие кода

Покрытие кода (code coverage) показывает, какой процент кода охвачен тестами. Важно стремиться к высокому, но не к 100% покрытию:

```javascript
// Пример настройки покрытия в Jest
// jest.config.js
module.exports = {
  collectCoverage: true,
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 85,
      lines: 90,
      statements: 90,
    },
  },
};
```

## Тестирование чистых функций

Чистые функции особенно хорошо подходят для модульного тестирования, так как они:
- Не имеют побочных эффектов
- Возвращают одинаковый результат для одинаковых входных данных
- Легко тестируются изолированно

```javascript
// Чистая функция
function calculateTotal(items) {
  return items.reduce((total, item) => total + item.price, 0);
}

// Тест для чистой функции
test('должна правильно вычислять общую сумму', () => {
  const items = [
    { name: 'Товар 1', price: 100 },
    { name: 'Товар 2', price: 200 },
    { name: 'Товар 3', price: 300 }
  ];
  
  const total = calculateTotal(items);
  
  expect(total).toBe(600);
});
```

## Тестирование граничных условий

При тестировании важно проверять граничные условия (boundary conditions):

- Пустые значения
- Максимальные/минимальные значения
- Неожиданные типы данных

```javascript
test('должна обрабатывать пустой массив', () => {
  const result = calculateTotal([]);
  expect(result).toBe(0);
});

test('должна обрабатывать отрицательные значения', () => {
  const items = [{ name: 'Товар', price: -50 }];
  const result = calculateTotal(items);
  expect(result).toBe(-50);
});
```

## Современные подходы к модульному тестированию

В 2025 году в российской практике становятся популярны следующие подходы:

- **Property-based testing** — тестирование на основе свойств
- **Snapshot testing** — сохранение и сравнение снимков состояния
- **Mutation testing** — тестирование качества тестов путем внесения изменений в код

## Заключение

Модульное тестирование — основа надежного JavaScript-приложения. Правильное применение модульных тестов позволяет создавать более стабильный и поддерживаемый код. Важно помнить, что тесты должны быть не только функциональными, но и понятными, поддерживаемыми и быстрыми в выполнении.

> [!note] См. также
> - [[Введение-в-тестирование]]
> - [[Интеграционные-тесты]]
> - [[Сквозные-тесты]]
> - [[Инструменты-тестирования]]
> - [[Тестирование-чистых-функций]]