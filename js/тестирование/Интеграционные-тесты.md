---
aliases: ["Integration Tests", "Интеграционное тестирование", "Тестирование взаимодействия"]
tags: ["#javascript", "#testing", "#integration-testing", "#api-testing"]
---

# Интеграционные тесты

## Определение интеграционного тестирования

Интеграционное тестирование — это тип тестирования, при котором проверяется взаимодействие между различными компонентами или модулями системы. В контексте JavaScript-приложений интеграционные тесты проверяют, как разные части приложения работают вместе, включая взаимодействие с API, базами данных и другими внешними системами.

## Цель интеграционных тестов

Цель интеграционного тестирования — убедиться, что различные компоненты приложения корректно взаимодействуют друг с другом. Это позволяет:
- Обнаруживать ошибки в интерфейсах между компонентами
- Проверять корректность передачи данных
- Обеспечивать стабильность при интеграции новых функций
- Проверять работу систем в комплексе

## Отличие от модульных тестов

> [!note] Отличие интеграционных тестов от модульных
> - Модульные тесты проверяют отдельные компоненты в изоляции
> - Интеграционные тесты проверяют взаимодействие между компонентами
> - Модульные тесты быстрее и стабильнее
> - Интеграционные тесты более реалистичны, но медленнее

## Типы интеграционных тестов

### 1. Тестирование API

Проверка взаимодействия между клиентом и сервером:

```javascript
// Пример интеграционного теста для API
const request = require('supertest');
const app = require('../app');

describe('API endpoints', () => {
  test('GET /api/users должен возвращать список пользователей', async () => {
    const response = await request(app)
      .get('/api/users')
      .expect(200);
    
    expect(Array.isArray(response.body)).toBe(true);
    expect(response.body.length).toBeGreaterThan(0);
  });

  test('POST /api/users должен создавать нового пользователя', async () => {
    const newUser = { name: 'Новый пользователь', email: 'test@example.com' };
    
    const response = await request(app)
      .post('/api/users')
      .send(newUser)
      .expect(201);
    
    expect(response.body.name).toBe(newUser.name);
    expect(response.body.email).toBe(newUser.email);
  });
});
```

### 2. Тестирование базы данных

Проверка взаимодействия с базой данных:

```javascript
// Пример теста взаимодействия с базой данных
describe('User repository', () => {
  beforeEach(async () => {
    // Очистка базы данных перед каждым тестом
    await User.deleteMany({});
  });

  test('должен сохранять и находить пользователя', async () => {
    const user = new User({ name: 'Тестовый пользователь', email: 'test@example.com' });
    await user.save();

    const foundUser = await User.findOne({ email: 'test@example.com' });
    
    expect(foundUser).not.toBeNull();
    expect(foundUser.name).toBe('Тестовый пользователь');
  });
});
```

### 3. Тестирование сервисов

Проверка взаимодействия между различными сервисами:

```javascript
// Пример теста взаимодействия сервисов
describe('Order service', () => {
  let orderService;
  let paymentService;
  let inventoryService;

  beforeEach(() => {
    paymentService = new PaymentService();
    inventoryService = new InventoryService();
    orderService = new OrderService(paymentService, inventoryService);
    
    // Мокаем внешние зависимости
    jest.spyOn(paymentService, 'processPayment').mockResolvedValue({ success: true });
    jest.spyOn(inventoryService, 'checkAvailability').mockResolvedValue(true);
    jest.spyOn(inventoryService, 'reserveItems').mockResolvedValue(true);
  });

  test('должен создать заказ при наличии оплаты и инвентаря', async () => {
    const orderData = { userId: 1, items: [{ productId: 1, quantity: 2 }] };
    
    const result = await orderService.createOrder(orderData);
    
    expect(result.success).toBe(true);
    expect(paymentService.processPayment).toHaveBeenCalled();
    expect(inventoryService.reserveItems).toHaveBeenCalled();
  });
});
```

## Подходы к интеграционному тестированию

### 1. Big Bang Integration Testing

Все компоненты объединяются сразу и тестируются вместе. Редко используется из-за сложности отладки.

### 2. Top-Down Integration Testing

Тестирование начинается с верхнего уровня системы и постепенно включает нижележащие компоненты. Используются драйверы и стабы.

### 3. Bottom-Up Integration Testing

Тестирование начинается с нижних уровней и постепенно поднимаются к верхним. Используются драйверы для тестирования.

### 4. Sandwich/Hybrid Integration Testing

Сочетание верхнего и нижнего подходов.

## Использование моков и фейков

При интеграционном тестировании часто используются моки для внешних зависимостей:

```javascript
// Пример использования мока для внешнего API
describe('Weather service', () => {
  let weatherService;
  let httpMock;

  beforeEach(() => {
    httpMock = {
      get: jest.fn()
    };
    weatherService = new WeatherService(httpMock);
  });

  test('должен получить данные о погоде', async () => {
    const mockResponse = { temperature: 20, condition: 'sunny' };
    httpMock.get.mockResolvedValue(mockResponse);

    const result = await weatherService.getCurrentWeather('Moscow');
    
    expect(result.temperature).toBe(20);
    expect(httpMock.get).toHaveBeenCalledWith('http://api.weather.com/moscow');
  });
});
```

## Тестирование асинхронных процессов

Интеграционные тесты часто включают асинхронные операции:

```javascript
// Тестирование асинхронного взаимодействия
test('должен обработать заказ и отправить уведомление', async () => {
  const orderId = await orderService.createOrder(orderData);
  await waitForNotification(orderId); // Ждем асинхронное уведомление
  
  const notification = await notificationService.getLastNotification(orderId);
  expect(notification.status).toBe('sent');
}, 10000); // Увеличен таймаут до 10 секунд
```

## Настройка тестового окружения

Для интеграционных тестов часто требуется специальное окружение:

```javascript
// Пример настройки тестового окружения
const mongoose = require('mongoose');
const app = require('../app');

let server;

beforeAll(async () => {
  // Подключение к тестовой базе данных
  await mongoose.connect(process.env.TEST_DB_URL);
  
  // Запуск сервера
  server = app.listen(3001);
});

afterAll(async () => {
  // Закрытие соединений
  await mongoose.connection.close();
  await server.close();
});

beforeEach(async () => {
  // Очистка коллекций перед каждым тестом
  await mongoose.connection.db.dropDatabase();
});
```

## Современные подходы в российском IT (2025)

В 2025 году в российской практике интеграционное тестирование включает:

- **Contract testing** — тестирование контрактов между сервисами
- **Consumer-driven contracts** — тестирование на основе потребностей клиентов
- **API-first development** — разработка API с тестированием с самого начала
- **Test containers** — использование контейнеров для тестирования интеграций

## Инструменты для интеграционного тестирования

Популярные инструменты в 2025 году:

- [[Инструменты-тестирования#Cypress]] — для интеграционного тестирования фронтенда
- [[Инструменты-тестирования#Postman]] — для тестирования API
- [[Инструменты-тестирования#Supertest]] — для тестирования HTTP-маршрутов
- [[Инструменты-тестирования#Puppeteer]] — для тестирования в браузере

## Заключение

Интеграционные тесты занимают важное место в пирамиде тестирования, обеспечивая проверку взаимодействия между компонентами системы. Они более сложны в настройке и выполнении, чем модульные тесты, но предоставляют более реалистичную картину работы приложения. Правильное использование интеграционных тестов помогает выявлять проблемы на границах компонентов и обеспечивает стабильность всей системы.

> [!note] См. также
> - [[Введение-в-тестирование]]
> - [[Модульные-тесты]]
> - [[Сквозные-тесты]]
> - [[Инструменты-тестирования]]
> - [[Тестирование-API]]