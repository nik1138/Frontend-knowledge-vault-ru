# Тестирование в JavaScript

## Введение

Тестирование - это процесс проверки правильности работы кода путем выполнения автоматизированных тестов. В JavaScript существует множество подходов и инструментов для тестирования, которые помогают обеспечить качество кода, предотвратить регрессии и упростить рефакторинг.

## Основные типы тестирования

### 1. Модульное тестирование (Unit Testing)

Модульное тестирование проверяет отдельные части кода (функции, классы, модули) изолированно от остальной системы.

```javascript
// Пример функции для тестирования
function calculateTotal(items) {
  if (!Array.isArray(items)) {
    throw new Error('Items must be an array');
  }
  
  return items.reduce((total, item) => {
    if (typeof item.price !== 'number') {
      throw new Error('Item price must be a number');
    }
    return total + item.price;
  }, 0);
}

// Пример модульного теста (псевдокод)
describe('calculateTotal', () => {
  test('should calculate total for valid items', () => {
    const items = [
      { name: 'Item 1', price: 10 },
      { name: 'Item 2', price: 20 }
    ];
    
    const result = calculateTotal(items);
    expect(result).toBe(30);
  });
  
  test('should return 0 for empty array', () => {
    const result = calculateTotal([]);
    expect(result).toBe(0);
  });
  
  test('should throw error for non-array input', () => {
    expect(() => {
      calculateTotal('not an array');
    }).toThrow('Items must be an array');
  });
});
```

### 2. Интеграционное тестирование

Интеграционное тестирование проверяет взаимодействие между несколькими модулями или компонентами системы.

```javascript
// Пример интеграционного теста для API
async function testUserAPI() {
  // Создание тестового пользователя
  const userData = { name: 'Test User', email: 'test@example.com' };
  const createdUser = await api.createUser(userData);
  
  // Проверка создания
  expect(createdUser).toHaveProperty('id');
  expect(createdUser.name).toBe(userData.name);
  expect(createdUser.email).toBe(userData.email);
  
  // Получение пользователя
  const fetchedUser = await api.getUser(createdUser.id);
  expect(fetchedUser).toEqual(createdUser);
  
  // Обновление пользователя
  const updatedData = { name: 'Updated User' };
  const updatedUser = await api.updateUser(createdUser.id, updatedData);
  expect(updatedUser.name).toBe(updatedData.name);
  
  // Удаление пользователя
  await api.deleteUser(createdUser.id);
  const deletedUser = await api.getUser(createdUser.id);
  expect(deletedUser).toBeNull();
}
```

### 3. Функциональное тестирование

Функциональное тестирование проверяет, соответствует ли система спецификациям и требованиям.

```javascript
// Пример функционального теста для формы входа
async function testLoginForm() {
  // Открытие страницы входа
  await page.goto('/login');
  
  // Заполнение формы
  await page.fill('#email', 'user@example.com');
  await page.fill('#password', 'password123');
  
  // Отправка формы
  await page.click('#login-button');
  
  // Проверка результата
  await page.waitForSelector('#dashboard');
  const url = await page.url();
  expect(url).toContain('/dashboard');
}
```

## Основные понятия тестирования

### 1. AAA паттерн (Arrange, Act, Assert)

```javascript
test('should calculate discount correctly', () => {
  // Arrange (Подготовка)
  const originalPrice = 100;
  const discountPercent = 20;
  const expectedPrice = 80;
  
  // Act (Действие)
  const discountedPrice = calculateDiscount(originalPrice, discountPercent);
  
  // Assert (Проверка)
  expect(discountedPrice).toBe(expectedPrice);
});
```

### 2. Mock-объекты и заглушки

```javascript
// Mock для HTTP-запросов
const mockFetch = jest.fn();
mockFetch.mockResolvedValue({
  json: () => Promise.resolve({ id: 1, name: 'Test User' })
});

// Использование mock в тесте
async function testFetchUser() {
  const user = await fetchUser(1, mockFetch);
  expect(user).toEqual({ id: 1, name: 'Test User' });
  expect(mockFetch).toHaveBeenCalledWith('/api/users/1');
}

// Stub для зависимости
const mockDatabase = {
  findUser: jest.fn().mockReturnValue({ id: 1, name: 'Test User' }),
  saveUser: jest.fn().mockResolvedValue(true)
};

function testUserService() {
  const service = new UserService(mockDatabase);
  const user = service.getUser(1);
  expect(user).toEqual({ id: 1, name: 'Test User' });
  expect(mockDatabase.findUser).toHaveBeenCalledWith(1);
}
```

### 3. Тестирование асинхронного кода

```javascript
// Тестирование Promise
test('should fetch user data', async () => {
  const userData = await fetchUser(1);
  expect(userData).toHaveProperty('id');
  expect(userData).toHaveProperty('name');
});

// Тестирование callback-функций
test('should call callback with result', (done) => {
  processUserData(data, (error, result) => {
    expect(error).toBeNull();
    expect(result).toBeDefined();
    done(); // Уведомляем тестовый фреймворк о завершении
  });
});

// Тестирование таймеров
test('should call function after delay', () => {
  jest.useFakeTimers();
  
  const mockCallback = jest.fn();
  delayedFunction(1000, mockCallback);
  
  jest.advanceTimersByTime(1000);
  expect(mockCallback).toHaveBeenCalled();
});
```

## Популярные фреймворки и библиотеки для тестирования

### 1. Jest

Jest - это полнофункциональный фреймворк для тестирования JavaScript, разработанный Facebook.

```javascript
// Пример теста с Jest
describe('UserService', () => {
  let userService;
  let mockDatabase;
  
  beforeEach(() => {
    mockDatabase = {
      findUser: jest.fn(),
      saveUser: jest.fn()
    };
    userService = new UserService(mockDatabase);
  });
  
  describe('getUser', () => {
    test('should return user when found', async () => {
      const mockUser = { id: 1, name: 'John' };
      mockDatabase.findUser.mockResolvedValue(mockUser);
      
      const user = await userService.getUser(1);
      
      expect(user).toEqual(mockUser);
      expect(mockDatabase.findUser).toHaveBeenCalledWith(1);
    });
    
    test('should throw error when user not found', async () => {
      mockDatabase.findUser.mockResolvedValue(null);
      
      await expect(userService.getUser(999))
        .rejects
        .toThrow('User not found');
    });
  });
});
```

### 2. Mocha и Chai

Mocha - это гибкий фреймворк для тестирования, а Chai - библиотека для утверждений.

```javascript
// Пример теста с Mocha и Chai
const { expect } = require('chai');

describe('Calculator', function() {
  describe('#add()', function() {
    it('should add two numbers correctly', function() {
      const calculator = new Calculator();
      const result = calculator.add(2, 3);
      expect(result).to.equal(5);
    });
    
    it('should handle negative numbers', function() {
      const calculator = new Calculator();
      const result = calculator.add(-2, 3);
      expect(result).to.equal(1);
    });
  });
});
```

### 3. Jasmine

Jasmine - это фреймворк для поведенческого тестирования (BDD).

```javascript
// Пример теста с Jasmine
describe('Player', function() {
  let player;
  let song;
  
  beforeEach(function() {
    player = new Player();
    song = new Song();
  });
  
  it('should be able to play a Song', function() {
    player.play(song);
    expect(player.currentlyPlayingSong).toEqual(song);
    
    // демонстрирует использование пользовательских матчеров
    expect(player).toBePlaying(song);
  });
  
  describe('when song has been paused', function() {
    beforeEach(function() {
      player.play(song);
      player.pause();
    });
    
    it('should indicate that the song is currently paused', function() {
      expect(player.isPlaying).toBeFalsy();
      
      // демонстрирует использование 'not' с пользовательским матчером
      expect(player).not.toBePlaying(song);
    });
  });
});
```

## Тестирование React-компонентов

### 1. React Testing Library

```javascript
// Пример теста компонента с React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Counter from './Counter';

test('should increment counter when button is clicked', () => {
  render(<Counter />);
  
  const counter = screen.getByText('0');
  const button = screen.getByText('Increment');
  
  fireEvent.click(button);
  
  expect(counter).toHaveTextContent('1');
});

test('should reset counter when reset button is clicked', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  
  // Увеличиваем счетчик
  const incrementButton = screen.getByText('Increment');
  await user.click(incrementButton);
  await user.click(incrementButton);
  
  expect(screen.getByText('2')).toBeInTheDocument();
  
  // Сбрасываем счетчик
  const resetButton = screen.getByText('Reset');
  await user.click(resetButton);
  
  expect(screen.getByText('0')).toBeInTheDocument();
});
```

### 2. Enzyme (устаревший, но все еще используемый)

```javascript
// Пример теста с Enzyme
import { shallow, mount } from 'enzyme';
import Counter from './Counter';

describe('Counter', () => {
  it('should start with count of 0', () => {
    const wrapper = shallow(<Counter />);
    expect(wrapper.state('count')).toBe(0);
  });
  
  it('should increment count when button is clicked', () => {
    const wrapper = shallow(<Counter />);
    const button = wrapper.find('button');
    
    button.simulate('click');
    
    expect(wrapper.state('count')).toBe(1);
  });
  
  it('should render correctly', () => {
    const wrapper = mount(<Counter />);
    expect(wrapper.text()).toContain('Count: 0');
  });
});
```

## Тестирование Node.js приложений

### 1. Тестирование Express-приложений

```javascript
// Пример теста Express-приложения с Supertest
const request = require('supertest');
const app = require('../app');

describe('GET /users', () => {
  it('should return list of users', async () => {
    const response = await request(app)
      .get('/users')
      .expect(200)
      .expect('Content-Type', /json/);
    
    expect(response.body).toBeInstanceOf(Array);
    expect(response.body.length).toBeGreaterThan(0);
  });
});

describe('POST /users', () => {
  it('should create new user', async () => {
    const newUser = {
      name: 'John Doe',
      email: 'john@example.com'
    };
    
    const response = await request(app)
      .post('/users')
      .send(newUser)
      .expect(201);
    
    expect(response.body).toHaveProperty('id');
    expect(response.body.name).toBe(newUser.name);
    expect(response.body.email).toBe(newUser.email);
  });
});
```

### 2. Тестирование баз данных

```javascript
// Пример теста с базой данных
describe('UserService', () => {
  let db;
  
  beforeAll(async () => {
    db = await setupTestDatabase();
  });
  
  afterAll(async () => {
    await db.close();
  });
  
  beforeEach(async () => {
    await db.clear();
  });
  
  test('should create user in database', async () => {
    const userData = { name: 'John', email: 'john@example.com' };
    const user = await UserService.create(userData);
    
    expect(user).toHaveProperty('id');
    expect(user.name).toBe(userData.name);
    
    // Проверка, что пользователь действительно сохранен в БД
    const savedUser = await db.findUser(user.id);
    expect(savedUser).toEqual(user);
  });
});
```

## Покрытие кода тестами

Покрытие кода тестами - это метрика, показывающая, какой процент кода выполняется во время тестов.

```javascript
// Пример кода с хорошим покрытием
function processOrder(order) {
  if (!order.items || order.items.length === 0) {
    throw new Error('Order must have items');
  }
  
  const total = order.items.reduce((sum, item) => {
    if (typeof item.price !== 'number' || item.price < 0) {
      throw new Error('Invalid item price');
    }
    return sum + item.price;
  }, 0);
  
  if (total > 1000) {
    // Скидка 10% для заказов свыше 1000
    return total * 0.9;
  }
  
  return total;
}

// Тесты для обеспечения полного покрытия
describe('processOrder', () => {
  test('should throw error for empty items', () => {
    expect(() => processOrder({ items: [] }))
      .toThrow('Order must have items');
  });
  
  test('should throw error for invalid price', () => {
    const order = { items: [{ price: 'invalid' }] };
    expect(() => processOrder(order))
      .toThrow('Invalid item price');
  });
  
  test('should calculate total without discount', () => {
    const order = { items: [{ price: 100 }, { price: 200 }] };
    expect(processOrder(order)).toBe(300);
  });
  
  test('should apply discount for large orders', () => {
    const order = { items: [{ price: 600 }, { price: 500 }] };
    expect(processOrder(order)).toBe(990); // 1100 * 0.9
  });
});
```

## Лучшие практики тестирования

### 1. Пишите читаемые тесты

```javascript
// Плохо: непонятные названия и структура
it('t1', () => {
  const r = calc(1, 2);
  expect(r).toBe(3);
});

// Хорошо: понятные названия и структура
describe('Calculator', () => {
  describe('add method', () => {
    it('should return sum of two positive numbers', () => {
      const result = calculator.add(1, 2);
      expect(result).toBe(3);
    });
    
    it('should return sum of negative and positive numbers', () => {
      const result = calculator.add(-1, 2);
      expect(result).toBe(1);
    });
  });
});
```

### 2. Используйте правильные данные для тестов

```javascript
// Плохо: сложные и непонятные данные
test('should process complex data', () => {
  const data = {
    a: { b: { c: [{ d: 1, e: [{ f: { g: 2 } }] }] } },
    h: [{ i: { j: 3, k: [{ l: 4 }] } }]
  };
  // ...
});

// Хорошо: простые и понятные данные
test('should calculate user age', () => {
  const user = { birthYear: 1990 };
  const currentYear = 2023;
  
  const age = calculateAge(user, currentYear);
  
  expect(age).toBe(33);
});
```

### 3. Тестируйте поведение, а не реализацию

```javascript
// Плохо: тестирование внутренней реализации
test('should call internal method', () => {
  const service = new UserService();
  const spy = jest.spyOn(service, 'internalMethod');
  
  service.createUser({ name: 'John' });
  
  expect(spy).toHaveBeenCalled();
});

// Хорошо: тестирование поведения
test('should create user with given data', () => {
  const service = new UserService();
  
  const user = service.createUser({ name: 'John' });
  
  expect(user).toHaveProperty('id');
  expect(user.name).toBe('John');
  expect(user.createdAt).toBeDefined();
});
```

### 4. Изолируйте тесты

```javascript
// Плохо: тесты зависят друг от друга
let counter = 0;

test('should increment counter', () => {
  counter++;
  expect(counter).toBe(1);
});

test('should increment counter again', () => {
  counter++;
  expect(counter).toBe(2); // Зависит от предыдущего теста
});

// Хорошо: каждый тест изолирован
test('should increment counter', () => {
  const counter = new Counter();
  counter.increment();
  expect(counter.value).toBe(1);
});

test('should increment counter again', () => {
  const counter = new Counter(); // Новый экземпляр
  counter.increment();
  expect(counter.value).toBe(1);
});
```

## Настройка тестовой среды

### 1. Конфигурация Jest

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/index.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.js'],
  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  }
};
```

### 2. Настройка CI/CD для тестов

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test
      - name: Run linting
        run: npm run lint
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v1
```

## Заключение

Тестирование - это критически важная часть разработки программного обеспечения. Хорошо написанные тесты помогают:

1. Обеспечить качество кода
2. Предотвратить регрессии
3. Упростить рефакторинг
4. Документировать поведение системы
5. Повысить уверенность в изменениях

Ключевые принципы эффективного тестирования:

- Пишите читаемые и поддерживаемые тесты
- Тестируйте поведение, а не реализацию
- Поддерживайте высокое покрытие кода тестами
- Используйте подходящие инструменты для разных типов тестов
- Автоматизируйте запуск тестов в CI/CD

#javascript #testing #jest #mocha #chai #tdd #bdd #unit-testing #integration-testing