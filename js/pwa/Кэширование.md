---
aliases: ["Кэширование в PWA", "Cache API", "Кэш"]
tags: ["#pwa", "#caching", "#performance", "#offline", "#javascript"]
---

# Кэширование

Кэширование - один из ключевых аспектов прогрессивных веб-приложений (PWA), обеспечивающий быструю загрузку, оффлайн-доступ и улучшенную производительность. В 2025 году кэширование становится особенно важным для российских разработчиков, учитывая требования к доступности и производительности веб-приложений в условиях ограниченного интернет-соединения.

## Введение в кэширование в PWA

Кэширование в PWA осуществляется через Cache API, которое работает в сочетании с Service Workers. Это позволяет:

- Сохранять статические ресурсы (CSS, JavaScript, изображения)
- Кэшировать динамические данные (API-ответы)
- Обеспечивать оффлайн-доступ к контенту
- Улучшать время загрузки приложения

## Cache API

Cache API предоставляет интерфейс для хранения и получения HTTP-ответов в кэше браузера:

```javascript
// Открытие кэша
caches.open('my-cache-v1')
  .then(function(cache) {
    // Добавление ресурсов в кэш
    return cache.addAll([
      '/',
      '/styles/main.css',
      '/scripts/main.js',
      '/images/logo.png'
    ]);
  });

// Получение ресурса из кэша
caches.match('/styles/main.css')
  .then(function(response) {
    if (response) {
      // Ресурс найден в кэше
      return response;
    }
    // Ресурс не найден в кэше
    return fetch('/styles/main.css');
  });
```

## Стратегии кэширования

### 1. Cache-only стратегия

Ресурс запрашивается только из кэша. Если ресурс не найден, запрос завершается неудачей.

```javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request)
      .then(function(response) {
        if (response) {
          return response;
        }
        return new Response('Ресурс не найден в кэше', {
          status: 404,
          headers: { 'Content-Type': 'text/plain' }
        });
      })
  );
});
```

### 2. Network-only стратегия

Ресурс запрашивается только из сети. Не использует кэш.

```javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(fetch(event.request));
});
```

### 3. Cache-first стратегия

Сначала проверяется кэш, если ресурс не найден, делается сетевой запрос.

```javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request)
      .then(function(response) {
        return response || fetch(event.request);
      })
  );
});
```

### 4. Network-first стратегия

Сначала делается сетевой запрос, если он неудачен, используется кэш.

```javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch(event.request)
      .then(function(networkResponse) {
        // Кэшируем успешный ответ
        caches.open('my-cache-v1')
          .then(function(cache) {
            cache.put(event.request, networkResponse.clone());
          });
        return networkResponse;
      })
      .catch(function() {
        // Возвращаем кэшированный ресурс при ошибке сети
        return caches.match(event.request);
      })
  );
});
```

### 5. Stale-while-revalidate стратегия

Возвращает кэшированный ресурс, но параллельно обновляет его в фоне.

```javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.open('my-cache-v1')
      .then(function(cache) {
        return cache.match(event.request)
          .then(function(response) {
            // Делаем сетевой запрос для обновления кэша
            var networkFetch = fetch(event.request)
              .then(function(networkResponse) {
                // Обновляем кэш
                cache.put(event.request, networkResponse.clone());
                return networkResponse;
              });
            
            // Возвращаем кэшированный ресурс или сетевой запрос
            return response || networkFetch;
          });
      })
  );
});
```

## Кэширование статических ресурсов

### При установке Service Worker

```javascript
var CACHE_NAME = 'static-v1';
var urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png',
  '/offline.html'
];

self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(function(cache) {
        console.log('Открыт кэш');
        return cache.addAll(urlsToCache);
      })
  );
});
```

### При активации Service Worker

```javascript
self.addEventListener('activate', function(event) {
  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheName !== CACHE_NAME) {
            console.log('Удаление старого кэша', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

## Кэширование API-ответов

Для кэширования динамических данных (например, API-ответов) используется Network-first стратегия:

```javascript
self.addEventListener('fetch', function(event) {
  // Проверяем, является ли запрос API-запросом
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then(function(networkResponse) {
          // Кэшируем ответ
          var responseClone = networkResponse.clone();
          caches.open('api-cache-v1')
            .then(function(cache) {
              cache.put(event.request, responseClone);
            });
          return networkResponse;
        })
        .catch(function() {
          // Возвращаем кэшированный ответ при ошибке сети
          return caches.match(event.request);
        })
    );
  }
});
```

## Управление кэшем

### Удаление кэша

```javascript
// Удаление конкретного кэша
caches.delete('my-cache-v1');

// Удаление конкретного запроса из кэша
caches.open('my-cache-v1')
  .then(function(cache) {
    cache.delete('/styles/main.css');
  });
```

### Проверка наличия кэша

```javascript
caches.has('my-cache-v1')
  .then(function(hasCache) {
    if (hasCache) {
      console.log('Кэш существует');
    } else {
      console.log('Кэш не существует');
    }
  });
```

### Получение всех ключей кэша

```javascript
caches.open('my-cache-v1')
  .then(function(cache) {
    cache.keys().then(function(requests) {
      requests.forEach(function(request) {
        console.log(request.url);
      });
    });
  });
```

## Кэширование изображений

Изображения можно кэшировать различными способами в зависимости от их использования:

```javascript
// Кэширование изображений при загрузке
self.addEventListener('fetch', function(event) {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.match(event.request)
        .then(function(response) {
          return response || fetch(event.request)
            .then(function(response) {
              // Кэшируем изображение для будущих запросов
              var responseClone = response.clone();
              caches.open('images-cache-v1')
                .then(function(cache) {
                  cache.put(event.request, responseClone);
                });
              return response;
            });
        })
    );
  }
});
```

## Кэширование шрифтов

Шрифты также можно кэшировать для улучшения производительности:

```javascript
self.addEventListener('fetch', function(event) {
  if (event.request.destination === 'font') {
    event.respondWith(
      caches.match(event.request)
        .then(function(response) {
          return response || fetch(event.request)
            .then(function(response) {
              var responseClone = response.clone();
              caches.open('fonts-cache-v1')
                .then(function(cache) {
                  cache.put(event.request, responseClone);
                });
              return response;
            });
        })
    );
  }
});
```

## Оптимизация кэширования

### Управление размером кэша

```javascript
// Ограничение размера кэша
function trimCache(cacheName, maxItems) {
  caches.open(cacheName)
    .then(function(cache) {
      return cache.keys()
        .then(function(requests) {
          if (requests.length > maxItems) {
            cache.delete(requests[0])
              .then(trimCache(cacheName, maxItems));
          }
        });
    });
}

// Использование при обновлении кэша
self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch(event.request)
      .then(function(response) {
        var responseClone = response.clone();
        caches.open('my-cache-v1')
          .then(function(cache) {
            cache.put(event.request, responseClone);
            trimCache('my-cache-v1', 50); // Ограничиваем до 50 элементов
          });
        return response;
      })
  );
});
```

### Кэширование с учетом версии

```javascript
// Использование версии приложения для кэширования
var VERSION = 'v2.1.0';
var CACHE_NAME = 'app-' + VERSION;

// При обновлении версии будет использоваться новый кэш
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(function(cache) {
        return cache.addAll([
          '/styles/main.css',
          '/scripts/main.js',
          '/index.html'
        ]);
      })
  );
});
```

## Рекомендации по кэшированию

### Что кэшировать

- Статические ресурсы (CSS, JavaScript, изображения)
- Часто используемые API-ответы
- Шрифты и иконки
- Страницы с оффлайн-контентом

### Что не кэшировать

- Очень большие файлы (например, видео)
- Часто изменяющийся контент
- Конфиденциальные данные без шифрования

> [!warning] Важно
> Не кэшируйте чувствительные данные без шифрования. Кэш доступен всем пользователям системы.

## Кэширование в условиях российских реалий

В 2025 году при разработке PWA для российского рынка важно учитывать:

- Нестабильное интернет-соединение в некоторых регионах
- Ограничения на традиционные магазины приложений
- Популярность бюджетных устройств с ограниченной памятью
- Требования к локализации и поддержке кириллицы

### Рекомендации для российских разработчиков

1. **Оптимизация размера кэша**:
   - Учитывайте ограничения по объему кэша (обычно 10-20% от свободного места)
   - Используйте сжатие изображений и оптимизацию ресурсов

2. **Поддержка оффлайн-режима**:
   - Обеспечьте базовую функциональность приложения без интернета
   - Реализуйте синхронизацию данных при восстановлении соединения

3. **Локализация кэшированных данных**:
   - Кэшируйте локализованные версии контента
   - Учитывайте часовые пояса и региональные особенности

4. **Учет специфики устройств**:
   - Проверяйте работу на устройствах с ограниченной памятью
   - Оптимизируйте размеры кэшируемых изображений

## Совместимость и ограничения

Cache API поддерживается всеми современными браузерами:
- Chrome: с версии 40
- Firefox: с версии 39
- Safari: с версии 11.1
- Edge: с версии 17

### Ограничения

- Ограниченное дисковое пространство для кэша
- Невозможность кэширования запросов с определенными заголовками
- Ограничения на размер отдельных элементов кэша

## Практические примеры

### Кэширование данных профиля пользователя

```javascript
// Кэширование данных профиля
function cacheUserProfile(userId, profileData) {
  return caches.open('user-data-v1')
    .then(function(cache) {
      return cache.put(
        new Request('/api/user/' + userId),
        new Response(JSON.stringify(profileData), {
          headers: { 'Content-Type': 'application/json' }
        })
      );
    });
}

// Получение данных профиля из кэша
function getUserProfile(userId) {
  return caches.match('/api/user/' + userId)
    .then(function(response) {
      if (response) {
        return response.json();
      }
      return null;
    });
}
```

### Кэширование списка товаров

```javascript
// Кэширование списка товаров с учетом параметров запроса
self.addEventListener('fetch', function(event) {
  var requestUrl = new URL(event.request.url);
  
  if (requestUrl.pathname === '/api/products' && requestUrl.search) {
    event.respondWith(
      caches.match(event.request)
        .then(function(response) {
          return response || fetch(event.request)
            .then(function(networkResponse) {
              var responseClone = networkResponse.clone();
              caches.open('products-cache-v1')
                .then(function(cache) {
                  cache.put(event.request, responseClone);
                });
              return networkResponse;
            });
        })
    );
  }
});
```

## Связанные темы

- [[Service Workers]]
- [[Оффлайн-работа]]
- [[Web-App-Manifest]]
- [[Современные практики JavaScript]]
- [[Производительность веб-приложений]]