---
aliases: ["Отправка данных", "Form Submission", "Отправка форм"]
tags: [javascript, forms, submission, frontend, network]
---

# Отправка данных форм в JavaScript

## Обзор

Отправка данных форм - ключевой этап взаимодействия пользователя с веб-приложением. В 2025 году отправка данных включает в себя не только традиционные методы, но и современные подходы с использованием Fetch API, async/await, а также сложные сценарии с индикацией прогресса, обработкой ошибок и оптимистичными обновлениями.

## Традиционные методы отправки

### Стандартная отправка формы

```html
<form action="/api/submit" method="POST" id="traditionalForm">
  <input type="text" name="username" required>
  <input type="email" name="email" required>
  <button type="submit">Отправить</button>
</form>
```

При стандартной отправке форма отправляется на сервер с перезагрузкой страницы. Этот метод всё ещё используется, особенно для SEO-критичных приложений.

### Отправка через JavaScript с FormData

```javascript
const form = document.getElementById('traditionalForm');

form.addEventListener('submit', async (e) => {
  e.preventDefault(); // Предотвращаем стандартное поведение
  
  const formData = new FormData(form);
  
  try {
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData
    });
    
    if (response.ok) {
      const result = await response.json();
      handleSuccess(result);
    } else {
      const error = await response.json();
      handleError(error);
    }
  } catch (error) {
    console.error('Ошибка отправки формы:', error);
    handleError({ message: 'Произошла ошибка при отправке данных' });
  }
});

function handleSuccess(result) {
  console.log('Форма успешно отправлена:', result);
  // Показать сообщение пользователю
  showMessage('Форма успешно отправлена!', 'success');
  
  // Очистить форму при необходимости
  form.reset();
}

function handleError(error) {
  console.error('Ошибка при отправке формы:', error);
  showMessage(error.message || 'Произошла ошибка при отправке', 'error');
}
```

## Современные методы отправки

### Использование Fetch API с JSON

```javascript
async function submitFormAsJSON(form) {
  // Собираем данные формы в объект
  const formData = new FormData(form);
  const data = Object.fromEntries(formData.entries());
  
  // Обработка специфических типов данных
  Object.keys(data).forEach(key => {
    // Преобразование строк в числа для числовых полей
    if (form.elements[key] && form.elements[key].type === 'number' && data[key]) {
      data[key] = parseFloat(data[key]) || 0;
    }
    
    // Преобразование дат
    if (form.elements[key] && form.elements[key].type === 'date' && data[key]) {
      data[key] = new Date(data[key]).toISOString();
    }
    
    // Обработка чекбоксов
    if (form.elements[key] && form.elements[key].type === 'checkbox') {
      data[key] = form.elements[key].checked;
    }
  });
  
  try {
    const response = await fetch('/api/submit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    return { success: true, data: result };
  } catch (error) {
    console.error('Ошибка отправки JSON:', error);
    return { success: false, error: error.message };
  }
}
```

### Отправка с индикацией прогресса

```javascript
class FormSubmitter {
  constructor(form) {
    this.form = form;
    this.progressBar = null;
    this.submitButton = form.querySelector('button[type="submit"]');
    this.init();
  }
  
  init() {
    this.form.addEventListener('submit', this.handleSubmit.bind(this));
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    // Показываем индикатор загрузки
    this.showLoadingState();
    
    try {
      const result = await this.submitWithProgress();
      
      if (result.success) {
        this.handleSuccess(result.data);
      } else {
        this.handleError(result.error);
      }
    } catch (error) {
      this.handleError(error);
    } finally {
      this.hideLoadingState();
    }
  }
  
  async submitWithProgress() {
    const formData = new FormData(this.form);
    
    // Создаем прогресс-бар если его нет
    if (!this.progressBar) {
      this.createProgressBar();
    }
    
    try {
      // Для больших файлов используем XMLHttpRequest для отслеживания прогресса
      if (this.hasFiles(formData)) {
        return await this.submitWithXHR(formData);
      } else {
        // Для обычных данных используем fetch
        return await this.submitWithFetch(formData);
      }
    } finally {
      this.hideProgressBar();
    }
  }
  
  hasFiles(formData) {
    for (let [key, value] of formData.entries()) {
      if (value instanceof File) {
        return true;
      }
    }
    return false;
  }
  
  createProgressBar() {
    this.progressBar = document.createElement('div');
    this.progressBar.className = 'upload-progress';
    this.progressBar.innerHTML = `
      <div class="progress-bar">
        <div class="progress-fill"></div>
      </div>
      <div class="progress-text">Отправка данных...</div>
    `;
    
    this.form.insertBefore(this.progressBar, this.form.firstChild);
  }
  
  updateProgress(loaded, total) {
    const percent = Math.round((loaded / total) * 100);
    const fill = this.progressBar.querySelector('.progress-fill');
    const text = this.progressBar.querySelector('.progress-text');
    
    fill.style.width = `${percent}%`;
    text.textContent = `Отправка данных: ${percent}%`;
  }
  
  hideProgressBar() {
    if (this.progressBar) {
      this.progressBar.remove();
      this.progressBar = null;
    }
  }
  
  async submitWithXHR(formData) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          this.updateProgress(e.loaded, e.total);
        }
      });
      
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve({ success: true, data: JSON.parse(xhr.responseText) });
        } else {
          reject(new Error(`Ошибка сервера: ${xhr.status}`));
        }
      });
      
      xhr.addEventListener('error', () => {
        reject(new Error('Ошибка сети при отправке'));
      });
      
      xhr.addEventListener('abort', () => {
        reject(new Error('Отправка отменена'));
      });
      
      xhr.open('POST', this.form.getAttribute('action') || '/api/submit');
      xhr.send(formData);
    });
  }
  
  async submitWithFetch(formData) {
    // Показываем начальный прогресс
    this.updateProgress(0, 100);
    
    try {
      const response = await fetch(this.form.getAttribute('action') || '/api/submit', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      // Имитируем прогресс для небольших данных
      for (let i = 0; i <= 100; i += 10) {
        this.updateProgress(i, 100);
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      throw error;
    }
  }
  
  showLoadingState() {
    if (this.submitButton) {
      this.submitButton.disabled = true;
      this.submitButton.textContent = 'Отправка...';
      this.submitButton.classList.add('loading');
    }
  }
  
  hideLoadingState() {
    if (this.submitButton) {
      this.submitButton.disabled = false;
      this.submitButton.textContent = 'Отправить';
      this.submitButton.classList.remove('loading');
    }
  }
  
  handleSuccess(data) {
    this.showMessage('Форма успешно отправлена!', 'success');
    
    // Очистить форму при необходимости
    if (this.form.dataset.clearOnSuccess !== 'false') {
      this.form.reset();
    }
    
    // Вызвать пользовательское событие
    this.form.dispatchEvent(new CustomEvent('form-success', { detail: data }));
  }
  
  handleError(error) {
    this.showMessage(error.message || 'Произошла ошибка при отправке', 'error');
    
    // Вызвать пользовательское событие
    this.form.dispatchEvent(new CustomEvent('form-error', { detail: error }));
  }
  
  showMessage(text, type) {
    // Создаем элемент сообщения
    const messageEl = document.createElement('div');
    messageEl.className = `form-message form-message-${type}`;
    messageEl.textContent = text;
    messageEl.setAttribute('role', 'alert');
    
    // Добавляем перед формой
    this.form.parentNode.insertBefore(messageEl, this.form);
    
    // Автоматическое удаление через 5 секунд
    setTimeout(() => {
      messageEl.remove();
    }, 5000);
  }
}

// Инициализация для формы
const formSubmitter = new FormSubmitter(document.getElementById('uploadForm'));
```

## Обработка различных типов данных

### Отправка файлов

```javascript
class FileFormSubmitter extends FormSubmitter {
  async handleFileSubmission(form) {
    const fileInputs = form.querySelectorAll('input[type="file"]');
    const formData = new FormData(form);
    
    // Проверка файлов перед отправкой
    for (const input of fileInputs) {
      if (input.files && input.files.length > 0) {
        for (const file of input.files) {
          if (!this.validateFile(file)) {
            throw new Error(`Файл ${file.name} не соответствует требованиям`);
          }
        }
      }
    }
    
    return await this.submitWithProgress();
  }
  
  validateFile(file) {
    // Проверка типа файла
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
    if (!allowedTypes.includes(file.type)) {
      console.warn(`Неподдерживаемый тип файла: ${file.type}`);
      return false;
    }
    
    // Проверка размера (5MB)
    const maxSize = 5 * 1024 * 1024;
    if (file.size > maxSize) {
      console.warn(`Файл превышает максимальный размер: ${file.size} > ${maxSize}`);
      return false;
    }
    
    return true;
  }
  
  async submitWithProgress() {
    const formData = new FormData(this.form);
    
    // Проверяем, есть ли файлы
    let hasFiles = false;
    for (let [key, value] of formData.entries()) {
      if (value instanceof File) {
        hasFiles = true;
        break;
      }
    }
    
    if (hasFiles) {
      return await this.submitWithXHR(formData);
    } else {
      return await this.submitWithFetch(formData);
    }
  }
}
```

### Отправка данных с геолокацией

```javascript
async function submitFormWithLocation(form) {
  const data = new FormData(form);
  
  try {
    // Получаем геолокацию пользователя
    const position = await getCurrentPosition();
    
    // Добавляем координаты к данным формы
    data.append('latitude', position.coords.latitude);
    data.append('longitude', position.coords.longitude);
    data.append('accuracy', position.coords.accuracy);
  } catch (error) {
    console.warn('Не удалось получить геолокацию:', error.message);
    // Продолжаем отправку без геолокации
  }
  
  // Отправляем форму
  const response = await fetch('/api/submit-with-location', {
    method: 'POST',
    body: data
  });
  
  return response.json();
}

function getCurrentPosition() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Геолокация не поддерживается'));
      return;
    }
    
    navigator.geolocation.getCurrentPosition(resolve, reject, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 300000 // 5 минут
    });
  });
}
```

## Обработка ошибок и откаты

### Повторная отправка при ошибках сети

```javascript
class ResilientFormSubmitter extends FormSubmitter {
  constructor(form, options = {}) {
    super(form);
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelay || 1000;
  }
  
  async submitWithRetry(formData, attempt = 1) {
    try {
      const response = await fetch(this.form.getAttribute('action') || '/api/submit', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      if (attempt < this.maxRetries && this.isNetworkError(error)) {
        console.warn(`Попытка ${attempt} не удалась, повтор через ${this.retryDelay}мс`);
        
        // Ждем перед повторной попыткой
        await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempt));
        
        // Увеличиваем задержку для следующей попытки
        return await this.submitWithRetry(formData, attempt + 1);
      }
      
      throw error;
    }
  }
  
  isNetworkError(error) {
    return error.name === 'TypeError' || 
           error.message.includes('network') || 
           error.message.includes('fetch');
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    this.showLoadingState();
    
    try {
      const formData = new FormData(this.form);
      const result = await this.submitWithRetry(formData);
      
      this.handleSuccess(result);
    } catch (error) {
      this.handleError(error);
    } finally {
      this.hideLoadingState();
    }
  }
}
```

### Оптимистичные обновления

```javascript
class OptimisticFormSubmitter extends FormSubmitter {
  constructor(form, options = {}) {
    super(form);
    this.optimisticUpdates = options.optimisticUpdates || {};
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    // Сохраняем текущее состояние для возможного отката
    const originalState = this.saveFormState();
    
    // Применяем оптимистичные изменения
    this.applyOptimisticUpdates();
    
    this.showLoadingState();
    
    try {
      const formData = new FormData(this.form);
      const result = await fetch(this.form.getAttribute('action') || '/api/submit', {
        method: 'POST',
        body: formData
      });
      
      if (!result.ok) {
        throw new Error(`HTTP error! status: ${result.status}`);
      }
      
      const data = await result.json();
      this.handleSuccess(data);
    } catch (error) {
      // Откатываем оптимистичные изменения при ошибке
      this.rollbackOptimisticUpdates(originalState);
      this.handleError(error);
    } finally {
      this.hideLoadingState();
    }
  }
  
  saveFormState() {
    const state = {};
    const inputs = this.form.querySelectorAll('input, select, textarea');
    
    inputs.forEach(input => {
      if (input.type !== 'file') { // Файлы не сохраняем
        state[input.name] = input.value;
      }
    });
    
    return state;
  }
  
  applyOptimisticUpdates() {
    // Применяем оптимистичные изменения к DOM
    Object.keys(this.optimisticUpdates).forEach(fieldName => {
      const field = this.form.querySelector(`[name="${fieldName}"]`);
      if (field) {
        const updateFn = this.optimisticUpdates[fieldName];
        if (typeof updateFn === 'function') {
          updateFn(field);
        }
      }
    });
  }
  
  rollbackOptimisticUpdates(originalState) {
    // Восстанавливаем оригинальное состояние
    Object.keys(originalState).forEach(fieldName => {
      const field = this.form.querySelector(`[name="${fieldName}"]`);
      if (field) {
        field.value = originalState[fieldName];
      }
    });
  }
}

// Пример использования с оптимистичными обновлениями
const optimisticSubmitter = new OptimisticFormSubmitter(
  document.getElementById('commentForm'),
  {
    optimisticUpdates: {
      comment: (field) => {
        // Показываем, что комментарий "уже отправлен"
        field.disabled = true;
        field.style.opacity = '0.6';
      }
    }
  }
);
```

## Российские особенности отправки данных

### Работа с российскими форматами и требованиями

```javascript
class RussianFormSubmitter extends FormSubmitter {
  constructor(form) {
    super(form);
    this.initRussianSpecifics();
  }
  
  initRussianSpecifics() {
    // Проверка на соответствие ФЗ-152 (персональные данные)
    this.form.addEventListener('submit', this.validatePersonalData.bind(this));
  }
  
  validatePersonalData(e) {
    // Проверка согласия на обработку персональных данных
    const consentCheckbox = this.form.querySelector('input[name="personal_data_consent"][type="checkbox"]');
    
    if (consentCheckbox && !consentCheckbox.checked) {
      e.preventDefault();
      this.showMessage('Необходимо дать согласие на обработку персональных данных', 'error');
      consentCheckbox.focus();
      return false;
    }
    
    // Проверка специфических полей (ИНН, ОГРН и т.д.)
    const innField = this.form.querySelector('input[data-type="inn"]');
    if (innField && innField.value && !this.validateINN(innField.value)) {
      e.preventDefault();
      this.showMessage('Некорректный ИНН', 'error');
      innField.focus();
      return false;
    }
    
    return true;
  }
  
  validateINN(inn) {
    if (!/^\d{10}$|^\d{12}$/.test(inn)) {
      return false;
    }

    const innArr = inn.split('').map(Number);
    
    if (inn.length === 10) {
      const checkDigit = (2 * innArr[0] + 4 * innArr[1] + 10 * innArr[2] + 
                         3 * innArr[3] + 5 * innArr[4] + 9 * innArr[5] + 
                         4 * innArr[6] + 6 * innArr[7] + 8 * innArr[8]) % 11 % 10;
      return checkDigit === innArr[9];
    } else {
      const checkDigits = [
        (7 * innArr[0] + 2 * innArr[1] + 4 * innArr[2] + 10 * innArr[3] + 
         3 * innArr[4] + 5 * innArr[5] + 9 * innArr[6] + 4 * innArr[7] + 
         6 * innArr[8] + 8 * innArr[9]) % 11 % 10,
        (3 * innArr[0] + 7 * innArr[1] + 2 * innArr[2] + 4 * innArr[3] + 
         10 * innArr[4] + 3 * innArr[5] + 5 * innArr[6] + 9 * innArr[7] + 
         4 * innArr[8] + 6 * innArr[9] + 8 * innArr[10]) % 11 % 10
      ];
      
      return checkDigits[0] === innArr[10] && checkDigits[1] === innArr[11];
    }
  }
  
  async handleSubmit(e) {
    if (!this.validatePersonalData(e)) {
      return; // Останавливаем отправку при ошибках валидации
    }
    
    // Добавляем российские специфические заголовки
    const formData = new FormData(this.form);
    
    // Добавляем информацию о локали
    formData.append('locale', 'ru-RU');
    formData.append('timezone_offset', new Date().getTimezoneOffset());
    
    // Продолжаем стандартную отправку
    await super.handleSubmit(e);
  }
}
```

### Отправка данных с поддержкой кириллицы

```javascript
// Универсальная функция для корректной отправки данных с кириллицей
async function submitFormDataWithCyrillic(form) {
  const formData = new FormData(form);
  
  // Проверяем, есть ли в данных кириллические символы
  const hasCyrillic = Array.from(formData.values()).some(value => 
    typeof value === 'string' && /[а-яё]/i.test(value)
  );
  
  if (hasCyrillic) {
    // Если есть кириллица, конвертируем в объект и затем в JSON
    const data = Object.fromEntries(formData.entries());
    
    return await fetch(form.action, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json; charset=utf-8'
      },
      body: JSON.stringify(data, null, 2) // Форматируем для лучшей читаемости
    });
  } else {
    // Если только латиница, можно использовать FormData напрямую
    return await fetch(form.action, {
      method: 'POST',
      body: formData
    });
  }
}
```

## Практические примеры

### Регистрация пользователя с валидацией

```javascript
class UserRegistrationForm {
  constructor(form) {
    this.form = form;
    this.init();
  }
  
  init() {
    this.form.addEventListener('submit', this.handleSubmit.bind(this));
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    // Показываем индикатор загрузки
    this.setLoadingState(true);
    
    try {
      // Собираем данные формы
      const userData = this.collectFormData();
      
      // Валидируем данные на клиенте
      const validation = this.validateUserData(userData);
      if (!validation.isValid) {
        this.showValidationErrors(validation.errors);
        return;
      }
      
      // Отправляем данные на сервер
      const response = await this.sendUserData(userData);
      
      if (response.success) {
        this.handleRegistrationSuccess(response.data);
      } else {
        this.handleRegistrationError(response.error);
      }
    } catch (error) {
      this.handleRegistrationError(error);
    } finally {
      this.setLoadingState(false);
    }
  }
  
  collectFormData() {
    const formData = new FormData(this.form);
    const data = Object.fromEntries(formData.entries());
    
    // Обработка специфических полей
    data.birthDate = data.birthDate ? new Date(data.birthDate) : null;
    data.phone = data.phone ? data.phone.replace(/\D/g, '') : '';
    data.acceptTerms = formData.get('acceptTerms') === 'on';
    
    return data;
  }
  
  validateUserData(data) {
    const errors = {};
    
    // Валидация email
    if (!data.email || !this.isValidEmail(data.email)) {
      errors.email = 'Пожалуйста, введите корректный email';
    }
    
    // Валидация пароля
    if (!data.password || data.password.length < 8) {
      errors.password = 'Пароль должен содержать минимум 8 символов';
    }
    
    // Проверка совпадения паролей
    if (data.password !== data.confirmPassword) {
      errors.confirmPassword = 'Пароли не совпадают';
    }
    
    // Проверка согласия с условиями
    if (!data.acceptTerms) {
      errors.acceptTerms = 'Необходимо принять условия использования';
    }
    
    // Валидация телефона
    if (data.phone && !this.isValidRussianPhone(data.phone)) {
      errors.phone = 'Пожалуйста, введите корректный российский номер телефона';
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }
  
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  isValidRussianPhone(phone) {
    // Проверка российского формата телефона (11 цифр, начинающихся с 7 или 8)
    const phoneRegex = /^(7|8)\d{10}$/;
    return phoneRegex.test(phone);
  }
  
  async sendUserData(userData) {
    // Удаляем confirmPassword из данных перед отправкой
    const { confirmPassword, ...sendData } = userData;
    
    const response = await fetch('/api/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(sendData)
    });
    
    return await response.json();
  }
  
  showValidationErrors(errors) {
    // Очищаем предыдущие ошибки
    this.clearErrors();
    
    // Показываем ошибки для каждого поля
    Object.keys(errors).forEach(fieldName => {
      const field = this.form.querySelector(`[name="${fieldName}"]`);
      if (field) {
        this.highlightFieldError(field, errors[fieldName]);
      }
    });
  }
  
  highlightFieldError(field, message) {
    field.classList.add('error');
    field.setAttribute('aria-invalid', 'true');
    
    // Создаем элемент с сообщением об ошибке
    let errorElement = field.parentNode.querySelector('.field-error');
    if (!errorElement) {
      errorElement = document.createElement('div');
      errorElement.className = 'field-error error-message';
      field.parentNode.appendChild(errorElement);
    }
    
    errorElement.textContent = message;
  }
  
  clearErrors() {
    const errorElements = this.form.querySelectorAll('.field-error');
    errorElements.forEach(el => el.remove());
    
    const errorFields = this.form.querySelectorAll('.error');
    errorFields.forEach(field => {
      field.classList.remove('error');
      field.setAttribute('aria-invalid', 'false');
    });
  }
  
  setLoadingState(loading) {
    const submitButton = this.form.querySelector('button[type="submit"]');
    if (submitButton) {
      submitButton.disabled = loading;
      submitButton.textContent = loading ? 'Регистрация...' : 'Зарегистрироваться';
    }
  }
  
  handleRegistrationSuccess(data) {
    this.showMessage('Регистрация прошла успешно! Проверьте ваш email для подтверждения.', 'success');
    
    // Перенаправление или другие действия после успешной регистрации
    setTimeout(() => {
      window.location.href = data.redirectUrl || '/dashboard';
    }, 3000);
  }
  
  handleRegistrationError(error) {
    const errorMessage = error.message || 'Произошла ошибка при регистрации. Пожалуйста, попробуйте еще раз.';
    this.showMessage(errorMessage, 'error');
  }
  
  showMessage(text, type) {
    // Создаем сообщение
    const messageEl = document.createElement('div');
    messageEl.className = `form-message form-message-${type}`;
    messageEl.textContent = text;
    messageEl.setAttribute('role', 'alert');
    
    // Добавляем перед формой
    this.form.parentNode.insertBefore(messageEl, this.form);
    
    // Автоматическое удаление
    setTimeout(() => messageEl.remove(), 5000);
  }
}

// Использование класса для формы регистрации
const registrationForm = new UserRegistrationForm(document.getElementById('registrationForm'));
```

## Лучшие практики

1. **Всегда обрабатывайте ошибки** - показывайте пользователю понятные сообщения
2. **Используйте индикацию загрузки** - улучшает восприятие скорости работы
3. **Реализуйте повторные попытки** для сетевых ошибок
4. **Сохраняйте данные формы** при ошибках, чтобы пользователю не приходилось вводить заново
5. **Используйте CSRF-токены** для защиты от межсайтовой подделки запросов
6. **Валидируйте данные как на клиенте, так и на сервере**

> [!tip] 
> При отправке форм всегда комбинируйте клиентскую и серверную валидацию. Клиентская улучшает UX, а серверная обеспечивает безопасность.

См. также: [[Валидация-форм]], [[Работа-с-полями-ввода]], [[Обработка-событий-форм]], [[Валидация-на-стороне-клиента]]