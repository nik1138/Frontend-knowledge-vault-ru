---
aliases: ["Валидация на стороне клиента", "Client-side Validation", "Клиентская валидация"]
tags: [javascript, forms, validation, frontend, security]
---

# Валидация на стороне клиента в JavaScript

## Обзор

Валидация на стороне клиента - это процесс проверки пользовательского ввода в браузере до отправки данных на сервер. В 2025 году клиентская валидация играет важную роль в обеспечении удобства пользователя, улучшении UX и снижении нагрузки на сервер, при этом она не должна заменять серверную валидацию, а дополнять её.

## Принципы клиентской валидации

### Основные цели

- **Улучшение UX**: Быстрая обратная связь пользователю
- **Снижение нагрузки на сервер**: Отсев очевидных ошибок до отправки
- **Экономия трафика**: Предотвращение отправки заведомо некорректных данных
- **Повышение доступности**: Четкие инструкции для пользователей

### Ограничения клиентской валидации

- **Не обеспечивает безопасность** - данные могут быть изменены
- **Зависит от JavaScript** - не работает при отключенном JS
- **Может быть обойдена** - не является надежной защитой

## Встроенные механизмы HTML5

### Атрибуты валидации

```html
<form id="userForm">
  <div class="form-group">
    <label for="email">Электронная почта:</label>
    <input 
      type="email" 
      id="email" 
      name="email" 
      required 
      placeholder="user@example.com"
      pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
    >
  </div>
  
  <div class="form-group">
    <label for="password">Пароль:</label>
    <input 
      type="password" 
      id="password" 
      name="password" 
      required 
      minlength="8"
      maxlength="128"
      placeholder="Минимум 8 символов"
    >
  </div>
  
  <div class="form-group">
    <label for="age">Возраст:</label>
    <input 
      type="number" 
      id="age" 
      name="age" 
      required 
      min="18" 
      max="120"
    >
  </div>
  
  <div class="form-group">
    <label for="website">Веб-сайт:</label>
    <input 
      type="url" 
      id="website" 
      name="website" 
      placeholder="https://example.com"
    >
  </div>
  
  <button type="submit">Отправить</button>
</form>
```

### Использование Constraint Validation API

```javascript
const form = document.getElementById('userForm');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const ageInput = document.getElementById('age');

// Проверка валидности формы
function isFormValid() {
  return form.checkValidity();
}

// Проверка конкретного поля
function isFieldValid(field) {
  return field.checkValidity();
}

// Отображение встроенных сообщений об ошибках
function showBuiltInErrors() {
  form.querySelectorAll('input, select, textarea').forEach(field => {
    if (!field.validity.valid) {
      field.reportValidity();
    }
  });
}

// Настройка пользовательских сообщений об ошибках
function setupCustomErrorMessages() {
  emailInput.addEventListener('invalid', function(e) {
    if (this.validity.valueMissing) {
      this.setCustomValidity('Пожалуйста, введите ваш email');
    } else if (this.validity.typeMismatch) {
      this.setCustomValidity('Пожалуйста, введите корректный email адрес');
    } else {
      this.setCustomValidity('');
    }
  });

  passwordInput.addEventListener('invalid', function(e) {
    if (this.validity.valueMissing) {
      this.setCustomValidity('Пожалуйста, введите пароль');
    } else if (this.validity.tooShort) {
      this.setCustomValidity(`Пароль должен содержать минимум ${this.minLength} символов`);
    } else {
      this.setCustomValidity('');
    }
  });

  ageInput.addEventListener('invalid', function(e) {
    if (this.validity.valueMissing) {
      this.setCustomValidity('Пожалуйста, укажите ваш возраст');
    } else if (this.validity.rangeUnderflow) {
      this.setCustomValidity(`Возраст должен быть не менее ${this.min} лет`);
    } else if (this.validity.rangeOverflow) {
      this.setCustomValidity(`Возраст должен быть не более ${this.max} лет`);
    } else {
      this.setCustomValidity('');
    }
  });
}

setupCustomErrorMessages();

// Обработка отправки формы
form.addEventListener('submit', function(e) {
  if (!isFormValid()) {
    e.preventDefault();
    showBuiltInErrors();
  }
});
```

## Кастомная валидация

### Простая система валидации

```javascript
class ClientValidator {
  constructor() {
    this.rules = new Map();
    this.messages = new Map();
  }
  
  // Добавление правила валидации
  addRule(fieldName, validator, message) {
    if (!this.rules.has(fieldName)) {
      this.rules.set(fieldName, []);
    }
    this.rules.get(fieldName).push({
      validator,
      message
    });
  }
  
  // Установка пользовательского сообщения
  setMessage(fieldName, ruleName, message) {
    if (!this.messages.has(fieldName)) {
      this.messages.set(fieldName, new Map());
    }
    this.messages.get(fieldName).set(ruleName, message);
  }
  
  // Валидация конкретного поля
  validateField(fieldName, value) {
    const errors = [];
    const rules = this.rules.get(fieldName) || [];
    
    for (const rule of rules) {
      if (!rule.validator(value)) {
        const customMessage = this.messages.has(fieldName) && 
                             this.messages.get(fieldName).get(rule.constructor.name) ||
                             rule.message;
        errors.push(customMessage);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  // Валидация всей формы
  validateForm(data) {
    const results = {};
    let isFormValid = true;
    
    for (const [fieldName, rules] of this.rules) {
      const result = this.validateField(fieldName, data[fieldName]);
      results[fieldName] = result;
      if (!result.isValid) {
        isFormValid = false;
      }
    }
    
    return {
      isValid: isFormValid,
      fieldResults: results
    };
  }
}

// Создание экземпляра валидатора
const validator = new ClientValidator();

// Добавление правил валидации
validator.addRule('email', 
  (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value), 
  'Пожалуйста, введите корректный email'
);

validator.addRule('email', 
  (value) => value && value.length <= 254, 
  'Email слишком длинный'
);

validator.addRule('password', 
  (value) => value && value.length >= 8, 
  'Пароль должен содержать минимум 8 символов'
);

validator.addRule('password', 
  (value) => /(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value), 
  'Пароль должен содержать заглавную букву, строчную букву и цифру'
);

validator.addRule('age', 
  (value) => value && !isNaN(value) && value >= 18 && value <= 120, 
  'Возраст должен быть от 18 до 120 лет'
);

validator.addRule('phone', 
  (value) => /^(\+7|8)[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/.test(value), 
  'Пожалуйста, введите корректный российский номер телефона'
);
```

### Интеграция с DOM

```javascript
class FormValidator {
  constructor(formSelector, validator) {
    this.form = document.querySelector(formSelector);
    this.validator = validator;
    this.fields = new Map();
    this.init();
  }
  
  init() {
    // Собираем все поля формы
    const inputs = this.form.querySelectorAll('input, select, textarea');
    
    inputs.forEach(input => {
      this.fields.set(input.name, input);
      
      // Добавляем обработчики событий
      input.addEventListener('blur', () => this.validateField(input.name));
      input.addEventListener('input', () => this.clearFieldError(input.name));
    });
    
    // Обработчик отправки формы
    this.form.addEventListener('submit', this.handleSubmit.bind(this));
  }
  
  validateField(fieldName) {
    const field = this.fields.get(fieldName);
    if (!field) return;
    
    const result = this.validator.validateField(fieldName, field.value);
    
    if (!result.isValid) {
      this.showFieldErrors(field, result.errors);
    } else {
      this.clearFieldError(fieldName);
    }
    
    return result.isValid;
  }
  
  showFieldErrors(field, errors) {
    field.classList.add('error');
    field.setAttribute('aria-invalid', 'true');
    
    // Удаляем предыдущие сообщения об ошибках
    this.clearFieldError(field.name);
    
    // Создаем контейнер для ошибок
    const errorContainer = document.createElement('div');
    errorContainer.className = 'field-errors';
    errorContainer.setAttribute('role', 'alert');
    
    // Добавляем все сообщения об ошибках
    errors.forEach(error => {
      const errorElement = document.createElement('div');
      errorElement.className = 'error-message';
      errorElement.textContent = error;
      errorContainer.appendChild(errorElement);
    });
    
    // Вставляем после поля
    field.parentNode.insertBefore(errorContainer, field.nextSibling);
  }
  
  clearFieldError(fieldName) {
    const field = this.fields.get(fieldName);
    if (!field) return;
    
    field.classList.remove('error');
    field.setAttribute('aria-invalid', 'false');
    
    // Удаляем сообщения об ошибках
    const errorContainer = field.parentNode.querySelector('.field-errors');
    if (errorContainer) {
      errorContainer.remove();
    }
  }
  
  async handleSubmit(e) {
    e.preventDefault();
    
    // Валидируем все поля
    let isFormValid = true;
    for (const fieldName of this.fields.keys()) {
      if (!this.validateField(fieldName)) {
        isFormValid = false;
      }
    }
    
    if (isFormValid) {
      // Форма валидна, можно отправлять
      await this.submitForm();
    } else {
      // Фокус на первое поле с ошибкой
      const firstErrorField = this.form.querySelector('.error');
      if (firstErrorField) {
        firstErrorField.focus();
      }
    }
  }
  
  async submitForm() {
    const formData = new FormData(this.form);
    const data = Object.fromEntries(formData.entries());
    
    try {
      // Показываем индикатор загрузки
      this.setLoadingState(true);
      
      // Отправляем данные
      const response = await fetch('/api/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      });
      
      const result = await response.json();
      
      if (result.success) {
        this.handleSuccess(result);
      } else {
        this.handleError(result);
      }
    } catch (error) {
      this.handleError({ message: 'Произошла ошибка при отправке формы' });
    } finally {
      this.setLoadingState(false);
    }
  }
  
  setLoadingState(loading) {
    const submitButton = this.form.querySelector('button[type="submit"]');
    if (submitButton) {
      submitButton.disabled = loading;
      submitButton.textContent = loading ? 'Отправка...' : 'Отправить';
    }
  }
  
  handleSuccess(result) {
    // Показываем сообщение об успехе
    this.showMessage('Форма успешно отправлена!', 'success');
    
    // Очищаем форму
    this.form.reset();
  }
  
  handleError(error) {
    this.showMessage(error.message || 'Произошла ошибка', 'error');
  }
  
  showMessage(text, type) {
    // Создаем сообщение
    const messageEl = document.createElement('div');
    messageEl.className = `form-message form-message-${type}`;
    messageEl.textContent = text;
    messageEl.setAttribute('role', 'alert');
    
    // Вставляем перед формой
    this.form.parentNode.insertBefore(messageEl, this.form);
    
    // Автоматическое удаление через 5 секунд
    setTimeout(() => messageEl.remove(), 5000);
  }
}

// Использование валидатора
const formValidator = new FormValidator('#userForm', validator);
```

## Продвинутые техники валидации

### Валидация с зависимостями между полями

```javascript
class AdvancedValidator extends ClientValidator {
  constructor() {
    super();
    this.dependencyRules = new Map();
  }
  
  // Добавление правила, зависящего от других полей
  addDependencyRule(fieldName, dependentFields, validator, message) {
    if (!this.dependencyRules.has(fieldName)) {
      this.dependencyRules.set(fieldName, []);
    }
    
    this.dependencyRules.get(fieldName).push({
      dependentFields: Array.isArray(dependentFields) ? dependentFields : [dependentFields],
      validator,
      message
    });
  }
  
  // Валидация с учетом зависимостей
  validateForm(data) {
    const basicResult = super.validateForm(data);
    
    // Проверяем зависимости
    for (const [fieldName, dependencyRules] of this.dependencyRules) {
      for (const rule of dependencyRules) {
        // Проверяем, все ли зависимые поля присутствуют
        const dependentValues = {};
        let allPresent = true;
        
        for (const depField of rule.dependentFields) {
          if (data.hasOwnProperty(depField)) {
            dependentValues[depField] = data[depField];
          } else {
            allPresent = false;
            break;
          }
        }
        
        if (allPresent) {
          const isValid = rule.validator(data[fieldName], dependentValues);
          
          if (!isValid) {
            if (!basicResult.fieldResults[fieldName]) {
              basicResult.fieldResults[fieldName] = { isValid: false, errors: [] };
            }
            
            basicResult.fieldResults[fieldName].errors.push(rule.message);
            basicResult.fieldResults[fieldName].isValid = false;
            basicResult.isValid = false;
          }
        }
      }
    }
    
    return basicResult;
  }
}

// Пример использования зависимостей
const advancedValidator = new AdvancedValidator();

// Добавляем базовые правила
advancedValidator.addRule('password', 
  (value) => value && value.length >= 8, 
  'Пароль должен содержать минимум 8 символов'
);

// Правило проверки совпадения паролей
advancedValidator.addDependencyRule('confirmPassword', 'password', 
  (confirmPassword, dependentValues) => confirmPassword === dependentValues.password,
  'Пароли не совпадают'
);

// Правило проверки возраста в зависимости от страны
advancedValidator.addDependencyRule('age', 'country', 
  (age, dependentValues) => {
    if (dependentValues.country === 'RU') {
      return age >= 18 && age <= 120; // В России 18+
    } else if (dependentValues.country === 'US') {
      return age >= 21 && age <= 120; // В США 21+
    }
    return age >= 18 && age <= 120; // По умолчанию 18+
  },
  'Недостаточный возраст для выбранной страны'
);
```

### Асинхронная валидация

```javascript
class AsyncValidator {
  constructor() {
    this.asyncRules = new Map();
    this.debounceTimers = new Map();
  }
  
  // Добавление асинхронного правила валидации
  addAsyncRule(fieldName, validator, message, debounceMs = 500) {
    if (!this.asyncRules.has(fieldName)) {
      this.asyncRules.set(fieldName, []);
    }
    
    this.asyncRules.get(fieldName).push({
      validator,
      message,
      debounceMs
    });
  }
  
  // Валидация поля с асинхронными правилами
  async validateFieldAsync(fieldName, value, showErrors = true) {
    const rules = this.asyncRules.get(fieldName);
    if (!rules || rules.length === 0) {
      return { isValid: true, errors: [] };
    }
    
    // Очищаем предыдущий таймер дебаунса
    if (this.debounceTimers.has(fieldName)) {
      clearTimeout(this.debounceTimers.get(fieldName));
    }
    
    return new Promise((resolve) => {
      const longestDebounce = Math.max(...rules.map(r => r.debounceMs));
      
      this.debounceTimers.set(fieldName, setTimeout(async () => {
        const errors = [];
        
        for (const rule of rules) {
          try {
            const isValid = await rule.validator(value);
            if (!isValid) {
              errors.push(rule.message);
            }
          } catch (error) {
            console.error(`Ошибка асинхронной валидации для поля ${fieldName}:`, error);
            errors.push('Ошибка проверки поля');
          }
        }
        
        resolve({
          isValid: errors.length === 0,
          errors
        });
      }, longestDebounce));
    });
  }
  
  // Проверка уникальности email
  async validateEmailUniqueness(email) {
    if (!email) return true;
    
    try {
      const response = await fetch(`/api/check-email?email=${encodeURIComponent(email)}`);
      const result = await response.json();
      return result.isUnique;
    } catch (error) {
      console.error('Ошибка проверки уникальности email:', error);
      // При ошибке запроса считаем поле валидным, чтобы не блокировать пользователя
      return true;
    }
  }
  
  // Проверка существования домена
  async validateDomainExists(domain) {
    if (!domain) return true;
    
    try {
      const response = await fetch(`/api/check-domain?domain=${encodeURIComponent(domain)}`);
      const result = await response.json();
      return result.exists;
    } catch (error) {
      console.error('Ошибка проверки домена:', error);
      return true;
    }
  }
}

// Использование асинхронного валидатора
const asyncValidator = new AsyncValidator();

// Добавление асинхронных правил
asyncValidator.addAsyncRule('email', 
  (email) => asyncValidator.validateEmailUniqueness(email),
  'Этот email уже используется',
  800 // дебаунс 800мс
);

asyncValidator.addAsyncRule('companyDomain', 
  (domain) => asyncValidator.validateDomainExists(domain),
  'Домен не существует или недоступен',
  1000 // дебаунс 1с
);
```

## Российские особенности валидации

### Валидация российских данных

```javascript
class RussianValidator {
  constructor() {
    this.validators = {
      inn: this.validateINN.bind(this),
      ogrn: this.validateOGRN.bind(this),
      snils: this.validateSNILS.bind(this),
      kpp: this.validateKPP.bind(this),
      phone: this.validateRussianPhone.bind(this),
      bankAccount: this.validateBankAccount.bind(this),
      corrAccount: this.validateCorrAccount.bind(this),
      bic: this.validateBIC.bind(this)
    };
  }
  
  // Валидация ИНН
  validateINN(inn) {
    if (!inn || !/^\d{10}$|^\d{12}$/.test(inn)) {
      return false;
    }

    const innArr = inn.split('').map(Number);
    
    if (inn.length === 10) {
      // Проверка для юридических лиц
      const checkDigit = (2 * innArr[0] + 4 * innArr[1] + 10 * innArr[2] + 
                         3 * innArr[3] + 5 * innArr[4] + 9 * innArr[5] + 
                         4 * innArr[6] + 6 * innArr[7] + 8 * innArr[8]) % 11 % 10;
      return checkDigit === innArr[9];
    } else {
      // Проверка для физических лиц
      const checkDigits = [
        (7 * innArr[0] + 2 * innArr[1] + 4 * innArr[2] + 10 * innArr[3] + 
         3 * innArr[4] + 5 * innArr[5] + 9 * innArr[6] + 4 * innArr[7] + 
         6 * innArr[8] + 8 * innArr[9]) % 11 % 10,
        (3 * innArr[0] + 7 * innArr[1] + 2 * innArr[2] + 4 * innArr[3] + 
         10 * innArr[4] + 3 * innArr[5] + 5 * innArr[6] + 9 * innArr[7] + 
         4 * innArr[8] + 6 * innArr[9] + 8 * innArr[10]) % 11 % 10
      ];
      
      return checkDigits[0] === innArr[10] && checkDigits[1] === innArr[11];
    }
  }
  
  // Валидация ОГРН
  validateOGRN(ogrn) {
    if (!ogrn || !/^\d{13}$/.test(ogrn)) return false;
    
    const checkDigit = parseInt(ogrn.substring(0, 12)) % 11 % 10;
    return checkDigit === parseInt(ogrn[12]);
  }
  
  // Валидация СНИЛС
  validateSNILS(snils) {
    if (!snils || !/^\d{11}$/.test(snils.replace(/\D/g, ''))) return false;
    
    const cleaned = snils.replace(/\D/g, '');
    const checkSum = parseInt(cleaned.substring(9, 11));
    const sum = cleaned.substring(0, 9).split('').reverse()
      .map((digit, index) => parseInt(digit) * (9 - index))
      .reduce((acc, val) => acc + val, 0);
    
    const calculatedCheckSum = sum % 101;
    const expectedCheckSum = calculatedCheckSum === 100 ? 0 : calculatedCheckSum;
    
    return expectedCheckSum === checkSum;
  }
  
  // Валидация КПП
  validateKPP(kpp) {
    return /^\d{4}[\dA-Z]{2}\d{3}$/.test(kpp);
  }
  
  // Валидация российского телефона
  validateRussianPhone(phone) {
    // Удаляем все нецифровые символы
    const cleaned = phone.replace(/\D/g, '');
    
    // Проверяем разные форматы российского номера
    if (cleaned.length === 11) {
      // Формат: 8XXXXXXXXXX или 7XXXXXXXXXX
      return /^(7|8)\d{10}$/.test(cleaned);
    } else if (cleaned.length === 10) {
      // Формат: XXXXXXXXXX (без кода страны)
      return /^\d{10}$/.test(cleaned);
    }
    
    return false;
  }
  
  // Валидация банковского счета
  validateBankAccount(account) {
    if (!account || !/^\d{20}$/.test(account)) return false;
    
    // Проверка контрольного числа банковского счета
    const bik = account.substring(0, 1); // В реальности БИК должен быть известен отдельно
    const checkDigit = (account.substring(13, 15) + account.substring(0, 13) + account.substring(15)).split('').map(Number);
    
    // Упрощенный алгоритм (в реальности используется более сложная логика)
    return true;
  }
  
  // Валидация корреспондентского счета
  validateCorrAccount(corrAccount) {
    return /^\d{20}$/.test(corrAccount);
  }
  
  // Валидация БИК
  validateBIC(bic) {
    return /^\d{9}$/.test(bic);
  }
  
  // Валидация паспортных данных
  validatePassport(passport) {
    // Паспорт: XXXX XXXXXX (4 цифры, пробел, 6 цифр)
    return /^\d{4} \d{6}$/.test(passport);
  }
  
  // Валидация серии и номера паспорта
  validatePassportSeriesNumber(seriesNumber) {
    // Формат: XXXX XXXXXX
    return /^\d{4}[ ]{0,1}\d{6}$/.test(seriesNumber.trim());
  }
  
  // Комплексная валидация юридического лица
  validateLegalEntity(data) {
    const errors = {};
    
    if (!this.validateINN(data.inn)) {
      errors.inn = 'Некорректный ИНН';
    }
    
    if (data.kpp && !this.validateKPP(data.kpp)) {
      errors.kpp = 'Некорректный КПП';
    }
    
    if (!this.validateOGRN(data.ogrn)) {
      errors.ogrn = 'Некорректный ОГРН';
    }
    
    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }
}

// Использование российского валидатора
const russianValidator = new RussianValidator();

// Интеграция с основным валидатором
validator.addRule('inn', 
  (value) => russianValidator.validateINN(value), 
  'Пожалуйста, введите корректный ИНН'
);

validator.addRule('ogrn', 
  (value) => russianValidator.validateOGRN(value), 
  'Пожалуйста, введите корректный ОГРН'
);

validator.addRule('snils', 
  (value) => russianValidator.validateSNILS(value), 
  'Пожалуйста, введите корректный СНИЛС'
);

validator.addRule('phone', 
  (value) => russianValidator.validateRussianPhone(value), 
  'Пожалуйста, введите корректный российский номер телефона'
);
```

### Работа с российскими регулярными выражениями

```javascript
class RussianRegexValidator {
  static patterns = {
    // Номер телефона в различных форматах
    phone: /^(\+7|8)[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/,
    
    // ИНН (10 или 12 цифр)
    inn: /^\d{10}$|^\d{12}$/,
    
    // ОГРН (13 цифр)
    ogrn: /^\d{13}$/,
    
    // СНИЛС (XXX-XXX-XXX XX)
    snils: /^\d{3}-\d{3}-\d{3}\s\d{2}$/,
    
    // КПП (4 цифры, 2 буквы/цифры, 3 цифры)
    kpp: /^\d{4}[\dA-Z]{2}\d{3}$/,
    
    // Серия и номер паспорта (XXXX XXXXXX)
    passport: /^\d{4}[ ]{0,1}\d{6}$/,
    
    // Банковский счет (20 цифр)
    bankAccount: /^\d{20}$/,
    
    // Корреспондентский счет (20 цифр)
    corrAccount: /^\d{20}$/,
    
    // БИК (9 цифр)
    bic: /^\d{9}$/,
    
    // Почтовый индекс (6 цифр)
    postalCode: /^\d{6}$/,
    
    // Региональный код (2 цифры)
    regionCode: /^\d{2}$/
  };
  
  static validate(fieldName, value) {
    const pattern = this.patterns[fieldName];
    if (!pattern) {
      return false;
    }
    
    return pattern.test(value);
  }
  
  // Валидация с нормализацией ввода
  static validateWithNormalization(fieldName, value) {
    let normalizedValue = value;
    
    switch (fieldName) {
      case 'phone':
        // Нормализация телефонного номера
        normalizedValue = this.normalizePhone(value);
        break;
      case 'snils':
        // Нормализация СНИЛС
        normalizedValue = this.normalizeSNILS(value);
        break;
      case 'passport':
        // Нормализация паспортных данных
        normalizedValue = this.normalizePassport(value);
        break;
    }
    
    return this.validate(fieldName, normalizedValue);
  }
  
  static normalizePhone(phone) {
    // Удаляем все нецифровые символы
    let cleaned = phone.replace(/\D/g, '');
    
    // Добавляем код страны если его нет
    if (cleaned.length === 10) {
      cleaned = '7' + cleaned;
    } else if (cleaned[0] === '8') {
      cleaned = '7' + cleaned.substring(1);
    }
    
    // Форматируем в стандартный вид
    if (cleaned.length === 11) {
      return `+7 (${cleaned.substring(1, 4)}) ${cleaned.substring(4, 7)}-${cleaned.substring(7, 9)}-${cleaned.substring(9, 11)}`;
    }
    
    return phone; // Возвращаем оригинальное значение, если нормализация не удалась
  }
  
  static normalizeSNILS(snils) {
    // Удаляем все нецифровые символы
    const cleaned = snils.replace(/\D/g, '');
    
    if (cleaned.length === 11) {
      return `${cleaned.substring(0, 3)}-${cleaned.substring(3, 6)}-${cleaned.substring(6, 9)} ${cleaned.substring(9, 11)}`;
    }
    
    return snils;
  }
  
  static normalizePassport(passport) {
    // Удаляем лишние пробелы и форматируем
    const cleaned = passport.replace(/\s+/g, '').replace(/(\d{4})(\d{6})/, '$1 $2');
    return cleaned;
  }
}
```

## Современные библиотеки валидации

### Сравнение популярных библиотек

```javascript
// Пример с Yup (одна из популярных библиотек валидации)
/*
import * as yup from 'yup';

const userSchema = yup.object({
  email: yup
    .string()
    .email('Некорректный email')
    .required('Email обязателен'),
  password: yup
    .string()
    .min(8, 'Пароль должен содержать минимум 8 символов')
    .required('Пароль обязателен'),
  age: yup
    .number()
    .min(18, 'Вы должны быть старше 18 лет')
    .max(120, 'Некорректный возраст')
    .required('Возраст обязателен'),
  phone: yup
    .string()
    .matches(/^(\+7|8)[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/, 'Некорректный телефон')
    .required('Телефон обязателен')
});

// Валидация
try {
  await userSchema.validate(formData, { abortEarly: false });
  // Данные валидны
} catch (validationError) {
  // Обработка ошибок валидации
  validationError.inner.forEach(error => {
    console.log(error.path, error.message);
  });
}
*/

// Пример с Zod (современная альтернатива с поддержкой TypeScript)
/*
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email('Некорректный email'),
  password: z.string().min(8, 'Пароль должен содержать минимум 8 символов'),
  age: z.number().min(18, 'Вы должны быть старше 18 лет').max(120, 'Некорректный возраст'),
  phone: z.string().regex(/^(\+7|8)[\s-]?\(?[0-9]{3}\)?[\s-]?[0-9]{3}[\s-]?[0-9]{2}[\s-]?[0-9]{2}$/, 'Некорректный телефон')
});

// Валидация
try {
  const validatedData = userSchema.parse(formData);
  // Данные валидны
} catch (error) {
  if (error instanceof z.ZodError) {
    // Обработка ошибок валидации
    error.errors.forEach(err => {
      console.log(err.path, err.message);
    });
  }
}
*/
```

## Лучшие практики

### 1. Комбинирование валидаций

```javascript
class CombinedValidator {
  constructor() {
    this.html5Validator = true; // Использовать встроенную валидацию HTML5
    this.customValidator = new ClientValidator();
    this.asyncValidator = new AsyncValidator();
    this.russianValidator = new RussianValidator();
  }
  
  // Комплексная валидация поля
  async validateField(fieldName, value, context = {}) {
    const results = {
      html5: true,
      custom: true,
      async: true,
      russian: true,
      errors: []
    };
    
    // Проверка HTML5 валидацией
    if (this.html5Validator) {
      const tempInput = document.createElement('input');
      // Устанавливаем атрибуты валидации в зависимости от типа поля
      if (fieldName.includes('email')) {
        tempInput.type = 'email';
      } else if (fieldName.includes('url')) {
        tempInput.type = 'url';
      } else if (fieldName.includes('number')) {
        tempInput.type = 'number';
      }
      
      tempInput.value = value;
      results.html5 = tempInput.checkValidity();
      
      if (!results.html5) {
        results.errors.push(this.getHTML5ErrorMessage(tempInput));
      }
    }
    
    // Проверка кастомными правилами
    const customResult = this.customValidator.validateField(fieldName, value);
    results.custom = customResult.isValid;
    if (!customResult.isValid) {
      results.errors.push(...customResult.errors);
    }
    
    // Проверка российскими правилами
    if (this.russianValidator.validators[fieldName]) {
      const russianValid = this.russianValidator.validators[fieldName](value);
      results.russian = russianValid;
      if (!russianValid) {
        results.errors.push(this.getRussianErrorMessage(fieldName));
      }
    }
    
    // Проверка асинхронными правилами
    const asyncResult = await this.asyncValidator.validateFieldAsync(fieldName, value, false);
    results.async = asyncResult.isValid;
    if (!asyncResult.isValid) {
      results.errors.push(...asyncResult.errors);
    }
    
    return {
      isValid: results.html5 && results.custom && results.async && results.russian,
      results,
      errors: results.errors
    };
  }
  
  getHTML5ErrorMessage(input) {
    if (input.validity.valueMissing) return 'Это поле обязательно';
    if (input.validity.typeMismatch) return 'Некорректный формат данных';
    if (input.validity.tooShort) return `Минимум ${input.minLength} символов`;
    if (input.validity.rangeUnderflow) return `Минимальное значение: ${input.min}`;
    if (input.validity.rangeOverflow) return `Максимальное значение: ${input.max}`;
    return 'Некорректное значение';
  }
  
  getRussianErrorMessage(fieldName) {
    const messages = {
      inn: 'Некорректный ИНН',
      ogrn: 'Некорректный ОГРН',
      snils: 'Некорректный СНИЛС',
      phone: 'Некорректный российский номер телефона'
    };
    
    return messages[fieldName] || 'Некорректные российские данные';
  }
}
```

### 2. Обработка ошибок и UX

```javascript
class UXValidator {
  constructor(form) {
    this.form = form;
    this.validator = new CombinedValidator();
    this.errorDisplay = new ErrorDisplayManager();
    this.init();
  }
  
  init() {
    // Устанавливаем обработчики для всех полей
    const fields = this.form.querySelectorAll('input, select, textarea');
    fields.forEach(field => {
      // Валидация при потере фокуса
      field.addEventListener('blur', () => this.validateField(field));
      
      // Очистка ошибки при вводе
      field.addEventListener('input', () => {
        if (field.classList.contains('error')) {
          this.errorDisplay.clearFieldError(field);
        }
      });
      
      // Валидация в реальном времени с задержкой
      if (field.dataset.validateOnInput) {
        this.setupRealTimeValidation(field);
      }
    });
  }
  
  setupRealTimeValidation(field) {
    let timeout;
    field.addEventListener('input', () => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        this.validateField(field, false); // Не показываем ошибки сразу
      }, 500);
    });
  }
  
  async validateField(field, showError = true) {
    const result = await this.validator.validateField(field.name, field.value);
    
    if (result.isValid) {
      this.errorDisplay.clearFieldError(field);
    } else if (showError) {
      this.errorDisplay.showFieldErrors(field, result.errors);
    }
    
    return result.isValid;
  }
  
  async validateForm() {
    let isFormValid = true;
    const fields = this.form.querySelectorAll('input, select, textarea');
    
    for (const field of fields) {
      const fieldValid = await this.validateField(field);
      if (!fieldValid) {
        isFormValid = false;
        if (isFormValid) { // Фокус на первом невалидном поле
          field.focus();
        }
      }
    }
    
    return isFormValid;
  }
}

class ErrorDisplayManager {
  showFieldErrors(field, errors) {
    field.classList.add('error');
    field.setAttribute('aria-invalid', 'true');
    
    // Создаем контейнер для ошибок
    let errorContainer = field.parentNode.querySelector(`.error-container-${field.name}`);
    if (!errorContainer) {
      errorContainer = document.createElement('div');
      errorContainer.className = `error-container error-container-${field.name}`;
      errorContainer.setAttribute('role', 'alert');
      field.parentNode.appendChild(errorContainer);
    }
    
    // Добавляем ошибки
    errorContainer.innerHTML = errors
      .map(error => `<div class="error-message">${error}</div>`)
      .join('');
  }
  
  clearFieldError(field) {
    field.classList.remove('error');
    field.setAttribute('aria-invalid', 'false');
    
    const errorContainer = field.parentNode.querySelector(`.error-container-${field.name}`);
    if (errorContainer) {
      errorContainer.remove();
    }
  }
}
```

## Заключение

Клиентская валидация в 2025 году должна быть многоуровневой системой, сочетающей встроенные механизмы HTML5, кастомные правила, асинхронные проверки и специфические требования (в данном случае - российские форматы данных). При этом важно помнить, что клиентская валидация не заменяет серверную, а дополняет её, улучшая UX и снижая нагрузку на сервер.

> [!tip] 
> Всегда используйте клиентскую валидацию как вспомогательный инструмент для улучшения UX. Основная валидация и безопасность должны быть реализованы на сервере.

См. также: [[Валидация-форм]], [[Работа-с-полями-ввода]], [[Обработка-событий-форм]], [[Отправка-данных]]