# События в браузере

События - это основной механизм взаимодействия с пользователем и реакцией на действия в браузере. JavaScript предоставляет мощную систему обработки событий, которая позволяет реагировать на действия пользователя, изменения состояния документа и другие события.

## Типы событий

### События мыши

```javascript
// Клик
element.addEventListener('click', function(event) {
    console.log('Клик по элементу');
});

// Двойной клик
element.addEventListener('dblclick', function(event) {
    console.log('Двойной клик');
});

// Наведение мыши
element.addEventListener('mouseenter', function(event) {
    console.log('Мышь над элементом');
});

// Уход мыши
element.addEventListener('mouseleave', function(event) {
    console.log('Мышь покинула элемент');
});

// Нажатие и отпускание кнопки мыши
element.addEventListener('mousedown', function(event) {
    console.log('Кнопка мыши нажата');
});

element.addEventListener('mouseup', function(event) {
    console.log('Кнопка мыши отпущена');
});
```

### События клавиатуры

```javascript
// Нажатие клавиши
document.addEventListener('keydown', function(event) {
    console.log('Клавиша нажата:', event.key);
    
    // Проверка специальных клавиш
    if (event.ctrlKey && event.key === 's') {
        event.preventDefault(); // Предотвратить стандартное действие
        console.log('Сохранение документа');
    }
});

// Отпускание клавиши
document.addEventListener('keyup', function(event) {
    console.log('Клавиша отпущена:', event.key);
});

// Ввод символа
inputElement.addEventListener('keypress', function(event) {
    console.log('Символ введен:', event.key);
});
```

### События формы

```javascript
// Отправка формы
formElement.addEventListener('submit', function(event) {
    event.preventDefault(); // Предотвратить стандартную отправку
    
    // Валидация и обработка
    const formData = new FormData(event.target);
    console.log('Данные формы:', Object.fromEntries(formData));
});

// Изменение значения поля
inputElement.addEventListener('input', function(event) {
    console.log('Значение изменено:', event.target.value);
});

// Изменение выбора
selectElement.addEventListener('change', function(event) {
    console.log('Выбор изменен:', event.target.value);
});

// Фокус на элементе
inputElement.addEventListener('focus', function(event) {
    console.log('Элемент получил фокус');
});

// Потеря фокуса
inputElement.addEventListener('blur', function(event) {
    console.log('Элемент потерял фокус');
});
```

### События документа и окна

```javascript
// Загрузка DOM
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM полностью загружен');
});

// Загрузка страницы
window.addEventListener('load', function() {
    console.log('Страница полностью загружена');
});

// Изменение размера окна
window.addEventListener('resize', function() {
    console.log('Размер окна изменен:', window.innerWidth, window.innerHeight);
});

// Прокрутка
window.addEventListener('scroll', function() {
    console.log('Позиция прокрутки:', window.pageYOffset);
});

// Закрытие страницы
window.addEventListener('beforeunload', function(event) {
    event.preventDefault();
    event.returnValue = 'Вы уверены, что хотите покинуть страницу?';
});
```

## Механизмы работы событий

### Цепочка событий (Event Flow)

События проходят через три фазы:
1. **Фаза захвата (Capture phase)** - событие движется от корня документа к целевому элементу
2. **Фаза всплытия (Bubbling phase)** - событие всплывает от целевого элемента к корню документа
3. **Фаза цели (Target phase)** - событие достигает целевого элемента

```javascript
// Пример демонстрации фаз событий
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Обработчик в фазе захвата
parent.addEventListener('click', function(event) {
    console.log('Фаза захвата: родитель');
}, true); // true указывает на фазу захвата

// Обработчик в фазе всплытия
parent.addEventListener('click', function(event) {
    console.log('Фаза всплытия: родитель');
});

// Обработчик в фазе захвата
child.addEventListener('click', function(event) {
    console.log('Фаза захвата: дочерний элемент');
}, true);

// Обработчик в фазе всплытия
child.addEventListener('click', function(event) {
    console.log('Фаза всплытия: дочерний элемент');
});

// Результат клика по дочернему элементу:
// 1. Фаза захвата: родитель
// 2. Фаза захвата: дочерний элемент
// 3. Фаза всплытия: дочерний элемент
// 4. Фаза всплытия: родитель
```

### Остановка всплытия

```javascript
// Остановка всплытия события
element.addEventListener('click', function(event) {
    console.log('Обработчик элемента');
    event.stopPropagation(); // Остановить всплытие
});

// Предотвращение стандартного действия
formElement.addEventListener('submit', function(event) {
    event.preventDefault(); // Предотвратить стандартную отправку формы
    console.log('Отправка формы обработана вручную');
});
```

## Методы добавления обработчиков

### addEventListener (рекомендуемый)

```javascript
// Добавление обработчика
element.addEventListener('click', handleClick);

// Добавление обработчика с опциями
element.addEventListener('click', handleClick, {
    once: true,        // Выполнить только один раз
    passive: true,     // Не предотвращать стандартное действие
    capture: true      // Фаза захвата
});

// Удаление обработчика
element.removeEventListener('click', handleClick);
```

### Inline-обработчики (не рекомендуется)

```javascript
// Не рекомендуется использовать
element.onclick = function() {
    console.log('Клик');
};

// Можно установить только один обработчик
element.onclick = firstHandler;
element.onclick = secondHandler; // firstHandler будет перезаписан
```

## Объект события

### Свойства объекта события

```javascript
element.addEventListener('click', function(event) {
    // Основные свойства
    console.log('Тип события:', event.type);
    console.log('Целевой элемент:', event.target);
    console.log('Текущий элемент:', event.currentTarget);
    console.log('Координаты:', event.clientX, event.clientY);
    
    // Состояние клавиш-модификаторов
    console.log('Ctrl:', event.ctrlKey);
    console.log('Shift:', event.shiftKey);
    console.log('Alt:', event.altKey);
    console.log('Meta (Cmd):', event.metaKey);
    
    // Состояние кнопок мыши
    console.log('Кнопка мыши:', event.button);
    
    // Временная метка
    console.log('Время события:', event.timeStamp);
});
```

### Кастомные события

```javascript
// Создание кастомного события
const customEvent = new CustomEvent('myCustomEvent', {
    detail: {
        message: 'Привет из кастомного события',
        data: { id: 1, name: 'Тест' }
    },
    bubbles: true,
    cancelable: true
});

// Добавление обработчика для кастомного события
element.addEventListener('myCustomEvent', function(event) {
    console.log('Кастомное событие:', event.detail);
});

// Вызов кастомного события
element.dispatchEvent(customEvent);
```

## Делегирование событий

### Принцип делегирования

```javascript
// Плохо: добавление обработчика для каждого элемента
const buttons = document.querySelectorAll('.button');
buttons.forEach(button => {
    button.addEventListener('click', handleClick);
});

// Хорошо: делегирование событий
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('button')) {
        handleClick(event);
    }
});
```

### Пример делегирования событий

```javascript
// Обработка кликов по списку с делегированием
const list = document.getElementById('itemList');

list.addEventListener('click', function(event) {
    const listItem = event.target.closest('.list-item');
    
    if (listItem) {
        console.log('Клик по элементу списка:', listItem.dataset.id);
        
        // Обработка клика по кнопке удаления
        if (event.target.classList.contains('delete-btn')) {
            event.stopPropagation(); // Остановить всплытие
            listItem.remove();
        }
    }
});
```

## Современные возможности

### Pointer Events

```javascript
// Поддержка различных типов указателей (мышь, тач, перо)
element.addEventListener('pointerdown', function(event) {
    console.log('Начало взаимодействия с указателем');
    console.log('Тип указателя:', event.pointerType); // 'mouse', 'touch', 'pen'
});

element.addEventListener('pointermove', function(event) {
    console.log('Движение указателя:', event.clientX, event.clientY);
});

element.addEventListener('pointerup', function(event) {
    console.log('Завершение взаимодействия с указателем');
});
```

### Touch Events

```javascript
// События сенсорного экрана
element.addEventListener('touchstart', function(event) {
    const touch = event.touches[0];
    console.log('Начало касания:', touch.clientX, touch.clientY);
});

element.addEventListener('touchmove', function(event) {
    event.preventDefault(); // Предотвратить стандартное поведение прокрутки
    const touch = event.touches[0];
    console.log('Движение касания:', touch.clientX, touch.clientY);
});

element.addEventListener('touchend', function(event) {
    console.log('Завершение касания');
});
```

## Лучшие практики

### 1. Использование делегирования событий

```javascript
// Эффективное управление событиями для динамических элементов
class EventManager {
    constructor() {
        this.handlers = new Map();
    }
    
    on(element, event, selector, handler) {
        const wrapper = (e) => {
            if (e.target.matches(selector)) {
                handler.call(e.target, e);
            }
        };
        
        element.addEventListener(event, wrapper);
        
        // Сохранение для возможности удаления
        const key = `${event}-${selector}`;
        if (!this.handlers.has(key)) {
            this.handlers.set(key, []);
        }
        this.handlers.get(key).push({ element, wrapper });
    }
    
    off(event, selector) {
        const key = `${event}-${selector}`;
        const handlers = this.handlers.get(key);
        
        if (handlers) {
            handlers.forEach(({ element, wrapper }) => {
                element.removeEventListener(event, wrapper);
            });
            this.handlers.delete(key);
        }
    }
}

// Использование
const eventManager = new EventManager();
eventManager.on(document, 'click', '.button', function(event) {
    console.log('Клик по кнопке');
});
```

### 2. Оптимизация производительности

```javascript
// Использование passive слушателей для событий прокрутки
window.addEventListener('scroll', function(event) {
    // Обработчик прокрутки
}, { passive: true });

// Использование debounce для событий, вызывающих частые вычисления
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

const debouncedScrollHandler = debounce(function() {
    // Вычисления при прокрутке
    console.log('Прокрутка завершена');
}, 100);

window.addEventListener('scroll', debouncedScrollHandler, { passive: true });
```

### 3. Управление памятью

```javascript
// Правильное удаление обработчиков для предотвращения утечек памяти
class Component {
    constructor(element) {
        this.element = element;
        this.boundHandler = this.handler.bind(this);
        this.init();
    }
    
    init() {
        this.element.addEventListener('click', this.boundHandler);
    }
    
    handler(event) {
        console.log('Обработчик компонента');
    }
    
    destroy() {
        // Удаление обработчика при уничтожении компонента
        this.element.removeEventListener('click', this.boundHandler);
    }
}
```

## Промышленные примеры

### Система управления событиями

```javascript
class EventSystem {
    constructor() {
        this.events = {};
    }
    
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    off(event, callback) {
        if (this.events[event]) {
            this.events[event] = this.events[event].filter(cb => cb !== callback);
        }
    }
    
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
    
    once(event, callback) {
        const onceCallback = (data) => {
            callback(data);
            this.off(event, onceCallback);
        };
        this.on(event, onceCallback);
    }
}

// Использование
const eventSystem = new EventSystem();

eventSystem.on('user:login', (userData) => {
    console.log('Пользователь вошел:', userData);
});

eventSystem.emit('user:login', { id: 1, name: 'Иван' });
```

### Обработка жестов

```javascript
class GestureHandler {
    constructor(element) {
        this.element = element;
        this.startX = 0;
        this.startY = 0;
        this.callbacks = {
            swipeLeft: [],
            swipeRight: [],
            swipeUp: [],
            swipeDown: []
        };
        
        this.init();
    }
    
    init() {
        this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
    }
    
    handleTouchStart(event) {
        this.startX = event.touches[0].clientX;
        this.startY = event.touches[0].clientY;
    }
    
    handleTouchMove(event) {
        // Заглушка для предотвращения стандартного поведения
    }
    
    handleTouchEnd(event) {
        const endX = event.changedTouches[0].clientX;
        const endY = event.changedTouches[0].clientY;
        
        const diffX = endX - this.startX;
        const diffY = endY - this.startY;
        
        // Определение направления жеста
        if (Math.abs(diffX) > Math.abs(diffY)) {
            // Горизонтальный жест
            if (diffX > 50) {
                this.trigger('swipeRight');
            } else if (diffX < -50) {
                this.trigger('swipeLeft');
            }
        } else {
            // Вертикальный жест
            if (diffY > 50) {
                this.trigger('swipeDown');
            } else if (diffY < -50) {
                this.trigger('swipeUp');
            }
        }
    }
    
    on(gesture, callback) {
        if (this.callbacks[gesture]) {
            this.callbacks[gesture].push(callback);
        }
    }
    
    trigger(gesture) {
        if (this.callbacks[gesture]) {
            this.callbacks[gesture].forEach(callback => callback());
        }
    }
}

// Использование
const gestureHandler = new GestureHandler(document.getElementById('swipe-area'));
gestureHandler.on('swipeLeft', () => console.log('Свайп влево'));
gestureHandler.on('swipeRight', () => console.log('Свайп вправо'));
```

## Совместимость и полифилы

### Совместимость с разными браузерами

```javascript
// Проверка поддержки современных событий
const supportsPassive = (function() {
    let supports = false;
    try {
        const opts = Object.defineProperty({}, 'passive', {
            get: function() {
                supports = true;
            }
        });
        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
    } catch (e) {}
    return supports;
})();

// Использование опций в зависимости от поддержки
const eventOptions = supportsPassive ? { passive: true } : false;
window.addEventListener('scroll', scrollHandler, eventOptions);
```

События в браузере - это мощный инструмент для создания интерактивных веб-приложений. Понимание их работы, фаз и правильное использование позволяет создавать эффективные и отзывчивые интерфейсы.

#javascript #events #frontend #web-development #best-practices