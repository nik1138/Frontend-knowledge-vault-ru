---
aliases: [Компонентный подход, Компоненты, UI-архитектура]
tags: [javascript, архитектура, компоненты, ui, frontend]
---

# Компонентная архитектура в JavaScript

## Обзор

Компонентная архитектура - это подход к разработке программного обеспечения, при котором приложение строится из независимых, переиспользуемых компонентов. В JavaScript-приложениях это позволяет создавать модульные, тестируемые и поддерживаемые интерфейсы.

## Основные принципы

### Изоляция

Каждый компонент должен быть изолирован от других и иметь четко определенные интерфейсы взаимодействия.

### Переиспользуемость

Компоненты должны быть разработаны так, чтобы их можно было использовать в разных частях приложения или даже в разных проектах.

### Конфигурируемость

Компоненты должны принимать параметры (props), которые позволяют настраивать их поведение и внешний вид.

## Реализация компонентной архитектуры

### Простой компонент

```javascript
class ButtonComponent {
  constructor(props) {
    this.text = props.text || 'Кнопка';
    this.type = props.type || 'button';
    this.onClick = props.onClick || (() => {});
    this.className = props.className || 'btn';
  }
  
  render() {
    const button = document.createElement('button');
    button.type = this.type;
    button.textContent = this.text;
    button.className = this.className;
    
    button.addEventListener('click', this.onClick);
    
    return button;
  }
}

// Использование
const myButton = new ButtonComponent({
  text: 'Отправить',
  className: 'btn-primary',
  onClick: () => console.log('Кнопка нажата')
});

document.body.appendChild(myButton.render());
```

### Компонент с состоянием

```javascript
class CounterComponent {
  constructor(initialValue = 0) {
    this.state = {
      count: initialValue
    };
    this.element = null;
  }
  
  increment() {
    this.state.count++;
    this.render();
  }
  
  decrement() {
    this.state.count--;
    this.render();
  }
  
  render() {
    if (!this.element) {
      this.element = document.createElement('div');
      this.element.className = 'counter';
    }
    
    this.element.innerHTML = `
      <div class="counter-display">${this.state.count}</div>
      <button class="counter-btn increment">+</button>
      <button class="counter-btn decrement">-</button>
    `;
    
    this.element.querySelector('.increment').addEventListener('click', () => this.increment());
    this.element.querySelector('.decrement').addEventListener('click', () => this.decrement());
    
    return this.element;
  }
}
```

### Система управления компонентами

```javascript
class ComponentManager {
  constructor() {
    this.components = new Map();
    this.nextId = 0;
  }
  
  register(name, componentClass) {
    this.components.set(name, componentClass);
  }
  
  create(name, props = {}) {
    const ComponentClass = this.components.get(name);
    if (!ComponentClass) {
      throw new Error(`Компонент ${name} не зарегистрирован`);
    }
    
    const component = new ComponentClass(props);
    component.id = `comp-${this.nextId++}`;
    return component;
  }
  
  renderTo(container, name, props = {}) {
    const component = this.create(name, props);
    const element = component.render();
    container.appendChild(element);
    return component;
  }
}

// Регистрация компонентов
const manager = new ComponentManager();
manager.register('Button', ButtonComponent);
manager.register('Counter', CounterComponent);

// Использование
const buttonContainer = document.getElementById('buttons');
manager.renderTo(buttonContainer, 'Button', {
  text: 'Нажми меня',
  onClick: () => alert('Кнопка нажата!')
});
```

## Современные подходы

### JSX-подобная реализация

```javascript
function createElement(tag, props, ...children) {
  const element = document.createElement(tag);
  
  // Установка атрибутов
  if (props) {
    Object.keys(props).forEach(key => {
      if (key.startsWith('on')) {
        // Обработчики событий
        element.addEventListener(key.slice(2).toLowerCase(), props[key]);
      } else if (key === 'className') {
        element.className = props[key];
      } else if (key === 'style') {
        Object.assign(element.style, props[key]);
      } else {
        element.setAttribute(key, props[key]);
      }
    });
  }
  
  // Добавление дочерних элементов
  children.forEach(child => {
    if (typeof child === 'string' || typeof child === 'number') {
      element.appendChild(document.createTextNode(child.toString()));
    } else {
      element.appendChild(child);
    }
  });
  
  return element;
}

// Использование
function renderCard(title, content) {
  return createElement('div', { className: 'card' },
    createElement('h3', { className: 'card-title' }, title),
    createElement('p', { className: 'card-content' }, content),
    createElement('button', { 
      className: 'btn', 
      onClick: () => console.log('Карточка нажата') 
    }, 'Подробнее')
  );
}

document.body.appendChild(renderCard('Заголовок', 'Содержимое карточки'));
```

### Компоненты с жизненным циклом

```javascript
class BaseComponent {
  constructor(props = {}) {
    this.props = props;
    this.state = {};
    this.refs = {};
    this.element = null;
  }
  
  componentWillMount() {
    // Вызывается перед монтированием
  }
  
  componentDidMount() {
    // Вызывается после монтирования
  }
  
  componentWillReceiveProps(nextProps) {
    // Вызывается при получении новых props
  }
  
  shouldComponentUpdate(nextProps, nextState) {
    // Определяет, нужно ли обновлять компонент
    return true;
  }
  
  componentWillUpdate() {
    // Вызывается перед обновлением
  }
  
  componentDidUpdate() {
    // Вызывается после обновления
  }
  
  componentWillUnmount() {
    // Вызывается перед размонтированием
  }
  
  setState(newState) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...newState };
    
    if (this.shouldComponentUpdate(this.props, this.state)) {
      this.componentWillUpdate();
      this.render();
      this.componentDidUpdate();
    }
  }
  
  render() {
    throw new Error('Метод render() должен быть реализован');
  }
}

class TodoListComponent extends BaseComponent {
  constructor(props) {
    super(props);
    this.state = {
      todos: props.initialTodos || [],
      newTodo: ''
    };
  }
  
  componentDidMount() {
    console.log('TodoListComponent смонтирован');
  }
  
  addTodo() {
    if (this.state.newTodo.trim()) {
      const newTodo = {
        id: Date.now(),
        text: this.state.newTodo,
        completed: false
      };
      
      this.setState({
        todos: [...this.state.todos, newTodo],
        newTodo: ''
      });
    }
  }
  
  toggleTodo(id) {
    this.setState({
      todos: this.state.todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    });
  }
  
  render() {
    this.element = document.createElement('div');
    this.element.className = 'todo-list';
    
    // Форма добавления
    const form = document.createElement('form');
    form.innerHTML = `
      <input type="text" class="todo-input" placeholder="Добавить задачу...">
      <button type="submit">Добавить</button>
    `;
    
    const input = form.querySelector('.todo-input');
    input.value = this.state.newTodo;
    input.addEventListener('input', (e) => {
      this.setState({ newTodo: e.target.value });
    });
    
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      this.addTodo();
    });
    
    // Список задач
    const list = document.createElement('ul');
    this.state.todos.forEach(todo => {
      const li = document.createElement('li');
      li.className = todo.completed ? 'completed' : '';
      li.innerHTML = `
        <span>${todo.text}</span>
        <button class="toggle-btn">${todo.completed ? 'Отменить' : 'Выполнено'}</button>
      `;
      
      li.querySelector('.toggle-btn').addEventListener('click', () => {
        this.toggleTodo(todo.id);
      });
      
      list.appendChild(li);
    });
    
    this.element.appendChild(form);
    this.element.appendChild(list);
    
    return this.element;
  }
}
```

## Практические рекомендации для российских разработчиков

### Организация компонентов

В 2025 году российские команды разработчиков следуют следующим практикам:

- **Файловая структура**: Компоненты организуются в отдельных папках с файлами `index.js`, `styles.css` и `tests.js`
- **Документирование**: Использование JSDoc для документирования интерфейсов компонентов
- **Тестирование**: Компоненты тестируются с помощью unit-тестов и интеграционных тестов

### Совместимость с фреймворками

- **React**: Использование компонентной архитектуры через функциональные компоненты и хуки
- **Vue**: Создание компонентов с использованием однофайловых компонентов (.vue)
- **Angular**: Использование компонентов как основной архитектурной единицы

### Российские стандарты разработки

Российские компании уделяют особое внимание:

- **Локализации**: Компоненты должны поддерживать русский язык и другие языки СНГ
- **Доступности**: Соответствие стандартам WCAG для обеспечения доступности
- **Производительности**: Оптимизация компонентов для работы в условиях ограниченного интернета

## Примеры использования в российской экосистеме

Компонентная архитектура активно используется в российских проектах:

- **Яндекс.Маркет** - для создания модульных UI-компонентов
- **Сбербанк Online** - для унификации интерфейсов на веб и мобильных платформах
- **ВКонтакте** - для быстрой разработки новых функций с использованием существующих компонентов

## Ссылки

- [[MVC-и-MVVM]] - для понимания архитектурных паттернов
- [[Паттерны-проектирования]] - для понимания других шаблонов проектирования
- [[Архитектура-приложений]] - для комплексного понимания архитектуры
- [[Модульность]] - для понимания организации кода

## Ключевые теги

#javascript #компоненты #архитектура #ui #frontend #ru2025