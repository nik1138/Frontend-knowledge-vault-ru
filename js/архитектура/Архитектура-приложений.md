---
aliases: [Архитектура JS-приложений, Структура приложений, Архитектурные решения]
tags: [javascript, архитектура, приложения, frontend, backend]
---

# Архитектура JavaScript-приложений

## Обзор

Архитектура JavaScript-приложений - это фундаментальная структура, определяющая, как различные компоненты приложения организованы, взаимодействуют друг с другом и разрабатываются. Правильная архитектура обеспечивает масштабируемость, поддерживаемость и тестируемость кода.

## Уровни архитектуры

### Фронтенд-архитектура

#### Многоуровневая архитектура

```javascript
// Слой представления (View Layer)
class UserView {
  constructor() {
    this.container = document.getElementById('user-container');
  }
  
  render(users) {
    this.container.innerHTML = users.map(user => `
      <div class="user-card">
        <h3>${user.name}</h3>
        <p>${user.email}</p>
      </div>
    `).join('');
  }
}

// Слой бизнес-логики (Service Layer)
class UserService {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  async getUsers() {
    try {
      const response = await this.apiClient.get('/users');
      return response.data;
    } catch (error) {
      console.error('Ошибка при получении пользователей:', error);
      throw error;
    }
  }
  
  async createUser(userData) {
    try {
      const response = await this.apiClient.post('/users', userData);
      return response.data;
    } catch (error) {
      console.error('Ошибка при создании пользователя:', error);
      throw error;
    }
  }
}

// Слой данных (Data Layer)
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  async get(endpoint) {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    return response.json();
  }
  
  async post(endpoint, data) {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// Контроллер (Controller Layer)
class UserController {
  constructor(userService, userView) {
    this.userService = userService;
    this.userView = userView;
  }
  
  async loadUsers() {
    try {
      const users = await this.userService.getUsers();
      this.userView.render(users);
    } catch (error) {
      // Обработка ошибок
      this.userView.showError('Не удалось загрузить пользователей');
    }
  }
}

// Использование
const apiClient = new ApiClient('https://api.example.com');
const userService = new UserService(apiClient);
const userView = new UserView();
const userController = new UserController(userService, userView);

userController.loadUsers();
```

### Бэкенд-архитектура

#### Микросервисная архитектура

```javascript
// Пример сервиса аутентификации
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

class AuthService {
  constructor(config) {
    this.app = express();
    this.config = config;
    this.setupRoutes();
  }
  
  setupRoutes() {
    this.app.use(express.json());
    
    // Регистрация
    this.app.post('/register', async (req, res) => {
      try {
        const { email, password, name } = req.body;
        
        // Хеширование пароля
        const hashedPassword = await bcrypt.hash(password, 10);
        
        // Сохранение пользователя в БД (здесь упрощенно)
        const user = await this.saveUser({ email, password: hashedPassword, name });
        
        res.status(201).json({ message: 'Пользователь зарегистрирован', userId: user.id });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
    
    // Логин
    this.app.post('/login', async (req, res) => {
      try {
        const { email, password } = req.body;
        
        // Получение пользователя из БД
        const user = await this.findUserByEmail(email);
        if (!user) {
          return res.status(401).json({ error: 'Неверные учетные данные' });
        }
        
        // Проверка пароля
        const isValid = await bcrypt.compare(password, user.password);
        if (!isValid) {
          return res.status(401).json({ error: 'Неверные учетные данные' });
        }
        
        // Генерация JWT токена
        const token = jwt.sign(
          { userId: user.id, email: user.email },
          this.config.jwtSecret,
          { expiresIn: '24h' }
        );
        
        res.json({ token, userId: user.id });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });
  }
  
  async saveUser(userData) {
    // Реализация сохранения пользователя
    return { id: Date.now(), ...userData };
  }
  
  async findUserByEmail(email) {
    // Реализация поиска пользователя по email
    return null; // Заглушка
  }
  
  start(port) {
    this.app.listen(port, () => {
      console.log(`Auth service running on port ${port}`);
    });
  }
}

// Пример использования
const authConfig = {
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
};

const authService = new AuthService(authConfig);
authService.start(3001);
```

## Архитектурные шаблоны

### Clean Architecture

```javascript
// Внешний слой - Frameworks & Drivers
class UserController {
  constructor(userInteractor) {
    this.userInteractor = userInteractor;
  }
  
  async handleGetUser(req, res) {
    try {
      const userId = req.params.id;
      const user = await this.userInteractor.getUserById(userId);
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}

// Второй слой - Interface Adapters
class UserInteractor {
  constructor(userRepository, userValidator) {
    this.userRepository = userRepository;
    this.userValidator = userValidator;
  }
  
  async getUserById(id) {
    // Валидация
    this.userValidator.validateId(id);
    
    // Бизнес-логика
    const user = await this.userRepository.findById(id);
    
    if (!user) {
      throw new Error('Пользователь не найден');
    }
    
    return user;
  }
}

// Внутренний слой - Entities (бизнес-правила)
class UserEntity {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
  }
  
  updateName(newName) {
    if (!newName || newName.trim().length < 2) {
      throw new Error('Имя должно содержать минимум 2 символа');
    }
    this.name = newName;
  }
  
  validateEmail() {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(this.email);
  }
}

// Репозиторий
class UserRepository {
  constructor(database) {
    this.database = database;
  }
  
  async findById(id) {
    // Получение пользователя из базы данных
    const userData = await this.database.get('users', id);
    if (!userData) return null;
    
    return new UserEntity(userData.id, userData.name, userData.email);
  }
  
  async save(user) {
    // Сохранение пользователя в базе данных
    await this.database.update('users', user.id, {
      name: user.name,
      email: user.email,
      createdAt: user.createdAt
    });
  }
}
```

### Layered Architecture (3-tier)

```javascript
// Data Access Layer
class DatabaseManager {
  constructor(connectionString) {
    this.connectionString = connectionString;
    this.connection = null;
  }
  
  async connect() {
    // Подключение к базе данных
    console.log('Подключение к базе данных...');
    // Здесь реальная реализация подключения
  }
  
  async executeQuery(query, params = []) {
    // Выполнение SQL-запроса
    console.log(`Выполнение запроса: ${query}`);
    // Здесь реальная реализация выполнения запроса
    return [];
  }
  
  async close() {
    // Закрытие соединения
    console.log('Закрытие соединения с базой данных...');
  }
}

// Business Logic Layer
class ProductService {
  constructor(databaseManager) {
    this.db = databaseManager;
  }
  
  async getAllProducts() {
    const query = 'SELECT * FROM products WHERE active = 1';
    const products = await this.db.executeQuery(query);
    return products.map(p => this.mapToProduct(p));
  }
  
  async getProductById(id) {
    const query = 'SELECT * FROM products WHERE id = ? AND active = 1';
    const products = await this.db.executeQuery(query, [id]);
    return products.length > 0 ? this.mapToProduct(products[0]) : null;
  }
  
  async createProduct(productData) {
    // Валидация данных
    this.validateProductData(productData);
    
    const query = 'INSERT INTO products (name, price, description) VALUES (?, ?, ?)';
    const result = await this.db.executeQuery(query, [
      productData.name,
      productData.price,
      productData.description
    ]);
    
    return result;
  }
  
  validateProductData(productData) {
    if (!productData.name || productData.name.trim().length === 0) {
      throw new Error('Название продукта обязательно');
    }
    
    if (productData.price <= 0) {
      throw new Error('Цена должна быть положительной');
    }
  }
  
  mapToProduct(data) {
    return {
      id: data.id,
      name: data.name,
      price: parseFloat(data.price),
      description: data.description,
      createdAt: new Date(data.created_at)
    };
  }
}

// Presentation Layer
class ProductController {
  constructor(productService) {
    this.service = productService;
  }
  
  async handleGetAllProducts(req, res) {
    try {
      const products = await this.service.getAllProducts();
      res.json({
        success: true,
        data: products,
        count: products.length
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
  
  async handleCreateProduct(req, res) {
    try {
      const result = await this.service.createProduct(req.body);
      res.status(201).json({
        success: true,
        message: 'Продукт успешно создан',
        data: result
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }
}
```

## Практические рекомендации для российских разработчиков

### Архитектурные решения в 2025 году

В российской разработке JavaScript-приложений в 2025 году популярны следующие подходы:

- **Микрофронтенды** для крупных приложений
- **Serverless архитектура** для быстрого развертывания
- **Event-driven architecture** для распределенных систем
- **Monorepo** для управления большим количеством пакетов

### Безопасность

Российские разработчики уделяют особое внимание безопасности:

- **CORS** политики
- **CSRF** защита
- **XSS** предотвращение
- **SQL-инъекции** защита

### Российские стандарты и практики

- **Соответствие требованиям ФЗ-152** (О персональных данных)
- **Интеграция с российскими сервисами** (Касса.Маршрут, Сбербанк API)
- **Поддержка ЕСИА** (Единая система идентификации и аутентификации)
- **Локализация** для русскоязычных пользователей

## Мониторинг и логирование

```javascript
// Система логирования
class Logger {
  constructor(config) {
    this.level = config.level || 'info';
    this.transports = config.transports || [console];
  }
  
  log(level, message, meta = {}) {
    if (this.shouldLog(level)) {
      const logEntry = {
        timestamp: new Date().toISOString(),
        level,
        message,
        ...meta
      };
      
      this.transports.forEach(transport => {
        transport.log(logEntry);
      });
    }
  }
  
  shouldLog(level) {
    const levels = ['error', 'warn', 'info', 'debug'];
    return levels.indexOf(level) <= levels.indexOf(this.level);
  }
  
  error(message, meta) { this.log('error', message, meta); }
  warn(message, meta) { this.log('warn', message, meta); }
  info(message, meta) { this.log('info', message, meta); }
  debug(message, meta) { this.log('debug', message, meta); }
}

// Пример использования в архитектуре
class OrderService {
  constructor(database, logger) {
    this.db = database;
    this.logger = logger;
  }
  
  async processOrder(orderData) {
    this.logger.info('Начало обработки заказа', { orderId: orderData.id });
    
    try {
      // Валидация заказа
      this.validateOrder(orderData);
      
      // Сохранение заказа
      const order = await this.saveOrder(orderData);
      
      // Отправка уведомления
      await this.sendNotification(order);
      
      this.logger.info('Заказ успешно обработан', { orderId: order.id });
      return order;
    } catch (error) {
      this.logger.error('Ошибка при обработке заказа', { 
        orderId: orderData.id, 
        error: error.message 
      });
      throw error;
    }
  }
  
  validateOrder(orderData) {
    if (!orderData.items || orderData.items.length === 0) {
      throw new Error('Заказ должен содержать хотя бы один товар');
    }
  }
  
  async saveOrder(orderData) {
    // Логика сохранения заказа
    return { id: Date.now(), ...orderData, status: 'pending' };
  }
  
  async sendNotification(order) {
    // Логика отправки уведомления
    console.log(`Уведомление отправлено для заказа ${order.id}`);
  }
}
```

## Ссылки

- [[Паттерны-проектирования]] - для понимания архитектурных паттернов
- [[MVC-и-MVVM]] - для понимания архитектурных структур
- [[Компонентная-архитектура]] - для понимания структурирования UI
- [[Модульность]] - для понимания организации кода

## Ключевые теги

#javascript #архитектура #приложения #frontend #backend #ru2025