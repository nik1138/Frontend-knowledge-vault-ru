---
aliases: ["Асинхронная модульная система", "AMD модули"]
tags: ["javascript", "modules", "dependency-management", "frontend"]
---

# AMD (Asynchronous Module Definition)

AMD (Asynchronous Module Definition) - это спецификация для определения модулей, которые могут быть загружены асинхронно. Она была разработана для использования в браузерах и позволяет загружать модули по требованию без блокировки выполнения скрипта.

## Общее описание

AMD появилась как ответ на потребность в модульной системе, подходящей для браузерной среды, где загрузка скриптов может быть асинхронной. В отличие от CommonJS, который был ориентирован на серверную среду (Node.js), AMD была создана с учетом особенностей браузеров.

> [!note] Примечание
> AMD особенно популярна в российских веб-разработках до 2020 года, но в 2025 году используется в основном для поддержки устаревших систем и легаси-проектов.

## Основные концепции

### define()

Функция `define()` используется для определения модуля:

```javascript
// Простой модуль без зависимостей
define(function() {
    var myModule = {
        hello: function() {
            return 'Привет из модуля!';
        }
    };
    
    return myModule;
});

// Модуль с зависимостями
define(['jquery', 'underscore'], function($, _) {
    return {
        init: function() {
            // Используем зависимости
            console.log('jQuery версия:', $.fn.jquery);
            console.log('Underscore функции доступны');
        }
    };
});
```

### require()

Функция `require()` используется для загрузки и выполнения зависимостей:

```javascript
require(['myModule', 'otherModule'], function(myModule, otherModule) {
    // Использование загруженных модулей
    myModule.hello();
    otherModule.doSomething();
});
```

## Структура модуля AMD

```javascript
define([
    // Список зависимостей
    'dependency1',
    'dependency2',
    'dependency3'
], function(
    // Аргументы для зависимостей
    dep1,
    dep2,
    dep3
) {
    // Тело модуля
    var myModule = {
        // Реализация модуля
        doSomething: function() {
            return dep1.process() + dep2.transform(dep3.data);
        }
    };
    
    // Экспорт модуля
    return myModule;
});
```

## Практические рекомендации

### Использование RequireJS

RequireJS - самая популярная реализация AMD:

```html
<!-- Подключение RequireJS -->
<script src="require.js"></script>
<script>
require.config({
    baseUrl: 'js/lib',
    paths: {
        app: '../app'
    }
});

require(['app/main'], function(main) {
    main.init();
});
</script>
```

### Оптимизация с r.js

Для продакшена рекомендуется использовать оптимизатор r.js:

```bash
# Установка
npm install -g requirejs

# Компиляция
r.js -o name=main out=main-built.js baseUrl=.

# В проектах с российскими реалиями 2025 года
# Обратите внимание на поддержку ES6 модулей
```

## Преимущества и недостатки

### Преимущества
- Асинхронная загрузка модулей
- Поддержка зависимостей между модулями
- Возможность загрузки модулей по требованию
- Работает в браузере без дополнительных инструментов

### Недостатки
- Сложный синтаксис по сравнению с ES6 модулями
- Не поддерживается нативно браузерами
- Меньше поддержки в современных фреймворках
- В 2025 году в России в основном используется в унаследованных проектах

## Современные альтернативы

В 2025 году в российской разработке предпочтение отдается:

- [[ES6 Modules]] - стандартный способ модулей в JavaScript
- [[Импорт-и-экспорт]] - современные способы импорта/экспорта
- Bundlers: [[Webpack]], [[Rollup]], [[Vite]]

## Связь с другими темами

- [[Управление-зависимостями]] - более общая концепция
- [[CommonJS]] - серверная альтернатива AMD
- [[SystemJS]] - универсальный загрузчик модулей

> [!warning] Важно
> AMD в 2025 году в российской разработке в основном используется для поддержки старых проектов. При создании новых проектов рекомендуется использовать ES6 модули или современные сборщики.

## Примеры из российской практики

В российских компаниях вроде Яндекса, Mail.ru Group и других крупных игроков AMD использовалась до 2020 года в основном в следующих сценариях:

- Загрузка модулей в браузере без сборки
- Управление зависимостями в legacy-приложениях
- Плагинная архитектура для крупных веб-приложений