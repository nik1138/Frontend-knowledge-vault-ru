---
tags: [programming, regexp, performance, frontend, javascript, advanced]
aliases: [повышение-производительности-регулярных-выражений, regexp-performance]
---

# Повышение производительности регулярных выражений

В этой статье рассмотрим методы оптимизации производительности регулярных выражений в веб-разработке. Производительность регулярных выражений особенно важна при обработке больших объемов данных или частом выполнении операций поиска и замены.

## Понимание производительности регулярных выражений

Производительность регулярных выражений зависит от нескольких факторов:

1. Сложности паттерна
2. Длины строки поиска
3. Количество совпадений
4. Используемых конструкций (квантификаторы, группы, опережающие проверки и т.д.)

### Измерение производительности

```javascript
// Класс для измерения производительности регулярных выражений
class RegexPerformanceMeasurer {
  static measure(pattern, text, iterations = 10000, flags = '') {
    const regex = new RegExp(pattern, flags);
    const startTime = performance.now();

    for (let i = 0; i < iterations; i++) {
      regex.test(text);
    }

    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    return {
      totalTime: totalTime,
      avgTime: totalTime / iterations,
      iterations: iterations
    };
  }

  static compare(patterns, text, iterations = 10000) {
    const results = {};
    
    for (const [name, pattern] of Object.entries(patterns)) {
      results[name] = this.measure(pattern, text, iterations);
    }
    
    return results;
  }

  static findSlowPatterns(text, regexArray, iterations = 1000) {
    const results = [];
    
    for (const [name, regex] of regexArray) {
      const startTime = performance.now();
      
      for (let i = 0; i < iterations; i++) {
        regex.test(text);
      }
      
      const endTime = performance.now();
      results.push({
        name,
        regex,
        time: endTime - startTime
      });
    }
    
    // Сортируем по времени выполнения (медленные первыми)
    return results.sort((a, b) => b.time - a.time);
  }
}

// Пример измерения производительности
const testText = "JavaScript - это мощный язык программирования. JavaScript используется в веб-разработке.".repeat(100);
const patterns = {
  'Простое совпадение': /JavaScript/,
  'Глобальное совпадение': /JavaScript/g,
  'Сложное совпадение': /Java(Script|Se[a-z]{4})/,
  'Совпадение с квантификатором': /Java\w*/,
  'Совпадение с группой': /(Java)(Script)/
};

const performanceResults = RegexPerformanceMeasurer.compare(patterns, testText, 5000);
for (const [name, result] of Object.entries(performanceResults)) {
  console.log(`${name}: ${result.avgTime.toFixed(6)}ms за операцию`);
}
```

## Оптимизация паттернов регулярных выражений

### Избегание чрезмерного использования квантификаторов

```javascript
// Плохо: может привести к чрезмерному backtracking
const inefficientPattern = /(a+)+b/;

// Лучше: упрощенный паттерн
const efficientPattern = /a+b/;

// Практический пример: валидация email
class EmailValidator {
  // Неэффективный паттерн (потенциально уязвим к ReDoS)
  static inefficientPattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  // Оптимизированный паттерн
  static efficientPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  static validateInefficient(email) {
    return this.inefficientPattern.test(email);
  }
  
  static validateEfficient(email) {
    return this.efficientPattern.test(email);
  }
  
  // Дополнительная валидация для повышения точности
  static validateWithExtraChecks(email) {
    if (!this.efficientPattern.test(email)) {
      return false;
    }
    
    // Дополнительные проверки
    const [localPart, domain] = email.split('@');
    
    // Проверка длины локальной части
    if (localPart.length > 64) {
      return false;
    }
    
    // Проверка длины домена
    if (domain.length > 255) {
      return false;
    }
    
    // Проверка на двойные точки
    if (email.includes('..')) {
      return false;
    }
    
    return true;
  }
}

// Сравнение производительности
const testEmails = [
  'user@example.com',
  'very.long.email.address.that.could.potentially.cause.performance.issues@example.com',
  'user.name+tag@example.co.uk'
];

console.time('Неэффективная валидация');
for (let i = 0; i < 1000; i++) {
  testEmails.forEach(email => EmailValidator.validateInefficient(email));
}
console.timeEnd('Неэффективная валидация');

console.time('Эффективная валидация');
for (let i = 0; i < 1000; i++) {
  testEmails.forEach(email => EmailValidator.validateEfficient(email));
}
console.timeEnd('Эффективная валидация');
```

### Использование незахватывающих групп

```javascript
// Захватывающие группы (менее эффективны при необходимости только проверки)
const capturingGroupPattern = /(\.com|\.org|\.net)$/;

// Незахватывающие группы (эффективнее при необходимости только проверки)
const nonCapturingGroupPattern = /(?:\.com|\.org|\.net)$/;

// Пример использования в практической задаче
class DomainValidator {
  // С использованием захватывающих групп
  static validateWithCapturing(url) {
    const match = url.match(/https?:\/\/(?:www\.)?[^\/]+(\.com|\.org|\.net|\.ru|\.co\.uk)/);
    return match ? match[1] : null;
  }
  
  // С использованием незахватывающих групп (эффективнее)
  static validateWithNonCapturing(url) {
    const match = url.match(/https?:\/\/(?:www\.)?[^\/]+(?:\.com|\.org|\.net|\.ru|\.co\.uk)/);
    return match ? match[0] : null;
  }
  
  // Если нужно получить только расширение
  static getDomainExtension(url) {
    const match = url.match(/https?:\/\/(?:www\.)?[^\/]+((?:\.[^\/.])+)/);
    return match ? match[1] : null;
  }
}

// Сравнение производительности
const testUrls = [
  'https://example.com',
  'http://www.test.org',
  'https://site.net',
  'http://subdomain.example.co.uk'
];

console.time('Захватывающие группы');
for (let i = 0; i < 10000; i++) {
  testUrls.forEach(url => DomainValidator.validateWithCapturing(url));
}
console.timeEnd('Захватывающие группы');

console.time('Незахватывающие группы');
for (let i = 0; i < 10000; i++) {
  testUrls.forEach(url => DomainValidator.validateWithNonCapturing(url));
}
console.timeEnd('Незахватывающие группы');
```

### Оптимизация квантификаторов

```javascript
// Плохо: жадные квантификаторы без необходимости
const greedyPattern = /<.*>/; // захватит все между первым < и последним > в строке

// Лучше: ленивые квантификаторы
const lazyPattern = /<.*?>/

// Еще лучше: конкретизация паттерна
const specificPattern = /<[^>]*>/

// Практический пример: извлечение HTML-тегов
class HtmlTagExtractor {
  // Неэффективный метод с жадными квантификаторами
  static extractWithGreedy(html) {
    return html.match(/<.*>/g) || [];
  }
  
  // Более эффективный метод
  static extractWithSpecific(html) {
    return html.match(/<[^>]*>/g) || [];
  }
  
  // Наиболее эффективный метод с конкретными тегами
  static extractSpecificTags(html, tags = ['div', 'p', 'span', 'a', 'img']) {
    const pattern = new RegExp(`<\/?(${tags.join('|')})[^>]*>`, 'gi');
    return html.match(pattern) || [];
  }
  
  // Метод с использованием lookahead для сложных случаев
  static extractComplexTags(html) {
    // Паттерн для тегов с атрибутами
    return html.match(/<[a-zA-Z][a-zA-Z0-9]*\b(?:\s+[a-zA-Z_:][a-zA-Z0-9:_.-]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s>]+))?)*\s*\/?>|<\s*\/\s*[a-zA-Z][a-zA-Z0-9]*\s*>/g) || [];
  }
}

const complexHtml = '<div class="test"><p>Текст</p><span id="example">Еще текст</span></div><img src="image.jpg">';

console.time('Жадный паттерн');
for (let i = 0; i < 1000; i++) {
  HtmlTagExtractor.extractWithGreedy(complexHtml);
}
console.timeEnd('Жадный паттерн');

console.time('Конкретный паттерн');
for (let i = 0; i < 1000; i++) {
  HtmlTagExtractor.extractWithSpecific(complexHtml);
}
console.timeEnd('Конкретный паттерн');
```

## Кэширование регулярных выражений

```javascript
// Класс для кэширования регулярных выражений
class RegexCache {
  constructor() {
    this.cache = new Map();
  }
  
  get(pattern, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    return this.cache.get(key);
  }
  
  clear() {
    this.cache.clear();
  }
  
  stats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
}

// Пример использования кэширования
class CachedValidator {
  constructor() {
    this.cache = new RegExpCache();
  }
  
  validateEmail(email) {
    const regex = this.cache.get('^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$', 'i');
    return regex.test(email);
  }
  
  validatePhone(phone) {
    const regex = this.cache.get('^\\+?[1-9]\\d{1,14}$');
    return regex.test(phone);
  }
  
  validateUrl(url) {
    const regex = this.cache.get('^https?:\\/\\/(?:[-\\w.]|(?:%[\\da-fA-F]{2}))+$');
    return regex.test(url);
  }
}

// Класс с автоматическим кэшированием
class AutoCachedRegex {
  constructor() {
    this.cache = new Map();
  }
  
  exec(pattern, text, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    
    return this.cache.get(key).exec(text);
  }
  
  test(pattern, text, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    
    return this.cache.get(key).test(text);
  }
  
  match(pattern, text, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    
    return text.match(this.cache.get(key));
  }
  
  replace(pattern, text, replacement, flags = 'g') {
    const key = `${pattern}_${flags}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    
    return text.replace(this.cache.get(key), replacement);
  }
}

// Сравнение производительности с кэшированием
const uncachedValidator = {
  validateEmail: (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
};

const cachedValidator = new CachedValidator();
const autoCached = new AutoCachedRegex();

const testEmails = ['user@example.com', 'test@domain.org', 'admin@site.net'].repeat(100).split(',');

console.time('Без кэширования');
for (let i = 0; i < 1000; i++) {
  testEmails.forEach(email => uncachedValidator.validateEmail(email));
}
console.timeEnd('Без кэширования');

console.time('С кэшированием');
for (let i = 0; i < 1000; i++) {
  testEmails.forEach(email => cachedValidator.validateEmail(email));
}
console.timeEnd('С кэшированием');
```

## Оптимизация сложных паттернов

### Разбиение сложных паттернов

```javascript
// Вместо одного сложного паттерна используем несколько простых
class ComplexValidator {
  // Один сложный паттерн (менее эффективно)
  static validateComplexBad(input) {
    return /^([A-Za-z]{2,16})\s+([A-Za-z]{2,16})\s+(\d{3}-\d{3}-\d{4})\s+([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/.test(input);
  }
  
  // Несколько простых паттернов (эффективнее)
  static validateComplexGood(input) {
    const parts = input.split(/\s+/);
    if (parts.length !== 4) return false;
    
    const [firstName, lastName, phone, email] = parts;
    
    const patterns = {
      name: /^[A-Za-z]{2,16}$/,
      phone: /^\d{3}-\d{3}-\d{4}$/,
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    };
    
    return patterns.name.test(firstName) && 
           patterns.name.test(lastName) && 
           patterns.phone.test(phone) && 
           patterns.email.test(email);
  }
  
  // Проверка с детализацией ошибок
  static validateWithDetails(input) {
    const parts = input.split(/\s+/);
    if (parts.length !== 4) {
      return { isValid: false, errors: ['Неверное количество частей'] };
    }
    
    const [firstName, lastName, phone, email] = parts;
    const errors = [];
    
    if (!/^[A-Za-z]{2,16}$/.test(firstName)) {
      errors.push('Некорректное имя');
    }
    
    if (!/^[A-Za-z]{2,16}$/.test(lastName)) {
      errors.push('Некорректная фамилия');
    }
    
    if (!/^\d{3}-\d{3}-\d{4}$/.test(phone)) {
      errors.push('Некорректный телефон');
    }
    
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      errors.push('Некорректный email');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Сравнение производительности
const testData = 'Иван Петров 123-456-7890 ivan@example.com';
const iterations = 10000;

console.time('Сложный паттерн');
for (let i = 0; i < iterations; i++) {
  ComplexValidator.validateComplexBad(testData);
}
console.timeEnd('Сложный паттерн');

console.time('Простые паттерны');
for (let i = 0; i < iterations; i++) {
  ComplexValidator.validateComplexGood(testData);
}
console.timeEnd('Простые паттерны');
```

### Использование альтернации эффективно

```javascript
// Неэффективно: длинная альтернация
const inefficientAlternation = /^(jpg|jpeg|png|gif|bmp|svg|webp|tiff|tif)$/i;

// Более эффективно: группировка по схожим паттернам
const efficientAlternation = /^jpe?g|png|gif|bmp|svg|webp|tiff?$/i;

// Практический пример: валидация расширений файлов
class FileExtensionValidator {
  // Неэффективная реализация
  static validateBad(extension) {
    return /^(jpg|jpeg|png|gif|bmp|svg|webp|tiff|tif|pdf|doc|docx|txt|html|css|js|json)$/i.test(extension);
  }
  
  // Эффективная реализация с группировкой
  static validateGood(extension) {
    extension = extension.toLowerCase();
    
    // Группы расширений
    const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'tiff', 'tif'];
    const docExts = ['pdf', 'doc', 'docx', 'txt'];
    const codeExts = ['html', 'css', 'js', 'json'];
    
    return imageExts.includes(extension) || 
           docExts.includes(extension) || 
           codeExts.includes(extension);
  }
  
  // С использованием Map для еще большей эффективности
  static validateBest(extension) {
    const validExtensions = new Set([
      'jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'tiff', 'tif',
      'pdf', 'doc', 'docx', 'txt', 'html', 'css', 'js', 'json'
    ]);
    
    return validExtensions.has(extension.toLowerCase());
  }
}

// Сравнение производительности
const extensions = ['jpg', 'png', 'pdf', 'html', 'invalid'];
const iterations = 50000;

console.time('Альтернация в регулярном выражении');
for (let i = 0; i < iterations; i++) {
  extensions.forEach(ext => FileExtensionValidator.validateBad(ext));
}
console.timeEnd('Альтернация в регулярном выражении');

console.time('С Set');
for (let i = 0; i < iterations; i++) {
  extensions.forEach(ext => FileExtensionValidator.validateBest(ext));
}
console.timeEnd('С Set');
```

## Избегание ReDoS атак

### Понимание и предотвращение ReDoS

```javascript
// Класс для анализа уязвимости к ReDoS
class RedosDetector {
  static testVulnerability(pattern, maliciousInput, timeout = 1000) {
    const regex = new RegExp(pattern);
    
    const startTime = Date.now();
    // Устанавливаем таймаут для предотвращения зависания
    const timeoutId = setTimeout(() => {
      throw new Error('Возможно, уязвимость к ReDoS');
    }, timeout);
    
    try {
      const result = regex.test(maliciousInput);
      clearTimeout(timeoutId);
      const endTime = Date.now();
      
      return {
        result,
        time: endTime - startTime,
        vulnerable: endTime > timeout * 0.8 // Если близко к таймауту
      };
    } catch (e) {
      clearTimeout(timeoutId);
      return {
        result: null,
        time: timeout,
        vulnerable: true,
        error: e.message
      };
    }
  }
  
  static generateMaliciousInputs() {
    return [
      'a'.repeat(1000) + '!',
      'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!',
      'foo@'.repeat(500) + 'bar.com',
      '<'.repeat(1000) + '>'
    ];
  }
  
  static comparePatterns(patterns, testInput) {
    const results = {};
    
    for (const [name, pattern] of Object.entries(patterns)) {
      const result = this.testVulnerability(pattern, testInput);
      results[name] = result;
    }
    
    return results;
  }
}

// Примеры уязвимых и безопасных паттернов
const patternsToTest = {
  'Уязвимый: (a+)+': '(a+)+',
  'Безопасный: a+': 'a+',
  'Уязвимый: (a|aa)+': '(a|aa)+',
  'Безопасный: a++': 'a++', // atomic group (не поддерживается в JS)
  'Реальный пример: email (уязвимый)': '^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$',
  'Реальный пример: email (безопасный)': '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$'
};

// Тестирование на уязвимость
const maliciousInput = 'a'.repeat(1000) + '!';
const vulnerabilityResults = RedosDetector.comparePatterns(patternsToTest, maliciousInput);

for (const [name, result] of Object.entries(vulnerabilityResults)) {
  console.log(`${name}: время=${result.time}ms, уязвим=${result.vulnerable}`);
}
```

## Практические примеры оптимизации

### Оптимизация парсинга логов

```javascript
class OptimizedLogParser {
  constructor() {
    // Кэшируем регулярные выражения
    this.regexCache = new Map();
  }
  
  getRegex(pattern, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.regexCache.has(key)) {
      this.regexCache.set(key, new RegExp(pattern, flags));
    }
    return this.regexCache.get(key);
  }
  
  // Неоптимизированный парсер
  parseLogLineBad(line) {
    // Создает новое регулярное выражение каждый раз
    const match = line.match(/^(\S+) (\S+) (\S+) \[([^\]]+)\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-)$/);
    if (!match) return null;
    
    return {
      ip: match[1],
      timestamp: match[4],
      method: match[5],
      url: match[6],
      status: parseInt(match[8]),
      size: match[9] === '-' ? 0 : parseInt(match[9])
    };
  }
  
  // Оптимизированный парсер
  parseLogLineGood(line) {
    // Использует кэшированное регулярное выражение
    const regex = this.getRegex(/^(\S+) (\S+) (\S+) \[([^\]]+)\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+|-)$/, '');
    const match = regex.exec(line);
    if (!match) return null;
    
    return {
      ip: match[1],
      timestamp: match[4],
      method: match[5],
      url: match[6],
      status: parseInt(match[8]),
      size: match[9] === '-' ? 0 : parseInt(match[9])
    };
  }
  
  // Парсинг множественных логов
  parseLogLines(lines) {
    const results = [];
    for (const line of lines) {
      const parsed = this.parseLogLineGood(line);
      if (parsed) {
        results.push(parsed);
      }
    }
    return results;
  }
  
  // Извлечение конкретных данных без полного парсинга
  extractStatuses(lines) {
    const statusRegex = this.getRegex(/\s(\d{3})\s/g, 'g');
    const statuses = [];
    
    for (const line of lines) {
      let match;
      while ((match = statusRegex.exec(line)) !== null) {
        statuses.push(parseInt(match[1]));
      }
    }
    
    return statuses;
  }
}

// Сравнение производительности
const sampleLogs = [
  '192.168.1.1 - - [25/Dec/2023:10:00:00 +0000] "GET /index.html HTTP/1.1" 200 1234',
  '10.0.0.1 - - [25/Dec/2023:10:01:00 +0000] "POST /api/users HTTP/1.1" 201 567',
  '192.168.1.1 - - [25/Dec/2023:10:02:00 +0000] "GET /about HTTP/1.1" 404 234'
].repeat(100).split(',');

console.time('Неоптимизированный парсер');
for (let i = 0; i < 1000; i++) {
  sampleLogs.forEach(log => OptimizedLogParser.prototype.parseLogLineBad(log));
}
console.timeEnd('Неоптимизированный парсер');

const optimizedParser = new OptimizedLogParser();
console.time('Оптимизированный парсер');
for (let i = 0; i < 1000; i++) {
  sampleLogs.forEach(log => optimizedParser.parseLogLineGood(log));
}
console.timeEnd('Оптимизированный парсер');
```

### Оптимизация обработки пользовательского ввода

```javascript
class OptimizedInputProcessor {
  constructor() {
    this.compiledPatterns = {
      email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      phone: /^\+?[\d\s\-\(\)]{7,15}$/,
      url: /^https?:\/\/[\w\.-]+\.[a-zA-Z]{2,}(?:\/[\w\.-]*)*\/?$/,
      creditCard: /^\d{4}[ -]?\d{4}[ -]?\d{4}[ -]?\d{4}$/,
      date: /^\d{4}-\d{2}-\d{2}$/
    };
  }
  
  // Быстрая проверка типа данных
  identifyInputType(input) {
    // Проверяем по длине и формату
    if (input.includes('@') && input.includes('.')) {
      return 'email';
    } else if (/^[\d\s\-\(\)+]{7,20}$/.test(input) && /\d/.test(input)) {
      return 'phone';
    } else if (/^https?:\/\//.test(input)) {
      return 'url';
    } else if (/^\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}$/.test(input)) {
      return 'creditCard';
    } else if (/^\d{4}-\d{2}-\d{2}$/.test(input)) {
      return 'date';
    }
    
    return 'unknown';
  }
  
  // Быстрая валидация
  validate(input, type = null) {
    if (!type) {
      type = this.identifyInputType(input);
    }
    
    const pattern = this.compiledPatterns[type];
    if (!pattern) {
      return false;
    }
    
    return pattern.test(input);
  }
  
  // Быстрая очистка
  sanitize(input, type) {
    switch (type) {
      case 'phone':
        return input.replace(/[^\d+]/g, '');
      case 'creditCard':
        return input.replace(/[^\d]/g, '');
      case 'url':
        return input.toLowerCase();
      default:
        return input;
    }
  }
  
  // Пакетная обработка
  processBatch(inputs) {
    const results = [];
    
    for (const input of inputs) {
      const type = this.identifyInputType(input);
      const isValid = this.validate(input, type);
      const sanitized = this.sanitize(input, type);
      
      results.push({
        original: input,
        type,
        isValid,
        sanitized
      });
    }
    
    return results;
  }
}

// Пример использования
const inputProcessor = new OptimizedInputProcessor();
const testInputs = [
  'user@example.com',
  '+7 (926) 123-45-67',
  'https://example.com',
  '4111 1111 1111 1111',
  '2023-12-25'
];

console.time('Пакетная обработка');
const results = inputProcessor.processBatch(testInputs);
console.timeEnd('Пакетная обработка');

console.log('Результаты обработки:', results);
```

## Заключение

Для повышения производительности регулярных выражений рекомендуется:

1. Кэшировать регулярные выражения при многократном использовании
2. Избегать чрезмерной сложности паттернов
3. Использовать незахватывающие группы, когда не нужны захваченные данные
4. Тестировать паттерны на уязвимость к ReDoS
5. Разбивать сложные задачи на несколько простых регулярных выражений
6. Использовать альтернацию эффективно
7. Измерять производительность в реальных условиях

Оптимизация регулярных выражений особенно важна в высоконагруженных приложениях, где они выполняются часто или на больших объемах данных.

## Следующие шаги

После изучения оптимизации производительности рекомендуется:

- [[Распространенные ошибки и как их избегать]]
- [[Продвинутые паттерны и их применение]]
- [[Продвинутые темы]]