---
tags: [programming, regexp, patterns, frontend, javascript, advanced]
aliases: [продвинутые-паттерны-и-их-применение, advanced-regexp-patterns]
---

# Продвинутые паттерны и их применение

В этой статье рассмотрим сложные и продвинутые паттерны регулярных выражений, которые находят применение в веб-разработке. Эти паттерны позволяют решать более сложные задачи обработки текста и анализа данных.

## Опережающие и ретроспективные проверки

### Позитивные и негативные опережающие проверки

```javascript
// Позитивная опережающая проверка (?=...)
// Проверяет, что за текущей позицией следует определенный паттерн, но не включает его в результат

// Найти все слова, за которыми следует цифра
const textWithWordsAndNumbers = "word1 test2 abc def3 end";
const wordsBeforeNumber = textWithWordsAndNumbers.match(/\w+(?=\d)/g);
console.log('Слова перед цифрами:', wordsBeforeNumber); // ['word', 'test', 'def']

// Негативная опережающая проверка (?!...)
// Проверяет, что за текущей позицией НЕ следует определенный паттерн

// Найти все слова, за которыми НЕ следует цифра
const wordsNotBeforeNumber = textWithWordsAndNumbers.match(/\w+(?!\d)/g);
console.log('Слова не перед цифрами:', wordsNotBeforeNumber); // ['word1', 'test2', 'abc', 'end']

// Практический пример: валидация сложного пароля
class AdvancedPasswordValidator {
  // Пароль должен содержать: минимум 8 символов, одну заглавную, одну строчную, одну цифру
  // и один специальный символ, но не содержать последовательностей типа "123", "abc"
  static validate(password) {
    // Проверки через опережающие проверки
    const checks = {
      length: /^(?=.{8,})/,           // минимум 8 символов
      uppercase: /^(?=.*[A-Z])/,      // содержит заглавную
      lowercase: /^(?=.*[a-z])/,      // содержит строчную
      number: /^(?=.*\d)/,            // содержит цифру
      special: /^(?=.*[!@#$%^&*()_+])/ // содержит специальный символ
    };
    
    // Проверки на запрещенные последовательности
    const forbidden = {
      sequential: /^(?!.*(?:012|123|234|345|456|567|678|789|890|abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz))/,
      repeated: /^(?!.*(.)\1{2,})/    // не содержит 3+ повторяющихся символов
    };
    
    // Комбинируем все проверки
    const allChecks = [
      ...Object.values(checks),
      ...Object.values(forbidden)
    ];
    
    return allChecks.every(regex => regex.test(password));
  }
  
  // Более подробная валидация с отчетом
  static validateWithReport(password) {
    const checks = {
      length: { regex: /^(?=.{8,})/, description: 'минимум 8 символов' },
      uppercase: { regex: /^(?=.*[A-Z])/, description: 'заглавная буква' },
      lowercase: { regex: /^(?=.*[a-z])/, description: 'строчная буква' },
      number: { regex: /^(?=.*\d)/, description: 'цифра' },
      special: { regex: /^(?=.*[!@#$%^&*()_+])/, description: 'специальный символ' },
      noSequential: { regex: /^(?!.*(?:012|123|234|abc|bcd|cde))/, description: 'без последовательностей' },
      noRepeats: { regex: /^(?!.*(.)\1{2,})/, description: 'без 3+ повторений' }
    };
    
    const result = {
      isValid: true,
      failedChecks: []
    };
    
    for (const [name, check] of Object.entries(checks)) {
      if (!check.regex.test(password)) {
        result.isValid = false;
        result.failedChecks.push(check.description);
      }
    }
    
    return result;
  }
}

// Примеры
const passwords = ['WeakPass1', 'Str0ng!Pass', 'aaa123!@#', 'ComplexPass123!'];
passwords.forEach(pwd => {
  console.log(`${pwd}: ${AdvancedPasswordValidator.validate(pwd)}`);
  console.log('  Отчет:', AdvancedPasswordValidator.validateWithReport(pwd));
});
```

### Позитивные и негативные ретроспективные проверки

```javascript
// Ретроспективные проверки (ES2018+) - проверяют, что перед текущей позицией следует (или не следует) паттерн

// Позитивная ретроспективная проверка (?<=...)
// Найти числа, перед которыми стоит знак доллара (цены)
const priceText = "Цена: $10.99, скидка: $5.50, налог: 1.50, итого: $18.00";
const prices = priceText.match(/(?<=\$)\d+(?:\.\d{2})/g);
console.log('Цены (с $):', prices); // ['10.99', '5.50']

// Негативная ретроспективная проверка (?<!...)
// Найти числа, перед которыми НЕ стоит знак доллара
const nonPrices = priceText.match(/(?<!\$)\b\d+(?:\.\d{2})\b/g);
console.log('Не цены:', nonPrices); // ['1.50']

// Практический пример: извлечение единиц измерения без цен
class MeasurementExtractor {
  static extractMeasurements(text) {
    // Извлекаем числа с единицами измерения, но не цены
    const measurementRegex = /(?<!\$)\b\d+(?:\.\d+)?\s*(кг|г|л|м|см|мм|км|т|мл|мг|шт|ед)\b/gi;
    return text.match(measurementRegex) || [];
  }
  
  static extractPrices(text) {
    // Извлекаем цены (числа после $, €, £ и т.д.)
    const priceRegex = /(?<=[$€£¥])\d+(?:\.\d{2})?|(?<!\w)(?:\d+(?:\.\d{2})?\s*[$€£¥])/g;
    return text.match(priceRegex) || [];
  }
  
  // Извлечение процентов (числа перед %)
  static extractPercentages(text) {
    const percentRegex = /(?<!\w)\d+(?:\.\d+)?(?=%)/g;
    return text.match(percentRegex) || [];
  }
}

const measurementText = "Вес: 2.5кг, объем: 1.5л, цена: $25.99, скидка: 15%, длина: 100см";
console.log('Измерения:', MeasurementExtractor.extractMeasurements(measurementText));
console.log('Проценты:', MeasurementExtractor.extractPercentages(measurementText));
```

## Атомарные группы и притязательные квантификаторы

### Атомарные группы (не поддерживаются в JavaScript, но важно понимать концепцию)

```javascript
// JavaScript не поддерживает атомарные группы вида (?>...), 
// но мы можем использовать незахватывающие группы и другие методы для оптимизации

class AtomicPatternEmulator {
  // Эмуляция атомарной группы для предотвращения backtracking
  // Вместо (?>a+)b используем a++b (если бы поддерживалось)
  
  // Плохой паттерн, который может вызвать ReDoS
  static problematicPattern = /(a+)+b/;
  
  // Оптимизированный паттерн
  static optimizedPattern = /a+b/;
  
  // Пример сложной валидации без вложенных квантификаторов
  static validateComplexPattern(input) {
    // Вместо сложного регулярного выражения с вложенными квантификаторами
    // разбиваем на несколько простых проверок
    
    // Проверяем структуру вручную
    if (!/^[a-zA-Z0-9_]+$/.test(input)) {
      return false;
    }
    
    // Дополнительные проверки
    const parts = input.split(/(?=[A-Z])/); // Разделение по заглавным буквам
    if (parts.length < 2) {
      return false;
    }
    
    // Проверяем, что каждая часть не пустая
    return parts.every(part => part.length > 0);
  }
  
  // Использование незахватывающих групп для оптимизации
  static extractVersionInfo(text) {
    // Паттерн для извлечения версии (например, "v1.2.3" или "version 2.5.1")
    // Используем незахватывающие группы для оптимизации
    const versionRegex = /(?:version\s+|v)(\d+)\.(\d+)\.(\d+)/gi;
    const matches = [...text.matchAll(versionRegex)];
    
    return matches.map(match => ({
      full: match[0],
      major: match[1],
      minor: match[2],
      patch: match[3],
      index: match.index
    }));
  }
}

const versionText = "Приложение v1.2.3, библиотека version 2.5.1, устаревшая версия 0.9.8";
console.log('Версии:', AtomicPatternEmulator.extractVersionInfo(versionText));
```

## Сложные паттерны с именованными группами

```javascript
// Использование именованных групп для сложного парсинга
class NamedGroupParser {
  // Паттерн для парсинга логов с именованными группами
  static logPattern = /^(?<timestamp>\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+(?<level>\w+)\s+\[(?<thread>[^\]]+)\]\s+(?<logger>[^:]+):\s+(?<message>.*)$/;
  
  // Паттерн для парсинга даты и времени с именованными группами
  static dateTimePattern = /^(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})\s+(?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2})(?:\.(?<millis>\d{3}))?$/;
  
  // Паттерн для парсинга URL с именованными группами
  static urlPattern = /^(?<protocol>https?):\/\/(?<domain>[\w.-]+)(?::(?<port>\d+))?\/(?<path>[^\s\?#]*)(?:\?(?<query>[^#]*))?(?:#(?<fragment>.*))?$/;
  
  // Паттерн для парсинга email с именованными группами
  static emailPattern = /^(?<local>[^@]+)@(?<domain>[^@]+\.([a-zA-Z]{2,}))$/;
  
  static parseLog(logLine) {
    const match = logLine.match(this.logPattern);
    return match ? match.groups : null;
  }
  
  static parseDateTime(dateTimeString) {
    const match = dateTimeString.match(this.dateTimePattern);
    return match ? match.groups : null;
  }
  
  static parseUrl(url) {
    const match = url.match(this.urlPattern);
    return match ? match.groups : null;
  }
  
  static parseEmail(email) {
    const match = email.match(this.emailPattern);
    return match ? match.groups : null;
  }
  
  // Сложный паттерн для извлечения информации из строки запроса
  static parseQueryString(queryString) {
    // Паттерн для извлечения пар параметр=значение
    const paramPattern = /(?<key>[^=&\s]+)=(?<value>[^&\s]*)/g;
    const matches = [...queryString.matchAll(paramPattern)];
    
    const params = {};
    matches.forEach(match => {
      params[decodeURIComponent(match.groups.key)] = decodeURIComponent(match.groups.value);
    });
    
    return params;
  }
}

// Примеры использования
const logLine = "2023-12-25 14:30:00 INFO [main] com.example.App: Application started successfully";
const dateTime = "2023-12-25 14:30:00.123";
const url = "https://api.example.com:8080/v1/users?id=123&format=json#section";
const email = "user.name+tag@example.co.uk";

console.log('Парсинг лога:', NamedGroupParser.parseLog(logLine));
console.log('Парсинг даты/времени:', NamedGroupParser.parseDateTime(dateTime));
console.log('Парсинг URL:', NamedGroupParser.parseUrl(url));
console.log('Парсинг email:', NamedGroupParser.parseEmail(email));
console.log('Парсинг строки запроса:', NamedGroupParser.parseQueryString("name=John&age=30&city=Moscow"));
```

## Рекурсивные паттерны и альтернативы

```javascript
// JavaScript не поддерживает истинную рекурсию в регулярных выражениях,
// но мы можем использовать альтернативные подходы

class RecursivePatternAlternatives {
  // Извлечение вложенных скобок с помощью итерации
  static extractNestedBrackets(text) {
    const results = [];
    let stack = [];
    let current = '';
    
    for (const char of text) {
      if (char === '(') {
        if (stack.length > 0) {
          current += char; // Добавляем к текущему, если уже внутри скобок
        }
        stack.push(char);
      } else if (char === ')') {
        stack.pop();
        if (stack.length > 0) {
          current += char; // Добавляем к текущему, если еще внутри скобок
        } else if (stack.length === 0) {
          results.push(current);
          current = '';
        }
      } else if (stack.length > 0) {
        current += char; // Добавляем символ, если внутри скобок
      }
    }
    
    return results;
  }
  
  // Извлечение вложенных фигурных скобок (для JSON-подобных структур)
  static extractNestedCurlyBraces(text) {
    const results = [];
    let depth = 0;
    let current = '';
    
    for (const char of text) {
      if (char === '{') {
        if (depth > 0) current += char;
        depth++;
      } else if (char === '}') {
        depth--;
        if (depth > 0) {
          current += char;
        } else if (depth === 0) {
          results.push(current);
          current = '';
        }
      } else if (depth > 0) {
        current += char;
      }
    }
    
    return results;
  }
  
  // Парсинг HTML с ограниченной вложенностью
  static parseSimpleHtml(html) {
    // Простой парсинг тегов с ограниченной вложенностью
    const tagRegex = /<(\w+)([^>]*)>(.*?)<\/\1>/gs;
    const matches = [...html.matchAll(tagRegex)];
    
    return matches.map(match => ({
      tag: match[1],
      attributes: match[2].trim(),
      content: match[3]
    }));
  }
  
  // Извлечение вложенных квадратных скобок (для массивов)
  static extractNestedArrays(text) {
    const results = [];
    let depth = 0;
    let current = '';
    
    for (const char of text) {
      if (char === '[') {
        if (depth > 0) current += char;
        depth++;
      } else if (char === ']') {
        depth--;
        if (depth > 0) {
          current += char;
        } else if (depth === 0) {
          results.push(current);
          current = '';
        }
      } else if (depth > 0) {
        current += char;
      }
    }
    
    return results;
  }
  
  // Проверка сбалансированности скобок
  static isBalanced(text, pairs = { '(': ')', '[': ']', '{': '}' }) {
    const stack = [];
    const opening = Object.keys(pairs);
    const closing = Object.values(pairs);
    
    for (const char of text) {
      if (opening.includes(char)) {
        stack.push(char);
      } else if (closing.includes(char)) {
        const last = stack.pop();
        if (!last || pairs[last] !== char) {
          return false;
        }
      }
    }
    
    return stack.length === 0;
  }
}

// Примеры использования
const nestedText = "(внешняя(вложенная(еще_вложенная)часть)и)нечто(другое(вложение))";
console.log('Вложенные скобки:', RecursivePatternAlternatives.extractNestedBrackets(nestedText));

const nestedCurly = "{ключ: {вложенный: {еще: 'значение'}}, другой: 'значение'}";
console.log('Вложенные фигурные скобки:', RecursivePatternAlternatives.extractNestedCurlyBraces(nestedCurly));

const simpleHtml = "<div>Контент<p>Вложенный контент</p></div><span>Другой контент</span>";
console.log('Простой HTML:', RecursivePatternAlternatives.parseSimpleHtml(simpleHtml));

const arrayText = "[1, 2, [3, 4, [5, 6]], 7]";
console.log('Вложенные массивы:', RecursivePatternAlternatives.extractNestedArrays(arrayText));

console.log('Сбалансированность:', RecursivePatternAlternatives.isBalanced("({[]})")); // true
console.log('Сбалансированность:', RecursivePatternAlternatives.isBalanced("({[}])")); // false
```

## Продвинутые паттерны для веб-безопасности

```javascript
class SecurityPatternValidator {
  // Паттерны для обнаружения потенциально опасного кода
  static dangerousPatterns = {
    // XSS попытки
    xss: /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>|javascript:/gi,
    
    // SQL-инъекции (упрощенные)
    sqlInjection: /(?:\b(?:SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|OR|AND)\b.*(?:FROM|WHERE|VALUES|SET)\b)/gi,
    
    // Command injection
    commandInjection: /[;&|`]/g,
    
    // Path traversal
    pathTraversal: /\.\.\/|\.\.\\/g,
    
    // Dangerous HTML attributes
    dangerousAttributes: /on\w+\s*=/gi
  };
  
  // Проверка на XSS
  static checkXSS(input) {
    return this.dangerousPatterns.xss.test(input);
  }
  
  // Санитизация HTML
  static sanitizeHtml(input) {
    return input
      .replace(this.dangerousPatterns.xss, '') // Удаляем скрипты
      .replace(this.dangerousPatterns.dangerousAttributes, '') // Удаляем обработчики событий
      .replace(/</g, '&lt;') // Экранируем угловые скобки
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }
  
  // Проверка на SQL-инъекции
  static checkSqlInjection(input) {
    return this.dangerousPatterns.sqlInjection.test(input);
  }
  
  // Проверка на command injection
  static checkCommandInjection(input) {
    return this.dangerousPatterns.commandInjection.test(input);
  }
  
  // Проверка на path traversal
  static checkPathTraversal(input) {
    return this.dangerousPatterns.pathTraversal.test(input);
  }
  
  // Комплексная проверка безопасности
  static checkSecurity(input) {
    const checks = {
      xss: this.checkXSS(input),
      sqlInjection: this.checkSqlInjection(input),
      commandInjection: this.checkCommandInjection(input),
      pathTraversal: this.checkPathTraversal(input)
    };
    
    const hasIssues = Object.values(checks).some(check => check);
    
    return {
      isSafe: !hasIssues,
      issues: Object.entries(checks)
        .filter(([_, hasIssue]) => hasIssue)
        .map(([type, _]) => type),
      checks
    };
  }
  
  // Создание безопасного идентификатора
  static createSafeIdentifier(input) {
    // Удаляем все символы, кроме букв, цифр и подчеркивания
    return input
      .replace(/[^a-zA-Z0-9_]/g, '_')
      .replace(/^(\d)/, '_$1'); // Не начинаем с цифры
  }
}

// Примеры
const dangerousInputs = [
  '<script>alert("XSS")</script>',
  'user\' OR 1=1--',
  'file.txt; rm -rf /',
  '../../../etc/passwd',
  'valid input'
];

dangerousInputs.forEach(input => {
  console.log(`Проверка "${input}":`, SecurityPatternValidator.checkSecurity(input));
});

console.log('Безопасный идентификатор:', SecurityPatternValidator.createSafeIdentifier('user-input@123'));
```

## Паттерны для анализа кода

```javascript
class CodeAnalyzer {
  // Паттерны для анализа JavaScript кода
  static jsPatterns = {
    // Извлечение функций
    functions: /(?:function\s+)?([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g,
    
    // Извлечение переменных
    variables: /\b(?:var|let|const)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g,
    
    // Извлечение вызовов методов
    methodCalls: /([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\.\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g,
    
    // Извлечение импортов
    imports: /(?:import\s+|from\s+|require\(\s*)["'](.*?\.(?:js|ts|jsx|tsx))["']/g,
    
    // Извлечение комментариев
    comments: /(?:\/\/.*$|\/\*[\s\S]*?\*\/)/gm,
    
    // Извлечение строк
    strings: /(["'])((?:(?!\1)[^\\]|\\.)*)(\1)/g
  };
  
  // Анализ функций в коде
  static extractFunctions(code) {
    const matches = [...code.matchAll(this.jsPatterns.functions)];
    return [...new Set(matches.map(match => match[1]))]; // Уникальные имена функций
  }
  
  // Анализ переменных в коде
  static extractVariables(code) {
    const matches = [...code.matchAll(this.jsPatterns.variables)];
    return [...new Set(matches.map(match => match[1]))]; // Уникальные имена переменных
  }
  
  // Анализ вызовов методов
  static extractMethodCalls(code) {
    const matches = [...code.matchAll(this.jsPatterns.methodCalls)];
    return matches.map(match => `${match[1]}.${match[2]}`);
  }
  
  // Извлечение импортов
  static extractImports(code) {
    const matches = [...code.matchAll(this.jsPatterns.imports)];
    return [...new Set(matches.map(match => match[1]))]; // Уникальные импорты
  }
  
  // Извлечение комментариев
  static extractComments(code) {
    return code.match(this.jsPatterns.comments) || [];
  }
  
  // Извлечение строковых литералов
  static extractStrings(code) {
    const matches = [...code.matchAll(this.jsPatterns.strings)];
    return matches.map(match => match[2]); // Только содержимое строк, без кавычек
  }
  
  // Анализ кода и извлечение всех элементов
  static analyzeCode(code) {
    return {
      functions: this.extractFunctions(code),
      variables: this.extractVariables(code),
      methodCalls: this.extractMethodCalls(code),
      imports: this.extractImports(code),
      comments: this.extractComments(code),
      strings: this.extractStrings(code)
    };
  }
  
  // Поиск потенциально опасных функций
  static findDangerousFunctions(code) {
    const dangerousFunctions = [
      'eval', 'Function', 'setTimeout', 'setInterval', 'execScript',
      'innerHTML', 'outerHTML', 'document.write', 'location.href'
    ];
    
    const dangerousPattern = new RegExp(`\\b(${dangerousFunctions.join('|')})\\b`, 'g');
    const matches = [...code.matchAll(dangerousPattern)];
    
    return [...new Set(matches.map(match => match[1]))];
  }
}

// Пример анализа кода
const sampleCode = `
import { Component } from 'react';
import { utils } from './utils.js';

const myVar = "Hello World";
let counter = 0;

function myFunction(param) {
  document.getElementById('test').innerHTML = param;
  setTimeout(() => console.log('Delayed'), 1000);
  // Это комментарий
  /* 
    Это
    многострочный
    комментарий
  */
  return utils.process(counter);
}

class MyClass {
  method() {
    eval("some code");
  }
}
`;

const analysis = CodeAnalyzer.analyzeCode(sampleCode);
console.log('Анализ кода:', analysis);

const dangerous = CodeAnalyzer.findDangerousFunctions(sampleCode);
console.log('Потенциально опасные функции:', dangerous);
```

## Паттерны для обработки естественного языка

```javascript
class NaturalLanguageProcessor {
  // Паттерны для обработки текста на естественном языке
  static nlpPatterns = {
    // Извлечение предложений
    sentences: /[.!?]+/g,
    
    // Извлечение слов
    words: /[\p{L}\p{N}]+/gu,
    
    // Извлечение аббревиатур
    abbreviations: /\b[A-Z]{2,}\b|\b[A-Z][a-z]*[A-Z][a-z]*\b/g,
    
    // Извлечение имен собственных (упрощенно)
    properNouns: /\b[A-Z][a-zа-яё]+\b/g,
    
    // Извлечение чисел и числовых выражений
    numbers: /\b\d+(?:[.,]\d+)?(?:\s*(?:тыс|млн|млрд|k|M|B))?\b/gi,
    
    // Извлечение денежных выражений
    money: /(?:\$|€|£|¥|₽|USD|EUR|GBP|RUB)\s*\d+(?:[.,]\d{2})?|\d+(?:[.,]\d{2})?\s*(?:\$|€|£|¥|₽|USD|EUR|GBP|RUB)/gi,
    
    // Извлечение процентов
    percentages: /\b\d+(?:[.,]\d+)?\s*%|\b\d+(?:[.,]\d+)?\s*процентов?\b/gi
  };
  
  // Разделение текста на предложения
  static splitToSentences(text) {
    const sentences = text.split(this.nlpPatterns.sentences);
    return sentences.filter(s => s.trim().length > 0).map(s => s.trim());
  }
  
  // Извлечение слов
  static extractWords(text) {
    return text.match(this.nlpPatterns.words) || [];
  }
  
  // Извлечение аббревиатур
  static extractAbbreviations(text) {
    return [...new Set(text.match(this.nlpPatterns.abbreviations) || [])];
  }
  
  // Извлечение имен собственных
  static extractProperNouns(text) {
    return [...new Set(text.match(this.nlpPatterns.properNouns) || [])];
  }
  
  // Извлечение чисел
  static extractNumbers(text) {
    return text.match(this.nlpPatterns.numbers) || [];
  }
  
  // Извлечение денежных выражений
  static extractMoney(text) {
    return text.match(this.nlpPatterns.money) || [];
  }
  
  // Извлечение процентов
  static extractPercentages(text) {
    return text.match(this.nlpPatterns.percentages) || [];
  }
  
  // Анализ текста
  static analyzeText(text) {
    return {
      sentences: this.splitToSentences(text),
      words: this.extractWords(text),
      abbreviations: this.extractAbbreviations(text),
      properNouns: this.extractProperNouns(text),
      numbers: this.extractNumbers(text),
      money: this.extractMoney(text),
      percentages: this.extractPercentages(text)
    };
  }
  
  // Подсчет сложности текста (упрощенно)
  static calculateTextComplexity(text) {
    const sentences = this.splitToSentences(text);
    const words = this.extractWords(text);
    
    // Индекс удобочитаемости Флеша (упрощенный)
    const avgWordsPerSentence = words.length / sentences.length;
    
    // Подсчет сложных слов (длиннее 3 слогов - упрощенно)
    const complexWords = words.filter(word => word.length > 6).length;
    const percentComplexWords = (complexWords / words.length) * 100;
    
    // Упрощенный индекс Флеша
    const fleschIndex = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * (complexWords / words.length));
    
    return {
      totalSentences: sentences.length,
      totalWords: words.length,
      avgWordsPerSentence: avgWordsPerSentence,
      percentComplexWords: percentComplexWords,
      fleschIndex: fleschIndex,
      readability: fleschIndex > 60 ? 'Простой' : fleschIndex > 30 ? 'Средний' : 'Сложный'
    };
  }
}

// Пример анализа текста
const sampleText = `
Компания Apple (AAPL) объявила о рекордной прибыли в размере $100.5 млрд за квартал. 
Это на 15% выше, чем в прошлом году. Рост составил 3.5%. 
CEO Тим Кук отметил, что компания продолжит инвестировать в R&D и D&A.
Общее количество сотрудников достигло 150 тыс. человек.
`;

const textAnalysis = NaturalLanguageProcessor.analyzeText(sampleText);
console.log('Анализ текста:', textAnalysis);

const complexity = NaturalLanguageProcessor.calculateTextComplexity(sampleText);
console.log('Сложность текста:', complexity);
```

## Практические примеры сложных паттернов

### Обработка конфигурационных файлов

```javascript
class ConfigParser {
  // Паттерны для парсинга конфигурационных файлов (типа INI/properties)
  static patterns = {
    // Комментарии
    comment: /^\s*[#;].*$/,
    
    // Секции
    section: /^\s*\[([^\]]+)\]\s*$/,
    
    // Пары ключ=значение
    keyValue: /^\s*([a-zA-Z0-9_.-]+)\s*=\s*(.*?)\s*$/,
    
    // Массивы (упрощенно)
    array: /^\s*([a-zA-Z0-9_.-]+)\s*=\s*\[(.*?)\]\s*$/
  };
  
  static parseConfig(configText) {
    const lines = configText.split('\n');
    const config = {};
    let currentSection = null;
    
    for (const line of lines) {
      // Пропускаем пустые строки и комментарии
      if (!line.trim() || this.patterns.comment.test(line)) {
        continue;
      }
      
      // Проверяем секцию
      const sectionMatch = line.match(this.patterns.section);
      if (sectionMatch) {
        currentSection = sectionMatch[1];
        config[currentSection] = {};
        continue;
      }
      
      // Проверяем пару ключ-значение
      const keyValueMatch = line.match(this.patterns.keyValue);
      if (keyValueMatch) {
        const key = keyValueMatch[1];
        let value = keyValueMatch[2];
        
        // Попытка парсинга массивов
        if (value.startsWith('[') && value.endsWith(']')) {
          value = value.slice(1, -1).split(',').map(v => v.trim());
        } else if (value.toLowerCase() === 'true') {
          value = true;
        } else if (value.toLowerCase() === 'false') {
          value = false;
        } else if (/^\d+$/.test(value)) {
          value = parseInt(value);
        } else if (/^\d+\.\d+$/.test(value)) {
          value = parseFloat(value);
        }
        
        if (currentSection) {
          config[currentSection][key] = value;
        } else {
          config[key] = value;
        }
      }
    }
    
    return config;
  }
}

const configText = `
# Комментарий
[database]
host = localhost
port = 5432
ssl = true

[features]
modules = [auth, api, admin]
timeout = 30.5

debug = false
name = MyApp
`;

console.log('Разбор конфигурации:', ConfigParser.parseConfig(configText));
```

## Заключение

Продвинутые паттерны регулярных выражений позволяют:

1. **Использовать опережающие и ретроспективные проверки** для более точного контроля над сопоставлением
2. **Применять именованные группы** для улучшения читаемости и структурированного извлечения данных
3. **Создавать безопасные паттерны** для обработки пользовательского ввода
4. **Анализировать сложные структуры данных** как альтернативу полному парсеру
5. **Решать задачи естественного языка** на базовом уровне

При использовании продвинутых паттернов важно помнить о производительности и безопасности. Для очень сложных задач может быть лучше использовать специализированные парсеры.

## Следующие шаги

После изучения продвинутых паттернов рекомендуется:

- [[Распространенные ошибки и как их избегать]]
- [[Повышение производительности регулярных выражений]]
- [[Продвинутые темы]]