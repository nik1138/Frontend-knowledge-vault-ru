---
aliases: ["Сложные задачи regexp", "Продвинутые регулярные выражения"]
tags: [regexp, advanced, frontend, problem-solving]
---

# Решение сложных задач с помощью регулярных выражений

Регулярные выражения - мощный инструмент, способный решать сложные задачи обработки текста. В этой статье рассмотрим примеры решения нетривиальных задач, часто встречающихся в фронтенд-разработке.

## Задача 1: Извлечение и валидация вложенных структур

Одной из сложных задач является обработка вложенных структур, таких как HTML-теги или JSON-подобные объекты.

```javascript
// Пример: извлечение содержимого вложенных HTML-тегов
function extractNestedContent(html, tagName) {
    // Регулярное выражение для извлечения содержимого тега с учетом вложенности
    // Используем рекурсивную структуру с помощью балансировки скобок
    const regex = new RegExp(`<${tagName}(?:\\s[^>]*)?>([^<]*(?:<(?!/${tagName}\\s*>)[^<]*)*)</${tagName}>`, 'gi');
    
    const matches = [];
    let match;
    
    while ((match = regex.exec(html)) !== null) {
        matches.push(match[1]);
    }
    
    return matches;
}

// Пример использования
const html = `
<div>
    <div>Вложенный контент <span>еще один уровень</span></div>
    <div>Еще один div</div>
</div>`;

const nestedDivs = extractNestedContent(html, 'div');
console.log(nestedDivs);
```

## Задача 2: Парсинг сложных форматов данных

Рассмотрим задачу парсинга строки с параметрами, как в URL или в конфигурационных файлах:

```javascript
// Парсинг строки параметров с поддержкой кавычек
function parseParameterString(paramString) {
    // Регулярное выражение для извлечения пар ключ=значение, учитывая кавычки
    const paramRegex = /(\w+)=("[^"]*"|'[^']*'|[^\s]*)/g;
    
    const params = {};
    let match;
    
    while ((match = paramRegex.exec(paramString)) !== null) {
        const key = match[1];
        let value = match[2];
        
        // Удаление кавычек, если они есть
        if ((value.startsWith('"') && value.endsWith('"')) || 
            (value.startsWith("'") && value.endsWith("'"))) {
            value = value.substring(1, value.length - 1);
        }
        
        params[key] = value;
    }
    
    return params;
}

// Пример использования
const paramString = 'name="John Doe" age=30 city="New York" active=true';
const params = parseParameterString(paramString);
console.log(params); // { name: "John Doe", age: "30", city: "New York", active: "true" }
```

## Задача 3: Валидация и форматирование сложных данных

Создадим валидатор для сложных форматов данных, таких как банковские карты с различными форматами:

```javascript
class CardValidator {
    constructor() {
        // Регулярные выражения для различных типов карт
        this.patterns = {
            visa: /^4[0-9]{12}(?:[0-9]{3})?$/,
            mastercard: /^5[1-5][0-9]{14}$/,
            amex: /^3[47][0-9]{13}$/,
            diners: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
            discover: /^6(?:011|5[0-9]{2})[0-9]{12}$/,
            jcb: /^(?:2131|1800|35\d{3})\d{11}$/
        };
        
        // Регулярное выражение для форматирования номера карты
        this.formatRegex = /(\d{4})(\d{4})(\d{4})(\d{4})/;
    }
    
    validate(cardNumber) {
        // Удаляем все нецифровые символы
        const cleanNumber = cardNumber.replace(/\D/g, '');
        
        for (const [type, pattern] of Object.entries(this.patterns)) {
            if (pattern.test(cleanNumber)) {
                return { isValid: true, type };
            }
        }
        
        return { isValid: false, type: null };
    }
    
    format(cardNumber) {
        const cleanNumber = cardNumber.replace(/\D/g, '');
        
        if (cleanNumber.length === 16) {
            return cleanNumber.replace(this.formatRegex, '$1 $2 $3 $4');
        } else if (cleanNumber.length === 15) {
            // Для American Express
            return cleanNumber.replace(/^(\d{4})(\d{6})(\d{5})$/, '$1 $2 $3');
        }
        
        return cardNumber; // Возвращаем как есть, если не поддерживаемый формат
    }
}

// Пример использования
const validator = new CardValidator();
console.log(validator.validate("4111111111111111")); // { isValid: true, type: "visa" }
console.log(validator.format("4111111111111111")); // "4111 1111 1111 1111"
```

## Задача 4: Обработка многострочных текстов с сохранением контекста

Рассмотрим задачу извлечения комментариев из исходного кода с сохранением информации о строках:

```javascript
// Извлечение комментариев из JavaScript-кода
function extractComments(code) {
    // Регулярное выражение для однострочных и многострочных комментариев
    const commentRegex = /(?:^|\s)\/\/(.*)$|\/\*([\s\S]*?)\*\//gm;
    
    const comments = [];
    let match;
    
    while ((match = commentRegex.exec(code)) !== null) {
        const lineNum = (code.substring(0, match.index).match(/\n/g) || []).length + 1;
        
        if (match[1]) { // Однострочный комментарий
            comments.push({
                type: 'single-line',
                content: match[1].trim(),
                line: lineNum,
                column: match.index - code.lastIndexOf('\n', match.index)
            });
        } else if (match[2]) { // Многострочный комментарий
            comments.push({
                type: 'multi-line',
                content: match[2].trim(),
                line: lineNum,
                column: match.index - code.lastIndexOf('\n', match.index)
            });
        }
    }
    
    return comments;
}

// Пример использования
const code = `
function hello() {
    // Это комментарий
    console.log("Привет, мир!");
    /* 
     * Это многострочный
     * комментарий
     */
    return true;
}`;

const comments = extractComments(code);
console.log(comments);
```

## Задача 5: Трансформация текста на основе условий

Создадим функцию, которая заменяет URL в тексте на HTML-ссылки, но только если они не находятся внутри уже существующих ссылок:

```javascript
function linkifyUrls(text) {
    // Используем negative lookahead, чтобы избежать замены URL внутри тегов
    const urlRegex = /(?<!\w)(https?:\/\/(?:www\.)?[-\w@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-\w()@:%_\+.~#?&//=]*))/gi;
    
    return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
}

// Пример использования
const text = "Посетите https://example.com или http://test.org для получения информации.";
const linkedText = linkifyUrls(text);
console.log(linkedText);
```

## Задача 6: Парсинг сложных строк запросов

Создадим продвинутый парсер строк запросов, который учитывает вложенные структуры:

```javascript
function parseComplexQuery(queryString) {
    // Регулярное выражение для извлечения параметров с поддержкой массивов и вложенных объектов
    const paramRegex = /([^&=]+)=?([^&]*)(?:&|$)/g;
    
    const params = {};
    let match;
    
    while ((match = paramRegex.exec(queryString)) !== null) {
        let key = decodeURIComponent(match[1]);
        let value = decodeURIComponent(match[2]);
        
        // Обработка вложенных структур (например, param[subparam]=value)
        const keys = key.split('[');
        let current = params;
        
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i].replace(']', '');
            if (i === keys.length - 1) {
                // Последний элемент - значение
                if (k === '') {
                    // Массив без ключей
                    if (!Array.isArray(current)) current = [];
                    current.push(value);
                } else {
                    current[k] = value;
                }
            } else {
                // Объект или массив
                if (k === '') {
                    if (!Array.isArray(current)) current = [];
                } else {
                    if (!current[k]) current[k] = {};
                }
                current = current[k];
            }
        }
        
        // Если это первый элемент и ключ пустой, используем как массив
        if (keys[0] === '' && !Array.isArray(params)) {
            if (!Array.isArray(params)) params = [];
            params.push(value);
        }
    }
    
    return params;
}

// Пример использования
const queryString = "name=John&hobbies[]=reading&hobbies[]=swimming&address[city]=NYC&address[zip]=10001";
const parsed = parseComplexQuery(queryString);
console.log(parsed);
```

## Задача 7: Создание DSL для валидации

Создадим простой DSL (Domain Specific Language) для описания правил валидации с использованием регулярных выражений:

```javascript
class ValidationDSL {
    constructor() {
        this.rules = new Map();
        this.compiledRules = new Map();
    }
    
    // Регистрация пользовательского правила
    addRule(name, pattern, message) {
        this.rules.set(name, { pattern, message });
        // Компилируем регулярное выражение для повторного использования
        this.compiledRules.set(name, new RegExp(pattern));
    }
    
    // Валидация значения по имени правила
    validate(value, ruleName) {
        const rule = this.rules.get(ruleName);
        if (!rule) {
            throw new Error(`Правило "${ruleName}" не найдено`);
        }
        
        const compiledRule = this.compiledRules.get(ruleName);
        return {
            isValid: compiledRule.test(value),
            message: compiledRule.test(value) ? null : rule.message
        };
    }
    
    // Комбинированная валидация
    validateAll(value, ruleNames) {
        const results = {};
        let isValid = true;
        
        for (const ruleName of ruleNames) {
            const result = this.validate(value, ruleName);
            results[ruleName] = result;
            if (!result.isValid) isValid = false;
        }
        
        return { isValid, results };
    }
}

// Пример использования
const validator = new ValidationDSL();

validator.addRule('email', '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', 'Некорректный email');
validator.addRule('strongPassword', '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]{8,}$', 'Пароль должен содержать заглавную, строчную букву и цифру');
validator.addRule('phone', '^\\+?[1-9]\\d{1,14}$', 'Некорректный номер телефона');

console.log(validator.validate('test@example.com', 'email')); // { isValid: true, message: null }
console.log(validator.validateAll('WeakPass1', ['email', 'strongPassword'])); // Комбинированная валидация
```

## Заключение

Решение сложных задач с помощью регулярных выражений требует глубокого понимания их возможностей и особенностей. Ключевые моменты:

1. Использование lookahead и lookbehind для сложных условий
2. Применение незахватывающих групп для повышения производительности
3. Понимание приоритетов и жадности квантификаторов
4. Тестирование на граничных случаях
5. Оптимизация для производительности

> [!tip] 
> При решении сложных задач полезно разбивать их на подзадачи и создавать промежуточные регулярные выражения для каждой подзадачи.

> [!warning]
> Не пытайтесь решать все задачи только регулярными выражениями. Иногда комбинация регулярных выражений с другими методами обработки строк дает лучший результат.

См. также: [[Тонкая настройка производительности]], [[Практическое сравнение различных подходов к решению задач]], [[Рекомендации по отладке регулярных выражений]]