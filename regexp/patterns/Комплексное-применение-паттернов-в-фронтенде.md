---
aliases: ["Комплексное применение паттернов", "Практическое применение regexp", "Frontend regexp примеры"]
tags: [regexp, patterns, frontend, practical, validation]
---

# Комплексное применение паттернов в frontend разработке

В этой главе мы рассмотрим комплексное применение различных типов регулярных выражений в frontend разработке, объединяя несколько паттернов для решения реальных задач.

## 1. Комплексная валидация форм

### Универсальный валидатор данных

```javascript
class FormDataValidator {
  constructor() {
    // Комбинация различных паттернов для валидации
    this.patterns = {
      // Паттерны для файловых путей
      path: {
        unix: /^\/(?:[^\/\0]+\/)*[^\/\0]*$/,
        windows: /^[a-zA-Z]:\\(?:[^\\\/:*?"<>|\r\n]+\\)*[^\\\/:*?"<>|\r\n]*(?:\.[^\\\/:*?"<>|\r\n]+)?$/i,
        relative: /^(?:\.\.\/)*(?:[a-zA-Z0-9._-]+\/)*[a-zA-Z0-9._-]*(?:\.[a-zA-Z0-9]+)?$/
      },
      
      // Паттерны для цветов
      color: {
        hex: /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/,
        rgb: /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i,
        rgba: /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+)\s*\)$/i,
        hsl: /^hsl\(\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*\)$/i,
        hsla: /^hsla\(\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(0|1|0?\.[0-9]+)\s*\)$/i
      },
      
      // Паттерны для SQL-безопасности
      sql: {
        dangerous: /\b(UNION|DROP|TRUNCATE|EXEC|EXECUTE|SLEEP|WAITFOR|DELAY|INSERT|UPDATE|DELETE)\b/i,
        comment: /(?:--|#|\/\*|\*\/)/g
      }
    };
  }

  validateField(fieldName, value) {
    const result = {
      field: fieldName,
      value: value,
      valid: true,
      issues: []
    };

    // Валидация на основе имени поля
    switch(fieldName) {
      case 'cssColor':
        result.valid = this.validateColor(value);
        if (!result.valid) result.issues.push('Invalid color format');
        break;
        
      case 'filePath':
        result.valid = this.validateFilePath(value);
        if (!result.valid) result.issues.push('Invalid file path');
        break;
        
      case 'sqlQuery':
        const sqlValidation = this.validateSqlQuery(value);
        result.valid = sqlValidation.safe;
        if (!sqlValidation.safe) result.issues = sqlValidation.issues;
        break;
        
      case 'userText':
        const textValidation = this.validateUserText(value);
        result.valid = textValidation.safe;
        if (!textValidation.safe) result.issues = textValidation.issues;
        break;
    }

    return result;
  }

  validateColor(color) {
    return Object.values(this.patterns.color).some(pattern => pattern.test(color));
  }

  validateFilePath(path) {
    return this.patterns.path.unix.test(path) || 
           this.patterns.path.windows.test(path) || 
           this.patterns.path.relative.test(path);
  }

  validateSqlQuery(query) {
    const issues = [];
    
    if (this.patterns.sql.dangerous.test(query)) {
      issues.push('Dangerous SQL keyword detected');
    }
    
    if ((query.match(this.patterns.sql.comment) || []).length > 1) {
      issues.push('SQL comment detected');
    }
    
    return {
      safe: issues.length === 0,
      issues
    };
  }

  validateUserText(text) {
    const issues = [];
    
    // Проверка на потенциальные грамматические ошибки
    const repeatedLetters = text.match(/\b\w*([а-яёa-z])\1{2,}\w*\b/gi);
    if (repeatedLetters && repeatedLetters.length > 0) {
      issues.push(`Potential typos detected: ${repeatedLetters.join(', ')}`);
    }
    
    // Проверка на отсутствие пробелов после знаков препинания
    const missingSpaces = text.match(/[,.:;!?)\]](?!\s)/g);
    if (missingSpaces && missingSpaces.length > 0) {
      issues.push(`Missing spaces after punctuation: ${missingSpaces.join(', ')}`);
    }
    
    return {
      safe: issues.length === 0,
      issues
    };
  }
}

// Пример использования
const validator = new FormDataValidator();

console.log(validator.validateField('cssColor', '#FF0000'));
console.log(validator.validateField('filePath', '/home/user/documents'));
console.log(validator.validateField('sqlQuery', 'SELECT * FROM users WHERE id = 1'));
console.log(validator.validateField('userText', 'Привет! Как дела? Я ооочень устал.'));
```

## 2. Комплексный парсер конфигурационных файлов

### Парсер с поддержкой различных форматов

```javascript
class ConfigParser {
  constructor() {
    this.patterns = {
      // Паттерны для извлечения цветов из CSS
      cssColor: /#([A-Fa-f0-9]{3,8})\b|rgba?\([^)]+\)|hsla?\([^)]+\)/gi,
      
      // Паттерны для извлечения путей из CSS/JS
      cssPath: /url\(['"]?([^'")]+)['"]?\)/gi,
      
      // Паттерны для извлечения SQL-запросов из JS-строк
      sqlQuery: /`(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\s+[^`]*`|(["'])((?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\s+(?:.(?!\1))*.)\1/gi,
      
      // Паттерны для извлечения файловых расширений
      fileExtension: /\.[^.\/\\]+$/g
    };
  }

  parseConfig(configText) {
    return {
      colors: this.extractColors(configText),
      paths: this.extractPaths(configText),
      queries: this.extractSqlQueries(configText),
      extensions: this.extractExtensions(configText)
    };
  }

  extractColors(text) {
    const matches = [...text.matchAll(this.patterns.cssColor)];
    return matches.map(match => ({
      color: match[0],
      position: match.index,
      type: this.getColorType(match[0])
    }));
  }

  getColorType(color) {
    if (color.startsWith('#')) return 'hex';
    if (color.toLowerCase().startsWith('rgb')) return color.toLowerCase().startsWith('rgba') ? 'rgba' : 'rgb';
    if (color.toLowerCase().startsWith('hsl')) return color.toLowerCase().startsWith('hsla') ? 'hsla' : 'hsl';
    return 'unknown';
  }

  extractPaths(text) {
    const matches = [...text.matchAll(this.patterns.cssPath)];
    return matches.map(match => ({
      path: match[1],
      full: match[0],
      position: match.index
    }));
  }

  extractSqlQueries(text) {
    const matches = [...text.matchAll(this.patterns.sqlQuery)];
    return matches.map(match => {
      // Проверяем, является ли это шаблонной строкой JS или обычной строкой
      const query = match[3] || (match[2] && match[2].slice(1, -1)) || match[0];
      return {
        query: query,
        full: match[0],
        position: match.index,
        type: this.getQueryType(query)
      };
    });
  }

  getQueryType(query) {
    const typeMatch = query.match(/^\s*(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\b/i);
    return typeMatch ? typeMatch[1].toUpperCase() : 'UNKNOWN';
  }

  extractExtensions(text) {
    const matches = [...text.matchAll(this.patterns.fileExtension)];
    return matches.map(match => ({
      extension: match[0],
      position: match.index
    }));
  }
}

// Пример использования
const configText = `
  .header {
    background-color: #FF0000;
    background-image: url('/images/bg.jpg');
  }
  
  const query = \`SELECT * FROM users WHERE id = \${id}\`;
  const anotherQuery = "SELECT name, email FROM users WHERE active = 1";
  
  import { Component } from './component.jsx';
  import styles from './styles.css';
`;

const parser = new ConfigParser();
console.log('Config analysis:', parser.parseConfig(configText));
```

## 3. Интеграция с веб-компонентами

### Создание валидирующего веб-компонента

```html
<!DOCTYPE html>
<html>
<head>
    <title>Комплексный валидатор данных</title>
    <style>
        .validator-container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .validation-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        
        .valid {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .invalid {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .issue {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 5px;
            margin: 5px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="validator-container">
        <h2>Комплексный валидатор данных</h2>
        
        <div class="input-group">
            <label for="colorInput">Цвет (HEX, RGB, HSL):</label>
            <input type="text" id="colorInput" placeholder="#FF0000 или rgb(255, 0, 0)">
            <div id="colorResult" class="validation-result" style="display: none;"></div>
        </div>
        
        <div class="input-group">
            <label for="pathInput">Файловый путь:</label>
            <input type="text" id="pathInput" placeholder="/home/user/file.txt">
            <div id="pathResult" class="validation-result" style="display: none;"></div>
        </div>
        
        <div class="input-group">
            <label for="textInput">Текст для проверки грамматики:</label>
            <textarea id="textInput" rows="4" placeholder="Введите текст для проверки..."></textarea>
            <div id="textResult" class="validation-result" style="display: none;"></div>
        </div>
        
        <div class="input-group">
            <label for="sqlInput">SQL-запрос:</label>
            <textarea id="sqlInput" rows="4" placeholder="SELECT * FROM table WHERE..."></textarea>
            <div id="sqlResult" class="validation-result" style="display: none;"></div>
        </div>
    </div>

    <script>
        class FrontendValidator {
            constructor() {
                this.validator = new FormDataValidator();
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('colorInput').addEventListener('input', 
                    () => this.validateField('colorInput', 'cssColor', 'colorResult'));
                document.getElementById('pathInput').addEventListener('input', 
                    () => this.validateField('pathInput', 'filePath', 'pathResult'));
                document.getElementById('textInput').addEventListener('input', 
                    () => this.validateField('textInput', 'userText', 'textResult'));
                document.getElementById('sqlInput').addEventListener('input', 
                    () => this.validateField('sqlInput', 'sqlQuery', 'sqlResult'));
            }

            validateField(inputId, fieldName, resultId) {
                const value = document.getElementById(inputId).value;
                const result = document.getElementById(resultId);
                
                if (!value.trim()) {
                    result.style.display = 'none';
                    return;
                }

                const validation = this.validator.validateField(fieldName, value);
                
                result.style.display = 'block';
                result.className = `validation-result ${validation.valid ? 'valid' : 'invalid'}`;
                
                if (validation.valid) {
                    result.innerHTML = `<strong>✓ Валидно</strong>`;
                } else {
                    result.innerHTML = `<strong>✗ Ошибки:</strong><br>` +
                        validation.issues.map(issue => `<div class="issue">• ${issue}</div>`).join('');
                }
            }
        }

        // Инициализация валидатора при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            new FrontendValidator();
        });
    </script>
</body>
</html>
```

## 4. Практические примеры использования в реальных приложениях

### Валидация пользовательского ввода в реальном времени

```javascript
// Класс для комплексной валидации формы
class RealTimeFormValidator {
  constructor(formSelector) {
    this.form = document.querySelector(formSelector);
    this.validator = new FormDataValidator();
    this.setupValidation();
  }

  setupValidation() {
    // Валидация всех полей формы при изменении
    const inputs = this.form.querySelectorAll('input, textarea, select');
    
    inputs.forEach(input => {
      input.addEventListener('blur', () => this.validateField(input));
      input.addEventListener('input', this.debounce(() => this.validateField(input), 500));
    });
  }

  validateField(field) {
    const fieldName = field.name || field.id;
    const value = field.value;

    // Определяем тип поля по его имени или атрибутам
    const fieldValidation = this.mapFieldNameToValidationType(fieldName);
    const result = this.validator.validateField(fieldValidation, value);

    this.displayValidationResult(field, result);
  }

  mapFieldNameToValidationType(fieldName) {
    if (fieldName.toLowerCase().includes('color') || fieldName.toLowerCase().includes('css')) {
      return 'cssColor';
    } else if (fieldName.toLowerCase().includes('path') || fieldName.toLowerCase().includes('file')) {
      return 'filePath';
    } else if (fieldName.toLowerCase().includes('sql') || fieldName.toLowerCase().includes('query')) {
      return 'sqlQuery';
    } else if (fieldName.toLowerCase().includes('text') || fieldName.toLowerCase().includes('content')) {
      return 'userText';
    }
    return 'userText'; // по умолчанию
  }

  displayValidationResult(field, result) {
    // Удаляем предыдущие сообщения
    const existingMessage = field.parentNode.querySelector('.validation-message');
    if (existingMessage) existingMessage.remove();

    // Создаем элемент для сообщения
    const messageElement = document.createElement('div');
    messageElement.className = `validation-message ${result.valid ? 'valid' : 'invalid'}`;
    
    if (result.valid) {
      messageElement.textContent = '✓ Поле заполнено корректно';
      messageElement.style.color = '#28a745';
    } else {
      messageElement.innerHTML = `✗ ${result.issues.join(', ')}`;
      messageElement.style.color = '#dc3545';
    }

    field.parentNode.appendChild(messageElement);
    
    // Добавляем класс к полю
    field.classList.remove('valid-field', 'invalid-field');
    field.classList.add(result.valid ? 'valid-field', 'invalid-field');
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
}

// Использование в реальном приложении
// const formValidator = new RealTimeFormValidator('#myForm');
```

### Анализ и оптимизация CSS

```javascript
class CssAnalyzer {
  constructor() {
    this.patterns = {
      color: /#([A-Fa-f0-9]{3,8})\b|rgba?\([^)]+\)|hsla?\([^)]+\)/gi,
      url: /url\(['"]?([^'")]+)['"]?\)/gi,
      import: /@import\s+["']([^"']+)["']/gi,
      fontFace: /@font-face\s*{[^}]*}/gi
    };
  }

  analyzeCss(cssText) {
    return {
      colors: this.extractColors(cssText),
      urls: this.extractUrls(cssText),
      imports: this.extractImports(cssText),
      fontFaces: this.extractFontFaces(cssText),
      statistics: this.calculateStatistics(cssText)
    };
  }

  extractColors(css) {
    const matches = [...css.matchAll(this.patterns.color)];
    return matches.map(match => ({
      color: match[0],
      position: match.index,
      type: this.getColorType(match[0])
    }));
  }

  getColorType(color) {
    if (color.startsWith('#')) return 'hex';
    if (color.toLowerCase().startsWith('rgb')) return color.toLowerCase().startsWith('rgba') ? 'rgba' : 'rgb';
    if (color.toLowerCase().startsWith('hsl')) return color.toLowerCase().startsWith('hsla') ? 'hsla' : 'hsl';
    return 'unknown';
  }

  extractUrls(css) {
    const matches = [...css.matchAll(this.patterns.url)];
    return matches.map(match => ({
      url: match[1],
      full: match[0],
      position: match.index
    }));
  }

  extractImports(css) {
    const matches = [...css.matchAll(this.patterns.import)];
    return matches.map(match => ({
      path: match[1],
      full: match[0],
      position: match.index
    }));
  }

  extractFontFaces(css) {
    const matches = css.match(this.patterns.fontFace) || [];
    return matches;
  }

  calculateStatistics(css) {
    return {
      totalSize: css.length,
      lineCount: css.split('\n').length,
      colorCount: (css.match(this.patterns.color) || []).length,
      urlCount: (css.match(this.patterns.url) || []).length,
      importCount: (css.match(this.patterns.import) || []).length
    };
  }

  optimizeColors(css) {
    // Находим все цвета и предлагаем оптимизацию (например, преобразование в переменные)
    const colors = this.extractColors(css);
    const colorCount = {};
    
    colors.forEach(color => {
      colorCount[color.color] = (colorCount[color.color] || 0) + 1;
    });

    // Возвращаем цвета, которые встречаются более 3 раз
    return Object.entries(colorCount)
      .filter(([color, count]) => count > 3)
      .map(([color, count]) => ({ color, count }));
  }
}

// Пример использования
const cssAnalyzer = new CssAnalyzer();
const sampleCss = `
  .header {
    background-color: #FF0000;
    color: rgb(255, 255, 255);
    background-image: url('/images/header-bg.jpg');
  }
  
  .footer {
    background-color: #FF0000; /* Тот же цвет что и в хедере */
    border: 1px solid hsl(0, 100%, 50%);
  }
  
  @import url('https://fonts.googleapis.com/css?family=Roboto');
`;

console.log('CSS Analysis:', cssAnalyzer.analyzeCss(sampleCss));
console.log('Colors to optimize:', cssAnalyzer.optimizeColors(sampleCss));
```

## 5. Лучшие практики комплексного использования паттернов

### Архитектура валидации

```javascript
// Модуль для комплексной валидации с использованием всех паттернов
const ValidationModule = {
  // Регистрация валидаторов
  validators: new Map(),
  
  registerValidator(name, validator) {
    this.validators.set(name, validator);
  },
  
  validate(data, rules) {
    const results = {};
    
    for (const [field, rule] of Object.entries(rules)) {
      const validator = this.validators.get(rule.type);
      if (validator) {
        results[field] = validator.validate(data[field], rule.options);
      }
    }
    
    return results;
  }
};

// Регистрация конкретных валидаторов
ValidationModule.registerValidator('color', {
  validate: (value, options = {}) => {
    const colorValidator = new FormDataValidator();
    const result = colorValidator.validateField('cssColor', value);
    return {
      valid: result.valid,
      value: result.value,
      issues: result.issues
    };
  }
});

ValidationModule.registerValidator('path', {
  validate: (value, options = {}) => {
    const pathValidator = new FormDataValidator();
    const result = pathValidator.validateField('filePath', value);
    return {
      valid: result.valid,
      value: result.value,
      issues: result.issues
    };
  }
});

ValidationModule.registerValidator('sql', {
  validate: (value, options = {}) => {
    const sqlValidator = new FormDataValidator();
    const result = sqlValidator.validateField('sqlQuery', value);
    return {
      valid: result.valid,
      value: result.value,
      issues: result.issues
    };
  }
});

// Пример использования
const formData = {
  backgroundColor: '#FF0000',
  assetPath: '/assets/images/logo.png',
  query: 'SELECT * FROM users WHERE id = 1'
};

const validationRules = {
  backgroundColor: { type: 'color' },
  assetPath: { type: 'path' },
  query: { type: 'sql' }
};

console.log('Complex validation results:', ValidationModule.validate(formData, validationRules));
```

## Заключение

Комплексное применение различных типов регулярных выражений позволяет создавать мощные инструменты валидации и анализа данных в frontend приложениях. Ключевые моменты:

- Используйте комбинации паттернов для комплексной валидации
- Создавайте модульные валидаторы для переиспользования
- Интегрируйте валидацию с веб-компонентами для лучшего UX
- Применяйте паттерны для анализа и оптимизации ресурсов (CSS, конфиги)
- Обеспечивайте безопасность при обработке пользовательского ввода

[[Паттерны для работы с файловыми путями]] [[Паттерны для извлечения информации из SQL-запросов]] [[Паттерны для работы с цветовыми форматами]] [[Паттерны-для-проверки-грамматических-структур-в-тексте]]