---
tags: [programming, regexp, validation, frontend, javascript, patterns]
aliases: [проверка-сложных-условий-в-строках, regexp-complex-validation]
---

# Проверка сложных условий в строках с помощью регулярных выражений

В этой статье рассмотрим паттерны регулярных выражений для проверки сложных условий в строках. Эти паттерны позволяют реализовать продвинутую валидацию и анализ текста, выходящий за рамки простых проверок.

## Проверка наличия и отсутствия паттернов

### Проверка наличия нескольких условий

```javascript
class MultiConditionValidator {
  // Проверка, содержит ли строка все указанные паттерны
  static containsAll(text, patterns) {
    return patterns.every(pattern => new RegExp(pattern).test(text));
  }
  
  // Проверка, содержит ли строка хотя бы один из паттернов
  static containsAny(text, patterns) {
    return patterns.some(pattern => new RegExp(pattern).test(text));
  }
  
  // Проверка, НЕ содержит ли строка ни одного из паттернов
  static containsNone(text, patterns) {
    return !patterns.some(pattern => new RegExp(pattern).test(text));
  }
  
  // Проверка, содержит ли строка все указанные слова (без учета регистра)
  static containsAllWords(text, words) {
    const lowerText = text.toLowerCase();
    return words.every(word => lowerText.includes(word.toLowerCase()));
  }
  
  // Проверка сложного пароля (должен содержать заглавную, строчную, цифру и специальный символ)
  static validateComplexPassword(password) {
    const checks = {
      length: /^.{8,}$/,           // минимум 8 символов
      uppercase: /(?=.*[A-Z])/,    // содержит заглавную
      lowercase: /(?=.*[a-z])/,    // содержит строчную
      number: /(?=.*\d)/,          // содержит цифру
      special: /(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?])/, // содержит специальный символ
      noSequential: /^(?!.*(?:012|123|234|345|456|567|678|789|890|abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz))/,
      noRepeats: /^(?!.*(.)\1{2,})/ // не содержит 3+ повторяющихся символов
    };
    
    const results = {};
    let isValid = true;
    
    for (const [name, regex] of Object.entries(checks)) {
      results[name] = regex.test(password);
      if (!results[name]) {
        isValid = false;
      }
    }
    
    return { isValid, results };
  }
}

// Примеры использования
const sampleText = "JavaScript - мощный язык программирования для веб-разработки";

console.log('Содержит все слова:', MultiConditionValidator.containsAllWords(sampleText, ['JavaScript', 'веб', 'мощный']));
console.log('Содержит любое из слов:', MultiConditionValidator.containsAny(sampleText, ['Python', 'Java', 'JavaScript']));

const complexPassword = "Str0ng!Password";
const passwordValidation = MultiConditionValidator.validateComplexPassword(complexPassword);
console.log(`Сложный пароль "${complexPassword}":`, passwordValidation);
```

### Проверка с использованием опережающих проверок

```javascript
class LookaheadValidator {
  // Проверка, что строка не содержит определенные последовательности
  static validateWithoutForbidden(text, forbiddenSequences) {
    const forbiddenPattern = `(?!.*(?:${forbiddenSequences.join('|')}))`;
    const regex = new RegExp(forbiddenPattern);
    return regex.test(text);
  }
  
  // Проверка, что строка содержит определенные паттерны в любом порядке
  static validateWithMultipleRequirements(text, requirements) {
    const allPresent = requirements.every(req => new RegExp(req).test(text));
    return allPresent;
  }
  
  // Сложная проверка формата (например, логин должен быть длиной 3-20, не начинаться с цифры, не содержать специальные символы)
  static validateUsername(username) {
    const checks = {
      length: /^(?=.{3,20}$)/,                    // длина 3-20 символов
      noStartWithDigit: /^(?!\d)/,               // не начинается с цифры
      onlyAllowedChars: /^[a-zA-Z0-9_]+$/,       // только буквы, цифры и подчеркивание
      noConsecutiveUnderscores: /^(?!.*__)/,     // не содержит подряд идущие подчеркивания
      noEndWithUnderscore: /^(?!.*_$)/           // не заканчивается подчеркиванием
    };
    
    const results = {};
    let isValid = true;
    
    for (const [name, regex] of Object.entries(checks)) {
      // Для паттернов с опережающими проверками используем общий префикс
      if (name === 'length' || name === 'noStartWithDigit' || name === 'noConsecutiveUnderscores' || name === 'noEndWithUnderscore') {
        const fullRegex = new RegExp(regex.source + '.*');
        results[name] = fullRegex.test(username);
      } else {
        results[name] = regex.test(username);
      }
      
      if (!results[name]) {
        isValid = false;
      }
    }
    
    return { isValid, results };
  }
  
  // Проверка email с дополнительными условиями
  static validateEnhancedEmail(email) {
    const checks = {
      basicFormat: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,  // базовый формат
      noConsecutiveDots: /^(?!.*\.\.)/,           // не содержит подряд идущие точки
      localPartRules: /^.{1,64}@/,                // локальная часть не длиннее 64 символов
      domainRules: /@.{1,255}$/,                  // доменная часть не длиннее 255 символов
      noStartEndDot: /^(?!.*\..*\@)|(?!\@.*\.)$/  // не начинается и не заканчивается точкой
    };
    
    const results = {};
    let isValid = true;
    
    for (const [name, regex] of Object.entries(checks)) {
      results[name] = regex.test(email);
      if (!results[name]) {
        isValid = false;
      }
    }
    
    return { isValid, results };
  }
}

// Примеры использования
console.log('Проверка username "user_name":', LookaheadValidator.validateUsername('user_name'));
console.log('Проверка username "123user":', LookaheadValidator.validateUsername('123user'));
console.log('Проверка email "user..name@example.com":', LookaheadValidator.validateEnhancedEmail('user..name@example.com'));
```

## Проверка структуры строк

### Проверка форматов с определенной структурой

```javascript
class StructuralValidator {
  // Проверка формата времени в 12-часовом формате
  static validate12HourTime(timeString) {
    const timeRegex = /^(0?[1-9]|1[0-2]):([0-5][0-9])\s?(AM|PM|am|pm)$/i;
    const match = timeString.match(timeRegex);
    
    if (!match) return { isValid: false, errors: ['Некорректный формат времени'] };
    
    const hour = parseInt(match[1]);
    const minute = parseInt(match[2]);
    const period = match[3].toUpperCase();
    
    // Дополнительная логическая проверка
    if (hour < 1 || hour > 12) {
      return { isValid: false, errors: ['Часы должны быть от 1 до 12'] };
    }
    
    if (minute < 0 || minute > 59) {
      return { isValid: false, errors: ['Минуты должны быть от 00 до 59'] };
    }
    
    if (!['AM', 'PM'].includes(period)) {
      return { isValid: false, errors: ['Период должен быть AM или PM'] };
    }
    
    return { isValid: true, errors: [], hour, minute, period };
  }
  
  // Проверка формата IPv4 с дополнительными условиями
  static validateIPv4(ip) {
    // Базовая проверка формата
    if (!/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/.test(ip)) {
      return { isValid: false, errors: ['Некорректный формат IPv4'] };
    }
    
    const parts = ip.split('.').map(Number);
    
    // Проверка диапазона значений
    for (const part of parts) {
      if (part < 0 || part > 255) {
        return { isValid: false, errors: ['Каждая часть IP-адреса должна быть от 0 до 255'] };
      }
    }
    
    // Проверка на ведущие нули (кроме самого нуля)
    const hasLeadingZeros = parts.some((part, index) => {
      const originalPart = ip.split('.')[index];
      return originalPart.length > 1 && originalPart[0] === '0';
    });
    
    if (hasLeadingZeros) {
      return { isValid: false, errors: ['IP-адрес не должен содержать ведущие нули'] };
    }
    
    return { isValid: true, errors: [], parts };
  }
  
  // Проверка формата MAC-адреса
  static validateMACAddress(mac) {
    const patterns = [
      /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/,  // XX:XX:XX:XX:XX:XX или XX-XX-XX-XX-XX-XX
      /^([0-9A-Fa-f]{4}[.]){2}([0-9A-Fa-f]{4})$/,   // XXXX.XXXX.XXXX
      /^([0-9A-Fa-f]{12})$/                         // XXXXXXXXXXXX
    ];
    
    const isValid = patterns.some(pattern => pattern.test(mac));
    
    return { 
      isValid, 
      errors: isValid ? [] : ['Некорректный формат MAC-адреса'],
      format: isValid ? this.getMACFormat(mac) : null
    };
  }
  
  static getMACFormat(mac) {
    if (/^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$/.test(mac)) return 'XX:XX:XX:XX:XX:XX';
    if (/^([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2})$/.test(mac)) return 'XX-XX-XX-XX-XX-XX';
    if (/^([0-9A-Fa-f]{4}[.]){2}([0-9A-Fa-f]{4})$/.test(mac)) return 'XXXX.XXXX.XXXX';
    if (/^([0-9A-Fa-f]{12})$/.test(mac)) return 'XXXXXXXXXXXX';
    return 'unknown';
  }
  
  // Проверка формата банковского счета
  static validateBankAccount(accountNumber) {
    // Удаляем все нецифровые символы для проверки
    const cleanNumber = accountNumber.replace(/\D/g, '');
    
    // Проверяем длину (обычно 20 для российских счетов)
    if (cleanNumber.length !== 20) {
      return { isValid: false, errors: ['Некорректная длина номера счета'] };
    }
    
    // Проверяем, начинается ли с 40 (для российских счетов)
    if (!cleanNumber.startsWith('40')) {
      return { isValid: false, errors: ['Некорректный префикс номера счета'] };
    }
    
    // Вычисляем контрольное число (упрощенно)
    const checkSum = this.calculateCheckSum(cleanNumber);
    
    return { 
      isValid: checkSum, 
      errors: checkSum ? [] : ['Некорректное контрольное число'],
      formatted: this.formatAccountNumber(cleanNumber)
    };
  }
  
  static calculateCheckSum(number) {
    // Упрощенная проверка - в реальных системах используется более сложный алгоритм
    const sum = number.split('').reduce((acc, digit) => acc + parseInt(digit), 0);
    return sum % 10 === 0;
  }
  
  static formatAccountNumber(number) {
    return number.replace(/(\d{4})/g, '$1 ').trim();
  }
}

// Примеры использования
console.log('Время 12-часового формата:', StructuralValidator.validate12HourTime('12:30 PM'));
console.log('IPv4:', StructuralValidator.validateIPv4('192.168.1.1'));
console.log('MAC-адрес:', StructuralValidator.validateMACAddress('AA:BB:CC:DD:EE:FF'));
console.log('Банковский счет:', StructuralValidator.validateBankAccount('40817810099910000001'));
```

## Проверка паттернов с подсчетом

### Подсчет вхождений и проверка условий

```javascript
class CountBasedValidator {
  // Проверка, что строка содержит определенное количество вхождений паттерна
  static validatePatternCount(text, pattern, minCount = 0, maxCount = Infinity) {
    const regex = new RegExp(pattern, 'g');
    const matches = text.match(regex) || [];
    const count = matches.length;
    
    const isValid = count >= minCount && count <= maxCount;
    
    return {
      isValid,
      count,
      minCount,
      maxCount,
      errors: isValid ? [] : [`Количество вхождений должно быть от ${minCount} до ${maxCount}, найдено: ${count}`]
    };
  }
  
  // Проверка сбалансированности скобок
  static validateBalancedBrackets(text, pairs = { '(': ')', '[': ']', '{': '}' }) {
    const stack = [];
    const opening = Object.keys(pairs);
    const closing = Object.values(pairs);
    
    for (const char of text) {
      if (opening.includes(char)) {
        stack.push(char);
      } else if (closing.includes(char)) {
        const last = stack.pop();
        if (!last || pairs[last] !== char) {
          return { 
            isValid: false, 
            errors: [`Несбалансированная скобка: ${char}`],
            position: text.indexOf(char)
          };
        }
      }
    }
    
    if (stack.length > 0) {
      return { 
        isValid: false, 
        errors: [`Не закрытые скобки: ${stack.join(', ')}`],
        unclosed: stack
      };
    }
    
    return { isValid: true, errors: [] };
  }
  
  // Проверка количества слов в строке
  static validateWordCount(text, minWords = 1, maxWords = 1000) {
    // Используем регулярное выражение для подсчета слов
    const words = text.match(/\S+/g) || [];
    const count = words.length;
    
    const isValid = count >= minWords && count <= maxWords;
    
    return {
      isValid,
      wordCount: count,
      minWords,
      maxWords,
      errors: isValid ? [] : [`Количество слов должно быть от ${minWords} до ${maxWords}, найдено: ${count}`]
    };
  }
  
  // Проверка количества предложений
  static validateSentenceCount(text, minSentences = 1, maxSentences = 100) {
    // Считаем предложения по точкам, восклицательным и вопросительным знакам
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const count = sentences.length;
    
    const isValid = count >= minSentences && count <= maxSentences;
    
    return {
      isValid,
      sentenceCount: count,
      minSentences,
      maxSentences,
      errors: isValid ? [] : [`Количество предложений должно быть от ${minSentences} до ${maxSentences}, найдено: ${count}`]
    };
  }
  
  // Проверка плотности ключевых слов
  static validateKeywordDensity(text, keywords, minDensity = 0.01, maxDensity = 0.1) {
    if (!text || !keywords || keywords.length === 0) {
      return { isValid: false, errors: ['Текст или ключевые слова отсутствуют'] };
    }
    
    const totalWords = text.match(/\S+/g)?.length || 0;
    if (totalWords === 0) {
      return { isValid: false, errors: ['Текст пуст'] };
    }
    
    let keywordCount = 0;
    const lowerText = text.toLowerCase();
    
    for (const keyword of keywords) {
      const regex = new RegExp(`\\b${keyword.toLowerCase()}\\b`, 'g');
      const matches = lowerText.match(regex);
      keywordCount += matches ? matches.length : 0;
    }
    
    const density = keywordCount / totalWords;
    const isValid = density >= minDensity && density <= maxDensity;
    
    return {
      isValid,
      keywordCount,
      totalWords,
      density,
      minDensity,
      maxDensity,
      errors: isValid ? [] : [`Плотность ключевых слов должна быть от ${(minDensity*100).toFixed(1)}% до ${(maxDensity*100).toFixed(1)}%, текущая: ${(density*100).toFixed(1)}%`]
    };
  }
}

// Примеры использования
console.log('Количество email:', CountBasedValidator.validatePatternCount('contact us at admin@example.com or support@site.org', '\\b[\\w.-]+@[\\w.-]+\\.[\\w]{2,}\\b', 1, 5));
console.log('Сбалансированные скобки:', CountBasedValidator.validateBalancedBrackets('(hello [world {test}])'));
console.log('Количество слов:', CountBasedValidator.validateWordCount('Это тестовое предложение с несколькими словами', 5, 10));
console.log('Количество предложений:', CountBasedValidator.validateSentenceCount('Первое предложение. Второе предложение! Третье?'));
console.log('Плотность ключевых слов:', CountBasedValidator.validateKeywordDensity('Этот текст о JavaScript и программировании на JavaScript', ['javascript', 'программирование'], 0.1, 0.5));
```

## Проверка сложных бизнес-правил

### Реализация сложных условий с использованием регулярных выражений

```javascript
class BusinessRuleValidator {
  // Проверка формата артикула (например, ABC-12345)
  static validateProductArticle(article) {
    // Формат: 3 буквы, дефис, 5 цифр
    const formatRegex = /^[A-Z]{3}-\d{5}$/i;
    
    if (!formatRegex.test(article)) {
      return { isValid: false, errors: ['Некорректный формат артикула (ожидается: XXX-12345)'] };
    }
    
    // Проверяем уникальность серийной части (последние 5 цифр)
    const serialPart = article.split('-')[1];
    if (serialPart === '00000') {
      return { isValid: false, errors: ['Серийный номер не может быть нулевым'] };
    }
    
    return { isValid: true, errors: [], serial: serialPart };
  }
  
  // Проверка формата лицензионного ключа
  static validateLicenseKey(key) {
    // Формат: XXXX-XXXX-XXXX-XXXX где X - шестнадцатеричные цифры
    const formatRegex = /^([A-F0-9]{4}-){3}[A-F0-9]{4}$/i;
    
    if (!formatRegex.test(key)) {
      return { isValid: false, errors: ['Некорректный формат лицензионного ключа'] };
    }
    
    // Проверяем контрольную сумму (упрощенно)
    const cleanKey = key.replace(/-/g, '');
    const checkSum = this.calculateLicenseChecksum(cleanKey);
    
    return { 
      isValid: checkSum, 
      errors: checkSum ? [] : ['Некорректная контрольная сумма лицензионного ключа'],
      formatted: key.toUpperCase()
    };
  }
  
  static calculateLicenseChecksum(key) {
    // Упрощенный алгоритм проверки - в реальных системах используется криптография
    let sum = 0;
    for (let i = 0; i < key.length; i++) {
      sum += parseInt(key[i], 16) * (i + 1);
    }
    return sum % 17 === 0;
  }
  
  // Проверка формата даты рождения (должна быть в прошлом и не слишком давно)
  static validateBirthDate(dateString) {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
      return { isValid: false, errors: ['Некорректный формат даты (ожидается: ГГГГ-ММ-ДД)'] };
    }
    
    const birthDate = new Date(dateString);
    const today = new Date();
    const age = today.getFullYear() - birthDate.getFullYear();
    
    // Проверяем, что дата в прошлом
    if (birthDate > today) {
      return { isValid: false, errors: ['Дата рождения не может быть в будущем'] };
    }
    
    // Проверяем возраст (реалистичный диапазон)
    if (age < 0 || age > 150) {
      return { isValid: false, errors: ['Некорректный возраст'] };
    }
    
    return { 
      isValid: true, 
      errors: [], 
      age,
      formatted: birthDate.toLocaleDateString('ru-RU')
    };
  }
  
  // Проверка формата номера документа
  static validateDocumentNumber(docNumber, type = 'passport') {
    const validators = {
      passport: () => {
        // Российский паспорт: 4 цифры, пробел, 6 цифр
        if (!/^\d{4}\s\d{6}$/.test(docNumber)) {
          return { isValid: false, errors: ['Некорректный формат паспорта (ожидается: XXXX XXXXXX)'] };
        }
        
        return { isValid: true, errors: [] };
      },
      driverLicense: () => {
        // Водительское удостоверение: 2 цифры, пробел, 2 цифры, пробел, 6 цифр
        if (!/^\d{2}\s\d{2}\s\d{6}$/.test(docNumber)) {
          return { isValid: false, errors: ['Некорректный формат водительского удостоверения'] };
        }
        
        return { isValid: true, errors: [] };
      },
      snils: () => {
        // СНИЛС: XXX-XXX-XXX YY
        if (!/^\d{3}-\d{3}-\d{3}\s\d{2}$/.test(docNumber)) {
          return { isValid: false, errors: ['Некорректный формат СНИЛС'] };
        }
        
        // Проверка контрольного числа
        const cleanNumber = docNumber.replace(/[-\s]/g, '');
        const checkSum = parseInt(cleanNumber.slice(-2));
        const mainPart = cleanNumber.slice(0, -2);
        
        let sum = 0;
        for (let i = 0; i < 9; i++) {
          sum += parseInt(mainPart[i]) * (9 - i);
        }
        
        const calculatedCheck = sum % 101;
        const expectedCheck = calculatedCheck > 100 ? calculatedCheck % 100 : calculatedCheck;
        
        if (checkSum !== expectedCheck) {
          return { isValid: false, errors: ['Некорректное контрольное число СНИЛС'] };
        }
        
        return { isValid: true, errors: [] };
      }
    };
    
    const validator = validators[type];
    if (!validator) {
      return { isValid: false, errors: [`Неизвестный тип документа: ${type}`] };
    }
    
    return validator();
  }
  
  // Проверка формата банковской карты и срока действия
  static validateCardWithExpiry(cardNumber, expiryDate) {
    // Проверяем номер карты
    const cleanCardNumber = cardNumber.replace(/\D/g, '');
    if (!/^(\d{13}|\d{14}|\d{15}|\d{16})$/.test(cleanCardNumber)) {
      return { isValid: false, errors: ['Некорректный номер карты'] };
    }
    
    // Проверяем срок действия (MM/YY или MM/YYYY)
    const expiryRegex = /^(0[1-9]|1[0-2])[\/\-](\d{2}|\d{4})$/;
    const expiryMatch = expiryDate.match(expiryRegex);
    
    if (!expiryMatch) {
      return { isValid: false, errors: ['Некорректный формат срока действия (ожидается: ММ/ГГ или ММ/ГГГГ)'] };
    }
    
    const month = parseInt(expiryMatch[1]);
    const year = parseInt(expiryMatch[2]);
    const fullYear = year < 100 ? 2000 + year : year; // Преобразуем 2-значный год в 4-значный
    
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth() + 1;
    
    // Проверяем, что карта не просрочена
    if (fullYear < currentYear || (fullYear === currentYear && month < currentMonth)) {
      return { isValid: false, errors: ['Срок действия карты истек'] };
    }
    
    // Проверяем контрольную сумму (алгоритм Луна)
    if (!this.validateLuhn(cleanCardNumber)) {
      return { isValid: false, errors: ['Некорректный номер карты (ошибка контрольной суммы)'] };
    }
    
    return { 
      isValid: true, 
      errors: [], 
      expiry: { month, year: fullYear },
      maskedNumber: this.maskCardNumber(cleanCardNumber)
    };
  }
  
  static validateLuhn(cardNumber) {
    let sum = 0;
    let isEven = false;
    
    for (let i = cardNumber.length - 1; i >= 0; i--) {
      let digit = parseInt(cardNumber.charAt(i));
      
      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }
      
      sum += digit;
      isEven = !isEven;
    }
    
    return sum % 10 === 0;
  }
  
  static maskCardNumber(cardNumber) {
    if (cardNumber.length < 8) return cardNumber;
    
    const first = cardNumber.substring(0, 4);
    const last = cardNumber.substring(cardNumber.length - 4);
    const middle = '*'.repeat(cardNumber.length - 8);
    
    return `${first}${middle}${last}`;
  }
}

// Примеры использования
console.log('Артикул товара:', BusinessRuleValidator.validateProductArticle('ABC-12345'));
console.log('Лицензионный ключ:', BusinessRuleValidator.validateLicenseKey('ABCD-1234-EFGH-5678'));
console.log('Дата рождения:', BusinessRuleValidator.validateBirthDate('1990-05-15'));
console.log('Номер паспорта:', BusinessRuleValidator.validateDocumentNumber('1234 567890', 'passport'));
console.log('Проверка карты с сроком:', BusinessRuleValidator.validateCardWithExpiry('4111111111111111', '12/27'));
```

## Проверка на основе паттернов с контекстом

### Проверка с учетом окружающего контекста

```javascript
class ContextualValidator {
  // Проверка email только в контексте контактной информации
  static validateContactEmails(text) {
    // Находим email в контексте контактных слов
    const contactContextRegex = /(?:контакт|email|почта|адрес|связь|обратная связь|contact|email)[^]{0,100}[\w.-]+@[\w.-]+\.\w{2,}|[\w.-]+@[\w.-]+\.\w{2,}[^]{0,100}(?:контакт|email|почта|адрес|связь|обратная связь|contact|email)/gi;
    const matches = [...text.matchAll(contactContextRegex)];
    
    const emailRegex = /[\w.-]+@[\w.-]+\.\w{2,}/g;
    const emails = [];
    
    matches.forEach(match => {
      const emailMatches = match[0].match(emailRegex);
      if (emailMatches) {
        emails.push(...emailMatches);
      }
    });
    
    return [...new Set(emails)].map(email => ({
      email,
      isValid: /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    }));
  }
  
  // Проверка телефонов в деловом контексте
  static validateBusinessPhones(text) {
    // Паттерн для телефонов в деловом контексте
    const businessContextRegex = /(?:телефон|звоните|свяжитесь|контакт|отдел|служба|служба поддержки|phone|tel)[^]{0,100}(?:\+?7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}/gi;
    const matches = [...text.matchAll(businessContextRegex)];
    
    const phoneRegex = /(?:\+?7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}/g;
    const phones = [];
    
    matches.forEach(match => {
      const phoneMatches = match[0].match(phoneRegex);
      if (phoneMatches) {
        phones.push(...phoneMatches);
      }
    });
    
    return [...new Set(phones)].map(phone => ({
      phone,
      isValid: /^(\+7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/.test(phone)
    }));
  }
  
  // Проверка цен в коммерческом контексте
  static validatePricesInContext(text) {
    // Находим числа в контексте цен
    const priceContextRegex = /(?:цена|стоимость|цена\s+составляет|в\s+размере|за|сумма|price)[^]{0,50}[\d\s,.]+(?:руб|р|RUR|USD|EUR|GBP|EUR|€|$|у\.е\.|тенге|сом|лари|драм)/gi;
    const matches = [...text.matchAll(priceContextRegex)];
    
    // Извлекаем числа из контекста
    const numberRegex = /[\d\s,.]+/g;
    const prices = [];
    
    matches.forEach(match => {
      const numberMatches = match[0].match(numberRegex);
      if (numberMatches) {
        numberMatches.forEach(num => {
          const cleanNum = num.trim().replace(/[^\d.,]/g, '');
          if (cleanNum && !isNaN(parseFloat(cleanNum.replace(/,/g, '')))) {
            prices.push(cleanNum);
          }
        });
      }
    });
    
    return prices.map(price => ({
      price,
      numericValue: parseFloat(price.replace(/,/g, ''))
    }));
  }
  
  // Проверка соответствия форматов в строке
  static validateFormatConsistency(text, expectedPattern) {
    const regex = new RegExp(expectedPattern, 'g');
    const matches = [...text.matchAll(regex)];
    
    if (matches.length === 0) {
      return { isValid: false, errors: ['Не найдено совпадений с ожидаемым паттерном'] };
    }
    
    // Проверяем, что все совпадения имеют одинаковый формат
    const formats = [...new Set(matches.map(match => {
      // Определяем формат на основе структуры совпадения
      return match[0].replace(/\d/g, 'N').replace(/[a-zA-Z]/g, 'L');
    }))];
    
    if (formats.length > 1) {
      return { 
        isValid: false, 
        errors: ['Найдены различные форматы совпадений'], 
        formats: formats 
      };
    }
    
    return { 
      isValid: true, 
      errors: [], 
      count: matches.length,
      format: formats[0]
    };
  }
  
  // Проверка на противоречия в данных
  static validateDataConsistency(text) {
    // Проверяем, есть ли противоречия в указанных датах
    const dateRegex = /\b\d{2}[\/\-\.]\d{2}[\/\-\.]\d{4}\b/g;
    const dates = [...text.matchAll(dateRegex)].map(match => match[0]);
    
    // Проверяем, есть ли дубликаты
    const uniqueDates = [...new Set(dates)];
    const hasDuplicates = uniqueDates.length !== dates.length;
    
    // Проверяем логическую последовательность (упрощенно)
    const dateObjects = dates.map(date => {
      const parts = date.split(/[\/\-\.]/).map(Number);
      return new Date(parts[2], parts[1] - 1, parts[0]);
    }).filter(date => !isNaN(date.getTime()));
    
    // Проверяем, есть ли будущие даты в прошлом контексте
    const futureDates = dateObjects.filter(date => date > new Date());
    
    return {
      hasDuplicates,
      futureDates: futureDates.length,
      totalDates: dates.length,
      inconsistencies: hasDuplicates || futureDates.length > 0
    };
  }
}

// Примеры использования
const contactText = 'Свяжитесь с нами по телефону 89261234567 или email: support@example.com. Контактное лицо: Иван Иванов.';
console.log('Контактные email:', ContextualValidator.validateContactEmails(contactText));
console.log('Бизнес телефоны:', ContextualValidator.validateBusinessPhones(contactText));

const priceText = 'Цена товара составляет 15 000 рублей, услуга - 5 500 р, общая сумма - $200 USD.';
console.log('Цены в контексте:', ContextualValidator.validatePricesInContext(priceText));

const dateText = 'Встреча запланирована на 25.12.2023, предыдущая встреча была 20.12.2023, следующая - 25.12.2023.';
console.log('Проверка дат на противоречия:', ContextualValidator.validateDataConsistency(dateText));
```

## Заключение

Проверка сложных условий в строках с помощью регулярных выражений позволяет:

1. **Реализовывать сложные бизнес-правила** с использованием паттернов
2. **Осуществлять многоуровневую валидацию** с комбинацией регулярных выражений и логики
3. **Анализировать структуру данных** в строковом формате
4. **Обнаруживать несоответствия и противоречия** в тексте

Для эффективной проверки сложных условий рекомендуется:
- Комбинировать регулярные выражения с логической проверкой
- Использовать опережающие и ретроспективные проверки для сложных условий
- Применять многоэтапную валидацию для повышения точности
- Учитывать контекст при анализе данных

## Следующие шаги

После изучения проверки сложных условий рекомендуется:

- [[Валидация различных форматов]]
- [[Санитизация данных]]
- [[Продвинутые темы]]