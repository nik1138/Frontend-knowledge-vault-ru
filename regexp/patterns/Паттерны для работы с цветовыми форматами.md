---
aliases: ["Паттерны для цветовых форматов", "Color Format Patterns", "Цветовые форматы"]
tags: [regexp, patterns, colors, validation, css, frontend]
---

# Паттерны для работы с цветовыми форматами (RGB, HEX, HSL)

## Общие принципы работы с цветовыми форматами

Цветовые форматы широко используются в веб-разработке, графическом дизайне и обработке изображений. Регулярные выражения позволяют эффективно валидировать, извлекать и преобразовывать различные цветовые форматы.

## 1. Валидация и извлечение HEX цветов

### Валидация HEX формата

```javascript
// Основные паттерны для HEX цветов
const hexPatterns = {
  // 6-значный HEX
  hex6: /^#([A-Fa-f0-9]{6})$/,
  
  // 3-значный HEX (сокращенный формат)
  hex3: /^#([A-Fa-f0-9]{3})$/,
  
  // 8-значный HEX (с альфа-каналом)
  hex8: /^#([A-Fa-f0-9]{8})$/,
  
  // Объединенный паттерн для всех HEX форматов
  hexAll: /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/
};

// Функция валидации HEX цвета
function validateHexColor(color) {
  const match = color.match(hexPatterns.hexAll);
  
  if (!match) {
    return { valid: false, format: null, error: 'Invalid HEX format' };
  }
  
  const hexValue = match[1];
  
  return {
    valid: true,
    format: hexValue.length === 3 ? 'hex3' : 
            hexValue.length === 6 ? 'hex6' : 'hex8',
    hex: color,
    value: hexValue,
    hasAlpha: hexValue.length === 8
  };
}

// Расширенная валидация с нормализацией
function normalizeHexColor(color) {
  const validation = validateHexColor(color);
  
  if (!validation.valid) {
    return validation;
  }
  
  let normalized = validation.value.toLowerCase();
  
  // Для 3-значного формата расширяем до 6-значного
  if (normalized.length === 3) {
    normalized = normalized.split('').map(c => c + c).join('');
  }
  
  // Для 8-значного формата извлекаем альфа-канал
  if (validation.hasAlpha) {
    const alpha = normalized.substring(6, 8);
    const rgb = normalized.substring(0, 6);
    return {
      ...validation,
      normalized: '#' + rgb,
      alpha: parseInt(alpha, 16) / 255,
      alphaHex: alpha
    };
  }
  
  return {
    ...validation,
    normalized: '#' + normalized
  };
}

// Примеры использования
console.log(validateHexColor('#FF0000')); // 6-значный
console.log(validateHexColor('#F00'));    // 3-значный
console.log(validateHexColor('#FF000080')); // 8-значный
console.log(validateHexColor('#GGGGGG')); // Невалидный
console.log(normalizeHexColor('#F00'));
```

### Извлечение HEX цветов из текста

```javascript
// Извлечение всех HEX цветов из текста
function extractHexColors(text) {
  const hexRegex = /#([A-Fa-f0-9]{3,8})\b/g;
  const matches = [...text.matchAll(hexRegex)];
  
  return matches.map(match => {
    const hex = match[0];
    const value = match[1];
    
    return {
      full: hex,
      value: value,
      position: match.index,
      format: value.length === 3 ? 'hex3' : 
              value.length === 6 ? 'hex6' : 
              value.length === 8 ? 'hex8' : 'invalid',
      valid: /^[A-Fa-f0-9]{3}$|^[A-Fa-f0-9]{6}$|^[A-Fa-f0-9]{8}$/.test(value)
    };
  });
}

// Извлечение с дополнительной информацией
function extractHexColorsDetailed(text) {
  const colors = extractHexColors(text);
  
  return colors.map(color => {
    if (!color.valid) return color;
    
    // Преобразуем в RGB для дополнительной информации
    let hexValue = color.value;
    
    // Расширяем 3-значный до 6-значного
    if (hexValue.length === 3) {
      hexValue = hexValue.split('').map(c => c + c).join('');
    }
    
    const r = parseInt(hexValue.substring(0, 2), 16);
    const g = parseInt(hexValue.substring(2, 4), 16);
    const b = parseInt(hexValue.substring(4, 6), 16);
    const a = hexValue.length === 8 ? parseInt(hexValue.substring(6, 8), 16) / 255 : 1;
    
    return {
      ...color,
      rgb: { r, g, b, a },
      brightness: calculateBrightness(r, g, b)
    };
  });
}

// Вспомогательная функция для расчета яркости
function calculateBrightness(r, g, b) {
  // Формула для расчета воспринимаемой яркости
  return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
}

// Пример использования
const cssText = `
  .header { background-color: #FF0000; color: #000; }
  .footer { background-color: #F0F0F0AA; border: 1px solid #CCC; }
  .highlight { background: #fff0; color: #f0f; }
`;

console.log('HEX colors found:', extractHexColorsDetailed(cssText));
```

## 2. Валидация и извлечение RGB цветов

### Валидация RGB формата

```javascript
// Паттерны для RGB цветов
const rgbPatterns = {
  // RGB без альфа-канала
  rgb: /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i,
  
  // RGBA с альфа-каналом
  rgba: /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+)\s*\)$/i,
  
  // RGB с процентами
  rgbPercent: /^rgb\(\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*\)$/i,
  
  // RGBA с процентами
  rgbaPercent: /^rgba\(\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(0|1|0?\.\d+)\s*\)$/i
};

// Валидация RGB цвета
function validateRgbColor(color) {
  // Проверяем все форматы RGB
  let match;
  
  if ((match = color.match(rgbPatterns.rgb))) {
    const [r, g, b] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    if (r > 255 || g > 255 || b > 255) {
      return { valid: false, error: 'RGB values must be 0-255' };
    }
    
    return {
      valid: true,
      format: 'rgb',
      values: { r, g, b },
      alpha: 1,
      normalized: `rgb(${r}, ${g}, ${b})`
    };
  }
  
  if ((match = color.match(rgbPatterns.rgba))) {
    const [r, g, b] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    const a = parseFloat(match[4]);
    
    if (r > 255 || g > 255 || b > 255 || a < 0 || a > 1) {
      return { valid: false, error: 'Invalid RGB or alpha values' };
    }
    
    return {
      valid: true,
      format: 'rgba',
      values: { r, g, b, a },
      alpha: a,
      normalized: `rgba(${r}, ${g}, ${b}, ${a})`
    };
  }
  
  if ((match = color.match(rgbPatterns.rgbPercent))) {
    const [r, g, b] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    if (r > 100 || g > 100 || b > 100) {
      return { valid: false, error: 'RGB percentage values must be 0-100%' };
    }
    
    // Преобразуем проценты в значения 0-255
    const rVal = Math.round(r * 255 / 100);
    const gVal = Math.round(g * 255 / 100);
    const bVal = Math.round(b * 255 / 100);
    
    return {
      valid: true,
      format: 'rgb-percent',
      values: { r: rVal, g: gVal, b: bVal },
      alpha: 1,
      normalized: `rgb(${rVal}, ${gVal}, ${bVal})`
    };
  }
  
  if ((match = color.match(rgbPatterns.rgbaPercent))) {
    const [r, g, b] = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
    const a = parseFloat(match[4]);
    
    if (r > 100 || g > 100 || b > 100 || a < 0 || a > 1) {
      return { valid: false, error: 'Invalid RGB percentage or alpha values' };
    }
    
    // Преобразуем проценты в значения 0-255
    const rVal = Math.round(r * 255 / 100);
    const gVal = Math.round(g * 255 / 100);
    const bVal = Math.round(b * 255 / 100);
    
    return {
      valid: true,
      format: 'rgba-percent',
      values: { r: rVal, g: gVal, b: bVal, a },
      alpha: a,
      normalized: `rgba(${rVal}, ${gVal}, ${bVal}, ${a})`
    };
  }
  
  return { valid: false, error: 'Invalid RGB format' };
}

// Примеры использования
console.log(validateRgbColor('rgb(255, 0, 0)'));
console.log(validateRgbColor('rgba(255, 0, 0, 0.5)'));
console.log(validateRgbColor('rgb(100%, 50%, 25%)'));
console.log(validateRgbColor('rgba(100%, 50%, 25%, 0.8)'));
console.log(validateRgbColor('rgb(300, 0, 0)')); // Невалидный
```

### Извлечение RGB цветов из текста

```javascript
// Извлечение всех RGB цветов из текста
function extractRgbColors(text) {
  const allMatches = [];
  
  // Ищем все возможные RGB форматы
  const formats = [
    { pattern: rgbPatterns.rgb, type: 'rgb' },
    { pattern: rgbPatterns.rgba, type: 'rgba' },
    { pattern: rgbPatterns.rgbPercent, type: 'rgb-percent' },
    { pattern: rgbPatterns.rgbaPercent, type: 'rgba-percent' }
  ];
  
  for (const format of formats) {
    let match;
    const regex = new RegExp(format.pattern.source, 'gi');
    
    while ((match = regex.exec(text)) !== null) {
      allMatches.push({
        full: match[0],
        type: format.type,
        values: match.slice(1),
        position: match.index
      });
    }
  }
  
  // Сортируем по позиции
  return allMatches.sort((a, b) => a.position - b.position);
}

// Пример использования
const cssWithRgb = `
  .box { 
    background: rgb(255, 0, 0);
    border: 1px solid rgba(0, 0, 0, 0.5);
    color: rgb(100%, 50%, 25%);
  }
  .transparent { background: rgba(255, 255, 255, 0.1); }
`;

console.log('RGB colors found:', extractRgbColors(cssWithRgb));
```

## 3. Валидация и извлечение HSL цветов

### Валидация HSL формата

```javascript
// Паттерны для HSL цветов
const hslPatterns = {
  // HSL без альфа-канала
  hsl: /^hsl\(\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*\)$/i,
  
  // HSLA с альфа-каналом
  hsla: /^hsla\(\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(\d{1,3}|[0-9]{1,2}\.[0-9]+)%\s*,\s*(0|1|0?\.[0-9]+)\s*\)$/i
};

// Валидация HSL цвета
function validateHslColor(color) {
  let match;
  
  if ((match = color.match(hslPatterns.hsl))) {
    const [h, s, l] = [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3])];
    
    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100) {
      return { valid: false, error: 'Invalid HSL values (H: 0-360, S: 0-100%, L: 0-100%)' };
    }
    
    return {
      valid: true,
      format: 'hsl',
      values: { h, s, l },
      alpha: 1,
      normalized: `hsl(${h}, ${s}%, ${l}%)`
    };
  }
  
  if ((match = color.match(hslPatterns.hsla))) {
    const [h, s, l] = [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3])];
    const a = parseFloat(match[4]);
    
    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100 || a < 0 || a > 1) {
      return { valid: false, error: 'Invalid HSL or alpha values' };
    }
    
    return {
      valid: true,
      format: 'hsla',
      values: { h, s, l, a },
      alpha: a,
      normalized: `hsla(${h}, ${s}%, ${l}%, ${a})`
    };
  }
  
  return { valid: false, error: 'Invalid HSL format' };
}

// Примеры использования
console.log(validateHslColor('hsl(0, 100%, 50%)'));
console.log(validateHslColor('hsla(120, 50%, 75%, 0.8)'));
console.log(validateHslColor('hsl(400, 50%, 50%)')); // Невалидный
```

### Извлечение HSL цветов из текста

```javascript
// Извлечение всех HSL цветов из текста
function extractHslColors(text) {
  const allMatches = [];
  
  const formats = [
    { pattern: hslPatterns.hsl, type: 'hsl' },
    { pattern: hslPatterns.hsla, type: 'hsla' }
  ];
  
  for (const format of formats) {
    let match;
    const regex = new RegExp(format.pattern.source, 'gi');
    
    while ((match = regex.exec(text)) !== null) {
      allMatches.push({
        full: match[0],
        type: format.type,
        values: match.slice(1),
        position: match.index
      });
    }
  }
  
  return allMatches.sort((a, b) => a.position - b.position);
}

// Пример использования
const cssWithHsl = `
  .primary { color: hsl(200, 100%, 50%); }
  .secondary { background: hsla(120, 50%, 75%, 0.8); }
  .accent { border: 1px solid hsl(60, 100%, 50%); }
`;

console.log('HSL colors found:', extractHslColors(cssWithHsl));
```

## 4. Преобразование между форматами

### HEX в RGB и обратно

```javascript
// Преобразование HEX в RGB
function hexToRgb(hex) {
  const validation = validateHexColor(hex);
  if (!validation.valid) return null;
  
  let hexValue = validation.value;
  
  // Расширяем 3-значный до 6-значного
  if (hexValue.length === 3) {
    hexValue = hexValue.split('').map(c => c + c).join('');
  }
  
  const r = parseInt(hexValue.substring(0, 2), 16);
  const g = parseInt(hexValue.substring(2, 4), 16);
  const b = parseInt(hexValue.substring(4, 6), 16);
  const a = hexValue.length === 8 ? parseInt(hexValue.substring(6, 8), 16) / 255 : 1;
  
  return { r, g, b, a };
}

// Преобразование RGB в HEX
function rgbToHex(r, g, b, a = 1) {
  if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 || a < 0 || a > 1) {
    throw new Error('Invalid RGB values');
  }
  
  const toHex = (n) => {
    const hex = Math.round(n).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };
  
  let hex = '#' + toHex(r) + toHex(g) + toHex(b);
  
  if (a < 1) {
    hex += toHex(Math.round(a * 255));
  }
  
  return hex.toUpperCase();
}

// Примеры использования
console.log('HEX #FF0000 to RGB:', hexToRgb('#FF0000'));
console.log('RGB 255,0,0 to HEX:', rgbToHex(255, 0, 0));
console.log('RGBA with alpha:', rgbToHex(255, 0, 0, 0.5));
```

### HSL в RGB и обратно

```javascript
// Преобразование HSL в RGB
function hslToRgb(h, s, l, a = 1) {
  // Нормализуем значения
  h = h / 360;
  s = s / 100;
  l = l / 100;
  
  if (s === 0) {
    const gray = Math.round(l * 255);
    return { r: gray, g: gray, b: gray, a };
  }
  
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  };
  
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  
  const r = Math.round(hue2rgb(p, q, h + 1/3) * 255);
  const g = Math.round(hue2rgb(p, q, h) * 255);
  const b = Math.round(hue2rgb(p, q, h - 1/3) * 255);
  
  return { r, g, b, a };
}

// Преобразование RGB в HSL
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  
  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    
    h /= 6;
  }
  
  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100)
  };
}

// Примеры использования
console.log('HSL 0,100,50 to RGB:', hslToRgb(0, 100, 50));
console.log('RGB 255,0,0 to HSL:', rgbToHsl(255, 0, 0));
```

## 5. Комплексный анализ цветов

### Класс для работы с цветами

```javascript
class ColorAnalyzer {
  constructor() {
    this.formats = {
      hex: hexPatterns.hexAll,
      rgb: new RegExp(`${rgbPatterns.rgb.source}|${rgbPatterns.rgba.source}|${rgbPatterns.rgbPercent.source}|${rgbPatterns.rgbaPercent.source}`, 'i'),
      hsl: new RegExp(`${hslPatterns.hsl.source}|${hslPatterns.hsla.source}`, 'i')
    };
  }
  
  analyzeColor(color) {
    // Определяем формат
    if (this.formats.hex.test(color)) {
      return { format: 'hex', ...this.validateHex(color) };
    } else if (this.formats.rgb.test(color)) {
      return { format: 'rgb', ...this.validateRgb(color) };
    } else if (this.formats.hsl.test(color)) {
      return { format: 'hsl', ...this.validateHsl(color) };
    }
    
    return { format: 'unknown', valid: false, error: 'Unknown color format' };
  }
  
  validateHex(color) {
    return validateHexColor(color);
  }
  
  validateRgb(color) {
    return validateRgbColor(color);
  }
  
  validateHsl(color) {
    return validateHslColor(color);
  }
  
  // Извлечение всех цветов из текста
  extractColors(text) {
    const colors = [];
    
    // Извлекаем HEX
    colors.push(...extractHexColors(text).map(c => ({ ...c, format: 'hex' })));
    
    // Извлекаем RGB
    colors.push(...extractRgbColors(text).map(c => ({ ...c, format: 'rgb' })));
    
    // Извлекаем HSL
    colors.push(...extractHslColors(text).map(c => ({ ...c, format: 'hsl' })));
    
    // Сортируем по позиции
    return colors.sort((a, b) => a.position - b.position);
  }
  
  // Преобразование между форматами
  convertColor(color, targetFormat) {
    const analysis = this.analyzeColor(color);
    if (!analysis.valid) return null;
    
    if (analysis.format === targetFormat) return color;
    
    // Сначала преобразуем в RGB как промежуточный формат
    let rgb;
    
    if (analysis.format === 'hex') {
      rgb = hexToRgb(color);
    } else if (analysis.format === 'rgb') {
      rgb = analysis.values;
    } else if (analysis.format === 'hsl') {
      rgb = hslToRgb(analysis.values.h, analysis.values.s, analysis.values.l, analysis.values.a);
    }
    
    // Преобразуем в целевой формат
    switch (targetFormat) {
      case 'hex':
        return rgbToHex(rgb.r, rgb.g, rgb.b, rgb.a);
      case 'rgb':
        return rgb.a === 1 ? 
          `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : 
          `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${rgb.a})`;
      case 'hsl':
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        return rgb.a === 1 ? 
          `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : 
          `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${rgb.a})`;
      default:
        return null;
    }
  }
}

// Пример использования
const analyzer = new ColorAnalyzer();

console.log('Analyze #FF0000:', analyzer.analyzeColor('#FF0000'));
console.log('Analyze rgb(255, 0, 0):', analyzer.analyzeColor('rgb(255, 0, 0)'));
console.log('Analyze hsl(0, 100%, 50%):', analyzer.analyzeColor('hsl(0, 100%, 50%)'));

// Извлечение из текста
const mixedColorText = `
  .header { 
    background: #FF0000; 
    color: rgb(255, 255, 255); 
    border: 1px solid hsl(0, 0%, 0%); 
  }
  .footer { 
    background: rgba(0, 0, 0, 0.1); 
    color: #fff; 
  }
`;

console.log('All colors found:', analyzer.extractColors(mixedColorText));

// Преобразование форматов
console.log('HEX to RGB:', analyzer.convertColor('#FF0000', 'rgb'));
console.log('RGB to HSL:', analyzer.convertColor('rgb(255, 0, 0)', 'hsl'));
console.log('HSL to HEX:', analyzer.convertColor('hsl(0, 100%, 50%)', 'hex'));
```

## 6. Практические примеры использования

### Валидация цветов в CSS

```javascript
// Класс для валидации CSS цветов
class CssColorValidator {
  constructor() {
    this.analyzer = new ColorAnalyzer();
  }
  
  validateCssColors(cssText) {
    const colors = this.analyzer.extractColors(cssText);
    const results = [];
    
    for (const color of colors) {
      const validation = this.analyzer.analyzeColor(color.full);
      results.push({
        ...color,
        validation,
        isAccessible: this.checkAccessibility(color.full)
      });
    }
    
    return results;
  }
  
  // Проверка доступности цвета (контрастность)
  checkAccessibility(color) {
    const analysis = this.analyzer.analyzeColor(color);
    if (!analysis.valid) return false;
    
    let rgb;
    if (analysis.format === 'hex') {
      rgb = hexToRgb(color);
    } else if (analysis.format === 'rgb') {
      rgb = analysis.values;
    } else if (analysis.format === 'hsl') {
      const hsl = analysis.values;
      rgb = hslToRgb(hsl.h, hsl.s, hsl.l, hsl.a);
    }
    
    if (!rgb) return false;
    
    // Расчет относительной яркости
    const r = rgb.r / 255;
    const g = rgb.g / 255;
    const b = rgb.b / 255;
    
    const rSRGB = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    const gSRGB = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
    const bSRGB = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
    
    const luminance = 0.2126 * rSRGB + 0.7152 * gSRGB + 0.0722 * bSRGB;
    
    // Простая проверка - яркость не должна быть слишком низкой
    return luminance > 0.15 && luminance < 0.85;
  }
  
  // Нормализация цветов в CSS
  normalizeCssColors(cssText, targetFormat = 'hex') {
    const colors = this.analyzer.extractColors(cssText);
    
    // Проходим по цветам в обратном порядке, чтобы индексы не сбивались
    for (let i = colors.length - 1; i >= 0; i--) {
      const color = colors[i];
      const converted = this.analyzer.convertColor(color.full, targetFormat);
      
      if (converted) {
        cssText = cssText.substring(0, color.position) + 
                 converted + 
                 cssText.substring(color.position + color.full.length);
      }
    }
    
    return cssText;
  }
}

// Пример использования
const cssValidator = new CssColorValidator();

const cssWithColors = `
  .button {
    background-color: #FF0000;
    color: rgb(255, 255, 255);
    border: 1px solid hsl(0, 100%, 50%);
  }
  .text {
    color: rgba(0, 0, 0, 0.8);
  }
`;

console.log('CSS color validation:', cssValidator.validateCssColors(cssWithColors));
console.log('Normalized CSS:', cssValidator.normalizeCssColors(cssWithColors, 'rgb'));
```

### Генерация палитр

```javascript
// Класс для генерации цветовых палитр
class ColorPaletteGenerator {
  constructor() {
    this.analyzer = new ColorAnalyzer();
  }
  
  // Генерация аналогичных цветов
  generateAnalogousColors(baseColor, count = 5) {
    const analysis = this.analyzer.analyzeColor(baseColor);
    if (!analysis.valid) return [];
    
    let hsl;
    if (analysis.format === 'hex') {
      const rgb = hexToRgb(baseColor);
      hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.a = rgb.a;
    } else if (analysis.format === 'rgb') {
      hsl = rgbToHsl(analysis.values.r, analysis.values.g, analysis.values.b);
      hsl.a = analysis.values.a;
    } else {
      hsl = analysis.values;
    }
    
    const colors = [];
    const angle = 30; // Угол для аналогичных цветов
    
    for (let i = 0; i < count; i++) {
      let newH = (hsl.h + (i - Math.floor(count/2)) * angle) % 360;
      if (newH < 0) newH += 360;
      
      const newColor = hslToRgb(newH, hsl.s, hsl.l, hsl.a);
      colors.push(rgbToHex(newColor.r, newColor.g, newColor.b, newColor.a));
    }
    
    return colors;
  }
  
  // Генерация комплементарных цветов
  generateComplementaryColors(baseColor) {
    const analysis = this.analyzer.analyzeColor(baseColor);
    if (!analysis.valid) return [];
    
    let hsl;
    if (analysis.format === 'hex') {
      const rgb = hexToRgb(baseColor);
      hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.a = rgb.a;
    } else if (analysis.format === 'rgb') {
      hsl = rgbToHsl(analysis.values.r, analysis.values.g, analysis.values.b);
      hsl.a = analysis.values.a;
    } else {
      hsl = analysis.values;
    }
    
    const complementaryH = (hsl.h + 180) % 360;
    const compColor = hslToRgb(complementaryH, hsl.s, hsl.l, hsl.a);
    
    return [
      baseColor,
      rgbToHex(compColor.r, compColor.g, compColor.b, compColor.a)
    ];
  }
  
  // Генерация оттенков (shades) и тонов (tints)
  generateShadesAndTints(baseColor, count = 5) {
    const analysis = this.analyzer.analyzeColor(baseColor);
    if (!analysis.valid) return [];
    
    let hsl;
    if (analysis.format === 'hex') {
      const rgb = hexToRgb(baseColor);
      hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.a = rgb.a;
    } else if (analysis.format === 'rgb') {
      hsl = rgbToHsl(analysis.values.r, analysis.values.g, analysis.values.b);
      hsl.a = analysis.values.a;
    } else {
      hsl = analysis.values;
    }
    
    const shades = [];
    const tints = [];
    
    for (let i = 1; i <= count; i++) {
      // Затенение (уменьшение светлоты)
      const shadeL = Math.max(0, hsl.l - (i * 100 / (count + 1)));
      const shadeColor = hslToRgb(hsl.h, hsl.s, shadeL, hsl.a);
      shades.push(rgbToHex(shadeColor.r, shadeColor.g, shadeColor.b, shadeColor.a));
      
      // Осветление (увеличение светлоты)
      const tintL = Math.min(100, hsl.l + (i * 100 / (count + 1)));
      const tintColor = hslToRgb(hsl.h, hsl.s, tintL, hsl.a);
      tints.push(rgbToHex(tintColor.r, tintColor.g, tintColor.b, tintColor.a));
    }
    
    return {
      base: baseColor,
      shades: shades.reverse(), // Темные оттенки
      tints: tints // Светлые оттенки
    };
  }
}

// Пример использования
const paletteGen = new ColorPaletteGenerator();

console.log('Analogous colors:', paletteGen.generateAnalogousColors('#FF0000', 5));
console.log('Complementary colors:', paletteGen.generateComplementaryColors('#FF0000'));
console.log('Shades and tints:', paletteGen.generateShadesAndTints('#FF0000', 3));
```

## 7. Практические рекомендации

### Лучшие практики работы с цветовыми форматами

```javascript
// Рекомендации по работе с цветовыми форматами
const ColorBestPractices = {
  // При валидации
  validation: {
    alwaysNormalize: true, // Всегда нормализуйте цвета для сравнения
    checkRange: true,      // Проверяйте диапазоны значений
    considerAlpha: true    // Учитывайте альфа-канал
  },
  
  // При преобразовании
  conversion: {
    useRgbAsIntermediate: true, // Используйте RGB как промежуточный формат
    preserveAlpha: true,        // Сохраняйте альфа-канал при преобразовании
    roundValues: true          // Округляйте значения для уменьшения ошибок
  },
  
  // При извлечении из текста
  extraction: {
    beSpecific: true,          // Используйте конкретные паттерны
    considerWhitespace: true,  // Учитывайте пробельные символы в CSS
    validateAfterExtract: true // Проверяйте извлеченные цвета
  }
};

// Практический пример комплексной обработки цветов
function processColorData(colorData) {
  const analyzer = new ColorAnalyzer();
  const results = {
    valid: [],
    invalid: [],
    conversions: {},
    statistics: {}
  };
  
  for (const color of colorData) {
    const analysis = analyzer.analyzeColor(color);
    
    if (analysis.valid) {
      results.valid.push({
        original: color,
        ...analysis
      });
      
      // Генерируем конверсии
      results.conversions[color] = {
        hex: analyzer.convertColor(color, 'hex'),
        rgb: analyzer.convertColor(color, 'rgb'),
        hsl: analyzer.convertColor(color, 'hsl')
      };
    } else {
      results.invalid.push({
        original: color,
        error: analysis.error
      });
    }
  }
  
  // Статистика
  results.statistics = {
    total: colorData.length,
    valid: results.valid.length,
    invalid: results.invalid.length,
    formats: {}
  };
  
  // Подсчет форматов
  results.valid.forEach(item => {
    results.statistics.formats[item.format] = 
      (results.statistics.formats[item.format] || 0) + 1;
  });
  
  return results;
}

// Пример использования
const testColors = [
  '#FF0000',
  'rgb(255, 0, 0)',
  'hsl(0, 100%, 50%)',
  '#F00',
  'rgba(255, 0, 0, 0.5)',
  'hsla(0, 100%, 50%, 0.8)',
  '#GGGGGG', // Невалидный
  'rgb(300, 0, 0)' // Невалидный
];

console.log('Processed color data:', processColorData(testColors));
```

## Заключение

Работа с цветовыми форматами требует точного подхода к валидации и преобразованию. Регулярные выражения обеспечивают эффективный способ извлечения и проверки различных цветовых форматов, что особенно полезно при обработке CSS, SVG и других форматов, содержащих цветовые определения.

Ключевые моменты:
- Используйте конкретные паттерны для каждого цветового формата
- Обязательно проверяйте диапазоны значений
- Учитывайте альфа-канал при работе с прозрачностью
- Используйте RGB как промежуточный формат для преобразований
- Всегда валидируйте извлеченные цвета