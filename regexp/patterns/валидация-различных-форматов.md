---
tags: [programming, regexp, validation, frontend, javascript, patterns]
aliases: [валидация-различных-форматов, regexp-validation-patterns]
---

# Валидация различных форматов с помощью регулярных выражений

В этой статье рассмотрим готовые паттерны регулярных выражений для валидации различных форматов данных, часто используемых в веб-разработке. Эти паттерны помогут быстро и эффективно проверять корректность пользовательского ввода.

## Валидация основных форматов

### Валидация email

```javascript
class EmailValidator {
  // Простой паттерн для большинства случаев
  static basicPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  // Более строгий паттерн (RFC 5322, упрощенный)
  static strictPattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  // Паттерн для домена
  static domainPattern = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$/;
  
  static validate(email, options = {}) {
    const { strict = false, checkDomain = false } = options;
    
    if (!email || typeof email !== 'string') {
      return { isValid: false, errors: ['Email не может быть пустым'] };
    }
    
    // Проверяем длину
    if (email.length > 254) {
      return { isValid: false, errors: ['Email слишком длинный'] };
    }
    
    const pattern = strict ? this.strictPattern : this.basicPattern;
    const isValid = pattern.test(email);
    
    if (!isValid) {
      return { 
        isValid: false, 
        errors: ['Некорректный формат email'] 
      };
    }
    
    // Дополнительная проверка домена при необходимости
    if (checkDomain) {
      const domain = email.split('@')[1];
      if (!this.domainPattern.test(domain)) {
        return { 
          isValid: false, 
          errors: ['Некорректный домен'] 
        };
      }
    }
    
    // Проверяем длину локальной части
    const [localPart] = email.split('@');
    if (localPart.length > 64) {
      return { 
        isValid: false, 
        errors: ['Локальная часть email слишком длинная'] 
      };
    }
    
    return { 
      isValid: true, 
      errors: [] 
    };
  }
  
  // Извлечение домена из email
  static extractDomain(email) {
    const match = email.match(/@(.+)/);
    return match ? match[1] : null;
  }
  
  // Извлечение локальной части из email
  static extractLocalPart(email) {
    const match = email.match(/^(.+)@/);
    return match ? match[1] : null;
  }
  
  // Получение информации о email
  static getInfo(email) {
    const validation = this.validate(email);
    if (!validation.isValid) {
      return { isValid: false, ...validation };
    }
    
    return {
      isValid: true,
      localPart: this.extractLocalPart(email),
      domain: this.extractDomain(email),
      length: email.length
    };
  }
}

// Примеры использования
const testEmails = [
  'user@example.com',
  'test.email+tag@domain.co.uk',
  'user@sub.domain.com',
  'invalid.email',
  'toolonglocalpartoolonglocalpartoolonglocalpartoolonglocalpart@domain.com'
];

console.log('=== Валидация email ===');
testEmails.forEach(email => {
  const result = EmailValidator.getInfo(email);
  console.log(`${email}: ${result.isValid ? '✓' : '✗'} ${result.errors ? result.errors.join(', ') : ''}`);
});
```

### Валидация телефонных номеров

```javascript
class PhoneValidator {
  // Паттерны для разных стран
  static patterns = {
    international: /^\+?[\d\s\-\(\)]{7,15}$/,
    ru: /^(\+7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/,
    us: /^(\+1)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{4}$/,
    de: /^(\+49)?[\s\-]?[0-9]{2,5}[\s\-]?[0-9]{1,9}[\s\-]?[0-9]{1,9}$/,
    uk: /^(\+44)?[\s\-]?[0-9]{4,5}[\s\-]?[0-9]{6}$/,
    cn: /^(\+86)?1[3-9]\d{9}$/
  };

  static validate(phone, country = 'international') {
    if (!phone || typeof phone !== 'string') {
      return { isValid: false, errors: ['Телефон не может быть пустым'] };
    }

    const pattern = this.patterns[country] || this.patterns.international;
    const isValid = pattern.test(phone);
    
    return {
      isValid,
      errors: isValid ? [] : [`Некорректный формат номера для страны: ${country}`]
    };
  }

  static format(phone, country = 'international') {
    // Очищаем номер от всех нецифровых символов (кроме + в начале)
    let cleanNumber = phone.replace(/[^\d+]/g, '');

    switch (country) {
      case 'ru':
        // Обработка российских номеров
        if (cleanNumber.length === 10) {
          cleanNumber = '+7' + cleanNumber;
        } else if (cleanNumber.length === 11 && cleanNumber[0] === '8') {
          cleanNumber = '+7' + cleanNumber.substring(1);
        }
        
        // Форматируем как +7 (XXX) XXX-XX-XX
        return cleanNumber.replace(/(\+7)(\d{3})(\d{3})(\d{2})(\d{2})/, "$1 ($2) $3-$4-$5");
        
      case 'us':
        // Обработка американских номеров
        if (cleanNumber.length === 10) {
          cleanNumber = '+1' + cleanNumber;
        } else if (cleanNumber.length === 11 && cleanNumber[0] === '1') {
          cleanNumber = '+' + cleanNumber;
        }
        
        // Форматируем как +1 (XXX) XXX-XXXX
        return cleanNumber.replace(/(\+1)(\d{3})(\d{3})(\d{4})/, "$1 ($2) $3-$4");
        
      default:
        // Общий формат
        return cleanNumber.replace(/(\d{1,4})(\d{3})(\d{3})(\d{2})(\d{2})/, "$1 $2 $3 $4 $5").trim();
    }
  }

  // Определение страны по номеру
  static detectCountry(phone) {
    const cleanNumber = phone.replace(/[^\d+]/g, '');
    
    if (cleanNumber.startsWith('7') && cleanNumber.length === 11) return 'ru';
    if (cleanNumber.startsWith('1') && cleanNumber.length === 11) return 'us';
    if (cleanNumber.startsWith('49') && cleanNumber.length >= 11) return 'de';
    if (cleanNumber.startsWith('44') && cleanNumber.length >= 11) return 'uk';
    if (cleanNumber.startsWith('86') && cleanNumber.length === 13) return 'cn';
    
    return 'international';
  }
  
  // Получение информации о номере
  static getInfo(phone) {
    const country = this.detectCountry(phone);
    const validation = this.validate(phone, country);
    const formatted = this.format(phone, country);
    
    return {
      original: phone,
      country,
      isValid: validation.isValid,
      formatted,
      errors: validation.errors
    };
  }
}

// Примеры использования
const testPhones = [
  '89261234567',
  '+7 (926) 123-45-67',
  '1234567890',
  '+1 (555) 123-4567',
  '+49 151 12345678'
];

console.log('\n=== Валидация телефонных номеров ===');
testPhones.forEach(phone => {
  const info = PhoneValidator.getInfo(phone);
  console.log(`${phone}: ${info.isValid ? '✓' : '✗'} [${info.country}] ${info.formatted}`);
});
```

### Валидация URL

```javascript
class UrlValidator {
  // Базовые паттерны
  static patterns = {
    // Простой паттерн
    basic: /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i,
    
    // Более строгий паттерн
    strict: /^(https?|ftp):\/\/(([a-z\d]([a-z\d-]*[a-z\d])?\.)+[a-z]{2,}|((\d{1,3}\.){3}\d{1,3}))(:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(#[-a-z\d_]*)?$/i,
    
    // Паттерн для домена
    domain: /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*\.[a-z]{2,}$/i,
    
    // Паттерн для IP-адреса
    ip: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
  };

  static validate(url, options = {}) {
    const { strict = false, requireProtocol = true } = options;
    
    if (!url || typeof url !== 'string') {
      return { isValid: false, errors: ['URL не может быть пустым'] };
    }

    // Проверяем длину
    if (url.length > 2048) {
      return { isValid: false, errors: ['URL слишком длинный'] };
    }

    const pattern = strict ? this.patterns.strict : this.patterns.basic;
    
    // Если протокол не обязателен, добавляем его для проверки
    const urlToTest = requireProtocol ? url : (url.startsWith('http') || url.startsWith('ftp') ? url : 'http://' + url);
    
    const isValid = pattern.test(urlToTest);
    
    if (!isValid) {
      return { 
        isValid: false, 
        errors: ['Некорректный формат URL'] 
      };
    }
    
    return { 
      isValid: true, 
      errors: [] 
    };
  }
  
  // Извлечение компонентов URL
  static parse(url) {
    try {
      const urlObj = new URL(url);
      return {
        protocol: urlObj.protocol,
        hostname: urlObj.hostname,
        port: urlObj.port,
        pathname: urlObj.pathname,
        search: urlObj.search,
        hash: urlObj.hash,
        origin: urlObj.origin
      };
    } catch (e) {
      // Альтернативный парсинг через регулярные выражения
      const match = url.match(/^(https?|ftp):\/\/([^\/\?:#]+)(?::(\d+))?(\/[^\?#]*)?(\?[^#]*)?(#.*)?$/i);
      
      if (match) {
        return {
          protocol: match[1],
          hostname: match[2],
          port: match[3] || '',
          pathname: match[4] || '/',
          search: match[5] || '',
          hash: match[6] || '',
          origin: `${match[1]}://${match[2]}${match[3] ? ':' + match[3] : ''}`
        };
      }
      
      return null;
    }
  }
  
  // Проверка, является ли домен IP-адресом
  static isIpAddress(hostname) {
    return this.patterns.ip.test(hostname);
  }
  
  // Нормализация URL
  static normalize(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.toString();
    } catch (e) {
      // Альтернативная нормализация
      return url
        .replace(/([^:]\/)\/+/g, '$1') // удаление двойных слэшей
        .toLowerCase()
        .replace(/\/$/, ''); // удаление завершающего слэша
    }
  }
}

// Примеры использования
const testUrls = [
  'https://example.com',
  'http://www.example.com/path?query=1#section',
  'ftp://files.example.com',
  'example.com', // без протокола
  'invalid-url'
];

console.log('\n=== Валидация URL ===');
testUrls.forEach(url => {
  const validation = UrlValidator.validate(url);
  const parsed = UrlValidator.parse(url);
  
  console.log(`${url}: ${validation.isValid ? '✓' : '✗'} ${validation.errors ? validation.errors.join(', ') : ''}`);
  if (parsed) {
    console.log(`  Хост: ${parsed.hostname}, Путь: ${parsed.pathname}`);
  }
});
```

## Валидация форматов дат и времени

```javascript
class DateTimeValidator {
  // Паттерны для разных форматов дат
  static datePatterns = {
    'DD/MM/YYYY': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}$/,
    'MM/DD/YYYY': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/,
    'YYYY/MM/DD': /^\d{4}\/(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])$/,
    'DD-MM-YYYY': /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-\d{4}$/,
    'MM-DD-YYYY': /^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\d{4}$/,
    'YYYY-MM-DD': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/,
    'DD.MM.YYYY': /^(0[1-9]|[12][0-9]|3[01])\.(0[1-9]|1[0-2])\.\d{4}$/
  };
  
  // Паттерны для времени
  static timePatterns = {
    'HH:MM': /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'HH:MM:SS': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'HH:MM:SS.A': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\.[0-9]{1,3}$/
  };
  
  // Паттерны для даты и времени
  static dateTimePatterns = {
    'YYYY-MM-DD HH:MM:SS': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'DD/MM/YYYY HH:MM': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'MM/DD/YYYY HH:MM:SS': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/
  };

  static validateDate(dateString, format = 'YYYY-MM-DD') {
    if (!dateString || typeof dateString !== 'string') {
      return { isValid: false, errors: ['Дата не может быть пустой'] };
    }

    const pattern = this.datePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат даты: ${format}`] };
    }

    if (!pattern.test(dateString)) {
      return { isValid: false, errors: ['Некорректный формат даты'] };
    }

    // Дополнительная проверка корректности даты
    try {
      let [day, month, year] = dateString.split(/[-/.]/).map(Number);
      
      // Для форматов MM/DD/YYYY и YYYY/MM/DD меняем порядок
      if (format === 'MM/DD/YYYY') {
        [month, day, year] = [day, month, year];
      } else if (format === 'YYYY/MM/DD') {
        [year, month, day] = [day, month, year];
      }
      
      const date = new Date(year, month - 1, day);
      
      if (date.getFullYear() !== year || 
          date.getMonth() !== month - 1 || 
          date.getDate() !== day) {
        return { isValid: false, errors: ['Несуществующая дата'] };
      }
      
      return { isValid: true, errors: [] };
    } catch (e) {
      return { isValid: false, errors: ['Ошибка при проверке даты'] };
    }
  }

  static validateTime(timeString, format = 'HH:MM:SS') {
    if (!timeString || typeof timeString !== 'string') {
      return { isValid: false, errors: ['Время не может быть пустым'] };
    }

    const pattern = this.timePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат времени: ${format}`] };
    }

    if (!pattern.test(timeString)) {
      return { isValid: false, errors: ['Некорректный формат времени'] };
    }

    // Дополнительная проверка значений
    const [hours, minutes, seconds] = timeString.split(':').map(Number);
    
    if (hours > 23 || minutes > 59 || (seconds !== undefined && seconds > 59)) {
      return { isValid: false, errors: ['Некорректные значения времени'] };
    }

    return { isValid: true, errors: [] };
  }

  static validateDateTime(dateTimeString, format = 'YYYY-MM-DD HH:MM:SS') {
    if (!dateTimeString || typeof dateTimeString !== 'string') {
      return { isValid: false, errors: ['Дата и время не могут быть пустыми'] };
    }

    const pattern = this.dateTimePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат даты и времени: ${format}`] };
    }

    if (!pattern.test(dateTimeString)) {
      return { isValid: false, errors: ['Некорректный формат даты и времени'] };
    }

    // Разделение даты и времени для отдельной проверки
    const parts = dateTimeString.split(/\s+/);
    if (parts.length < 2) {
      return { isValid: false, errors: ['Невозможно разделить дату и время'] };
    }

    // Определение форматов даты и времени на основе общего формата
    let dateFormat, timeFormat;
    
    switch (format) {
      case 'DD/MM/YYYY HH:MM':
        dateFormat = 'DD/MM/YYYY';
        timeFormat = 'HH:MM';
        break;
      case 'MM/DD/YYYY HH:MM:SS':
        dateFormat = 'MM/DD/YYYY';
        timeFormat = 'HH:MM:SS';
        break;
      case 'YYYY-MM-DD HH:MM:SS':
        dateFormat = 'YYYY-MM-DD';
        timeFormat = 'HH:MM:SS';
        break;
      default:
        return { isValid: false, errors: ['Неподдерживаемый формат'] };
    }

    const dateValidation = this.validateDate(parts[0], dateFormat);
    if (!dateValidation.isValid) {
      return { isValid: false, errors: [`Ошибка в дате: ${dateValidation.errors.join(', ')}`] };
    }

    const timeValidation = this.validateTime(parts[1], timeFormat);
    if (!timeValidation.isValid) {
      return { isValid: false, errors: [`Ошибка во времени: ${timeValidation.errors.join(', ')}`] };
    }

    return { isValid: true, errors: [] };
  }
  
  // Определение формата даты
  static detectDateFormat(dateString) {
    for (const [format, pattern] of Object.entries(this.datePatterns)) {
      if (pattern.test(dateString)) {
        return format;
      }
    }
    return null;
  }
  
  // Преобразование между форматами
  static convertFormat(dateString, fromFormat, toFormat) {
    const validation = this.validateDate(dateString, fromFormat);
    if (!validation.isValid) {
      return null;
    }

    try {
      // Извлечение компонентов
      let [day, month, year] = dateString.split(/[-/.]/).map(Number);
      
      // Корректировка порядка для разных форматов
      if (fromFormat === 'MM/DD/YYYY') {
        [month, day, year] = [day, month, year];
      } else if (fromFormat === 'YYYY/MM/DD') {
        [year, month, day] = [day, month, year];
      }

      // Форматирование в новый формат
      switch (toFormat) {
        case 'YYYY-MM-DD':
          return `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
        case 'DD/MM/YYYY':
          return `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
        case 'MM/DD/YYYY':
          return `${month.toString().padStart(2, '0')}/${day.toString().padStart(2, '0')}/${year}`;
        default:
          return null;
      }
    } catch (e) {
      return null;
    }
  }
}

// Примеры использования
const testDates = [
  '2023-12-25',
  '25/12/2023',
  '12/25/2023',
  '29/02/2024', // високосный год
  '29/02/2023', // не високосный год
  'invalid-date'
];

console.log('\n=== Валидация дат ===');
testDates.forEach(date => {
  const format = DateTimeValidator.detectDateFormat(date) || 'YYYY-MM-DD';
  const validation = DateTimeValidator.validateDate(date, format);
  console.log(`${date} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors ? validation.errors.join(', ') : ''}`);
});

const convertedDate = DateTimeValidator.convertFormat('25/12/2023', 'DD/MM/YYYY', 'YYYY-MM-DD');
console.log(`Преобразованная дата: ${convertedDate}`);
```

## Валидация специфических форматов

### Валидация артикулов, кодов и идентификаторов

```javascript
class CodeValidator {
  // Паттерны для различных кодов
  static patterns = {
    // ISBN-10 и ISBN-13
    isbn: /^(?:\d{9}[\dX]|\d{10})$|^(?:\d{13})$/,
    
    // ИНН (российский)
    inn: /^\d{10}$|^\d{12}$/,
    
    // КПП (российский)
    kpp: /^\d{9}$/,
    
    // ОГРН (российский)
    ogrn: /^\d{13}$|^\d{15}$/,
    
    // СНИЛС (российский)
    snils: /^\d{3}-\d{3}-\d{3} \d{2}$/,
    
    // Серия и номер паспорта (российский)
    passport: /^\d{4} \d{6}$/,
    
    // Номер водительского удостоверения (российский)
    driverLicense: /^\d{2} \d{2} \d{6}$/,
    
    // Номер СТС (российский)
    sts: /^[ABEKMHOPCTYX]\d{3}[ABEKMHOPCTYX]{2}\d{2,3}$/,
    
    // Номер свидетельства о регистрации ТС (российский)
    registration: /^\d{4}-\d{6}$/,
    
    // Номер банковской карты
    cardNumber: /^\d{4} \d{4} \d{4} \d{4}$|^\d{16}$/,
    
    // Номер счета в банке
    accountNumber: /^40[0-9]{19}$|^[0-9]{20}$/,
    
    // БИК (российский)
    bik: /^\d{9}$/
  };

  static validate(formatName, value) {
    const pattern = this.patterns[formatName];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат: ${formatName}`] };
    }

    if (!value || typeof value !== 'string') {
      return { isValid: false, errors: ['Значение не может быть пустым'] };
    }

    // Для некоторых форматов нужна дополнительная логическая проверка
    switch (formatName) {
      case 'isbn':
        return this.validateISBN(value);
      case 'snils':
        return this.validateSNILS(value);
      case 'inn':
        return this.validateINN(value);
      default:
        const isValid = pattern.test(value);
        return {
          isValid,
          errors: isValid ? [] : [`Некорректный формат ${formatName}`]
        };
    }
  }

  // Валидация ISBN
  static validateISBN(isbn) {
    // Удаляем дефисы и пробелы
    const cleanIsbn = isbn.replace(/[-\s]/g, '');

    if (cleanIsbn.length === 10) {
      // ISBN-10
      const regex = /^(?:\d{9}[\dX]|\d{10})$/;
      if (!regex.test(cleanIsbn)) return { isValid: false, errors: ['Некорректный ISBN-10'] };

      // Проверка контрольной суммы для ISBN-10
      let sum = 0;
      for (let i = 0; i < 9; i++) {
        sum += parseInt(cleanIsbn[i]) * (10 - i);
      }

      const lastChar = cleanIsbn[9];
      const lastValue = lastChar === 'X' ? 10 : parseInt(lastChar);
      sum += lastValue;

      return { isValid: sum % 11 === 0, errors: [] };
    } else if (cleanIsbn.length === 13) {
      // ISBN-13
      const regex = /^\d{13}$/;
      if (!regex.test(cleanIsbn)) return { isValid: false, errors: ['Некорректный ISBN-13'] };

      // Проверка контрольной суммы для ISBN-13
      let sum = 0;
      for (let i = 0; i < 12; i++) {
        sum += parseInt(cleanIsbn[i]) * (i % 2 === 0 ? 1 : 3);
      }

      const checkDigit = (10 - (sum % 10)) % 10;
      return { isValid: checkDigit === parseInt(cleanIsbn[12]), errors: [] };
    }

    return { isValid: false, errors: ['Неподдерживаемая длина ISBN'] };
  }

  // Валидация СНИЛС
  static validateSNILS(snils) {
    // Проверяем формат
    if (!this.patterns.snils.test(snils)) {
      return { isValid: false, errors: ['Некорректный формат СНИЛС'] };
    }

    // Удаляем все разделители
    const cleanSnils = snils.replace(/[-\s]/g, '');
    
    // Извлекаем контрольное число
    const controlNumber = parseInt(cleanSnils.slice(-2));
    
    // Извлекаем основную часть
    const mainPart = cleanSnils.slice(0, -2);
    
    // Вычисляем контрольное число
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += parseInt(mainPart[i]) * (9 - i);
    }
    
    let calculatedControl = sum % 101;
    if (calculatedControl > 100) calculatedControl = calculatedControl % 100;
    
    return { isValid: controlNumber === calculatedControl, errors: [] };
  }

  // Валидация ИНН
  static validateINN(inn) {
    if (!this.patterns.inn.test(inn)) {
      return { isValid: false, errors: ['Некорректный формат ИНН'] };
    }

    const digits = inn.split('').map(Number);
    
    if (inn.length === 10) {
      // Для юридических лиц
      const checkDigit = (2 * digits[0] + 4 * digits[1] + 10 * digits[2] + 
                         3 * digits[3] + 5 * digits[4] + 9 * digits[5] + 
                         4 * digits[6] + 6 * digits[7] + 8 * digits[8]) % 11 % 10;
      
      return { isValid: checkDigit === digits[9], errors: [] };
    } else if (inn.length === 12) {
      // Для физических лиц
      const checkDigits = [
        (7 * digits[0] + 2 * digits[1] + 4 * digits[2] + 10 * digits[3] + 
         3 * digits[4] + 5 * digits[5] + 9 * digits[6] + 4 * digits[7] + 
         6 * digits[8] + 8 * digits[9]) % 11 % 10,
        (3 * digits[0] + 7 * digits[1] + 2 * digits[2] + 4 * digits[3] + 
         10 * digits[4] + 3 * digits[5] + 5 * digits[6] + 9 * digits[7] + 
         4 * digits[8] + 6 * digits[9] + 8 * digits[10]) % 11 % 10
      ];
      
      return { 
        isValid: checkDigits[0] === digits[10] && checkDigits[1] === digits[11], 
        errors: [] 
      };
    }

    return { isValid: false, errors: ['Неподдерживаемая длина ИНН'] };
  }
  
  // Генерация валидатора для пользовательского формата
  static createCustomValidator(pattern, description = 'пользовательский формат') {
    return {
      validate: (value) => {
        if (!value || typeof value !== 'string') {
          return { isValid: false, errors: ['Значение не может быть пустым'] };
        }
        
        const isValid = new RegExp(pattern).test(value);
        return {
          isValid,
          errors: isValid ? [] : [`Некорректный формат ${description}`]
        };
      }
    };
  }
}

// Примеры использования
const testCodes = [
  { format: 'snils', value: '123-456-789 12' },
  { format: 'inn', value: '1234567890' },
  { format: 'passport', value: '1234 567890' },
  { format: 'isbn', value: '0-306-40615-2' },
  { format: 'cardNumber', value: '4111 1111 1111 1111' }
];

console.log('\n=== Валидация специфических форматов ===');
testCodes.forEach(({ format, value }) => {
  const validation = CodeValidator.validate(format, value);
  console.log(`${value} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors ? validation.errors.join(', ') : ''}`);
});

// Пример пользовательского валидатора
const customValidator = CodeValidator.createCustomValidator('^\\d{3}-\\d{2}-\\d{4}$', 'SSN');
console.log('Пользовательский валидатор (SSN):', customValidator.validate('123-45-6789'));
```

### Валидация цветов

```javascript
class ColorValidator {
  static patterns = {
    // HEX формат
    hex: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
    
    // RGB формат
    rgb: /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/,
    
    // RGBA формат
    rgba: /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+)\s*\)$/,
    
    // HSL формат
    hsl: /^hsl\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*\)$/,
    
    // HSLA формат
    hsla: /^hsla\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(0|1|0?\.\d+)\s*\)$/,
    
    // Названия цветов
    name: /^(?:aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow)$/i
  };

  static validate(color) {
    if (!color || typeof color !== 'string') {
      return { isValid: false, errors: ['Цвет не может быть пустым'] };
    }

    // Проверяем каждый паттерн
    for (const [format, pattern] of Object.entries(this.patterns)) {
      if (pattern.test(color)) {
        return { isValid: true, format, errors: [] };
      }
    }

    return { isValid: false, errors: ['Некорректный формат цвета'] };
  }
  
  // Конвертация между форматами
  static toHex(color) {
    const validation = this.validate(color);
    if (!validation.isValid) return null;
    
    if (validation.format === 'hex') {
      return color;
    }
    
    if (validation.format === 'rgb' || validation.format === 'rgba') {
      const match = color.match(/\d+/g);
      if (match && match.length >= 3) {
        const [r, g, b] = match.slice(0, 3).map(n => {
          const num = parseInt(n);
          return Math.max(0, Math.min(255, num)).toString(16).padStart(2, '0');
        });
        return `#${r}${g}${b}`;
      }
    }
    
    return null;
  }
  
  // Извлечение компонентов цвета
  static getComponents(color) {
    const validation = this.validate(color);
    if (!validation.isValid) return null;
    
    const format = validation.format;
    
    if (format === 'hex') {
      const hex = color.replace('#', '');
      if (hex.length === 3) {
        return {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16)
        };
      } else {
        return {
          r: parseInt(hex.substring(0, 2), 16),
          g: parseInt(hex.substring(2, 4), 16),
          b: parseInt(hex.substring(4, 6), 16)
        };
      }
    } else if (format === 'rgb' || format === 'rgba') {
      const match = color.match(/\d+/g);
      if (match && match.length >= 3) {
        return {
          r: parseInt(match[0]),
          g: parseInt(match[1]),
          b: parseInt(match[2]),
          a: match[3] ? parseFloat(match[3]) : 1
        };
      }
    }
    
    return null;
  }
}

// Примеры использования
const testColors = [
  '#ff0000',
  '#f00',
  'rgb(255, 0, 0)',
  'rgba(255, 0, 0, 0.5)',
  'hsl(0, 100%, 50%)',
  'invalid-color'
];

console.log('\n=== Валидация цветов ===');
testColors.forEach(color => {
  const validation = ColorValidator.validate(color);
  console.log(`${color}: ${validation.isValid ? '✓' : '✗'} [${validation.format || 'N/A'}]`);
  
  if (validation.isValid) {
    const hex = ColorValidator.toHex(color);
    const components = ColorValidator.getComponents(color);
    console.log(`  HEX: ${hex}, Компоненты:`, components);
  }
});
```

## Заключение

Валидация различных форматов с помощью регулярных выражений позволяет:

1. **Обеспечить целостность данных** на клиентской стороне
2. **Предотвратить ошибки ввода** пользователей
3. **Снизить нагрузку на сервер** за счет предварительной проверки
4. **Улучшить пользовательский опыт** за счет мгновенной обратной связи

При создании валидаторов важно учитывать баланс между строгостью проверки и удобством использования. В некоторых случаях может быть целесообразно использовать дополнительные проверки помимо регулярных выражений, особенно для форматов с контрольными суммами.

## Следующие шаги

После изучения валидации форматов рекомендуется:

- [[Санитизация данных]]
- [[Проверка сложных условий в строках]]
- [[Практические примеры]]