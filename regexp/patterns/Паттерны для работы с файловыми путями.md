---
aliases: ["Паттерны для работы с путями", "Path Regex Patterns", "Файловые пути"]
tags: [regexp, patterns, file-paths, validation, frontend, security]
---

# Паттерны для работы с файловыми путями

## Общие принципы работы с паттернами файловых путей

Работа с файловыми путями - частая задача в программировании, особенно при создании инструментов сборки, систем управления файлами и валидации. Регулярные выражения предоставляют мощный инструмент для разбора, валидации и преобразования файловых путей.

## 1. Валидация файловых путей

### Пути Unix/Linux

```javascript
// Валидация Unix/Linux пути
function validateUnixPath(path) {
  // Основное регулярное выражение для Unix пути
  const unixPathRegex = /^\/(?:[^\/\0]+\/)*[^\/\0]*$/;
  
  // Более строгая валидация с дополнительными проверками
  const strictUnixPathRegex = /^\/(?:[a-zA-Z0-9._-]+\/)*[a-zA-Z0-9._-]*(?:\.[a-zA-Z0-9]+)?$/;
  
  return {
    basic: unixPathRegex.test(path),
    strict: strictUnixPathRegex.test(path)
  };
}

// Извлечение компонентов Unix пути
function parseUnixPath(path) {
  const components = path.split('/').filter(Boolean);
  
  return {
    isAbsolute: path.startsWith('/'),
    root: path.startsWith('/') ? '/' : '',
    directory: components.slice(0, -1).join('/'),
    filename: components[components.length - 1] || '',
    components: components,
    depth: components.length
  };
}

// Примеры использования
console.log(validateUnixPath('/home/user/documents/file.txt')); // { basic: true, strict: true }
console.log(validateUnixPath('home/user/documents')); // { basic: false, strict: false } - неабсолютный путь
console.log(parseUnixPath('/var/log/application.log'));
```

### Пути Windows

```javascript
// Валидация Windows пути
function validateWindowsPath(path) {
  // Регулярное выражение для Windows пути
  const windowsPathRegex = /^[a-zA-Z]:\\(?:[^\\\/:*?"<>|\r\n]+\\)*[^\\\/:*?"<>|\r\n]*(?:\.[^\\\/:*?"<>|\r\n]+)?$/i;
  
  // Альтернативное выражение для сетевых путей
  const networkPathRegex = /^\\\\[^\\\/:*?"<>|\r\n]+\\[^\\\/:*?"<>|\r\n]+(?:\\[^\\\/:*?"<>|\r\n]*)*$/i;
  
  return {
    local: windowsPathRegex.test(path),
    network: networkPathRegex.test(path),
    valid: windowsPathRegex.test(path) || networkPathRegex.test(path)
  };
}

// Извлечение компонентов Windows пути
function parseWindowsPath(path) {
  // Проверяем, является ли сетевым путем
  if (path.startsWith('\\\\')) {
    const parts = path.split('\\');
    return {
      type: 'network',
      server: parts[2],
      share: parts[3],
      path: parts.slice(4).join('\\'),
      isAbsolute: true
    };
  }
  
  // Обычный локальный путь
  const match = path.match(/^([a-zA-Z]:\\)(.*)/i);
  if (match) {
    const [_, drive, rest] = match;
    const components = rest.split('\\').filter(Boolean);
    
    return {
      type: 'local',
      drive,
      directory: components.slice(0, -1).join('\\'),
      filename: components[components.length - 1] || '',
      components,
      isAbsolute: true
    };
  }
  
  return { type: 'relative', path };
}

// Примеры использования
console.log(validateWindowsPath('C:\\Users\\John\\Documents\\file.txt'));
console.log(validateWindowsPath('\\\\Server\\Share\\Folder\\file.txt'));
console.log(parseWindowsPath('C:\\Program Files\\Application\\app.exe'));
```

### Кроссплатформенная валидация

```javascript
// Кроссплатформенная валидация пути
function validatePath(path) {
  // Определяем тип пути по символам
  const isUnix = path.startsWith('/');
  const isWindows = /^[a-zA-Z]:\\/.test(path) || path.startsWith('\\\\');
  
  if (isUnix) {
    return { platform: 'unix', ...validateUnixPath(path) };
  } else if (isWindows) {
    return { platform: 'windows', ...validateWindowsPath(path) };
  } else {
    // Относительный путь - проверяем оба формата
    return {
      platform: 'relative',
      unix: validateUnixPath('./' + path).basic,
      windows: validateWindowsPath('.\\' + path).local
    };
  }
}

// Универсальный парсер путей
function parsePath(path) {
  if (path.startsWith('/')) {
    return { ...parseUnixPath(path), platform: 'unix' };
  } else if (/^[a-zA-Z]:\\/.test(path)) {
    return { ...parseWindowsPath(path), platform: 'windows' };
  } else if (path.startsWith('\\\\')) {
    return { ...parseWindowsPath(path), platform: 'windows-network' };
  } else {
    // Относительный путь
    const separator = path.includes('\\') ? '\\' : '/';
    const components = path.split(separator).filter(Boolean);
    
    return {
      platform: 'relative',
      directory: components.slice(0, -1).join(separator),
      filename: components[components.length - 1] || '',
      components,
      separator
    };
  }
}

// Примеры использования
console.log(validatePath('/home/user/file.txt'));
console.log(validatePath('C:\\Users\\John\\file.txt'));
console.log(parsePath('../folder/subfolder/file.js'));
```

## 2. Извлечение информации из путей

### Извлечение имени файла и расширения

```javascript
// Извлечение имени файла и расширения
function extractFileInfo(path) {
  // Регулярное выражение для извлечения имени файла и расширения
  const fileRegex = /.*[\/\\]([^\/\\]+?)(?:\.([^.\/\\]+))?$/;
  const match = path.match(fileRegex);
  
  if (match) {
    return {
      fullName: match[1],
      name: match[1].replace(/\.[^.]+$/, ''), // Имя без расширения
      extension: match[2] || '', // Расширение без точки
      hasExtension: !!match[2]
    };
  }
  
  return {
    fullName: '',
    name: '',
    extension: '',
    hasExtension: false
  };
}

// Извлечение всех расширений (для файлов с несколькими расширениями)
function extractAllExtensions(path) {
  const parts = path.split(/[\/\\]/);
  const filename = parts[parts.length - 1];
  
  if (!filename.includes('.')) {
    return { name: filename, extensions: [] };
  }
  
  const nameParts = filename.split('.');
  const name = nameParts[0];
  const extensions = nameParts.slice(1);
  
  return { name, extensions };
}

// Примеры использования
console.log(extractFileInfo('/home/user/document.pdf'));
console.log(extractFileInfo('C:\\Projects\\app.min.js'));
console.log(extractAllExtensions('archive.tar.gz'));
console.log(extractAllExtensions('image.photo.jpg'));
```

### Извлечение директории

```javascript
// Извлечение директории из пути
function extractDirectory(path) {
  // Для Unix путей
  if (path.startsWith('/')) {
    const lastSlash = path.lastIndexOf('/');
    if (lastSlash === 0) return '/'; // корневая директория
    if (lastSlash === -1) return '.'; // файл в текущей директории
    return path.substring(0, lastSlash);
  }
  
  // Для Windows путей
  if (path.includes('\\')) {
    const lastSlash = path.lastIndexOf('\\');
    if (lastSlash === 1 && /^[a-zA-Z]:\\/.test(path)) {
      return path.substring(0, 3); // диск:\
    }
    if (lastSlash === -1) return '.';
    return path.substring(0, lastSlash);
  }
  
  // Для путей с прямым слешем
  if (path.includes('/')) {
    const lastSlash = path.lastIndexOf('/');
    if (lastSlash === 0) return '/';
    if (lastSlash === -1) return '.';
    return path.substring(0, lastSlash);
  }
  
  return '.';
}

// Универсальный регулярный паттерн для извлечения директории
function extractDirectoryRegex(path) {
  // Паттерн, который захватывает директорию и имя файла
  const dirPattern = /^(.*[\/\\])([^\/\\]+)$/;
  const match = path.match(dirPattern);
  
  return match ? match[1] : (path.includes('/') || path.includes('\\')) ? '.' : '';
}

// Примеры использования
console.log(extractDirectory('/home/user/documents/file.txt'));
console.log(extractDirectory('C:\\Users\\John\\Desktop\\image.png'));
console.log(extractDirectoryRegex('/var/log/app.log'));
```

## 3. Преобразование и нормализация путей

### Нормализация разделителей

```javascript
// Нормализация разделителей пути
function normalizePathSeparators(path, targetSeparator = '/') {
  // Заменяем все возможные разделители на целевой
  return path.replace(/[\/\\]+/g, targetSeparator);
}

// Упрощение пути (удаление . и ..)
function simplifyPath(path) {
  const originalSeparator = path.includes('\\') ? '\\' : '/';
  const normalized = normalizePathSeparators(path, '/');
  
  const parts = normalized.split('/');
  const result = [];
  
  for (const part of parts) {
    if (part === '..') {
      result.pop(); // Удаляем предыдущий элемент
    } else if (part !== '.' && part !== '') {
      result.push(part);
    }
  }
  
  // Восстанавливаем исходный разделитель
  return result.join(originalSeparator) || (normalized.startsWith('/') ? originalSeparator : '');
}

// Примеры использования
console.log(normalizePathSeparators('C:\\Users\\John/../Jane', '/')); // C:/Users/Jane
console.log(simplifyPath('/home/user/./documents/../downloads')); // /home/user/downloads
console.log(simplifyPath('folder/../subfolder/./file.txt')); // subfolder/file.txt
```

### Проверка шаблонов путей (glob patterns)

```javascript
// Преобразование glob паттернов в регулярные выражения
function globToRegex(globPattern) {
  // Экранируем специальные регулярные символы
  let regexPattern = globPattern
    .replace(/\./g, '\\.') // Экранируем точки
    .replace(/\+/g, '\\+') // Экранируем плюсы
    .replace(/\?/g, '.') // Один символ
    .replace(/\*/g, '.*'); // Любое количество символов
  
  // Обработка квадратных скобок для наборов символов
  regexPattern = regexPattern.replace(/\[([^\]]+)\]/g, '[$1]');
  
  return new RegExp(`^${regexPattern}$`);
}

// Продвинутое преобразование glob в regex
function advancedGlobToRegex(globPattern) {
  // Обработка сложных паттернов вроде {txt,pdf,doc}
  let regexPattern = globPattern;
  
  // Обработка альтернации {option1,option2}
  regexPattern = regexPattern.replace(/\{([^}]+)\}/g, (match, options) => {
    const optionList = options.split(',').map(opt => opt.trim());
    return `(${optionList.join('|')})`;
  });
  
  // Экранирование и преобразование остальных символов
  regexPattern = regexPattern
    .replace(/\./g, '\\.')
    .replace(/\+/g, '\\+')
    .replace(/\?/g, '[^/\\\\]') // Один символ, кроме разделителя
    .replace(/\*\*/g, '.*') // Глубокий поиск
    .replace(/\*/g, '[^/\\\\]*'); // Один уровень
  
  return new RegExp(`^${regexPattern}$`);
}

// Проверка соответствия пути glob паттерну
function matchesGlob(path, globPattern) {
  const regex = advancedGlobToRegex(globPattern);
  return regex.test(path);
}

// Примеры использования
console.log(matchesGlob('/home/user/document.txt', '/home/user/*.txt')); // true
console.log(matchesGlob('/home/user/documents/file.pdf', '/home/user/**/*.pdf')); // true
console.log(matchesGlob('/home/user/config.json', '/home/user/{config,settings}.json')); // true
```

## 4. Специфические паттерны

### Паттерны для специфических типов файлов

```javascript
// Паттерны для различных типов файлов
const filePatterns = {
  // Изображения
  image: /\.(jpe?g|png|gif|bmp|webp|svg|tiff?)$/i,
  
  // Документы
  document: /\.(pdf|docx?|xlsx?|pptx?|txt|odt|ods|odp)$/i,
  
  // Архивы
  archive: /\.(zip|rar|7z|tar|gz|bz2|tar\.gz)$/i,
  
  // Исполняемые файлы
  executable: /\.(exe|msi|app|bin|sh|bat|cmd)$/i,
  
  // Код
  code: /\.(js|ts|jsx|tsx|html?|css|scss|sass|less|json|xml|py|java|cpp|c|h|cs|php|rb|go|rs|swift|kt|sql)$/i,
  
  // Конфигурационные файлы
  config: /\.(config|conf|ini|yml|yaml|toml|env|cfg)$/i,
  
  // Временные файлы
  temp: /\.(tmp|temp|log|cache|lock)$/i,
  
  // Системные файлы
  system: /^(config|system|boot|ntldr|pagefile|hiberfil)\./i
};

// Проверка типа файла
function getFileType(filename) {
  for (const [type, pattern] of Object.entries(filePatterns)) {
    if (pattern.test(filename)) {
      return type;
    }
  }
  return 'other';
}

// Группировка файлов по типам
function categorizeFiles(filenames) {
  const categories = {};
  
  for (const filename of filenames) {
    const type = getFileType(filename);
    if (!categories[type]) {
      categories[type] = [];
    }
    categories[type].push(filename);
  }
  
  return categories;
}

// Примеры использования
const files = [
  'document.pdf',
  'image.jpg',
  'script.js',
  'config.json',
  'archive.zip',
  'application.exe',
  'style.css'
];

console.log(categorizeFiles(files));
```

### Паттерны для специфических директорий

```javascript
// Паттерны для специфических директорий
const directoryPatterns = {
  // Системные директории
  system: /^\/(bin|sbin|usr|etc|var|tmp|proc|sys|dev)$|^C:\\(Windows|Program Files|ProgramData|Users)$/i,
  
  // Домашние директории
  home: /^\/home\/[^\/]+|^C:\\Users\\[^\\]+/i,
  
  // Временные директории
  temp: /^\/tmp|^C:\\Temp|^C:\\temp/i,
  
  // Директории проектов
  projectRoot: /(\/|\\)(src|lib|dist|build|node_modules|vendor)(\/|\\)/,
  
  // Конфигурационные директории
  config: /(\/|\\)(config|conf|etc)(\/|\\)/,
  
  // Директории с логами
  logs: /(\/|\\)(log|logs|logging)(\/|\\)/
};

// Проверка типа директории
function getDirectoryType(path) {
  for (const [type, pattern] of Object.entries(directoryPatterns)) {
    if (pattern.test(path)) {
      return type;
    }
  }
  return 'other';
}

// Примеры использования
console.log(getDirectoryType('/home/user/documents')); // home
console.log(getDirectoryType('C:\\Users\\John\\AppData')); // home
console.log(getDirectoryType('/var/log/application')); // logs
console.log(getDirectoryType('/project/src/components')); // projectRoot
```

## 5. Практические примеры использования

### Валидация загрузки файлов

```javascript
// Валидация файлов для загрузки
class FileUploadValidator {
  constructor(allowedTypes = [], maxSize = 10 * 1024 * 1024) { // 10MB по умолчанию
    this.allowedTypes = allowedTypes;
    this.maxSize = maxSize;
  }
  
  validatePath(filepath) {
    // Проверяем путь на безопасность
    if (this.isPathTraversal(filepath)) {
      return { valid: false, reason: 'Path traversal detected' };
    }
    
    // Проверяем расширение
    const ext = this.getFileExtension(filepath);
    if (this.allowedTypes.length > 0 && !this.allowedTypes.includes(ext.toLowerCase())) {
      return { valid: false, reason: `File type ${ext} not allowed` };
    }
    
    return { valid: true };
  }
  
  isPathTraversal(filepath) {
    // Проверяем на паттерны path traversal
    const traversalRegex = /\.\.\//g;
    return traversalRegex.test(normalizePathSeparators(filepath, '/'));
  }
  
  getFileExtension(filepath) {
    const match = filepath.match(/\.[^.\/\\]+$/);
    return match ? match[0].substring(1) : ''; // Убираем точку
  }
}

// Пример использования
const validator = new FileUploadValidator(['jpg', 'png', 'pdf'], 5 * 1024 * 1024); // 5MB
console.log(validator.validatePath('documents/report.pdf')); // { valid: true }
console.log(validator.validatePath('../config/passwords.txt')); // { valid: false, reason: 'Path traversal detected' }
```

### Поиск файлов по паттернам

```javascript
// Класс для поиска файлов по паттернам
class FilePatternMatcher {
  constructor() {
    this.compiledPatterns = new Map();
  }
  
  addPattern(name, pattern) {
    this.compiledPatterns.set(name, new RegExp(pattern, 'i'));
  }
  
  match(filepath, patternName) {
    const regex = this.compiledPatterns.get(patternName);
    return regex ? regex.test(filepath) : false;
  }
  
  matchMultiple(filepath, patternNames) {
    return patternNames.some(name => this.match(filepath, name));
  }
  
  // Поиск файлов по нескольким критериям
  findMatchingFiles(files, criteria) {
    return files.filter(filepath => {
      return Object.entries(criteria).every(([patternName, shouldMatch]) => {
        const matches = this.match(filepath, patternName);
        return shouldMatch ? matches : !matches;
      });
    });
  }
}

// Пример использования
const matcher = new FilePatternMatcher();

// Добавляем паттерны
matcher.addPattern('javascript', '\\.(js|jsx|ts|tsx)$');
matcher.addPattern('test', '.*\\.(test|spec)\\.js$');
matcher.addPattern('minified', '.*\\.min\\.[^.]+$');

const files = [
  'src/app.js',
  'src/components/button.jsx',
  'dist/app.min.js',
  'tests/button.test.js',
  'styles/main.css'
];

console.log('JavaScript files:', files.filter(f => matcher.match(f, 'javascript')));
console.log('Test files:', files.filter(f => matcher.match(f, 'test')));
console.log('Minified files:', files.filter(f => matcher.match(f, 'minified')));

// Поиск файлов с несколькими критериями
const criteria = {
  javascript: true,  // должен быть JS файлом
  test: false,       // не должен быть тестом
  minified: false    // не должен быть минифицированным
};

console.log('Production JS files:', matcher.findMatchingFiles(files, criteria));
```

## 6. Практические рекомендации

### Безопасность при работе с путями

```javascript
// Рекомендации по безопасности
const SecurityPatterns = {
  // Паттерны для обнаружения path traversal атак
  pathTraversal: [
    /\.\.\//g,      // Unix path traversal
    /\.\.\\/g,      // Windows path traversal
    /%2e%2e%2f/gi,  // URL encoded
    /\.\.\%2f/gi,   // Mixed encoding
  ],
  
  // Опасные имена файлов
  dangerousNames: [
    /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i,  // Windows reserved names
    /^\..*$/,  // Скрытые файлы (Unix)
  ],
  
  // Опасные расширения
  dangerousExtensions: /\.(exe|bat|cmd|sh|scr|pif|com|vbs|js|jse|wsf|wsh|msi|msp)$/i
};

// Функция проверки безопасности пути
function isPathSecure(filepath) {
  // Проверяем на path traversal
  for (const pattern of SecurityPatterns.pathTraversal) {
    if (pattern.test(filepath)) {
      return { secure: false, reason: 'Path traversal detected' };
    }
  }
  
  // Проверяем имя файла на опасные названия
  const filename = filepath.split(/[\/\\]/).pop();
  const basename = filename.replace(/\.[^/.]+$/, ""); // имя без расширения
  
  for (const pattern of SecurityPatterns.dangerousNames) {
    if (pattern.test(basename)) {
      return { secure: false, reason: 'Dangerous file name detected' };
    }
  }
  
  // Проверяем расширение
  if (SecurityPatterns.dangerousExtensions.test(filename)) {
    return { secure: false, reason: 'Dangerous file extension detected' };
  }
  
  return { secure: true };
}

// Примеры использования
console.log(isPathSecure('../../etc/passwd')); // { secure: false, reason: 'Path traversal detected' }
console.log(isPathSecure('C:\\Users\\John\\desktop.ini')); // { secure: false, reason: 'Dangerous file name detected' }
console.log(isPathSecure('script.exe')); // { secure: false, reason: 'Dangerous file extension detected' }
console.log(isPathSecure('document.pdf')); // { secure: true }
```

## Заключение

Паттерны для работы с файловыми путями являются важной частью многих приложений. Правильное использование регулярных выражений для валидации, извлечения и преобразования путей помогает создавать более надежные и безопасные приложения.

Ключевые моменты:
- Учитывайте различия между Unix и Windows путями
- Всегда проверяйте пути на безопасность
- Используйте нормализацию для упрощения работы с путями
- Валидируйте расширения файлов и типы директорий
- Рассмотрите использование специализированных библиотек для сложных операций