---
tags: [programming, regexp, validation, frontend, javascript, practical]
aliases: [валидация-данных-регулярными-выражениями, regexp-validation]
---

# Валидация данных с помощью регулярных выражений

В этой статье рассмотрим практические примеры валидации различных типов данных с помощью регулярных выражений в веб-разработке. Валидация данных является критически важной частью разработки приложений, особенно для обработки пользовательского ввода.

## Валидация электронной почты

Хотя полная валидация email по RFC может быть чрезвычайно сложной, для большинства веб-приложений достаточно простой проверки формата:

```javascript
class EmailValidator {
  // Простой паттерн для валидации email
  static basicEmailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  
  // Более строгий паттерн
  static strictEmailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  // Паттерн для валидации домена
  static domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}$/;

  static validate(email, options = {}) {
    const { strict = false, checkDomain = false } = options;
    
    if (!email || typeof email !== 'string') {
      return { isValid: false, errors: ['Email не может быть пустым'] };
    }

    const regex = strict ? this.strictEmailRegex : this.basicEmailRegex;
    const isValid = regex.test(email);
    
    if (!isValid) {
      return { 
        isValid: false, 
        errors: ['Некорректный формат email'] 
      };
    }
    
    // Дополнительная проверка домена при необходимости
    if (checkDomain) {
      const domain = email.split('@')[1];
      if (!this.domainRegex.test(domain)) {
        return { 
          isValid: false, 
          errors: ['Некорректный домен'] 
        };
      }
    }
    
    return { 
      isValid: true, 
      errors: [] 
    };
  }
  
  // Метод для получения домена из email
  static getDomain(email) {
    const match = email.match(/@(.+)/);
    return match ? match[1] : null;
  }
  
  // Метод для получения имени пользователя из email
  static getUsername(email) {
    const match = email.match(/^(.+)@/);
    return match ? match[1] : null;
  }
}

// Пример использования
const testEmails = [
  'user@example.com',
  'invalid.email',
  'user@domain',
  'test.email+tag@domain.co.uk'
];

testEmails.forEach(email => {
  const result = EmailValidator.validate(email);
  console.log(`${email}: ${result.isValid ? '✓' : '✗'} ${result.errors.join(', ')}`);
});
```

## Валидация телефонных номеров

Различные страны имеют разные форматы телефонных номеров, поэтому рассмотрим несколько подходов:

```javascript
class PhoneValidator {
  // Паттерны для разных стран
  static patterns = {
    international: /^\+?[\d\s\-\(\)]{7,15}$/,
    ru: /^(\+7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/,
    us: /^(\+1)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{4}$/,
    de: /^(\+49)?[\s\-]?\(?[0-9]{2,5}\)?[\s\-]?[0-9]{1,9}[\s\-]?[0-9]{1,9}$/,
    uk: /^(\+44)?[\s\-]?[0-9]{4}[\s\-]?[0-9]{6}$/,
    cn: /^(\+86)?[\s\-]?1[3-9]\d{9}$/
  };

  static validate(phone, country = 'international') {
    if (!phone || typeof phone !== 'string') {
      return { isValid: false, errors: ['Телефон не может быть пустым'] };
    }

    const pattern = this.patterns[country] || this.patterns.international;
    const isValid = pattern.test(phone);
    
    return {
      isValid,
      errors: isValid ? [] : [`Некорректный формат номера для страны: ${country}`]
    };
  }

  static format(phone, country = 'international') {
    // Очищаем номер от всех нецифровых символов (кроме + в начале)
    let cleanNumber = phone.replace(/[^\d+]/g, '');

    switch (country) {
      case 'ru':
        // Обработка российских номеров
        if (cleanNumber.length === 10) {
          cleanNumber = '+7' + cleanNumber;
        } else if (cleanNumber.length === 11 && cleanNumber[0] === '8') {
          cleanNumber = '+7' + cleanNumber.substring(1);
        }
        
        // Форматируем как +7 (XXX) XXX-XX-XX
        return cleanNumber.replace(/(\+7)(\d{3})(\d{3})(\d{2})(\d{2})/, "$1 ($2) $3-$4-$5");
        
      case 'us':
        // Обработка американских номеров
        if (cleanNumber.length === 10) {
          cleanNumber = '+1' + cleanNumber;
        } else if (cleanNumber.length === 11 && cleanNumber[0] === '1') {
          cleanNumber = '+' + cleanNumber;
        }
        
        // Форматируем как +1 (XXX) XXX-XXXX
        return cleanNumber.replace(/(\+1)(\d{3})(\d{3})(\d{4})/, "$1 ($2) $3-$4");
        
      default:
        // Общий формат
        return cleanNumber.replace(/(\d{1,4})(\d{3})(\d{3})(\d{2})(\d{2})/, "$1 $2 $3 $4 $5").trim();
    }
  }

  // Метод для определения страны по телефонному номеру
  static detectCountry(phone) {
    const cleanNumber = phone.replace(/[^\d+]/g, '');
    
    if (cleanNumber.startsWith('7') && cleanNumber.length === 11) return 'ru';
    if (cleanNumber.startsWith('1') && cleanNumber.length === 11) return 'us';
    if (cleanNumber.startsWith('49') && cleanNumber.length >= 11) return 'de';
    if (cleanNumber.startsWith('44') && cleanNumber.length >= 11) return 'uk';
    if (cleanNumber.startsWith('86') && cleanNumber.length === 13) return 'cn';
    
    return 'international';
  }
}

// Пример использования
const testPhones = [
  '89261234567',
  '+7 (926) 123-45-67',
  '1234567890',
  '+1 (555) 123-4567'
];

testPhones.forEach(phone => {
  const detectedCountry = PhoneValidator.detectCountry(phone);
  const validation = PhoneValidator.validate(phone, detectedCountry);
  const formatted = PhoneValidator.format(phone, detectedCountry);
  
  console.log(`${phone}:`);
  console.log(`  Страна: ${detectedCountry}`);
  console.log(`  Валидация: ${validation.isValid ? '✓' : '✗'}`);
  console.log(`  Форматированный: ${formatted}`);
  console.log('');
});
```

## Валидация URL и веб-адресов

Проверка корректности URL является важной задачей в веб-разработке:

```javascript
class UrlValidator {
  // Базовый паттерн для URL
  static basicUrlRegex = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i;
  
  // Более строгий паттерн для URL
  static strictUrlRegex = /^(https?|ftp):\/\/(([a-z\d]([a-z\d-]*[a-z\d])?\.)+[a-z]{2,}|((\d{1,3}\.){3}\d{1,3}))(:\d+)?(\/[-a-z\d%_.~+]*)*(\?[;&a-z\d%_.~+=-]*)?(#[-a-z\d_]*)?$/i;
  
  // Паттерн для домена
  static domainRegex = /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*\.[a-z]{2,}$/i;
  
  // Паттерн для IP-адреса
  static ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

  static validate(url, options = {}) {
    const { strict = false, requireProtocol = true } = options;
    
    if (!url || typeof url !== 'string') {
      return { isValid: false, errors: ['URL не может быть пустым'] };
    }

    const regex = strict ? this.strictUrlRegex : this.basicUrlRegex;
    
    // Если протокол не обязателен, добавляем его для проверки
    const urlToTest = requireProtocol ? url : (url.startsWith('http') ? url : 'http://' + url);
    
    const isValid = regex.test(urlToTest);
    
    if (!isValid) {
      return { 
        isValid: false, 
        errors: ['Некорректный формат URL'] 
      };
    }
    
    return { 
      isValid: true, 
      errors: [] 
    };
  }
  
  // Извлечение домена из URL
  static extractDomain(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname;
    } catch (e) {
      // Альтернативный метод через регулярные выражения
      const match = url.match(/https?:\/\/(?:www\.)?([^\/\?#]+)/i);
      return match ? match[1] : null;
    }
  }
  
  // Извлечение протокола из URL
  static extractProtocol(url) {
    const match = url.match(/^(https?|ftp):\/\//i);
    return match ? match[1].toLowerCase() : null;
  }
  
  // Проверка, является ли домен IP-адресом
  static isIpAddress(domain) {
    return this.ipRegex.test(domain);
  }
  
  // Нормализация URL (удаление лишних слэшей, приведение к нижнему регистру и т.д.)
  static normalize(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.toString();
    } catch (e) {
      // Альтернативная нормализация через регулярные выражения
      return url
        .replace(/([^:]\/)\/+/g, '$1') // удаление двойных слэшей
        .toLowerCase(); // приведение к нижнему регистру
    }
  }
}

// Пример использования
const testUrls = [
  'https://example.com',
  'http://www.example.com/path?query=1',
  'ftp://files.example.com',
  'example.com',
  'invalid-url'
];

testUrls.forEach(url => {
  const validation = UrlValidator.validate(url);
  const domain = UrlValidator.extractDomain(url);
  const protocol = UrlValidator.extractProtocol(url);
  const normalized = UrlValidator.normalize(url);
  
  console.log(`${url}:`);
  console.log(`  Валидация: ${validation.isValid ? '✓' : '✗'}`);
  console.log(`  Домен: ${domain || 'не определен'}`);
  console.log(`  Протокол: ${protocol || 'не определен'}`);
  console.log(`  Нормализованный: ${normalized}`);
  console.log('');
});
```

## Валидация форматов дат и времени

Работа с датами и временем требует особого внимания к форматам:

```javascript
class DateTimeValidator {
  // Паттерны для разных форматов дат
  static datePatterns = {
    'DD/MM/YYYY': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}$/,
    'MM/DD/YYYY': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/,
    'YYYY/MM/DD': /^\d{4}\/(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])$/,
    'DD-MM-YYYY': /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-\d{4}$/,
    'MM-DD-YYYY': /^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-\d{4}$/,
    'YYYY-MM-DD': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/,
    'DD.MM.YYYY': /^(0[1-9]|[12][0-9]|3[01])\.(0[1-9]|1[0-2])\.\d{4}$/
  };
  
  // Паттерны для времени
  static timePatterns = {
    'HH:MM': /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'HH:MM:SS': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'HH:MM:SS.A': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\.[0-9]{1,3}$/
  };
  
  // Паттерны для даты и времени
  static dateTimePatterns = {
    'DD/MM/YYYY HH:MM': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'YYYY-MM-DDTHH:MM:SS': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'YYYY-MM-DD HH:MM:SS': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/
  };

  static validateDate(dateString, format = 'DD/MM/YYYY') {
    if (!dateString || typeof dateString !== 'string') {
      return { isValid: false, errors: ['Дата не может быть пустой'] };
    }

    const pattern = this.datePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат даты: ${format}`] };
    }

    if (!pattern.test(dateString)) {
      return { isValid: false, errors: ['Некорректный формат даты'] };
    }

    // Дополнительная проверка корректности даты
    try {
      let [day, month, year] = dateString.split(/[-/.]/).map(Number);
      
      // Для форматов MM/DD/YYYY и YYYY/MM/DD меняем порядок
      if (format === 'MM/DD/YYYY') {
        [month, day, year] = [day, month, year];
      } else if (format === 'YYYY/MM/DD') {
        [year, month, day] = [day, month, year];
      }
      
      const date = new Date(year, month - 1, day);
      
      if (date.getFullYear() !== year || 
          date.getMonth() !== month - 1 || 
          date.getDate() !== day) {
        return { isValid: false, errors: ['Несуществующая дата'] };
      }
      
      return { isValid: true, errors: [] };
    } catch (e) {
      return { isValid: false, errors: ['Ошибка при проверке даты'] };
    }
  }

  static validateTime(timeString, format = 'HH:MM') {
    if (!timeString || typeof timeString !== 'string') {
      return { isValid: false, errors: ['Время не может быть пустым'] };
    }

    const pattern = this.timePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат времени: ${format}`] };
    }

    if (!pattern.test(timeString)) {
      return { isValid: false, errors: ['Некорректный формат времени'] };
    }

    // Дополнительная проверка значений
    const [hours, minutes, seconds] = timeString.split(':').map(Number);
    
    if (hours > 23 || minutes > 59 || (seconds !== undefined && seconds > 59)) {
      return { isValid: false, errors: ['Некорректные значения времени'] };
    }

    return { isValid: true, errors: [] };
  }

  static validateDateTime(dateTimeString, format = 'YYYY-MM-DD HH:MM:SS') {
    if (!dateTimeString || typeof dateTimeString !== 'string') {
      return { isValid: false, errors: ['Дата и время не могут быть пустыми'] };
    }

    const pattern = this.dateTimePatterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат даты и времени: ${format}`] };
    }

    if (!pattern.test(dateTimeString)) {
      return { isValid: false, errors: ['Некорректный формат даты и времени'] };
    }

    // Разделение даты и времени для отдельной проверки
    const parts = dateTimeString.split(/\s+/);
    if (parts.length < 2) {
      return { isValid: false, errors: ['Невозможно разделить дату и время'] };
    }

    // Определение форматов даты и времени на основе общего формата
    let dateFormat, timeFormat;
    
    switch (format) {
      case 'DD/MM/YYYY HH:MM':
        dateFormat = 'DD/MM/YYYY';
        timeFormat = 'HH:MM';
        break;
      case 'YYYY-MM-DDTHH:MM:SS':
        dateFormat = 'YYYY-MM-DD';
        timeFormat = 'HH:MM:SS';
        break;
      case 'YYYY-MM-DD HH:MM:SS':
        dateFormat = 'YYYY-MM-DD';
        timeFormat = 'HH:MM:SS';
        break;
      default:
        return { isValid: false, errors: ['Неподдерживаемый формат'] };
    }

    const dateValidation = this.validateDate(parts[0], dateFormat);
    if (!dateValidation.isValid) {
      return { isValid: false, errors: [`Ошибка в дате: ${dateValidation.errors.join(', ')}`] };
    }

    const timeValidation = this.validateTime(parts[1].replace('T', ''), timeFormat);
    if (!timeValidation.isValid) {
      return { isValid: false, errors: [`Ошибка во времени: ${timeValidation.errors.join(', ')}`] };
    }

    return { isValid: true, errors: [] };
  }

  // Преобразование даты из одного формата в другой
  static convertDateFormat(dateString, fromFormat, toFormat) {
    const validation = this.validateDate(dateString, fromFormat);
    if (!validation.isValid) {
      return null;
    }

    // Извлечение компонентов даты
    let [day, month, year] = dateString.split(/[-/.]/).map(Number);
    
    if (fromFormat === 'MM/DD/YYYY') {
      [month, day, year] = [day, month, year];
    } else if (fromFormat === 'YYYY/MM/DD') {
      [year, month, day] = [day, month, year];
    }

    // Форматирование в новый формат
    switch (toFormat) {
      case 'DD/MM/YYYY':
        return `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;
      case 'MM/DD/YYYY':
        return `${month.toString().padStart(2, '0')}/${day.toString().padStart(2, '0')}/${year}`;
      case 'YYYY/MM/DD':
        return `${year}/${month.toString().padStart(2, '0')}/${day.toString().padStart(2, '0')}`;
      case 'DD-MM-YYYY':
        return `${day.toString().padStart(2, '0')}-${month.toString().padStart(2, '0')}-${year}`;
      case 'YYYY-MM-DD':
        return `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
      default:
        return null;
    }
  }
}

// Пример использования
const testDates = [
  { date: '29/02/2024', format: 'DD/MM/YYYY' },
  { date: '29/02/2023', format: 'DD/MM/YYYY' }, // не високосный год
  { date: '12/25/2023', format: 'MM/DD/YYYY' },
  { date: '2023-12-25', format: 'YYYY-MM-DD' }
];

testDates.forEach(({ date, format }) => {
  const validation = DateTimeValidator.validateDate(date, format);
  console.log(`${date} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors.join(', ')}`);
});

// Пример преобразования формата
const converted = DateTimeValidator.convertDateFormat('25/12/2023', 'DD/MM/YYYY', 'YYYY-MM-DD');
console.log(`Преобразованная дата: ${converted}`); // 2023-12-25
```

## Валидация сложных форматов

Рассмотрим валидацию более сложных форматов, таких как артикулы, коды, идентификаторы:

```javascript
class ComplexFormatValidator {
  // Паттерны для различных форматов
  static patterns = {
    // ISBN-10 и ISBN-13
    isbn: /^(?:\d{9}[\dX]|\d{10})$|^(?:\d{13})$/,
    
    // ИНН (российский)
    inn: /^\d{10}$|^\d{12}$/,
    
    // КПП (российский)
    kpp: /^\d{9}$/,
    
    // ОГРН (российский)
    ogrn: /^\d{13}$|^\d{15}$/,
    
    // СНИЛС (российский)
    snils: /^\d{3}-\d{3}-\d{3} \d{2}$/,
    
    // Серия и номер паспорта (российский)
    passport: /^\d{4} \d{6}$/,
    
    // Номер водительского удостоверения (российский)
    driverLicense: /^\d{2} \d{2} \d{6}$/,
    
    // Номер СТС (российский)
    sts: /^[ABEKMHOPCTYX]\d{3}[ABEKMHOPCTYX]{2}\d{2,3}$/,
    
    // Номер свидетельства о регистрации ТС (российский)
    registration: /^\d{4}-\d{6}$/,
    
    // Номер банковской карты
    cardNumber: /^\d{4} \d{4} \d{4} \d{4}$|^\d{16}$/,
    
    // Номер счета в банке
    accountNumber: /^40[0-9]{19}$|^[0-9]{20}$/,
    
    // БИК (российский)
    bik: /^\d{9}$/
  };

  static validate(formatName, value) {
    const pattern = this.patterns[formatName];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат: ${formatName}`] };
    }

    if (!value || typeof value !== 'string') {
      return { isValid: false, errors: ['Значение не может быть пустым'] };
    }

    // Для некоторых форматов нужна дополнительная логическая проверка
    switch (formatName) {
      case 'isbn':
        return this.validateISBN(value);
      case 'snils':
        return this.validateSNILS(value);
      case 'inn':
        return this.validateINN(value);
      default:
        const isValid = pattern.test(value);
        return {
          isValid,
          errors: isValid ? [] : [`Некорректный формат ${formatName}`]
        };
    }
  }

  // Валидация ISBN
  static validateISBN(isbn) {
    // Удаляем дефисы и пробелы
    const cleanIsbn = isbn.replace(/[-\s]/g, '');

    if (cleanIsbn.length === 10) {
      // ISBN-10
      const regex = /^(?:\d{9}[\dX]|\d{10})$/;
      if (!regex.test(cleanIsbn)) return { isValid: false, errors: ['Некорректный ISBN-10'] };

      // Проверка контрольной суммы для ISBN-10
      let sum = 0;
      for (let i = 0; i < 9; i++) {
        sum += parseInt(cleanIsbn[i]) * (10 - i);
      }

      const lastChar = cleanIsbn[9];
      const lastValue = lastChar === 'X' ? 10 : parseInt(lastChar);
      sum += lastValue;

      return { isValid: sum % 11 === 0, errors: [] };
    } else if (cleanIsbn.length === 13) {
      // ISBN-13
      const regex = /^\d{13}$/;
      if (!regex.test(cleanIsbn)) return { isValid: false, errors: ['Некорректный ISBN-13'] };

      // Проверка контрольной суммы для ISBN-13
      let sum = 0;
      for (let i = 0; i < 12; i++) {
        sum += parseInt(cleanIsbn[i]) * (i % 2 === 0 ? 1 : 3);
      }

      const checkDigit = (10 - (sum % 10)) % 10;
      return { isValid: checkDigit === parseInt(cleanIsbn[12]), errors: [] };
    }

    return { isValid: false, errors: ['Неподдерживаемая длина ISBN'] };
  }

  // Валидация СНИЛС
  static validateSNILS(snils) {
    // Проверяем формат
    if (!this.patterns.snils.test(snils)) {
      return { isValid: false, errors: ['Некорректный формат СНИЛС'] };
    }

    // Удаляем все разделители
    const cleanSnils = snils.replace(/[-\s]/g, '');
    
    // Извлекаем контрольное число
    const controlNumber = parseInt(cleanSnils.slice(-2));
    
    // Извлекаем основную часть
    const mainPart = cleanSnils.slice(0, -2);
    
    // Вычисляем контрольное число
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += parseInt(mainPart[i]) * (9 - i);
    }
    
    let calculatedControl = sum % 101;
    if (calculatedControl > 100) calculatedControl = calculatedControl % 100;
    
    return { isValid: controlNumber === calculatedControl, errors: [] };
  }

  // Валидация ИНН
  static validateINN(inn) {
    if (!this.patterns.inn.test(inn)) {
      return { isValid: false, errors: ['Некорректный формат ИНН'] };
    }

    const digits = inn.split('').map(Number);
    
    if (inn.length === 10) {
      // Для юридических лиц
      const checkDigit = (2 * digits[0] + 4 * digits[1] + 10 * digits[2] + 
                         3 * digits[3] + 5 * digits[4] + 9 * digits[5] + 
                         4 * digits[6] + 6 * digits[7] + 8 * digits[8]) % 11 % 10;
      
      return { isValid: checkDigit === digits[9], errors: [] };
    } else if (inn.length === 12) {
      // Для физических лиц
      const checkDigits = [
        (7 * digits[0] + 2 * digits[1] + 4 * digits[2] + 10 * digits[3] + 
         3 * digits[4] + 5 * digits[5] + 9 * digits[6] + 4 * digits[7] + 
         6 * digits[8] + 8 * digits[9]) % 11 % 10,
        (3 * digits[0] + 7 * digits[1] + 2 * digits[2] + 4 * digits[3] + 
         10 * digits[4] + 3 * digits[5] + 5 * digits[6] + 9 * digits[7] + 
         4 * digits[8] + 6 * digits[9] + 8 * digits[10]) % 11 % 10
      ];
      
      return { 
        isValid: checkDigits[0] === digits[10] && checkDigits[1] === digits[11], 
        errors: [] 
      };
    }

    return { isValid: false, errors: ['Неподдерживаемая длина ИНН'] };
  }
}

// Пример использования
const testComplex = [
  { format: 'snils', value: '123-456-789 12' },
  { format: 'inn', value: '1234567890' },
  { format: 'passport', value: '1234 567890' },
  { format: 'isbn', value: '0-306-40615-2' }
];

testComplex.forEach(({ format, value }) => {
  const validation = ComplexFormatValidator.validate(format, value);
  console.log(`${value} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors.join(', ')}`);
});
```

## Заключение

Валидация данных с помощью регулярных выражений — это мощный инструмент в веб-разработке. Однако важно помнить, что:

1. Регулярные выражения не всегда подходят для сложной валидации (например, полной проверки email по RFC)
2. Для критических данных всегда стоит использовать серверную валидацию
3. Нужно учитывать производительность при использовании сложных регулярных выражений
4. Важно тестировать регулярные выражения на уязвимости ReDoS (Regular Expression Denial of Service)

Для более сложных случаев валидации рекомендуется использовать специализированные библиотеки, такие как Joi, Yup или Zod.

## Следующие шаги

После изучения валидации данных рекомендуется:

- [[Извлечение данных из текста]]
- [[Поиск и замена в строках]]
- [[Работа с форматами дат и времени]]