---
tags: [programming, regexp, date-time, frontend, javascript, practical]
aliases: [работа-с-форматами-дат-и-времени, regexp-date-time]
---

# Работа с форматами дат и времени с помощью регулярных выражений

В этой статье рассмотрим практические примеры работы с форматами дат и времени с использованием регулярных выражений в веб-разработке. Обработка дат и времени — важная задача во многих приложениях, от календарей до систем аналитики.

## Основы работы с датами и временем

Для работы с датами и временем в JavaScript можно использовать как встроенные объекты `Date`, так и регулярные выражения для валидации и извлечения форматов.

```javascript
// Простые паттерны для основных форматов дат
const datePatterns = {
  // DD/MM/YYYY или DD.MM.YYYY или DD-MM-YYYY
  'DD/MM/YYYY': /^(0[1-9]|[12][0-9]|3[01])[\/\-\.](0[1-9]|1[0-2])[\/\-\.]\d{4}$/,
  
  // MM/DD/YYYY
  'MM/DD/YYYY': /^(0[1-9]|1[0-2])[\/\-\.](0[1-9]|[12][0-9]|3[01])[\/\-\.]\d{4}$/,
  
  // YYYY/MM/DD
  'YYYY/MM/DD': /^\d{4}[\/\-\.](0[1-9]|1[0-2])[\/\-\.](0[1-9]|[12][0-9]|3[01])$/,
  
  // ISO 8601: YYYY-MM-DD
  'ISO': /^\d{4}-\d{2}-\d{2}$/
};

// Простые паттерны для форматов времени
const timePatterns = {
  // HH:MM
  'HH:MM': /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
  
  // HH:MM:SS
  'HH:MM:SS': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
  
  // HH:MM:SS.mmm (с миллисекундами)
  'HH:MM:SS.mmm': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\.\d{1,3}$/
};

// Пример проверки даты
function validateDate(dateString, format = 'ISO') {
  const pattern = datePatterns[format];
  if (!pattern) {
    throw new Error(`Неизвестный формат даты: ${format}`);
  }
  
  return pattern.test(dateString);
}

// Пример проверки времени
function validateTime(timeString, format = 'HH:MM:SS') {
  const pattern = timePatterns[format];
  if (!pattern) {
    throw new Error(`Неизвестный формат времени: ${format}`);
  }
  
  return pattern.test(timeString);
}

console.log(validateDate('2023-12-25')); // true
console.log(validateTime('14:30:00')); // true
```

## Валидация различных форматов дат

```javascript
class DateValidator {
  static patterns = {
    // Популярные форматы дат
    'DD/MM/YYYY': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}$/,
    'DD-MM-YYYY': /^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-\d{4}$/,
    'DD.MM.YYYY': /^(0[1-9]|[12][0-9]|3[01])\.(0[1-9]|1[0-2])\.\d{4}$/,
    'MM/DD/YYYY': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/,
    'YYYY/MM/DD': /^\d{4}\/(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])$/,
    'YYYY-MM-DD': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/,
    'YYYY.MM.DD': /^\d{4}\.(0[1-9]|1[0-2])\.(0[1-9]|[12][0-9]|3[01])$/,
    'DD MMM YYYY': /^(0[1-9]|[12][0-9]|3[01])\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}$/i,
    'DD Month YYYY': /^(0[1-9]|[12][0-9]|3[01])\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}$/i
  };

  static validate(dateString, format = 'YYYY-MM-DD') {
    const pattern = this.patterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат: ${format}`] };
    }

    if (!pattern.test(dateString)) {
      return { isValid: false, errors: ['Некорректный формат даты'] };
    }

    // Дополнительная проверка корректности даты
    try {
      let [day, month, year] = this.extractDateComponents(dateString, format);
      
      const date = new Date(year, month - 1, day);
      
      if (date.getFullYear() !== year || 
          date.getMonth() !== month - 1 || 
          date.getDate() !== day) {
        return { isValid: false, errors: ['Несуществующая дата'] };
      }
      
      return { isValid: true, errors: [] };
    } catch (e) {
      return { isValid: false, errors: ['Ошибка при проверке даты'] };
    }
  }

  static extractDateComponents(dateString, format) {
    const pattern = this.patterns[format];
    if (!pattern) {
      throw new Error(`Неизвестный формат: ${format}`);
    }

    const match = dateString.match(pattern);
    if (!match) {
      throw new Error(`Строка не соответствует формату: ${format}`);
    }

    let day, month, year;

    switch (format) {
      case 'DD/MM/YYYY':
      case 'DD-MM-YYYY':
      case 'DD.MM.YYYY':
        day = parseInt(match[1]);
        month = parseInt(match[2]);
        year = parseInt(match[3]);
        break;
      case 'MM/DD/YYYY':
        month = parseInt(match[1]);
        day = parseInt(match[2]);
        year = parseInt(match[3]);
        break;
      case 'YYYY/MM/DD':
      case 'YYYY-MM-DD':
      case 'YYYY.MM.DD':
        year = parseInt(match[1]);
        month = parseInt(match[2]);
        day = parseInt(match[3]);
        break;
      case 'DD MMM YYYY':
        day = parseInt(match[1]);
        month = this.getMonthNumber(match[2]);
        year = parseInt(match[3]);
        break;
      case 'DD Month YYYY':
        day = parseInt(match[1]);
        month = this.getMonthNumber(match[2]);
        year = parseInt(match[3]);
        break;
      default:
        throw new Error(`Формат не поддерживается: ${format}`);
    }

    return [day, month, year];
  }

  static getMonthNumber(monthName) {
    const months = {
      'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12,
      'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
      'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12
    };

    return months[monthName] || 0;
  }

  // Метод для определения формата даты
  static detectFormat(dateString) {
    for (const [format, pattern] of Object.entries(this.patterns)) {
      if (pattern.test(dateString)) {
        return format;
      }
    }
    return null;
  }
}

// Примеры использования
const testDates = [
  '25/12/2023',
  '2023-12-25',
  '25.12.2023',
  '25 Dec 2023',
  '29/02/2024', // високосный год
  '29/02/2023'  // не високосный год
];

testDates.forEach(date => {
  const format = DateValidator.detectFormat(date);
  const validation = DateValidator.validate(date, format);
  console.log(`${date} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors.join(', ')}`);
});
```

## Валидация форматов времени

```javascript
class TimeValidator {
  static patterns = {
    // Форматы времени
    'HH:MM': /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'HH:MM:SS': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'HH:MM:SS.mmm': /^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\.\d{1,3}$/,
    'HH:MM AM/PM': /^(0?[1-9]|1[0-2]):[0-5][0-9]\s?(AM|PM|am|pm)$/i,
    'HH:MM:SS AM/PM': /^(0?[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9]\s?(AM|PM|am|pm)$/i
  };

  static validate(timeString, format = 'HH:MM:SS') {
    const pattern = this.patterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат: ${format}`] };
    }

    if (!pattern.test(timeString)) {
      return { isValid: false, errors: ['Некорректный формат времени'] };
    }

    // Дополнительная проверка значений
    try {
      const components = this.extractTimeComponents(timeString, format);
      const [hours, minutes, seconds = 0, milliseconds = 0] = components;

      if (format.includes('AM/PM')) {
        // Для 12-часового формата
        if (hours < 1 || hours > 12) {
          return { isValid: false, errors: ['Часы должны быть от 1 до 12'] };
        }
      } else {
        // Для 24-часового формата
        if (hours < 0 || hours > 23) {
          return { isValid: false, errors: ['Часы должны быть от 0 до 23'] };
        }
      }

      if (minutes < 0 || minutes > 59) {
        return { isValid: false, errors: ['Минуты должны быть от 0 до 59'] };
      }

      if (seconds < 0 || seconds > 59) {
        return { isValid: false, errors: ['Секунды должны быть от 0 до 59'] };
      }

      if (milliseconds < 0 || milliseconds > 999) {
        return { isValid: false, errors: ['Миллисекунды должны быть от 0 до 999'] };
      }

      return { isValid: true, errors: [] };
    } catch (e) {
      return { isValid: false, errors: ['Ошибка при проверке времени'] };
    }
  }

  static extractTimeComponents(timeString, format) {
    const pattern = this.patterns[format];
    if (!pattern) {
      throw new Error(`Неизвестный формат: ${format}`);
    }

    const match = timeString.match(pattern);
    if (!match) {
      throw new Error(`Строка не соответствует формату: ${format}`);
    }

    let hours, minutes, seconds, milliseconds;

    switch (format) {
      case 'HH:MM':
        hours = parseInt(match[1]);
        minutes = parseInt(match[2]);
        return [hours, minutes];
      case 'HH:MM:SS':
        hours = parseInt(match[1]);
        minutes = parseInt(match[2]);
        seconds = parseInt(match[3]);
        return [hours, minutes, seconds];
      case 'HH:MM:SS.mmm':
        hours = parseInt(match[1]);
        minutes = parseInt(match[2]);
        seconds = parseInt(match[3]);
        milliseconds = parseInt(match[4]);
        return [hours, minutes, seconds, milliseconds];
      case 'HH:MM AM/PM':
        hours = parseInt(match[1]);
        minutes = parseInt(match[2]);
        const period = match[3].toUpperCase();
        if (period === 'AM' && hours === 12) hours = 0;
        if (period === 'PM' && hours !== 12) hours = hours + 12;
        return [hours, minutes];
      case 'HH:MM:SS AM/PM':
        hours = parseInt(match[1]);
        minutes = parseInt(match[2]);
        seconds = parseInt(match[3]);
        const period2 = match[4].toUpperCase();
        if (period2 === 'AM' && hours === 12) hours = 0;
        if (period2 === 'PM' && hours !== 12) hours = hours + 12;
        return [hours, minutes, seconds];
      default:
        throw new Error(`Формат не поддерживается: ${format}`);
    }
  }

  // Метод для определения формата времени
  static detectFormat(timeString) {
    for (const [format, pattern] of Object.entries(this.patterns)) {
      if (pattern.test(timeString)) {
        return format;
      }
    }
    return null;
  }
}

// Примеры использования
const testTimes = [
  '14:30:00',
  '02:30 PM',
  '02:30:45 AM',
  '25:00:00', // некорректное время
  '14:70:00'  // некорректные минуты
];

testTimes.forEach(time => {
  const format = TimeValidator.detectFormat(time);
  const validation = TimeValidator.validate(time, format);
  console.log(`${time} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors.join(', ')}`);
});
```

## Валидация форматов даты и времени

```javascript
class DateTimeValidator {
  static patterns = {
    // Комбинированные форматы даты и времени
    'YYYY-MM-DD HH:MM:SS': /^\d{4}-\d{2}-\d{2}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'YYYY-MM-DDTHH:MM:SS': /^\d{4}-\d{2}-\d{2}T([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/,
    'YYYY-MM-DDTHH:MM:SSZ': /^\d{4}-\d{2}-\d{2}T([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]Z$/,
    'YYYY-MM-DDTHH:MM:SS.sssZ': /^\d{4}-\d{2}-\d{2}T([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\.\d{3}Z$/,
    'DD/MM/YYYY HH:MM': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    'MM/DD/YYYY HH:MM:SS': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/
  };

  static validate(dateTimeString, format = 'YYYY-MM-DD HH:MM:SS') {
    const pattern = this.patterns[format];
    if (!pattern) {
      return { isValid: false, errors: [`Неизвестный формат: ${format}`] };
    }

    if (!pattern.test(dateTimeString)) {
      return { isValid: false, errors: ['Некорректный формат даты и времени'] };
    }

    try {
      // Разделяем дату и время
      const parts = dateTimeString.split(/\s+|T/);
      if (parts.length < 2) {
        return { isValid: false, errors: ['Невозможно разделить дату и время'] };
      }

      // Определяем форматы даты и времени
      let dateFormat, timeFormat;
      
      switch (format) {
        case 'YYYY-MM-DD HH:MM:SS':
          dateFormat = 'YYYY-MM-DD';
          timeFormat = 'HH:MM:SS';
          break;
        case 'YYYY-MM-DDTHH:MM:SS':
        case 'YYYY-MM-DDTHH:MM:SSZ':
          dateFormat = 'YYYY-MM-DD';
          timeFormat = 'HH:MM:SS';
          break;
        case 'YYYY-MM-DDTHH:MM:SS.sssZ':
          dateFormat = 'YYYY-MM-DD';
          timeFormat = 'HH:MM:SS.mmm';
          break;
        case 'DD/MM/YYYY HH:MM':
          dateFormat = 'DD/MM/YYYY';
          timeFormat = 'HH:MM';
          break;
        case 'MM/DD/YYYY HH:MM:SS':
          dateFormat = 'MM/DD/YYYY';
          timeFormat = 'HH:MM:SS';
          break;
        default:
          return { isValid: false, errors: ['Неподдерживаемый формат'] };
      }

      // Проверяем дату
      const dateValidation = DateValidator.validate(parts[0], dateFormat);
      if (!dateValidation.isValid) {
        return { isValid: false, errors: [`Ошибка в дате: ${dateValidation.errors.join(', ')}`] };
      }

      // Проверяем время (удаляем Z в конце для проверки времени)
      let timePart = parts[1];
      if (timePart.endsWith('Z')) {
        timePart = timePart.slice(0, -1);
      }
      
      const timeValidation = TimeValidator.validate(timePart, timeFormat);
      if (!timeValidation.isValid) {
        return { isValid: false, errors: [`Ошибка во времени: ${timeValidation.errors.join(', ')}`] };
      }

      return { isValid: true, errors: [] };
    } catch (e) {
      return { isValid: false, errors: ['Ошибка при проверке даты и времени'] };
    }
  }

  // Метод для определения формата даты и времени
  static detectFormat(dateTimeString) {
    for (const [format, pattern] of Object.entries(this.patterns)) {
      if (pattern.test(dateTimeString)) {
        return format;
      }
    }
    return null;
  }

  // Преобразование между форматами
  static convertFormat(dateTimeString, fromFormat, toFormat) {
    const validation = this.validate(dateTimeString, fromFormat);
    if (!validation.isValid) {
      return null;
    }

    try {
      // Извлекаем компоненты
      const [datePart, timePart] = dateTimeString.split(/\s+|T/);
      
      // Преобразуем в объект Date для унификации
      let date;
      if (fromFormat.includes('T') && dateTimeString.includes('Z')) {
        // Если формат содержит Z, это UTC время
        date = new Date(dateTimeString);
      } else {
        // Иначе создаем локальное время
        const [year, month, day] = datePart.split(/[-/.]/).map(Number);
        const [hours, minutes, seconds = 0] = timePart.replace('Z', '').split(':').map(Number);
        date = new Date(year, month - 1, day, hours, minutes, seconds);
      }

      // Преобразуем в требуемый формат
      switch (toFormat) {
        case 'YYYY-MM-DD HH:MM:SS':
          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
        case 'DD/MM/YYYY HH:MM':
          return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        case 'YYYY-MM-DDTHH:MM:SSZ':
          return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
        default:
          throw new Error(`Неподдерживаемый формат для конвертации: ${toFormat}`);
      }
    } catch (e) {
      return null;
    }
  }
}

// Примеры использования
const testDateTimes = [
  '2023-12-25 14:30:00',
  '2023-12-25T14:30:00',
  '25/12/2023 14:30',
  '2023-12-25T14:30:00Z',
  '2023-12-25 25:30:00' // некорректное время
];

testDateTimes.forEach(dateTime => {
  const format = DateTimeValidator.detectFormat(dateTime);
  const validation = DateTimeValidator.validate(dateTime, format);
  console.log(`${dateTime} (${format}): ${validation.isValid ? '✓' : '✗'} ${validation.errors.join(', ')}`);
});

// Пример преобразования формата
const converted = DateTimeValidator.convertFormat('2023-12-25 14:30:00', 'YYYY-MM-DD HH:MM:SS', 'DD/MM/YYYY HH:MM');
console.log(`Преобразованное время: ${converted}`); // 25/12/2023 14:30
```

## Извлечение дат и времени из текста

```javascript
class DateTimeExtractor {
  // Паттерны для извлечения дат и времени из текста
  static patterns = {
    date: /\b(0[1-9]|[12][0-9]|3[01])[\/\-\.](0[1-9]|1[0-2])[\/\-\.]\d{4}\b|\b\d{4}[\/\-\.](0[1-9]|1[0-2])[\/\-\.](0[1-9]|[12][0-9]|3[01])\b|\b(0[1-9]|[12][0-9]|3[01])\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\b/i,
    time: /\b([01]?[0-9]|2[0-3]):[0-5][0-9](?::[0-5][0-9])?\b|\b(0?[1-9]|1[0-2]):[0-5][0-9]\s?(AM|PM|am|pm)\b/i,
    dateTime: /\b\d{4}-\d{2}-\d{2}\s+([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\b|\b\d{4}-\d{2}-\d{2}T([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](Z|[\+\-]\d{2}:\d{2})?\b/
  };

  // Извлечение всех дат из текста
  static extractDates(text) {
    const dateRegex = this.patterns.date;
    const matches = [...text.matchAll(dateRegex)];
    return matches.map(match => match[0]);
  }

  // Извлечение всех времен из текста
  static extractTimes(text) {
    const timeRegex = this.patterns.time;
    const matches = [...text.matchAll(timeRegex)];
    return matches.map(match => match[0]);
  }

  // Извлечение всех дат и времен из текста
  static extractDateTimes(text) {
    const dateTimeRegex = this.patterns.dateTime;
    const matches = [...text.matchAll(dateTimeRegex)];
    return matches.map(match => match[0]);
  }

  // Извлечение всех дат, времен и дат-времен
  static extractAllDateTime(text) {
    return {
      dates: this.extractDates(text),
      times: this.extractTimes(text),
      dateTimes: this.extractDateTimes(text)
    };
  }

  // Извлечение дат с контекстом (до и после)
  static extractDatesWithContext(text, contextLength = 20) {
    const dateRegex = this.patterns.date;
    const matches = [...text.matchAll(dateRegex)];
    
    return matches.map(match => {
      const start = Math.max(0, match.index - contextLength);
      const end = Math.min(text.length, match.index + match[0].length + contextLength);
      return {
        date: match[0],
        context: text.substring(start, end),
        index: match.index
      };
    });
  }

  // Извлечение событий с датами (например, "встреча 25.12.2023 в 14:30")
  static extractEventsWithDateTime(text) {
    // Паттерн для извлечения событий с датами и временем
    const eventRegex = /([^.!?]*?)\b(0[1-9]|[12][0-9]|3[01])[\/\-\.](0[1-9]|1[0-2])[\/\-\.]\d{4}\b[^.!?]*?(?:\s+в\s+([01]?[0-9]|2[0-3]):([0-5][0-9]))?[^.!?]*[.!?]/gi;
    const matches = [...text.matchAll(eventRegex)];
    
    return matches.map(match => {
      const eventDescription = match[1].trim();
      const day = match[2];
      const month = match[3];
      const year = match[4];
      const hour = match[5];
      const minute = match[6];
      
      const date = `${day}.${month}.${year}`;
      const time = hour && minute ? `${hour}:${minute}` : null;
      
      return {
        description: eventDescription,
        date: date,
        time: time
      };
    });
  }
}

// Примеры использования
const textWithDateTime = `
Встреча запланирована на 25.12.2023 в 14:30. 
Дедлайн проекта - 31/01/2024. 
Событие состоится 15-03-2024 в 09:00:00. 
Следующая встреча - Dec 25, 2023. 
Сервер перезагружен в 23:59:59. 
Совещание в 10:30 AM. 
ISO дата и время: 2023-12-25T14:30:00Z.
`;

console.log('Извлеченные даты:', DateTimeExtractor.extractDates(textWithDateTime));
console.log('Извлеченные времена:', DateTimeExtractor.extractTimes(textWithDateTime));
console.log('Извлеченные даты-времена:', DateTimeExtractor.extractDateTimes(textWithDateTime));
console.log('Все даты/времена:', DateTimeExtractor.extractAllDateTime(textWithDateTime));

console.log('События с датами:');
const events = DateTimeExtractor.extractEventsWithDateTime(textWithDateTime);
events.forEach(event => {
  console.log(`- ${event.description} (${event.date}${event.time ? ` ${event.time}` : ''})`);
});
```

## Работа с часовыми поясами

```javascript
class TimeZoneProcessor {
  // Паттерны для извлечения информации о часовом поясе
  static tzPatterns = {
    // Форматы часовых поясов
    offset: /[+-]\d{2}:?\d{2}|[+-]\d{4}|[+-]\d{2}/,
    name: /\b(?:GMT|UTC|EST|PST|CST|MST|JST|CET|EET|MSK|IST|CST|JST|KST|AEST|PST|EST|CET|EET|MSK|PST|EST5EDT|CST6CDT|EET|MSK|MST|PST8PDT)\b/i,
    full: /(?:GMT|UTC)?[+-]\d{2}:?\d{2}|(?:GMT|UTC)?[+-]\d{4}|[A-Z]{3,4}(?:[+-]\d{2}:?\d{2})?/
  };

  // Извлечение часового пояса из строки даты-времени
  static extractTimeZone(dateTimeString) {
    const tzRegex = this.tzPatterns.full;
    const match = dateTimeString.match(tzRegex);
    return match ? match[0] : null;
  }

  // Проверка формата с часовым поясом
  static validateWithTimeZone(dateTimeString) {
    // ISO формат с часовым поясом
    const isoWithTz = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:?\d{2})$/;
    return isoWithTz.test(dateTimeString);
  }

  // Преобразование времени между часовыми поясами
  static convertTimeZone(dateTimeString, fromTz, toTz) {
    // В реальных приложениях для этого используются специализированные библиотеки
    // такие как date-fns-tz или moment-timezone
    console.warn('Для точной работы с часовыми поясами рекомендуется использовать специализированные библиотеки');
    return dateTimeString;
  }

  // Извлечение информации о часовом поясе из текста
  static extractTimeZonesFromText(text) {
    const tzRegex = this.tzPatterns.full;
    const matches = [...text.matchAll(tzRegex)];
    return [...new Set(matches.map(match => match[0]))]; // Уникальные значения
  }
}

// Пример использования
const tzExamples = [
  '2023-12-25T14:30:00Z',
  '2023-12-25T14:30:00+03:00',
  '2023-12-25T14:30:00-0500',
  '2023-12-25T14:30:00+05'
];

tzExamples.forEach(dateTime => {
  const tz = TimeZoneProcessor.extractTimeZone(dateTime);
  const valid = TimeZoneProcessor.validateWithTimeZone(dateTime);
  console.log(`${dateTime}: часовой пояс=${tz}, валидный=${valid}`);
});
```

## Практические примеры для веб-приложений

### Обработка пользовательского ввода дат

```javascript
class UserDateTimeInputProcessor {
  // Валидация и нормализация пользовательского ввода даты
  static processDateInput(input, expectedFormat = 'YYYY-MM-DD') {
    // Удаляем лишние пробелы
    const cleanInput = input.trim();
    
    // Пробуем определить формат
    const detectedFormat = DateValidator.detectFormat(cleanInput);
    
    if (detectedFormat) {
      // Если формат определен, проверяем его валидность
      const validation = DateValidator.validate(cleanInput, detectedFormat);
      
      if (validation.isValid) {
        // Если валидно, конвертируем в ожидаемый формат
        if (detectedFormat === expectedFormat) {
          return { isValid: true, normalized: cleanInput, original: input, format: detectedFormat };
        } else {
          // Здесь должна быть реализация конвертации форматов
          return { isValid: true, normalized: cleanInput, original: input, format: detectedFormat };
        }
      }
    }
    
    // Если формат не определен или невалиден, пытаемся обработать как можно
    return { isValid: false, normalized: null, original: input, errors: ['Некорректный формат даты'] };
  }

  // Обработка пользовательского ввода даты и времени
  static processDateTimeInput(input) {
    // Пробуем разные форматы
    const formats = [
      'YYYY-MM-DD HH:MM:SS',
      'YYYY-MM-DDTHH:MM:SS',
      'DD/MM/YYYY HH:MM',
      'MM/DD/YYYY HH:MM:SS',
      'YYYY-MM-DD HH:MM'
    ];
    
    for (const format of formats) {
      if (DateTimeValidator.validate(input, format).isValid) {
        return { 
          isValid: true, 
          normalized: input, 
          original: input, 
          format: format,
          timestamp: Date.parse(input) // Преобразуем в timestamp для дальнейшей обработки
        };
      }
    }
    
    return { 
      isValid: false, 
      normalized: null, 
      original: input, 
      errors: ['Не удалось распознать формат даты и времени'] 
    };
  }

  // Форматирование даты для отображения пользователю
  static formatForDisplay(dateString, locale = 'ru-RU', options = {}) {
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) {
        throw new Error('Некорректная дата');
      }
      
      const defaultOptions = { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      
      return date.toLocaleString(locale, { ...defaultOptions, ...options });
    } catch (e) {
      return dateString; // Возвращаем оригинальную строку, если не удалось отформатировать
    }
  }
  
  // Создание удобных для пользователя форматов
  static createFriendlyFormat(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (isNaN(date.getTime())) {
      return dateString;
    }
    
    if (diffDays === 0) {
      // Сегодня
      return `Сегодня в ${date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (diffDays === 1) {
      // Вчера
      return `Вчера в ${date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (diffDays < 7) {
      // На этой неделе
      return date.toLocaleDateString('ru-RU', { 
        weekday: 'long', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    } else {
      // Обычный формат
      return date.toLocaleDateString('ru-RU', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  }
}

// Примеры использования
const userInputDates = [
  '25/12/2023',
  '2023-12-25',
  '25.12.2023 14:30:00',
  'invalid-date'
];

userInputDates.forEach(input => {
  const processed = UserDateTimeInputProcessor.processDateInput(input);
  console.log(`${input}: ${processed.isValid ? '✓' : '✗'} -> ${processed.normalized || processed.errors?.[0]}`);
});

// Пример форматирования для отображения
const exampleDate = '2023-12-25T14:30:00';
console.log('Для отображения:', UserDateTimeInputProcessor.formatForDisplay(exampleDate));
console.log('Удобный формат:', UserDateTimeInputProcessor.createFriendlyFormat(exampleDate));
```

## Оптимизация производительности

### Кэширование регулярных выражений для работы с датами

```javascript
class OptimizedDateTimeProcessor {
  constructor() {
    this.regexCache = new Map();
  }
  
  getRegex(pattern, flags = '') {
    const key = `${pattern}_${flags}`;
    if (!this.regexCache.has(key)) {
      this.regexCache.set(key, new RegExp(pattern, flags));
    }
    return this.regexCache.get(key);
  }
  
  // Оптимизированная проверка даты
  validateDate(dateString, format = 'YYYY-MM-DD') {
    const patterns = {
      'YYYY-MM-DD': '^\\d{4}-\\d{2}-\\d{2}$',
      'DD/MM/YYYY': '^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[0-2])/\\d{4}$',
      'MM/DD/YYYY': '^(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/\\d{4}$',
      'DD-MM-YYYY': '^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-\\d{4}$'
    };
    
    const pattern = patterns[format];
    if (!pattern) {
      return false;
    }
    
    const regex = this.getRegex(pattern);
    return regex.test(dateString);
  }
  
  // Оптимизированное извлечение дат из текста
  extractDatesFromText(text) {
    // Используем более общий паттерн для поиска потенциальных дат
    const generalDateRegex = this.getRegex('\\b\\d{1,4}[-/.]\\d{1,2}[-/.]\\d{2,4}\\b', 'g');
    const potentialDates = text.match(generalDateRegex) || [];
    
    // Затем проверяем каждую потенциальную дату более строго
    const validDates = [];
    for (const date of potentialDates) {
      if (this.validateDate(date, this.detectDateFormat(date))) {
        validDates.push(date);
      }
    }
    
    return validDates;
  }
  
  // Определение формата даты (упрощенное)
  detectDateFormat(dateString) {
    if (this.getRegex('^\\d{4}-\\d{2}-\\d{2}$').test(dateString)) return 'YYYY-MM-DD';
    if (this.getRegex('^\\d{2}/\\d{2}/\\d{4}$').test(dateString)) return 'DD/MM/YYYY';
    if (this.getRegex('^\\d{2}-\\d{2}-\\d{4}$').test(dateString)) return 'DD-MM-YYYY';
    if (this.getRegex('^\\d{4}/\\d{2}/\\d{2}$').test(dateString)) return 'YYYY/MM/DD';
    return null;
  }
}

// Пример использования оптимизированного процессора
const optimizedProcessor = new OptimizedDateTimeProcessor();
console.log('Оптимизированная проверка:', optimizedProcessor.validateDate('2023-12-25'));

const textWithDates = 'Встречи: 2023-12-25, 25/12/2023, 25-12-2023 и 12/25/2023';
console.log('Извлеченные даты:', optimizedProcessor.extractDatesFromText(textWithDates));
```

## Заключение

Работа с форматами дат и времени с помощью регулярных выражений требует особого внимания к:

1. Различным международным форматам дат
2. Валидации корректности дат (например, 30 февраля не существует)
3. Учету часовых поясов и летнего времени
4. Производительности при обработке больших объемов данных
5. Локализации и культурных различиях в форматах

Для сложных операций с датами и временем рекомендуется использовать специализированные библиотеки, такие как date-fns, Moment.js или Temporal (будущая спецификация JavaScript), но регулярные выражения остаются полезными для первичной валидации и извлечения данных.

## Следующие шаги

После изучения работы с форматами дат и времени рекомендуется:

- [[Валидация данных с помощью регулярных выражений]]
- [[Извлечение данных из текста]]
- [[Поиск и замена в строках]]