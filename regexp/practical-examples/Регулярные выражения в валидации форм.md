---
aliases: ["Валидация форм с регулярными выражениями", "Regex Form Validation"]
tags: [regexp, validation, forms, react, vue]
---

# Регулярные выражения в валидации форм

## Общие принципы валидации форм

Регулярные выражения играют ключевую роль в клиентской валидации форм. Они позволяют проверять формат данных до отправки на сервер, улучшая UX и снижая нагрузку на сервер.

## Валидация в React компонентах

### Базовая валидация формы регистрации

```jsx
import React, { useState } from 'react';

const RegistrationForm = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    phone: ''
  });
  
  const [errors, setErrors] = useState({});
  
  // Регулярные выражения для валидации
  const validators = {
    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
    phone: /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/
  };

  const validateField = (name, value) => {
    switch (name) {
      case 'email':
        return validators.email.test(value) ? '' : 'Некорректный email';
      case 'password':
        if (value.length < 8) return 'Пароль должен быть не менее 8 символов';
        if (!validators.password.test(value)) {
          return 'Пароль должен содержать заглавную, строчную буквы, цифру и специальный символ';
        }
        return '';
      case 'phone':
        return validators.phone.test(value) ? '' : 'Некорректный номер телефона';
      default:
        return '';
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Валидация в реальном времени
    const error = validateField(name, value);
    setErrors(prev => ({
      ...prev,
      [name]: error
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Валидация всех полей перед отправкой
    const newErrors = {};
    Object.keys(formData).forEach(field => {
      const error = validateField(field, formData[field]);
      if (error) newErrors[field] = error;
    });
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Форма валидна, отправляем:', formData);
      // Отправка данных
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          className={errors.email ? 'error' : ''}
        />
        {errors.email && <span className="error-message">{errors.email}</span>}
      </div>
      
      <div>
        <label>Пароль:</label>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          className={errors.password ? 'error' : ''}
        />
        {errors.password && <span className="error-message">{errors.password}</span>}
      </div>
      
      <div>
        <label>Телефон:</label>
        <input
          type="tel"
          name="phone"
          value={formData.phone}
          onChange={handleChange}
          className={errors.phone ? 'error' : ''}
        />
        {errors.phone && <span className="error-message">{errors.phone}</span>}
      </div>
      
      <button type="submit" disabled={Object.keys(errors).some(field => errors[field])}>
        Зарегистрироваться
      </button>
    </form>
  );
};

export default RegistrationForm;
```

### Кастомный хук для валидации

```jsx
import { useState, useCallback } from 'react';

// Регулярные выражения для общего использования
const REGEX_PATTERNS = {
  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
  phone: /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/,
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
  url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
  zipCode: /^\d{5}(-\d{4})?$/,
  creditCard: /^\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}$/
};

export const useValidation = (validationRules) => {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const validate = useCallback((name, value) => {
    const rules = validationRules[name];
    if (!rules) return '';

    for (const rule of rules) {
      if (rule.test && !rule.test.test(value)) {
        return rule.message;
      }
      
      if (rule.validate && !rule.validate(value)) {
        return rule.message;
      }
      
      if (rule.required && !value) {
        return rule.message || 'Это поле обязательно';
      }
      
      if (rule.minLength && value.length < rule.minLength) {
        return `Минимум ${rule.minLength} символов`;
      }
      
      if (rule.maxLength && value.length > rule.maxLength) {
        return `Максимум ${rule.maxLength} символов`;
      }
    }
    
    return '';
  }, [validationRules]);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Валидация при изменении
    const error = validate(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  }, [validate]);

  const handleBlur = useCallback((e) => {
    const { name, value } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    
    const error = validate(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  }, [validate]);

  const reset = useCallback(() => {
    setValues({});
    setErrors({});
    setTouched({});
  }, []);

  const isValid = Object.keys(errors).every(key => !errors[key]);

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    reset,
    isValid
  };
};

// Использование хука
const ContactForm = () => {
  const validationRules = {
    name: [
      { required: true, message: 'Имя обязательно' },
      { minLength: 2, message: 'Имя должно быть не менее 2 символов' }
    ],
    email: [
      { required: true, message: 'Email обязателен' },
      { test: REGEX_PATTERNS.email, message: 'Некорректный email' }
    ],
    message: [
      { required: true, message: 'Сообщение обязательно' },
      { minLength: 10, message: 'Сообщение должно быть не менее 10 символов' }
    ]
  };

  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    reset
  } = useValidation(validationRules);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (Object.keys(errors).every(key => !errors[key])) {
      console.log('Форма валидна:', values);
      reset();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="name"
          placeholder="Имя"
          value={values.name || ''}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.name && errors.name ? 'error' : ''}
        />
        {touched.name && errors.name && (
          <div className="error-message">{errors.name}</div>
        )}
      </div>
      
      <div>
        <input
          type="email"
          name="email"
          placeholder="Email"
          value={values.email || ''}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.email && errors.email ? 'error' : ''}
        />
        {touched.email && errors.email && (
          <div className="error-message">{errors.email}</div>
        )}
      </div>
      
      <div>
        <textarea
          name="message"
          placeholder="Сообщение"
          value={values.message || ''}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.message && errors.message ? 'error' : ''}
        />
        {touched.message && errors.message && (
          <div className="error-message">{errors.message}</div>
        )}
      </div>
      
      <button type="submit" disabled={!Object.keys(errors).every(key => !errors[key])}>
        Отправить
      </button>
    </form>
  );
};
```

## Валидация в Vue компонентах

### Использование Composition API

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div class="form-group">
      <label for="email">Email:</label>
      <input
        id="email"
        v-model="formData.email"
        type="email"
        :class="{ error: errors.email }"
        @blur="validateField('email')"
      />
      <div v-if="errors.email" class="error-message">
        {{ errors.email }}
      </div>
    </div>
    
    <div class="form-group">
      <label for="password">Пароль:</label>
      <input
        id="password"
        v-model="formData.password"
        type="password"
        :class="{ error: errors.password }"
        @input="validateField('password')"
        @blur="validateField('password')"
      />
      <div v-if="errors.password" class="error-message">
        {{ errors.password }}
      </div>
    </div>
    
    <div class="form-group">
      <label for="phone">Телефон:</label>
      <input
        id="phone"
        v-model="formData.phone"
        type="tel"
        :class="{ error: errors.phone }"
        @blur="validateField('phone')"
      />
      <div v-if="errors.phone" class="error-message">
        {{ errors.phone }}
      </div>
    </div>
    
    <button type="submit" :disabled="!isFormValid">
      Отправить
    </button>
  </form>
</template>

<script>
import { ref, computed } from 'vue';

// Регулярные выражения
const EMAIL_REGEX = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
const PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
const PHONE_REGEX = /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/;

export default {
  name: 'RegistrationForm',
  setup() {
    const formData = ref({
      email: '',
      password: '',
      phone: ''
    });
    
    const errors = ref({
      email: '',
      password: '',
      phone: ''
    });
    
    const validateField = (fieldName) => {
      const value = formData.value[fieldName];
      
      switch (fieldName) {
        case 'email':
          errors.value.email = EMAIL_REGEX.test(value) 
            ? '' 
            : 'Некорректный email адрес';
          break;
          
        case 'password':
          if (value.length < 8) {
            errors.value.password = 'Пароль должен быть не менее 8 символов';
          } else if (!PASSWORD_REGEX.test(value)) {
            errors.value.password = 'Пароль должен содержать заглавную, строчную буквы, цифру и специальный символ';
          } else {
            errors.value.password = '';
          }
          break;
          
        case 'phone':
          errors.value.phone = PHONE_REGEX.test(value)
            ? ''
            : 'Некорректный номер телефона';
          break;
          
        default:
          break;
      }
    };
    
    const isFormValid = computed(() => {
      return !Object.values(errors.value).some(error => error !== '');
    });
    
    const handleSubmit = () => {
      // Проверяем все поля перед отправкой
      Object.keys(formData.value).forEach(field => {
        validateField(field);
      });
      
      if (isFormValid.value) {
        console.log('Форма валидна:', formData.value);
        // Отправка данных
      }
    };
    
    return {
      formData,
      errors,
      validateField,
      isFormValid,
      handleSubmit
    };
  }
};
</script>

<style>
.form-group {
  margin-bottom: 1rem;
}

.error {
  border-color: #ff0000 !important;
}

.error-message {
  color: #ff0000;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}
</style>
```

### Кастомная директива валидации

```javascript
// validationDirective.js
const EMAIL_REGEX = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
const PHONE_REGEX = /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/;

export const validationDirective = {
  mounted(el, binding) {
    const { value: pattern } = binding;
    const input = el.tagName === 'INPUT' ? el : el.querySelector('input');
    
    if (!input) return;
    
    const validate = () => {
      const isValid = pattern.test(input.value);
      input.classList.toggle('invalid', !isValid);
      input.classList.toggle('valid', isValid);
      
      // Вызов колбэка при изменении валидности
      if (binding.instance && binding.arg) {
        binding.instance[binding.arg](isValid);
      }
    };
    
    input.addEventListener('input', validate);
    input.addEventListener('blur', validate);
    
    // Сохраняем обработчики для очистки
    el._validationHandlers = { validate };
  },
  unmounted(el) {
    const input = el.tagName === 'INPUT' ? el : el.querySelector('input');
    if (input && el._validationHandlers) {
      input.removeEventListener('input', el._validationHandlers.validate);
      input.removeEventListener('blur', el._validationHandlers.validate);
    }
  }
};

// Использование в компоненте
export default {
  directives: {
    validate: validationDirective
  },
  data() {
    return {
      email: '',
      isEmailValid: false
    };
  },
  methods: {
    onEmailValidation(isValid) {
      this.isEmailValid = isValid;
    }
  },
  template: `
    <div>
      <input 
        v-model="email" 
        v-validate:[onEmailValidation]="EMAIL_REGEX" 
        type="email" 
        placeholder="Email"
      />
      <span v-if="isEmailValid" style="color: green;">✓ Валидно</span>
      <span v-else style="color: red;">✗ Невалидно</span>
    </div>
  `
};
```

## Продвинутая валидация с использованием библиотек

### Валидация с Yup и Formik (React)

```jsx
import React from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// Регулярные выражения для схемы валидации
const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
const phoneRegex = /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/;
const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

const validationSchema = Yup.object({
  email: Yup.string()
    .matches(emailRegex, 'Некорректный email')
    .required('Email обязателен'),
  password: Yup.string()
    .matches(passwordRegex, 'Пароль должен содержать заглавную, строчную буквы, цифру и специальный символ')
    .min(8, 'Пароль должен быть не менее 8 символов')
    .required('Пароль обязателен'),
  phone: Yup.string()
    .matches(phoneRegex, 'Некорректный номер телефона')
    .required('Телефон обязателен')
});

const FormWithYup = () => {
  const initialValues = {
    email: '',
    password: '',
    phone: ''
  };

  const onSubmit = (values, { setSubmitting }) => {
    setTimeout(() => {
      console.log('Форма отправлена:', values);
      setSubmitting(false);
    }, 1000);
  };

  return (
    <Formik
      initialValues={initialValues}
      validationSchema={validationSchema}
      onSubmit={onSubmit}
    >
      {({ isSubmitting }) => (
        <Form>
          <div>
            <Field type="email" name="email" placeholder="Email" />
            <ErrorMessage name="email" component="div" className="error-message" />
          </div>
          
          <div>
            <Field type="password" name="password" placeholder="Пароль" />
            <ErrorMessage name="password" component="div" className="error-message" />
          </div>
          
          <div>
            <Field type="tel" name="phone" placeholder="Телефон" />
            <ErrorMessage name="phone" component="div" className="error-message" />
          </div>
          
          <button type="submit" disabled={isSubmitting}>
            Отправить
          </button>
        </Form>
      )}
    </Formik>
  );
};

export default FormWithYup;
```

## Практические рекомендации

### 1. Комбинирование клиентской и серверной валидации

```javascript
// Клиентская валидация
const clientValidation = {
  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/
};

// Серверная валидация (Node.js пример)
const serverValidation = {
  email: async (email) => {
    // Дополнительная проверка существования домена, битых аккаунтов и т.д.
    const domain = email.split('@')[1];
    // Проверка существования MX записи домена
    return await checkDomainExists(domain);
  }
};
```

### 2. Обработка ошибок и UX

```javascript
// Показ ошибок с задержкой для улучшения UX
const useDelayedValidation = (delay = 500) => {
  const [errorTimeout, setErrorTimeout] = useState(null);
  
  const validateWithDelay = useCallback((validationFn) => {
    if (errorTimeout) {
      clearTimeout(errorTimeout);
    }
    
    const newTimeout = setTimeout(() => {
      validationFn();
    }, delay);
    
    setErrorTimeout(newTimeout);
  }, [delay, errorTimeout]);
  
  return validateWithDelay;
};
```

### 3. Мемоизация регулярных выражений

```javascript
// Использование useMemo для оптимизации производительности
import { useMemo } from 'react';

const useFormValidation = () => {
  const regexPatterns = useMemo(() => ({
    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    phone: /^(\+7|7|8)?[\s\-]?\(?[0-9]{3}\)?[\s\-]?[0-9]{3}[\s\-]?[0-9]{2}[\s\-]?[0-9]{2}$/,
    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/
  }), []); // Паттерны создаются только один раз
  
  return regexPatterns;
};
```

## Заключение

Регулярные выражения в валидации форм обеспечивают гибкость и контроль над форматом пользовательских данных. При правильном использовании они значительно улучшают UX за счет мгновенной обратной связи и снижают нагрузку на сервер за счет ранней фильтрации некорректных данных.

Ключевые моменты:
- Всегда комбинируйте клиентскую валидацию с серверной
- Используйте мемоизацию для сложных регулярных выражений
- Обеспечьте хорошую UX при валидации в реальном времени
- Предоставляйте понятные сообщения об ошибках
- Рассмотрите использование специализированных библиотек для сложных форм