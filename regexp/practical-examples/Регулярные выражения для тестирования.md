---
aliases: ["Регулярные выражения в тестировании", "Regex in Testing"]
tags: [regexp, testing, unit-tests, e2e, validation]
---

# Регулярные выражения для тестирования (unit и e2e тесты)

## Общие принципы использования регулярных выражений в тестировании

Регулярные выражения играют важную роль в тестировании программного обеспечения, особенно при проверке форматов данных, валидации пользовательского ввода и анализе логов. Они позволяют точно проверять соответствия паттернам, что особенно полезно при unit-тестировании и end-to-end тестировании.

## Unit тестирование с регулярными выражениями

### 1. Тестирование валидации форм

```javascript
// userValidator.js
const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
const phoneRegex = /^\+?[1-9]\d{1,14}$/;
const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;

export const validateUser = (userData) => {
  const errors = {};
  
  if (!userData.email || !emailRegex.test(userData.email)) {
    errors.email = 'Invalid email format';
  }
  
  if (!userData.phone || !phoneRegex.test(userData.phone)) {
    errors.phone = 'Invalid phone format';
  }
  
  if (!userData.password || !passwordRegex.test(userData.password)) {
    errors.password = 'Invalid password format';
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

// __tests__/userValidator.test.js
import { validateUser } from '../userValidator';

describe('User validation', () => {
  test('should validate correct email', () => {
    const result = validateUser({ email: 'test@example.com' });
    expect(result.errors.email).toBeUndefined();
  });

  test('should reject invalid email', () => {
    const result = validateUser({ email: 'invalid-email' });
    expect(result.errors.email).toBe('Invalid email format');
  });

  test('should validate correct phone number', () => {
    const result = validateUser({ phone: '+1-555-123-4567' });
    expect(result.errors.phone).toBeUndefined();
  });

  test('should reject invalid phone number', () => {
    const result = validateUser({ phone: 'invalid-phone' });
    expect(result.errors.phone).toBe('Invalid phone format');
  });

  test('should validate complex password', () => {
    const result = validateUser({ password: 'Password123!' });
    expect(result.errors.password).toBeUndefined();
  });

  test('should reject simple password', () => {
    const result = validateUser({ password: 'simple' });
    expect(result.errors.password).toBe('Invalid password format');
  });

  test('should validate all fields correctly', () => {
    const result = validateUser({
      email: 'test@example.com',
      phone: '+1-555-123-4567',
      password: 'ComplexPass123!'
    });
    
    expect(result.isValid).toBe(true);
    expect(result.errors).toEqual({});
  });
});
```

### 2. Тестирование обработки строк

```javascript
// textProcessor.js
export const sanitizeInput = (input) => {
  // Удаление HTML тегов
  const htmlTagRegex = /<[^>]*>/g;
  let sanitized = input.replace(htmlTagRegex, '');
  
  // Удаление потенциально опасных символов
  const dangerousCharsRegex = /[<>'"&]/g;
  sanitized = sanitized.replace(dangerousCharsRegex, (match) => {
    const escapeMap = {
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '&': '&amp;'
    };
    return escapeMap[match];
  });
  
  return sanitized;
};

export const extractEmails = (text) => {
  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
  return text.match(emailRegex) || [];
};

export const formatPhone = (phone) => {
  // Удаляем все нецифровые символы
  const digitsOnly = phone.replace(/\D/g, '');
  
  // Применяем форматирование
  if (digitsOnly.length === 10) {
    return digitsOnly.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
  }
  
  return phone; // Возвращаем оригинальный, если не соответствует формату
};

// __tests__/textProcessor.test.js
import { sanitizeInput, extractEmails, formatPhone } from '../textProcessor';

describe('Text processing functions', () => {
  describe('sanitizeInput', () => {
    test('should remove HTML tags', () => {
      const input = '<script>alert("xss")</script>Hello <b>world</b>';
      const expected = '&lt;script&gt;alert(&quot;xss&quot;)&lt;&#x27;/script&gt;Hello &lt;b&gt;world&lt;&#x27;/b&gt;';
      expect(sanitizeInput(input)).toBe(expected);
    });

    test('should escape dangerous characters', () => {
      const input = 'Hello "world" & \'test\' <script>';
      const expected = 'Hello &quot;world&quot; &amp; &#x27;test&#x27; &lt;script&gt;';
      expect(sanitizeInput(input)).toBe(expected);
    });
  });

  describe('extractEmails', () => {
    test('should extract all emails from text', () => {
      const text = 'Contact us at info@example.com or support@test.org for more info.';
      const emails = extractEmails(text);
      expect(emails).toEqual(['info@example.com', 'support@test.org']);
    });

    test('should return empty array when no emails found', () => {
      const text = 'No emails here';
      const emails = extractEmails(text);
      expect(emails).toEqual([]);
    });

    test('should handle multiple formats', () => {
      const text = 'Emails: user.name+tag@example.co.uk, test123@domain.info';
      const emails = extractEmails(text);
      expect(emails).toEqual(['user.name+tag@example.co.uk', 'test123@domain.info']);
    });
  });

  describe('formatPhone', () => {
    test('should format 10-digit phone number', () => {
      expect(formatPhone('1234567890')).toBe('(123) 456-7890');
    });

    test('should format phone with separators', () => {
      expect(formatPhone('123-456-7890')).toBe('(123) 456-7890');
    });

    test('should return original if not 10 digits', () => {
      expect(formatPhone('123')).toBe('123');
      expect(formatPhone('12345678901')).toBe('12345678901');
    });
  });
});
```

### 3. Тестирование логов и сообщений

```javascript
// logAnalyzer.js
export const analyzeLogs = (logText) => {
  const errorRegex = /ERROR:\s*(.+)/g;
  const warningRegex = /WARNING:\s*(.+)/g;
  const timestampRegex = /\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/g;
  const ipRegex = /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b/g;
  
  const errors = [];
  let match;
  
  while ((match = errorRegex.exec(logText)) !== null) {
    errors.push(match[1]);
  }
  
  const warnings = [];
  while ((match = warningRegex.exec(logText)) !== null) {
    warnings.push(match[1]);
  }
  
  const timestamps = logText.match(timestampRegex) || [];
  const ips = logText.match(ipRegex) || [];
  
  return {
    errors,
    warnings,
    timestamps: timestamps.length,
    ips: [...new Set(ips)] // Уникальные IP-адреса
  };
};

// __tests__/logAnalyzer.test.js
import { analyzeLogs } from '../logAnalyzer';

describe('Log analysis', () => {
  test('should extract errors from log', () => {
    const log = `
      2023-01-01 10:00:00 INFO: Application started
      2023-01-01 10:01:00 ERROR: Database connection failed
      2023-01-01 10:02:00 WARNING: High memory usage
      2023-01-01 10:03:00 ERROR: User authentication failed
    `;
    
    const result = analyzeLogs(log);
    expect(result.errors).toEqual([
      'Database connection failed',
      'User authentication failed'
    ]);
  });

  test('should extract warnings from log', () => {
    const log = `
      2023-01-01 10:00:00 INFO: Application started
      2023-01-01 10:01:00 WARNING: Deprecated function used
      2023-01-01 10:02:00 WARNING: Slow query detected
    `;
    
    const result = analyzeLogs(log);
    expect(result.warnings).toEqual([
      'Deprecated function used',
      'Slow query detected'
    ]);
  });

  test('should extract IP addresses', () => {
    const log = `
      2023-01-01 10:00:00 INFO: Request from 192.168.1.1
      2023-01-01 10:01:00 INFO: Request from 10.0.0.1
      2023-01-01 10:02:00 INFO: Request from 192.168.1.1  // Повтор
    `;
    
    const result = analyzeLogs(log);
    expect(result.ips).toEqual(['192.168.1.1', '10.0.0.1']);
  });
});
```

## E2E тестирование с регулярными выражениями

### 1. Использование в тестах Cypress

```javascript
// cypress/e2e/form-validation.cy.js
describe('Form validation tests', () => {
  beforeEach(() => {
    cy.visit('/registration');
  });

  it('should show validation error for invalid email', () => {
    cy.get('[data-cy="email-input"]').type('invalid-email');
    cy.get('[data-cy="submit-button"]').click();
    
    // Проверка сообщения об ошибке с использованием регулярного выражения
    cy.get('[data-cy="error-message"]')
      .should('be.visible')
      .and('have.text', 'Invalid email format');
  });

  it('should accept valid email format', () => {
    cy.get('[data-cy="email-input"]').type('test@example.com');
    cy.get('[data-cy="email-input"]').should('have.value', 'test@example.com');
    
    // Проверка, что сообщение об ошибке не отображается
    cy.get('[data-cy="error-message"]').should('not.be.visible');
  });

  it('should validate phone number format', () => {
    cy.get('[data-cy="phone-input"]').type('+1-555-123-4567');
    
    // Проверка формата телефона с помощью регулярного выражения
    cy.get('[data-cy="phone-input"]')
      .invoke('val')
      .then((value) => {
        const phoneRegex = /^\+?[1-9]\d{1,14}$/;
        expect(phoneRegex.test(value)).to.be.true;
      });
  });

  it('should validate password complexity', () => {
    const complexPassword = 'ComplexPass123!';
    
    cy.get('[data-cy="password-input"]').type(complexPassword);
    
    // Проверка сложности пароля с помощью регулярного выражения
    cy.get('[data-cy="password-input"]')
      .invoke('val')
      .then((value) => {
        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
        expect(passwordRegex.test(value)).to.be.true;
      });
  });

  it('should extract data from API response', () => {
    cy.intercept('POST', '/api/register').as('register');
    
    cy.get('[data-cy="email-input"]').type('test@example.com');
    cy.get('[data-cy="submit-button"]').click();
    
    cy.wait('@register').then((interception) => {
      const response = interception.response.body;
      
      // Проверка формата ID с помощью регулярного выражения
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      expect(uuidRegex.test(response.userId)).to.be.true;
      
      // Проверка формата созданного email
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      expect(emailRegex.test(response.email)).to.be.true;
    });
  });
});
```

### 2. Использование в тестах Playwright

```javascript
// tests/registration.spec.js
import { test, expect } from '@playwright/test';

test.describe('Registration form validation', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/registration');
  });

  test('should show validation error for invalid email', async ({ page }) => {
    await page.locator('[data-testid="email-input"]').fill('invalid-email');
    await page.locator('[data-testid="submit-button"]').click();
    
    // Ожидание сообщения об ошибке
    const errorElement = page.locator('[data-testid="error-message"]');
    await expect(errorElement).toBeVisible();
    
    // Проверка текста сообщения об ошибке
    await expect(errorElement).toContainText('Invalid email format');
  });

  test('should validate email format correctly', async ({ page }) => {
    const validEmails = [
      'user@example.com',
      'user.name+tag@example.co.uk',
      'user123@test-domain.org'
    ];
    
    for (const email of validEmails) {
      await page.locator('[data-testid="email-input"]').fill(email);
      
      // Проверка, что ошибки нет
      await expect(page.locator('[data-testid="error-message"]')).not.toBeVisible();
    }
  });

  test('should extract and validate UUID from response', async ({ page, request }) => {
    // Подготовка данных для регистрации
    const userData = {
      email: 'test@example.com',
      password: 'ComplexPass123!'
    };
    
    // Отправка запроса
    const response = await request.post('/api/register', {
      data: userData
    });
    
    const responseBody = await response.json();
    
    // Проверка формата UUID с помощью регулярного выражения
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    expect(uuidRegex.test(responseBody.userId)).toBeTruthy();
  });

  test('should validate URL format in profile page', async ({ page }) => {
    // Предполагаем, что пользователь уже зарегистрирован
    await page.goto('/profile');
    
    // Проверка URL сайта в профиле
    const websiteUrl = await page.locator('[data-testid="website"]').textContent();
    
    // Регулярное выражение для проверки URL
    const urlRegex = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
    expect(urlRegex.test(websiteUrl)).toBeTruthy();
  });
});
```

### 3. Использование в тестах Selenium (Node.js)

```javascript
// tests/formValidation.test.js
const { Builder, By, until } = require('selenium-webdriver');
const chrome = require('selenium-webdriver/chrome');

describe('Form validation with Selenium', function() {
  let driver;

  before(async function() {
    driver = await new Builder().forBrowser('chrome').build();
  });

  after(async function() {
    await driver.quit();
  });

  it('should validate email format', async function() {
    await driver.get('http://localhost:3000/registration');
    
    const emailInput = await driver.findElement(By.css('[data-cy="email-input"]'));
    await emailInput.sendKeys('invalid-email');
    
    const submitButton = await driver.findElement(By.css('[data-cy="submit-button"]'));
    await submitButton.click();
    
    // Ожидание сообщения об ошибке
    const errorMessage = await driver.wait(
      until.elementLocated(By.css('[data-cy="error-message"]')),
      5000
    );
    
    const errorText = await errorMessage.getText();
    expect(errorText).toBe('Invalid email format');
  });

  it('should validate phone number format', async function() {
    await driver.get('http://localhost:3000/registration');
    
    const phoneInput = await driver.findElement(By.css('[data-cy="phone-input"]'));
    await phoneInput.sendKeys('+1-555-123-4567');
    
    // Получение значения из поля ввода
    const enteredValue = await phoneInput.getAttribute('value');
    
    // Проверка формата с помощью регулярного выражения
    const phoneRegex = /^\+?[1-9]\d{1,14}$/;
    expect(phoneRegex.test(enteredValue)).toBe(true);
  });

  it('should extract and validate timestamp from log', async function() {
    // Предполагаем, что у нас есть доступ к логам приложения
    await driver.get('http://localhost:3000/admin/logs');
    
    const logElement = await driver.findElement(By.css('[data-cy="log-content"]'));
    const logText = await logElement.getText();
    
    // Извлечение временных меток с помощью регулярного выражения
    const timestampRegex = /\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/g;
    const timestamps = logText.match(timestampRegex) || [];
    
    // Проверка, что все найденные временные метки имеют правильный формат
    const isValidFormat = timestamps.every(ts => /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(ts));
    expect(isValidFormat).toBe(true);
  });
});
```

## Тестирование с использованием библиотек

### 1. Тестирование с Jest и регулярными выражениями

```javascript
// utils/dataValidator.js
export const validateData = (data) => {
  const patterns = {
    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    phone: /^\+?[1-9]\d{1,14}$/,
    url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
    uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
    creditCard: /^\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}$/
  };

  const errors = {};

  if (data.email && !patterns.email.test(data.email)) {
    errors.email = 'Invalid email format';
  }

  if (data.phone && !patterns.phone.test(data.phone)) {
    errors.phone = 'Invalid phone format';
  }

  if (data.website && !patterns.url.test(data.website)) {
    errors.website = 'Invalid URL format';
  }

  if (data.id && !patterns.uuid.test(data.id)) {
    errors.id = 'Invalid UUID format';
  }

  if (data.cardNumber && !patterns.creditCard.test(data.cardNumber)) {
    errors.cardNumber = 'Invalid credit card format';
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

// __tests__/dataValidator.test.js
import { validateData } from '../utils/dataValidator';

describe('Data validation with regex patterns', () => {
  describe('Email validation', () => {
    test('validates correct email formats', () => {
      const validEmails = [
        'user@example.com',
        'user.name+tag@example.co.uk',
        'user123@test-domain.org',
        'user@sub.domain.com'
      ];

      validEmails.forEach(email => {
        const result = validateData({ email });
        expect(result.errors.email).toBeUndefined();
        expect(result.isValid).toBe(true);
      });
    });

    test('rejects invalid email formats', () => {
      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'user@',
        'user..name@example.com'
      ];

      invalidEmails.forEach(email => {
        const result = validateData({ email });
        expect(result.errors.email).toBe('Invalid email format');
        expect(result.isValid).toBe(false);
      });
    });
  });

  describe('Phone validation', () => {
    test('validates correct phone formats', () => {
      const validPhones = [
        '+1-555-123-4567',
        '+44 20 7946 0958',
        '1234567890',
        '+1 (555) 123-4567'
      ];

      validPhones.forEach(phone => {
        const result = validateData({ phone });
        expect(result.errors.phone).toBeUndefined();
      });
    });
  });

  describe('URL validation', () => {
    test('validates correct URL formats', () => {
      const validUrls = [
        'https://example.com',
        'http://www.test.org',
        'https://sub.domain.co.uk/path?query=value'
      ];

      validUrls.forEach(url => {
        const result = validateData({ website: url });
        expect(result.errors.website).toBeUndefined();
      });
    });
  });

  describe('UUID validation', () => {
    test('validates correct UUID formats', () => {
      const validUuids = [
        '550e8400-e29b-41d4-a716-446655440000',
        '550E8400-E29B-41D4-A716-446655440000' // uppercase
      ];

      validUuids.forEach(id => {
        const result = validateData({ id });
        expect(result.errors.id).toBeUndefined();
      });
    });

    test('rejects invalid UUID formats', () => {
      const invalidUuids = [
        'invalid-uuid',
        '550e8400-e29b-41d4-a716', // too short
        '550e8400-e29b-41d4-a716-446655440000-extra' // too long
      ];

      invalidUuids.forEach(id => {
        const result = validateData({ id });
        expect(result.errors.id).toBe('Invalid UUID format');
      });
    });
  });
});
```

### 2. Тестирование с регулярными выражениями в React компонентах

```javascript
// __tests__/RegistrationForm.test.js
import React from 'react';
import { render, fireEvent, screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import RegistrationForm from '../components/RegistrationForm';

describe('RegistrationForm component', () => {
  test('shows error for invalid email', async () => {
    render(<RegistrationForm />);
    
    const emailInput = screen.getByLabelText(/email/i);
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } });
    
    // Потеря фокуса для триггера валидации
    fireEvent.blur(emailInput);
    
    await waitFor(() => {
      expect(screen.getByText(/invalid email format/i)).toBeInTheDocument();
    });
  });

  test('accepts valid email', async () => {
    render(<RegistrationForm />);
    
    const emailInput = screen.getByLabelText(/email/i);
    fireEvent.change(emailInput, { target: { value: 'valid@example.com' } });
    
    fireEvent.blur(emailInput);
    
    await waitFor(() => {
      expect(screen.queryByText(/invalid email format/i)).not.toBeInTheDocument();
    });
  });

  test('validates password complexity', async () => {
    render(<RegistrationForm />);
    
    const passwordInput = screen.getByLabelText(/password/i);
    fireEvent.change(passwordInput, { target: { value: 'simple' } });
    
    fireEvent.blur(passwordInput);
    
    await waitFor(() => {
      expect(screen.getByText(/password complexity/i)).toBeInTheDocument();
    });
    
    // Теперь вводим сложный пароль
    fireEvent.change(passwordInput, { target: { value: 'ComplexPass123!' } });
    fireEvent.blur(passwordInput);
    
    await waitFor(() => {
      expect(screen.queryByText(/password complexity/i)).not.toBeInTheDocument();
    });
  });

  test('submits form with valid data', async () => {
    const mockSubmit = jest.fn();
    render(<RegistrationForm onSubmit={mockSubmit} />);
    
    // Заполнение формы валидными данными
    fireEvent.change(screen.getByLabelText(/email/i), { target: { value: 'test@example.com' } });
    fireEvent.change(screen.getByLabelText(/password/i), { target: { value: 'ComplexPass123!' } });
    fireEvent.change(screen.getByLabelText(/phone/i), { target: { value: '+1-555-123-4567' } });
    
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));
    
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'ComplexPass123!',
        phone: '+1-555-123-4567'
      });
    });
  });
});
```

## Практические рекомендации

### 1. Покрытие тестами регулярных выражений

```javascript
// __tests__/regexPatterns.test.js
// Тестируем сами регулярные выражения
const patterns = {
  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
  phone: /^\+?[1-9]\d{1,14}$/,
  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
  url: /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/,
  uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
};

describe('Regex patterns validation', () => {
  test('email pattern should match valid emails', () => {
    const validEmails = [
      'user@example.com',
      'test.email+tag@domain.co.uk',
      'user123@sub.domain.org'
    ];
    
    validEmails.forEach(email => {
      expect(patterns.email.test(email)).toBe(true);
    });
  });

  test('email pattern should not match invalid emails', () => {
    const invalidEmails = [
      'invalid-email',
      '@domain.com',
      'user@',
      'user..name@domain.com'
    ];
    
    invalidEmails.forEach(email => {
      expect(patterns.email.test(email)).toBe(false);
    });
  });

  test('phone pattern should match valid phone numbers', () => {
    const validPhones = [
      '+1234567890',
      '+1-555-123-4567',
      '1234567890'
    ];
    
    validPhones.forEach(phone => {
      expect(patterns.phone.test(phone)).toBe(true);
    });
  });

  test('password pattern should match complex passwords', () => {
    const complexPasswords = [
      'Password123!',
      'MyComplex@Pass42',
      'Test#123456'
    ];
    
    complexPasswords.forEach(password => {
      expect(patterns.password.test(password)).toBe(true);
    });
  });

  test('password pattern should not match simple passwords', () => {
    const simplePasswords = [
      'password',
      'Password',
      '12345678',
      'Pass123'
    ];
    
    simplePasswords.forEach(password => {
      expect(patterns.password.test(password)).toBe(false);
    });
  });
});
```

### 2. Тестирование производительности регулярных выражений

```javascript
// __tests__/regexPerformance.test.js
describe('Regex performance tests', () => {
  test('email validation should be fast', () => {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    const testEmail = 'user@example.com';
    
    const startTime = performance.now();
    for (let i = 0; i < 10000; i++) {
      emailRegex.test(testEmail);
    }
    const endTime = performance.now();
    
    // Должно выполниться за разумное время
    expect(endTime - startTime).toBeLessThan(100); // менее 100ms для 10k итераций
  });

  test('should not be vulnerable to ReDoS attacks', () => {
    const dangerousString = 'a'.repeat(10000) + '!'; // Длинная строка
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    
    const startTime = performance.now();
    const result = emailRegex.test(dangerousString);
    const endTime = performance.now();
    
    // Должно выполниться быстро, даже с длинной строкой
    expect(endTime - startTime).toBeLessThan(50);
    expect(result).toBe(false);
  });
});
```

## Заключение

Регулярные выражения в тестировании обеспечивают мощный инструмент для проверки форматов данных, валидации пользовательского ввода и анализа текстовых данных. Они особенно полезны в unit-тестах для проверки бизнес-логики и в e2e тестах для валидации пользовательских данных и API ответов.

Ключевые моменты:
- Используйте регулярные выражения для проверки форматов данных в тестах
- Тестируйте как позитивные, так и негативные сценарии
- Проверяйте производительность регулярных выражений
- Обеспечьте полное покрытие тестами всех регулярных выражений в коде
- Используйте подходящие инструменты тестирования для разных уровней